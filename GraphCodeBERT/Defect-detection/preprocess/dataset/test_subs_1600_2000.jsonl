{"project": "qemu", "commit_id": "cca1af8c4d2ef6449fd61494ba2cb087b838011c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n\n                            int opc)\n\n{\n\n    int addr_regl, addr_reg1, addr_meml;\n\n    int data_regl, data_regh, data_reg1, data_reg2;\n\n    int mem_index, s_bits;\n\n#if defined(CONFIG_SOFTMMU)\n\n    void *label1_ptr, *label2_ptr;\n\n    int sp_args;\n\n#endif\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(CONFIG_SOFTMMU)\n\n    uint8_t *label3_ptr;\n\n# endif\n\n    int addr_regh, addr_reg2, addr_memh;\n\n#endif\n\n    data_regl = *args++;\n\n    if (opc == 3)\n\n        data_regh = *args++;\n\n    else\n\n        data_regh = 0;\n\n    addr_regl = *args++;\n\n#if TARGET_LONG_BITS == 64\n\n    addr_regh = *args++;\n\n#endif\n\n    mem_index = *args;\n\n    s_bits = opc & 3;\n\n\n\n    if (opc == 3) {\n\n#if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n        data_reg1 = data_regh;\n\n        data_reg2 = data_regl;\n\n#else\n\n        data_reg1 = data_regl;\n\n        data_reg2 = data_regh;\n\n#endif\n\n    } else {\n\n        data_reg1 = data_regl;\n\n        data_reg2 = 0;\n\n    }\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n    addr_reg1 = addr_regh;\n\n    addr_reg2 = addr_regl;\n\n    addr_memh = 0;\n\n    addr_meml = 4;\n\n# else\n\n    addr_reg1 = addr_regl;\n\n    addr_reg2 = addr_regh;\n\n    addr_memh = 4;\n\n    addr_meml = 0;\n\n# endif\n\n#else\n\n    addr_reg1 = addr_regl;\n\n    addr_meml = 0;\n\n#endif\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    tcg_out_opc_sa(s, OPC_SRL, TCG_REG_A0, addr_regl, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_imm(s, OPC_ANDI, TCG_REG_A0, TCG_REG_A0, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_A0, TCG_REG_A0, TCG_AREG0);\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_meml);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T0, TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n    tcg_out_opc_reg(s, OPC_AND, TCG_REG_T0, TCG_REG_T0, addr_regl);\n\n\n\n# if TARGET_LONG_BITS == 64\n\n    label3_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BNE, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_memh);\n\n\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, addr_regh, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    reloc_pc16(label3_ptr, (tcg_target_long) s->code_ptr);\n\n# else\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n# endif\n\n\n\n    /* slow path */\n\n    sp_args = TCG_REG_A0;\n\n    tcg_out_mov(s, sp_args++, addr_reg1);\n\n# if TARGET_LONG_BITS == 64\n\n    tcg_out_mov(s, sp_args++, addr_reg2);\n\n# endif\n\n    tcg_out_movi(s, TCG_TYPE_I32, sp_args++, mem_index);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T9, (tcg_target_long)qemu_ld_helpers[s_bits]);\n\n    tcg_out_opc_reg(s, OPC_JALR, TCG_REG_RA, TCG_REG_T9, 0);\n\n    tcg_out_nop(s);\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xff);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 24);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 24);\n\n        break;\n\n    case 1:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xffff);\n\n        break;\n\n    case 1 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 16);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 16);\n\n        break;\n\n    case 2:\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    case 3:\n\n        tcg_out_mov(s, data_reg2, TCG_REG_V1);\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    label2_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO, 0);\n\n    tcg_out_nop(s);\n\n\n\n    /* label1: fast path */\n\n    reloc_pc16(label1_ptr, (tcg_target_long) s->code_ptr);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_V0, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addend) + addr_meml);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_V0, TCG_REG_V0, addr_regl);\n\n\n\n    addr_reg1 = TCG_REG_V0;\n\n#endif\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_LBU, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_imm(s, OPC_LB, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 1:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LHU, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 1 | 4:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16s(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LH, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 2:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 3:\n\n#if !defined(CONFIG_SOFTMMU)\n\n        tcg_out_mov(s, TCG_REG_V0, addr_reg1);\n\n        addr_reg1 = TCG_REG_V0;\n\n#endif\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 4);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg2, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg2, addr_reg1, 4);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    reloc_pc16(label2_ptr, (tcg_target_long) s->code_ptr);\n\n#endif\n\n}\n", "idx": 16352, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "t", "sg", "w", "i", "p", "ses", "sq", "h", "ctx", "e", "g", "rs", "gs", "S", "ss", "session", "ns", "sts", "v", "ps", "sys", "js", "c", "in", "j", "comm", "n", "ts", "x", "sc", "b", "m"], "args": ["atts", "fields", "cs", "ds", "nets", "blocks", "arr", "arms", "limits", "terms", "flags", "members", "changes", "md", "aws", "results", "Args", "ctx", "aw", "ars", "ks", "bugs", "bs", "qs", "ians", "arg", "vals", "points", "gs", "amps", "tags", "values", "axis", "ns", "pointers", "ums", "keys", "doc", "ams", "js", "GS", "xs", "types", "ants", "func", "gets", "ids", "fs", "ags", "ts", "faces", "ims", "actions", "parts", "icks", "params", "names", "cats", "bes", "orders", "seconds"], "opc": ["OPcs", "copca", "optc", "OPfc", "copuc", "opbc", "oppuc", "oppsc", "copcs", "opf", "OPca", "ripfc", "copc", "opppc", " opcs", "OPco", "operuc", "ripco", "opfc", "copce", "coppc", "opcs", "opuc", "opco", "oppc", " opca", "operc", "operpc", "OPpc", "rippc", "opsbc", "ripc", "optf", "opsf", "jppc", "opersc", "opspc", "OPc", "jpco", "optpc", " opce", "OPf", "jpc", "opsc", "OPce", "opca", "optbc", "jpfc", "opce", "copsc", "OPbc"], "addr_regl": ["addr_remli", "addr_re1", "addr_gemle", "addr_randl", "addr_randb", "addr_res2", "addr_memb", "addr_remn", "addr_randn", "addr_legli", "addr_remle", "addr_regle", "addr_reml", "addr_legl", "addr_regb", "addr_regn", "addr_remb", "addr_gem1", "addr_res1", "addr_gemh", "addr_romL", "addr_reL", "addr_memli", "addr_leg2", "addr_rel", "addr_roml", "addr_rem2", "addr_modl", "addr_memn", "addr_mem2", "addr_mod1", "addr_resl", "addr_rom1", "addr_regli", "addr_rand1", "addr_rom2", "addr_resli", "addr_geml", "addr_legle", "addr_modL", "addr_rem1", "addr_regL", "addr_mem1", "addr_memL", "addr_romli", "addr_ren", "addr_memle", "addr_remL"], "addr_reg1": ["addr_disc9", "addr_registern", "addr_addrl", "addr_rm1", "addr_memn", "addr_memone", "addr_rm2", "addr_region2", "addr_reg9", "addr_register1", "addr_group2", "addr_mem1", "addr_rml", "addr_mem2", "addr_registerl", "addr_reg0", "addr_REG2", "addr_groupl", "addr_mem9", "addr_regiona", "addr_mem0", "addr_group1", "addr_disc1", "addr_register2", "addr_mema", "addr_addr1", "addr_REGa", "addr_rmn", "addr_regone", "addr_REGone", "addr_disc2", "addr_groupn", "addr_rega", "addr_regn", "addr_REG1", "addr_addrn", "addr_region1", "addr_regionone", "addr_addr2", "addr_disc0"], "addr_meml": ["addr_modl", "addr_emli", "addr_Mem2", "addr_siml", "addr_memoryll", "addr_modll", "addr_memoryli", "addr_hist2", "addr_temph", "addr_memoryl", "addr_histh", "addr_Meml", "addr_memoryr", "addr_limh", "addr_memoryh", "addr_mem2", "addr_mem1", "addr_memo", "addr_mod1", "addr_limo", "addr_emr", "addr_memory2", "addr_simh", "addr_memll", "addr_sim1", "addr_tempo", "addr_memli", "addr_limr", "addr_templ", "addr_limli", "addr_limv", "addr_modh", "addr_liml", "addr_histli", "addr_simll", "addr_emh", "addr_eml", "addr_histl", "addr_tempv", "addr_Memli", "addr_Memh", "addr_memv", "addr_memr", "addr_memory1"], "data_regl": ["data_REG2", "data_mapl", "data_regL", "data_memo", "data_reL", "data1regl", "data_sim1", "data_winl", "data_re2", "data1registerL", "data_regle", "data_ego", "data_eg1", "data1reg2", "data_randl", "data_res2", "data1registerle", "data_rego", "data_rele", "data_winh", "data1registerl", "data1register2", "data_regs", "data_urgls", "data_siml", "data_regyl", "data_urgo", "data_registerL", "data_rands", "data_eg2", "data_regls", "data_resl", "data_maph", "data_registerel", "data_register1", "data_reso", "data_registerl", "data_urgl", "data_mem2", "data_maps", "data_registerle", "data_meml", "data_memL", "data_simel", "data_REGo", "data_registero", "data_randh", "data_rel", "data_REGls", "data_wins", "data_memel", "data_mem1", "data_mapyl", "data_memle", "data_register2", "data_randyl", "data_resls", "data1regle", "data_REGl", "data_egl", "data_sim2", "data_urg2", "data_regel", "data_winyl", "data1regL"], "data_regh": ["data_arregh", "data_crech", "data_rupr", "data_reph", "data_resgh", "data2rech", "data_resht", "data_refl", "data2gregh", "data2regh", "data_rugh", "data_reekr", "data_rufl", "data2repr", "data_reht", "data_arrepr", "data__repr", "data_reshl", "data_rekr", "data2grech", "data_creith", "data__reht", "data_ruph", "data_rech", "data__regr", "data_reith", "data_respr", "data_reehl", "data_cregh", "data_resfl", "data_recpr", "data_resph", "data_resch", "data_ruch", "data_grech", "data2regr", "data_crepr", "data_reskr", "data__regh", "data_recgh", "data2gregr", "data_grepr", "data_crekr", "data_regr", "data_gregr", "data_recgr", "data_gregh", "data_rehl", "data_resgr", "data_recht", "data__creht", "data__crepr", "data_greph", "data_reegh", "data_reeith", "data2grepr", "data_crehl", "data__cregr", "data_cregr", "data_arrech", "data__cregh", "data_creht", "data_repr", "data_resith", "data_arrefl"], "data_reg1": ["data_rml", "data_romone", "data_gregone", "data_memone", "data_leg2", "data_roy1", "data_res2", "data_remone", "data_loc1", "data_rm100", "data_leg0", "data_regOne", "data_res100", "data_royOne", "data_rem0", "data_regone", "data_reg0", "data_res1", "data_greg1", "data_rm1", "data_rom1", "data_memOne", "data_rem2", "data_locOne", "data_mem2", "data_legone", "data_rmone", "data_meml", "data_mem0", "data_rm2", "data_leg1", "data_resone", "data_greg2", "data_reg100", "data_mem1", "data_rom2", "data_roy2", "data_roml", "data_rem1", "data_greg100", "data_loc2"], "data_reg2": ["data_meml", "data_mem12", "data_re4", "data_memL", "data_remTwo", "data_reg3", "data_res2", "data_memTwo", "data_memb", "data_res1", "data_REGL", "data_re1", "data_REG2", "data_mem4", "data_relTwo", "data_locb", "data_regL", "data_loc12", "data_rel1", "data_regb", "data_addr2", "data_reL", "data_addr12", "data_mem1", "data_rell", "data_regTwo", "data_loc1", "data_re3", "data_res4", "data_rem2", "data_addrb", "data_res3", "data_reg4", "data_re2", "data_REG1", "data_reg12", "data_mem3", "data_mem2", "data_reml", "data_rem1", "data_loc2", "data_addr1", "data_rel2"], "mem_index": ["mem2ind", "mem_pos", "mem_address", "Mem_ind", "memmatpos", "mem_size", "mem__address", "memmatconnect", "Mem_address", "mem_connect", " mem_pos", "mem2index", "memmattype", "mem__size", "mem__index", "mem_ind", "Mem_index", "mem2address", "mem2size", "mem_type", "Mem_size", " mem_connect", "memmatindex", "mem__ind", " mem_type"], "s_bits": ["s_flags", "s_count", " s_flags", "s__bits", "s_bs", " s_bs", "s__flags", "s__bs", "g_count", "g_flags", "g_bits"], "label1_ptr": ["label1__tr", "label3_pt", "label1__pt", "label3__ptr", "label3__tr", "label3__pt", "label3_req", "label1__req", "label1_pt", "label3_tr", "label1_req", "label1__ptr", "label3__req", "label1_tr"], "label2_ptr": ["label3_pt", "label2_tr", "label2_pointer", "label3_pointer", "label3_tr", "label2_pt"], "sp_args": ["sh_index", "sh__args", "spallpos", "spallargs", "sp_vals", "sp_index", "sp__index", "sh__vals", "sh_args", "spallvals", "sp_pos", "sp__pos", "sh__pos", "spallindex", "sh_vals", "sp__args", "sh__index", "sh_pos", "sp__vals"], "label3_ptr": ["label3_pt", "label1_src", "label3_src", "label3_pointer", "label1_pt", "label1_pointer"], "addr_regh": ["addr_creeth", "addr_gregh", "addr_auql", "addr_beph", "addr_gregt", "addr_resgt", "addr_rough", "addr_greql", "addr_resgo", "addr_resql", "addr_crehl", "addr_reci", "addr_cregr", "addr_rego", "addr_reseth", "addr_grehl", "addr_prepr", "addr_resgh", "addr_resci", "addr_preph", "addr_rergr", "addr_begt", "addr_reql", "addr_bego", "addr_pregh", "addr_auph", "addr_resph", "addr_greph", "addr_reeth", "addr_repr", "addr_regt", "addr_regr", "addr_grego", "addr_augh", "addr_rouph", "addr_roupr", "addr_cregh", "addr_auhl", "addr_respr", "addr_rehl", "addr_preci", "addr_resgr", "addr_begh", "addr_reph", "addr_rerhl", "addr_reshl", "addr_rereth", "addr_rouci", "addr_rergh"], "addr_reg2": ["addr_rem2", "addr_storetwo", "addr_reg4", "addr_leg1", "addr_registertwo", "addr_egl", "addr_register1", "addr_mem22", "addr_rem1", "addr_store1", "addr_mem1", "addr_mem2", "addr_leg4", "addr_store22", "addr_memj", "addr_regj", "addr_register22", "addr_memtwo", "addr_mem5", "addr_reg22", "addr_egj", "addr_register2", "addr_mem4", "addr_leg5", "addr_leg2", "addr_regtwo", "addr_store2", "addr_remj", "addr_eg1", "addr_reml", "addr_reg5", "addr_eg2"], "addr_memh": ["addr_histen", "addr_histol", "addr_modl", "addr_mbh", "addr_mb1", "addr_moden", "addr_memoryl", "addr_memoryp", "addr_histh", "addr_mindh", "addr_Meml", "addr_mindb", "addr_memoryh", "addr_memen", "addr_mem1", "addr_mindel", "addr_maph", "addr_mbel", "addr_memb", "addr_modol", "addr_memoryol", "addr_map1", "addr_mtl", "addr_modh", "addr_mapel", "addr_mtb", "addr_mind1", "addr_mapb", "addr_memoryen", "addr_mtp", "addr_mbb", "addr_Memp", "addr_memoryb", "addr_Memb", "addr_memel", "addr_histl", "addr_memp", "addr_Memh", "addr_memol", "addr_mth"]}}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGLabel *lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                TCGLabel *lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_ctzi_tl(cpu_R[rd], cpu_R[ra], -1);\n\n            tcg_gen_addi_tl(cpu_R[rd], cpu_R[rd], 1);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_clzi_tl(cpu_R[rd], cpu_R[ra], TARGET_LONG_BITS);\n\n            tcg_gen_subfi_tl(cpu_R[rd], TARGET_LONG_BITS, cpu_R[rd]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 16360, "substitutes": {"dc": ["td", "ds", "dp", "tc", "disc", "oc", "dt", "mc", "ec", "pc", "dl", "dat", "bc", "cc", "di", "cd", "da", "dm", "lc", "cm", "fc", "df", "nc", "xc", "DC", "rc", "icc", "sc"], "insn": ["intersnr", "INSpan", "pinssn", " inspn", " inssn", "psoln", "interssn", "vspan", "tsns", " insgn", "atsgn", "attsnc", "stsnr", "psno", "ainsgn", "kinsoln", "retssn", "tsn", "risnc", "vssn", "pinsn", "intersn", "statsn", "stsnc", "rissn", "inspan", "retsoln", "kssn", "ksgn", "vsne", "inn", "atspn", "intnc", "kinsno", "ainsnr", "risn", "ainsnc", " insne", "INSne", "ainsn", "ksn", "risoln", "intersnc", "statsne", "intsn", "ksns", "insns", "ingn", "attsn", "statsgn", "retsno", "insoln", "intoln", "ainssn", "stssn", " insns", "atsn", "inspn", "insne", "psn", "INSn", "tsgn", "kinsn", "attssn", "insnr", "INSsn", "stsn", "inssn", "vsn", "retsn", "insno", "pssn", "atsne", "insnc", "kinssn", "intn", "pinspan", "inns", "insgn", "pinsne", "statspn", "ainsns", "tssn", "attsoln"], "op0": ["OP0", "pop0", "oop0", "hop2", "op5", "opt2", "oop50", "hop0", "OP5", "hop1", "opt50", "oop1", "OP2", "pop5", " op50", "p0", "oop2", "pop2", "OP1", "op50", "hop5", "opt0", "pop1", "p1"], "op1": ["p01", "cop3", "OpOne", "Op0", "op3", "copOne", "Op2", " op3", "Op01", " op6", "opOne", "cop2", "Op1", "op01", "Op6", "Op3", "cop01", "OP3", "OPOne", "p2", "OP2", " op01", "cop6", "cop0", "p3", "OP1", "op6", "cop1", "p1"], "op2": ["opt5", "ip6", "ip2", "tip2", "opt1", "ip1", "tip1", "op5", "opt2", " op6", " op5", "ip5", "iplet", "tip5", " oplet", "optlet", "tip6", "oplet", "op6"], "ra": ["a", "rap", "au", "raf", "loc", "res", "ara", "ur", "stra", "ta", "ring", "rain", "rise", "ras", "rx", "tar", "ar", "ran", "ru", "rom", "ri", "sa", "ata", "rs", "tra", "rou", "rum", "ma", "ora", "da", "area", "rar", "era", "dr", "Ra", "r", "art", "RA", "ina", "la", "red", "ba", "ro", "from", "rn", "rc", "alpha", "dra", "rf", "cro", "po", "aria"], "rb": ["raf", "rob", "rab", "sb", "bb", "rw", "reb", "ru", "hr", "rt", "fb", "ob", "rub", "ri", "rs", "mr", "rr", "lb", "db", "pb", "wb", "rar", "nb", "erb", "r", "rid", "rg", "cb", "RB", "sr", "rn", "ro", "vr", "rc", "rf", "rib", "b", "lr", "rl"], "rd": ["td", "raf", "rm", "rob", "fd", "nder", "dd", "pr", "rx", "rw", "ru", "hr", "rt", "RD", "ri", "fr", "rs", "mr", "rr", "bd", "d", "cd", "dr", "rar", "cr", "r", "rid", "ird", "rg", "rat", "sr", "ld", "rn", "ro", "nd", "rh", "rc", "dra", "rf", "red", "lr", "rl"], "lab": ["loc", "l", "box", "sel", "LAB", "px", "el", "disc", "els", "lib", "cell", "abb", " labels", "Lab", "ub", " label", "ob", "tmp", "ann", "abel", "ox", "reg", "label", "star", "cd", "pb", "bl", "tab", "ab", "hub", "gb", "ind", "lit", " bab", "ref", "local", "val", "lc", "fc", "la", "pl", " lb", "cb", "ls", "bus", "xc", "col", "lb"]}}
{"project": "qemu", "commit_id": "225d02cd1a34d5d87e8acefbf8e244a5d12f5f8c", "target": 1, "func": "int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n", "idx": 16365, "substitutes": {"timeout": ["OUT", "size", "slot", "dt", "span", "option", "password", "latest", "local", "number", "cache", "buffer", "alert", "t", "always", "port", "lock", "global", "tmp", "resolution", "shape", "limit", "start", "response", "service", "call", "update", "try", "directory", "Timeout", "localhost", "version", "status", "event", "total", "period", "wait", "delay", "address", "instance", "time", "python", "target", "to", "note", "height", "print", "state", "network", "ssl", "tt", "policy", "seconds", "missing", "history", "duration", "window", "client", "timer", "out", "unit", "socket", "sleep", "value", "data", "watch", "message", "table", "blocking", "sequence", "tv", "type"], "add": ["init", "a", "pos", "late", "grow", "check", "apply", "ord", "total", "adding", "pad", "sub", "make", "num", "en", "end", "set", "sum", "shift", "append", "mod", "Add", "amount", "save", "step", "lat", "ad", "d", "adder", "attr", "push", "addr", "update", "pkg", "ext", "att", "dev", "AD", "ADD", "new", "mk", "post", "cal", "diff", "extra", "attach", "acc", "del", "len", "alpha", "added", "ac", "build", "plus", "part", "import", "inc", "dd"], "delta": ["indummy", "idelta", "rota", "adta", "lynam", "lota", "relta", " delt", "indelta", "adota", "dota", "lata", "Dynam", "adelt", "sdota", "indelt", "idelt", "dummy", "fota", "felta", "Dota", "Data", "fata", "lta", "indata", "dynam", "lelt", "data", "sdelt", "sdelta", "Delta", "Delt", " dota", "delt", "lelta", "felt", "sdta", "drelta", "idummy", " data", "dta", "drota", "drynam", "rata", " dummy", "drelt", "indota", "adelta", "relt"]}}
{"project": "FFmpeg", "commit_id": "e1fb3143bb3a6006612fe0e1d1a15c8eb4955802", "target": 1, "func": "static int ftp_abort(URLContext *h)\n\n{\n\n    static const char *command = \"ABOR\\r\\n\";\n\n    int err;\n\n    static const int abor_codes[] = {225, 226, 0};\n\n    FTPContext *s = h->priv_data;\n\n\n\n    /* According to RCF 959:\n\n       \"ABOR command tells the server to abort the previous FTP\n\n       service command and any associated transfer of data.\"\n\n\n\n       There are FTP server implementations that don't response\n\n       to any commands during data transfer in passive mode (including ABOR).\n\n\n\n       This implementation closes data connection by force.\n\n    */\n\n\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n\n        ftp_close_both_connections(s);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    } else {\n\n        ftp_close_data_connection(s);\n\n    }\n\n\n\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n\n        /* wu-ftpd also closes control connection after data connection closing */\n\n        ffurl_closep(&s->conn_control);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16370, "substitutes": {"h": ["hs", "here", "history", "l", "oh", "hh", "hu", "t", "w", "hi", "sh", "kh", "p", "he", "hz", "th", "hash", "bh", "hd", "ht", "handle", "m", "her", "v", "hw", "k", "H", "ih", "http", "c", "hm", "hp", "host", "ph", "zh", "dh", "x", "rh", "ah", "it", "hal", "b", "eh", "hl"], "command": ["connection", "character", "history", "channel", "error", "comment", "controller", "Command", "program", "power", "action", "communication", "password", "reason", "content", "operation", "address", "method", "control", "execute", "response", "value", "service", "description", "data", "cmd", "call", "argument", "template", "message", "sequence", "request", "attribute", "function", "buffer", "pattern", "event", " Command", "mode"], "err": ["late", "here", "error", "ok", "arr", "z", "die", "t", "i", "pr", "Error", "test", "gz", "kr", "ner", "buf", "fr", "actor", " terr", "mr", "rr", "fer", "out", "off", "warn", "v", "Er", "attr", "iter", "dr", "ptr", "doc", "fee", "cor", "js", "lr", "sys", "msg", "c", "my", "cr", "try", "r", "plain", "ev", "gr", "cfg", "str", "cer", "n", "raw", "usr", "er", "state", "notice", "txt", "cb", "later", "rn", "cert", "nr", "code", "elt", "conf", "trace", "br", "oe"], "abor_codes": ["abor_code", "ab_odes", "abor2odes", "gob_names", "ab_names", "gob_odes", "ab_codes", "ab_code", "abor2names", "gob_codes", "abor2code", "abor_names", "abor2codes", "gob_code", "abor_odes"], "s": ["a", "sc", "hs", "ds", "cs", "os", "z", "l", "t", "w", "sh", "p", "sb", "sp", "sq", "aws", "q", "sm", "qs", "is", "g", "sv", "rs", "gs", "S", "ss", "ns", "v", "sts", "self", "ps", "sys", "js", "c", "j", "es", "r", "n", "ts", "ssl", "ls", "stats", "sl", "b", "has", "y"]}}
{"project": "FFmpeg", "commit_id": "a4fec9a7eab842ea5eea1b1ee98624356cb31422", "target": 1, "func": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n    written++;\n    channel_id = hdr & 0x3F;\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       return AVERROR(EAGAIN);\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;", "idx": 16385, "substitutes": {"h": ["hs", "here", "history", "l", "oh", "hh", "t", "w", "hl", "uh", "sh", "kh", "window", "hi", "he", "hz", "th", "q", "bh", "hash", "html", "hr", "g", "ht", "handle", "ch", "v", "hw", "k", "H", "ih", "each", "http", "conn", "c", "hm", "hp", "r", "host", "ph", "zh", "dh", "cache", "rh", "s", "f", "ah", "hal", "b", "eh", "m"], "p": ["a", "lp", "np", "t", "w", "wp", "pp", "q", "pc", "g", "d", "v", "pb", "c", "pkg", "j", "r", "jp", "n", "o", "x", "pa", "cp", "f", "fp", "P", "b", "m"], "chunk_size": ["chacket_length", "chunkedlength", "chacket_count", "chunkedcount", "chunk_count", "chunk_length", "chacket_SIZE", "chunkedSIZE", "chacket_size", "chunk_SIZE", "chunkedsize"], "prev_pkt_ptr": ["prev_pkg_req", "prev_pkg_tr", "prev_pkg2ptr", "prev_pkt_pad", "prev_pkt_addr", "prev_pkt_Ptr", "prev_pck_addr", "prev_pkg_ptr", "prev_pck_obj", "prev_pkt_obj", "prev_pkg2pad", "prev_pkt2ptr", "prev_pck_Ptr", "prev_pkt_tr", "prev_pkt_req", "prev_pkg2tr", "prev_pkt2obj", "prev_pkt2tr", "prev_pkg_obj", "prev_pck_ptr", "prev_pkg_pt", "prev_pkg2obj", "prev_pkt2pad", "prev_pkt_pt", "prev_pkg_pad"], "nb_prev_pkt": ["nb_prev_ipck", "nb_prev_npacket", "nb_prev_pnt", "nb_prev_npkt", "nb_prev_nnt", "nb_prev_nkt", "nb_prev_npnt", "nb_prev_Pnt", "nb_prev_ipkt", "nb_prev_Pck", "nb_prev2pck", "nb_prev_packet", "nb_prev2npnt", "nb_prev_ipacket", "nb_prev_Packet", "nb_prev2npck", "nb_prev_nacket", "nb_prev2pkt", "nb_prev_npck", "nb_prev_Pkt", "nb_prev_nck", "nb_prev_pck", "nb_prev2npacket", "nb_prev_ipnt", "nb_prev2packet", "nb_prev2pnt", "nb_prev2npkt"], "hdr": ["hrd", "whdr", "Hheader", "wrid", " hdc", "Hdr", "hrs", "ohdr", "ohbr", "wrd", "hhDR", "hhmt", "whdc", "khDR", "ihrs", "trd", "hdc", "ahdr", " hDR", "thmt", "ahrs", " hrd", "hDR", "dhdc", "phdr", " hrs", "ihDR", "khbr", "whDR", "hld", "tgt", "dhDR", "trid", "hrc", " hbr", "phpar", "ihrc", "dhld", "whld", " hrc", "thheader", "thdr", "wdr", "hheader", "ohrc", "hmt", "hhheader", "tdr", "HDR", "hpar", "phbr", "hbr", "ihdr", "hgt", " hgt", "Hpar", "thDR", " hrid", "Hbr", "ohDR", "khpar", "hrid", "phDR", "khdr", "wgt", " hld", "hhdr", "ohrs", "ahDR", "Hmt", "ahbr", "dhdr"], "buf": ["loc", "img", "tx", "ctx", "good", "bag", "conv", "kw", "wb", "iter", "bl", "obj", "req", "bu", "comm", "orig", "cache", "buffer", "ah", "mem", "cap", "cv", "Buff", "desc", "var", "rw", "bh", "port", "gz", "cur", "tmp", "etc", "pb", "read", "doc", "msg", "pkg", "usr", "resp", "que", "buff", "ctr", "err", "late", "box", "bar", "proc", "og", "vec", "prop", "queue", "BU", "ptr", "addr", "raw", "str", "act", "rb", "txt", "block", "fw", "cp", "b", "next", "pos", "pause", "window", "fb", "bs", "pg", "bytes", "data", "cmd", "foo", "func", "ext", "ref", "pool", "batch", "extra", "cb", "uf", "Buffer", "seq", "br"], "channel_id": ["channelNamemid", "character_status", "channel_uid", "channel_Id", "channel_pid", "channelIid", "channel_status", "channelIDdb", "channel2no", "character_part", " channel_Id", "channel_tag", "shortityID", "channelIDID", "channel_code", "channelIDiden", "channelityuid", "channel_no", "channelitycode", "channel___ident", "channelityID", "char_id", "channelityside", "channelityId", " channel_str", "channel___info", "channel2i", "channel_orig", " channel_mid", " channel_i", "filter_id", " channel_type", "channelitypid", "channelNameid", "shortityiden", "channel_ident", "filter_orig", "character_side", "channel_i", "char_tag", "channel5link", "channel2info", "channelIdinfo", "short_ID", "channelNamestr", "channel_str", "channelIDlink", " channel_code", "channelIdi", "channel_key", "channel_db", "short_uid", " channel_no", "character_id", "character_pid", "channelIdid", " channel_info", "channel_side", "channelIDuid", "shortityid", "channelIId", "character_Id", "character_ident", "channel5tag", " channel_side", "filter_link", "channel_type", "channelityiden", "shortityuid", "channelIpart", "channelIstatus", "channelIDid", "channelIDorig", "channel_link", "channel_info", "channel5id", "channelIDident", " channel_ident", "char_link", "channel_part", "channelityid", "channel___id", "channelNameside", "channel_iden", "channel2id", "channel_mid", " channel_db", "channelIdno", " channel_key", "short_iden", "channelityident", "short_id", "channel_ID"], "timestamp": ["simability", "extetime", "timeetime", "timeability", "exttime", "extestamp", "timetime", "extability", "simtime", "timtime", "simetime", "timeestamp", "timability", "simestamp"], "size": ["offset", "zone", "total", "sent", "max", "timeout", "scale", "sum", "count", "course", "sized", "empty", "shape", "resolution", "general", "length", "send", "name", "address", "bytes", "capacity", "sn", "time", "description", "data", "ize", "speed", "changed", "storage", "id", "height", "summary", "extra", "number", "space", "dim", "Size", "notice", "SIZE", "info", "len", " sizes", "s", "buffer", "small"], "ts_field": ["ats_Field", "tsettag", "ts_Field", "TS_value", "ts_id", "ats_field", "tsistlabel", "ats_option", "its_id", "tslisttable", "tsitytype", "itslistfield", "tsistfields", "tsetfield", "ts_type", "tslisttype", "ts_label", "ats_label", "itslisttable", "ats_fields", "ts_option", "its_table", "TS_fields", "tslistid", "its_type", "its_field", "ts___value", "tsetfields", "tsistField", "tsxid", "ts___field", "itslistid", "tsxfield", "TS_field", "itslisttype", "tsxtype", "TS_tag", "tsityfield", "tsitytable", "ts_tag", "ts_value", "ts___fields", "tsetvalue", "ts___tag", "ts_bit", "ts_table", "tsxtable", "tsityid", "tslistfield", "ats_bit", "tsistfield", "ts_fields"], "type": ["offset", "error", " types", " t", " error", "format", "t", "style", "oe", "total", " kind", "ping", " typ", "term", "where", "test", "action", "ype", "what", "owner", "shape", "length", "other", "tp", "name", "kind", "class", " ty", "time", "description", "types", "role", "typ", "id", "TYPE", "event", "scope", "tag", "field", "relation", "date", "ty", "extra", "key", "state", "info", "trace", "ime", "Type", "ver", "pe", "spec", " family", "version", "status", "file", "like"], "ret": ["mem", "nt", "res", "t", "back", "final", "result", "ll", "Ret", "ry", "ern", "rt", "il", "tr", "mt", "out", "tf", "ptr", "read", "dr", "obj", "ft", "value", "rem", " Ret", "RET", "rev", "re", "reset", "lit", "try", "ref", "r", "val", "def", "extra", "alt", "aux", "got", "txt", "len", "resp", "not", "gt", "it", "elt", "status", "red", "rets"], "toread": ["tourad", "torstad", "ntoread", "toresady", "toreade", "ntorend", "ntoreade", "tournd", "tourade", "torstady", "toresad", "toresnd", "ntorstnd", "torend", "ntoready", "toready", "ntorstade", "ntorstady", "torstade", "toresade", "torstnd", "ntorstad", "tourady"], "prev_pkt": ["prev_compkt", "prev_ret", "prev_bptx", "prev_ipacket", "prev_pdu", "prev_Pkt", "prev_rkt", "prev_bpdu", "prev_ipkt", "prev_pact", "prev_bplet", "prev_Pelt", "prev_compet", "prev_packtx", "prev_pett", "prev_packdt", "prev_cet", "prev_pulse", "prev_Pulse", "prev_peacket", "prev_Pnt", "prev_cpkg", "prev_compqt", "prev_ptx", "prev_wett", "prev_iplet", "prev_Pet", "prev_ract", "prev_nkt", "prev_ipulse", "prev_peelt", "prev_cett", "prev_nnt", "prev_Pett", "prev_rdt", "prev_pnt", "prev_Packet", "prev_rwk", "prev_bpkt", "prev_rqt", "prev_packwk", "prev_compkg", "prev_cpmsg", "prev_pdt", "prev_packact", "prev_ckt", "prev_ipdu", "prev_wkt", "prev_packlet", "prev_pqt", "prev_pwk", "prev_nacket", "prev_pkg", "prev_Pmsg", "prev_cpkt", "prev_cpnt", "prev_pmsg", "prev_wacket", "prev_iptx", "prev_cacket", "prev_ipelt", "prev_packkt", "prev_wet", "prev_plet", "prev_cpet", "prev_cpacket", "prev_packet", "prev_pet", "prev_packdu", "prev_rkg", "prev_nmsg", "prev_pelt", "prev_pekt", "prev_cpqt", "prev_peulse"], "written": ["Written", "documented", "hidden", "itted", "wrote", "rew", "loaded", "used", "w", "sent", "writ", "future", "rawn", "num", "en", "balanced", "broken", "linked", "readable", "ordered", "made", "played", "created", "count", "reported", "output", "done", "writer", "called", "checked", "said", "numbered", "out", "ritten", "started", "packed", "bytes", "built", "read", "held", "wat", "printed", "changed", "finished", "adjusted", "generated", "updated", "recorded", "n", "number", "writing", "connected", "encrypted", "len", "led", "initialized", "ended", "stretched", "write"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "void eeprom93xx_write(eeprom_t *eeprom, int eecs, int eesk, int eedi)\n\n{\n\n    uint8_t tick = eeprom->tick;\n\n    uint8_t eedo = eeprom->eedo;\n\n    uint16_t address = eeprom->address;\n\n    uint8_t command = eeprom->command;\n\n\n\n    logout(\"CS=%u SK=%u DI=%u DO=%u, tick = %u\\n\",\n\n           eecs, eesk, eedi, eedo, tick);\n\n\n\n    if (! eeprom->eecs && eecs) {\n\n        /* Start chip select cycle. */\n\n        logout(\"Cycle start, waiting for 1st start bit (0)\\n\");\n\n        tick = 0;\n\n        command = 0x0;\n\n        address = 0x0;\n\n    } else if (eeprom->eecs && ! eecs) {\n\n        /* End chip select cycle. This triggers write / erase. */\n\n        if (eeprom->writable) {\n\n            uint8_t subcommand = address >> (eeprom->addrbits - 2);\n\n            if (command == 0 && subcommand == 2) {\n\n                /* Erase all. */\n\n                for (address = 0; address < eeprom->size; address++) {\n\n                    eeprom->contents[address] = 0xffff;\n\n                }\n\n            } else if (command == 3) {\n\n                /* Erase word. */\n\n                eeprom->contents[address] = 0xffff;\n\n            } else if (tick >= 2 + 2 + eeprom->addrbits + 16) {\n\n                if (command == 1) {\n\n                    /* Write word. */\n\n                    eeprom->contents[address] &= eeprom->data;\n\n                } else if (command == 0 && subcommand == 1) {\n\n                    /* Write all. */\n\n                    for (address = 0; address < eeprom->size; address++) {\n\n                        eeprom->contents[address] &= eeprom->data;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        /* Output DO is tristate, read results in 1. */\n\n        eedo = 1;\n\n    } else if (eecs && ! eeprom->eesk && eesk) {\n\n        /* Raising edge of clock shifts data in. */\n\n        if (tick == 0) {\n\n            /* Wait for 1st start bit. */\n\n            if (eedi == 0) {\n\n                logout(\"Got correct 1st start bit, waiting for 2nd start bit (1)\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"wrong 1st start bit (is 1, should be 0)\\n\");\n\n                tick = 2;\n\n                //~ assert(!\"wrong start bit\");\n\n            }\n\n        } else if (tick == 1) {\n\n            /* Wait for 2nd start bit. */\n\n            if (eedi != 0) {\n\n                logout(\"Got correct 2nd start bit, getting command + address\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"1st start bit is longer than needed\\n\");\n\n            }\n\n        } else if (tick < 2 + 2) {\n\n            /* Got 2 start bits, transfer 2 opcode bits. */\n\n            tick++;\n\n            command <<= 1;\n\n            if (eedi) {\n\n                command += 1;\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits) {\n\n            /* Got 2 start bits and 2 opcode bits, transfer all address bits. */\n\n            tick++;\n\n            address = ((address << 1) | eedi);\n\n            if (tick == 2 + 2 + eeprom->addrbits) {\n\n                logout(\"%s command, address = 0x%02x (value 0x%04x)\\n\",\n\n                       opstring[command], address, eeprom->contents[address]);\n\n                if (command == 2) {\n\n                    eedo = 0;\n\n                }\n\n                address = address % eeprom->size;\n\n                if (command == 0) {\n\n                    /* Command code in upper 2 bits of address. */\n\n                    switch (address >> (eeprom->addrbits - 2)) {\n\n                        case 0:\n\n                            logout(\"write disable command\\n\");\n\n                            eeprom->writable = 0;\n\n                            break;\n\n                        case 1:\n\n                            logout(\"write all command\\n\");\n\n                            break;\n\n                        case 2:\n\n                            logout(\"erase all command\\n\");\n\n                            break;\n\n                        case 3:\n\n                            logout(\"write enable command\\n\");\n\n                            eeprom->writable = 1;\n\n                            break;\n\n                    }\n\n                } else {\n\n                    /* Read, write or erase word. */\n\n                    eeprom->data = eeprom->contents[address];\n\n                }\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits + 16) {\n\n            /* Transfer 16 data bits. */\n\n            tick++;\n\n            if (command == 2) {\n\n                /* Read word. */\n\n                eedo = ((eeprom->data & 0x8000) != 0);\n\n            }\n\n            eeprom->data <<= 1;\n\n            eeprom->data += eedi;\n\n        } else {\n\n            logout(\"additional unneeded tick, not processed\\n\");\n\n        }\n\n    }\n\n    /* Save status of EEPROM. */\n\n    eeprom->tick = tick;\n\n    eeprom->eecs = eecs;\n\n    eeprom->eesk = eesk;\n\n    eeprom->eedo = eedo;\n\n    eeprom->address = address;\n\n    eeprom->command = command;\n\n}\n", "idx": 16406, "substitutes": {"eeprom": ["eEPcm", "eepsprom", "eekrome", "eethrim", "eepsrum", "eimprome", "jeethom", "eepercm", "eeepprom", "esegrom", "eegdem", "eebchrom", "ieecchrom", "peekprom", "eegom", "eaperom", "seEProme", "ieeparm", "seipprom", "eeepom", "eopprom", "peepsprom", "eekchrom", "eegcm", "meecom", "eekdem", "ieEPram", "edegdom", "eipprom", "seEProm", "ieeprim", "seeprum", "eemrome", "zeeprom", "eekrim", "eipram", "eecprom", "eEProm", "eEPdem", "jeeprom", "eebrom", "eepsarm", "esegrem", "eecom", "eseprem", "eyprum", "seyprum", "ieEProm", "peepcm", "ieepchrom", "eepom", "eegroc", "eaperum", "seEPron", "eeeproc", "seEPchrom", "eecram", "pepprom", "meecrom", "eeperron", "seeeprom", "seypchrom", "eeekom", "eseprome", "seeeperrom", "epron", "eepsom", "peppram", "eyprome", "eEPprom", "eeperchrom", "eepdom", "eekcom", "neeprome", "eyproc", "exprom", "eespcm", "peepsram", "seEPprom", "eepchrom", "eipom", "eegdom", "eebcm", "seyprim", "seypom", "eimprem", "zeepcm", "eekprom", "seepron", "eecarm", "seeepprom", "eebarm", "exprim", "eeprome", "jeeprim", "epearm", "eesprom", "seeprom", "eypcom", "eegrem", "epprum", "eepcm", "edegdem", "eepram", "eecdem", "eeproc", "eyprim", "eeperrome", "eseprom", "eecchrom", "eremrome", "eEPron", "eiprem", "eperom", "eEPram", "seipram", "meecram", "eekram", "zeespchrom", "eppdem", "eeepdem", "seeprome", "seyproc", "eeekdem", "neepprom", "jeethrom", "seepprom", "eeperram", "eeperprom", "eremrom", "neeperrom", "seeeperprom", "epprim", "ereprome", "eethom", "neeprom", "eegprom", "eekrom", "peppcm", "eesprum", "eiprim", "eeperom", "edegrom", "peepcom", "eebram", "eegarm", "eebrum", "peepram", "jeethrome", "eegram", "eeglam", "neeperprom", "epprom", "seiprim", "eecrim", "exproc", "eperome", "eyplam", "seyprom", "seeprim", "eepsrom", "eypprom", "eespram", "eremcm", "peepprom", "seepram", "eppram", "edeprom", "eremom", "eemcm", "eeekprom", "eeyplam", "eebrim", "eeeplam", "peeprom", "eaperim", "eoprom", "eoprome", "eebprom", "eprom", "eseprim", "eeprim", "eopcm", "eipcom", "eespchrom", "eeprem", "eprome", "ieEPprom", "eegchrom", "eypram", "eypom", "ereprom", "seepchrom", "edepdom", "eeplam", "seepom", "eemrom", "eppprom", "ieecrim", "eeprum", "eEPrim", "jeepom", "ieecarm", "meeprim", "eEProme", "eypchrom", "eimplam", "ieepprom", "eethrome", "eeyprim", "seeproc", "peekram", "edegrim", "neepcm", "eimprom", "eecrom", "eepsram", "jeethrim", "neeperrome", "erepcm", "eekom", "eeekrom", "esegrim", "eespcom", "edepdem", "eypcm", "erepom", "eimproc", "eeyprom", "eppcom", "zeesprom", "eyprom", "eppcm", "eeperrom", "eeeprim", "epechrom", "eegrim", "eeeprom", "eEPom", "peeparm", "peekrom", "zeespcm", "seeepram", "eemom", "meeprom", "epeom", "eimprim", "eeperrum", "eiprom", "seEPom", "eegrome", "eperim", "eegrom", "eethrom", "eekrum", "eppom", "ieepram", "zeesprum", "eepprom", "eepdem", "expchrom", "edeprim", "eekcm", "eepcom", "ieEPrim", "seeeperrum", "eiprome", "jeeprome", "eeparm", "seeeperram", "eeyproc", "eEPchrom", "peepsrom", "zeeprum", "eepron", "peekcom", "meepom", "esegrome", "peppcom", "neepercm", "peepsarm", "meepram", "ieeprom", "eapeom", "eepsrim", "meecrim", "ieecrom", "seiprom", "seeeprum", "eppdom", "zeepchrom"], "eecs": ["seegs", "eepds", "eocs", "peecis", "eebts", "eECrs", "eegos", "eercrates", "geebds", "seecs", "eefes", "eeps", "eeeeescs", "eects", "eepes", "eescis", "eeeeecs", "eeeeeccs", "peepols", "geebs", "eebs", "geecds", "eepcs", "eocjs", "peeps", "eescks", "eegds", "eeeeecks", "peecs", "eekis", "eesccs", "eekos", "seegis", "eefcs", "eecds", "eeccs", "eescjs", "seecis", " eecjs", "eecjs", "eecols", "eepjs", "eegrates", "peepos", "geebes", "eoces", "peecrates", "eescps", "eepis", "peegos", "eefs", "geects", "seeges", "eercols", "eefks", "eECes", "eecos", "eegs", " eeces", "eECis", "eeges", "seeces", "peecps", " eocjs", "eegps", "eebes", "eegols", "eeeeesccs", " eocs", "eecis", "peeprates", "eescols", "eECs", "eecrs", "geecs", "seecrs", "peecos", "geebts", "peepes", "eegts", "peecrs", "eeces", "eerces", "eepks", " eoces", "eecrates", "peeprs", "eefrs", "eescos", "peecols", "eecks", "eegis", "eesces", "eercs", "peegps", "eocols", "eecps", "eeprates", "eebds", "peegis", "eefos", " eecols", "eescs", "eeks", "eepols", "seegrs", "eegrs", "eepos", "eepts", "geeces", "peegs", "peeces", "eeprs", "eekps", "eeeeescks", " eocols"], "eesk": ["eedskh", "reesks", "reesok", "reeso", "ekso", "epsky", "reeskh", "edsok", "eesky", "eedskk", "eksk", "reeski", "eeskk", "edsh", "leesky", "eedsk", "reesu", "edsk", "eeskh", "eksky", "eesu", "eesh", "edski", "eesok", "eedsky", "eedso", "epskk", "eedsu", "eksok", "eeso", "epsks", "epsk", "eksh", "eeski", "reesh", "reesk", "leesk", "leeskh", "ekski", "ekskk", "leesks", "reesky", "eksks", "eksu", "eesks", "eedsks"], "eedi": ["ededz", "edediu", "eeds", "emedi", "ededo", "emedish", "eadish", "eadI", "eedo", "seeds", "emeds", "eadpi", "ededish", "emedpi", "seedo", "eedI", "seedz", "eedmi", "wolfii", "seedi", "seediu", "eedii", "eedin", "emedo", "wolfo", "wolfI", "ededI", "emedin", "seedin", "eadi", "ededi", "emedI", "ededs", "eediu", "wolfi", "ededin", "seedii", "emedz", "emedmi", "eedpi", "seedI", "seedmi", "ededii", "ededpi", "ededmi", "eedish", "emediu", "eedz"], "address": ["size", "controller", "base", "balance", "resource", "point", "ace", "ase", "length", "password", "email", "variable", "page", "host", "context", "number", "module", "attribute", "buffer", "phrase", "angle", "relative", "offset", "index", "memory", "port", "readable", "domain", "device", "distance", "shape", "command", "activity", "pointer", "route", "service", "description", "condition", "date", "hello", "directory", "confirmed", "Address", "code", "event", "location", "comment", "array", "interface", "adr", "delay", "prefix", "operation", "execute", "clock", "ip", "addr", "document", "order", "race", "target", "random", "element", "payment", "request", "state", "network", "iterator", "gate", "process", "component", "client", "store", "remote", "action", "ice", "padding", "position", "reference", "value", "data", "entity", "batch", "message", "table", "sequence", "alias", "direction", "active", "trace"], "tick": ["ck", "pad", "ping", "tx", "dt", "slot", "test", "shift", "length", "step", "ox", "stop", "insert", "commit", "sync", "token", "topic", "jump", "exec", "check", "offset", "frame", "quote", "index", "icker", "tim", "t", "shock", "timeout", "always", "zero", "stick", "lock", "chip", "shape", "_", "command", "scroll", "start", "pointer", "tip", "call", "date", "xe", "event", "task", "patch", "ctl", "snap", "click", "tc", "style", "repeat", "comment", "script", "delay", "normal", "cycle", "butt", "ock", "clock", "addr", "time", "TX", "race", "payment", "draw", "mill", "block", "tt", "trial", "byte", "loop", "nice", "tz", "window", "cell", "action", "timer", "empty", "padding", "choice", "bytes", "push", "trigger", "magic", "roll", "cmd", "pick", "watch", "tag", "new", "sequence", "tty", "dx", "tv", "trace", "ick"]}}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 16410, "substitutes": {"opaque": ["Opaque", " opicate", "oplay", " oplay", " opque", "boque", " opossus", "opicate", "boaque", "oplicate", "ropicate", "Opque", " opute", "oplaque", "boca", " opca", "opute", "opllay", "opque", "oplossus", "roplay", "opossus", "opca", "boute", "ropossus", "ropaque", "Opute", "Opca"], "iothread": ["eostreader", "iothload", "iostload", "iothstream", "iopathreader", "iththread", "ihandreader", "ioshric", "irothreader", "gioretreading", "ioothread", "ioshplay", "iologreader", "gioretread", "iouthwrite", "ioshwrite", "ioretstream", "iheartword", "irothlink", "iforereadable", "iothreadable", "eothread", "liothread", "piothale", "irostreader", "ioothride", "iouthstream", "iologlink", "aiothread", "iforthale", "girostread", "pioothread", "liothplay", "iothreader", "ionseride", " iouthreader", "ihatereader", "iothride", "ithreader", "iologride", "giothread", "irostread", "giostreader", "ionseprint", "iouthric", "iheartreader", "ireetread", "iostword", "iothreading", "iothric", "phiclothlock", "iforerecord", "iologread", "giostwrite", "ciologwrite", "iforthride", "irothread", " iothreader", "ciothreader", " iothstream", "ciothwrite", "iothlock", "ioretwrite", "giostread", "giothreading", "iforeread", "giothwrite", "ihandride", "iforthread", "ioretreading", "giothlink", "iforthreader", "aiothrecord", "ioretreader", "iouthreader", "pioothale", "phiothread", "ioshreader", "ihandwrite", " iothwrite", "iostreader", "giothreader", "iclothreader", "lioretread", "iclothreading", " iouthread", "ioshread", "giothload", " iouthwrite", "girostload", "ioretric", "phioththread", "ciologread", "iothparse", "iothlink", "pioothprint", "irothwrite", "iostread", "icloththread", "aiforerecord", "iforthrecord", "irothstream", "ihandread", "aiothreader", "iclothread", "ioththread", "ithlock", "irostreadable", "gioretparse", "eostword", "ioothale", "iostwrite", "iopathreading", "aiforereadable", "aiforereader", "ihateload", "eothword", "ciologride", "giothreadable", "ionseread", "ithread", "iostlink", "gioretreader", "iostreadable", "ioretparse", "girostreader", "iforereader", "iologwrite", "ciologreader", "lioretplay", "phiothreader", "phiothlock", "piothread", "ioshrecord", "ihateread", "girostreadable", "phiclothread", "eostreadable", "aiothreadable", "giothparse", "aiforeread", "iheartreadable", "ciothride", "ihatereadable", "iouthread", "ireetreader", "phiclothreader", " iouthstream", "giostlink", "ionseale", "iothprint", "iclothlock", "iothword", "ciothread", "eothreader", "iopathparse", "liothwrite", "eostread", "iouthplay", "irothlock", "iforthprint", "ireetword", "iforthreadable", "ioothprint", "iothplay", "liothric", "phicloththread", "ioretread", "piothride", "piothprint", "iclothparse", "eothreadable", "ioretplay", "iroththread", "ireetreadable", "lioretric", "iothale", "iopathread", "ioshreadable", "irostload", "irothride", "iothrecord", "pioothride", "iheartread", "lioretwrite", "iothwrite"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 16412, "substitutes": {"avctx": ["avecontext", "AVctx", "vcontext", "vtxt", " avcontext", " avtxt", "avecfg", "vpkg", " avcfg", "AVcontext", "avcontext", "avcfg", "aftx", "afctx", "AVtxt", " avtx", " avpkg", "avtxt", "avpkg", "avectx", "avtx", "afcfg", "AVpkg", "vctx", "afcontext", "avetx"]}}
{"project": "qemu", "commit_id": "3c3e88a814ef4eb8b2f8bf81863baec24838d998", "target": 0, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    int64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    mr = host_memory_backend_get_memory(dimm->hostmem, errp);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_int(v, name, &value, errp);\n\n}\n", "idx": 16415, "substitutes": {"obj": ["Object", "os", "np", "nt", "ist", "bh", "xy", "rect", "ctx", "bo", "ob", "op", "tmp", "onet", "ot", "out", "hw", "attr", "cont", "object", "js", "conn", "cmd", "pkg", "j", "att", "oj", "ref", "inst", "oid", "Obj", "obs", "o", "act", "txt", "objects", "org", "resp", "ex", "po", "elt", "phys"], "v": ["vi", "cv", "lv", "l", "qv", "t", "w", "vim", "p", "vt", "h", "nv", "av", "g", "sv", "vp", "vc", "conv", "d", "uv", "vs", "vm", "ve", "iv", "c", "inv", "j", "vy", "r", "vis", "ev", "V", "o", "mint", "vr", "f", "b", "m"], "name": ["a", "mem", "word", "error", "ame", "size", "t", "w", "p", "var", "term", "cn", " Name", " names", "prefix", " NAME", "Name", "ann", "named", "label", "attr", "data", "id", "common", "tag", "val", "str", "n", "path", "key", "alias", "title", "info", "names", "NAME", "code", "part", "ident", "nam", "type"], "opaque": ["operus", "ipaque", "opz", "openz", "opatile", "operaque", "operatile", "openaque", "ipatile", "openus", "operz", "ipus", "ipz", "openatile", "opus"], "errp": ["erping", " errr", "errorp", "errorP", " errping", "erp", "errr", "rrr", "rrping", "rrp", "errping", "errorr", "errP", "rrP", "erP", " errP", "errorping", "err"], "value": ["index", "ue", "memory", "qv", "size", "widget", "VALUE", "total", "w", "max", "p", "bar", "array", "result", "port", "scale", "output", "distance", "property", "vp", "length", "checked", "values", "Value", "position", "unit", "select", "tv", "description", "data", "json", " Value", "field", "val", "message", "hello", "oval", "key", "state", "attribute", "buffer", "text", "trace", "type"], "mr": ["bm", "mer", "spr", "rm", "memory", "mir", "ur", "pr", "wm", "mc", "ml", "rw", "RM", "kr", "hr", "adr", "rs", "shr", "mn", "rr", "tr", "mt", "rar", "Mr", "lr", "pm", "ocr", "r", "mar", "gr", "cm", "MR", "rg", "usr", "sr", "rn", "vr", "gm", "rpm", "drm", "rl", "m"], "dimm": ["dedimp", "digm", "dagm", "daimm", "dedimm", "dgm", " diam", "Dimm", "dedigm", "daigm", "dimp", "Dem", " digm", " dimp", "Diam", "diam", "pem", "Dim", "daimp", "dedgm", "piam", " dgm", "dim", "pim", " dim", "pimm", " dem", "dem"]}}
{"project": "qemu", "commit_id": "d0e7605ee0d91c3737052127a79199ddab3ff653", "target": 0, "func": "pflash_t *pflash_cfi02_register(target_phys_addr_t base, ram_addr_t off,\n\n                                BlockDriverState *bs, uint32_t sector_len,\n\n                                int nb_blocs, int nb_mappings, int width,\n\n                                uint16_t id0, uint16_t id1,\n\n                                uint16_t id2, uint16_t id3,\n\n                                uint16_t unlock_addr0, uint16_t unlock_addr1)\n\n{\n\n    pflash_t *pfl;\n\n    int32_t chip_len;\n\n\n\n    chip_len = sector_len * nb_blocs;\n\n    /* XXX: to be fixed */\n\n#if 0\n\n    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&\n\n        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))\n\n        return NULL;\n\n#endif\n\n    pfl = qemu_mallocz(sizeof(pflash_t));\n\n    /* FIXME: Allocate ram ourselves.  */\n\n    pfl->storage = qemu_get_ram_ptr(off);\n\n    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,\n\n                                         pfl);\n\n    pfl->off = off;\n\n    pfl->base = base;\n\n    pfl->chip_len = chip_len;\n\n    pfl->mappings = nb_mappings;\n\n    pflash_register_memory(pfl, 1);\n\n    pfl->bs = bs;\n\n    if (pfl->bs) {\n\n        /* read the initial flash content */\n\n        bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9);\n\n    }\n\n#if 0 /* XXX: there should be a bit to set up read-only,\n\n       *      the same way the hardware does (with WP pin).\n\n       */\n\n    pfl->ro = 1;\n\n#else\n\n    pfl->ro = 0;\n\n#endif\n\n    pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl);\n\n    pfl->sector_len = sector_len;\n\n    pfl->width = width;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n    pfl->status = 0;\n\n    pfl->ident[0] = id0;\n\n    pfl->ident[1] = id1;\n\n    pfl->ident[2] = id2;\n\n    pfl->ident[3] = id3;\n\n    pfl->unlock_addr[0] = unlock_addr0;\n\n    pfl->unlock_addr[1] = unlock_addr1;\n\n    /* Hardcoded CFI table (mostly from SG29 Spansion flash) */\n\n    pfl->cfi_len = 0x52;\n\n    /* Standard \"QRY\" string */\n\n    pfl->cfi_table[0x10] = 'Q';\n\n    pfl->cfi_table[0x11] = 'R';\n\n    pfl->cfi_table[0x12] = 'Y';\n\n    /* Command set (AMD/Fujitsu) */\n\n    pfl->cfi_table[0x13] = 0x02;\n\n    pfl->cfi_table[0x14] = 0x00;\n\n    /* Primary extended table address */\n\n    pfl->cfi_table[0x15] = 0x31;\n\n    pfl->cfi_table[0x16] = 0x00;\n\n    /* Alternate command set (none) */\n\n    pfl->cfi_table[0x17] = 0x00;\n\n    pfl->cfi_table[0x18] = 0x00;\n\n    /* Alternate extended table (none) */\n\n    pfl->cfi_table[0x19] = 0x00;\n\n    pfl->cfi_table[0x1A] = 0x00;\n\n    /* Vcc min */\n\n    pfl->cfi_table[0x1B] = 0x27;\n\n    /* Vcc max */\n\n    pfl->cfi_table[0x1C] = 0x36;\n\n    /* Vpp min (no Vpp pin) */\n\n    pfl->cfi_table[0x1D] = 0x00;\n\n    /* Vpp max (no Vpp pin) */\n\n    pfl->cfi_table[0x1E] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x1F] = 0x07;\n\n    /* Timeout for min size buffer write (NA) */\n\n    pfl->cfi_table[0x20] = 0x00;\n\n    /* Typical timeout for block erase (512 ms) */\n\n    pfl->cfi_table[0x21] = 0x09;\n\n    /* Typical timeout for full chip erase (4096 ms) */\n\n    pfl->cfi_table[0x22] = 0x0C;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x23] = 0x01;\n\n    /* Max timeout for buffer write (NA) */\n\n    pfl->cfi_table[0x24] = 0x00;\n\n    /* Max timeout for block erase */\n\n    pfl->cfi_table[0x25] = 0x0A;\n\n    /* Max timeout for chip erase */\n\n    pfl->cfi_table[0x26] = 0x0D;\n\n    /* Device size */\n\n    pfl->cfi_table[0x27] = ctz32(chip_len);\n\n    /* Flash device interface (8 & 16 bits) */\n\n    pfl->cfi_table[0x28] = 0x02;\n\n    pfl->cfi_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    /* XXX: disable buffered write as it's not supported */\n\n    //    pfl->cfi_table[0x2A] = 0x05;\n\n    pfl->cfi_table[0x2A] = 0x00;\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = nb_blocs - 1;\n\n    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = sector_len >> 8;\n\n    pfl->cfi_table[0x30] = sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n\n\n    return pfl;\n\n}\n", "idx": 16419, "substitutes": {"base": ["a", "bal", "offset", "mem", "history", "server", "memory", "bare", "size", "basic", "back", "pad", "p", "as", "i", "max", "bp", "bas", "balance", "map", "ase", "based", "prefix", "cpu", "m", "mb", "db", "out", "name", "start", "bottom", "area", "ip", "bit", "re", "storage", "id", "bu", "ref", "local", "origin", "root", "bound", "bf", "alias", "ram", "block", "bin", "from", "buffer", "bind", "full", "boot", "us", "b", "file", "br", "Base"], "off": ["a", "offset", "pos", "mem", "loc", "os", "b", "of", "offs", "ap", "pad", "i", "p", "at", "end", "set", "on", "bas", "zero", "buf", "op", "map", "Off", "_", "name", "out", "ori", "start", "obj", "ip", "offer", "addr", "order", "reset", "hand", "id", "ext", "att", "dev", "ref", "local", "origin", "raw", "o", "now", "low", "oa", "info", "block", "from", "f", "bind", "it", "boot", "ex", "OFF", "ff"], "bs": ["bm", "cs", "lbs", "os", "ops", "fps", "bed", "bits", "bles", "BS", "sb", "bb", "blog", "hz", "ubs", "bh", "bp", "ks", "bas", "bps", "rs", "gs", "bg", "bc", "ns", "bytes", "vs", "pb", "bid", "bos", "ps", "sys", "bl", "js", "bes", "obs", "fs", "bi", "ts", "aos", "ls", "cb", "ba", "stats", "ms", "boot", "b", "bis", "its", "bn"], "sector_len": ["tor_loc", "chip_l", "chip_lin", "sectorLengthlen", "sectorLengthli", "sector_l", "tor_len", "sector_loc", "sector_lin", "chip_size", "tor_val", "chip_fin", "sector67li", "sector_li", "sector_val", "sectorLengthlvl", "pixel_len", "sectorLengthsize", "chip_Len", "sector_lvl", "sector_size", "sector_fin", "tor_fin", "sector67size", "pixel_lvl", "sector_Len", "chip_li", "pixel_li", "sector67len", "sector67lvl", "pixel_size"], "nb_blocs": ["nb_BLOCes", "nb_blocis", "nb_bloces", "nb_bligs", "nb_blocationses", "nb_blocationsitions", "nb_bloadals", "nb_blOCS", "nb_blOCals", "nb_blociS", "nb_bliges", "nb_bloads", "nb_blOCes", "nb_glOCs", "nb_blocies", "nb_glOCals", "nb_glocS", "nb_bloced", "nb_blOCitions", "nb_BLoces", "nb_blocals", "nb_bliged", "nb_blocS", "nb_blOCs", "nb_blocationss", "nb_bloadS", "nb_glocs", "nb_blOCed", "nb_BLOCitions", "nb_BLoced", "nb_bloades", "nb_blocials", "nb_glOCS", "nb_BLOCs", "nb_bligitions", "nb_BLOCed", "nb_gloces", "nb_BLocs", "nb_blocitions", "nb_blocationsed", "nb_glOCes", "nb_BLocitions", "nb_glocals"], "nb_mappings": ["nb_links", "nb_Mappings", "nb_lappers", "nb_Mappers", "nb_masks", "nb_Minks", "nb_sairs", "nb_mairs", "nb_Mapper", "nb_lasks", "nb_matappings", "nb_sappers", "nb_fairs", "nb_fappers", "nb_fappings", "nb_fapper", "nb_Mairs", "nb_sapper", "nb_mapper", "nb_matinks", "nb_mappers", "nb_matasks", "nb_matappers", "nb_sappings", "nb_Masks", "nb_minks", "nb_lappings"], "id0": ["sid1", "kid00", "sid0", "id8", " id5", "ID8", "id5", "rid0", "ID00", "sid00", " id8", "rid00", "sid2", "kid0", "rid5", "rid8", "id00", "kid1", " id00", "kid2", "ID0", "ID5"], "id1": [" id11", "id8", "id01", "ID01", "kid3", "ID8", "id11", " id01", "ID11", "ident1", "ID2", "ident11", " id8", "ID3", "kid0", "ID1", "kid8", "ident01", "kid1", "ID0", "ident2"], "id2": [" id4", " id5", "id5", "Id1", "type5", "ident1", "vid4", "Id4", "id4", "id02", " id02", "vid5", "ident02", "ident4", "type4", "type2", "vid2", "vid02", "Id02", "Id2", "type02", "ident2"], "id3": ["Id3", " id4", " id5", "Id5", "id5", "oid3", "oid23", "id23", "ID2", "sid03", "ID4", "id4", "ID3", "sid2", " id03", "ID03", " id23", "oid5", "id03", "sid3", "Id03", "Id23", "sid4", "oid03"], "unlock_addr0": ["unlock2addr0", "unlock2ptr3", "unlock2addr_", "unlock_id0", "unlock_id3", "unlock_id2", "unlock_ptr_", "unlock_ptr1", "unlock_mt3", "unlock2ptr_", "unlock_addr2", "unlock_mt_", "unlock2ptr0", "unlock_addr_", "unlock2addr3", "unlock_address0", "unlock_address_", "unlock_ptr2", "unlock_mt0", "unlock_address3", "unlock_id1", "unlock_ptr0", "unlock_ptr3", "unlock_addr3"], "unlock_addr1": ["unlock_dr01", "unlock_dr3", "unlock_ptr1", "unlock_addr01", "unlock_addr2", "unlock_dr2", "unlock_ptr2", "unlock_dr1", "unlock_ptr01", "unlock_ptr3", "unlock_addr3"], "pfl": ["pll", " pft", " psl", "policygl", "npfl", "mfr", "pifl", "ipcoll", "pcsl", "expfl", " pcoll", "Pform", "pcoll", "parsefly", "pacoll", "pval", "ppkl", "pingval", "pcff", "pFL", "formfil", "pingcoll", "preflo", "csl", "prepol", "pift", "pipt", "parfil", "expgl", "Pkl", "apfd", "clientpol", "pfil", "policyfc", "pingFL", " ppl", "cpfd", " pll", " pkl", "ipfl", "mpl", "expfd", "pingfl", " pgl", "cpflo", "apfl", "parsell", "pingfd", " pFl", "pcfil", "mfl", "pcf", "Pfr", "pject", "formflo", "pifd", "Pfc", "psl", "cpFL", "policyfl", "pingfol", " pval", "pingfc", "cppl", "Psw", "apll", "pinll", " pcompl", "pcfd", "patt", " pfc", "Pfl", "expfil", "pingcompl", "parsefr", "expfr", "pingpol", "pinfl", "pingflo", " pfd", "pipl", "pisw", "cpkl", "pfc", " pfol", "pcfol", " pfil", "pcft", " pform", "patvl", "Pgl", "parsecompl", "pafl", "exppol", "piform", "pif", "cfl", "pinpol", "apff", "pvl", "ipform", "pFl", "pfr", "pcpol", "cpfp", " poft", "postvl", "postoft", " psw", "pcll", "PFL", "ppflo", "pcpt", "Pfp", "ipFL", "pcflo", "cpf", "patcompl", "ppFl", "pafd", "clientfol", " pf", "parsepl", "pingfly", "nppl", "parsevl", "pff", "pcompl", "Ply", "formpol", "mFl", "clientf", "pcfc", "pafol", "npfd", "pcatt", "pcfl", "pft", "parval", "clientfp", "patfl", "ppl", " pfp", "ppol", "formfl", "pf", "apject", " pvl", "cpatt", "expflush", "parfl", " pfr", "ply", "pform", "apsl", "clientcompl", "pkl", "ppfr", "pfly", "expfc", " ppol", "cpfr", "pingflush", "Pflo", "pigl", "psw", " ppt", "patoft", "parseflo", "Psl", "PFl", "pifr", "clientfil", "pfol", "parsefl", "clientfl", "cpsl", "postfl", "ppfl", "cpff", "pckl", "prefl", "appl", " pFL", " pfly", "pinkl", "pflo", "pfp", "pingpl", "cpFl", "cFl", "pcflush", "npfr", "pflush", "Pflush", "pfd", "Pcoll", "pival", "picompl", "ppt", "expvl", "postcompl", "expkl", "policyvl", "pingvl", "cflo", "ppatt", "parsely", "clientFL", "pingll", "pgl", "Pfd", "poft", "parform", "ppfp", "Ppl", "expcompl", " pflo", "prefil", " pflush", "cpfl", " ply", "clientflo", " pject", "pifil", "pill", "piject"], "chip_len": ["chip_num", "chip_loss", "chipxls", "pixel_en", "sector_ls", "chipmopsize", "nice_loc", "chipxlen", "pixel_mem", "chip_loc", "sector_loc", "chipxnum", "chip33len", "chip_size", "chip33lim", "sector_num", "pixel_len", "chip_del", "chipxlength", "chipmoplen", "nice_loss", "nice_len", "sector_lim", "chip33compl", "sector_del", "chip_mem", "chip_length", "chip_ls", "chip_min", "chip_vec", "chipmoploc", "chip_en", "nice_size", "chip_addr", "chipmoploss", "chip33del", "chip_lim", "chip_compl", "sector_addr", "sector_length", "pixel_vec", "sector_compl", "sector_min"]}}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n", "idx": 16422, "substitutes": {"s": ["hs", "ds", "sam", "cs", "os", "ops", "sl", "t", "p", "sb", "ess", "ses", "als", "sq", "store", "aws", "h", "sm", "is", "e", "sv", "rs", "sa", "gs", "S", "ss", "d", "v", "sts", "ns", "se", "obj", "sys", "js", "service", "c", "es", "ats", "n", "fs", "space", "state", "ts", "ls", "ains", "sim", "ms", "serv", "states"], "path": ["eth", "box", "w", "p", "md", "th", "PATH", "device", "ata", "prefix", "node", "prop", "name", "mat", "partial", "pod", "pointer", "kind", "msg", "cmd", "pt", "ath", "ref", "template", "host", "str", "transform", "piece", "key", "alias", "module", "pred", "txt", "pattern", "chain", "full", "text", "Path", "m"], "mode": ["mem", "mac", "perm", "size", "deg", "im", "de", "max", "mm", "md", "mit", "test", "power", "move", "mod", "ace", "ase", "command", "mt", "name", "pro", "mask", "MODE", "spec", "data", "range", "role", "dm", "member", "def", "Mode", "ode", "dim", "key", "module", "tm", "type", "mid", "code", "dem", "status", "m"]}}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int check_physical (CPUState *env, mmu_ctx_t *ctx,\n\n                           target_ulong eaddr, int rw)\n\n{\n\n    int in_plb, ret;\n\n\n\n    ctx->raddr = eaddr;\n\n    ctx->prot = PAGE_READ;\n\n    ret = 0;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL_4xx:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 16431, "substitutes": {"env": ["init", "cv", "here", "ov", "np", "server", "eng", "t", "window", "tx", "ei", "desc", "proc", "en", "vt", "ec", "enter", "enc", "app", "end", "eni", "nv", "e", "buf", "conf", "exc", "equ", "config", "cur", "global", "eas", "hw", "ku", "v", "uv", "esc", "ew", "obj", "ve", "era", "vs", "ef", "gear", "vm", "conn", "cmd", "inv", "ext", "den", "dev", "ev", "context", "et", "NV", "act", "erd", "er", "viron", "info", "network", "vv", "rod", "net", "ah", "code", "org", "event", "eh", "worker", "environment"], "ctx": ["ctl", "cv", "history", "loc", "np", "tc", "nt", "ck", "tx", "qu", "p", "dt", "proc", "mc", "acl", "kt", "unc", "buf", "conf", "cf", "config", "crit", "jac", "cc", "ct", "bc", "kw", "conv", "alloc", "etc", "pg", "hw", "obj", "addr", "conn", "req", "cmd", "pkg", "func", "mk", "context", "cmp", "tk", "ctrl", "cfg", "act", "x", "cb", "nc", "anc", "xc", "resp", "cp", "abc", "ac", "exec", "sc", "Conn"], "eaddr": ["eeddriver", "awder", "reamder", "oadDR", "ader", "ddDR", "ewer", "eddder", "ewder", "alkder", "rollDR", " elDR", "alkdr", " eldress", "awr", "edder", " oxDR", "reamdriver", "edddriver", "adr", "eedDR", "aedtr", "oadhr", "alkdriver", "ddr", "eadr", " oxhr", "reamDR", "eadhr", "adder", "ewdriver", "oadtr", "addr", "rollr", " oxdr", "oader", "edddr", "rolldriver", "awer", "rolldr", "dddr", " oxdress", " eldr", "eddtr", "eadDR", " elhr", "eaddriver", "eadder", "eedder", "alker", "reamdr", "oaddress", "dddriver", "eaddress", "eddr", "ewdr", "aeddr", "eeddr", "eadtr", "oaddr", "eader", "aeder", "awdr", "eddDR"], "rw": ["rew", "wp", "w", " rc", "rx", "iw", "aw", "rt", "rr", "nw", " shr", "kw", "xf", " w", "wr", "sw", "hw", "ew", "wb", "wa", "wx", "nb", "rd", "r", "rss", "wn", "RW", "rb", "rh", "nr", "fw", "vr", "write", "rf", "rack", "tw", "rl"], "in_plb": ["in2plad", "in_plbs", "in_plad", "in_pla", "in_perz", "in_cld", "in2ipla", "in_pcb", "in2iplB", "in_plz", "in_palB", "in2plb", "in___PLd", "in_PLd", "in_ld", "in_plB", "in_pcB", "in2plB", "in___PLx", "in_PLa", "in2iplad", "in_palb", "in___pla", "in_palad", "in2pla", "in_ipla", "in_lx", "in_iplad", "in_pcad", "in___plx", "in_lb", "in_perb", "in_iplb", "in___PLa", "in___PLb", "in_PLx", "in2iplb", "in_clb", "in_PLb", "in_pld", "in_pala", "in_iplB", "in_plx", "in_la", "in_clx", "in_cla", "in___plb", "in_perbs", "in___pld", "in_pca"], "ret": ["rm", "res", "nt", "deg", "back", "flag", "t", "ter", "desc", "num", "result", "Ret", "rt", "count", "tr", "mt", "nz", "out", "conv", "off", "ptr", "cont", "ft", "rem", "pet", "RET", "reset", "re", "gb", "rev", "cmd", "att", "rot", "rel", "ref", "val", "def", "print", "usr", "alt", "pert", "txt", "len", "resp", "f", "gt", "fun", "over", "elt", "status", "rets"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_xvmc_field_end(MpegEncContext *s)\n\n{\n\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n\n    assert(render);\n\n\n\n    if (render->filled_mv_blocks_num > 0)\n\n        ff_mpeg_draw_horiz_band(s, 0, 0);\n\n}\n", "idx": 16437, "substitutes": {"s": ["a", "ds", "cs", "sg", "t", "p", "sb", "as", "ses", "ins", "details", "sq", "h", "set", "qs", "is", "e", "sv", "rs", "gs", "S", "ss", "session", "ns", "sts", "v", "ps", "js", "c", "ats", "comm", "fs", "ts", "ls", "sac", "f", "stats", "ms", "spec", "b", "m"], "render": ["snap", "frame", "spr", "res", "eng", "format", "nder", "plot", "proc", "report", "result", "h", "rect", "end", "html", "buf", "fr", "config", "run", "rend", "match", "save", "stat", "select", "Render", "feat", "rev", "re", "update", "cmd", "data", "review", "r", "field", "rendered", "tag", "prof", "draw", "raw", "transform", "print", "pair", "reflect", "respond", "view", "vr", "f", "bind", "spec", "pen", "material"]}}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 16449, "substitutes": {"mr": ["bm", "br", "rm", " MR", "wm", "mc", "ml", "RM", "kr", "hr", "adr", "rs", "shr", "rr", "mn", "mt", "m", "dr", "rar", "Mr", "mp", "hm", "mx", "r", "mk", "gr", "MT", "MR", "rg", "rb", "sr", "rn", "rh", "vr", "ms", "drm", " rm"]}}
{"project": "FFmpeg", "commit_id": "c96f3750c22ef1576a46140f3101e3585041f41f", "target": 0, "func": "pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)\n\n{\n\n    char temp[GET_MODE_BUFFER_SIZE];\n\n    char *p= temp;\n\n    static const char filterDelimiters[] = \",/\";\n\n    static const char optionDelimiters[] = \":\";\n\n    struct PPMode *ppMode;\n\n    char *filterToken;\n\n\n\n    ppMode= av_malloc(sizeof(PPMode));\n\n\n\n    ppMode->lumMode= 0;\n\n    ppMode->chromMode= 0;\n\n    ppMode->maxTmpNoise[0]= 700;\n\n    ppMode->maxTmpNoise[1]= 1500;\n\n    ppMode->maxTmpNoise[2]= 3000;\n\n    ppMode->maxAllowedY= 234;\n\n    ppMode->minAllowedY= 16;\n\n    ppMode->baseDcDiff= 256/8;\n\n    ppMode->flatnessThreshold= 56-16-1;\n\n    ppMode->maxClippedThreshold= 0.01;\n\n    ppMode->error=0;\n\n\n\n    memset(temp, 0, GET_MODE_BUFFER_SIZE);\n\n    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: %s\\n\", name);\n\n\n\n    for(;;){\n\n        char *filterName;\n\n        int q= 1000000; //PP_QUALITY_MAX;\n\n        int chrom=-1;\n\n        int luma=-1;\n\n        char *option;\n\n        char *options[OPTIONS_ARRAY_SIZE];\n\n        int i;\n\n        int filterNameOk=0;\n\n        int numOfUnknownOptions=0;\n\n        int enable=1; //does the user want us to enabled or disabled the filter\n\n\n\n        filterToken= strtok(p, filterDelimiters);\n\n        if(filterToken == NULL) break;\n\n        p+= strlen(filterToken) + 1; // p points to next filterToken\n\n        filterName= strtok(filterToken, optionDelimiters);\n\n        av_log(NULL, AV_LOG_DEBUG, \"pp: %s::%s\\n\", filterToken, filterName);\n\n\n\n        if(*filterName == '-'){\n\n            enable=0;\n\n            filterName++;\n\n        }\n\n\n\n        for(;;){ //for all options\n\n            option= strtok(NULL, optionDelimiters);\n\n            if(option == NULL) break;\n\n\n\n            av_log(NULL, AV_LOG_DEBUG, \"pp: option: %s\\n\", option);\n\n            if(!strcmp(\"autoq\", option) || !strcmp(\"a\", option)) q= quality;\n\n            else if(!strcmp(\"nochrom\", option) || !strcmp(\"y\", option)) chrom=0;\n\n            else if(!strcmp(\"chrom\", option) || !strcmp(\"c\", option)) chrom=1;\n\n            else if(!strcmp(\"noluma\", option) || !strcmp(\"n\", option)) luma=0;\n\n            else{\n\n                options[numOfUnknownOptions] = option;\n\n                numOfUnknownOptions++;\n\n            }\n\n            if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;\n\n        }\n\n        options[numOfUnknownOptions] = NULL;\n\n\n\n        /* replace stuff from the replace Table */\n\n        for(i=0; replaceTable[2*i]!=NULL; i++){\n\n            if(!strcmp(replaceTable[2*i], filterName)){\n\n                int newlen= strlen(replaceTable[2*i + 1]);\n\n                int plen;\n\n                int spaceLeft;\n\n\n\n                if(p==NULL) p= temp, *p=0;      //last filter\n\n                else p--, *p=',';               //not last filter\n\n\n\n                plen= strlen(p);\n\n                spaceLeft= p - temp + plen;\n\n                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){\n\n                    ppMode->error++;\n\n                    break;\n\n                }\n\n                memmove(p + newlen, p, plen+1);\n\n                memcpy(p, replaceTable[2*i + 1], newlen);\n\n                filterNameOk=1;\n\n            }\n\n        }\n\n\n\n        for(i=0; filters[i].shortName!=NULL; i++){\n\n            if(   !strcmp(filters[i].longName, filterName)\n\n               || !strcmp(filters[i].shortName, filterName)){\n\n                ppMode->lumMode &= ~filters[i].mask;\n\n                ppMode->chromMode &= ~filters[i].mask;\n\n\n\n                filterNameOk=1;\n\n                if(!enable) break; // user wants to disable it\n\n\n\n                if(q >= filters[i].minLumQuality && luma)\n\n                    ppMode->lumMode|= filters[i].mask;\n\n                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))\n\n                    if(q >= filters[i].minChromQuality)\n\n                            ppMode->chromMode|= filters[i].mask;\n\n\n\n                if(filters[i].mask == LEVEL_FIX){\n\n                    int o;\n\n                    ppMode->minAllowedY= 16;\n\n                    ppMode->maxAllowedY= 234;\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        if(  !strcmp(options[o],\"fullyrange\")\n\n                           ||!strcmp(options[o],\"f\")){\n\n                            ppMode->minAllowedY= 0;\n\n                            ppMode->maxAllowedY= 255;\n\n                            numOfUnknownOptions--;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == TEMP_NOISE_FILTER)\n\n                {\n\n                    int o;\n\n                    int numOfNoises=0;\n\n\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        char *tail;\n\n                        ppMode->maxTmpNoise[numOfNoises]=\n\n                            strtol(options[o], &tail, 0);\n\n                        if(tail!=options[o]){\n\n                            numOfNoises++;\n\n                            numOfUnknownOptions--;\n\n                            if(numOfNoises >= 3) break;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK\n\n                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){\n\n                    int o;\n\n\n\n                    for(o=0; options[o]!=NULL && o<2; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        if(o==0) ppMode->baseDcDiff= val;\n\n                        else ppMode->flatnessThreshold= val;\n\n                    }\n\n                }\n\n                else if(filters[i].mask == FORCE_QUANT){\n\n                    int o;\n\n                    ppMode->forcedQuant= 15;\n\n\n\n                    for(o=0; options[o]!=NULL && o<1; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        ppMode->forcedQuant= val;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        if(!filterNameOk) ppMode->error++;\n\n        ppMode->error += numOfUnknownOptions;\n\n    }\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppMode->lumMode, ppMode->chromMode);\n\n    if(ppMode->error){\n\n        av_log(NULL, AV_LOG_ERROR, \"%d errors in postprocess string \\\"%s\\\"\\n\", ppMode->error, name);\n\n        av_free(ppMode);\n\n        return NULL;\n\n    }\n\n    return ppMode;\n\n}\n", "idx": 16452, "substitutes": {"name": ["a", "mem", "word", "ame", "format", "size", "filename", "w", "comment", "t", "term", "base", "prefix", "length", "Name", "letter", "out", "v", "label", "time", "data", "c", "id", "common", "n", "path", "key", "alias", "package", "source", "title", "null", "len", "buffer", "filter", "names", "NAME", "part", "code", "version", "file", "type"], "quality": ["priority", "format", "weight", "comment", "depth", "equality", "q", "level", "scale", "ness", "qual", "distance", "confidence", "language", "length", "ity", "Quality", "limit", "media", "value", "Q", "condition", "availability", "sequence", " Quality", "frequency", "version", "mode"], "temp": ["mem", "tim", "tc", "memory", "t", "w", "ta", "max", "mm", "var", "input", "result", "test", "pid", "base", "tem", "buf", "empty", "tmp", "prefix", "vp", "tr", "Temp", "out", "v", "ptr", "iter", "ps", "mp", "data", "c", "pi", "pt", "jp", "template", "current", "raw", "unt", "n", "cu", "cache", "txt", "null", "tm", "pre", "type", "cp", "buffer", "emp", "mode", "m"], "p": ["pos", "lp", "t", "w", "wp", "pr", "pp", "ping", "sp", "pad", "q", "h", "bp", "pid", "at", "pc", "g", "tmp", "vp", "tp", "position", "d", "v", "start", "ps", "mp", "c", "pi", "pt", "pkg", "up", "j", "post", "ph", "n", "pl", "pa", "ep", "cp", "f", "it", "fp", "P", "b", "y", "ap", "m"], "filterDelimiters": ["filterDelipiterors", "filterDelimitizters", "filterDelamitsERS", "filterDelimitors", "filterDelamitsters", "filterDelimitsERS", "filterDelimiterERS", "filterDelamitsers", "filterDelipitors", "filterDelipiterters", "filterDelimITer", "filterDelimitizors", "filterDelimitters", "filterDelamitERS", "filterDelimiterters", "filterDelimiterer", "filterDelipiterers", "filterDelimitser", "filterDelimiterers", "filterDelimiterors", "filterDelamiter", "filterDelimITers", "filterDelimitizers", "filterDelimitsers", "filterDelimitsors", "filterDelipiters", "filterDelamiters", "filterDelipitERS", "filterDelimitsters", "filterDelimitERS", "filterDelimiter", "filterDelimITters", "filterDelamitters", "filterDelimitizERS", "filterDelamitser", "filterDelimITERS", "filterDelipitters", "filterDelipiterERS"], "optionDelimiters": ["optionDelemitsters", "optionDelimitERS", "optionDelimmitERS", "optionDelimitizters", "optionDelamitERS", "optionDelimritters", "optionDelimitsers", "optionDelimitators", "optionDelimmiters", "optionDelemitters", "optionDelimiterators", "optionDelimriter", "optionDelimITers", "optionDelimiterers", "optionDelimriters", "optionDelimiterERS", "optionDelemitsators", "optionDelimITters", "optionDelimitsators", "optionDelamiters", "optionDelamitsERS", "optionDelamitsers", "optionDelimitsors", "optionDelimitizERS", "optionDelimitsERS", "optionDelemiters", "optionDelemiter", "optionDelemitser", "optionDelimITer", "optionDelimitser", "optionDelemitators", "optionDelimiterer", "optionDelimmITer", "optionDelamitsters", "optionDelimitizers", "optionDelimiterters", "optionDelimITERS", "optionDelimiterors", "optionDelamitsors", "optionDelamitters", "optionDelimitsters", "optionDelimritators", "optionDelimmiter", "optionDelimmITers", "optionDelimmitters", "optionDelimitors", "optionDelemitsers", "optionDelamitors", "optionDelimiter", "optionDelimitizors", "optionDelimmITters", "optionDelimitters", "optionDelimmITERS"], "ppMode": [" ppMODE", "ppMu", "ptModel", "plMode", "xxModule", "cpMode", "pingModule", "ppMod", "cpMod", "portMod", "PPMu", "ppForce", "bpTheme", "plMODE", "cppMu", "ptTheme", "ppUser", "ppeForce", "ppoMu", " ppMember", "appMode", "suppMode", "oppDef", "xxMODE", "ppoMODE", "pportStyle", " ppUser", "ppStyle", "pingTheme", "pMODE", "cpTheme", "procMODE", "pportRole", " ppTheme", "ppeTheme", "oppMu", "xxMode", "ppModule", "oppForce", "pgMod", "dpMode", "plRole", "pMod", "portMODE", "pdMode", "PPMode", "portMode", "pdMod", "oppEngine", "phpTheme", " ppMod", " ppStyle", "cppModule", " ppModule", "ppoUser", "ptMod", "oppMODE", "oppMode", "portEngine", "PPSettings", "procMode", "ppoMod", "suppModel", "procSettings", "cppSession", "cppMode", "oppModule", "dpMODE", "ppoSession", "oppUser", "pingMode", "ppEngine", "procModule", "bpMod", "ppeMode", "PPTheme", "pMode", "pxMode", "ppoEngine", "appModule", "ppMember", "ppTheme", " ppSettings", "cppMODE", "pportMODE", "oppMod", "PPModule", "cppTheme", "pgMode", "ppoForce", "cppDef", "appTheme", "dpMod", "suppMod", "pxMod", "appMODE", "pEngine", "ppSettings", "dpMember", "pxMODE", "suppTheme", "xxTheme", "phpMu", "ppSession", "ppDef", "pdModule", " ppRole", "ppoModule", "ppoTheme", " ppEngine", "oppTheme", "phpSession", "pgModel", "ptMode", "pportMode", "plStyle", "phpMode", "cppEngine", "pxMember", "cpModule", "pdUser", "PPMODE", "bpMode", " ppDef", "ppoMode", "ppRole", "bpModule", "pgTheme", "ppeUser", "ppModel", "pingMu", "ppMODE"], "filterToken": ["frequencyTO", "filType", "filName", "sorttoken", "frequencyTokens", "filterNode", "formatToken", "profileTokens", "transformNode", "profileToken", "filToken", "transformName", "sortToken", " filterParser", "sortNode", "filInitial", "formattoken", "formatName", "FilterToken", " filterNode", " filterTokens", "filterParser", "transformInitial", "profiletoken", " filtertoken", "transformTokens", "filterTO", "filterType", "profileTO", "filterTok", "FilterName", "transformToken", "filtertoken", "frequencyToken", "frequencytoken", "FilterType", "sortType", "FilterTokens", "sortName", "filterTokens", "transformParser", " filterTO", "filterInitial", "FilterInitial", "sortParser", "filTok", "FilterTok", "transformTok"], "filterName": ["filName", "filType", "filterCount", "stopNames", "stopName", "sortNAME", " filterNAME", "stopNAME", "formatToken", "tagTag", "filToken", "formatKey", "sortToken", "mapToken", "hashNAME", "profileNAME", "filterNAME", "mapName", "optionType", " filtername", "filterKey", "optionToken", "formatName", "sortname", " filterKey", "FilterToken", "tagKey", "filterNames", " filterType", "mapname", "profileCount", "filterTag", " filterCount", "tagName", "hashCount", "tagToken", "filterType", "hashName", "formatTag", "FilterName", "stopToken", " filterNames", "profileName", "sortName", "mapNAME", "FilterNames", "filtername", "hashname", "profilename", "optionName", " filterTag", "optionNAME", "filNAME", "FilterNAME"], "option": ["channel", "item", "question", "opt", "comment", "translation", "term", "menu", "timeout", "test", "feature", "zero", "action", "point", "empty", "op", "prefix", "command", "other", "second", "operation", "unit", "label", "ption", "select", "instance", "value", "optional", "argument", "record", "TION", "field", "condition", "tag", "relation", "table", "pair", "key", "alias", "alt", "cho", "attribute", "block", "open", "section", "consider", "entry", "Option", "filter", "trial", "event", "answer", "category"], "options": ["ptions", "times", "ops", "args", "opt", "settings", "flags", "bits", "events", "terms", "members", "results", "vals", "pins", "values", "tags", "Options", "styles", "errors", "weights", "ts", "actions", "params", "names", "versions", "objects", "comments"], "OPTIONS_ARRAY_SIZE": ["OPTIONS_ARRAY_Size", "OPTIONS_ARRAY_POS", "OPTIONS_ARArray_SIZE", "OPTIONS_ARArray_Size", "OPTIONS_ARRAY_TYPE", "OPTIONS_ARArray_TYPE", "OPTIONS_ARArray_POS"], "i": ["index", "l", "t", "ci", "li", "e", "ni", "I", "ai", "limit", "ip", "mi", "pi", "c", "in", "id", "j", "r", "n", "info", "x", "f", "it", "b", "y", "ii", "m"], "numOfUnknownOptions": ["numOfunknownItems", "numofKnownOptions", "numofUnknownItems", "numofUnknownOption", "numOfUnknownOption", "numofUnknownOptions", "numOfInvalidValues", "numOfKnownOption", "numOfUnknownItems", "numOfKnownOptions", "numOfKnownItems", "numofUnknownValues", "numOfInvalidOption", "numofKnownOption", "numOfunknownOptions", "numofKnownValues", "numofKnownItems", "numOfunknownOption", "numOfunknownValues", "numOfUnknownValues", "numOfKnownValues", "numOfInvalidOptions", "numOfInvalidItems"], "error": ["offset", "debug", "comment", "result", "timeout", "Error", "feature", "volume", "ERROR", "command", "address", "bug", "progress", "value", "success", "order", "warning", "ror", "extra", "rank", "errors", "info", "ack", "loss", "alpha", "danger", "err", "type"]}}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16465, "substitutes": {"bs": ["bm", "hs", "ds", "cs", "lbs", "os", "fps", "outs", "bits", "BS", "sb", "ses", "blog", "ubs", "bh", "bp", "bps", "rs", "gs", "ss", "bc", "aus", "ubis", "ns", "sts", "vs", "pb", "bos", "bl", "ps", "bes", "js", "iss", "http", "obs", "cks", "fs", "acs", "ts", "aos", "ls", "locks", "ims", "asis", "ms", "b", "bis", "its"], "l1_index": ["l1__index", "l0_Index", "l1_Index", "l1__x", "l1__address", "l1_ind", "l0_address", "l0_ind", "l0_x", "l0_index", "l1__ind", "l1_address", "l1_x", "l1_sequence", "l0_sequence"], "s": ["a", "ies", "hs", "ds", "cs", " ss", "os", "bits", "sb", "p", "ses", "ins", "ubs", "h", "qs", "is", "sv", "rs", "gs", "sa", "S", "plays", "ss", "sts", "ns", "v", "vs", "ps", "http", "sys", "js", "spec", "css", "ats", "gets", "fs", "less", "acs", "ts", "ssl", "ls", "ims", "locks", "stats", "sis", "b", "bis", "its"], "buf": ["next", "mem", "cap", "cv", "Buff", "box", "window", "img", "tx", "desc", "var", "p", "bar", "result", "rw", "port", "bp", "ctx", "vec", "cam", "cf", "cur", "tmp", "tr", " buffer", "queue", "bc", "off", "out", "ctr", "db", " vec", "pb", "iter", "bl", "doc", "wb", "tab", "obj", "data", "cmd", "msg", "page", "pkg", "priv", "pool", "raw", "pack", "str", "usr", "rb", "cache", "txt", "cb", "block", "nm", "uf", "cp", "buffer", "Buffer", "buff", "code", "b", "seq", "br", "err", "dq"], "l1_start_index": ["l1_start_i", "l1_end_line", "l1_end_Index", "l1_start_Index", "l1_end_ind", "l1_end_i", "l1_start_ind", "l1_end_status", "l1_start_num", "l1_start_line", "l1_end_data", "l1_startdIndex", "l1_end_num", "l1_end_position", "l1_end_location", "l1_end_index", "l1_start_data", "l1_start_status", "l1_start_position", "l1_startdlocation", "l1_start_location", "l1_startddata", "l1_startdindex"], "i": ["init", "ic", "index", "ij", "l", "si", "or", "ci", "im", "ki", "qi", "me", "port", "li", "is", "\u0438", "e", "point", "I", " ii", "u", "ai", "phi", "io", "di", " mi", "iter", "ip", "mi", "pi", "c", "ind", " j", "id", "j", "xi", "in", "inner", "r", "ti", "ui", "batch", "gi", "o", " I", "n", "multi", "print", "uri", "fi", "bi", "ji", "x", "ims", " ni", "zi", "ini", "sim", "ie", "it", "ix", "iu", "y", "ii", "m"], "ret": ["rm", "nt", "res", "pret", "arr", "t", "back", "deg", "ter", "dt", "result", "ll", "Ret", "ne", "rt", "expr", "gc", "arg", "tr", "mt", "nz", "out", "cont", "ft", " Ret", "rem", "pt", "cat", "reset", "RET", "re", "det", "nl", "cmd", "try", "att", "reply", "ext", "ref", "r", "lit", "plain", "val", "jp", "def", "print", "pat", "fi", "usr", "alt", "del", "txt", "tail", "len", "cert", "resp", "net", "not", "it", "gt", "fun", "elt", "red", "rets"]}}
{"project": "qemu", "commit_id": "f46e9a0b9911fcfbc13f85f3a8808067990a0f5c", "target": 0, "func": "static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n\n{\n\n    uintptr_t host_start, host_map_start, host_end;\n\n\n\n    last_bss = TARGET_PAGE_ALIGN(last_bss);\n\n\n\n    /* ??? There is confusion between qemu_real_host_page_size and\n\n       qemu_host_page_size here and elsewhere in target_mmap, which\n\n       may lead to the end of the data section mapping from the file\n\n       not being mapped.  At least there was an explicit test and\n\n       comment for that here, suggesting that \"the file size must\n\n       be known\".  The comment probably pre-dates the introduction\n\n       of the fstat system call in target_mmap which does in fact\n\n       find out the size.  What isn't clear is if the workaround\n\n       here is still actually needed.  For now, continue with it,\n\n       but merge it with the \"normal\" mmap that would allocate the bss.  */\n\n\n\n    host_start = (uintptr_t) g2h(elf_bss);\n\n    host_end = (uintptr_t) g2h(last_bss);\n\n    host_map_start = (host_start + qemu_real_host_page_size - 1);\n\n    host_map_start &= -qemu_real_host_page_size;\n\n\n\n    if (host_map_start < host_end) {\n\n        void *p = mmap((void *)host_map_start, host_end - host_map_start,\n\n                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n        if (p == MAP_FAILED) {\n\n            perror(\"cannot mmap brk\");\n\n            exit(-1);\n\n        }\n\n\n\n        /* Since we didn't use target_mmap, make sure to record\n\n           the validity of the pages with qemu.  */\n\n        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);\n\n    }\n\n\n\n    if (host_start < host_map_start) {\n\n        memset((void *)host_start, 0, host_map_start - host_start);\n\n    }\n\n}\n", "idx": 16483, "substitutes": {"elf_bss": ["elf_rsc", "elf_rbcss", "elf_arbsy", "elf_rbsy", "elf_bSS", "elf_gsc", "elf__bss", "elf___bcss", "elf_rss", "elf___rbcss", "elf___bsy", "elf_arbss", "elf_bsy", "elf_gss", "elf__pss", "elf__bsc", "elf_psc", "elf_pSS", "elf_gSS", "elf_bcss", "elf___rbass", "elf_pass", "elf_rboss", "elf__pst", "elf_pst", "elf_rbess", "elf__bSS", "elf___rbsy", "elf_gst", "elf_rSS", "elf_arbcss", "elf___bss", "elf_rbass", "elf_bess", "elf___bass", "elf___rbss", "elf__psc", "elf_pcss", "elf_bass", "elf_poss", "elf__bst", "elf_psy", "elf__pSS", "elf_arbass", "elf_pess", "elf_boss", "elf_bsc", "elf_rst", "elf_pss", "elf_rbss", "elf_bst"], "last_bss": ["last_bess", "last_abss", "last_abSS", "last_pcss", "last_nbss", "last_pss", "last_sbcss", "last_sbSS", "last_bass", "last_pess", "last_pass", "last_sboss", "last_vSS", "last_gst", "last_gss", "last_vcss", "last_vss", "last_bSS", "last_nbcss", "last_rass", "last_prss", "last_bcss", "last_blss", "last_rss", "last_aboss", "last_abcss", "last_bws", "last_fst", "last_fess", "last_gess", "last_brss", "last_nbws", "last_rbss", "last_fss", "last_sbss", "last_rbws", "last_gass", "last_fass", "last_rgn", "last_blcss", "last_grss", "last_pSS", "last_bst", "last_rbcss", "last_rcss", "last_rbSS", "last_blass", "last_nbSS", "last_poss", "last_bgn", "last_boss", "last_vws", "last_pgn", "last_blgn"], "prot": ["next", "offset", "eth", "style", "chron", "format", "lag", "bits", "phy", "prototype", "desc", "aff", "protected", "ht", "header", "virtual", "tif", " PROT", "prop", "tr", "stat", "mat", "method", "pro", "io", "tf", "ef", "cmd", "pkg", "ext", "rot", "def", "iot", "pat", "top", "platform", "Prot", "txt", " protocol", "net", "ocol", "phys", " proto", "tech", " protocols", "policy", "supported", "version", "seq", "col", "type"], "host_start": ["hosttoffset", "host_from", "host64begin", "host1next", "hosttstart", "node_end", "Host_end", "Host_start", "hosttend", " host_begin", "Host_try", "host09end", "node_begin", "host_base", "host64start", " host_Start", "node09next", "host09start", "node_start", "host_started", "node09begin", "host09begin", " host_base", "node_next", "host_Start", "host1begin", " host_first", "host_try", "host1start", "host_offset", "host_next", "node09end", "host1end", "Host_offset", "host09next", "host_first", "hosttfrom", "host_store", "host64first", " host_started", "Host_from", "Host_store", "node09start", "host64offset", " host_offset", "host_begin"], "host_map_start": ["host_map_need", "host_list_start", "host_set_begin", "host_set_start", "host_map_end", "host_cap_offset", "host_list_end", "host_list_size", "host_set_init", "host_cap_size", "host_cache_init", "host_set_end", "host_cache_start", "host_start_need", "host_mapingstep", "host_map_offset", "host_map_size", "host_cache_offset", "host_mapingstart", "host_mapingend", "host_cache_end", "host_start_start", "host_mapingneed", "host_map_init", "host_cache_left", "host_map_step", "host_cache_begin", "host_start_end", "host_map_begin", "host_cap_start", "host_cache_size", "host_map_stop", "host_start_step", "host_map_left"], "host_end": ["host_id", "port_ended", "Host_end", "Host_start", "localhost_stop", "host7end", "host7start", "localhost_size", "host_ending", "host_ends", "host_ended", "host_stop", "server_begin", "Host_End", "server_start", "localhost_id", "port_start", "port_end", "server_end", "localhost_end", "server_ends", "host7begin", "host_End", "host7ends", "port_End", "host_size", "Host_ending", "host_begin"], "p": ["lp", "np", "l", "perm", "t", "wp", "i", "pp", "ping", "q", "h", "pic", "imp", "pc", "g", "per", "u", "tp", "pro", "rep", "v", "d", "pb", "c", "pkg", "j", "r", "jp", "post", "pre", "pl", "pa", "cp", "php", "f", "fp", "pe", "P", "y", "ap", "m"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_biwgt_4x4multiple_msa(uint8_t *src,\n\n                                      int32_t src_stride,\n\n                                      uint8_t *dst,\n\n                                      int32_t dst_stride,\n\n                                      int32_t height,\n\n                                      int32_t log2_denom,\n\n                                      int32_t src_weight,\n\n                                      int32_t dst_weight,\n\n                                      int32_t offset_in)\n\n{\n\n    uint8_t cnt;\n\n    uint32_t load0, load1, load2, load3;\n\n    v16i8 src_wgt, dst_wgt, wgt;\n\n    v16i8 src0, src1, src2, src3;\n\n    v16i8 dst0, dst1, dst2, dst3;\n\n    v8i16 temp0, temp1, temp2, temp3;\n\n    v8i16 denom, offset, add_val;\n\n    int32_t val = 128 * (src_weight + dst_weight);\n\n\n\n    offset_in = ((offset_in + 1) | 1) << log2_denom;\n\n\n\n    src_wgt = __msa_fill_b(src_weight);\n\n    dst_wgt = __msa_fill_b(dst_weight);\n\n    offset = __msa_fill_h(offset_in);\n\n    denom = __msa_fill_h(log2_denom + 1);\n\n    add_val = __msa_fill_h(val);\n\n    offset += add_val;\n\n\n\n    wgt = __msa_ilvev_b(dst_wgt, src_wgt);\n\n\n\n    for (cnt = height / 4; cnt--;) {\n\n        LOAD_4WORDS_WITH_STRIDE(src, src_stride, load0, load1, load2, load3);\n\n        src += (4 * src_stride);\n\n\n\n        src0 = (v16i8) __msa_fill_w(load0);\n\n        src1 = (v16i8) __msa_fill_w(load1);\n\n        src2 = (v16i8) __msa_fill_w(load2);\n\n        src3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        LOAD_4WORDS_WITH_STRIDE(dst, dst_stride, load0, load1, load2, load3);\n\n\n\n        dst0 = (v16i8) __msa_fill_w(load0);\n\n        dst1 = (v16i8) __msa_fill_w(load1);\n\n        dst2 = (v16i8) __msa_fill_w(load2);\n\n        dst3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        XORI_B_4VECS_SB(src0, src1, src2, src3, src0, src1, src2, src3, 128);\n\n\n\n        XORI_B_4VECS_SB(dst0, dst1, dst2, dst3, dst0, dst1, dst2, dst3, 128);\n\n\n\n        ILVR_B_4VECS_SH(src0, src1, src2, src3, dst0, dst1, dst2, dst3,\n\n                        temp0, temp1, temp2, temp3);\n\n\n\n        temp0 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp0);\n\n        temp1 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp1);\n\n        temp2 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp2);\n\n        temp3 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp3);\n\n\n\n        SRA_4VECS(temp0, temp1, temp2, temp3,\n\n                  temp0, temp1, temp2, temp3, denom);\n\n\n\n        temp0 = CLIP_UNSIGNED_CHAR_H(temp0);\n\n        temp1 = CLIP_UNSIGNED_CHAR_H(temp1);\n\n        temp2 = CLIP_UNSIGNED_CHAR_H(temp2);\n\n        temp3 = CLIP_UNSIGNED_CHAR_H(temp3);\n\n\n\n        PCKEV_B_STORE_4_BYTES_4(temp0, temp1, temp2, temp3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n    }\n\n}\n", "idx": 16498, "substitutes": {"src": ["sc", "loc", "sort", "rol", "sel", "dist", "filename", "img", "sub", "ins", "st", "input", "sq", "rx", "rt", "scale", "bs", "syn", "buf", "cur", "rs", "load", "tmp", "copy", "length", "lb", "ctr", "ptr", "cont", "iv", "sys", "sn", "addr", "target", "in", "inst", "str", "raw", "obs", "usr", "source", "sr", "s", "rc", "scan", "sur", "urg", "url", "sl", "comp", "dest", "ser", "rl", "hl"], "src_stride": ["src_divride", "src_strid", "src_brice", "src_strine", "src_collope", "src_divider", "src_collage", "src_provage", "src_slide", "src_STRIDE", "src_strope", "src_STRider", "src_STRide", "src_tride", "src_trid", "src_provide", "src_gride", "src_brine", "src_strider", "src_trice", "src_grine", "src_divIDE", "src_slage", "src_brid", "src_strride", "src_slope", "src_depthride", "src_divide", "src_collice", "src_grice", "src_grid", "src_depthider", "src_strice", "src_depthide", "src_strIDE", "src_bride", "src_slice", "src_STRride", "src_trine", "src_depthIDE", "src_provope", "src_collide", "src_provice", "src_strage"], "dst": ["fddest", "ddest", "fdnd", "Dest", "Ddest", "fdst", "dnd", " dnd", "dest", "fdest", "Dnd", " ddest", "Dst", " dest"], "dst_stride": ["dst_drride", "dst_dride", "dst_strider", "dst_trid", "dst_collride", "dst_collid", "dst_trider", "dst_strride", "dst_tride", "dst_drid", "dst_trride", "dst_collider", "dst_drider", "dst_collide", "dst_strid"], "height": ["grow", "history", "index", "style", "size", "density", "window", "depth", "max", "tx", "th", "h", "ctx", "shift", "base", "volume", "count", "shape", "resolution", "padding", "length", "kw", "capacity", "read", "bottom", "range", "available", "through", "rows", "rank", "dim", "y", "cache", "x", "block", "row", "vol", "buffer", "chain", "ty", "Height", "status", "stack", "type"], "log2_denom": ["log2_genOM", "log2_deromin", "log2_donomin", "log2_donoms", "log2_Denot", "log2_derot", "log2_denOM", "log2_derOM", "log2_Denoms", "log2_denoms", "log2_Denormal", "log2_donormal", "log2_enot", "log2_Denum", "log2_derom", "log2_denomin", "log2_denum", "log2_enom", "log2_derum", "log2_DenOM", "log2_deroms", "log2_genomin", "log2_enOM", "log2_donom", "log2_genom", "log2_denormal", "log2_Denom", "log2_genoms", "log2_Denomin", "log2_enum", "log2_denot"], "src_weight": ["ssl_fee", "src___Weight", "src___power", "src___index", "srcitymean", "ack___index", "srcmymean", "src___hack", "ack___weight", "src_speed", "src_index", "srcmmweight", "ack___mean", "srcmmfee", "sslmmfee", "ssl_width", "srcmmwidth", "sslmmwidth", "src_hack", "sslmmspeed", "ctrl_Weight", "ssl_weight", "src2weight", "src2Weight", "ack_weight", "srcmyindex", "ctrl_weight", "ack_id", "srcityweight", "src_mean", "src_power", "src_Weight", "ack_mean", "srcmyweight", "src_fee", "ctrl_hack", "ack_index", "sslmmweight", "ack___id", "src___mean", "src2power", "src___id", "srcmyid", "ssl_speed", "src_id", "ctrl_power", "srcmmspeed", "srcityid", "srcityindex", "src___weight", "src_width", "src2hack"], "dst_weight": ["drc_link", "dnd_weights", "dst___money", "drc_default", "dstThemoney", "dstThefrequency", "dst_Weight", "dnd_weight", "dest_money", "dst___weight", "dst_money", "dst_link", "dst_power", "drc_weight", "dstTheweights", "dest_weights", "dnd_power", "dst_frequency", "dst_default", "dest_weight", "dnd_Weight", "dest_frequency", "dstTheweight", "dst_weights", "dst___weights", "dst___frequency"], "offset_in": ["offset_int", "offset___ex", "alias_nin", "alias_in", "alias___ex", "alias_gin", "offset2ex", "alias_ex", "scroll_ex", "set_in", "set_int", "offset67In", "offset____nin", "scroll____inc", "offset67gin", "scroll_in", " offset_IN", "offset67nin", " offset_In", "offset2in", "offset__int", "offset67IN", "offset_IN", "offset____inc", "offset__inc", "offset2inc", "alias___gin", "offset___nin", "scroll____in", "scroll____ex", "offset_nin", "offset_gin", "offset67in", "offset_ex", "offset2nin", "offset67ex", "alias___nin", "scroll_nin", " offset_cin", "offset_inc", "offset_cin", "offset___in", "set_inc", "scroll_inc", "offset_In", "offset___inc", "offset___gin", "offset____in", "offset____ex", "alias___in", "scroll____nin", "offset__in", "offset67cin"], "cnt": ["Cct", " cct", "unccount", "acNT", " count", "cnd", "cct", "count", "uncnt", "ccount", "pcnd", "Cnt", " cNT", "acount", "account", "acct", " ccount", "Count", "uncount", "cNT", "pcount", "CNT", "Cnd", "pcNT", "uncNT", "pcnt", "acnd", "Ccount", "acnt"], "load0": ["loader8", "pick1", "loader0", "pick0", "LOAD1", "load8", "loader1", "LOAD0", "pick8", "loader2", "LOAD2", " load8", "loader3"], "load1": ["loader11", "load11", "pick11", " load4", "loader01", "pick1", "read2", "require1", "loader3", "load10", "read1", "load4", "read10", " load11", "pick01", "pick2", "read4", "loader1", "load01", "require4", "require2", "loader2", "read3", " load01", " load10", "require10"], "load2": ["read02", "loader8", "loader02", "play2", "read2", "require1", " load02", "play3", "read1", "require3", "play1", "load8", "fail8", "loader1", "fail3", "require8", "require2", "loader2", "read3", "fail1", "play02", " load8", "load02", "loader3", "fail2", "fail02"], "load3": [" load103", "pack6", "load103", "pay0", "LOAD3", "play2", "load5", "pay3", "play3", "pay2", "pack3", "load6", "play1", "fail0", "LOAD5", "pack2", " load5", "loader1", "fail3", "loader5", "pack1", "loader6", "loader2", "fail103", "LOAD2", "play6", "loader3", "LOAD1", "fail2", "pay103"], "src_wgt": ["src_rwgs", "src_wger", "src_Wgt", "src_wwht", "src_wrger", "src_awgt", "src2wger", "src_rgt", "src_rwgt", "src_rg", "src_wrdr", "src_wlt", "src2wgt", "src_rdr", "src_rgz", "src_wwger", "src_rwgz", "src2wrht", "src_wrgt", "src_wdr", "src_wgz", "src_Wgz", "src__awgz", "src_rgs", "src__awlt", "src_rht", "src_Wgs", "src__awgt", "src_awgz", "src2wht", "src__wgz", "src__wdr", "src_awdr", "src_wg", "src_wrht", "src_wht", "src__wlt", "src2wgz", "src2wrgt", "src_wgs", "src_wrlt", "src__wgt", "src2wrgz", "src__awdr", "src_wrgz", "src_awlt", "src_rger", "src2wrger", "src_wwgt", "src_wwgz", "src_Wg", "src_rwg", "src_rlt"], "dst_wgt": ["dst_rgs", "dst2wgt", "dst_tgz", "dst_awtg", "dst___wgt", "dst_hgt", "dst_wrgn", "dst_awgt", "dst___wtg", "dst___wgn", "dst___wagz", "dst_wgs", "dst_wrtg", "dst_hrt", "dst___wlt", "dst___awlt", "dst_wrgz", "dst_ewtg", "dst___wgz", "dst___wgb", "dst___wagt", "dst_tgt", "dst_wmt", "dst2wgs", "dst___awgt", "dst_wrt", "dst_ewlt", "dst_wgn", "dst_Wgt", "dst_wlt", "dst_rgz", "dst_rgt", "dst_awmt", "dst_Wgb", "dst_hgs", "dst_wtg", "dst_wgb", "dst_Wgn", "dst_wagb", "dst_rrt", "dst_hgz", "dst___awtg", "dst_wgz", "dst2hrt", "dst_ewmt", "dst2wrt", "dst_wagt", "dst2hgz", "dst_tgs", "dst___awmt", "dst___wagn", "dst_wagz", "dst_trt", "dst___wmt", "dst_awlt", "dst2wgz", "dst_wrgt", "dst_Wgz", "dst2hgt", "dst_wrmt", "dst_wagn", "dst___wagb", "dst_wrlt", "dst2hgs", "dst_ewgt", "dst_wrgb"], "wgt": [" wrt", "vrt", "ewgn", "wbgs", "vgz", "wbgn", "wbrt", "vgt", "Wgz", " wgn", "wgn", "wbgt", "wrt", " wmt", "wgz", "wmt", " wgz", "ewgs", "wgs", "Wmt", "ewgt", "Wrt", "vmt", "ewrt", "Wgt", " wgs"], "src0": ["sr1", "loc00", "rc0", "loc0", "rc_", "rc1", "source0", "src_", "source1", "sr0", "rc3", " src_", "sr00", "src00", "rc00", "sr3", "loc1", "loc3", "source_"], "src1": ["sr1", "sourceOne", " srcOne", "rc11", "rc1", "source1", "sr11", "src11", "rc2", "rc3", "rcOne", "source2", "srcOne", "sr3", " src11", "sr2"], "src2": ["sr1", "rcTwo", "rc0", "sr01", "rc1", "srTwo", "srcTwo", "source0", "source1", "source01", "rc01", "sr0", "rc2", "source2", "src01", "sourceTwo", "sr2"], "src3": ["source43", "source3", "src03", "rc1", " src43", "source1", "source03", "rc2", " src03", "rc3", "source2", "rc03", "rc43", "src43"], "dst0": ["lst0", "lest0", "lst2", "lst1", "dist3", "dist0", "ddest0", "lest3", "dest3", "dest0", "ddest3", "lest2", "lest1", "dist2", "dest1", "ddest2", "ddest1", "dist1", "lst3", "dest2"], "dst1": [" dist2", "dist0", " dist0", "dest0", "dest91", "dist91", "dst91", "dstop2", " dist1", "dstop91", "dist2", "dest1", "dstop0", "dist1", "dstop1", " dst91", " dist91", "dest2"], "dst2": ["dset4", "dset3", "idset4", "idst3", "idst2", "dest3", "dst4", "dint3", "idset3", "idst4", "idset2", "dest4", "dset2", "dint2", "dint4", "dest2"], "dst3": ["dsp3", "dist3", "distiii", " dspiii", "dspiii", " dsp1", "dstiii", "dist2", "drciii", "drc2", "dist1", "dsp2", " dsp3", " dsp2", "drc1", "drc3", "dsp1", " dstiii"], "temp0": ["level2", "tmp0", "tmp1", "level1", "level00", "temp00", "level0", "tmp00", "tmp2", " temp00"], "temp1": [" temp01", "tc1", "tc2", "tc01", "tem0", "tc0", "temp01", "tem2", "tem1", "tem01"], "temp2": ["test1", "test02", "Temp1", "TempTwo", " tempTwo", "tempTwo", "Temp02", "Temp2", "temp02", "testTwo", " temp02", "test2"], "temp3": ["Temp1", "tmp1", "Temp2", "Temp3", "tmp2", "tmp3"], "denom": [" denot", "Denom", "lenorm", " denum", " denorm", "monom", "Denorm", "lenom", "Denoms", "Denot", "monum", "denorm", "monoms", " denoms", "denum", "denot", "monorm", "lenum", "Denum", "lenot", "denoms"], "offset": ["temp", "pos", "index", "Offset", "loc", "error", "seed", "size", "weight", "i", "slot", "num", "timeout", "xy", "shift", "set", "end", "unc", "point", "padding", "length", "ot", "position", "off", "out", "scroll", "start", "attr", "value", "addr", "bit", "order", "rot", "ref", "val", "origin", "bound", "key", "alt", "attribute", "block", "len", "tile", "elt", "type"], "add_val": ["add_pol", "add2value", "add_value", "add2val", "add2VAL", " add_value", "add67cal", "add_v", "added_cal", "added_val", "add67val", "add_cal", "added_pol", " add_VAL", " add_v", "add67pol", "add_VAL"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,\n\n                              TCGReg arg1, intptr_t arg2)\n\n{\n\n    int opi, opx;\n\n\n\n    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);\n\n    if (type == TCG_TYPE_I32) {\n\n        opi = LWZ, opx = LWZX;\n\n    } else {\n\n        opi = LD, opx = LDX;\n\n    }\n\n    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);\n\n}\n", "idx": 16501, "substitutes": {"s": ["a", "sc", "ds", "cs", "scl", "t", "w", "p", "sb", "ses", "sq", "h", "set", "qs", "is", "g", "rs", "gs", "S", "ss", "ns", "ps", "js", "c", "es", "r", "n", "fs", "ts", "f", "sl", "b", "conf", "m"], "type": ["error", "style", "format", "t", "or", "p", "ping", "dt", "test", "otype", "ry", "at", "port", "e", "ype", "mt", "tp", "name", "ct", "all", "kind", "get", "sys", "typ", "time", "range", "re", "types", "cmd", "role", "TYPE", "id", "ref", "et", "o", "now", "key", "state", "null", "Type", "ver", "no", "al", "function", "pe", "ty", "y", "file", "like", "class"], "ret": ["mem", " RET", "res", "nt", "back", "lib", "desc", "result", "Ret", "ry", "rt", "arg", "des", "out", "reg", "iter", " Ret", "rem", "rl", "sys", "RET", "reply", "re", "rev", "cmd", "ext", "det", "try", " arg", "reset", "ref", "std", "val", "rets", "def", "complete", "alt", "resp", "fun", "gt", "status", "red", "err"], "arg1": ["tagOne", "Arg01", "arg01", " arg3", " targ2", " argOne", " Arg3", " Arg1", "Arg2", " targ1", "Arg1", "tag2", " Arg0", " targ3", " arg0", " arg01", "arg0", "argOne", " targ0", " Arg2", "ArgOne", "arg3", "tag01", "tag1"], "arg2": ["ig2", "Arg0", "ig0", " arg3", "val02", "val1", "Arg2", "argtwo", "vol1", "Arg1", "voltwo", "vol02", "val2", " arg0", "vol2", "valtwo", "arg0", "ig3", " argtwo", "Arg3", "arg3", " arg02", "arg02", "ig1"], "opi": ["Opis", " opdi", " opbi", " apis", "opbi", "OPpi", "roppi", "ostbi", "OPdi", " popin", "ostui", "Opin", "ostpi", "Opi", " opis", " opiu", "OPiu", "OPi", "OPci", "copci", " apI", " apin", "opiu", "opin", "OPis", "opdi", "opI", "optiu", "copiu", "ropci", "osti", "copi", "opis", "ropi", " popi", "OpI", "optis", "opui", "opti", " api", "coppi", "ropiu", " opui", " popis", "opci", " oppi", " popI", "ropbi", "optdi", "ropui", "oppi"], "opx": ["OPix", "epxx", "hopxs", " opxs", "OPX", "preX", "opX", "eprx", "OPtx", " Opex", "epxs", "OPxs", "OPx", " optx", "epex", "aptx", " Opxs", "opix", " opxx", "apx", "optx", "apxe", "epX", "opxx", " Opx", "OPxe", "epx", " opX", "prex", " Opxx", "hopX", "oprx", "hopx", "opxs", "apX", " opex", "opxe", "prexx", "opex", " opxe", "prerx", " opix", "hopix", " oprx"]}}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "func": "void do_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    Error *err = NULL;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    bs1 = NULL;\n\n    while ((bs1 = bdrv_next(bs1))) {\n\n        if (bdrv_can_snapshot(bs1)) {\n\n            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);\n\n            if (err) {\n\n                monitor_printf(mon,\n\n                               \"Error while deleting snapshot on device '%s':\"\n\n                               \" %s\\n\",\n\n                               bdrv_get_device_name(bs),\n\n                               error_get_pretty(err));\n\n                error_free(err);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16507, "substitutes": {"mon": ["Mon", "mons", "mer", "man", "chron", "MON", "san", "mm", "mit", "sym", "util", "tem", "annot", "hog", "mn", "onet", "mt", "ann", "mat", "mun", "ox", "mu", "cat", "monitor", "mi", "mont", "mx", "wat", "admin", "dm", "met", " Mon", "den", "comm", "dom", "cond", "med", "ston", "mut", "meter", "monkey", "om", "min", "m"], "qdict": ["qqdict", "sqdom", "qmap", "qqd", "qualcompl", "sqmap", "qualdom", "qcompl", "qualmap", "sqdict", "sqd", "qdom", "questdict", "qmd", "qqmap", "qqcompl", "qd", "sqcompl", "questd", "questmd", "qualdict", "sqmd", "questmap", "qqmd", "qqdom"], "bs": ["bm", "ds", "cs", "lbs", "boxes", "blocks", "ists", "bed", "bits", "ach", "sb", "BS", "bb", "ras", "ubs", "bh", "oss", "bp", "bas", "bps", "vals", "gs", "bc", "aus", "ubis", "ns", "vs", "pb", "bos", "ps", "aps", "bes", "js", "iss", "bl", "xs", "bu", "obs", "cks", "fs", "acs", "bi", "ts", "aos", "ls", "locks", "s", "ms", "aches", "b", "bis", "its"], "bs1": ["bes11", "tsig", "obs3", "bs6", "cs4", "bs64", "ps0", "tsone", "bes2", "bis0", "bs3", "bes64", "ns4", "cs0", "ns1", "busone", "bes3", "bis6", "besig", "BS1", "ubs4", "BS4", "cs1", "ps3", "obs11", "busig", "bus1", "ts0", "besone", "bs0", "ubs2", "bsone", "bis1", "BS2", "bis64", "bsig", "obs6", "obs4", "cs6", "ts3", "obs64", "bus2", "bs4", "bes1", "bs2", "ts2", "BS0", "obs1", "ps2", "ns0", "ubs1", "ns2", "bis4", "bis11", "bs11", "ts1", "obs0", "ps1", "bis3", "ns3", "ubs0"], "err": ["error", "res", "arr", "or", "ez", "ei", "norm", "Error", "h", "gz", "kr", "e", "buf", "eas", "exc", "fr", "mr", "rs", "rr", "ch", "off", "out", "warn", "ns", "Er", "attr", "obj", "iter", "dr", "aaa", "sys", "fee", "ptr", "conn", "esp", "msg", "cmd", "ocr", "cr", "inner", "r", "ev", "gr", "str", "cer", "errors", "usr", "erd", "er", "txt", "cb", "eor", "later", "rn", "resp", "ah", "urg", "der", "ex", "elt", "conf", "br", "oe"], "name": ["word", "ame", "filename", "w", "comment", "cn", "text", "family", "ni", "prefix", "Name", "named", "ma", "label", "spec", "order", "data", "nl", "id", "admin", "ref", "local", "new", "str", "n", "path", "key", "alias", "nm", "info", "no", "names", "NAME", "title", "part", "b", "nam", "type"]}}
{"project": "qemu", "commit_id": "64607d088132abdb25bf30d93e97d0c8df7b364c", "target": 0, "func": "void object_property_add(Object *obj, const char *name, const char *type,\n\n                         ObjectPropertyAccessor *get,\n\n                         ObjectPropertyAccessor *set,\n\n                         ObjectPropertyRelease *release,\n\n                         void *opaque, Error **errp)\n\n{\n\n    ObjectProperty *prop;\n\n\n\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n\n        if (strcmp(prop->name, name) == 0) {\n\n            error_setg(errp, \"attempt to add duplicate property '%s'\"\n\n                       \" to object (type '%s')\", name,\n\n                       object_get_typename(obj));\n\n            return;\n\n        }\n\n    }\n\n\n\n    prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->name = g_strdup(name);\n\n    prop->type = g_strdup(type);\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n    prop->release = release;\n\n    prop->opaque = opaque;\n\n\n\n    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n\n}\n", "idx": 16521, "substitutes": {"obj": ["ic", "this", "os", "nt", "ist", "img", "oc", "app", "og", "ctx", "ob", "bs", "ht", "tmp", "op", "node", "onet", "so", "ot", "off", "bj", " ob", "ns", "hw", "self", "object", "sys", "addr", "js", "conn", "typ", "cmd", "pkg", "ind", "id", "j", "att", "inst", "comm", "oid", "et", "Obj", "tk", "obo", "obs", "obb", "o", "act", "cmp", "rb", "ent", "txt", "cb", "org", "src", "ex", "po", "elt", "y", "objects"], "name": ["word", "error", "size", "format", "base", "resource", "Name", "label", "admin", "common", "local", "path", "names", "NAME", "spec", "title", "form", "ame", "t", "filename", "list", "on", "family", "property", "unknown", "start", "read", "description", "range", "parent", "n", "null", "al", "code", "part", "version", "err", "old", "class", "comment", "term", "normal", "prefix", "node", "named", "attr", "order", "def", "str", "source", "nm", "info", "xml", "no", "ident", "missing", "p", "ns", "value", "data", "id", "ext", "r", "new", "key", "alias", "sequence", "search", "create", "nam"], "type": ["check", "form", "style", "error", "size", "t", "valid", "ping", "where", "test", "otype", "family", "base", "ype", "shape", "link", "length", "unit", "kind", "value", "time", "typ", "range", "role", "types", "TYPE", "id", "rel", "tag", "key", "sequence", "state", "info", "trace", "Type", "ver", "buffer", "pe", "title", "ty", "version", "y", "file", "class"], "get": ["help", "export", "check", "use", "rieve", "make", "query", "q", "ret", "ge", "find", "util", "g", "load", "handle", "grab", "select", "read", "value", "getting", "call", "eval", "cmd", "access", "update", "gets", "field", "Get", "draw", "def", "print", "give", "del", "GET", "info", "open", "build", "gener", "it", "exec", "parse", "show", "like"], "set": ["hide", "help", "check", "sc", "use", "form", "apply", "server", "place", "san", "delete", "make", "store", "test", "end", "change", "util", "mod", "setup", "clear", "op", "save", "send", "start", "select", "read", "add", "value", "sys", "sets", "se", "reset", "site", "update", "up", "et", "enable", "del", "un", "ver", "write", "spec", "parse", "create"], "release": ["require", "snap", "use", "process", "launch", "ca", "delete", "close", "make", "test", "Release", "util", "hold", "resource", "load", "quire", "fail", "ase", "save", "throw", "sem", "grab", "leases", "execute", "reference", "value", "manager", "range", "re", "commit", "update", "leasing", "available", "establish", "forge", "may", "develop", "destroy", "fire", "released", "mor", "ro", "un", "broad", "leased", "slave", "version", "lease", "LEASE"], "opaque": ["pute", "operacity", "oposition", "composition", " opatile", "OPacity", "popula", "boaque", "OPca", "operaques", "boaques", "opatile", "opaques", "popaque", "opula", "compacity", "boacity", "pca", "popacity", "ipacity", "ipute", " opula", "compaque", "boosition", " opacity", "opute", "opacity", "ipaque", "OPute", "pacity", "paque", "popatile", "operaque", "operosition", "compaques", "patile", "opca", "OPaque", "ipca", "pula"], "errp": [" ercp", " errr", " erp", " erpb", " errpb", "errpb", "acerpb", "acerr", "errpd", "rrpd", "erpb", "erp", "errr", " errcp", "errcp", "rrr", "rrp", "erpd", "acerpd", "rrpb", "rrcp", "acerp", " err", "err"], "prop": ["temp", "pr", "test", "crit", "zip", "opp", "pro", "properties", "mp", "req", "priv", "jp", "ph", "gp", "pl", "spec", "Prop", "rop", "np", "perm", "plot", "pp", "desc", "port", "property", "tmp", "grab", "pb", "ps", "msg", "pkg", "pt", "try", "acc", "pred", "resp", "rest", "po", "elt", "opt", "agg", " Prop", "term", "proc", "expr", "buf", "xp", "stat", "bug", "attr", "ptr", "verb", "att", "j", "cfg", "def", "pose", "cp", "col", "pos", "p", "dep", "pid", "decl", "op", "rep", "supp", "feat", "cmd", "func", "lit", "ref", "tag", "mk", "val", "key", "coord", "par", "comp", "dest", "phys", "prot"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void collie_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    StrongARMState *s;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"sa1110\";\n\n    }\n\n\n\n    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(SA_CS0, NULL, \"collie.fl1\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 1);\n\n    pflash_cfi01_register(SA_CS1, NULL, \"collie.fl2\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    sysbus_create_simple(\"scoop\", 0x40800000, NULL);\n\n\n\n    collie_binfo.kernel_filename = kernel_filename;\n\n    collie_binfo.kernel_cmdline = kernel_cmdline;\n\n    collie_binfo.initrd_filename = initrd_filename;\n\n    collie_binfo.board_id = 0x208;\n\n    arm_load_kernel(s->cpu, &collie_binfo);\n\n}\n", "idx": 16524, "substitutes": {"machine": ["iso", "managed", "connection", "zone", "process", "server", "mac", "linux", "money", "controller", "mc", "hard", "handler", "walker", "mount", "power", "device", "domain", "mom", "model", "node", "command", "engine", "cpu", "green", "di", "vm", "achine", "instance", "monitor", "Machine", "manager", "template", "local", "message", "host", "present", "hello", "keeper", "module", "state", "computer", "shell", "sim", "smart", "spin", "dem", "series", "gate", "mode", "m"], "cpu_model": ["cpu_models", "CPU_Model", "cputimeattribute", "cpuProdomain", " cpu_mode", "cpuPromodel", "CPU_model", "cpu_domain", "cpu_status", "pu_mode", "cpuaxymodel", "cputimemodel", "cpu_type", "cpu_module", "pu_domain", " cpu_models", " cpu_module", "pu_status", "cputimemode", "cpuPromode", " cpu_class", "cpu_mode", "cpuaxytype", "cpuProattribute", "pu_attribute", "cpu_Model", "CPU_attribute", "cputimedomain", "cpuaxyModel", "pu_type", "pu_model", "cpuaxyattribute", "CPU_type", " cpu_link", "cpu_class", "cpu_attribute", "cpu_link"], "kernel_filename": ["boardamesource", "console___filename", "kernel_original", "kernelamewit", "kernel_binary", "console_filename", "kernelamepdf", "console_command", "console___binary", "kernel_username", "kernelistdir", "kernel___binary", "kernel_dir", "ernel_original", "kernel_pdf", "system_binary", "kernelfilefilename", "kernelamesource", "kernel_file", "boardamewit", "kernelistfilename", "system_file", "kernelistfile", "kernel___username", "console___username", "console_username", "kernelamebinary", "ernel_family", "kernel___source", "ernel_file", "boardamepdf", "kernel___command", "system_dir", "kernel_command", "kernelfiledir", "kernelameusername", "kernel_family", "console_binary", "board_filename", "kernelamefilename", "board_wit", "board_pdf", "kernel_wit", "console___command", "ernel_filename", "boardamefilename", "kernelfilefile", "kernel___wit", "board_source", "kernel___pdf", "kernelamecommand", "system_filename", "kernelfilebinary", "kernel___filename", "kernel_source", "kernelistbinary"], "kernel_cmdline": ["kernel_condLine", "kernel_cssLINE", "kernel_readLine", "kernel_commandline", "kernel_commandde", "kernel_catsline", "kernel_genLine", "kernel_gentype", "kernel_cmdLine", "kernel_genln", "kernel_commandspec", "kernel_cssLine", "kernel_commandlines", "kernel_mdLine", "kernel_readde", "kernel_cmdln", "kernel_mdlines", "kernel_condline", "kernel_readline", "kernel_commandLINE", "kernel_commandln", "kernel_catsLine", "kernel_commandLine", "kernel_cookLine", "kernel_genline", "kernel_cmdlines", "kernel_catsln", "kernel_cooktype", "kernel_readln", "kernel_cookln", "kernel_condLINE", "kernel_cssspec", "kernel_cookline", "kernel_cmdLINE", "kernel_cmdspec", "kernel_commandtype", "kernel_cmdde", "kernel_condspec", "kernel_catsde", "kernel_cmdtype", "kernel_mdline", "kernel_cssline"], "initrd_filename": ["initrd___files", "initrr_file", "initrdmmfile", "initrt_cmd", "initrd_fle", "initrt_files", "initrar_filename", "initrar_file", "initdrm_tty", "initrt_file", "initrdetytty", "initrt__cmd", "initrd___file", "initdrmetycmd", "initdrm_filename", "initrt_filename", "initrd_fp", "initrdmmfiles", "initrr_files", "initrar_fle", "initrdityfile", "initrdmmfilename", "initrd_cmd", "initrd__files", "initdrm_file", "initrt__files", "initrdetyfilename", "initrt__filename", "initrd_files", "initrd___filename", "initdrmetyfilename", "initrdityfle", "initdrmetytty", "initrdityFILE", "initrr_filename", "initrr_fp", "initrd_tty", "initrt__file", "initrd_FILE", "initrdityfilename", "initrdetyfile", "initrd__file", "initrd_file", "initrdetycmd", "initdrm_cmd", "initrdmmcmd", "initrd__filename", "initrd___fp", "initrar_FILE", "initrd__cmd", "initdrmetyfile"], "s": ["a", "ds", "sam", "states", "os", "t", "w", "i", "sb", "p", "sp", "ses", "sq", "h", "sm", "is", "e", "g", "sv", "sa", "rs", "gs", "S", "ss", "so", "ns", "sts", "socket", "se", "sing", "sports", "sys", "ps", "c", "fs", "space", "state", "ts", "stats", "sis", "sl", "b", "y", "m"], "dinfo": ["sdinner", " diso", "diiter", "pinfo", "didinfo", " dnotice", "pinf", "Dii", "sdentry", "odii", "ddcache", "dinformation", "dditer", " dquery", "sdcomment", "sdinfo", " dinner", "pinit", "daconf", " dinit", "sdInfo", " dcache", "odinf", "adinfo", "ddINFO", "dii", "dcache", "dinner", "daquery", "diinfo", "dicache", " dINFO", " dInfo", "dentry", " dconf", "DInfo", "diter", "dcomment", "diso", "odinfo", "didquery", "Dinfo", "dInfo", "adInfo", "pinner", "Diso", "odnotice", "didinf", "dno", "dinf", "odinformation", "adcomment", "didconf", " dinf", "dlinfo", "dlnotice", "dainfo", "ddinfo", "sdinf", "odInfo", "adentry", "dinit", "Dinf", " dentry", "dconf", "sdinit", " dii", "dlinformation", "dINFO", "diINFO", " dcomment", "dnotice", "Dno", "didiso", " diter", " dno", "dquery", "dlinf", "didno", " dinformation"], "sysmem": ["ysMem", "systemmem", "ysphys", "skyphys", "sysMem", "sysm", "skymemory", "sym", "ysmemory", "systemMem", "systemmemory", "sysmb", "ysmb", "ysm", "skymem", "symemory", "systemmb", "symem", "sysmemory", " sysMem", "ysmem", "sysphys", " sysmb", "skym", "syphys", " sysmemory"]}}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)\n\n{\n\nPOWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);\n\n#ifdef ALTIVEC_USE_REFERENCE_C_CODE\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));\n\n      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));\n\n      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));\n\n      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#else /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;\n\n    register vector unsigned char perm = vec_lvsl(0, pixels);\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      pixelsv1 = vec_ld(0, (unsigned char*)pixels);\n\n      pixelsv2 = vec_ld(16, (unsigned char*)pixels);\n\n      blockv = vec_ld(0, block);\n\n      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);\n\n      blockv = vec_avg(blockv,pixelsv);\n\n      vec_st(blockv, 0, (unsigned char*)block);\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#endif /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n}\n", "idx": 16536, "substitutes": {"block": ["tx", "base", "point", "header", "label", "bl", "object", "bit", "commit", "line", "context", "number", "bin", "buffer", "chain", "book", "check", "offset", "frame", "index", "channel", "list", "zero", "lock", "global", "link", "limit", "mask", "range", "parent", "pack", "x", "open", "snap", "box", "Block", "num", "model", "load", "prefix", "group", "disk", "name", "wall", "k", "ip", "random", "side", "height", "draw", "row", "no", "byte", "loop", "pos", "pixel", "blocks", "board", "window", "p", "volume", "empty", "map", "position", "image", "out", "unit", "id", "record", "batch", "new", "blocking", "BL", "file", "type"], "pixels": ["pels", " pels", "pseters", "psuls", "pix", "cpuls", "ipixel", "dixel", " pix", "psips", "cpixel", "modes", "cpipers", "mixel", "dkins", "cpeters", "apix", "apipers", "npipers", " puls", "moms", "Pixel", "apixel", "psoms", "npeters", "peters", " pixel", " peters", "psuli", "poms", "psixels", " pips", "Pixels", "pipers", "ipipers", "piles", "puli", " poms", "npels", "ppiles", "deters", "Pipers", "dixels", "npixels", "pips", "Pels", "ppixels", "psixel", "ppipers", "pkins", "mixels", "puls", "npixel", "muli", "psipers", " pipers", "pskins", "pixel", "ppels", " pkins", " podes", "mipers", "psodes", "mips", " piles", "Peters", "apixels", "Pix", "npiles", "podes", "cpixels", "npix", "ipiles", "ppix", "Piles", "ipixels", "cpuli"], "line_size": ["line_space", " line_scale", "line_width", " line_space", " line_SIZE", " line_height", "line_SIZE", "line8count", "line_number", "line8scale", "line8number", "line_height", " line_number", "line8SIZE", "line_count", "line8space", " line_width", "line_scale", "line8size", " line_count"], "h": ["hs", "history", "l", "oh", "hh", "t", "w", "hi", "uh", "kh", "p", "hl", "he", "hz", "bh", "hash", "ha", "q", "hr", "ht", "header", "his", "ch", "v", "k", "H", "ih", "head", "c", "hm", "height", "r", "n", "x", "it", "b", "y", "eh", "loop", "m"], "i": ["z", "hi", "li", "e", "g", "I", "ai", "di", "mi", "eu", "gu", "chain", "ex", "multi", "ii", "index", "ij", "t", "ci", "q", "\u0438", "phi", "d", "v", "io", "cli", "pi", "try", "through", "gi", "n", "bi", "x", "zi", "ini", "f", "it", "iu", "err", "a", "init", "ic", "l", "w", "ei", "qi", "me", "ip", "j", "ti", "um", "uli", " I", "ami", "info", "by", "ix", "b", "y", "m", "si", "im", "p", "ki", "is", "ind", "id", "in", "xi", "ui", "iy", "ims", "sim", "us", "this"], "pixelsv1": ["pixv2", "petersveon", "pixelsvanta", "pixelsv0", "pixelsp10", "pixelsenons", "petersvanta", "pipersv10", "pixelsveon", "pixelsvvanta", "pixelsv10", "pixelsve1", "pixv1", "pixelsv9", "pixelsvv1", "pixelsp0", "pipersp10", "pixelsveons", "pixelsV10", "pixv9", "pixelsV0", "pixelsvvon", "petersveons", "pixelsp2", "pixelsp1", "petersvons", "pixelsv4", "pixelsm9", "pixelsm2", "pixelssv1", "petersveanta", "pixelsenon", "pixelssv0", "pixelsV2", "pixelsen1", "pipersp1", "pipersp0", "pixelsl2", "pixelsl1", "pixelssv2", "pixelsl4", "pixelsenanta", "pixelsvons", "petersve1", "pixv4", "pipersv0", "petersvon", "pixelsveanta", "pixelsm1", "pixelsm4", "pixelsvvons", "pipersv2", "pixelsV1", "pixelsvon", "petersv1", "pixelssv10", "pipersv1", "pixelsl9", "pipersp2"], "pixelsv2": ["pixv2", "pixelsvc2", "pixf9", "pipsv6", "pixelsv6", "pixelsver1", "pixelsf3", "pixf3", "pixelsv9", "pixv1", "picksvertwo", "pipsl1", "pipsv02", "pixf1", "pipsl6", "pixv9", "pixelsv3", "pixelsav9", "pixelsav02", "picksvtwo", "pixelsl02", "pipsl2", "pixelsV2", "pixelsver2", "pixf2", "pixelsl2", "pixelsav1", "pixelsl1", "pixv3", "pipsv2", "pixelsV02", "picksver2", "picksv1", "pixelsav3", "pixelsvctwo", "pixelsvtwo", "pipsl02", "pixelsv02", "pixelsav6", "picksver1", "pixelsf2", "pipsv1", "picksv2", "pixelsV1", "pixelsf9", "pixelsvc1", "pixelsf1", "pixelsV6", "pixelsvertwo", "pixelsav2", "pixelsl6"], "pixelsv": [" pixelsconv", " pixelsp", " pairsv", "pixelsl", "pulsei", "pixelsconv", "pipersf", "pipsi", " pairsl", " pipsv", "pixelsp", "pairsl", " pixelsi", "pentsconv", "pairsp", "pipsf", "pipersp", "pipsconv", "pulseconv", "pairsf", " pipsl", "pixelsi", "pipersl", " pixelsl", "pipsp", " pairsf", "pipsv", "pulsel", "pulsev", "pentsl", " pairsp", "pixelsf", "pipersv", "pipsl", "pentsv", " pipsconv", " pixelsf", "pentsi", "pairsv", " pipsi"], "blockv": ["blockvi", "boxj", "BlockV", "box_", "block_", "lockv", "lineg", " block_", "lock_", "boxp", "linkv", "lockj", "lockV", " blockj", "linkV", "boxV", "linep", "Blockg", "blockp", "lockp", "blockg", " blockV", "boxv", "Blockp", "linkvi", "lineV", " blockvi", "blockj", "linev", "Blockv", " blockp", "blockV", "Blockvi", " blockg"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void blk_send_response_all(struct XenBlkDev *blkdev)\n\n{\n\n    struct ioreq *ioreq;\n\n    int send_notify = 0;\n\n\n\n    while (!LIST_EMPTY(&blkdev->finished)) {\n\n        ioreq = LIST_FIRST(&blkdev->finished);\n\n\tsend_notify += blk_send_response_one(ioreq);\n\n\tioreq_release(ioreq);\n\n    }\n\n    if (send_notify)\n\n\txen_be_send_notify(&blkdev->xendev);\n\n}\n", "idx": 16542, "substitutes": {"blkdev": ["blckswitch", " blkclient", " blkswitch", "blkerDev", "blunkDev", "blkserver", "blksdevice", " blckdevice", "bltkdev", "blkdef", "blkerdef", "blktserver", "blkerdevice", "blckclient", "blksswitch", " blckserver", "blkerswitch", "bltkden", "blkerdev", "blkDev", "blktdev", " blckDev", " blkdef", "blckDev", "blckdevice", "blksclient", "blckdef", "blksdev", "blckserver", "bltkDev", "blkden", " blckdef", " blckden", " blkden", "blunkclient", "blunkdevice", "blksDev", "blkclient", " blkDev", " blkserver", " blkdevice", " blckclient", "blkdevice", " blckswitch", " blckdev", "bltkdevice", "blckden", "blktdef", "blckdev", "blkswitch", "blunkdev", "blktDev", "blkerserver", "blksden"], "ioreq": ["iorenqs", "iareqs", "iareql", "ioringqu", "ioresquant", "iorerqs", "ioserquest", "ioveqs", " iorerc", "iressoq", "iorich", "ioveq", "liressoq", "iorerch", "liressoquest", "ioriqs", " iorerqi", "liorequant", "ioresquest", "iorerc", "pioresquant", "iorerquest", "iressoquant", "ioveqi", "ioringquest", "piorerquest", " ioresquest", "liorequ", " iorerqs", " ioreqs", "iorerql", "pioresqs", "iorech", "ioserqs", "piorequest", " ioreqi", " iorerq", "iorequest", "ioriq", "ioreqi", "ioserq", "pioresquest", "iorequant", "liorequest", "ioreqs", "piorerqs", "pioresq", "ioringq", "liressoqu", "iarequest", "pioreqs", "iovec", "ioresql", "iorequ", "piorerch", "lioreq", "iressoquest", "ioreql", " iorequest", "liressoquant", "iorerqi", "iorench", "iorenquest", "iressoqu", "iareq", " ioresqs", "piorech", "pioreq", " ioreql", "iorerquant", " ioresql", "ioringquant", "ioriquest", "piorerq", " iorec", "ioresqs", "iorec", "iorenq", "iorerq", "iorerqu", "ioresq", "piorequant", " ioresq", "ioserquant"]}}
{"project": "qemu", "commit_id": "6c7565028c272c4c6f2a83c3a90b044eeaf2804a", "target": 0, "func": "static int interface_client_monitors_config(QXLInstance *sin,\n\n                                        VDAgentMonitorsConfig *monitors_config)\n\n{\n\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n\n    QXLRom *rom = memory_region_get_ram_ptr(&qxl->rom_bar);\n\n    int i;\n\n    unsigned max_outputs = ARRAY_SIZE(rom->client_monitors_config.heads);\n\n\n\n    if (qxl->revision < 4) {\n\n        trace_qxl_client_monitors_config_unsupported_by_device(qxl->id,\n\n                                                               qxl->revision);\n\n        return 0;\n\n    }\n\n    /*\n\n     * Older windows drivers set int_mask to 0 when their ISR is called,\n\n     * then later set it to ~0. So it doesn't relate to the actual interrupts\n\n     * handled. However, they are old, so clearly they don't support this\n\n     * interrupt\n\n     */\n\n    if (qxl->ram->int_mask == 0 || qxl->ram->int_mask == ~0 ||\n\n        !(qxl->ram->int_mask & QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)) {\n\n        trace_qxl_client_monitors_config_unsupported_by_guest(qxl->id,\n\n                                                            qxl->ram->int_mask,\n\n                                                            monitors_config);\n\n        return 0;\n\n    }\n\n    if (!monitors_config) {\n\n        return 1;\n\n    }\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n    /* limit number of outputs based on setting limit */\n\n    if (qxl->max_outputs && qxl->max_outputs <= max_outputs) {\n\n        max_outputs = qxl->max_outputs;\n\n    }\n\n#endif\n\n\n\n    memset(&rom->client_monitors_config, 0,\n\n           sizeof(rom->client_monitors_config));\n\n    rom->client_monitors_config.count = monitors_config->num_of_monitors;\n\n    /* monitors_config->flags ignored */\n\n    if (rom->client_monitors_config.count >= max_outputs) {\n\n        trace_qxl_client_monitors_config_capped(qxl->id,\n\n                                monitors_config->num_of_monitors,\n\n                                max_outputs);\n\n        rom->client_monitors_config.count = max_outputs;\n\n    }\n\n    for (i = 0 ; i < rom->client_monitors_config.count ; ++i) {\n\n        VDAgentMonConfig *monitor = &monitors_config->monitors[i];\n\n        QXLURect *rect = &rom->client_monitors_config.heads[i];\n\n        /* monitor->depth ignored */\n\n        rect->left = monitor->x;\n\n        rect->top = monitor->y;\n\n        rect->right = monitor->x + monitor->width;\n\n        rect->bottom = monitor->y + monitor->height;\n\n    }\n\n    rom->client_monitors_config_crc = qxl_crc32(\n\n            (const uint8_t *)&rom->client_monitors_config,\n\n            sizeof(rom->client_monitors_config));\n\n    trace_qxl_client_monitors_config_crc(qxl->id,\n\n            sizeof(rom->client_monitors_config),\n\n            rom->client_monitors_config_crc);\n\n\n\n    trace_qxl_interrupt_client_monitors_config(qxl->id,\n\n                        rom->client_monitors_config.count,\n\n                        rom->client_monitors_config.heads);\n\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);\n\n    return 1;\n\n}\n", "idx": 16566, "substitutes": {"monitors_config": ["monitors___cfg", "monitors1error", "monifiers_exec", "monitors_output", "monitorsistexec", "monitors_desc", "monitors00name", "monitors_def", "monitors_exec", "monistors___config", "monvisors___Config", "monistors___cfg", "moners_config", "monvisors_config", "monitors1exec", "monitors___config", "monvisors___control", "moners_diff", "monitorsurestorage", "monors_desc", "monitorsisterror", "monitors1config", "monifiers_config", "monors_config", "monors_output", "monagers_name", "monitors1storage", "monors_conf", "monitors00control", "monitorsistconfig", "monitors___spec", "monistors___state", "monvisors___config", "monitorsureconfig", "monitors_Config", "monitors_conn", "monitors____control", "monitorsureexec", "monagers_control", "monitors____name", "monitors___control", "monistors_config", "monagers_config", "monitors_spec", "monistors_def", "monistors_cfg", "moners_conf", "monifiersureerror", "monvisors_Config", "monitorsiststorage", "monitors00conn", "monitors____config", "monitorsetricconf", "monitors00config", "monifiersureconfig", "monitorsetricoutput", "monitors_state", "monitors_cfg", "monifiers_storage", "monitors___Config", "monitorsetricdesc", "monifiersureexec", "monitors_conf", "monvisors_control", "monitorsetricconfig", "monitorsureerror", "monagers_conn", "monitors_control", "monifiers_error", "monitors___state", "monifiersurestorage", "monvisors___spec", "monitors___def", "monitors_storage", "monistors_state", "monitors_name", "monitors____conn", "monvisors_spec", "monitors_error", "monitors_diff", "monistors___def"], "qxl": ["qrxl", "qexll", "qtryl", "qxml", "qtxml", "qnzlay", "qxla", "qxclp", "qtxql", "qxael", "queryxl", "qlexel", "quxyl", "qxplc", "chargexl", "qxpl", " qxld", "requxal", "qkl", "qxyln", "qtryf", "qpxll", "qxilb", "qlexld", "qklock", "quxl", "qxln", "queueixl", "qxcml", "qxll", "qoverlay", "qpxql", "qoxls", "qqxml", "qxmllay", "qxlp", "iqexml", "iqexl", "eqklb", "qxdls", "qxxlt", "chargexlay", " qxla", "quxln", "qxal", "qrxel", "iqexld", "qqxyls", "qxdl", "qxesly", "iqxml", "quxf", "qoxfl", "qqxl", "qumxll", "qoverl", "eqxlock", "qwxli", " quxlc", "qnzlb", "qdxll", "queryxls", "qqxyl", " qtxlp", "qkd", "qxmll", "qxyla", "qxL", "qxls", "qxdli", "quxhl", "qrxli", "qxpla", "eqklock", "sqxl", "queuexL", "qnzl", "qmxly", "chargexlb", " qxml", " qtxml", "qxxlc", "qxilock", "qtxla", "qoverlt", "qtxel", "chargenzlay", "qmxl", "chargenzlb", "qxyls", "qqxyml", "qxql", "qoxl", "iqxl", "qtxlb", "qxeshl", "qpxld", "qbyfl", "quxyfl", " quxla", "queueixL", "qmxil", "qtryil", "requxla", " qlexlc", "qxly", "qxid", "qxphl", "qrxls", "qxyl", "qoxf", "eqkd", "qdxml", "qxesl", "qoxli", "sqxlb", "quxli", "qbylb", "qxlb", "qoxln", "qmxli", "queryrxls", "eqxd", "qxxlb", "qxyml", "qxyel", "qxf", "qrxln", "requxel", "qxil", "eqxl", "qxmlhl", "qbyl", "qxala", "qxeslb", "qlexhl", "qxmllt", "qpxml", "qtryll", "qoxlb", "qmxll", "qxlc", "quxyml", "qxdln", "qtxlay", "qtxL", "iqxll", "eqxlb", "qumxf", " quxl", "quxd", "quxlc", "qxlock", "queryrxl", "qxxl", "sqxxlt", "sqxxlay", "qxel", " qxlc", "qlexls", "quxla", "qxeslay", "qxpml", "qxxli", "qumxhl", "qexml", "qpxL", "qrxlp", "quxlb", "qxlt", "qxxlay", "qxli", "qdxla", "iqexll", "qqxel", " qxli", "qxxld", "qqxyel", "qxyfl", "qxmllb", " qlexld", "qlexly", " qtxl", "queryrxli", "qxylb", "qbyln", "quxlock", "qlexli", " qlexli", "requxl", "queryrxln", "qdxld", " qxhl", "qlexml", "qtxl", " qlexl", "qwxlc", "qqxls", "queuexl", "quxyli", "qmxhl", "qxld", "qumxl", "qwxld", "chargenzl", "qoxil", "queuexql", "qxesli", "qixql", "quxml", "qxd", "qlexlc", "qexld", "qxcl", "queryxln", "quxll", "eqkl", "qrxml", "qxmllc", "quxyla", "qwxl", "quxyln", "qumxly", "requxala", "requxael", "qlexl", "quxylb", "qxhl", "qixl", "qxyli", "qdxl", "qklb", "qoxll", "sqxlay", "qtxlp", " quxhl", "qexl", "quxly", "quxil", "qixL", "sqxxlb", "qumxli", "qxmlla", "queueixql", "qdxli", " qxlp", "qmxf", "qxfl", "iqxld", "queryxli", "qumxil", "qpxl", "qxlay", "sqxlt", "quxfl", "qxpli", "sqxxl", "qoverlb"], "rom": ["iam", "roma", "rm", "rob", "sky", "res", "rol", "roy", "mm", "rain", "tom", "ROM", "norm", "ry", "aram", "ran", "irm", "ri", "rax", "serv", "mr", "rs", "yan", "rome", "mn", "rum", "cpu", "gem", "rep", "gom", "reg", "radio", "rim", "gra", "dr", "rar", "rem", "rd", "re", "prem", "cmd", "cr", "ocr", "rock", "r", "prom", "arm", "comm", "dom", "rss", "cm", "ram", "recomm", "roc", "ro", "stan", "rpm", "rib", "ost", "dem", "om", "red", "drm", "chrom"], "i": ["ic", "index", "l", " t", "si", "ci", "im", "p", " n", "qi", " ti", "me", "li", " pi", "is", "e", "g", "I", " ii", " l", " e", "ai", "phi", "u", "v", "di", " mi", "k", " k", "ip", "mi", "pi", "c", "in", " j", "j", "xi", "ti", "batch", "ui", "gi", "n", " I", "ami", "multi", "bi", " x", "x", " ni", " m", " v", " c", "sim", "ini", "it", "ix", "us", "iu", "y", "ii", "m"], "monitor": ["ctor", "channel", "component", "username", "timeout", "port", "program", "device", "map", "mate", "profile", "command", "match", "minimum", "execute", "param", "mark", "Monitor", "manager", "watch", "batch", "member", "minute", "connect", "gray", " mate", "monkey", "proxy"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);\n\n\n\n    /*\n\n     * virtio pci bar layout used by default.\n\n     * subclasses can re-arrange things if needed.\n\n     *\n\n     *   region 0   --  virtio legacy io bar\n\n     *   region 1   --  msi-x bar\n\n     *   region 4+5 --  virtio modern memory (64bit) bar\n\n     *\n\n     */\n\n    proxy->legacy_io_bar  = 0;\n\n    proxy->msix_bar       = 1;\n\n    proxy->modern_io_bar  = 2;\n\n    proxy->modern_mem_bar = 4;\n\n\n\n    proxy->common.offset = 0x0;\n\n    proxy->common.size = 0x1000;\n\n    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;\n\n\n\n    proxy->isr.offset = 0x1000;\n\n    proxy->isr.size = 0x1000;\n\n    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;\n\n\n\n    proxy->device.offset = 0x2000;\n\n    proxy->device.size = 0x1000;\n\n    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;\n\n\n\n    proxy->notify.offset = 0x3000;\n\n    proxy->notify.size =\n\n        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;\n\n    proxy->notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    proxy->notify_pio.offset = 0x0;\n\n    proxy->notify_pio.size = 0x4;\n\n    proxy->notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    /* subclasses can enforce modern, so do this unconditionally */\n\n    memory_region_init(&proxy->modern_bar, OBJECT(proxy), \"virtio-pci\",\n\n                       2 * QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *\n\n                       VIRTIO_QUEUE_MAX);\n\n\n\n    memory_region_init_alias(&proxy->modern_cfg,\n\n                             OBJECT(proxy),\n\n                             \"virtio-pci-cfg\",\n\n                             &proxy->modern_bar,\n\n                             0,\n\n                             memory_region_size(&proxy->modern_bar));\n\n\n\n    address_space_init(&proxy->modern_as, &proxy->modern_cfg, \"virtio-pci-cfg-as\");\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus) &&\n\n        !pci_bus_is_root(pci_dev->bus)) {\n\n        int pos;\n\n\n\n        pos = pcie_endpoint_cap_init(pci_dev, 0);\n\n        assert(pos > 0);\n\n\n\n        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);\n\n        assert(pos > 0);\n\n\n\n        /*\n\n         * Indicates that this function complies with revision 1.2 of the\n\n         * PCI Power Management Interface Specification.\n\n         */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_PMC, 0x3);\n\n    } else {\n\n        /*\n\n         * make future invocations of pci_is_express() return false\n\n         * and pci_config_size() return PCI_CONFIG_SPACE_SIZE.\n\n         */\n\n        pci_dev->cap_present &= ~QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);\n\n    if (k->realize) {\n\n        k->realize(proxy, errp);\n\n    }\n\n}\n", "idx": 16585, "substitutes": {"pci_dev": ["pci2device", "pciogadv", "pdi_device", "pci2Dev", "pdo_adv", "pdi_spec", "pki_link", "pdi_Dev", "pdi_ev", "pcioglink", "pci2dev", "pki_dev", "pciogDev", "pci_device", "pci_adv", "pci_link", "pci_ev", "pdi_dev", "pci2ev", "pdo_serial", "pki_Dev", "pki_adv", "pciogdev", "pdo_ev", "pci_spec", "pdo_dev", "pci_Dev", "pci_serial"], "errp": [" errpar", "errps", "errpar", "errP", "erps", "arrps", " errps", "arrpar", "erp", "erP", "erpar", " errP", "arrp", "arrP"], "proxy": ["callback", "roxy", "echo", "ping", "controller", "report", "handler", "password", "pro", "friend", "manager", "driver", "wrapper", "page", "sync", "project", "gp", "module", "cache", "token", "shadow", "pin", "connection", "index", "use", "server", "settings", "timeout", "port", "device", "lock", "force", "pointer", "Proxy", "apache", "response", "XY", "service", "call", "reply", "json", "hello", "x", "reverse", "view", "slave", "po", "version", "show", "linux", "java", "query", "ion", "native", "profile", "address", "instance", "http", "target", "embed", "template", "prime", "go", "php", "super", "history", "component", "phy", "client", "xy", "remote", "ice", "builder", "cas", "library", "engine", "primary", "cci", "web", "cone", "socket", "reference", "select", "PRO", "reflect", "alias", "pse", "tor", "forward", "create"], "k": ["km", "aka", "tc", "t", "ck", "p", "ks", "kt", "kr", "set", "kit", "ka", "cc", "kw", "kid", "kind", "kk", "c", "j", "ko", "ker", "o", "key", "kernel", "lass", "K", "spec", "m"]}}
{"project": "FFmpeg", "commit_id": "cf6914e27f14cf2b5a66e25f5cf3549ceabb1648", "target": 0, "func": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *data_size, AVPacket *pkt)\n\n{\n\n    CDXLVideoContext *c = avctx->priv_data;\n\n    AVFrame * const p = &c->frame;\n\n    int ret, w, h, encoding, format, buf_size = pkt->size;\n\n    const uint8_t *buf = pkt->data;\n\n\n\n    if (buf_size < 32)\n\n        return AVERROR_INVALIDDATA;\n\n    encoding        = buf[1] & 7;\n\n    format          = buf[1] & 0xE0;\n\n    w               = AV_RB16(&buf[14]);\n\n    h               = AV_RB16(&buf[16]);\n\n    c->bpp          = buf[19];\n\n    c->palette_size = AV_RB16(&buf[20]);\n\n    c->palette      = buf + 32;\n\n    c->video        = c->palette + c->palette_size;\n\n    c->video_size   = buf_size - c->palette_size - 32;\n\n\n\n    if (c->palette_size > 512)\n\n        return AVERROR_INVALIDDATA;\n\n    if (buf_size < c->palette_size + 32)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp < 1)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp > 8) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n    if (format) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)\n\n        return AVERROR_INVALIDDATA;\n\n    if (!encoding && c->palette_size && c->bpp <= 8) {\n\n        avctx->pix_fmt = PIX_FMT_PAL8;\n\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n\n        if (c->palette_size != (1 << (c->bpp - 1)))\n\n            return AVERROR_INVALIDDATA;\n\n        avctx->pix_fmt = PIX_FMT_BGR24;\n\n    } else {\n\n        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",\n\n                              encoding, c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    p->reference = 0;\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    if (encoding) {\n\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n\n                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!c->new_video)\n\n            return AVERROR(ENOMEM);\n\n        if (c->bpp == 8)\n\n            cdxl_decode_ham8(c);\n\n        else\n\n            cdxl_decode_ham6(c);\n\n    } else {\n\n        cdxl_decode_rgb(c);\n\n    }\n\n    *data_size      = sizeof(AVFrame);\n\n    *(AVFrame*)data = c->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 16602, "substitutes": {"avctx": ["navtx", "avercb", " avcontext", "aveconn", "ivercontext", "wavctx", "averconfig", "avconn", " avcb", "savconfig", " avca", "avjac", "avercp", " avconfig", "afctx", " avjp", "avpkg", " avtimeout", "savjac", "avertmp", "savcontext", "cvcontext", "avetx", "avecontext", "navcp", "navcontext", "avcu", "avecmp", "avepkg", "avconfig", "avtimeout", " avtx", "navcu", "navcfg", "avecp", "avtmp", "avecb", " avtmp", "avcp", "avcb", "savconn", "avercontext", "savctx", "aftx", "avca", "savpkg", " avsys", " avcfg", "iverjp", "averca", "avcontext", "avcfg", "avesys", "aveconfig", "avectx", "ivertimeout", "avejac", "wavjac", "cvjp", "avejp", " avcmp", "afcontext", "cvctx", "ivercmp", "wavconfig", "afcu", "avecfg", "navcmp", "iverca", "avsys", "wavpkg", " avcp", "avertimeout", "avcmp", "avetmp", " avconn", "iverctx", "averctx", "savcp", "cvtx", "avjp", " avcu", "navctx", "avtx", "navsys"], "data": ["a", "frame", "t", "window", "size", "pad", "input", "dat", "ata", "padding", "length", "content", "image", "d", "DATA", "bytes", "mu", "Data", "video", "area", "value", "body", "batch", "message", "def", "raw", "o", "package", "type", "bin", "buffer", "f", "text", "multiple", "m"], "data_size": ["data_count", " data_len", "data_len", " data_length", "data_length", " data_count"], "pkt": ["pppt", " ppt", "packpt", " pdu", "Packet", "pct", " pqt", "packkt", "pqt", "pux", "ppqt", "packet", "mct", "pcacket", " pet", " pKT", "pKT", "ppet", "mkt", "pdu", "mdu", "ppt", "pet", "Pct", "pckt", "pcKT", " packet", "paux", "pcux", "macket", "Pdu", " pux", "Pkt", " pct", "pakt", "ppkt", "paacket", "packqt", "paKT"], "c": ["sc", "con", "cv", "cs", "ic", "tc", "l", "ca", "can", "t", "ci", "mc", "ec", "at", "ctx", "err", "unc", "pc", "gc", "e", "g", "cur", "cam", "cf", "vc", "comments", "cc", "bc", "ct", "conv", "co", "content", "v", "etc", "cd", "cont", "call", "uc", "cr", "comm", "cmp", "lc", "cm", "dc", "C", "n", "coll", "fc", "ce", "cu", "cache", "nc", "anc", "xc", "com", "cp", "rc", "f", "abc", "ac", "chain", "comp", "ed", "b", "conf", "col", "m"], "p": ["np", "t", " P", "pp", "q", "pc", "op", "vp", "conv", "d", "rep", "v", "pb", "ps", "pkg", "j", "r", "jp", "n", "pa", "cp", "f", "fp", "pe", "P", "b", "m"], "ret": ["mem", "mel", "nt", "res", "el", "t", "back", "flag", "result", "Ret", "err", "rt", "tr", "match", "mt", "out", "v", "Return", "cont", "iter", "ft", "value", "rem", " Ret", "RET", "reset", "re", "det", "try", "rel", "ref", "r", "val", "def", "print", "alt", "aux", "len", "resp", "f", "it", "gt", "elt", "status", "rets"], "w": ["word", "l", "size", "wp", "window", "mm", "rw", "we", "win", "iw", "aw", "g", "wid", "wt", "nw", "d", "wr", "v", "sw", "hw", "ew", "wb", "wa", "wx", "wd", "r", "wh", "ww", "wi", "W", "n", "wn", "x", "fw", "wind", "wal", "f", "ex", "b", "m"], "h": ["him", "hs", "history", "ho", "hh", "oh", "l", "z", "t", "hi", "uh", "sh", "kh", "ish", "he", "hang", "bh", "ha", "hash", "q", "hr", "hd", "g", "ht", "length", "phi", "m", "ch", "v", "k", "ih", "H", "hm", "j", "height", "wh", "host", "mk", "high", "ph", "n", "o", "ah", "b", "y", "hl"], "encoding": ["ecression", "decoder", "ecoding", "Encryption", "enoding", "decryption", "Encoding", "encoder", "encression", "ecaling", "compryption", "encaling", "enryption", "decoding", "compoding", "ecuration", "decuration", "encuration", "compaling", "compression", "enoder", "Encression", "ecoder", "coding", "Encaling", "enaling", "enuration", "caling", "coder", "ecryption", "encryption", "cryption"], "format": ["offset", "frame", "form", "style", "size", "term", "test", "feature", "color", "family", "option", "scale", "action", "html", "padding", "prefix", "command", "mt", "name", "mat", "method", "conv", "unit", "v", "label", "video", "atter", "apache", "feat", "pretty", "spec", "pi", "note", "ats", "tag", "template", "options", "table", "transform", "file", "act", "fc", "Format", "fm", "function", "f", "filter", "pattern", "fp", "title", "version", "status", "ff", "mode", "type"], "buf": ["late", "mem", "cap", "pos", "cv", "Buff", "font", "xff", "np", "boxes", "arr", "t", "args", "deg", "img", "pad", "desc", "var", "emb", "proc", "num", "ctx", "words", "fb", "bs", "vals", "vec", "cam", "tmp", "fac", "length", "queue", "alloc", "mat", "grab", "conv", "packed", "db", "bytes", "pb", "doc", "bl", "wb", "cmd", "msg", "pkg", "func", "req", "ref", "r", "batch", "raw", "str", "workers", "rb", "orig", "txt", "cb", "nm", "block", "lim", "len", "uf", "buffer", "Buffer", "buff", "begin", "b", "seq", "br", "err"]}}
{"project": "FFmpeg", "commit_id": "9c85329cd02e9284892bf263ce6133b2fc479792", "target": 1, "func": "static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)\n\n{\n\n    uint32_t opcode_size, offset;\n\n    uint8_t *dst, *dend, mask = 0, color = 0;\n\n    const uint8_t *src, *send, *opcodes;\n\n    int i, j, op = 0;\n\n\n\n    i = bytestream2_get_byte(&c->gb);\n\n    if (i) {\n\n        if (code & 0x10) {\n\n            int align;\n\n\n\n            align = bytestream2_tell(&c->gb) & 3;\n\n            if (align)\n\n                bytestream2_skip(&c->gb, 4 - align);\n\n        }\n\n        do {\n\n            int page, val, x, y;\n\n            val    = bytestream2_get_be16(&c->gb);\n\n            page   = val >> 14;\n\n            x      = (val & 0x7F) * 2;\n\n            y      = ((val >> 7) & 0x7F) * 2;\n\n            dst    = c->frame[page] + x + y * c->width;\n\n            dend   = c->frame[page] + c->frame_size;\n\n            offset = (x & 0x7F) * 2;\n\n            j      = bytestream2_get_le16(&c->gb) + offset;\n\n            do {\n\n                offset++;\n\n                if (dst + 3 * c->width + 4 > dend)\n\n                    return AVERROR_INVALIDDATA;\n\n                read4x4block(c, dst, c->width);\n\n                if ((offset & 0x3F) == 0)\n\n                    dst += c->width * 3;\n\n                dst += 4;\n\n            } while (offset < j);\n\n        } while (--i);\n\n    }\n\n\n\n    dst  = c->frame[c->current_frame];\n\n    dend = c->frame[c->current_frame] + c->frame_size;\n\n    do {\n\n        set_src_position(c, &src, &send);\n\n        if ((src + 3 * c->width + 4 > send) ||\n\n            (dst + 3 * c->width + 4 > dend))\n\n            return AVERROR_INVALIDDATA;\n\n        copy_block4(dst, src, c->width, c->width, 4);\n\n        i++;\n\n        if ((i & 0x3F) == 0)\n\n            dst += c->width * 3;\n\n        dst += 4;\n\n    } while (i < c->video_size / 16);\n\n\n\n    opcode_size = bytestream2_get_le16(&c->gb);\n\n    bytestream2_skip(&c->gb, 2);\n\n\n\n    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    opcodes = pkt + bytestream2_tell(&c->gb);\n\n    bytestream2_skipu(&c->gb, opcode_size);\n\n\n\n    dst = c->frame[c->current_frame];\n\n\n\n    for (i = 0; i < c->height; i += 4, dst += c->width * 3)\n\n        for (j = 0; j < c->width; j += 4, dst += 4) {\n\n            int opcode, k = 0;\n\n            if (op > opcode_size)\n\n                return AVERROR_INVALIDDATA;\n\n            if (j & 4) {\n\n                opcode = opcodes[op] & 15;\n\n                op++;\n\n            } else {\n\n                opcode = opcodes[op] >> 4;\n\n            }\n\n\n\n            while (block_sequences[opcode][k]) {\n\n                offset = c->width * 2;\n\n                code   = block_sequences[opcode][k++];\n\n\n\n                switch (code) {\n\n                case 2:\n\n                    offset = 0;\n\n                case 3:\n\n                    color = bytestream2_get_byte(&c->gb);\n\n                case 4:\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_color_mask(dst + offset, c->width, mask, color);\n\n                    break;\n\n                case 5:\n\n                    offset = 0;\n\n                case 6:\n\n                    set_src_position(c, &src, &send);\n\n                case 7:\n\n                    if (src + offset + c->width + 4 > send)\n\n                        return AVERROR_INVALIDDATA;\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_src_mask(dst + offset, c->width, mask, src + offset);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 16614, "substitutes": {"c": ["check", "con", "cv", "cs", "ic", "form", "tc", "l", "ca", "t", "ci", "p", "mc", "ec", "enc", "ctx", "err", "unc", "pc", "gc", "e", "cl", "g", "cur", "cam", "config", "cf", "ct", "cc", "bc", "content", "d", "co", "v", "etc", "cd", "ch", "cont", "self", "call", "cr", "comm", "cmp", "lc", "cm", "dc", "C", "n", "coll", "fc", "ce", "cod", "cu", "cache", "cb", "nc", "anc", "com", "cp", "rc", "f", "ac", "abc", "chain", "sc", "b", "conf"], "pkt": ["pctx", "vkt", " pdu", "npkt", "npkg", "vkg", "pkg", "npdu", " pctx", " pkg", "npctx", "vctx", "vdu", "pdu"], "code": [" co", " reason", "index", "channel", "error", "size", " Code", "ci", " cmd", "test", " mode", "ice", "e", "count", "command", "length", " ecc", "reason", "content", "cc", "image", "ch", "co", " chunk", " coding", "coe", "value", "bit", "time", " whence", "Code", "id", "codes", "message", "ode", " status", "cod", "ce", "state", "cache", " change", "buffer", "rc", "text", "event", "mode", "type"], "opcode_size": ["opcodes_start", "opcodes_size", "opcode_name", "opcode___start", "opcode_start", "opcodes_name", "opcode___area", "opcode_area", "opcode___size", "opcode___name", "opcodes_area"], "offset": ["next", "pos", "index", "Offset", "loc", "error", "location", "z", "item", "size", "slice", "p", "slot", "sp", "timeout", "xy", "shift", "end", "set", "e", "point", "padding", "length", "step", "ot", "position", "address", "off", "seek", "scroll", "io", "start", "pointer", "attr", "mask", "ip", "value", "addr", "time", "reset", "range", "data", "skip", "to", "height", "um", "ui", "origin", "line", "o", "key", "block", "row", "f", "tile", "buffer", "fp", "angle"], "dst": ["idST", "oduse", "idstart", "sdst", "adest", "fST", "dsrest", "dsend", "dint", "copy", "lst", "dST", "dsest", "Dst", "odstart", "dsset", "dstart", "bit", "dset", "bdst", "idst", "dsint", "Dist", "sdST", "adst", "Dint", "DST", "dpend", "dist", "dspend", "adend", "sdot", "Duse", "dot", "bdput", "idend", "_", "lST", "read", "fnd", "call", "odst", "bdpend", "Dest", "lnd", "lest", " dstart", "fst", "Dstart", "odend", " dot", " duse", " dest", " dST", "fend", " dset", "lend", "bdend", "def", "block", "Drest", " dint", "Dpend", "dnd", "sdend", "dput", "byte", "Dset", "adist", " drest", " dnd", "lstart", " dist", "duse", "idnd", "dsst", "Dot", "cont", "dsput", "Dput", "drest", "Dend", "new", "idest", "dest"], "dend": ["dends", "pst", " dending", "mends", "dEND", " dsend", " dnd", "psend", "mst", "dended", "dsend", "lEND", "vend", "fend", "lending", " dended", "vends", "fending", "pends", "vending", "lend", "wended", "Dst", "mending", "fnd", "Dended", "fended", "pnd", "wEND", "wending", "wend", "Dnd", "dending", "Dend", "vst", "wst", "wnd", " dends", "lended", "pend", "pended", "fst", "dnd", " dEND", "mend", "fsend", "fends"], "src": ["sc", "pos", "loc", "size", "slice", "img", "sb", "sub", "ins", "st", "sp", "input", "ctx", "rt", "cur", "rs", "tmp", "start", "ptr", "attr", "cont", "read", "iv", "addr", "sn", "sys", "cmd", "ind", "in", "inner", "inst", "r", "sync", "usr", "fc", "source", "txt", "sr", "gin", "s", "rc", "url", "fp", "ctr", "sl", "dest", "ser", "trans"], "send": ["late", "init", "pos", "use", "eng", "size", "slice", "sent", "sp", "num", "q", "ceive", "set", "end", "find", "g", "sv", "save", "handle", "seek", "out", "force", "fin", "sw", "start", "se", "push", "get", "read", "sys", "sn", "msg", "speed", "body", "source", "pose", "Send", "share", "jump", "nd", "write", "bind", "sc", "show", "trans"], "opcodes": ["opbits", "OPbits", "pnames", "opnames", "pbits", "OPcode", "popcode", "popcodes", "OPnames", "OPcodes", "pcode", "popbits", "popnames", "pcodes"], "i": ["a", "ic", "index", "ij", "l", "si", "ci", "hi", "p", "port", "li", "is", "e", "g", "I", "u", "ai", "phi", "d", "v", "io", "start", "di", "cli", "iter", "ip", "mi", "pi", "in", "id", "xi", "r", "ti", "ui", "iat", "o", "n", "multi", "bi", "iu", "ini", "f", "it", "ia", "ix", "b", "ii", "m"], "j": ["pos", "index", "jj", "ij", "z", "l", "si", "p", "slot", "dj", "sp", "kj", "q", "shift", "ja", "g", "uj", "fr", "J", "off", "bj", "d", "v", "k", "jl", "js", "json", "r", "jp", "o", "ji", "n", "aj", "jump", "vol", "it", "jc", "b"], "align": ["aligned", " anchor", "repeat", "ag", "lag", "pad", "aug", "adj", "aff", "hang", "shift", "balance", "hold", "lock", "padding", "alter", "length", "match", "wrap", "anch", "mark", "order", "range", " aligned", " overlap", "pal", "skip", "half", "rel", "ign", "cmp", " angle", "join", "pair", " alignment", "alias", "coord", "margin", "tail", "adjust", "len", "alpha", "al", "ac", "chain", "ia", "angle", "hal", "gap", "inc", "ang", "ignment"], "page": ["next", "pos", "frame", "index", "window", "total", "plot", "p", "pp", "sp", "num", "port", "pid", "base", "pc", "wait", "Page", "age", "count", "point", "cycle", "link", "node", "position", "pg", "pointer", "ip", "mark", "order", "pi", "site", "id", "pt", "ref", "pool", "parent", "line", "post", "number", "key", "cache", "block", "row", "pl", "go", "chain", "pe", "month", "loop"], "val": ["bal", "mem", "ul", "index", "Val", "loc", "l", "item", "el", "sel", "ival", "valid", "tx", "p", "var", "slot", "lib", "vt", "test", "xy", "VAL", "ret", "base", "vals", "count", "point", "il", "aval", "unit", "v", "value", "mark", "bit", "data", "eval", "pt", "pal", "dev", "ref", "local", "cal", "V", "def", "key", "state", "pl", "len", "vol", "al", "f", "it", "angle", "b", "elt"], "x": ["index", "l", "z", "location", "lon", "px", "w", "ax", "tx", "p", "xt", "rx", "xy", "xa", "point", "xp", "lat", "ox", "d", "xf", "v", "axis", "start", "X", "wx", "ip", "xs", "to", "xi", "xx", "n", "path", "fx", "xc", "dx", "f", "ix", "ex", "m"], "y": ["ies", "sky", "ly", "z", "yr", "xy", "axy", "sy", "ey", "ym", "hy", "py", "lat", "ot", "ch", "v", "ay", "asy", "my", "yy", "vy", "height", "gy", "fy", "n", "yo", "ny", "key", "yt", "iy", "row", "Y", "ty", "b", "cy", "col"], "op": ["pos", "prev", "ops", "pop", "im", "oc", "p", "sp", "copy", "ot", "operation", "co", "OP", "ip", "bit", "update", "jp", "um", "cmp", "oper", "o", "eff", "cp", "Op", "inc", "ap", "hop", "oe"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void save_native_fp_fsave(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    uint16_t fpuc;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    asm volatile (\"fsave %0\" : : \"m\" (*fp));\n\n    env->fpuc = fp->fpuc;\n\n    env->fpstt = (fp->fpus >> 11) & 7;\n\n    env->fpus = fp->fpus & ~0x3800;\n\n    fptag = fp->fptag;\n\n    for(i = 0;i < 8; i++) {\n\n        env->fptags[i] = ((fptag & 3) == 3);\n\n        fptag >>= 2;\n\n    }\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    /* we must restore the default rounding state */\n\n    fpuc = 0x037f | (env->fpuc & (3 << 10));\n\n    asm volatile(\"fldcw %0\" : : \"m\" (fpuc));\n\n}\n", "idx": 16628, "substitutes": {"env": ["enter", "ctx", "e", "te", "vp", "vs", "self", "obj", "peer", "ee", "esp", "manager", "jp", "context", "er", " esp", "rn", "ah", "pe", "Environment", "hl", "environment", "cv", "np", "el", "server", "pp", "desc", "sp", "en", "eni", "end", "ja", "nv", "tmp", "nw", "v", "ew", "pb", "hw", "dev", "forge", "code", "org", "worker", " ens", "console", "sb", "ei", "skin", "ner", "buf", "sv", "uv", "ptr", "ef", "addr", "js", " environment", "ev", "state", "cp", "window", " en", "vt", "ec", "engine", "db", "esc", "vm", "ve", "conn", "et", "cb", "pen", "oe"], "fptag": [" fptagen", "fptagen", "sptype", "Fctagn", "fiptagger", "feptag", " fptagged", "spttag", "fntagger", "sprettag", "faptog", "fcptags", "spretag", "fctang", "fctagn", "fctagen", "spretype", "Fcttag", "fpointype", "fqtagger", "spretagger", "fqtag", "fctype", " fctagen", "faptag", "fctagger", "feptagn", " fctagger", "ftpagger", "fptagn", "fpropagger", "fptype", "fpropag", "fcqtog", "fqtog", "fpropagen", "fcptag", "fportag", "Fptagn", "sptag", "fptagged", "fcqtag", "fpropagn", "ftopag", "fepttag", "fptags", "fpointtag", " fctagn", "fcqtags", "Fptag", "fcptog", "Fpttag", "fptog", " fctagged", "fprettag", "fctagged", "fcptagger", "fptagger", "feptagger", "fqtags", "fctag", "fpretagger", "Fctag", "fntang", "fportang", "ftpagen", "sptagger", "faptags", "fportagged", " fctang", "fntag", "fcqtagger", " fptagn", " fptagger", "fportagger", "fcttag", "fpretype", "fiptags", "ftpag", "fiptog", "ftopagn", "fpretag", "ftpagn", "faptagger", "fptang", "fiptag", " fptang", "fpointagger", "Fptagger", "fpttag", " fctag", "Fctagger", "fpointag", "fntagged", "ftopagger", "ftoptag"], "i": ["iso", "init", "ic", "index", "ij", "this", "si", "ci", "im", "p", "ei", "ki", "qi", "me", "at", "q", "li", "is", "\u0438", "ri", "point", "I", "ai", "phi", "v", "io", "di", "cli", "iter", "ip", "PI", "mi", "pi", "oi", "ind", "iri", "in", "xi", "ti", "ui", "gi", "print", "ji", "multi", "uri", "fi", "er", "bi", "x", "info", "zi", "ini", "sim", "ie", "it", "ix", "iu", "y", "ii", "m"], "j": ["pos", "index", "jj", "ij", "z", "l", "si", "pr", "p", "dj", "kj", "q", "h", "ja", "uj", "g", "fr", "u", "J", "jac", "jit", "d", "v", "k", "jl", "js", "c", "json", "pt", "r", "jp", "n", "ji", "o", "aj", "bi", "x", "jump", "f", "it", "jc", "b", "y", "br", "m"], "fpuc": ["vpauc", " gpuc", "fpuid", "psc", "puusc", "lpauc", "tpauc", " gpbc", "puuc", "lpucc", "cpuc", "wpuc", "vpucc", "bpuc", "pusc", "gpauc", "wpun", "lpsc", "bpusc", "tpusc", "gpsc", "fpucc", "jpbc", "fpun", "fpusc", "vpsc", "tpsc", "fpuf", "fgauc", "vpuc", "gpusc", " gpuid", "cpun", "fpsc", "cpsc", "jpuid", "puacc", "fmuid", "vpusc", "fpbc", "wpauc", "cpauc", "lpusc", "fgusc", "bpucc", "pacc", "fmbc", "puc", "cpusc", "fmuf", "fpauc", "jpuf", "wpusc", "gpuc", "jpuc", "tpuc", "pauc", "bpauc", " gpuf", "fpacc", "lpuc", "fgun", "fmuc", "gpacc", "fguc"], "fp1": ["tp2", "jp0", " gp1", "jp2", "fp0", "tp1", "tp0", " gp0", " gp2", "vp2", "p2", "jp1", "p0", "vp1", "fp2", "vp0", "p1"], "fp": ["spr", "lp", "png", "np", "fps", "fn", "fd", "wp", "filename", "pr", "csv", "p", "pp", "sp", "yp", "bp", "ctx", "ulp", "buf", "FP", "xp", "cf", "vp", "il", "tp", "conv", "fg", "fe", "tf", "ptr", "pb", "ft", "ps", "esp", "mp", "pkg", "ff", "func", "jp", "cfg", "file", "fs", "fi", "VP", "fm", "gp", "bf", "fc", "nil", "ppo", "cb", "fx", "fw", "uf", "cp", "f", "php", "ap"]}}
{"project": "FFmpeg", "commit_id": "5dbb63feefb9070d6fbb5fc16406813f14aa7f9b", "target": 0, "func": "static int decode_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic;\n\n    int err, i, ret, video_index, audio_index, subtitle_index;\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    AVFormatParameters params, *ap = &params;\n\n\n\n    video_index = -1;\n\n    audio_index = -1;\n\n    subtitle_index = -1;\n\n    is->video_stream = -1;\n\n    is->audio_stream = -1;\n\n    is->subtitle_stream = -1;\n\n\n\n    global_video_state = is;\n\n    url_set_interrupt_cb(decode_interrupt_cb);\n\n\n\n    memset(ap, 0, sizeof(*ap));\n\n\n\n    ap->width = frame_width;\n\n    ap->height= frame_height;\n\n    ap->time_base= (AVRational){1, 25};\n\n    ap->pix_fmt = frame_pix_fmt;\n\n\n\n    err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if(genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    err = av_find_stream_info(ic);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if(ic->pb)\n\n        ic->pb->eof_reached= 0; //FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < ic->nb_streams; i++) {\n\n        AVCodecContext *enc = ic->streams[i]->codec;\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n        switch(enc->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if ((audio_index < 0 || wanted_audio_stream-- > 0) && !audio_disable)\n\n                audio_index = i;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            if ((video_index < 0 || wanted_video_stream-- > 0) && !video_disable)\n\n                video_index = i;\n\n            break;\n\n        case CODEC_TYPE_SUBTITLE:\n\n            if (wanted_subtitle_stream-- >= 0 && !video_disable)\n\n                subtitle_index = i;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (show_status) {\n\n        dump_format(ic, 0, is->filename, 0);\n\n        dump_stream_info(ic);\n\n    }\n\n\n\n    /* open the streams */\n\n    if (audio_index >= 0) {\n\n        stream_component_open(is, audio_index);\n\n    }\n\n\n\n    if (video_index >= 0) {\n\n        stream_component_open(is, video_index);\n\n    } else {\n\n        if (!display_disable)\n\n            is->show_audio = 1;\n\n    }\n\n\n\n    if (subtitle_index >= 0) {\n\n        stream_component_open(is, subtitle_index);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    for(;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER\n\n        if (is->paused && !strcmp(ic->iformat->name, \"rtsp\")) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int stream_index= -1;\n\n            int64_t seek_target= is->seek_pos;\n\n\n\n            if     (is->   video_stream >= 0) stream_index= is->   video_stream;\n\n            else if(is->   audio_stream >= 0) stream_index= is->   audio_stream;\n\n            else if(is->subtitle_stream >= 0) stream_index= is->subtitle_stream;\n\n\n\n            if(stream_index>=0){\n\n                seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q, ic->streams[stream_index]->time_base);\n\n            }\n\n\n\n            ret = av_seek_frame(is->ic, stream_index, seek_target, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            }else{\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (is->audioq.size > MAX_AUDIOQ_SIZE ||\n\n            is->videoq.size > MAX_VIDEOQ_SIZE ||\n\n            is->subtitleq.size > MAX_SUBTITLEQ_SIZE) {\n\n            /* wait 10 ms */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n        if(url_feof(ic->pb)) {\n\n            av_init_packet(pkt);\n\n            pkt->data=NULL;\n\n            pkt->size=0;\n\n            pkt->stream_index= is->video_stream;\n\n            packet_queue_put(&is->videoq, pkt);\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret != AVERROR_EOF && url_ferror(ic->pb) == 0) {\n\n                SDL_Delay(100); /* wait for user event */\n\n                continue;\n\n            } else\n\n                break;\n\n        }\n\n        if (pkt->stream_index == is->audio_stream) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* disable interrupting */\n\n    global_video_state = NULL;\n\n\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        av_close_input_file(is->ic);\n\n        is->ic = NULL; /* safety */\n\n    }\n\n    url_set_interrupt_cb(NULL);\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    return 0;\n\n}\n", "idx": 16651, "substitutes": {"arg": ["arr", "ag", "args", "w", "ax", "p", "og", "ctx", "ar", "pc", "gc", "g", "op", "il", "pg", "reg", "v", "doc", "param", "ive", "call", "in", "argument", "ark", "ref", "jp", "val", "Arg", "ary", "arp", "ac", "it", "arc", "parse", "inc", "ig"], "is": ["init", "iso", "os", "si", "ism", "ists", "are", "ist", "bits", "im", "as", "ish", "isl", "ins", "isc", "isi", "num", "ics", "isp", "ir", "tis", "ar", "ik", "has", "IS", "ri", "bs", "iris", "il", "ai", "isin", "ot", "isa", "get", "ip", "ps", "sys", "isf", "Is", "iss", "js", "pi", "in", "id", "es", "inst", "ais", "pas", "bi", "ib", "ois", "ims", "parts", "mis", "s", "was", "rest", "ms", "ris", "lis", "sis", "it", "ia", "bis", "its"], "ic": ["wic", "ica", "ij", "ico", "tc", "nic", "ci", "oc", "isc", "mc", "acl", "ics", "ec", "ican", "ctx", "pic", "ik", " nic", "pc", "gc", "ai", "vc", "tic", "icing", "ot", "rec", "ct", "aic", "co", "sic", "ric", "bc", "iq", "ick", "ip", "ive", "ab", "mic", "c", "ict", "IC", "voc", "icon", "lic", "fc", "ib", "eric", "iac", "abc", "icc", "ac", "ix", "it", "irc", "ia", "inc", "ici", "iat"], "err": ["error", "score", "kr", "e", "fr", "rr", "fer", "iter", "aaa", "sys", "ler", "req", "c", "inner", "plain", "ger", "er", "eor", "rn", "lr", "die", "or", "t", "yr", "norm", "gz", " Err", "ber", "mr", "rar", "fee", "msg", "my", "cr", "try", "n", "usr", "len", "resp", "ctr", "elt", "late", "res", "ter", "hz", "ner", "buf", " er", "ch", "ptr", "attr", "cor", "js", "order", "ere", "cfg", "str", "raw", "erd", "rb", "notice", "txt", "later", "nr", "der", "m", "arr", "asm", "Error", "count", "timer", "Er", "dr", "outer", "cmd", "r", "val", "cer", "dy", "cb", "conf", "br"], "i": ["init", "index", "ij", "si", "ci", "im", "p", "ei", "qi", "me", "ir", "li", "\u0438", "e", "I", "ai", "v", "di", "start", "instance", "ip", "mi", "pi", "oi", "ind", "id", "c", "j", "xi", "in", "ti", "ui", "batch", "iat", "gi", "n", "o", "ami", "multi", "ji", "fire", "bi", "x", "ims", "sim", "ini", "zi", "chain", "it", "ix", "iu", "y", "ii", "m"], "ret": ["mem", "rm", "nt", "res", "arr", "pret", "t", "back", "deg", "ter", "dt", "desc", "xt", "result", "ll", "Ret", "rt", "ber", "success", "tr", "mt", "nz", "out", "mat", "fin", "dr", "iter", "lt", "ft", "addr", "rem", " Ret", "backed", "RET", "rev", "reply", "re", "cmd", "det", "try", "att", "reset", "rel", "ref", "r", "jp", "ext", "val", "rets", "def", "print", "fi", "usr", "alt", "del", "txt", "net", "resp", "it", "gt", "fun", "elt", "br"], "video_index": ["audio_stream", "video_number", "audio_number", "video_device", "video32device", "video32path", "video32stream", "audio_size", "video_size", "video_stream", "video32index", "audio_device", "audio_path", "video_path", "audio_id", "video_id"], "audio_index": ["audio_stream", "media_long", "media_number", "media_stream", "audio_number", "media_index", "media_id", "audio_id", "audio_long"], "subtitle_index": ["subtitle_length", "subTitle_offset", "subtitle_Index", "subtitle_stream", "subname_number", "subTitle_index", "subname_length", "subname_index", "subTitle_Index", "subtitle_number", "subname_id", "subtitle_id", "subtitle_offset", "subTitle_stream"], "pkt1": ["pkt3", "opacket1", "packet0", "pqt1", " pet3", "pelt1", " pet1", "opacket0", " pet2", "pelt2", "opkt0", " pkt3", "pqt3", "pkt2", "opacket2", "packet2", "opkt2", "pkt0", "pet3", "opkt1", "packet1", "pqt2", "pet0", "packet3", " pet0", "pqt0", "pet2", " pkt2", "pet1", "pelt0", " pkt0"], "pkt": [" pact", "Pkt", "cpact", "cpct", "cpacket", " pct", "Pact", "Packet", "Pct", " packet", "pct", "packet", "pact", "cpkt"], "params": ["cap", "pos", " stats", "fps", "args", " fps", "as", "p", "pps", "ctx", " paras", "ars", "pc", "pres", "caps", "rs", "map", " props", "amps", "kw", " pars", " args", "aps", "param", "ps", "ams", " pan", "js", "mp", "types", " parameters", "jp", "options", " parts", " ps", "pas", "par", "parts", "pa", " pairs", "s", "cp", "ac", "spec", "conf", " caps"], "ap": ["rap", "mem", "cap", "snap", "am", "el", "arr", "mac", "ag", "wp", "and", "im", "ax", "p", "pp", "sp", "amp", "tap", "acl", "app", "at", "ipp", "ar", "set", "ars", "html", "ape", "av", "map", "op", "ad", "pb", "attr", "aps", "ps", "ip", "addr", "ab", "ast", "mp", "att", "hap", "art", "apa", "apt", "acc", "aj", "par", "pa", "ep", "api", "al", "arp", "cp", "ac", "AP", "aph"], "timestamp": ["metest", "talestamp", "timemark", "stimance", "temetime", "Timest", "mometime", "temestamp", "timeeline", " timemark", "imemark", "temement", "taleline", "timeest", "timination", "timement", " timance", "Timement", "tmetime", "Timetime", "tminal", "timeinal", "metetime", "Timestamp", "stimestamp", "timeetime", "momestamp", "imetime", "momest", "tmestamp", "tmeline", "timance", "temeline", "imance", "meteline", "timeline", "timetime", "timinal", "temination", " timetime", "temest", "talest", "talination", "momement", "stimetime", "metinal", "imestamp", "Timeline", "timeestamp", "Timination", "timest", "metestamp", "stimemark"], "enc": ["loc", "oc", "ec", "kt", "pc", "exc", "sec", "rec", "conv", "kw", "iv", "conn", "et", "coll", "act", "cod", "fc", "ent", "ack", "ENC", "lang", "nc", "anc", "txt", "rc", "ac", "comp"]}}
{"project": "FFmpeg", "commit_id": "608708009f69ba4cecebf05120c696167494c897", "target": 1, "func": "static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ADPCMDecodeContext *c = avctx->priv_data;\n    ADPCMChannelStatus *cs;\n    int n, m, channel, i;\n    short *samples;\n    const uint8_t *src;\n    int st; /* stereo */\n    int count1, count2;\n    int nb_samples, coded_samples, ret;\n    nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);\n    if (nb_samples <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of samples in packet\\n\");\n    }\n    /* get output buffer */\n    c->frame.nb_samples = nb_samples;\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (short *)c->frame.data[0];\n    /* use coded_samples when applicable */\n    /* it is always <= nb_samples, so the output buffer will be large enough */\n    if (coded_samples) {\n        if (coded_samples != nb_samples)\n            av_log(avctx, AV_LOG_WARNING, \"mismatch in coded sample count\\n\");\n        c->frame.nb_samples = nb_samples = coded_samples;\n    }\n    src = buf;\n    st = avctx->channels == 2 ? 1 : 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ADPCM_IMA_QT:\n        /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples).\n           Channel data is interleaved per-chunk. */\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int16_t predictor;\n            int step_index;\n            cs = &(c->status[channel]);\n            /* (pppppp) (piiiiiii) */\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n            predictor = AV_RB16(src);\n            step_index = predictor & 0x7F;\n            predictor &= 0xFF80;\n            src += 2;\n            if (cs->step_index == step_index) {\n                int diff = (int)predictor - cs->predictor;\n                if (diff < 0)\n                    diff = - diff;\n                if (diff > 0x7f)\n                    goto update;\n            } else {\n            update:\n                cs->step_index = step_index;\n                cs->predictor = predictor;\n            }\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            samples = (short *)c->frame.data[0] + channel;\n            for (m = 0; m < 32; m++) {\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n                samples += avctx->channels;\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n                samples += avctx->channels;\n                src ++;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WAV:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for(i=0; i<avctx->channels; i++){\n            cs = &(c->status[i]);\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n        }\n        for (n = (nb_samples - 1) / 8; n > 0; n--) {\n            for (i = 0; i < avctx->channels; i++) {\n                cs = &c->status[i];\n                for (m = 0; m < 4; m++) {\n                    uint8_t v = *src++;\n                    *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);\n                    samples += avctx->channels;\n                    *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 3);\n                    samples += avctx->channels;\n                }\n                samples -= 8 * avctx->channels - 1;\n            }\n            samples += 7 * avctx->channels;\n        }\n        break;\n    case CODEC_ID_ADPCM_4XM:\n        for (i = 0; i < avctx->channels; i++)\n            c->status[i].predictor= (int16_t)bytestream_get_le16(&src);\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].step_index= (int16_t)bytestream_get_le16(&src);\n            c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n        }\n        for (i = 0; i < avctx->channels; i++) {\n            samples = (short *)c->frame.data[0] + i;\n            cs = &c->status[i];\n            for (n = nb_samples >> 1; n > 0; n--, src++) {\n                uint8_t v = *src;\n                *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 4);\n                samples += avctx->channels;\n                *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 4);\n                samples += avctx->channels;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_MS:\n    {\n        int block_predictor;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        block_predictor = av_clip(*src++, 0, 6);\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        if (st) {\n            block_predictor = av_clip(*src++, 0, 6);\n            c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n            c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        }\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n        if (st){\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n        }\n        c->status[0].sample1 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n        c->status[0].sample2 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n        *samples++ = c->status[0].sample2;\n        if (st) *samples++ = c->status[1].sample2;\n        *samples++ = c->status[0].sample1;\n        if (st) *samples++ = c->status[1].sample1;\n        for(n = (nb_samples - 2) >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_DK4:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n            *samples++ = cs->predictor;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_DK3:\n    {\n        unsigned char last_byte = 0;\n        unsigned char nibble;\n        int decode_top_nibble_next = 0;\n        int end_of_packet = 0;\n        int diff_channel;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n        c->status[0].step_index = src[14];\n        c->status[1].step_index = src[15];\n        /* sign extend the predictors */\n        src += 16;\n        diff_channel = c->status[1].predictor;\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n         * the buffer is consumed */\n        while (1) {\n            /* for this algorithm, c->status[0] is the sum channel and\n             * c->status[1] is the diff channel */\n            /* process the first predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the diff channel predictor */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n            /* process the first pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n            /* process the second predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the second pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_ISS:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v1, v2;\n            uint8_t v = *src;\n            /* nibbles are swapped for mono */\n            if (st) {\n                v1 = v >> 4;\n                v2 = v & 0x0F;\n            } else {\n                v2 = v >> 4;\n                v1 = v & 0x0F;\n            }\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WS:\n        while (src < buf + buf_size) {\n            uint8_t v = *src++;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_XA:\n        while (buf_size >= 128) {\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n                avctx->channels);\n            src += 128;\n            samples += 28 * 8;\n            buf_size -= 128;\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n        src += 4; // skip sample count (already read)\n        for (i=0; i<=st; i++)\n            c->status[i].step_index = bytestream_get_le32(&src);\n        for (i=0; i<=st; i++)\n            c->status[i].predictor  = bytestream_get_le32(&src);\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n        }\n        break;\n    case CODEC_ID_ADPCM_EA:\n    {\n        int32_t previous_left_sample, previous_right_sample;\n        int32_t current_left_sample, current_right_sample;\n        int32_t next_left_sample, next_right_sample;\n        int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n        uint8_t shift_left, shift_right;\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n           each coding 28 stereo samples. */\n        src += 4; // skip sample count (already read)\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n        for (count1 = 0; count1 < nb_samples / 28; count1++) {\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n            src++;\n            shift_left  = 20 - (*src >> 4);\n            shift_right = 20 - (*src & 0x0F);\n            src++;\n            for (count2 = 0; count2 < 28; count2++) {\n                next_left_sample  = sign_extend(*src >> 4, 4) << shift_left;\n                next_right_sample = sign_extend(*src,      4) << shift_right;\n                src++;\n                next_left_sample = (next_left_sample +\n                    (current_left_sample * coeff1l) +\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n                next_right_sample = (next_right_sample +\n                    (current_right_sample * coeff1r) +\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n                previous_left_sample = current_left_sample;\n                current_left_sample = av_clip_int16(next_left_sample);\n                previous_right_sample = current_right_sample;\n                current_right_sample = av_clip_int16(next_right_sample);\n                *samples++ = (unsigned short)current_left_sample;\n                *samples++ = (unsigned short)current_right_sample;\n            }\n        }\n        if (src - buf == buf_size - 2)\n            src += 2; // Skip terminating 0x0000\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n    {\n        int coeff[2][2], shift[2];\n        for(channel = 0; channel < avctx->channels; channel++) {\n            for (i=0; i<2; i++)\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n            shift[channel] = 20 - (*src & 0x0F);\n            src++;\n        }\n        for (count1 = 0; count1 < nb_samples / 2; count1++) {\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n                for(channel = 0; channel < avctx->channels; channel++) {\n                    int32_t sample = sign_extend(src[channel] >> i, 4) << shift[channel];\n                    sample = (sample +\n                             c->status[channel].sample1 * coeff[channel][0] +\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n                    c->status[channel].sample2 = c->status[channel].sample1;\n                    c->status[channel].sample1 = av_clip_int16(sample);\n                    *samples++ = c->status[channel].sample1;\n                }\n            }\n            src+=avctx->channels;\n        }\n        /* consume whole packet */\n        src = buf + buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_R1:\n    case CODEC_ID_ADPCM_EA_R2:\n    case CODEC_ID_ADPCM_EA_R3: {\n        /* channel numbering\n           2chan: 0=fl, 1=fr\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n        int32_t previous_sample, current_sample, next_sample;\n        int32_t coeff1, coeff2;\n        uint8_t shift;\n        unsigned int channel;\n        uint16_t *samplesC;\n        const uint8_t *srcC;\n        const uint8_t *src_end = buf + buf_size;\n        int count = 0;\n        src += 4; // skip sample count (already read)\n        for (channel=0; channel<avctx->channels; channel++) {\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n                                         : bytestream_get_le32(&src))\n                           + (avctx->channels-channel-1) * 4;\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n            srcC  = src + offset;\n            samplesC = samples + channel;\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n            } else {\n                current_sample  = c->status[channel].predictor;\n                previous_sample = c->status[channel].prev_sample;\n            }\n            for (count1 = 0; count1 < nb_samples / 28; count1++) {\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n                    srcC++;\n                    if (srcC > src_end - 30*2) break;\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n                    for (count2=0; count2<28; count2++) {\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n                        samplesC += avctx->channels;\n                    }\n                } else {\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n                    shift = 20 - (*srcC++ & 0x0F);\n                    if (srcC > src_end - 14) break;\n                    for (count2=0; count2<28; count2++) {\n                        if (count2 & 1)\n                            next_sample = sign_extend(*srcC++,    4) << shift;\n                        else\n                            next_sample = sign_extend(*srcC >> 4, 4) << shift;\n                        next_sample += (current_sample  * coeff1) +\n                                       (previous_sample * coeff2);\n                        next_sample = av_clip_int16(next_sample >> 8);\n                        previous_sample = current_sample;\n                        current_sample  = next_sample;\n                        *samplesC = current_sample;\n                        samplesC += avctx->channels;\n                    }\n                }\n            }\n            if (!count) {\n                count = count1;\n            } else if (count != count1) {\n                av_log(avctx, AV_LOG_WARNING, \"per-channel sample count mismatch\\n\");\n                count = FFMAX(count, count1);\n            }\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n                c->status[channel].predictor   = current_sample;\n                c->status[channel].prev_sample = previous_sample;\n            }\n        }\n        c->frame.nb_samples = count * 28;\n        src = src_end;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_XAS:\n        for (channel=0; channel<avctx->channels; channel++) {\n            int coeff[2][4], shift[4];\n            short *s2, *s = &samples[channel];\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n                for (i=0; i<2; i++)\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n                shift[n] = 20 - (src[2] & 0x0F);\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n            }\n            for (m=2; m<32; m+=2) {\n                s = &samples[m*avctx->channels + channel];\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n                        int level = sign_extend(*src >> (4 - i), 4) << shift[n];\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n                    }\n                }\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_AMV:\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n        c->status[0].step_index = bytestream_get_le16(&src);\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n            src+=4;\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            char hi, lo;\n            lo = *src & 0x0F;\n            hi = *src >> 4;\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n                FFSWAP(char, hi, lo);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                lo, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                hi, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_CT:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case CODEC_ID_ADPCM_SBPRO_4:\n    case CODEC_ID_ADPCM_SBPRO_3:\n    case CODEC_ID_ADPCM_SBPRO_2:\n        if (!c->status[0].step_index) {\n            /* the first byte is a raw sample */\n            *samples++ = 128 * (*src++ - 0x80);\n            if (st)\n              *samples++ = 128 * (*src++ - 0x80);\n            c->status[0].step_index = 1;\n            nb_samples--;\n        }\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n            for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] >> 4, 4, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x0F, 4, 0);\n            }\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n            for (n = nb_samples / 3; n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 5        , 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x07, 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] & 0x03, 2, 0);\n            }\n        } else {\n            for (n = nb_samples >> (2 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 6        , 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    (src[0] >> 4) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x03, 2, 2);\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_SWF:\n    {\n        GetBitContext gb;\n        const int *table;\n        int k0, signmask, nb_bits, count;\n        int size = buf_size*8;\n        init_get_bits(&gb, buf, size);\n        //read bits & initial values\n        nb_bits = get_bits(&gb, 2)+2;\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n        table = swf_index_tables[nb_bits-2];\n        k0 = 1 << (nb_bits-2);\n        signmask = 1 << (nb_bits-1);\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n            for (i = 0; i < avctx->channels; i++) {\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n                c->status[i].step_index = get_bits(&gb, 6);\n            }\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n                int i;\n                for (i = 0; i < avctx->channels; i++) {\n                    // similar to IMA adpcm\n                    int delta = get_bits(&gb, nb_bits);\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n                    int k = k0;\n                    do {\n                        if (delta & k)\n                            vpdiff += step;\n                        step >>= 1;\n                        k >>= 1;\n                    } while(k);\n                    vpdiff += step;\n                    if (delta & signmask)\n                        c->status[i].predictor -= vpdiff;\n                    else\n                        c->status[i].predictor += vpdiff;\n                    c->status[i].step_index += table[delta & (~signmask)];\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n                    *samples++ = c->status[i].predictor;\n                }\n            }\n        }\n        src += buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_YAMAHA:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n        }\n        break;\n    case CODEC_ID_ADPCM_THP:\n    {\n        int table[2][16];\n        int prev[2][2];\n        int ch;\n        src += 4; // skip channel size\n        src += 4; // skip number of samples (already read)\n        for (i = 0; i < 32; i++)\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n        /* Initialize the previous sample.  */\n        for (i = 0; i < 4; i++)\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n        for (ch = 0; ch <= st; ch++) {\n            samples = (short *)c->frame.data[0] + ch;\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < nb_samples / 14; i++) {\n                int index = (*src >> 4) & 7;\n                unsigned int exp = *src++ & 15;\n                int factor1 = table[ch][index * 2];\n                int factor2 = table[ch][index * 2 + 1];\n                /* Decode 14 samples.  */\n                for (n = 0; n < 14; n++) {\n                    int32_t sampledat;\n                    if(n&1) sampledat = sign_extend(*src++, 4);\n                    else    sampledat = sign_extend(*src >> 4, 4);\n                    sampledat = ((prev[ch][0]*factor1\n                                + prev[ch][1]*factor2) >> 11) + (sampledat << exp);\n                    *samples = av_clip_int16(sampledat);\n                    prev[ch][1] = prev[ch][0];\n                    prev[ch][0] = *samples++;\n                    /* In case of stereo, skip one sample, this sample\n                       is for the other channel.  */\n                    samples += st;\n                }\n            }\n        }\n        break;\n    }\n    default:\n        return -1;\n    }\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n    return src - buf;\n}", "idx": 16664, "substitutes": {"avctx": ["ajpkg", "AVctx", "avctl", "abcp", " avcontext", "aveconn", "AVcp", "afcc", " avcmd", "avconn", " avctl", " avkl", "avjac", "afctx", "ajcc", "avpkg", "afpkg", "avercfg", "avekl", "avcmd", "avetx", "avecontext", "navcontext", "avcpu", "avcu", "avecmp", "apcmd", "avertx", "AVcontext", "avepkg", " avtx", "averkl", "abhandle", "avecp", "averpkg", "abhistory", "apctx", "avcp", "avehandle", "averconn", "avercontext", "abcpu", "vctx", "vcontext", "apcontext", "vtx", "avcc", "avhistory", "afctl", " avcfg", " avhistory", "afhandle", " avcpu", "avkl", "avcontext", "avcfg", "avectl", "AVcmp", "avectx", "avejac", "ajcu", " avcmp", "avecu", "abctl", "apconn", "afcp", "avercc", "avecfg", "avercu", "abcmp", " avcp", "aptx", "abtx", "avcmp", "ajctx", "avhandle", " avconn", "averhistory", " avpkg", "averctx", "abjac", "abcontext", "navctl", "AVtx", "ajcfg", "navctx", "avecmd", "avtx", "vconn", "abctx", "navcpu", "avercmp", "AVjac"], "data": ["next", "offset", "frame", "fields", "size", "t", "window", "w", "args", "pad", "flags", "p", "input", "feed", "output", "empty", "dat", "ata", "padding", "header", "map", "length", "values", "content", "name", "image", "d", "DATA", "bytes", "mu", "Data", "video", "read", "da", "value", "id", "body", "rel", "r", "batch", "message", "options", "raw", "extra", "o", "align", "cache", "block", "bin", "buffer", "f", "filter", "text", "type"], "got_frame_ptr": ["got_frame2handle", "got_frame_handle", "got_frames_handle", "got_frames_pointers", "got_frame2pointers", "got_frame2ptr", "got_frame_pointer", "got_frame_pointers", "got_frame2pointer", "got_frames_ptr", "got_frames_pointer"], "avpkt": ["avpst", "avvkl", "avfkt", "avdacket", "avpwt", "vanparfx", "avwpkg", "avvkt", "ajvwt", " avPacket", " avPkt", "avapkl", "avPkg", "avpackct", "ajpwt", "avapwt", "avwpst", " avPkg", " avPst", "avpacket", "avpct", "avPfx", "avpdu", "vanpardu", " avpacket", "ajvkl", "avPkt", "vanpdu", "avPdu", "avfwt", "avpfx", "avapdu", "avdkt", "vanparkt", "ajvdu", "avpardu", " avpkg", "vanpkt", "avvwt", "ajpkl", "avpkg", "avparkt", "avdkg", "vanparct", "ajpkt", "avdst", "avPst", "avfkl", "ajvkt", "avparct", "avwpacket", "avpackfx", "avparfx", "ajpdu", "vanpct", "avwpkt", "avvdu", "avapkt", "avfdu", "avpackdu", " avpst", "avpackkt", "avPct", "vanpfx", "avpkl", "avPacket"], "buf": ["late", "mem", "pos", "cv", "loc", "window", "img", "proc", "bh", "ctx", "vec", "map", "tmp", "length", "queue", "db", "bytes", "pb", "doc", "ptr", "cmd", "msg", "pkg", "ref", "batch", "raw", "path", "rb", "cache", "txt", "cb", "block", "nm", "bin", "uf", "rc", "buffer", "buff", "b", "seq", "br"], "c": ["con", "cv", "tc", "l", "ca", "t", "ci", "p", "mc", "cn", "ec", "ctx", "pc", "gc", "cl", "g", "cam", "cf", "vc", "cc", "bc", "ct", "co", "d", "v", "etc", "cd", "cont", "cr", "comm", "cmp", "lc", "cm", "dc", "C", "fc", "ce", "cu", "cache", "cb", "anc", "xc", "com", "cp", "f", "abc", "ac", "comp", "rc", "b", "conf"], "cs": ["hs", "cv", "ds", "tc", "ci", "csv", "ec", "ics", "cn", "ks", "ctx", "cons", "qs", "pc", "bs", "cf", "rs", "gs", "vc", "cc", "ns", "sts", "vs", "ps", "js", "ants", "css", "ats", "Cs", "cmp", "lc", "cks", "fs", "fc", "acs", "ts", "ls", "cus", "cp", "stats", "CS", "ms", "wcs", "sc"], "n": ["na", "t", "p", "num", "en", "cn", "ne", "g", "ni", "mn", "d", "v", "ns", "k", "nn", "sn", "nb", "nu", "j", "N", "nm", "nc", "rn", "len", "net"], "m": ["bm", "man", "l", "t", "im", "p", "num", "mc", "sm", "mn", "v", "mu", "mi", "msg", "M", "dm", "r", "min", "cm", "mult", "dim", "nm", "mid", "f", "mut", "middle", "mode"], "channel": ["pixel", "connection", "index", "bean", "frame", "face", "chron", "can", "server", "chapter", "component", "window", "slot", "client", "cell", "annels", "column", "change", "chip", "course", "button", "config", "cam", "command", "ann", "queue", "unit", "axis", "label", "instance", "peer", "monitor", "chan", "ind", "id", "mode", "entity", "CHO", "field", "version", "batch", "camera", "member", "cm", "number", "key", "coord", "Channel", "row", "section", "panel", "chn", "chain", "broad", "character", "part", "sc", "direction", "status", "counter", "col", "category"], "i": ["index", "l", "t", "ci", "im", "p", "ir", "e", "I", "ai", "v", "di", "k", "ip", "mi", "pi", "ind", "id", "j", "ti", "x", "f", "it", "y", "ii"], "samples": ["ssamps", "tamples", "ssources", "Samples", "samps", "tamps", "tources", "ssamp", "sizes", "Sizes", "ssamples", "Sources", "ssizes", "Samp", "tamp", "Samps", "samp", "sources"], "src": ["offset", "loc", "np", "seed", "filename", "img", "sb", "sub", "proc", "input", "sq", "stream", "bs", "syn", "rs", "tmp", "length", "seek", "conv", "ptr", "iter", "supp", "addr", "sn", "sys", "ind", "inst", "ref", "r", "sync", "origin", "std", "raw", "str", "fc", "source", "txt", "sr", "from", "rc", "stats", "scan", "url", "fp", "ctr", "sc", "b", "dest", "ser", "sample"], "st": ["pos", "z", "size", "t", "w", "ist", "p", "sp", "stage", "stream", "at", "set", "step", "ct", "ste", "out", "stop", "sw", "d", "St", "start", "sth", "inst", "r", "std", "ST", "str", "sta", "est", "state", "x", "nd", "tt", "rest", "it", "ost", "status", "iat"], "count1": ["length1", " count0", "code1", "length3", "count0", "length0", "code2", " count3", "count3", "code3", "code0", "length2"], "count2": ["conf02", "lengthtwo", "length3", "conf3", "Counttwo", "length02", "Count02", "count3", "conftwo", "count02", "conf2", "counttwo", "Count3", "length2", "Count2"], "nb_samples": ["nb_socks", "nb_isamples", "nb_swores", "nb67spamps", "nb_mamples", "nb_psamp", "nb_tamples", "nbntservutes", "nb_mizes", "nb_isocks", "nb_gizes", "nb_samp", "nbntservamps", "nb_gamples", "nb_servamps", "nb_gabilities", "nb__samp", "nb_absamples", "nb_spamples", "nb_sutes", "nb_sumps", "nb67samples", "nb_samps", "nb_bamps", "nb67sots", "nb_nocks", "nb_namples", "nb_sizes", "nb__psamp", "nb_sannels", "nb_swamples", "nb_nances", "nb_shaves", "nb_exannels", "nb_stringsips", "nb_swots", "nb_sances", "nb_servips", "nb_damples", "nb_mamps", "nb_sacks", "nb_spores", "nb67spamples", "nb_isances", "nbntsips", "nb_psizes", "nb67samps", "nb_bamples", "nb_Sizes", "nb_spamps", "nb_sucks", "nbntsamples", "nb_bannels", "nb_servamples", "nbntservamples", "nb_dacks", "nb_sabilities", "nb_shumps", "nb__psamples", "nb__samples", "nb__psizes", "nb_bizes", "nbntsutes", "nb_psamples", "nb_shamples", "nb_stringsutes", "nb_spots", "nb_backs", "nb67spots", "nb_naves", "nb_shucks", "nb_Sacks", "nb_gamps", "nb_damps", "nb_Sannels", "nb_Samp", "nb__sizes", "nb_stringsamps", "nb_tumps", "nb_Samps", "nb67sores", "nb_servutes", "nbntservips", "nb_sots", "nb_isaves", "nb_mabilities", "nb_examps", "nb_swamps", "nb_absumps", "nb_Sabilities", "nb67spores", "nb_stringsamples", "nb_examples", "nb_namp", "nb_absaves", "nb_taves", "nbntsamps", "nb_saves", "nb_nizes", "nb_Samples", "nb_sips", "nb_dizes", "nb_sores", "nb_absucks", "nb_tucks", "nb_exizes"], "coded_samples": ["coded_nims", "coded_Sents", "coded_pamps", "coded_isamps", "coded_gamps", "coded_pucks", "coded_isumbers", "coded_osples", "coded_Sucks", "coded_sucks", "coded_sents", "coded_seamples", "coded_examps", "coded_gims", "coded_namples", "coded_gents", "coded_Samples", "coded_Sims", "coded_Sample", "coded_osamples", "coded_pounds", "coded_sample", "coded_alides", "coded_osamps", "coded_sumbers", "coded_seumbers", "coded_sides", "coded_samps", "coded_sounds", "coded_hucks", "coded_exples", "coded_Sumbers", "coded_hamples", "coded_exents", "coded_namps", "coded_hamps", "coded_seample", "coded_gamples", "coded_seamps", "coded_isamples", "coded_pamples", "coded_alounds", "coded_sims", "coded_pides", "coded_nents", "coded_Sples", "coded_hples", "coded_alamples", "coded_Samps", "coded_sples", "coded_pples", "coded_examples", "coded_osents", "coded_alples", "coded_isample"], "ret": ["mem", "rm", "res", "nt", "deg", "back", "flag", "t", "dt", "result", "ll", "Ret", "err", "last", "rt", "tmp", "tr", "out", "mat", "fin", "reg", "progress", "cont", " Ret", "rem", "reset", "RET", "re", "rev", "det", "reply", "ref", "val", "new", "alt", "repl", "txt", "len", "resp", "not", "fun", "gt", "it", "elt", "red", "rets"], "predictor": ["padaptutor", "pocolored", "pochitor", "ppector", "pochor", "pochutor", "pocoltor", "pprioring", "ppredori", "pocolutor", "prerediction", "pjectori", "peredictutor", "ppriractor", "pochractor", "ipictionori", "prediction", "pereciitor", "proxor", "proredictor", "ipictionoring", "proredictory", "propectory", "peprioral", "predictutor", "peprior", "practutor", "predicttor", "ipredictor", "ipredictori", "ipictionor", "predictored", "pjector", "peredictor", "peredictitor", "ipredictory", "priptutor", "pereciractor", "pstickor", "pocolor", "preredictori", "proxori", "predictator", " predicttor", "ppredor", "pription", " pocoltor", "peprioring", "predictoral", "ppectory", "predictoring", "pstickored", "perecior", "predictory", "peredictoral", "ipictionory", "padaptor", "predictori", "pripttor", "pprior", "prejection", "pocolory", "pictionor", "prejectori", " predictoral", "pstickator", "proxory", "priptori", "pereciutor", "propectator", "propectored", " pocoloral", "pprioral", "priptractor", "pstickory", "predictractor", "ppectored", " predictutor", "pjectory", "precior", "pepriractor", "proredictator", "prejector", "practor", "preredictory", "prejectory", "priptory", "propector", "ipredictoring", "predictitor", " pocolutor", "proxion", " pocolor", "preciutor", "peredictoring", "pictionory", "pocoloring", "preredictor", "ppredory", "padaptitor", "priptor", "preciitor", "peredictractor", "pocolator", "padaptractor", "practoral", "pocolractor", "ppredoring", "pictionoring", "priptoring", "preciractor", "pjectoring", "pjection", "proredictored", "pocoloral", "practtor", "ppectator", "priptoral", "pictionori"], "step_index": [" step2index", " step2number", "step1number", "step_ind", "step2Index", " step_number", "STEP_id", "step_id", "step2num", " step_Index", "step2is", "step1Index", "STEP_level", " step2num", "step1index", " step_num", "step1num", "step_level", "step_Index", " step2Index", "stepxindex", " step_ind", "STEP_ind", "stepxi", "stepxind", "step2index", "step2i", "step_i", "step2ind", " step_size", "step_number", " step_i", " step2ind", " step2i", "stepxIndex", "step2number", "step_size", "step_is", " step2size", "step_num", "step2size", "STEP_index", " step_is", " step2is"]}}
{"project": "qemu", "commit_id": "a38648290ee277c7cb8a53eabdcdb08bb7a9f23f", "target": 1, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16666, "substitutes": {"req": ["tx", "test", "ctx", "good", "rt", "fr", "crit", "requ", "rr", "pro", "sys", "esp", "rd", "wrapper", "inv", "aux", "exec", "dist", "desc", "q", "required", "compl", "cur", "tf", "ps", " sched", "msg", "pkg", "range", "forced", "rss", "usr", "low", "qt", "resp", "urg", "org", "worker", "err", "res", "rx", "expr", "buf", "prefix", "tr", "queue", " requ", "progress", "http", "gr", "quest", "request", "xml", "rc", "qq", "needed", "require", "history", "deg", "md", "sq", "config", "rec", "seq", "wx", "cmd", "eq", "ind", "rel", "ref", "r", "coord", "rh", "comp", "rpm", "conf", "rl", "dq"], "i": ["hi", "ski", "li", "ql", "ri", "g", "point", "I", "ai", "di", "iter", "mi", "c", "ji", "chain", "ex", "multi", "ii", "index", "t", "ci", "q", "\u0438", "phi", "v", "cli", "pi", "gi", "n", "bi", "x", "zi", "ini", "f", "it", "iu", "PI", "init", "ic", "ei", "qi", " ti", "me", "user", " ii", "name", "ip", " j", "j", "ti", "uri", "info", " bi", "ie", "ix", "y", "m", "si", "im", "p", "client", "ki", " pi", "is", "oi", "ind", "id", "in", "xi", "ui", "ims", " v", " m", "sim", "ms"], "sign": ["round", "grad", "form", "sch", "si", "size", "sh", "close", "pay", "sq", "set", "shift", "scale", "sum", "is", "mod", "pres", "sa", "ss", "sem", "wrap", "mask", "se", "add", "ig", "mark", "sd", "dig", "ind", "gate", "fix", "trade", "operator", "ign", "draw", "sha", " SIGN", "diff", "just", "act", "align", "sche", "s", "ver", "mut", "go", "trust", "angle", "spec", "sc", "SIGN", "min", "pen", "Sign"], "tmp": ["temp", "img", "pad", "ghost", "st", "test", "ctx", "mobi", "good", "rt", "zip", "mb", "obj", "pretty", "mp", "diff", "tm", "bt", "emp", "td", "trap", "np", "perm", "t", "dust", "pp", "sp", "var", "result", "mmm", "gz", "etc", "v", "tf", "msg", "pkg", "null", "buff", "snap", "tc", "nt", "wp", "mm", "tar", "buf", "uv", "ptr", "attr", "cmp", "txt", "prime", "tg", "nd", "cp", "tt", "mint", "qq", "m", "stuff", "MP", "p", "vt", "xy", "tn", "db", "gb", "mk", "new", "extra", "top", "tty", "uf", "vv", "gm"]}}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static char *choose_pixel_fmts(OutputStream *ost)\n\n{\n\n    if (ost->keep_pix_fmt) {\n\n        if (ost->filter)\n\n            avfilter_graph_set_auto_convert(ost->filter->graph->graph,\n\n                                            AVFILTER_AUTO_CONVERT_NONE);\n\n        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)\n\n            return NULL;\n\n        ost->pix_fmts[0] = ost->st->codec->pix_fmt;\n\n        return ost->pix_fmts;\n\n    }\n\n    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {\n\n        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));\n\n    } else if (ost->enc->pix_fmts) {\n\n        const enum PixelFormat *p;\n\n        AVIOContext *s = NULL;\n\n        uint8_t *ret;\n\n        int len;\n\n\n\n        if (avio_open_dyn_buf(&s) < 0)\n\n            exit_program(1);\n\n\n\n        p = ost->enc->pix_fmts;\n\n        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };\n\n            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,\n\n                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };\n\n            }\n\n        }\n\n\n\n        for (; *p != PIX_FMT_NONE; p++)\n\n            avio_printf(s, \"%s:\", av_get_pix_fmt_name(*p));\n\n        len = avio_close_dyn_buf(s, &ret);\n\n        ret[len - 1] = 0;\n\n        return ret;\n\n    } else\n\n        return NULL;\n\n}\n", "idx": 16693, "substitutes": {"ost": ["ist", "st", "otype", "rt", "lost", "lov", "dit", "oth", "ox", "news", "boost", " nost", "host", "oad", "art", "ud", "wn", "ott", "irst", "roc", "ty", "tto", "os", "gob", "utt", "ot", "etc", "upload", "ast", "ous", "mont", "ocr", "ict", "ood", "post", "rss", "obs", "hyd", "usr", "yt", "rest", "bott", "past", "poll", "drm", "old", "nt", "ord", "wp", "mm", "rost", "rom", "expr", "stat", "mt", "htt", "sty", "wikipedia", "ogg", "embed", "ird", "stone", "oster", "tt", "od", "hop", "must", "oss", "omm", "ob", "aft", "rend", "osta", "ond", "inst", "oid", "wart", "ust", "est", "sta", "rog", "OST"], "p": ["a", "lp", "np", "perm", "t", "wp", "pr", "i", "pp", "sp", "h", "q", "bp", "pc", "per", "op", "vp", "u", "tp", "pro", "rep", "v", "pb", "ip", "ps", "c", "pkg", "pt", "j", "r", "jp", "o", "pat", "par", "pa", "ep", "cp", "php", "f", "fp", "pe", "P", "ap", "m"], "s": ["a", "hs", "ds", "cs", "os", "ops", "t", "i", "sb", "ins", "h", "is", "bs", "g", "rs", "gs", "S", "ss", "ns", "sts", "ps", "sys", "js", "c", "es", "ats", "n", "fs", "ts", "ls", "stats", "ms", "b", "its"], "ret": ["mem", "res", "nt", "final", "result", "gc", "vals", "buf", "tmp", "mt", "out", "conv", "RET", "reset", "re", "rev", "tag", "val", "new", "pas", "alt", "uf", "resp", "status", "Ret"], "len": [" length", "mem", "cap", "l", "el", "t", "lib", "en", "vec", " l", "length", "name", "ln", "c", "ref", "L", "cmp", "str", "n", " bl", " Len", "ls", " clen", "Len", "file", "err"]}}
{"project": "FFmpeg", "commit_id": "5e2202d6f3ac2f3afd714a62437ca6b24f75c09f", "target": 1, "func": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)\n\n{\n\n    char buffer[32];\n\n    if (time) {\n\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));\n\n        av_metadata_set2(metadata, \"creation_time\", buffer, 0);\n\n    }\n\n}\n", "idx": 16700, "substitutes": {"metadata": ["managed", "iso", "aka", "about", "memory", "basic", "details", "md", "tar", "maybe", "config", "map", "dirty", "header", "profile", "node", "pdf", "ka", "mt", "ad", "partial", "properties", "google", "latest", "data", "json", "adata", "met", "ATA", "template", "message", "options", "summary", "directory", "package", "info", "xml", "meta", "database", "m"], "time": ["check", "offset", "tim", "duration", "size", "t", "window", "im", "comment", "before", "timeout", "TIME", "user", "IME", "set", "end", "etime", "runtime", " timestamp", "hour", "ype", "created", "timer", "node", "length", "mt", "name", "stop", "start", "inter", "clock", " Time", "instance", "value", "data", "func", "id", "UTC", "sync", "template", "message", "date", "context", "str", "transform", "now", "path", "Time", "info", "tm", "ts", "ime", "year", "code", "month", "event", "trace", "mode", "type"], "buffer": ["mem", "offset", "index", "server", "memory", "window", "comment", "pad", "bb", "result", "interface", "stream", "text", "base", "output", "buf", "button", "header", "command", "length", "engine", "queue", "bytes", "variable", "limit", "iter", "read", "document", "data", "page", "record", "batch", "message", "context", "line", "table", "raw", "cache", "null", "block", "screen", "row", "Buffer", "buff", "b", "byte", "stack"]}}
{"project": "qemu", "commit_id": "6982d6647ea98544f76d5ef40ddc23115ff44a77", "target": 1, "func": "static uint32_t hpet_ram_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            printf(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                return timer->config;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                return timer->config >> 32;\n\n            case HPET_TN_CMP: // comparator register\n\n                return timer->cmp;\n\n            case HPET_TN_CMP + 4:\n\n                return timer->cmp >> 32;\n\n            case HPET_TN_ROUTE:\n\n                return timer->fsb >> 32;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return s->capability;\n\n            case HPET_PERIOD:\n\n                return s->capability >> 32;\n\n            case HPET_CFG:\n\n                return s->config;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl \\n\");\n\n                return 0;\n\n            case HPET_COUNTER:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick;\n\n            case HPET_COUNTER + 4:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick >> 32;\n\n            case HPET_STATUS:\n\n                return s->isr;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16708, "substitutes": {"opaque": ["opane", "Opaque", " opque", "Oposter", "oposter", "obaque", "Opane", "opaques", " opaques", "OPque", "obaques", "compane", "OPcache", "composter", "compacity", "Opacity", " oposter", " opcache", "obque", "compaque", " opane", " opacity", "opacity", "opque", "obcache", "OPaques", "opcache", "OPaque"], "addr": ["offset", "pos", "mem", "init", "loc", "z", "arr", "ord", "pad", "i", "tx", "var", "asm", "mb", "hz", "hash", "ctx", "kt", "adr", "ace", "point", "atom", "tmp", "prefix", "mt", "alloc", " address", "ad", "address", "seek", "name", "ock", "off", "hw", "ptr", "obj", "inter", "add", "attr", "conn", "cmd", "pkg", "ref", "r", "__", "ash", "host", "oad", "align", "now", "act", "alt", "alias", "dh", "state", "coord", "oa", "x", "block", "Address", "ack", "arp", "gt", "src", "ix", "gate"], "s": ["results", "ches", "e", "vals", "rs", "vs", "obj", "self", "sys", "sets", "c", "es", "comm", "fs", "er", "spec", "sis", "sl", "os", "t", "sp", "sm", "qs", "S", "ss", "sts", "v", "ments", "ps", "xs", "erences", "n", "o", "ts", "ls", "parts", "stats", "objects", "eds", "a", "ds", "w", "terms", "sb", "as", "ses", "changes", "als", "sv", "sw", "js", "state", "ssl", "an", "states", "b", "m", "hs", "ists", "p", "ers", "sq", "aws", "h", "ands", "is", "bs", "gs", "ries", "ports", "ns", "ations", "aps", "tes", "ats", "less", "actions", "ims", "sim", "ms", "its"], "cur_tick": [" cur_tty", "cor_tick", "cor__tz", " cur_poll", "cur_cycle", "curpttick", "curmmbyte", "curtpoll", "curitycycle", "curvtick", " cur_trigger", "cur_stick", "cur___pick", "curtpick", " cur_tz", "curvick", "curptcycle", "curPpick", " cur_shot", "curxtoken", " cur_cycle", " cur_ick", "curpttoken", "curpttty", "curxtick", "cur_tty", "curitytz", "curptick", "curmmick", " cur_loop", "cur_byte", "cur_shot", "cur_mill", " cur_mill", "curJcycle", "cor__tick", " cur_stick", "cor__ick", "curxtrigger", "curvpick", "cor_tz", "curMtick", "cor_cycle", "curPbyte", "curPick", "cur_poll", "cur__tz", "curptshot", "cur_ick", " cur_pick", "curxick", "curMick", "cur__ick", "cur_token", " cur_byte", "cur__tick", "curJloop", "cor_ick", "curvpoll", " cur_token", "curmmtick", "cur___ick", "curityick", "curPtick", "curtick", "curitytick", "cur_trigger", "cor__cycle", "curttick", "curMtrigger", "cur__cycle", "curJtick", "curptloop", "curMtoken", "cur_tz", "cur_pick", "curtstick", "cur___tick", "cur___stick", "curmmpick", "cur_loop", "curJtty"], "index": ["offset", "pos", "check", "loc", "error", "can", "seed", "location", "size", "slice", "i", "tx", "num", "timeout", "input", "test", "hash", "ctx", "set", "zero", "find", "action", "lock", "point", "shape", "link", "Index", "length", "node", "address", "position", "db", "seek", "label", "axis", "pointer", "iter", "obj", "ex", "order", "range", "cmd", "typ", "ind", "id", "height", "ref", "val", "context", "rank", "act", "key", "vector", "x", "info", "block", "open", "row", "scan", "ix", "angle", "code", "status", "dd", "gate", "loop", "type"], "timer": ["temp", "tim", "duration", "tc", "ramer", "tz", "t", "byter", "ter", "tom", "term", "imer", "menu", "timeout", "tick", "dt", "tar", "cell", "test", "handler", "walker", "program", "span", "task", "tem", "Timer", "actor", "cker", "mr", "header", "atom", "iler", "writer", "loader", "variable", "thread", "clock", "iter", "trigger", "parser", "peer", "time", "monitor", "wrapper", "processor", "tower", "runner", "cer", "ger", "er", "finder", "state", "tm", "later", "trace", "player", "meter", "browser", "transfer", "taker", "event", "counter", "worker"]}}
{"project": "qemu", "commit_id": "bd8b92d5c8387c2c94f06665514c05000169fafd", "target": 1, "func": "void usb_claim_port(USBDevice *dev, Error **errp)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    assert(dev->port == NULL);\n\n\n\n    if (dev->port_path) {\n\n        QTAILQ_FOREACH(port, &bus->free, next) {\n\n            if (strcmp(port->path, dev->port_path) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (port == NULL) {\n\n            error_setg(errp, \"usb port %s (bus %s) not found (in use?)\",\n\n                       dev->port_path, bus->qbus.name);\n\n            return;\n\n        }\n\n    } else {\n\n        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), \"usb-hub\") != 0) {\n\n            /* Create a new hub and chain it on */\n\n            usb_create_simple(bus, \"usb-hub\");\n\n        }\n\n        if (bus->nfree == 0) {\n\n            error_setg(errp, \"tried to attach usb device %s to a bus \"\n\n                       \"with no free ports\", dev->product_desc);\n\n            return;\n\n        }\n\n        port = QTAILQ_FIRST(&bus->free);\n\n    }\n\n    trace_usb_port_claim(bus->busnr, port->path);\n\n\n\n    QTAILQ_REMOVE(&bus->free, port, next);\n\n    bus->nfree--;\n\n\n\n    dev->port = port;\n\n    port->dev = dev;\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->used, port, next);\n\n    bus->nused++;\n\n}\n", "idx": 16717, "substitutes": {"dev": ["loc", "pad", "valid", "test", "av", "conf", "cam", "ad", "pro", "obj", "iv", "sys", "driver", "priv", "req", "den", "gu", "dem", "serv", "spec", "ex", "dd", "mem", "die", "dist", "de", "desc", "var", "app", "device", "prov", "usb", "d", "v", "hw", "doc", "add", "pt", "env", "ver", "tech", "event", "patch", " device", "ds", "nt", "w", " doc", "proc", "dis", "DEV", " ov", "buf", "des", "serial", "det", "att", "ev", "fo", " priv", "def", "info", "Device", "go", "did", "od", "dn", "debug", "dep", "Dev", "md", "util", " def", " spec", "db", " devs", "ve", "wd", "conn", "sd", " adm", "cmd", "ind", "ext", "rel", "val", "api", "vol", "dest", "iver"], "errp": ["erping", " errr", " errpa", "errm", "rerp", "rrm", "strpe", "strp", "ferpc", "ferp", "erp", "errpa", "erm", "errr", "errpc", "derr", "ferpe", "rrr", " errpc", "derp", "rrping", "rrp", "rerr", "errpe", "derm", "errping", "strP", "strpc", "ferP", "errP", " errpe", "erpa", "rerpa", "derping", " errP", "err"], "bus": ["back", "bits", "ck", "lib", "ctx", "mount", "uss", "cast", "self", "cat", "driver", "plug", "sync", "local", "host", "cache", "book", "chain", "boot", "gen", "way", "os", "bh", "stick", "lock", "usb", "handle", "soc", "BUS", "ass", "ack", "cus", "proxy", "bill", "nt", "box", "proc", "bar", "user", "buf", "disk", "bc", "bug", "http", "hand", "um", "docker", "state", "kernel", "block", "b", "bool", "loop", "US", "bal", "pos", " busy", "bridge", "board", "used", "store", "bur", "bo", "is", "kit", "bs", "util", "config", "cpu", "db", "bid", "conn", "hub", "data", "Bus", "pool", "tag", " BUS", "bank", "vol", "phys", "ac", "us", "trace", "br"], "port": ["export", "pr", "pad", "ping", "report", "test", "point", "pit", "length", "PORT", "pro", "peer", " Port", "page", "project", "path", "gp", "be", "buffer", " transport", "import", "pe", "connection", "index", "server", "pipe", "pp", "var", "ORT", "list", "pport", "device", "pan", "handle", "ot", "limit", "tip", "range", "pi", "pt", "post", "null", "entry", "ver", "it", "po", "version", "proxy", "Port", "mit", "per", "profile", "mobile", "mt", "queue", "name", "eport", "ptr", "target", "to", "vision", "ported", "pose", "cp", "P", "trace", "priority", "next", "pos", "bridge", "seat", "phy", "p", "client", "ort", "pid", "pc", " sport", "position", "out", "ports", "pod", "unit", "ve", "pool", "tag", "val", "message", "table", "key", "file", "pen", "type"], "nfree": ["mFree", "Navailable", "unavailable", "Nused", "mavailable", "unfree", "nFREE", "NFree", " navailable", "unFree", "Nfree", "nFree", "mfree", "mused", "unFREE", " nFree", "NFREE", " nFREE", "navailable"], "nused": ["nneeded", "ntneeded", "cneeded", "ntUsed", "ntfree", "newfree", "cUsed", "newused", "newUsed", "nUsed", "cfree", "ntused", "cused", "newneeded"]}}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "static void vmxnet3_update_features(VMXNET3State *s)\n\n{\n\n    uint32_t guest_features;\n\n    int rxcso_supported;\n\n\n\n    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,\n\n                                               devRead.misc.uptFeatures);\n\n\n\n    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);\n\n    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);\n\n    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);\n\n\n\n    VMW_CFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\",\n\n              s->lro_supported, rxcso_supported,\n\n              s->rx_vlan_stripping);\n\n    if (s->peer_has_vhdr) {\n\n        qemu_peer_set_offload(qemu_get_queue(s->nic),\n\n                        rxcso_supported,\n\n                        s->lro_supported,\n\n                        s->lro_supported,\n\n                        0,\n\n                        0);\n\n    }\n\n}\n", "idx": 16723, "substitutes": {"s": ["services", "ies", "a", "hs", "ds", "cs", "states", "os", "ops", "t", "w", "sb", "p", "as", "ses", "st", "changes", "sq", "details", "aws", "h", "als", "store", "set", "qs", "is", "bs", "sv", "rs", "gs", "S", "ss", "so", "des", "d", "ports", "ns", "v", "sts", "vs", "se", "ps", "js", "spec", "c", "pers", "comm", "n", "fs", "less", "ts", "ims", "ls", "params", "stats", "ms", "sis", "sl", "b", "its", "m"], "guest_features": ["guility_features", "guarentlyreports", "guess_results", "guest____links", "guess_faces", "guarentlyrelations", "guest2feature", "guest_flags", "guest_links", "guestfulterms", "guestlytimes", "guEST_members", "guest_feature", "guest_members", "guestmatabilities", "guEST_abilities", "guestlyfeatures", "guhouse_features", "guEST_features", "guest_relations", "guess_flags", "guestlyfits", "guility_links", "guest2forms", "guest_forms", "guarent_reports", "guility_forms", "guarent_fits", "guhouse_results", "guestlyrelations", "guhouse_abilities", "guestXfeatures", "guestmattimes", "guest_fits", "guest____features", "guestXfits", "guility_feature", "guESTlymembers", "guestfulrelations", "guestlyreports", "guest_terms", "guestXreports", "guestlyabilities", "guhouse_terms", "guestfulresults", "guest2features", "guESTlyabilities", "guest_reports", "guarent_relations", "guestmatmembers", "guest_abilities", "guestXrelations", "guestlymembers", "guestfulreports", "guest_times", "guest____forms", "guEST_times", "guess_features", "guest_results", "guestmatfeatures", "guarentlyfits", "guarentlyfeatures", "guESTlytimes", "guestfulfits", "guest2links", "guestfulabilities", "guest____feature", "guest_faces", "guESTlyfeatures", "guestfulfeatures", "guarent_features"], "rxcso_supported": ["rxcsi67supported", "rxcso_allowed", "rxcso67supported", "rxcSo_support", "rxcso67Supported", "rxcso__enabled", "rxcsi67enabled", "rxcSO_allowed", "rxcso_supp", "rxcsi67supp", "rxcsi_enabled", "rxcsi67Supported", "rxcsi_Supported", "rxcSo_enabled", "rxcsi_supp", "rxcso_Supported", "rxcsi_supported", "rxcso_enabled", "rxcso__supported", "rxcSo_supported", "rxcSO_supported", "rxcso__support", "rxcso_powered", "rxcso67supp", "rxcso67enabled", "rxcSO_powered", "rxcso_support"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int virtio_blk_exit_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n\n\n    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);\n\n    return virtio_exit_pci(pci_dev);\n\n}\n", "idx": 16724, "substitutes": {"pci_dev": ["pciabledevice", "pci_priv", "pciableev", "pci_info", "pci2devices", "pdi_device", "pdi_def", "pci_cur", "pct_device", "pcu_dev", "pci_def", "pdi_Dev", "pdi_ev", "pci2dev", "pci_device", "pci2priv", "pci_ev", "pci2info", "pct_ev", "pdi_dev", "pcu_priv", "pcu_devices", "pci__def", "pci_devices", "pciablecur", "pci__ev", "pciabledev", "pci_Dev", "pct_cur", "pci__dev", "pcu_info", "pci__device", "pct_dev"], "proxy": ["server", "clone", "pipe", "roxy", "linux", "phy", "sup", "ping", "client", "remote", "xy", "port", "device", "boss", "cas", "link", "profile", "primary", "pro", "one", "Proxy", "friend", "response", "cor", "service", "manager", "reply", "target", "master", "dev", " proxies", "project", "PRO", "alias", "pse", "cache", "x", "info", "prime", "reverse", "shadow", "super", "slave", "version", "bus"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A = 0xffff<<14;\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]    ) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16727, "substitutes": {"ubuf0": ["ubuxee", "abuf0", "ubufee", "ubuf2", "ubux1", "ubuffer0", "ubool0", "ubbuf19", "ubux047", "abufee", "ubbuf1", "ubbuf047", "ubbuf0", "abuf2", "ubuffer1", "ubimg0", "ubool19", "ubimg1", "abbuf1", "abuf1", "ubimg19", "abbuf19", "abbufee", "abuf047", "ubuffer047", "ubimg2", "ubufferee", "abbuf2", "ubux0", "abuf19", "abbuf0", "ubool1", "ubbuf2", "abbuf047", "ubool2", "ubuf047", "ubbufee", "ubuf19"], "vbuf0": ["vbuff2", "vuf3", "bbuffer3", "bbuffer1", "vbuff3", "qbuf3", "vbuffer0", "bbuf0", "qbuf1", "bbuf1", "vbuf3", "quf3", "vbuffer2", "vbuff1", "vbuffer3", "vbuff0", "qbuf2", "qbuf0", "bbuf3", "vbuffer1", "vuf1", "quf1", "vuf2", "quf0", "bbuffer2", "quf2", "vuf0", "bbuffer0", "bbuf2", "vbuf2"], "i": ["a", "ic", "index", "ij", "l", "z", "si", "t", "ci", "im", "p", "ki", "qi", "list", "me", "ski", "err", "li", "is", "\u0438", "ri", "e", "point", "I", "ai", "phi", "v", "di", "cli", "io", "k", "ip", "mi", "pi", "c", "ind", "id", "oi", "j", "xi", "in", "ti", "ui", "batch", "gi", "n", "o", "ami", "multi", "ji", "bi", "iu", "x", "info", "zi", "ini", "sim", "status", "f", "chain", "it", "ix", "ex", "b", "y", "ii", "m"], "R": ["RE", "GR", "RR", "DR", "AR", "RO", "RGB", "RF", "I", "S", " r", "U", "RI", "H", "X", "RC", "M", "BR", "r", "L", "V", "D", "W", "C", "RA", "N", "SR", "MR", "A", "RB", "RG", "E", "Y", "RL", "P", "F", "T", "HR"], "G": ["GR", "GE", "Ge", "BG", "GU", "g", "Gb", "GA", "GC", "GG", "J", "Gr", "GD", "GB", "U", "Graphics", "VG", "H", "GH", "GP", "GF", "GM", "M", "gg", "Q", "PG", "Gh", "L", "Gu", "V", "LG", "GT", "C", "GI", "CG", "W", "Gs", "GV", "RG", "Y", "F"], "B": ["Br", "BG", "BA", "BW", "TB", "I", "J", "GB", "U", "H", "BM", "BC", "Bar", "SB", "M", "BR", "Q", "L", "V", "W", "C", "D", "N", "BL", "A", "Z", "BB", "E", "Y", "AB", "DB", "P", "F", "b", "WB", "T", "Base"], "ubuf1": ["ubump4", "umbuf1", "ubuf2", "ubump0", "umuf0", "ubump2", "ubuff0", "ubuf4", "ubbuf1", "umuf2", "ubbuf0", "umuf4", "ubuff4", "umuf1", "umbuf4", "umbuf0", "ubuff2", "umbuf2", "ubump1", "ubbuf2", "ubbuf4", "ubuff1"]}}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "func": "static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n", "idx": 16728, "substitutes": {"packet": ["presacket", "ppets", "preskt", "octets", "presets", "pets", "packkt", "ppacket", "packpet", "pkt", "ppet", "pppet", "octpet", "pet", "tenets", "preset", "packacket", "tenet", "tenpet", "tenacket", "octkt", "packets", "octacket", "octet"], "opaque": ["Oposit", "Opaque", "oppvious", "operois", "opvious", "opaques", "popvious", "oppaques", " opaques", " opush", "oposit", "operosit", "popaque", "poposit", "Opque", "operque", "oppush", "oppaque", "popque", "opois", "opque", "popaques", "opush", "operaque", "popois", "popush", " opvious", "Opois"], "s": ["a", "ies", "ds", "cs", "os", "t", "w", "i", "p", "sb", "ess", "as", "ses", "ins", "sq", "h", "q", "qs", "is", "e", "g", "rs", "gs", "S", "ss", "d", "ns", "sts", "ps", "js", "c", "xs", "j", "es", "ats", "n", "o", "fs", "ts", "ls", "stats", "sl", "b", "its", "m"], "async": ["aseync", "Assync", "assync", "Async", "assynchronous", "aync", "ASync", "Asynchronous", "aseynchronous", "asapter", " ASsync", "ASsync", "aload", "assyn", "assapter", "ASynchronous", "aseload", "asyn", "asssync", "asynchronous", "aseapter", "resyn", "lassync", "AsAsync", "asesync", "lasynchronous", "resynchronous", " ASynchronous", " ASapter", "resync", "asload", "lasAsync", "assload", "ASAsync", "lasyn", "aynchronous", "asAsync", "ressync", "lasync", " ASync"]}}
{"project": "qemu", "commit_id": "02acedf93da420713a0c4bbeaf32ce9d734a4332", "target": 0, "func": "static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n", "idx": 16735, "substitutes": {"reg": ["temp", "mem", "grid", "rm", "loc", "res", "nt", "p", "adj", "ret", "ru", "rt", "gc", "g", "map", "REG", "prefix", "rr", "Reg", "mt", "rec", "m", "rep", "db", "pg", "gov", "mb", "ptr", "out", "addr", "rem", "mp", "re", "ref", "r", "tag", "gr", "state", "cache", "txt", "pre", "eg"], "q": ["ue", "z", "qv", "t", "w", "i", "max", "qu", "p", "qi", "sq", "query", "qs", "count", "g", "conf", "dq", "queue", "iq", "v", "k", "ip", "mp", "req", "quant", "eq", "j", "Q", "aq", "x", "qt", "qa", "f", "quit", "qq", "m"], "tmp": ["temp", "offset", "snap", "needed", "rm", "cv", "np", "nt", "t", "img", "pad", "max", "p", "mm", "sp", "num", "test", "ctx", "uint", "ret", "rt", "buf", "cur", "map", "tn", "mt", "tp", "out", "mb", "db", "gov", "v", "start", "ptr", "mp", "nb", "pkg", "msg", "r", "mk", "new", "cmp", "cache", "nm", "x", "cb", "prime", "nr", "cp", "tt", "buff", "mint", "qq", "ap", "m"], "size": ["l", "style", "z", "t", "sh", "p", "ose", "ne", "scale", "e", "count", "g", "empty", "sv", "shape", "group", "length", "name", "m", "v", "k", "sn", "c", "ize", "nl", "scope", "sync", "space", "dim", "Size", "SIZE", "cache", "network", "len", "small", "code", "dimension", "mode", "type"], "n": ["na", " out", " ne", "g", " ans", "mn", " name", "ln", "nor", " number", "c", "number", "wn", " iter", "s", "names", " i", "ren", "index", "np", "fn", " len", "t", "en", "norm", "on", "nw", "d", "v", "nn", "sn", " fn", "o", " nin", "len", "f", "after", "nt", "yn", "l", "w", "num", "cn", " net", "ne", " ii", "node", "name", "all", "k", " ns", "nl", " j", "j", "note", "raw", "nan", "nm", "an", "go", "un", "no", "nr", "m", " sn", "dn", " na", " nu", "i", "p", "ll", "h", "remote", "ng", " no", "tn", "out", "ns", "nu", "ind", "batch", "N", " num", "gn", "nc", " ni", " ng", " nm"], "t0": ["tm1", "tu5", "te1", "Tn", " t6", "t5", "t2", "tm8", "tsn", "t6", " T2", "pt047", " T1", "pk", " T0", "T0", "T6", " t047", "at047", "T8", "tm0", "tu0", "tn", "ts0", "t8", "at3", " t2", "kt0", " tk", "tu1", "p2", "kt1", "T5", "pt3", "tk", "ts8", " Tk", "p0", "te0", "at0", " t3", "t047", "kt6", "ts1", "T1", "tmn", "pt0", "te5", "t3", "p1"], "t1": ["te1", " t9", " t6", "T10", "t2", "T9", "template2", "t6", "type64", "at1", "Tone", "type10", "type0", "type8", "tone", " t4", "T0", "teone", "template64", "at9", "te64", " tOne", "type1", "at6", " t10", "t8", "at4", " t2", "t9", "teOne", "template1", "t4", "type4", "atOne", "at0", "tOne", "type2", "t10", "template8", "te6", "te2", "atone", "T1", " tone", "typeone", "t64", "T4", "T2", "te8"]}}
{"project": "qemu", "commit_id": "f892291eee376505cfec8b6cade7ccf952a6d3e0", "target": 0, "func": "static void parse_numa_distance(NumaDistOptions *dist, Error **errp)\n\n{\n\n    uint16_t src = dist->src;\n\n    uint16_t dst = dist->dst;\n\n    uint8_t val = dist->val;\n\n\n\n    if (src >= MAX_NODES || dst >= MAX_NODES) {\n\n        error_setg(errp,\n\n                   \"Invalid node %\" PRIu16\n\n                   \", max possible could be %\" PRIu16,\n\n                   MAX(src, dst), MAX_NODES);\n\n        return;\n\n    }\n\n\n\n    if (!numa_info[src].present || !numa_info[dst].present) {\n\n        error_setg(errp, \"Source/Destination NUMA node is missing. \"\n\n                   \"Please use '-numa node' option to declare it first.\");\n\n        return;\n\n    }\n\n\n\n    if (val < NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \"\n\n                   \"it shouldn't be less than %d.\",\n\n                   val, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    if (src == dst && val != NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"Local distance of node %d should be %d.\",\n\n                   src, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    numa_info[src].distance[dst] = val;\n\n    have_numa_distance = true;\n\n}\n", "idx": 16752, "substitutes": {"dist": ["missing", "ds", "grad", "form", "ist", "disc", "lib", "desc", "dt", "dj", "dep", "md", "dis", " redist", "delay", "distance", "d", "progress", "dr", "add", "wd", "conn", "driver", "req", "cmd", "det", "ind", "dir", "dm", "att", "dev", "draw", "Dist", "def", "diff", "str", "du", "df", "dim", "del", "reflect", "txt", "depend", "resp", "dx", "rest", "dem", "exec", "conf", "dd", "err"], "errp": ["confp", "ierP", " errr", "errorcp", "ererpa", "confcp", "eorpkg", "confpa", "errpress", "errorp", "aerping", "aerp", "ierg", "errg", "derpress", "lrpost", "eorg", "errorup", "lrp", "ererup", " errpoint", "ererpc", "errorpc", "errpa", "errup", "ererr", "ierpost", "ierpkg", "errr", "errpc", "errcp", "confup", "derp", "lrg", " errpc", "erercp", "errpkg", "errorpa", "aercp", "aerpress", "ererpun", "eorp", "errorpun", "ererp", "ierp", "errping", "dercp", "errpost", "ierpoint", "errpun", "eorpost", "errorr", " errpun", "errP", "errorpress", "errpoint", "lrpkg", "derping", "eorpoint", " errP", "errorping", "eorP"]}}
{"project": "FFmpeg", "commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "target": 1, "func": "static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n", "idx": 16755, "substitutes": {"avctx": ["Avtx", "avecontext", "avctl", "apcontext", "apctl", " avcontext", "avtc", " avtc", "Avctl", "aftc", "Avcontext", " avctl", "aptx", "avcontext", "aftx", "afctx", " avtx", "Avctx", "avetc", "avectx", "apctx", "avtx", "afcontext", "avetx"], "gbc": [" gxc", "gensc", "lvc", "gcm", "gxc", "gbo", " gcb", "gatedb", "jbc", "gatebc", " gbitcoin", "gsec", "gamecb", "godb", "gbitcoin", "jcc", "gupc", "genbc", " gmc", "gamebus", "igvc", "gbus", " gbus", "ergdb", "gatemc", "gcache", "iggc", "googlebc", "gocache", "gomc", " gdc", "gubc", "jpc", "gfc", " gcc", "igbus", "gamecm", "gamecc", " gcache", "gbt", "gatevc", "gategc", "gatebt", "jbo", "gsc", " gpc", "pgfc", "gobc", " gvc", "ergbc", "gatedc", "ergbt", " gcurrency", "gamedc", "ggc", "gdb", "igcm", "genxc", "pgbo", " gsec", "pgbc", "gamebc", "lbc", "googlecc", "gucc", "gatecb", " gsc", "jxc", "gatecache", " ggc", "gosec", " gcm", "gamebitcoin", "gatesec", "jfc", "gcc", "googlebitcoin", "lpc", "gcurrency", "guvc", "gatebus", "lcc", "gmc", "jsc", "gcb", "googlecurrency", "gpc", "gamecurrency", "gobt", "gdc", "gencc", " gbo", "igbc", "gvc", "gamesec", " gfc", "pgpc"], "pal": ["sal", "pixel", "el", " Pal", "pad", "cloth", "p", "cell", "list", " oval", " cal", "color", "le", " ph", "pol", "cam", " pad", "isal", "Pal", "pro", " pill", " al", "label", " palette", "olor", " style", "bl", "theme", "col", " PAL", " val", "phal", "val", "batch", "cal", "ell", "ph", "pack", "pat", "lam", "cel", "pread", "phil", "pl", "ali", "al", " pl", "pill"], "colors": ["icolORS", "colorors", "olours", "icolors", "Collections", "colorORS", "Colours", "colorlections", " colours", "ColORS", "colores", " colORS", "Colores", "icolores", "Colors", "colours", "olores", "icollections", "olors", " colores", "collections", "colORS", "colorores", "olORS"], "i": ["init", "ic", "index", "si", "ci", "im", "hi", " n", "qi", " ti", "me", "ki", "li", " pi", "span", "I", " ii", "ai", "phi", " multi", " index", "iq", "di", " mi", " li", "mi", "pi", "c", "ind", " j", "id", "j", "xi", "in", "ti", "ui", "batch", "uli", " I", "multi", "bi", "x", " x", "ims", " v", " m", "zi", " iter", " c", " err", "ini", "sim", "it", "ix", "us", "ex", "iu", "ii", "m"], "r": ["rm", "res", "ur", "t", "ra", "rx", "ir", " R", "ar", "kr", "ru", "hr", "rt", "ri", "fr", "rs", "mr", "rr", "tr", "d", "attr", "dr", "rar", " rg", "rl", "rd", "c", "re", "cr", "R", "rg", "usr", "rb", "er", "x", "sr", "rate", "ro", "nr", "rh", "rc", "vr", "rf", "lr", "err"], "g": [" G", "erg", "l", "ga", "gravity", "gio", "p", "og", "gz", "ge", "gc", "gs", "G", "group", "bg", "gem", "pg", "fg", "greg", "gb", "msg", "yg", "gg", "j", "gy", "gr", "gi", "mg", "rg", "ger", "gp", "gd", "gn", "ug", "tg", "gu", "gh", "go", "gm", "eg", "gre", "ig"], "b": ["a", "l", "t", "sb", "p", "bb", "beta", "bar", "bp", "bo", "bas", "fb", "bs", "ob", "u", "bg", "bc", "db", "wb", "bl", "B", "ab", "nb", "gb", "c", "bit", "j", "o", "blue", "bf", "rb", "bi", "ib", "x", "be", "ba", "bin", "eb", "bis", "br"]}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_int64(const void *a, const void *b)\n\n{\n\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n\n    return va < vb ? -1 : va > vb ? +1 : 0;\n\n}\n", "idx": 16767, "substitutes": {"a": ["ea", "aaaa", "am", "air", "ga", "t", "ach", "aws", "at", "app", "ar", "va", "ae", "eas", "ace", "ata", "aa", "v", "aaa", "anta", "ya", "ab", "c", "admin", "r", "sta", "act", "apa", "acs", "aux", "A", "oa", "la", "ba", "an", "ia", "ao"], "b": ["another", "t", "back", "sb", "bb", "abb", "bp", "facebook", "fb", "bs", "ob", "g", "other", "bc", "d", "db", "v", "pb", "B", "ab", "hub", "gb", "c", "n", "blue", "bf", "rb", "ib", "bi", "be", "bin", "ba", "eb", "bis", "y"]}}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "uint32_t kvm_arch_get_supported_cpuid(CPUState *env, uint32_t function,\n\n                                      uint32_t index, int reg)\n\n{\n\n    struct kvm_cpuid2 *cpuid;\n\n    int i, max;\n\n    uint32_t ret = 0;\n\n    uint32_t cpuid_1_edx;\n\n\n\n    if (!kvm_check_extension(env->kvm_state, KVM_CAP_EXT_CPUID)) {\n\n        return -1U;\n\n    }\n\n\n\n    max = 1;\n\n    while ((cpuid = try_get_cpuid(env->kvm_state, max)) == NULL) {\n\n        max *= 2;\n\n    }\n\n\n\n    for (i = 0; i < cpuid->nent; ++i) {\n\n        if (cpuid->entries[i].function == function &&\n\n            cpuid->entries[i].index == index) {\n\n            switch (reg) {\n\n            case R_EAX:\n\n                ret = cpuid->entries[i].eax;\n\n                break;\n\n            case R_EBX:\n\n                ret = cpuid->entries[i].ebx;\n\n                break;\n\n            case R_ECX:\n\n                ret = cpuid->entries[i].ecx;\n\n                break;\n\n            case R_EDX:\n\n                ret = cpuid->entries[i].edx;\n\n                switch (function) {\n\n                case 1:\n\n                    /* KVM before 2.6.30 misreports the following features */\n\n                    ret |= CPUID_MTRR | CPUID_PAT | CPUID_MCE | CPUID_MCA;\n\n                    break;\n\n                case 0x80000001:\n\n                    /* On Intel, kvm returns cpuid according to the Intel spec,\n\n                     * so add missing bits according to the AMD spec:\n\n                     */\n\n                    cpuid_1_edx = kvm_arch_get_supported_cpuid(env, 1, 0, R_EDX);\n\n                    ret |= cpuid_1_edx & 0x183f7ff;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(cpuid);\n\n\n\n    return ret;\n\n}\n", "idx": 16771, "substitutes": {"env": ["init", "cv", "eye", "ov", "here", "server", "eng", "window", "ei", "en", "enter", "ec", "vt", "h", "ctx", "end", "nv", "esm", "e", "buf", "cur", "config", "vp", "engine", "pg", "gov", "v", "vs", "esc", "ew", "hw", "self", "obj", "ef", "vm", "stack", "conn", "req", "inv", "estate", "dev", "ev", "forge", "context", "et", "erd", "er", "viron", "shell", "ah", "org", "eh", "serv", "environment"], "function": ["callback", "frame", "connection", "functional", "fn", "form", "word", "lambda", "format", "component", "domain", "interface", "test", "feature", "unction", "program", "family", "unc", "script", "action", "power", "normal", "expression", "resource", "Function", "command", "library", "length", "operation", "address", "method", "name", "FUN", "reference", "value", "region", "service", "role", "func", "r", "condition", "table", "job", "number", "package", "module", "attribute", "section", "f", "fun", "full", "code", "version", "event", "trace", "type"], "index": ["connection", "IND", "error", "location", "si", "can", "valid", "num", "interface", "hash", "is", "find", "action", "ion", "expression", "point", "run", "Index", "length", "command", "link", "address", "position", "image", "all", "name", "operation", "pointer", "reference", "value", "region", "order", "ind", "id", "condition", "context", "connect", "number", "key", "sequence", "alias", "x", "info", "row", "search", "code", "version", "active", "rule", "type"], "reg": ["country", "form", "res", "or", "format", "asm", "script", "ion", "g", "config", "map", "REG", "Reg", "name", "address", "reference", "region", "addr", "order", "re", "func", "ref", "r", "tag", "cond", "key", "state", "type", "org", "regular", "pattern", "eg", "fun", "registered", "ex", "rule", "red", "br"], "cpuid": ["cssuu", "pcsid", " cppid", "ipuu", "zipsu", "pcuid", " tcpunt", "cmpvid", "cpuu", "cid", "cpvoid", "cpuf", "cmpuu", "ipuid", "ctxud", "cpuudi", " cphn", "skyuf", "cpusu", "catuid", "cpido", " cpuint", "skyvoid", " cpvoid", "zipuid", " cpid", "cssido", "compvoid", "cunt", "ctxuu", "cpazz", " cpsid", "cpuvoid", "catuu", " cpudi", "cssvoid", "cmpud", "cssuint", " cpuu", "ipido", "compsid", "pcpid", "ipupid", "cssupid", "ctxuid", " cpvid", "cuu", "cpunt", "cpuuint", "cpuhn", "cmpuf", " tcpid", "skyudi", "cssudi", "catud", "ctxu", "ctud", "compu", "pcu", "cpud", "cpuuf", "cpusid", " cpu", "cmpupid", "cssuid", "zipuint", "csshn", "pkguf", "cpuazz", "pkgvid", "pkguid", "zipazz", "cpudi", "cpuuid", "cpvid", " cpazz", "cpid", " cpupid", "cppid", " cpud", "catu", "cmpuid", "cuid", "skyuid", "cpu", "ctu", "cpuupid", "cpuint", " tcpuid", "cphn", " cpuf", "cpsid", "pkgud", "cpupid", "compuid", "ctuid", "comppid", "cpsu", " cpsu", "ctuu", "cmpido", " cpunt", " tcpuu"], "i": ["ic", "ij", "si", "t", "ci", "im", "hi", "ei", "qi", "list", "me", "li", "is", "\u0438", "ri", "e", "g", "I", " ii", "ai", "phi", "uli", "v", "di", "io", "cli", "ip", "mi", "pi", "oi", "ind", " j", "id", "j", "xi", "iri", "json", "ti", "ui", "batch", "gi", "n", " I", "o", "multi", "ami", "key", "fi", "bi", "ji", "uri", "x", "info", "zi", "ini", "sim", "ie", "go", "f", "it", "ix", "ms", "series", "iu", "y", "ii", "m"], "max": ["grow", "check", "next", "res", "size", "t", "window", "total", "ax", "p", "final", "num", "q", "last", "end", "base", "scale", "count", "mod", " MAX", "map", "length", "MAX", "v", "limit", "k", "head", "rem", "range", "mx", "id", "j", "r", "pool", "new", " Max", "n", "act", "huge", "Max", "top", "maximum", "cache", "x", "prime", "len", "row", "net", "rest", "chain", "ms", "full", "ex", "conf", "min", "m"], "cpuid_1_edx": ["cpuid_1_eex", "cpuid_1_exw", "cpuid_1_eepx", "cpuid_1_eeex", "cpuid_1_dy", "cpuid_1_edy", "cpuid_1_ledix", "cpuid_1_dedw", "cpuid_1__ledex", "cpuid_1__ledx", "cpuid_1_dedpx", "cpuid_1_exy", "cpuid_1__ledix", "cpuid_1_edex", "cpuid_1__edw", "cpuid_1_dX", "cpuid_1_dedix", "cpuid_1_ledx", "cpuid_1_edix", "cpuid_1_eeX", "cpuid_1_dex", "cpuid_1__edex", "cpuid_1_ledw", "cpuid_1_exix", "cpuid_1_edpx", "cpuid_1_exX", "cpuid_1_dedex", "cpuid_1_expx", "cpuid_1__ledw", "cpuid_1_exex", "cpuid_1_edw", "cpuid_1__edix", "cpuid_1_edX", "cpuid_1_exx", "cpuid_1_ledex", "cpuid_1_dedx", "cpuid_1_dedX", "cpuid_1__edx", "cpuid_1_dx"]}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,\n\n                          uint8_t **bufptr, DumpState *s)\n\n{\n\n    GuestPhysBlock *block = *blockptr;\n\n    hwaddr addr;\n\n    uint8_t *buf;\n\n\n\n    /* block == NULL means the start of the iteration */\n\n    if (!block) {\n\n        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n\n        *blockptr = block;\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        if (bufptr) {\n\n            *bufptr = block->host_addr;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    *pfnptr = *pfnptr + 1;\n\n    addr = pfn_to_paddr(*pfnptr);\n\n\n\n    if ((addr >= block->target_start) &&\n\n        (addr + s->page_size <= block->target_end)) {\n\n        buf = block->host_addr + (addr - block->target_start);\n\n    } else {\n\n        /* the next page is in the next block */\n\n        block = QTAILQ_NEXT(block, next);\n\n        *blockptr = block;\n\n        if (!block) {\n\n            return false;\n\n        }\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        buf = block->host_addr;\n\n    }\n\n\n\n    if (bufptr) {\n\n        *bufptr = buf;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16780, "substitutes": {"blockptr": ["boxpointer", "lockaddr", "buspointer", "buspert", " blocktr", "chainptr", "lockctr", " blockctr", "blockaddr", "bustr", "chainaddr", "blockpert", "lockpointer", "blockpointer", "boxtr", "boxptr", "lockptr", "chaintr", "locktr", "lockpert", "blocktr", "chainpointer", "busptr", " blockpointer", "boxctr", "blockctr", "boxaddr", " blockpert"], "pfnptr": ["pdnobj", "preldesc", "pcndesc", "pnnrel", " pdnct", "ptnptr", "pfinaddr", "Pfnoffset", "Pnnoffset", "pnnptr", "ptnaddr", "pdndesc", "pdnpointer", "Pfnrel", "pdnct", " pdnpointer", "pnnoffset", "PfnPtr", " pnnptr", "phprelpert", "pcdnoffset", "plnrel", "PnnPtr", "phpfndesc", " pfnct", "prelstr", "pfnaddr", " pdnrel", "pfunctiondesc", "pfnpointer", "pconnrel", "pfillstr", "pdnrect", " pfndesc", "Pnnrel", "pfunpointer", " pfnpert", "phpfnptr", " pnnaddr", "prelptr", "pfunctionptr", "pfinrect", "pfunptr", "pfunpert", " pnnrect", " pfnobj", " pdndesc", "pdnaddr", "pcnstr", "pfunctionct", "pfillpert", "pcdnPtr", "pfnct", "pcdnptr", " pdnptr", "pfnpert", "pfnobj", "plnptr", "Pfnptr", "phpfnstr", "pfilldesc", " pfnpointer", "pbnrel", "pnnpointer", "pconnoffset", "pfunPtr", " pfnPtr", "pfnrel", "pbnpointer", "pdnptr", "pnnPtr", "pnnpert", "ptnct", "pfndesc", " pfnaddr", " pnnpointer", "plnobj", " pdnobj", "pfnstr", "pcdnrel", "phprelstr", "pfinptr", "pbnobj", "pdnrel", "phpreldesc", "phprelptr", "pfinpointer", "pconnPtr", "pfnrect", " pfnrel", " pfnrect", "pfunctionaddr", "pfillptr", "pfnoffset", "pcnptr", "pconnptr", "Pnnptr", "phpfnpert", "prelpert", "pnnaddr", "pfnPtr", "pnnrect", "plnpointer", "pbnptr", "pcnpert", "ptndesc", " pdnaddr"], "bufptr": [" bufpointers", "queueptr", "ufproc", "bufPtr", "fbptr", "buffobj", "ufptr", "imgptr", "capptr", "fbpointers", "rafptr", "bufproc", "bufctr", "bufferPtr", "imgpointer", "bufrect", " buftr", "capcert", "buffptr", "imgcert", " bufrob", "bufferobj", "rafrob", "buffPtr", "ufobj", "bufobj", "bufcert", "cappointer", "fbrect", "buffproc", "queuetr", "buffctr", "bufftr", "buffertr", "ufcert", "imgtr", "fbpointer", " bufpointer", "bufpointers", "buftr", "uftr", "bufferptr", "ufpointer", "buffrect", "buffpointer", "rafctr", "captr", "buffpointers", " bufctr", "ufPtr", "buffrob", " bufrect", "bufrob", "raftr", "queueproc", "bufpointer"], "s": ["size", "details", "e", "rs", "tags", "vs", "self", "obj", "sys", "sets", "c", "es", "comm", "fs", "sol", "space", "series", "os", "ops", "t", "settings", "sp", "sm", "set", "S", "ss", "d", "sts", "ps", "xs", "dev", "n", "ts", "ls", "parts", "stats", "services", "ies", "ds", "times", "sb", "ses", "sv", "sw", "session", "js", "j", "state", "info", "ssl", "ix", "states", "b", "m", "blocks", "si", "p", "sq", "h", "is", "gs", "ries", "ns", "socket", "ats", "less", "ims", "ms", "conf", "its"], "block": ["word", "error", "tx", "blank", "hash", "point", "obj", "self", "bl", "object", "friend", "manager", "bit", "commit", "inv", "field", "sync", "line", "local", "join", "space", "bin", "buffer", "chain", "check", "channel", "none", "sp", "list", "set", "zero", "device", "lock", "link", "command", "unknown", "single", "mask", "re", "json", "scope", "escape", "condition", "pack", "x", "null", "ver", "part", "event", "bus", "init", "snap", "box", "Block", "mm", "cl", "model", "load", "prefix", "node", "group", "disk", "bc", "name", "address", "method", "wall", "instance", "ip", "side", "def", "raw", "network", "info", "row", "an", "un", "no", "panel", "byte", "loop", "man", "history", "blocks", "bridge", "window", "p", "bo", "OCK", "empty", "map", "image", "unit", "record", "rel", "ref", "pool", "tag", "new", "blocking", "BL", "filter", "full", "type"], "addr": ["loc", "pad", "tx", " aid", " href", "hash", "ress", "rt", "ace", "rs", "lat", "obj", "iter", "sha", " amp", "url", "offset", "eth", "np", "end", "gz", " rel", "start", "add", "pkg", "align", "n", "ack", "oa", "Address", "len", " err", "elt", "err", " ip", "res", "ord", "adr", "tr", "mt", "name", "address", "ptr", "attr", "ip", "nl", "act", "alt", "alpha", "arp", "rc", " fmt", "ix", " res", "pos", " align", " arr", "arr", "tz", "p", "at", " url", " pad", "dr", " add", "cmd", "id", " act", "ref", "r", " conn", "alias", "coord", "src", " rev", "br"], "buf": ["next", "mem", "cap", "offset", "cv", "Buff", "nom", "loc", "box", "window", "img", "var", "bar", "port", "ctx", "end", "bp", "ret", "vec", "tmp", "cast", "ann", "queue", "alloc", "fg", "bytes", "limit", "pb", "ptr", "bl", "tab", "cmd", "pkg", "page", "func", "pool", "batch", "raw", "pack", "bf", "rb", "nm", "cb", "bin", "uf", "buffer", "Buffer", "buff", "b", "dest", "seq", "ff", "br"]}}
{"project": "qemu", "commit_id": "280d373579558f73a8b70e329d9a6206933d3809", "target": 0, "func": "static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,\n\n                                 remaining_sectors);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta->nb_clusters > 0 &&\n\n            (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS)) {\n\n            qcow2_mark_dirty(bs);\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta != NULL) {\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            run_dependent_requests(s, l2meta);\n\n            g_free(l2meta);\n\n            l2meta = NULL;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    if (l2meta != NULL) {\n\n        run_dependent_requests(s, l2meta);\n\n        g_free(l2meta);\n\n    }\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 16783, "substitutes": {"bs": ["bm", "hs", "ds", "cs", "lbs", "os", "outs", "bits", "sb", "BS", "ubs", "bh", "bp", "qs", "bps", "rs", "gs", "ss", "bc", "aus", "ubis", "ns", "vs", "pb", "bos", "sys", "bes", "js", "obs", "cks", "fs", "bi", "ts", "aos", "ls", "bt", "b", "bis", "its", "lb"], "sector_num": ["sector2nr", "sector10NUM", " sector_nr", "sector_mult", "section_num", "sector2NUM", "sector_nr", "sector_number", "ector_n", "sector2orig", "section_number", "section_mult", "sector10orig", " sector_mon", "sector2num", "section_NUM", "section_mon", " sector_number", "sector10mon", "ector_num", "sector10num", "section_orig", "sector_mon", "sector_orig", "ector_Num", "sector_NUM", "sector2mon", "ector_coord", "sector_coord", "sector_n", "sector_Num", "sector2number"], "remaining_sectors": ["remaining_peors", "remaining_segments", "remaining_specs", "remaining_vellers", "remaining_psegments", "remaining_meonents", "remaining_vegments", "remaining_erctors", "remaining_vectors", "remaining_meors", "remaining_sebers", "remaining_erctions", "remaining_pecs", "remaining_pebers", "remaining_vections", "remaining_vebers", "remaining_veors", "remaining_seonents", "remaining_sellers", "remaining_pseonents", "remaining_sexters", "remaining_eronents", "remaining_sexors", "remaining_psectors", "remaining_mectors", "remaining_pseors", "remaining_sections", "remaining_psections", "remaining_spegments", "remaining_sexctors", "remaining_veters", "remaining_pectors", "remaining_vecs", "remaining_seors", "remaining_secs", "remaining_erllers", "remaining_veonents", "remaining_pegments", "remaining_psellers", "remaining_sexbers", "remaining_peters", "remaining_spectors", "remaining_speors", "remaining_seters", "remaining_megments"], "qiov": [" qiev", "qiour", "oxiour", "quiev", "quiov", "qiev", " qiour", "qudyl", "qurov", "qrov", "iqiour", "oxiov", "iqrov", "oxdyl", " qdyl", "iqiov", "oxiev", " qrov", "iqiev", "quiour", "qdyl"], "s": ["services", "a", "hs", "ds", "cs", "sam", "os", "t", "w", "settings", "i", "bits", "sb", "p", "sp", "changes", "details", "sq", "aws", "h", "abilities", "set", "qs", "is", "ares", "sv", "rs", "gs", "S", "ss", "sts", "ns", "v", "vs", "ps", "sys", "sets", "js", "bes", "c", "j", "es", "ats", "comm", "ids", "fs", "less", "ts", "actions", "ssl", "ls", "ims", "stats", "ms", "spec", "b", "bis", "its", "comments"], "index_in_cluster": ["index_in_lructure", "index_in_plructure", "index_in_Clust", "index_in_clusters", "index_in_luster", "index_in_ploser", "index_in_gluster", "index_in_Clusters", "index_in_choser", "index_in_chuster", "index_in_scuster", "index_in_Cluster", "index_in_scusters", "index_in_glust", "index_in_chusters", "index_in_Closer", "index_in_plust", "index_in_clructure", "index_in_scructure", "index_in_clust", "index_in_lusters", "index_in_gloser", "index_in_closer", "index_in_lust", "index_in_scust", "index_in_pluster", "index_in_glusters", "index_in_plusters"], "n_end": ["indexvalending", "nvalend", "N_num", "n00edge", "index00end", "n_post", "n_End", "index_size", "index00ending", "n_ends", "N_END", "index_begin", "n2End", "n_tail", "n_num", "N_End", "n2num", "index_edge", "n_END", "n00end", "n_size", "index_tail", "index_post", "nvalbegin", "n_edge", "nvalending", "n2end", "indexvalbegin", "index00edge", "index00size", "n00ending", "n00size", " n_ended", "index_end", "index_ending", "n2END", "indexvalend", "n_start", "indexvaltail", "n_begin", "n_ended", "n_ending", "nvaltail", " n_start", "index_ends", "N_end"], "ret": ["mem", "mel", " RET", "nt", "res", "t", "back", "deg", "flag", "big", "ter", "result", "ll", "Ret", "test", "err", "rt", "arg", "tr", "mt", "nz", "out", "Return", "tf", "cont", "iter", "lt", "ft", " Ret", "rem", "RET", "rev", "re", "cmd", "ref", "val", "job", "print", "pat", "alt", "encrypted", "len", "cert", "tech", "tt", "gt", "fun", "elt", "rets"], "cur_nr_sectors": ["cur_nr_seors", "cur_nr_segments", "cur_nr_pseors", "cur_nr_selements", "cur_nr_vectors", "cur_nr_pectors", "cur_nr_pselements", "cur_nr_peors", "cur_nr_psectors", "cur_nr_velements", "cur_nr_servers", "cur_nr_spelements", "cur_nr_serctors", "cur_nr_sergments", "cur_nr_pegments", "cur_nr_speors", "cur_nr_severs", "cur_nr_spectors", "cur_nr_vevers", "cur_nr_vegments", "cur_nr_spegments", "cur_nr_veors", "cur_nr_pevers", "cur_nr_serors", "cur_nr_psegments"], "cluster_offset": ["cluster__offset", "cluster__data", "cluster____data", "clandra____id", "cluster_size", "clusters_addr", "cluster___data", "clusters_data", "clusters_size", "clusters_meta", "clandra____data", "cluster___offset", "clandra_id", "clandra_addr", "clandra_data", "clandra_offset", "cluster_meta", "cluster____id", "clandra____addr", "cluster___id", "clusters_offset", "cluster_id", "cluster_addr", "cluster____offset", "clandra____offset", "cluster____addr", "cluster__meta", "cluster___addr", "cluster__addr"], "hd_qiov": ["hd_Qiev", "hd_giov", "hd_viov", "dh__", "hd__", "hd_vveh", "hd_Qovi", "hd_sqveh", "hd_2", "hd_quroid", "hd_qveh", "hd_Qrov", "hd_grov", "hd_quiev", "hd_Qiov", "hd_qurov", "hd_quiov", "hd_qiour", "hd_groid", "hd_qovi", "hd_sqiour", "hd_Qroid", "hd_qrov", "hd_viour", "hd_qiev", "hd_sqiov", "dh_2", "hd_vovi", "hd_Qiour", "hd_Qveh", "hd_giev", "hd_sqovi", "hd_qroid"], "cluster_data": ["cluster2data", "cluster___cache", "cluster2cache", "cluster___data", "clusters_data", "cluster___offset", "cluster___buffer", "cluster_cache", "cluster_buffer", "cluster2offset", "clusters_offset", "clusters_cache", "cluster2buffer", "clusters_buffer"], "l2meta": ["l2eta", "L2settings", "l_Meta", "l1meta", "nl1eta", " l2met", "l2policy", " l3meta", "nl1metadata", "ltometa", "lophersettings", "L3meta", "l3Meta", "l1eta", "l3data", "l4Meta", "nl2Meta", " l2Meta", "nl1meta", "L2policy", "l3metadata", "l1Meta", "l5eta", " l_Meta", " l3met", "l3eta", "l_data", "l3settings", "l4data", " l3eta", "L3settings", "ltosettings", "ltometadata", "l2data", " l_data", "nl2metadata", "nl1Meta", "nl2eta", "l3meta", "l4meta", "l2met", " l_meta", "lophermetadata", "L3metadata", "l3policy", " l2metadata", "l5meta", "l4met", "l1metadata", " l2data", "L2metadata", "l_metadata", "l5met", "l2metadata", " l2eta", "ltopolicy", "nl2meta", "l5Meta", "lophermeta", "l2Meta", "lopherpolicy", "l_meta", "L2meta", "L3policy", " l_metadata", "l4metadata", "l3met", " l3Meta", "l4eta", "l2settings"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    uint8_t buf[256];\n\n    uint8_t type = value >> 8;\n\n    uint8_t index = value & 0xff;\n\n    int ret = -1;\n\n\n\n    switch(type) {\n\n    case USB_DT_DEVICE:\n\n        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n\n        trace_usb_desc_device(dev->addr, len, ret);\n\n        break;\n\n    case USB_DT_CONFIG:\n\n        if (index < desc->full->bNumConfigurations) {\n\n            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n\n        }\n\n        trace_usb_desc_config(dev->addr, index, len, ret);\n\n        break;\n\n    case USB_DT_STRING:\n\n        ret = usb_desc_string(dev, index, buf, sizeof(buf));\n\n        trace_usb_desc_string(dev->addr, index, len, ret);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,\n\n                dev->addr, type, len);\n\n        break;\n\n    }\n\n\n\n    if (ret > 0) {\n\n        if (ret > len) {\n\n            ret = len;\n\n        }\n\n        memcpy(dest, buf, ret);\n\n    }\n\n    return ret;\n\n}\n", "idx": 16787, "substitutes": {"dev": ["mem", "debug", "adv", "loc", "nt", "server", "dist", "w", "de", "pad", "Dev", "var", "dep", "md", "ow", "th", "dis", "test", "h", "end", "ctx", "app", "device", "DEV", "av", "cam", "des", "ad", "d", "pro", "v", "db", "hw", "attr", "self", "ve", "add", "wd", "iv", "addr", "obj", "conn", "sys", "priv", "cmd", "det", "att", "ev", "val", "def", "raw", "env", "info", "Device", "go", "ver", "scan", "home", "conf", "dd"], "value": ["index", "ue", "size", "VALUE", "weight", "total", "num", "test", "port", "ness", "device", "scale", "length", "values", "Value", "name", "address", "unit", "v", "instance", "data", "range", " val", "field", "val", "message", "current", "number", "key", "attribute", "block", "buffer", "code", "version", "byte", "type"], "dest": ["temp", "mem", "loc", "dist", "w", "opt", "img", "st", "result", "decl", "end", "cas", "tmp", "tr", "out", "doc", "ptr", "cont", "iter", "priv", "target", "lit", "ref", "master", "std", "table", "path", "usr", "pas", "orig", "coord", "source", "Dest", "txt", "bin", "resp", "rest", "src", "trans"], "len": ["lp", "loc", "size", "lon", "format", "lib", "dt", "length", "conv", "ln", "iter", "Length", "lim", "bin", "hl", "offset", "mem", "index", "el", "t", "sp", "en", "end", "ret", "compl", "syn", "limit", "msg", "L", "n", "ls", "resp", "fun", "Len", "elt", "trans", "err", "fl", " length", "l", "nt", "total", "vec", "all", "ptr", "lt", "addr", "nl", "cmp", "str", "lan", "alt", "ld", "pos", "lf", "ll", "h", "empty", "fin", "bytes", "conn", "lit", "ref", "val", "dim", "full", "type"], "desc": ["td", "ds", "loc", "fn", "dist", "disc", "comment", "dep", "sub", "test", "decl", "ctx", "Desc", "ript", "cam", "config", "des", "sec", "rec", "seq", "pro", "reg", "cd", "esc", "doc", "ptr", "pri", "dr", "feat", "cor", "asc", "description", "conn", "priv", "cmd", "det", "req", "ext", "cmp", "def", "dc", "diff", "pb", "dim", "info", "resp", "rc", "der", "sc", "conf"], "buf": ["temp", "mem", "cap", "cv", "Buff", "loc", "nt", "arr", "box", "window", "img", "max", "tx", "var", "rw", "port", "ctx", "good", "ret", "vec", "cur", "tmp", "prop", "tr", " buffer", "queue", "off", "out", "db", "bytes", "doc", "ptr", "bl", "pb", "iter", "addr", "wb", "cat", "obj", "data", "cmd", "msg", "pkg", "priv", "ref", "pool", "batch", "raw", "str", "rb", "cache", "txt", "cb", "bin", "uf", "buffer", "Buffer", "gt", "buff", "src", "b", "seq", "br", "err"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void connex_init(MachineState *machine)\n\n{\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t connex_rom = 0x01000000;\n\n    uint32_t connex_ram = 0x04000000;\n\n\n\n    cpu = pxa255_init(address_space_mem, connex_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"connext.rom\", connex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, connex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 36 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 36));\n\n}\n", "idx": 16792, "substitutes": {"machine": ["frame", "channel", "mm", "mc", "me", "handler", "power", "device", "model", "link", "node", "image", "m", "session", "vm", "achine", "instance", "Machine", "monitor", "host", "state", "computer", "ram", "net", "chain", "task", "process"], "cpu": ["mem", "np", "memory", "nic", "linux", "p", "proc", "ctx", "pc", "gc", "core", "util", "chip", "node", "disk", "pu", "mu", "hw", "clock", "achine", "vm", "conn", "c", "mx", "bench", "xi", "pool", "processor", "gpu", "cu", " CPU", "computer", "bus", "cp", "CPU", "boot", "pai", "phys", "process"], "dinfo": [" dfo", " ddetails", " dinf", "dbinfo", " dINFO", " dInfo", "dready", "ldinfo", "Ddetails", "adinformation", "dINFO", "DInfo", "ldInfo", "dbfi", "dbInfo", "Dfi", "lINFO", "finf", "lInfo", "Dinformation", "Dready", "Dinfo", "fInfo", "dInfo", "adInfo", "dinformation", " dfi", "ldready", "adfo", "ddetails", "Dfo", "finfo", "linfo", "dinf", "dbinf", "linformation", " dready", " dinformation", "dfo", "dfi", "lddetails", "adinfo", "Dinf"], "be": ["use", "ue", "b", "are", " Be", "z", "or", "obe", " we", "st", "beat", " ne", " bo", "we", "he", "end", "bo", "ne", "le", "ge", "ke", "ob", "te", " BE", "e", "ape", "ae", "scale", "bd", "ot", "ch", "fe", "se", "ve", "ide", " pe", "abe", "ble", "ere", " Bo", " probe", "enable", "BE", "Be", "ze", "itte", "cho", " ba", "by", " he", "loop", "it", "eb", " b", "ed", "bes", "br", "\u662f", "oe"], "address_space_mem": ["address_space_ref", "address_store_reg", "address_space2mem", "address_space2ram", "address_space_reg", "address_space_mt", "address_space2ref", "address_store_mem", "address_store_mt", "address_store_ram", "address_space_ram"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *notifier,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_read,\n\n                            AioPollFn *io_poll)\n\n{\n\n    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,\n\n                       (IOHandler *)io_read, NULL, io_poll, notifier);\n\n}\n", "idx": 16794, "substitutes": {"ctx": ["cv", "loc", "tc", "ca", "tx", "unc", "gc", "care", "cas", "cf", "jac", "ct", "cc", "bc", "kw", "co", "alloc", "hw", "wx", "wd", "pkg", "cmd", "jp", "context", "cmp", "cm", "cu", "txt", "Context", "nc", "anc", "xc", "cp", "chain", "wcs", "ctr", "sc", "iat"], "notifier": ["Notifer", " notification", "indifiable", "signifer", "NOTification", "indifer", "NOTifier", "NOTifer", "indification", "Notifier", "Notressor", "signification", "Noticator", "NOTifiable", "identifier", "signressor", "signifier", " notressor", "notifiable", " notifer", "Notifiers", "noticator", "notressor", " notifiers", "identifiers", "identicator", "notifer", "notification", " notifiable", "identifer", "notifiers", " noticator", "indifier", "Notification"], "is_external": ["is_unique", "is42internal", "is_binary", "is_outside", "is_extra", " is_binary", "is42unique", " is_extra", "is42outside", " is_internal", " is_unique", "is42external", " is_outside", "is_internal"], "io_read": [" io__run", "i_send", " io__readable", "io___readable", "io_reader", "io_send", "io2send", "i_read", " io_run", "io___read", "io2reader", "io2readable", "io2read", "i_reader", "io__write", "io_readable", "io__read", "io_write", " io_write", "io_run", "io__readable", "io__run", "i_readable", "io___run", "io___write", " io__write", " io_readable", " io__read"], "io_poll": ["api_pull", "iot_handle", "api____connect", "iot_pull", "ioPhandle", "io____write", "api_poll", "api_write", "io____connect", "iowpull", "io_pull", "iot_write", "iotPpoll", "iowpoll", "iotPhandle", "ioPpull", "iot_poll", "api____pull", "api_connect", "ioPwrite", "iowconnect", "io____pull", "io____poll", "io_write", "ioPpoll", "iowwrite", "api____poll", "iotPwrite", "io_handle", "api____write", "iotPpull", "io_connect"]}}
{"project": "FFmpeg", "commit_id": "f6687bf5f8989d397cdef6d9d05bcb13a7ef8c4f", "target": 0, "func": "void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,\n\n                   uint8_t *iv, int decrypt)\n\n{\n\n    int i;\n\n\n\n    while (count > 0) {\n\n        if (decrypt) {\n\n            xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = dst[i] ^ iv[i];\n\n                memcpy(iv, src, 8);\n\n            }\n\n        } else {\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = src[i] ^ iv[i];\n\n                xtea_crypt_ecb(ctx, dst, dst, decrypt);\n\n                memcpy(iv, dst, 8);\n\n            } else {\n\n                xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n            }\n\n        }\n\n\n\n        src   += 8;\n\n        dst   += 8;\n\n        count -= 8;\n\n    }\n\n}\n", "idx": 16795, "substitutes": {"ctx": ["bm", "ctl", "con", "cv", "nt", "tc", "ca", "ck", "tx", "cn", "kt", "rt", "gc", "cas", "cf", "tmp", "jac", "ct", "cc", "kw", "co", "etc", "hw", "obj", "wx", "sys", "conn", "cpp", "cmd", "pool", "jp", "batch", "context", "cmp", "cm", "act", "cu", "x", "cb", "qt", "fw", "xc", "resp", "cp", "rc", "urg", "ctr", "sc", "conf", "iat"], "dst": ["idsp", "dsts", "dspl", "pdpt", "dsrest", "pdest", "lst", "dsest", " dlt", "lct", "pdst", "delsrc", " dna", "idst", "sct", " ddest", " drc", "ddrest", "sest", " dict", " dpt", " dsp", "indst", "ddest", "dlna", "dust", "delrest", "dtst", "pdict", "dlt", "ddst", "dlst", "delsts", "idfr", "dsct", "dusp", "dna", " dpl", "dsost", "dssts", "dlstr", "dtct", "dfr", "dpt", "dsrc", "indsts", "dct", "rpt", "lest", "rest", "dost", "sst", "ddna", "dbr", "ddpt", " dest", "lrc", " Dost", "dspt", "dlput", "dsbr", " dstr", "dsstr", "dupt", "dtlt", "dsp", "indsrc", "rst", "inddest", "dlpl", "dict", " dbr", "dsdest", " dsrc", "dlrest", "dput", "ddict", "dtest", " Dct", " drest", " dct", " dfr", " dost", "dssrc", "dpl", " dput", "delst", "idpt", "dsst", " dsts", "rbr", "dstr", "drest", "dslt", "dlpt", "drc", " Dsrc", "ddput", "dufr", " Dst", "dest"], "src": ["sc", "init", "ul", "loc", "fn", "sel", "img", "sb", "desc", "sub", "ins", "st", "proc", "sq", "stream", "ipp", "enc", "rect", "rt", "bs", "syn", "cur", "rs", "sels", "vc", "length", "tp", "sec", "ch", "ptr", "supp", "cont", "ipl", "sys", "sn", "addr", "via", "cmd", "ind", "func", "inner", "inst", "sync", "std", "str", "usr", "fc", "source", "txt", "ssl", "sr", "s", "rc", "vr", "sur", "urg", "ctr", "sl", "dest", "ser", "rl", "hl"], "count": [" length", "check", "offset", "next", "con", "index", "nt", "z", "repeat", "size", " len", " start", "depth", "flag", "total", " n", "list", "num", "result", "th", "ount", " cont", "find", "sum", "cycle", "length", "amount", "cast", "ct", "name", "cc", "all", "force", "ch", "start", "cont", "call", " code", "c", " size", "cmd", "ind", "try", "CC", "current", "coll", "n", "Count", " call", " num", "len", "buffer", "code", "ctr", "conf", "counter", " c"], "iv": ["init", "cv", "ic", "ov", "ij", "seed", "or", "oc", "var", "ec", "ipp", "enc", "hash", "rect", "uint", "test", "nv", "buf", "sv", "ith", "vp", "zip", "vc", "ot", "bc", "off", "iq", "ctr", "v", "auth", "uv", "ch", "ptr", "iter", "ih", "ip", "tv", "ive", "tip", "driver", "typ", "attr", "ind", "ext", "rot", "ev", "ipher", "iov", "icon", "Iv", "act", "env", "IV", "block", "rn", "mix", "vv", "ie", "rc", "vr", "it", "der", "rib", "crypt", "iver", "col", "err", "iat"], "decrypt": ["encure", "declryption", "desrypted", "desrypt", "ecry", "Decode", "ecode", " decry", "Deccrypt", "desipher", "decryption", " deccrypt", "decrol", "DECryption", "deccrypt", "DECrypted", "Decry", "Decrypt", "declure", "desccrypt", " decode", "ecipher", "enccrypt", "encrol", "decipher", "declode", "eccrypt", "decode", "descode", "DECcrypt", "ecrypt", "desryption", " decrypted", "encode", " decure", "decry", "decrypted", "declrypt", "DECrypt", " decryption", " decipher", "encrypt", "encrypted", "descrypt", "descrol", "decure", "descrypted", "descryption", " decrol", "ecryption", "encryption", "ecrypted"], "i": ["iso", "hi", "ski", "li", "ri", "ni", "point", "I", "copy", "ai", "di", "mi", "ji", "er", "chain", "ex", "multi", "ii", "ij", "t", "ci", "menu", "list", "q", "\u0438", "phi", "v", "io", "cli", "pi", "my", "json", "try", "parent", "gi", "fi", "bi", "x", "zi", "ini", "it", "iu", "status", "PI", "init", "ic", "l", "ei", "qi", "me", " ii", "name", "ip", " j", "j", "ti", "print", "ami", "uri", "info", "eric", "ie", "php", "ix", "y", "m", "si", "im", "client", "ki", "at", "remote", "is", "oi", "in", "ind", "id", "xi", "r", "ui", "batch", " v", " m", "sim", "us", "ms", "this"]}}
{"project": "FFmpeg", "commit_id": "6241e8a3821d971755217652dff01f3a45580820", "target": 0, "func": "static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)\n\n{\n\n    AVRational time_base = {1, 1000};\n\n    uint32_t start, end;\n\n    AVChapter *chapter;\n\n    uint8_t *dst = NULL;\n\n    int taglen;\n\n    char tag[5];\n\n\n\n    decode_str(s, pb, 0, &dst, &len);\n\n    if (len < 16)\n\n        return;\n\n\n\n    start = avio_rb32(pb);\n\n    end   = avio_rb32(pb);\n\n    avio_skip(pb, 8);\n\n\n\n    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);\n\n    if (!chapter) {\n\n        av_free(dst);\n\n        return;\n\n    }\n\n\n\n    len -= 16;\n\n    while (len > 10) {\n\n        avio_read(pb, tag, 4);\n\n        tag[4] = 0;\n\n        taglen = avio_rb32(pb);\n\n        avio_skip(pb, 2);\n\n        len -= 10;\n\n        if (taglen < 0 || taglen > len) {\n\n            av_free(dst);\n\n            return;\n\n        }\n\n        if (tag[0] == 'T')\n\n            read_ttag(s, pb, taglen, &chapter->metadata, tag);\n\n        else\n\n            avio_skip(pb, taglen);\n\n        len -= taglen;\n\n    }\n\n\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);\n\n    av_free(dst);\n\n}\n", "idx": 16808, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "t", "w", "p", "sb", "as", "ses", "ins", "sq", "aws", "h", "ctx", "qs", "is", "bs", "e", "sv", "rs", "gs", "S", "ss", "v", "ns", "sts", "self", "aps", "ps", "sys", "js", "c", "es", "ats", "r", "local", "n", "fs", "ts", "ls", "f", "stats", "spec", "sc", "b", "its"], "pb": ["patch", "td", "snap", "lp", "cv", "np", "dp", "wp", "px", "phy", "p", "sb", "pp", "bb", "amp", "sp", "asm", "proc", "bh", "ctx", "bp", "pc", "fb", "bs", "ob", "buf", "bps", "gc", "tmp", "vp", "tp", "pg", "pro", "bj", "wb", "stab", "pm", "typ", "mp", "nb", "PB", "pkg", "pt", "gb", "erb", "pool", "jp", "batch", "tk", "bf", "rb", "txt", "cb", "pl", "pa", "uf", "resp", "cp", "fp", "eb", "b", "ap", "lb"], "len": ["lp", "loc", "z", "lon", "size", "format", "lib", "ml", " l", "length", "conv", "ln", "label", "iter", "local", "ell", "lim", "pl", "offset", "mem", "el", "t", "sp", "en", "compl", "dl", "msg", "L", "kl", "n", "fc", "ls", "lang", "Len", "elt", "fl", " length", "l", "nt", "total", "num", "enc", "vec", "all", "lt", "nl", "cmp", "lan", "alt", "ld", "next", "pos", "lf", "ll", "mil", "fin", "bytes", "rev", "lit", "val", "lc", "lic", "repl", " clen", "seq"], "ttag": ["ktagger", "ktags", "mtags", "ktagg", "otags", "ttags", "mtagg", "mtag", "ktag", "otagger", "otagg", "ttagg", "mtagger", "ttagger", "otag"], "extra_meta": ["extra2data", " extra_data", " extra2data", " extra2desc", "extra_desc", " extra_desc", " extra_metadata", "extra_data", "extra___data", "extra2metadata", "extra___meta", " extra2meta", " extra2metadata", "extra___metadata", "extra2desc", "extra___desc", "extra_metadata", "extra2meta"], "start": ["next", "offset", "init", "check", "pos", "index", "loc", "use", "size", "before", "sp", "st", "set", "Start", "base", "shift", "op", "load", "starting", "step", "name", "stop", "ad", "position", "get", " beg", "first", "time", "range", "origin", "art", "rank", "top", "space", "open", "wind", "from", "rest", "it", "part", "begin", "trans"], "end": ["offset", "until", "ue", "eng", "size", "max", "close", "st", "en", "then", "enc", "ender", "last", "util", "ape", "fail", "length", "send", "out", "stop", "fin", "ad", "wrap", "add", "ending", "range", "roll", "id", "ext", "east", "line", "ell", "est", "bound", "eff", "End", "ent", "exec", "END", "ended", "nd", "rest", "except", "it", "begin", "event", "ek"], "chapter": ["format", "shop", "cloth", "student", "handler", "header", "self", "friend", "peer", "c", "joined", "page", "context", "cho", "metadata", "section", "year", "book", "chain", "lot", "series", "title", "connection", "channel", "server", "item", "plot", "result", "wiki", "course", "virtual", "cop", "tmp", "soc", "plugin", "msg", "parent", "root", "Chapter", "cue", "entry", "part", "version", "trans", "patch", "chron", "proc", "toc", "voice", "prop", "ch", "progress", "instance", "verb", "cmp", "month", "podcast", "man", "chart", "character", "history", "component", "p", "client", "cell", "morph", "change", "artist", "config", "cont", "record", "table", "lc", "comp"], "dst": ["sdsp", "dsts", "sdst", "tst", "mst", "Dsp", "pdest", "wST", "ntd", "dST", "Dst", "tdest", " ddest", " dtd", "drast", "desst", "fdpt", "dsnd", " dpt", " dsp", "ddest", "dtd", "sdct", "fdst", "nST", "sddest", "rST", "dsct", "fdbr", "destd", "pnd", "wend", "dpt", "dct", "tsp", "dost", "fdsts", "desST", "pst", "dbr", "psts", "pct", "mpt", "rost", " dST", "dspt", " dend", "dsp", "tsts", "rst", "dradest", "wst", " dbr", "Ddest", "dnd", "desct", "msts", "Dsts", "nst", " dct", "sdost", " dost", "psp", "sdnd", "rend", "nct", "dsst", " dsts", "ppt", "drasp", "mbr", "dend", "draost", "wost", "sdpt"], "taglen": ["taglon", "monthlen", "bitln", "buglin", "taggen", "bitLen", "TAGLen", "charlength", "buglength", "wordl", "TAGlen", "TAGlon", "tagname", " tagl", "charname", "tagln", "logln", " taggen", " taglib", " tagname", "tagl", "agname", "tasklength", "loglon", "buglon", "ticklength", " taglin", "tasklen", "bitgen", "monthgen", " tagln", "loglib", "monthln", "aglen", "wordlen", "bugl", "tasklon", "bitlen", "ticklen", "wordlon", "charlen", "aglength", "bugln", "taglength", "loglen", "monthLen", "agLen", "TAGln", "wordln", "tagLen", "charLen", "buglib", "wordlength", "tickLen", "TAGlength", " tagLen", "buglen", " taglength", "tickln", "tasklin", "taglib", " taglon", "taglin"], "tag": ["word", "error", "ag", "back", "flag", "comment", "pad", "format", "agg", "var", "test", "at", "bad", "tar", "feature", "set", "sum", "bag", "mod", "arg", "map", "tmp", "prefix", "match", "prop", "other", "step", "tags", "name", "ad", "image", "ot", "stat", "bug", "reg", "mat", "attr", "add", "feat", "param", "cat", "mp", "TAG", "msg", "data", "bit", "id", "att", "pkg", "local", "field", "et", "date", "pack", "Tag", "pair", "key", "ack", "token", "tail", "row", "go", "comp", "part", "byte", "col", "type"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    unsigned long page_index;\n\n    int ret;\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n    page_index = ram_addr >> TARGET_PAGE_BITS;\n\n    if (!modified_ram_pages_table[page_index]) {\n\n#if 0\n\n        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);\n\n#endif\n\n        modified_ram_pages_table[page_index] = 1;\n\n        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;\n\n        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {\n\n            /* flush */\n\n#ifdef _WIN32\n\n            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                                  &nb_modified_ram_pages,\n\n                                  sizeof(nb_modified_ram_pages),\n\n                                  NULL, 0, &temp, NULL);\n\n#else\n\n            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                        &nb_modified_ram_pages);\n\n#endif\n\n            kqemu_reset_modified_ram_pages();\n\n        }\n\n    }\n\n}\n", "idx": 16812, "substitutes": {"env": ["con", "eng", "tx", "proc", "en", "vt", "test", "h", "ctx", "end", "e", "buf", "cur", "db", "v", "obj", "param", "req", " environment", "ev", "context", "txt", "code", "pe", "dest", "conf", "eh", "environment"], "ram_addr": [" ram_ref", "ram_address", "rammyref", " ram_ord", "rammyord", "ram2addr", "ram2pos", "am_address", "rammyaddr", "ram_ref", "am_pos", "am_ref", "ram2add", "rammyadd", "gram_addr", "am_addr", "am_add", "ram2address", "ram_ptr", "gram_ref", " ram_add", "ram2ptr", "ram_ord", "ram_pos", "ram2ref", "gram_address", "ram_add", "am_ptr"], "page_index": [" page_link", "page00number", "Page_ind", "cycleNameindex", "page_prefix", "page_alias", "pagezalias", "pageingnumber", "pagezindex", "page00value", "cycleNameprefix", "page_Index", "pageNamealias", "cycleNamealias", " page_strength", "pageNameindex", "page_link", "cycleNameIndex", "pageingdepth", "pageNameIndex", "page_object", " page_depth", "page00index", "cycle_prefix", "pagezprefix", "pagezIndex", "page_number", " page_value", "pageingvalue", "page_value", "Page_index", "pageingindex", "cycle_Index", "Page_number", " page_number", "page_ind", "pageNameprefix", "page_depth", " page_Index", "cycle_alias", "page_strength", "cycle_index", "page00depth", "Page_object"], "ret": ["mem", " RET", "res", "nt", "pret", "t", "back", "flag", "valid", "ter", "final", "result", "report", "rt", "arg", "tmp", "prop", "tr", "out", "reg", "Return", "inter", "cont", "get", "ft", " Ret", "rem", "sys", "class", "RET", "reply", "re", "det", "ext", "att", "ref", "val", "def", "print", "alt", "ert", "resp", "not", "elt", "status", "Ret"], "temp": ["mem", " output", "index", "tc", " t", "t", "w", " wr", " temporary", "term", "result", "vt", "test", " Temp", "tem", " result", "dat", "tmp", " ptr", "fac", "Temp", "v", "limit", " buf", "ptr", "attr", "data", " mem", "pt", "storage", "EMP", "pool", "template", " temperature", "alt", " tmp", "cache", "txt", "null", "tm", "pre", " term", "buffer", "status"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                                 unsigned npfd, int64_t timeout)\n\n{\n\n    if (!ctx->epoll_available) {\n\n        return false;\n\n    }\n\n    if (aio_epoll_enabled(ctx)) {\n\n        return true;\n\n    }\n\n    if (npfd >= EPOLL_ENABLE_THRESHOLD) {\n\n        if (aio_epoll_try_enable(ctx)) {\n\n            return true;\n\n        } else {\n\n            aio_epoll_disable(ctx);\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 16829, "substitutes": {"ctx": ["ctl", "cv", "history", "tc", "nt", "ca", "ok", "window", "ck", "tx", "mc", "kt", "gc", "uj", "setup", "cur", "config", "cf", "tmp", "cas", "prefix", "jac", "ct", "bc", "cc", "kw", "conv", "hw", "obj", "wx", "wd", "sys", "conn", "req", "c", "cmd", "pkg", "jp", "parent", "mk", "context", "cmp", "tk", "ctrl", "cm", "cfg", "batch", "act", "Context", "cb", "txt", "anc", "xc", "cp", "wcs", "exec", "sc", "ctr"], "pfds": ["pifrs", " pfns", " pfcs", "pifcs", "pfdcs", "pfdns", "pifds", "pifns", " pfrs", " pifds", "pfsns", "pfsds", "pfrs", "pfsrs", " pifcs", "pfscs", " pifrs", " pifns", "pfdrs", "pfns", "pfdds", "pfcs"], "npfd": ["pnfp", " npdat", "npdat", "pnda", "npda", "pnfd", "npfp", "ndat", "ncds", " npFD", "ncfp", "pnFD", "ncFD", "nbfd", "nFD", "pnds", "nfd", "nbfp", "ncfd", "nbds", " npda", "nda", "pndat", "nbFD", "npFD", "npds"], "timeout": ["check", "duration", " t", "size", "opt", "ffff", "period", "uration", " threshold", "wait", "delay", "lock", "resolution", "sec", "out", "unit", " seconds", "time", " duration", "Timeout", "ts", "block", "tt", "buffer", "frequency", "policy", "tv", "seconds"]}}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void aarch64_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&aarch64_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {\n\n        aarch64_cpu_register(&aarch64_cpus[i]);\n\n    }\n\n}\n", "idx": 16842, "substitutes": {"i": ["init", "ic", "index", "ij", "si", "ci", "im", " my", "p", "uu", "ei", " n", "qi", "ki", "port", "li", " pi", "is", "\u0438", "ri", "point", "I", " ii", " l", "ai", "phi", " multi", "ori", "iq", "v", "di", "mu", "cli", " mi", "ip", "mi", "pi", "c", "ii", " j", "ind", "j", "xi", "oi", "my", "ti", "ui", "batch", "gi", "print", " I", "ji", "multi", "fi", "key", "bi", "x", "ims", " m", "sim", " err", "ini", " bi", "zi", "gu", "it", "ix", "iu", "y", " c", "m"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 16862, "substitutes": {"opaque": ["opane", "operacity", "iopacity", "operaques", "obacity", "obaque", "opus", "operula", "opaques", " opaques", "popus", "popaque", "ogaque", "obula", "ogus", "iopus", "obaques", "opula", "iopane", "popacity", "iopaque", " opula", "ogane", " opacity", "ogacity", "popane", "opacity", "operaque"], "offset": ["priority", "pos", "index", "Offset", "location", "style", "ta", "pad", "slot", "set", "shift", "count", "point", "op", "prefix", "padding", "command", "length", "alloc", "position", "off", "seek", "address", "name", "start", "pointer", "mask", "area", "addr", "tab", "range", "id", "scope", "field", "oid", "origin", "bound", "o", "alias", "attribute", "buffer", "code"], "value": ["word", "format", "VALUE", "weight", "echo", "test", "feature", "scale", "option", "vp", "length", "password", "Value", "variable", "label", "self", "get", "field", "number", "maximum", "attribute", "buffer", "eth", "index", "use", "server", "input", "result", "always", "set", "zero", "sum", "property", "initial", "amount", "unknown", "content", "v", "fee", "description", "json", "try", "dev", "parent", "hello", "true", "null", "entry", "code", "version", "status", "mode", "style", "wire", "total", "name", "address", "all", "example", "python", "operator", "template", "raw", "transform", "vector", "state", "request", "block", "no", "text", "byte", "priority", "see", "ue", "widget", "VAL", "expression", "padding", "values", "position", "unit", "select", "ay", "data", "record", "flow", "val", "message", "current", "now", "key", "package", "when", "function", "type"], "size": ["cap", "mem", "style", "z", "window", "weight", "shift", "scale", "sum", "count", "length", "name", "address", "start", "area", "fee", "ize", "message", "n", "space", "Size", "SIZE", "len", "code", "type"], "s": ["details", "rs", "vs", "se", "obj", "sys", "ants", "es", "sync", "comm", "fs", "er", "spec", "sl", "os", "t", "settings", "q", "sm", "set", "qs", "S", "ss", "so", "sts", "ps", "service", "o", "n", "ts", "ls", "parts", "stats", "bis", "comments", "services", "ies", "ds", "cs", "terms", "sb", "changes", "ses", "als", "sv", "des", "js", "j", "request", "ssl", "b", "y", "rates", "m", "hs", "uploads", "i", "p", "ins", "store", "sq", "h", "is", "bs", "gs", "ports", "ns", "sports", "tes", "pers", "ats", "r", "eps", "less", "ears", "ims", "conf", "its"]}}
{"project": "qemu", "commit_id": "3b2e934463121f06d04e4d17658a9a7cdc3717b0", "target": 0, "func": "static inline uint32_t nvic_gprio_mask(NVICState *s)\n\n{\n\n    return ~0U << (s->prigroup + 1);\n\n}\n", "idx": 16870, "substitutes": {"s": ["a", "hs", "ds", "t", "p", "sb", "ses", "sq", "aws", "h", "is", "bs", "e", "g", "sv", "rs", "gs", "S", "ss", "ns", "sts", "v", "sys", "js", "c", "j", "es", "ats", "r", "n", "ts", "b", "bis", "m"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "int qemu_eventfd(int fds[2])\n\n{\n\n#ifdef CONFIG_EVENTFD\n\n    int ret;\n\n\n\n    ret = eventfd(0, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = ret;\n\n        qemu_set_cloexec(ret);\n\n        if ((fds[1] = dup(ret)) == -1) {\n\n            close(ret);\n\n            return -1;\n\n        }\n\n        qemu_set_cloexec(fds[1]);\n\n        return 0;\n\n    }\n\n\n\n    if (errno != ENOSYS) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    return qemu_pipe(fds);\n\n}\n", "idx": 16879, "substitutes": {"fds": ["fDs", "fdrs", "Fuds", "fps", "nys", "fcs", "formda", " frs", " fps", "formdes", "sfdes", "nds", "bfDs", "afps", "Fcs", "afrs", " fcs", "tyds", "fdos", "frs", "hys", "afts", "bfds", "fts", "fda", "formds", " fDs", "nDs", " fels", " fdos", "fdps", "sfds", "sfdos", "fdds", "fdes", "fuds", "foredos", "Fds", "huds", "sfda", "fels", "foreda", " fbs", "fbs", "fsds", "fsbs", " fuds", "fys", "formdos", "fsels", " fts", "Fys", "tydos", "fsdos", "tybs", "foredes", " fys", "hds", "afds", " fda", "nda", "foreds", "tyels", "fdts", "bfda", "bfys", "hcs"], "ret": ["mem", "res", "nt", "t", "back", "flag", "p", "ter", "dt", "lib", "num", "result", "vt", "Ret", "ry", "set", "end", "rt", "gc", "buf", "arg", "g", "tr", "mt", "sec", "out", "v", "reg", "inter", "cont", "get", "lt", " Ret", "ft", "success", "conn", "RET", "reset", "re", "gb", "ext", "try", "j", "ref", "r", "val", "new", "def", "usr", "alt", "x", "txt", "cb", "len", "net", "no", "resp", "cert", "f", "gt", "code", "elt", "red", "err"]}}
{"project": "qemu", "commit_id": "77a5a0001bd9eaee9da7dc8f0b69702d56b0cc67", "target": 0, "func": "static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    return -ENOTSUP;\n\n}\n", "idx": 16888, "substitutes": {"bs": ["bm", "ds", " ss", "cs", "lbs", "BS", "sb", "bb", "ses", "as", "bh", "bp", "ks", "qs", "is", "rs", "gs", "ss", "bd", "bc", "ns", "vs", "bos", "ps", "cks", "fs", "bf", "ts", "bis"], "offset": ["pos", " seek", "Offset", "index", "size", " start", "set", "shift", "base", "zero", "amount", "seek", "off", "scroll", "start", "pointer", "tab", " offsets", "ref", "oid", "origin", " off", " o", "top", "block", "from", "type"]}}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER(wsr_ibreakenable)(uint32_t v)\n\n{\n\n    uint32_t change = v ^ env->sregs[IBREAKENABLE];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < env->config->nibreak; ++i) {\n\n        if (change & (1 << i)) {\n\n            tb_invalidate_phys_page_range(\n\n                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);\n\n        }\n\n    }\n\n    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);\n\n}\n", "idx": 16890, "substitutes": {"v": ["a", "cv", "lv", "l", "qv", "size", "t", "w", "p", "vt", "h", "q", "va", "nv", "change", "g", "sv", "vp", "u", "vc", "values", "conv", "uv", "limit", "vs", "vm", "ve", "value", "iv", "c", "j", "r", "ev", "V", "NV", "n", "o", "env", "x", "vv", "s", "f", "tv", "b", "y", "m"], "i": ["init", "ic", "index", "l", "si", "ci", "im", "p", "ei", "qi", "me", "li", "is", "span", "\u0438", "e", "ri", "I", " ii", "u", "ai", "phi", "di", "io", "cli", "k", "ip", "mi", "pi", "oi", "ind", "id", "my", "j", "xi", "in", "ti", "ui", "gi", "o", "uli", "ami", "multi", "uri", "fi", "eu", "bi", "x", "ims", "info", "sim", "ini", "zi", "ie", "chain", "ms", "ix", "it", "ex", "us", "iu", "y", "ii", "m"]}}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 16924, "substitutes": {"oc": ["ic", "loc", "os", "ok", "mc", "ec", "ctx", "unc", "pc", "ob", "toc", "vc", "ot", "alloc", "bc", "co", "soc", "orp", "c", "uc", "ocr", "oci", "oco", "oid", "voc", "o", "nc", "roc", "OC", "ocation", "ac", "org", "ost", "od", "oca", "oe"], "data": ["ds", "res", "desc", "mc", "config", "dat", "ata", "name", "rec", "out", "d", "DATA", "di", "mu", "Data", "doc", "instance", "func", "new", "draw", "def", "dll", "bin", "rc", "dd", "bus"], "occ": ["con", "loc", "ok", "mc", "ec", "erc", "unc", "bec", "ob", "Rec", "exc", "usc", "cf", "rec", "cci", "orm", "co", "gov", "etc", "soc", "obj", "orp", "ocr", "func", "Occ", "oci", "oid", "coll", "orc", "rog", "fc", "acc", "circ", "nc", "anc", "rown", "roc", "OC", "xc", "rc", "abc", "icc", "ac", "org", "inc", "oe"], "cc": ["ctl", "con", "cs", "tc", "ca", "cong", "ci", "ck", "disc", "lib", "lf", "mc", "isc", "ec", "ll", "cn", "ctx", "erc", "pc", "gc", "bec", "cl", "cf", "craft", "vc", "cca", "bc", "rec", "cci", "co", "ct", "etc", "control", "cd", "cont", "cy", "BC", "uc", "c", "cmd", "func", "ctrl", "CC", "lc", "cmp", "xx", "coll", "cm", "fc", "acc", "ce", "cu", "nc", "ld", "roc", "ucc", "xc", "rc", "icc", "ac", "code", "sc", "inc", "dd"], "dc": ["ctl", "ds", "cs", "dp", "tc", "ca", "disc", "ck", "mc", "ec", "ctx", "unc", "pc", "gc", "cam", "cf", "vc", "cca", "bc", "rec", "nz", "d", "co", "db", "di", "cd", "da", "cat", "c", "uc", "bd", "cmp", "lc", "fc", "acc", "nc", "iac", "DC", "rc", "ac", "sc"]}}
{"project": "qemu", "commit_id": "d99598cc9929ad6993ad3d19d9b1ec1d891f0d7f", "target": 1, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n", "idx": 16930, "substitutes": {"opaque": ["oplque", "ropiera", "oplay", " oplay", " opque", "iplay", "opiera", "oplaque", "oppacity", "oppque", " opiera", "oppaque", "oplacity", " opacity", "opacity", "ipaque", "opque", "opllay", "roplay", "ropaque", "ipiera", "opplay"], "addr": ["a", "offset", "pos", "loc", "res", "arr", "pad", "tx", "var", "hash", "ctx", "kt", "ress", "adr", "buf", "ace", "map", "tmp", "rs", "prefix", "handle", "mt", "name", "address", "ad", "ns", "attr", "ptr", "dr", "add", "obj", "ip", "wd", "data", "msg", "cmd", "to", "id", "nl", "pkg", "ref", "r", "host", "str", "pair", "alt", "alias", "state", "ack", "Address", "len", "arp", "bind", "url", "src", "trans"], "f": ["fd", "fn", "t", "fal", "w", "fab", "i", "p", "lf", "sf", "h", "fb", "e", "fr", "g", "cf", "u", "fac", "xf", "d", "v", "alf", "fe", "tf", "ft", "ff", "r", "fo", "o", "fs", "fi", "fc", "bf", "fm", "fa", "af", "x", "fw", "uf", "fp", "rf", "F", "b", "file", "fl"], "c": [" C", "con", "cs", "l", "tc", "t", " cc", "ci", "i", " count", "p", " cs", " n", "mc", "cn", "ec", "h", "ctx", "unc", "pc", "gc", "e", "count", "cl", "cur", "g", "vc", "ct", "cc", "ch", "out", "d", "co", "v", "bc", "k", "cont", "call", "uc", "cr", "r", "cmp", "lc", "cm", "dc", "C", "n", "cod", "ce", "fc", "cu", "cache", "x", "nc", "len", "com", "cp", "ac", "s", "chain", "rc", "sc", "b", "conf", "m"]}}
{"project": "qemu", "commit_id": "a9db86b223030bd40bdd81b160788196bc95fe6f", "target": 1, "func": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n", "idx": 16933, "substitutes": {"dest": ["temp", "export", "comb", "nom", "loc", "word", "dist", "deg", "opt", "comment", "prototype", "desc", "num", "result", "test", "port", "decl", "good", "sum", "output", "created", "global", "dat", "tmp", "shape", "tif", "prop", "foreign", "tr", "sec", "out", "d", "etc", "them", "doc", "iter", "cont", "document", "order", "priv", "req", "target", "msg", "master", "dev", "local", "origin", "draw", "est", "usr", "del", "coord", "Dest", "txt", "rest", "src", "way", "trans"], "source": ["init", "check", "sc", "see", "ource", "sky", "use", "style", "seed", "item", "size", "component", "comment", "before", "sp", "secure", "store", "input", "interface", "query", "sum", "config", "copy", "subject", "match", "other", "name", "image", "unit", "session", "start", "SOURCE", "se", "supp", "service", "any", "in", "ind", "inner", "master", "scope", "Source", "parent", "template", "origin", "local", "message", "draw", "join", "str", "now", "info", "sim", "from", "s", "params", "it", "src", "comp", "spec", "part", "rule"], "i": ["hi", "ski", "li", "ri", "g", "point", "I", "ai", "di", "mi", "c", "ji", "asi", "chain", "multi", "ii", "index", "ij", "t", "ci", "port", "\u0438", "phi", " multi", "v", "cli", "pi", "my", "gi", "fi", "bi", "x", "zi", "ini", "f", "it", "iu", "status", "init", "ic", "l", "ei", "qi", " ti", "me", " ii", " mi", "k", "ip", "iri", "j", "ti", " ki", "print", " I", "ami", "uri", "uli", "info", " di", " bi", "ix", "y", "m", "si", "im", "ki", "remote", " Li", " pi", "is", "oi", "in", "ind", "id", "xi", "batch", "ui", "key", "ims", " ni", "sim"]}}
{"project": "FFmpeg", "commit_id": "b00fb157bae79f9735910064585fd95b8c123003", "target": 0, "func": "static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n\n{\n\n    const uint8_t *src_end = src + src_size;\n\n    int x = 0, y = 0;\n\n\n\n#define INC_XY(n) \\\n\n    x += n; \\\n\n    if (x >= width) { \\\n\n        y++; \\\n\n        if (y >= height) \\\n\n            return 0; \\\n\n        x = 0; \\\n\n    }\n\n\n\n    while (src_end - src >= 2) {\n\n        uint8_t v = *src++;\n\n        if (v > 0 && v < 0xC0) {\n\n            do {\n\n                int length = FFMIN(v, width - x);\n\n                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n\n                INC_XY(length);\n\n                v   -= length;\n\n            } while (v > 0);\n\n            src++;\n\n        } else if (v >= 0xC1) {\n\n            v -= 0xC0;\n\n            do {\n\n                int length = FFMIN3(v, width - x, src_end - src);\n\n                if (src_end - src < length)\n\n                    break;\n\n                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);\n\n                INC_XY(length);\n\n                src += length;\n\n                v   -= length;\n\n            } while (v > 0);\n\n        } else {\n\n            avpriv_request_sample(avctx, \"opcode %d\", v);\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16984, "substitutes": {"avctx": ["avctl", "AVctx", " avcontext", "AVcp", "Avctl", " avcp", " avcas", "avconn", "Avcontext", " avctl", "AVcontext", "avcontext", "ajctx", " avconn", "Avctx", "AVcas", "avcas", "ajcontext", "savcp", "savcas", "ajctl", "avcp", "Avconn", "savcontext", "savctx", "ajconn"], "dst": ["ddest", "dsts", "pst", "bnd", "psts", "lpt", "dsht", "disST", "bsts", "dlt", "dispt", "dspt", "dht", "disest", "lST", "cdest", "lst", "cht", "dST", "Dst", "disst", "dsst", "cpt", "dept", "deht", "cst", "pnd", "lsts", "dedest", "dpt", "bst", "lnd", "Dest", "dsdest", "blt", "lest", "Dpt", "dnd", "llt", "DST", "dest", "plt"], "src": ["loc", "ser", "ur", "size", "img", "sup", "st", "rt", "rs", "length", "tp", "conv", "iv", "sys", "c", "inner", "sync", "sr", "s", "url", "sl", "hl", "offset", "np", "sp", "input", "stream", "gz", "syn", "cur", "tmp", "sec", "start", "sn", "usr", "x", "ctr", "sc", "stack", "init", "cs", "seed", "slice", "sb", "sub", "proc", "th", "ith", "cc", "bc", "uv", "ptr", "sing", "addr", "source", "txt", "nr", "rc", "scan", "b", "i", "ins", "sq", "bs", "u", "rec", "supp", "cont", "ind", "in", "inst", "r", "sur", "comp", "dest", "seq", "rl"], "src_size": ["ser_SIZE", "rc_size", "src_time", "src_SIZE", "rc_dim", "src_dim", "src_Size", "ser_size", "ser_Size", "rc_time", "rc_Size"], "height": ["grow", "history", "size", "density", "gravity", "depth", "hang", "acity", "h", "radius", "stroke", "axy", "oom", "shape", "padding", "resolution", "length", "ch", "holes", "hub", "wh", "rows", "loss", "build", "ows", "Height", "y"], "linesize": ["blockspace", "linespan", "inesize", "linspan", "dspan", "blocksIZE", "usersze", "inespan", "linesized", "linsize", " linesze", "inespace", "dsized", "framesization", "usersize", "usersization", "inesIZE", "inesized", "blocksize", "lineize", "lineizer", "linepace", "framesizer", "linespace", " linesization", "dsiz", "usersizer", "linesization", "framesze", "lineIZE", "linesIZE", "dsize", "linesizer", "linesiz", "inesizer", " linesizer", "linsized", "blocksizer", "inesiz", "linsiz", "framesize", "linesze"], "src_end": ["source_end", "rc_size", "rc_end", "src_start", "source_start", " src_start", "src_next", "src___start", "src___end", "rc_begin", "rc_start", "src_begin", "src_END", "rc_next", "source_END", "src___next"]}}
{"project": "FFmpeg", "commit_id": "9aa0606e87a221eba935ed675c1cd5ca94832e28", "target": 0, "func": "static int hls_read_seek(AVFormatContext *s, int stream_index,\n\n                               int64_t timestamp, int flags)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i;\n\n    int64_t seek_timestamp;\n\n    int valid_for = -1;\n\n\n\n    if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->playlists[0]->finished)\n\n        return AVERROR(ENOSYS);\n\n\n\n    seek_timestamp = stream_index < 0 ? timestamp :\n\n                     av_rescale_rnd(timestamp, AV_TIME_BASE,\n\n                                    s->streams[stream_index]->time_base.den,\n\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n\n\n    if (s->duration < seek_timestamp)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* check first that the timestamp is valid for some playlist */\n\n        struct playlist *pls = c->playlists[i];\n\n        int seq_no;\n\n        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {\n\n            /* set segment now so we do not need to search again below */\n\n            pls->cur_seq_no = seq_no;\n\n            valid_for = i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (valid_for < 0)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* Reset reading */\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->input) {\n\n            ffurl_close(pls->input);\n\n            pls->input = NULL;\n\n        }\n\n        av_free_packet(&pls->pkt);\n\n        reset_packet(&pls->pkt);\n\n        pls->pb.eof_reached = 0;\n\n        /* Clear any buffered data */\n\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n\n        pls->pb.pos = 0;\n\n\n\n        pls->seek_timestamp = seek_timestamp;\n\n        pls->seek_flags = flags;\n\n\n\n        /* set closest segment seq_no for playlists not handled above */\n\n        if (valid_for != i)\n\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n\n    }\n\n\n\n    c->cur_timestamp = seek_timestamp;\n\n\n\n    return 0;\n\n}\n", "idx": 16986, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "sg", "t", "w", "settings", "p", "as", "ses", "changes", "sq", "aws", "qs", "is", "bs", "sv", "rs", "gs", "S", "ss", "comments", "sts", "ns", "bytes", "ps", "sys", "sports", "js", "es", "ats", "comm", "n", "o", "fs", "acs", "ts", "actions", "ls", "parts", "stats", "spec", "sc", "b", "conf", "its", "m"], "stream_index": ["stream_connected", "streamityindex", "peer_error", "stream_num", " stream_Index", "stream_error", "streamityconnected", " stream_length", "stream_name", "stream_length", "peer_ind", "ream_num", "stream_ind", "streamNamelength", "peer_code", "streamNameconnected", " stream_connected", "stream_Index", "streamityIndex", "stream_code", "streamityind", "streamNameindex", "stream_number", "ream_index", "streamitycode", "streamNameIndex", "streamityerror", "peer_index", "ream_name", "streamitylength", "ream_number"], "timestamp": ["primestamp", "primement", "Timest", "timeeline", "tmest", " timement", "tunency", "tunestamp", "timement", "timeest", "Timency", "Timement", "tmetime", "Timetime", "Timeless", " timest", "Timestamp", "tunest", "timeetime", " timeless", "tmestamp", "tmeline", "primest", "timeline", "timetime", "timeless", "primeless", "timency", "Timeline", "timeestamp", "timeency", "timest"], "flags": ["atts", "fields", "cs", "acts", "times", "fps", "args", "flag", "settings", "bits", "events", "details", "limits", "changes", "rates", "posts", "lines", "frames", "words", "vals", "allows", "grades", "length", "files", "values", "tags", "properties", "mask", "aps", "ps", "sets", "ants", "types", "styles", "ats", "options", "uses", "fs", "ags", "ints", "weights", "ts", "actions", "features", "FLAG", "locks", "levels", "parts", "stats", "wcs", "heads", " Flags", "lag", "ents", "status", "Flags", "comments"], "c": ["con", "cv", "cs", "tc", "l", "ca", "t", "ci", "p", "mc", "ec", "enc", "ctx", "ar", "pc", "gc", "cl", "g", "cam", "cf", "config", "vc", "cc", "ct", "bc", "ch", "co", "v", "etc", "cd", "cont", "cr", "comm", "cmp", "lc", "cm", "dc", "C", "n", "fc", "ce", "cu", "cache", "cb", "nc", "cp", "com", "ac", "f", "rc", "ex", "sc", "b", "conf"], "i": ["hi", "li", "ri", "e", "point", "I", "ai", "di", "iter", "mi", "ji", "gu", "chain", "series", "multi", "ii", "index", "ij", "t", "ci", "\u0438", "phi", "v", "cli", "json", "pi", "try", "gi", "n", "o", "bi", "x", "zi", "ini", "f", "it", "iu", "init", "ic", "l", "ei", "qi", "me", "ik", " ii", "name", "iq", "ip", "to", " j", "j", "ti", " I", "info", "go", "ie", "ix", "y", "m", "history", "si", "im", "p", "ki", "remote", "is", "oi", "ind", "id", "in", "xi", "ui", "batch", "iy", "ims", "sim"], "seek_timestamp": ["seek_timeetz", "seek_simestation", "seek67simest", "seek_Timetz", "seek_timeestamp", "seek_waitestamp", "seek_nowemark", "seek67timest", "seek_timesetime", "seek_mometz", "seekabletimtime", "seek___timestamp", "seek___dimestamp", "seek_timesetz", "seek67timestamp", "seekedtimence", "seek_baspace", "seek_waitetime", "seek___timporal", "seek_dimenth", "seekabletimestamp", "seek_timenth", "seekedwaitence", "seek_simest", "seek_metotype", "seek___timest", "seekabletimest", "seek_timesest", "seek_timpace", "seek_dimificate", "seek_timesency", "seek_timest", "seek___dimporal", "seek_numestamp", "seek_timeence", "seek___timenth", "seekedtimestamp", "seek_dimestamp", "seek_typest", "seek_Timenth", "seek_timespace", "seek67simaration", "seek_numence", "seek_timetime", "seek_nowotype", "seek_dimest", "seek_timemark", "seek_mediaration", "seek_Timest", "seek_Timtime", "seek_Timaration", "seek_typestamp", "seekableTimest", "seek67simestation", "seek_dimporal", "seek_simaration", "seekedwaitestamp", "seek_momency", "seek67timestation", "seek_timeest", "seek_timaration", "seek_timency", "seek_timporal", "seek_timeamp", "seek_Timestamp", "seek_dimemark", "seek_Timporal", "seek_basetz", "seek_metemark", "seek_numetime", "seek_terminestamp", "seek_timetz", "seekableTimamp", "seek_stimest", "seek67simestamp", "seek_timesestamp", "seekedwaitetz", "seek_nowificate", "seek_dimotype", "seek_typtime", "seek_metestamp", "seek_terminetz", "seek_momestamp", "seek_timotype", "seek_numetz", "seek_basestamp", "seek67timaration", "seek_timtime", "seek_basetime", "seek_timestation", "seek___dimenth", "seek_timence", "seek_stimporal", "seek_mediestation", "seek_mediest", "seek_timificate", "seek_Timency", "seek_momest", "seek_Timamp", "seek_Timestation", "seek_terminpace", "seekedtimetz", "seek_stimenth", "seek_waitetz", "seek_simestamp", "seek_timamp", "seek___dimest", "seek_stimestamp", "seekedwaitetime", "seek_mediestamp", "seek_typamp", "seek_waitence", "seekedtimetime", "seekabletimamp", "seek_nowestamp", "seek_timeetime", "seekableTimestamp", "seek_metificate", "seek_terminetime", "seekableTimtime"], "pls": ["palis", " plgs", "splv", "Plats", "splains", " plains", "splges", "logts", "replgs", "pts", "plains", " plies", "implgs", "prts", "plis", "plies", "palands", "logs", "logis", "replands", "cls", "PLjs", "lookjs", " pljs", " plands", "ptjs", "plongs", "palts", " pli", "paties", "spli", "pli", "Pls", "PLts", "looks", "paljs", "spljs", "splis", "loggs", "legies", "repls", "splongs", " plv", "replies", "patges", "splds", "impls", "cljs", "plats", "plns", "plv", "palgs", "plugjs", " plats", "clts", "plts", "Plis", " plts", "repljs", "plands", "Pljs", "prs", "splies", "plys", "places", "legis", " places", "patts", " plges", "pals", "pljs", "Places", "legongs", "plds", "splats", "replts", "logi", "Plts", "plugs", "spls", " plis", "implands", "lookts", "plugv", "logjs", "splgs", "ptains", "ptds", "palongs", "splts", "plgs", "clies", " plns", "prns", "ptts", "plygs", "PLs", "splaces", "plges", "pries", "pats", "lookies", "legs", "Plgs", "plyands", "palies", "ptgs", " plds", "clgs", "pris", "Plns", "prjs"], "seq_no": ["seq_n", "seq_one", "seq_nr", "seqzno", "cmp_no", "seqendo", " seq_n", "seqenno", "seq10No", "seq10no", "seq_do", "cmp_index", " seq_No", "seqableNo", " seq_do", "seqableno", "seqzao", "seq_index", "seq10one", "cmp_nr", "cmp_ao", "seq_ao", "seqznr", "seq10n", "seq23no", "seq23ao", " seq_index", "seq_No", "seqableone", "seqzindex", "seq23nr", "seq23index", "seqenindex", "seqablen", " seq_one"]}}
{"project": "qemu", "commit_id": "6877cff044cdf6da66885eab62363baf98bb39ee", "target": 0, "func": "static int assigned_initfn(struct PCIDevice *pci_dev)\n\n{\n\n    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);\n\n    uint8_t e_intx;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    if (!kvm_enabled()) {\n\n        error_report(\"pci-assign: error: requires KVM support\");\n\n        return -1;\n\n    }\n\n\n\n    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&\n\n        !dev->host.function) {\n\n        error_report(\"pci-assign: error: no host device specified\");\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * Set up basic config space access control. Will be further refined during\n\n     * device initialization.\n\n     */\n\n    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);\n\n    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);\n\n    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_BIST, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CARDBUS_CIS, 4);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_CAPABILITY_LIST + 1, 7);\n\n    assigned_dev_direct_config_read(dev, PCI_MIN_GNT, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_MAX_LAT, 1);\n\n    memcpy(dev->emulate_config_write, dev->emulate_config_read,\n\n           sizeof(dev->emulate_config_read));\n\n\n\n    get_real_device(dev, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* intercept MSI-X entry page in the MMIO */\n\n    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n\n        assigned_dev_register_msix_mmio(dev, &local_err);\n\n        if (local_err) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* handle real device's MMIO/PIO BARs */\n\n    assigned_dev_register_regions(dev->real_device.regions,\n\n                                  dev->real_device.region_number, dev,\n\n                                  &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* handle interrupt routing */\n\n    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;\n\n    dev->intpin = e_intx;\n\n    dev->intx_route.mode = PCI_INTX_DISABLED;\n\n    dev->intx_route.irq = -1;\n\n\n\n    /* assign device to guest */\n\n    r = assign_device(dev);\n\n    if (r < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* assign legacy INTx to the device */\n\n    r = assign_intx(dev);\n\n    if (r < 0) {\n\n        goto assigned_out;\n\n    }\n\n\n\n    assigned_dev_load_option_rom(dev);\n\n\n\n    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);\n\n\n\n    return 0;\n\n\n\nassigned_out:\n\n    deassign_device(dev);\n\nout:\n\n    free_assigned_device(dev);\n\n    return -1;\n\n}\n", "idx": 16999, "substitutes": {"pci_dev": ["pci_Dev", "pdi_dev", "pci_def", "pdi_Dev", "pdi_ev", "pci__dev", "pci__def", "pci__ev", "pci_ev", "pdi_def"], "dev": ["loc", "test", "av", "cam", "ad", "pro", "obj", "priv", "req", "local", "host", " Dev", "develop", "aux", "orig", "gu", "home", "dem", "serv", "mem", "np", "form", "server", "roy", "de", "desc", "var", "app", "end", "device", "nv", "cur", "unknown", "d", "v", "hw", "pkg", "pack", "env", "ver", "tech", " device", "ov", "nt", "res", "w", "num", "ow", "proc", "query", "enc", "th", "DEV", "buf", "prop", "tr", "des", "sw", "serial", "attr", "any", "det", "att", "ev", "draw", "def", "raw", "info", "row", "go", "scan", "debug", "adv", "eng", "p", "Dev", "h", "util", "out", "off", "db", " devs", "hid", "ve", "wd", "rem", "conn", "sd", "data", "cmd", "prom", "val", "new", "conf"], "e_intx": ["e_uintv", "e_intr", "e2intr", "e2indx", "e_uintr", "e_idr", "e_uintx", "e_idx", "e_indr", "e2intv", "e_idv", "e_indv", "e_indx", "e2intx", "e2indv", "e_intv", "e2indr"], "r": ["error", "l", "or", "w", "ra", "ach", "p", "Error", "h", "ry", "ar", "ran", "rt", "e", "rs", "rin", "rr", "attr", "rans", "race", "ror", "R", "usr", "er", "rc", "f", "b", "err"], "local_err": ["local__err", " local_", "local_cr", "local__exc", "global_", "local_", "local__buf", "self_cr", "local_exc", "self_buf", "local__cr", "self_exc", "Local_", "self_err", "local_buf"]}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "int xen_be_send_notify(struct XenDevice *xendev)\n\n{\n\n    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);\n\n}\n", "idx": 17004, "substitutes": {"xendev": ["wxindev", "xenedown", "xentev", "xenedoc", "xndoc", "wxendef", "xesendederv", "xpenedoc", "xendef", "xappendeman", "wxenddev", "xindev", "wxindef", "xendeman", "xendedoc", "xesenderv", "xpendev", "xendederv", "xesendev", "xpenedown", "xentef", "xendoc", "xenderv", "xinderv", "xenedeman", "xendown", "xnderv", "xpenedeman", "wxendev", "xendeddev", "xindoc", "xentdev", "wxinderv", "xenedev", "xpenedev", "xnddev", "xenterv", "xinddev", "xesenddev", "xpendeman", "xenddev", "xesendedoc", "xndef", "wxinddev", "xendedown", "xndev", "xesendedev", "xendedev", "xesendoc", "xpendown", "xpendoc", "wxenderv", "xappendev", "xindef", "xappendoc", "xendedeman", "xappendown", "xesendeddev"]}}
{"project": "FFmpeg", "commit_id": "1e901ffc619459944ae7102428f48972cd899caa", "target": 0, "func": "static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)\n\n{\n\n    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&\n\n        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {\n\n        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&\n\n            timestamp < st->pts_wrap_reference)\n\n            return timestamp + (1ULL<<st->pts_wrap_bits);\n\n        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&\n\n            timestamp >= st->pts_wrap_reference)\n\n            return timestamp - (1ULL<<st->pts_wrap_bits);\n\n    }\n\n    return timestamp;\n\n}\n", "idx": 17009, "substitutes": {"st": ["z", "ist", "ace", "ste", "step", "se", "obj", "rd", "art", "irst", "net", "s", "sl", "ost", "td", "form", "t", "sh", "desc", "sp", "sm", "set", "utt", "ss", "so", "ct", "sts", "etc", "ast", "sn", "sth", "mont", "pt", "usr", "ent", "ts", "rest", "sc", "ut", "stack", "sam", "nt", "th", "cl", "sv", "mt", "stat", "co", "sty", "sw", "each", "spect", "storage", "std", "draw", "ST", "str", "act", "ld", "nd", "tt", "history", "stable", "stage", "store", "must", "tra", "St", "inst", "et", "ust", "est", "sta", "lo", "stan"], "timestamp": ["statificate", "Timtim", "capetz", "timener", "documentemark", "timeest", "timeinal", "timeumn", "timetz", "Timestamp", "capest", "testatile", "momsequence", "statestamp", "poolmediately", "broadestone", "timetime", "pixelemark", " timumn", "timitude", "pixelener", "timeatile", "statemark", "documentificate", "pixelestone", "timeestamp", "timest", "documentestamp", "timtim", "documentmediately", "timtime", "triptim", "magitude", "tomitude", "timumn", "timmediately", "testumn", "statmediately", "timinal", "capestamp", "captim", "messpoint", "timsequence", "broadestamp", " timpoint", "imtime", "magsequence", "testestamp", " timtime", "messumn", "iminal", "Timest", "timed", "timpoint", "timificate", "timeener", "timeestone", " timinal", " timest", "maged", "testpoint", "tomestamp", "momed", "broademark", "timepoint", "tomsequence", "timestone", "timemark", "poolestamp", "timeemark", "pixelestamp", "tripetz", "Timpoint", "impoint", "momestamp", "poolemark", "timatile", "tripestamp", "magestamp", "tomed", "momitude", "Timumn", "broadener", "poolificate", "messatile", "messestamp", "tripest", "imestamp", "Timetz"]}}
{"project": "qemu", "commit_id": "41a2b9596c9ed2a827e16e749632752dd2686647", "target": 0, "func": "static void ide_atapi_cmd_reply_end(IDEState *s)\n\n{\n\n    int byte_count_limit, size, ret;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    printf(\"reply: tx_size=%d elem_tx_size=%d index=%d\\n\",\n\n           s->packet_transfer_size,\n\n           s->elementary_transfer_size,\n\n           s->io_buffer_index);\n\n#endif\n\n    if (s->packet_transfer_size <= 0) {\n\n        /* end of transfer */\n\n        ide_transfer_stop(s);\n\n        s->status = READY_STAT;\n\n        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n\n        ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n        printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n    } else {\n\n        /* see if a new sector must be read */\n\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n\n            ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);\n\n            if (ret < 0) {\n\n                ide_transfer_stop(s);\n\n                ide_atapi_io_error(s, ret);\n\n                return;\n\n            }\n\n            s->lba++;\n\n            s->io_buffer_index = 0;\n\n        }\n\n        if (s->elementary_transfer_size > 0) {\n\n            /* there are some data left to transmit in this elementary\n\n               transfer */\n\n            size = s->cd_sector_size - s->io_buffer_index;\n\n            if (size > s->elementary_transfer_size)\n\n                size = s->elementary_transfer_size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n        } else {\n\n            /* a new transfer is needed */\n\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n\n            byte_count_limit = s->lcyl | (s->hcyl << 8);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"byte_count_limit=%d\\n\", byte_count_limit);\n\n#endif\n\n            if (byte_count_limit == 0xffff)\n\n                byte_count_limit--;\n\n            size = s->packet_transfer_size;\n\n            if (size > byte_count_limit) {\n\n                /* byte count limit must be even if this case */\n\n                if (byte_count_limit & 1)\n\n                    byte_count_limit--;\n\n                size = byte_count_limit;\n\n            }\n\n            s->lcyl = size;\n\n            s->hcyl = size >> 8;\n\n            s->elementary_transfer_size = size;\n\n            /* we cannot transmit more than one sector at a time */\n\n            if (s->lba != -1) {\n\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n\n                    size = (s->cd_sector_size - s->io_buffer_index);\n\n            }\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n        }\n\n    }\n\n}\n", "idx": 17012, "substitutes": {"s": ["z", "bits", "details", "results", "g", "rs", "conv", "vs", "se", "self", "obj", "sys", "c", "es", "comm", "sync", "fs", "er", "params", "serv", "spec", "ows", "sis", "sl", "os", "ops", "t", "settings", "events", "sm", "set", "qs", "S", "ss", "so", "d", "sts", "v", "ps", "xs", "ids", "n", "ts", "ls", "parts", "stats", "bis", "services", "ies", "a", "ds", "cs", "times", "w", "sb", "as", "ses", "changes", "als", "south", "sv", "des", "sw", "http", "js", "j", "gets", "source", "ssl", "tests", "states", "b", "has", "y", "m", "utils", "hs", "args", "ys", "i", "p", "ins", "store", "sq", "ers", "aws", "h", "ions", "is", "gs", "ns", "ties", "sports", "tes", "ats", "r", "less", "ims", "ms", "full", "search", "conf", "its"], "byte_count_limit": ["byte_count_limits", "byte_size_limit", "byte_count_limited", "byte_count_control", "byte_length_lock", "byte_size_lim", "byte_list_lock", "byte_size_control", "byte_count\u05bclimits", "byte_size_lock", "byte_count_lock", "byte_list_limit", "byte_length_limits", "byte_count\u05bclimit", "byte_list_limits", "byte_count\u05bccontrol", "byte_count_lim", "byte_length_limit", "byte_list_limited", "byte_count\u05bclock", "byte_size_limits"], "size": ["export", "format", "shift", "scale", "g", "length", "news", "speed", "sha", "number", "space", "city", "buffer", "yes", "grow", "mem", "offset", "use", "sh", "max", "big", "sp", "timeout", "gz", "set", "zero", "sum", "shape", "general", "scroll", "start", "limit", "add", "fee", "sn", "description", "range", "n", "len", "small", "status", "min", "l", "total", "num", "largest", "south", "send", "name", "address", "capacity", "time", "any", "storage", "to", "body", "height", "too", "huge", "Size", "notice", "SIZE", "no", "see", "used", "args", "sent", "count", "empty", "padding", "mini", "bytes", "area", "data", "ize", "new", "message", "member", "now", "dim", "large", "full", "fit"], "ret": ["mem", "res", "nt", "t", "deg", "flag", "sent", "git", "back", "dt", "st", "result", "hash", "rt", "count", "arg", "tmp", "mt", "nz", "reg", "failed", "cont", "get", " Ret", "rem", "RET", "rev", "re", "reset", "lit", "j", "try", "ref", "r", "val", "rets", "def", "usr", "alt", "repl", "got", "tail", "len", "resp", "rc", "f", "gt", "fun", "elt", "after", "red", "err", "Ret"], "lba": ["lbal", "lana", "llda", "lpa", "lBA", "lina", "llva", "llbal", "llbe", "lifa", "lita", "laba", "bba", "lata", "llBA", "nlBA", " lpa", "llpa", "lna", "lfa", "llta", "lta", "lafa", " lda", "lda", "liba", "nlda", "llba", "nlba", "nlbal", "lva", " lva", "bbe", "lbe", "llfa", " lbe", "bva", "bpa", " lbal", "llna", " lBA"]}}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    MiscState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr & LED_MAXADDR;\n\n    MISC_DPRINTF(\"Write diagnostic LED reg 0x\" TARGET_FMT_plx \" =  %x\\n\", addr,\n\n                 val);\n\n    switch (saddr) {\n\n    case 0:\n\n        s->leds = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 17021, "substitutes": {"opaque": ["opane", "oppsolete", "OPsolete", " opque", "OPacity", "OPac", "obaque", " opsolete", "obacity", "opsolete", "OPane", "opaques", "oppaques", " opaques", "OPque", "opac", "oppaque", "obane", "obque", " opane", " opacity", " opac", "opacity", "opque", "OPaques", "OPaque", "oppac"], "addr": ["offset", "mem", "pos", "a", "work", "grad", "loc", "index", "res", "arr", "ord", "ag", "pad", "tx", "at", "hash", "ctx", "rt", "adr", "ace", "rs", "mt", "alloc", " address", "ad", "address", "off", "start", "inter", "ptr", "dr", "attr", "add", "hw", "cmd", "id", "ref", "r", "oad", "align", "now", "alt", "alias", "coord", "ack", "x", "Address", "ac", "url", "src", "err"], "val": ["bal", "mem", "Val", "grad", "res", "sel", "ival", "weight", "valid", "tx", "slot", "num", "vt", "test", "xy", "ctx", "VAL", "ret", "buf", " value", "vals", "arg", "pol", "count", "values", "all", "v", "bl", "value", "fee", "eval", "data", "bit", "pt", "pal", "rel", "ref", "cal", "def", "sol", "alt", "x", "vol", "al", "serv", "bool", "elt"], "s": ["hs", "t", "w", "i", "p", "sb", "ess", "ses", "sp", "h", "q", "sm", "qs", "is", "bs", "rs", "gs", "S", "ss", "d", "ns", "v", "ps", "c", "n", "o", "fs", "sol", "state", "ts", "ls", "stats", "ms", "sis", "sl", "b", "bis", "m"], "saddr": ["svpad", " sadd", "ssptr", "saddress", "Sadd", "Saddr", "sptr", "wsaddress", "scoord", " saddress", "spad", "svcoord", "wspad", "Scoord", "ssaddr", "ssaddress", " sadr", "ssadr", "sadr", " sptr", "Saddress", "svaddr", "wsaddr", "sadd", "wscoord", "svaddress", "Spad"]}}
{"project": "qemu", "commit_id": "7ce21016b69b512bf4777965a4292318f2bc7544", "target": 0, "func": "int coroutine_fn bdrv_co_discard(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors)\n\n{\n\n    int max_discard;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n\n        return -EIO;\n\n    } else if (bs->read_only) {\n\n        return -EROFS;\n\n    }\n\n\n\n    bdrv_reset_dirty(bs, sector_num, nb_sectors);\n\n\n\n    /* Do nothing if disabled.  */\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {\n\n        return 0;\n\n    }\n\n\n\n    max_discard = bs->bl.max_discard ?  bs->bl.max_discard : MAX_DISCARD_DEFAULT;\n\n    while (nb_sectors > 0) {\n\n        int ret;\n\n        int num = nb_sectors;\n\n\n\n        /* align request */\n\n        if (bs->bl.discard_alignment &&\n\n            num >= bs->bl.discard_alignment &&\n\n            sector_num % bs->bl.discard_alignment) {\n\n            if (num > bs->bl.discard_alignment) {\n\n                num = bs->bl.discard_alignment;\n\n            }\n\n            num -= sector_num % bs->bl.discard_alignment;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_discard) {\n\n            num = max_discard;\n\n        }\n\n\n\n        if (bs->drv->bdrv_co_discard) {\n\n            ret = bs->drv->bdrv_co_discard(bs, sector_num, num);\n\n        } else {\n\n            BlockDriverAIOCB *acb;\n\n            CoroutineIOCompletion co = {\n\n                .coroutine = qemu_coroutine_self(),\n\n            };\n\n\n\n            acb = bs->drv->bdrv_aio_discard(bs, sector_num, nb_sectors,\n\n                                            bdrv_co_io_em_complete, &co);\n\n            if (acb == NULL) {\n\n                return -EIO;\n\n            } else {\n\n                qemu_coroutine_yield();\n\n                ret = co.ret;\n\n            }\n\n        }\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        sector_num += num;\n\n        nb_sectors -= num;\n\n    }\n\n    return 0;\n\n}\n", "idx": 17030, "substitutes": {"bs": ["bits", "ubs", "banks", "uts", "vals", "rs", "aus", "vs", "obj", "bl", "sys", "fs", "ib", "aos", "bm", "boxes", "BS", "bb", "blog", "bys", "bh", "abilities", "tops", "bas", "qs", "bps", "bec", "ubis", "sts", "pb", "ps", "lets", "obs", "bf", "ts", "ls", "locks", "stats", "books", "bes", "bis", "ds", "cs", "sb", "changes", "als", "hz", "bp", "bsp", "bd", "bc", "stones", "js", "css", "cks", "bing", "eb", "states", "b", "hs", "lbs", "fps", "outs", "bles", "ins", "aws", "gs", "eks", "ports", "ns", "bytes", "bos", "irms", "ats", "ims", "ms", "its", "bn"], "sector_num": ["sectorNamena", "tier_num", "tier_net", "slave_mun", "iter_comm", "sector1desc", " sector_gen", "slave_n", " sector_nr", "sector1num", "section_num", "sector_comm", "sectorjdesc", "sector1nom", "sectoritymaster", "sector_nam", "sector_nr", "sector_desc", "sector_number", "tier_tim", "slave9nb", "sector_name", "sector9nb", "sectorNamenum", "sectoritynam", "sector9Num", "sectorNameNUM", "sector1name", "sector1Num", "slave9n", "section_number", "sector_mun", "iter_NUM", "sectoritytim", "sector1nr", " sector_nom", "sector_nom", "sector1na", "iterNamecomm", "sector_gen", " sector_master", "sector9num", "sector2num", "sector9gen", "section_mon", " sector_number", "sector_net", "sectorNamecomm", "sector_na", "sector_nb", "slave9mun", "section_Num", "iter_na", "slave9num", "sector1number", "slave_num", "sector_tim", "sectoritygen", "iter_num", "sectoritynet", "sectorjnom", "iterNamenum", "sectoritynum", "sector_mon", " sector_Num", "sectorjnumber", "sectorityNum", "iterNamena", "sector_master", "sector_NUM", "sector2mon", " sector_name", "tier_nam", " sector_desc", "sector_Num", "sector_n", "iterNameNUM", "sector9master", "sector1comm", "sector1NUM", "sector9mun", "sectorjnum", "sector9n", "slave_nb", "sector2number", "sector2Num"], "nb_sectors": ["nb_seors", "nb_vections", "nb_speriers", "nb_segments", "nb_gectors", "nb_veivers", "nb_shgments", "nb_seurers", "nb_mevers", "nb_peors", "nb_temctors", "nb_spectors", "nb_sukers", "nb_veims", "nb_geors", "nb_sesivers", "nb_veurers", "nb_gegments", "nb_begments", "nb_shctors", "nb_meors", "nb_sourceors", "nb_temivers", "nb_beors", "nb_sekers", "nb_geicas", "nb_suors", "nb_seivers", "nb_speors", "nb_shors", "nb_sourcectors", "nb_vekers", "nb_mectors", "nb_veors", "nb_sesriers", "nb_sesgments", "nb_mections", "nb_vevers", "nb_sesims", "nb_suctors", "nb_temims", "nb_severs", "nb_shurers", "nb_seriers", "nb_pections", "nb_vegments", "nb_sykers", "nb_syctors", "nb_vectors", "nb_sourcegments", "nb_sections", "nb_bectors", "nb_beicas", "nb_spegments", "nb_veriers", "nb_seims", "nb_sesors", "nb_sesctors", "nb_pevers", "nb_sourceurers", "nb_temors", "nb_seicas", "nb_pectors", "nb_suvers", "nb_syvers", "nb_veicas", "nb_syors"], "max_discard": ["max_decARD", "max_Discard", "max_subard", "max_regards", "max_disount", "max_discards", "max_disards", "max_decarded", "max_iscard", "max_Discount", "max2discarded", "max_Discards", "max_disord", "max_discord", "max_discARD", "max_discount", "max_disard", "max2iscarded", "max_disment", "max_dcart", "max2discARD", "max_destard", "max_decard", "max_discment", "max_destment", "max_discarded", "max_subment", "max_subordon", "max_dcarded", "max_decord", "max_destount", "max_Discarded", "max_disarded", "max_Discord", "max_subarded", "max_discordon", "max_iscarded", "max_discuster", "max_diffart", "max2iscart", "max_diffARD", "max_dcard", "max_DiscARD", "max_Discuster", "max2iscARD", "max2discard", "max_discart", "max_disad", "max_iscart", "max_decards", "max_decment", "max_disart", "max_Discad", "max_decuster", "max_regard", "max_discad", "max_diffard", "max_destart", "max_Discart", "max2iscard", "max_regad", "max_Discordon", "max_Discment", "max_dcARD", "max2discart", "max_disordon", "max_iscARD", "max_diffarded", "max_regord"], "ret": ["mem", "rm", "nt", "res", "arr", "t", "back", "flag", "ter", "num", "result", "Ret", "ry", "err", "ne", "rt", "gc", "arg", "empty", "tmp", "tree", "tr", "mt", "nz", "out", "reg", "failed", "Return", "inter", "iter", "get", "progress", "ft", " Ret", "rem", "RET", "reset", "re", "det", "ext", "try", "att", "lit", "ref", "r", "local", "val", "new", "def", "print", "pas", "fi", "alt", "del", "got", "x", "len", "resp", "rest", "not", "gt", "url", "elt", "red", "rets"], "acb": ["acB", "acv", "ancbd", "acsb", "ancb", "acaB", "acbd", "acerB", "aconbd", "acbt", "abcb", "fcb", " acbl", "fcsb", "aconbl", "acerb", "acerbc", "abcB", "acabc", "acabt", "acerbt", "bcb", " acbc", "acbl", "bcv", "abcbl", "acab", "bcsb", " acbt", "abcbd", "ancsb", "fcv", " acbd", "ancv", "aconb", "acbc", "bcbd", " acB", "fcbd", "aconB"]}}
{"project": "qemu", "commit_id": "aff3f0f150769ec4f97c6e2cefe91c4a0377b548", "target": 0, "func": "static void xlnx_ep108_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"Xilinx ZynqMP EP108 board\";\n\n    mc->init = xlnx_ep108_init;\n\n    mc->block_default_type = IF_IDE;\n\n    mc->units_per_default_bus = 1;\n\n    mc->ignore_memory_transaction_failures = true;\n\n}\n", "idx": 17043, "substitutes": {"mc": ["bm", "ic", "mac", "tc", "nic", "ci", "disc", "mm", "oc", "colm", "isc", "md", "cn", "ml", "pc", "MC", "gc", "cf", "mr", "mn", "Mc", "tic", "bc", "cc", "cci", "cca", "co", "mt", "ns", "mic", "mi", "c", "mx", "mp", "mot", "coat", "mk", "cmp", "lc", "cm", "dc", "fc", "tm", "nc", "anc", "cms", "cp", "icc", "ms", "ac", "mint", "m"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,\n\n                             TCGReg rd, TCGReg rn, uint64_t limm)\n\n{\n\n    unsigned h, l, r, c;\n\n\n\n    assert(is_limm(limm));\n\n\n\n    h = clz64(limm);\n\n    l = ctz64(limm);\n\n    if (l == 0) {\n\n        r = 0;                  /* form 0....01....1 */\n\n        c = ctz64(~limm) - 1;\n\n        if (h == 0) {\n\n            r = clz64(~limm);   /* form 1..10..01..1 */\n\n            c += r;\n\n        }\n\n    } else {\n\n        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */\n\n        c = r - h - 1;\n\n    }\n\n    if (ext == TCG_TYPE_I32) {\n\n        r &= 31;\n\n        c &= 31;\n\n    }\n\n\n\n    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);\n\n}\n", "idx": 17048, "substitutes": {"s": ["ds", "cs", "t", "w", "p", "sb", "aws", "q", "ctx", "is", "e", "g", "rs", "gs", "S", "ss", "d", "ns", "v", "sts", "ps", "js", "es", "n", "fs", "ts", "x", "ains", "ex", "sc", "b", "m"], "insn": ["inne", "linsn", "linsne", "inssn", "tsn", " inssn", "tssn", " insne", "linsgn", "csne", "csgn", "cssn", "tsne", " statsn", "csn", " statssn", " insgn", "insgn", "ingn", " statsgn", "linssn", " statsne", "inn", "insne", "tsgn"], "ext": ["init", "eng", "Ext", "t", "format", "opt", "tx", "desc", "xt", "ec", "enc", "err", "end", "ret", "ect", "cur", "config", "xp", "tif", "tr", "ct", "out", "EXT", "ch", "alg", "v", "ox", "tf", "ptr", "obj", "inter", "class", "ef", "typ", "esp", "rev", "cmd", "ind", "req", "ref", "external", "new", "et", "def", "str", "extra", "act", "aux", "yt", "txt", "x", "qt", "ex", "text", "prot", "type"], "rd": ["rm", "ds", "rob", "ra", "rx", "rw", "kr", "RD", "hr", "rt", "ru", "ri", "fr", "mr", "rs", "rr", "d", "orn", "dr", "rar", "cr", "rid", "rog", "rg", "ird", "erd", "rb", "ld", "nd", "rh", "ro", "rc", "rf", "red", "lr", "rl"], "rn": ["rm", "cv", "ra", " fr", "dn", "cn", "rx", "rw", "rt", "mr", "RN", "rr", "rov", "reg", "orn", "rar", " rh", "re", "nl", "cr", " intr", "drm", "rog", "rg", "rb", " re", "ld", "roc", "nd", "rh", "ro", "rc", "vr", "rf", "lr", "rl", " rm"], "limm": ["Limdm", "lammt", "limr", " limM", "commt", "limmi", "locmt", "temM", "plmn", "limn", "limkm", " limn", " slimpm", "plmt", " limitm", "lamms", "gemm", "profmt", "comm", " limmi", "limms", "milpm", "sammn", " limr", "limgm", " limitM", "limmn", "dimm", " limitkm", "lamm", " limgm", "ligms", "lammn", "limmt", "gemM", "dimM", "profmn", "miln", "milm", " slimmi", "temm", "limcm", "Limm", "sammt", "milmi", " limpm", "loccm", "locdm", " slimn", "limM", " slimm", "ligmn", "samms", "ligmt", " slimkm", "gemgm", "Limmt", "Limcm", " limitmi", "temkm", "profms", " slimM", "ligm", "gemr", "dimr", "comdm", "plms", "comcm", "plm", "temmi", "limdm", "profm", "locm", "limpm", "dimgm", "samm"], "h": ["hs", "ho", "z", "oh", "hh", "t", "w", "hl", "hi", "i", "sh", "p", "kh", "he", "th", "ir", "ha", "bh", "q", "hr", "hd", "g", "ht", "u", "phi", "ch", "d", "v", "k", "dr", "H", "ih", "hm", "j", "L", "high", "ph", "n", "dh", "x", "rh", "f", "ah", "hal", "y", "m"], "l": ["lp", "lv", "ly", "loc", "el", "z", "hl", "i", "p", "ml", "ll", "li", "le", "lu", "g", "il", "u", "d", "ln", "v", "lt", "nl", "lit", "j", "L", "lc", "n", "lo", "ls", "pl", "lang", "ld", "len", "sl", "b", "lin", "lr", "lb", "m"], "r": ["a", "br", "rm", "res", "ur", "z", "w", "pr", "i", "p", "rx", "err", "ar", "q", "hr", "rt", "e", "g", "mr", "rs", "u", "rr", "rec", "d", "v", "k", "dr", "rar", "range", "re", "cr", "j", "n", "R", "rb", "er", "x", "sr", "ro", "nr", "rc", "vr", "f", "b", "red", "lr", "rl", "m"], "c": ["con", "cv", "cs", "tc", "ca", "z", "t", "ci", "i", "p", "mc", "cn", "ec", "pc", "gc", "e", "cl", "g", "cur", "cf", "u", "cut", "cc", "ct", "ch", "bc", "co", "d", "v", "cont", "cr", "cal", "lc", "cm", "dc", "C", "n", "fc", "ce", "cu", "cache", "cb", "com", "cp", "rc", "sc", "col", "m"]}}
{"project": "qemu", "commit_id": "80db0e7822962554c91bef05d784c898e8ab1c3c", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  bool smm_enabled,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,\n\n                      pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->smm_enabled = smm_enabled;\n\n\n\n    pm->enable_tco = true;\n\n    acpi_pm_tco_init(&pm->tco_regs, &pm->io);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    legacy_acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci),\n\n        OBJECT(lpc_pci), &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 17072, "substitutes": {"lpc_pci": ["lpc_dcu", "lpc_propc", "lpc_pcm", "lpc_ppi", "lpc_proci", "lpc_cco", "lpc_mco", "lpc_dpi", "lpc_cmi", "lpc_dpc", "lpc_pce", "lpc_doci", "lpc_lca", "lpc_sci", "lpc_cca", "lpc_lcu", "lpc_mki", "lpc_poci", "lpc_dco", "lpc_ski", "lpc_ipcm", "lpc_pca", "lpc_dca", "lpc_lci", "lpc_coci", "lpc_ccm", "lpc_moci", "lpc_ipce", "lpc_procm", "lpc_dcm", "lpc_pcu", "lpc_pki", "lpc_ippc", "lpc_dci", "lpc_ipcu", "lpc_mcu", "lpc_scm", "lpc_ppc", "lpc_pco", "lpc_cci", "lpc_dki", "lpc_ipci", "lpc_ippi", "lpc_dmi", "lpc_lmi", "lpc_mce", "lpc_mcm", "lpc_sco", "lpc_pmi", "lpc_propi", "lpc_mci", "lpc_dce", "lpc_ccu"], "pm": ["temp", " am", "nom", "am", "px", "test", "cam", "ym", "vp", "mp", "mi", "cm", "module", "pl", "pa", "dem", "dd", "bm", "vim", "pp", "wm", "program", "mr", "tmp", "em", "activity", "pb", "service", "pi", "my", "pt", "mx", "pkg", "json", "dev", "post", "ram", "pn", "po", "rm", "sam", "wp", "mm", "term", "mod", "mt", " npm", "dm", "master", "um", "ami", "nm", "cp", "policy", "process", "m", "imm", "im", "p", "asm", "power", "pc", "gem", "pg", "db", "PM", "vm", "ams", "wd", "rem", "param", "hm", "pool", "prom", "member", "gm", "ms", "rpm"], "smm_enabled": ["smm_available", "smm_en", "smmableenable", "smi_enabled", "smmm_disabled", "smmm_supported", "smmetricavailable", "smm_powered", "smi_available", "smmetricenabled", "smmm_enable", "smmm_enabled", "smi_en", "smmablepowered", "smm_failed", "smm_supported", "smmableenabled", "smmm_powered", "smm_disabled", "smi_failed", "smmetricfailed", "smm_enable", "smmetricen"], "sci_irq": ["sci_irqs", "sci_mirq", "sci_mirck", "sci_prq", "sci_irz", "sci_mirqs", "sci_arq", "sci_arck", "sci_prqs", "sci_pirQ", "sci_arqs", "sci_irQ", "sci_mrqs", "sci_mrQ", "sci_mrz", "sci_mrck", "sci_prQ", "sci_prz", "sci_pirz", "sci_pirq", "sci_pirqs", "sci_irck", "sci_mrq"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void handle_sys(DisasContext *s, uint32_t insn, bool isread,\n\n                       unsigned int op0, unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    const ARMCPRegInfo *ri;\n\n    TCGv_i64 tcg_rt;\n\n\n\n    ri = get_arm_cp_reginfo(s->cp_regs,\n\n                            ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP,\n\n                                               crn, crm, op0, op1, op2));\n\n\n\n    if (!ri) {\n\n        /* Unknown register; this might be a guest error or a QEMU\n\n         * unimplemented feature.\n\n         */\n\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch64 \"\n\n                      \"system register op0:%d op1:%d crn:%d crm:%d op2:%d\\n\",\n\n                      isread ? \"read\" : \"write\", op0, op1, crn, crm, op2);\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    /* Check access permissions */\n\n    if (!cp_access_ok(s->current_el, ri, isread)) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (ri->accessfn) {\n\n        /* Emit code to perform further access permissions checks at\n\n         * runtime; this may result in an exception.\n\n         */\n\n        TCGv_ptr tmpptr;\n\n        TCGv_i32 tcg_syn;\n\n        uint32_t syndrome;\n\n\n\n        gen_a64_set_pc_im(s->pc - 4);\n\n        tmpptr = tcg_const_ptr(ri);\n\n        syndrome = syn_aa64_sysregtrap(op0, op1, op2, crn, crm, rt, isread);\n\n        tcg_syn = tcg_const_i32(syndrome);\n\n        gen_helper_access_check_cp_reg(cpu_env, tmpptr, tcg_syn);\n\n        tcg_temp_free_ptr(tmpptr);\n\n        tcg_temp_free_i32(tcg_syn);\n\n    }\n\n\n\n    /* Handle special cases first */\n\n    switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n\n    case ARM_CP_NOP:\n\n        return;\n\n    case ARM_CP_NZCV:\n\n        tcg_rt = cpu_reg(s, rt);\n\n        if (isread) {\n\n            gen_get_nzcv(tcg_rt);\n\n        } else {\n\n            gen_set_nzcv(tcg_rt);\n\n        }\n\n        return;\n\n    case ARM_CP_CURRENTEL:\n\n        /* Reads as current EL value from pstate, which is\n\n         * guaranteed to be constant by the tb flags.\n\n         */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        tcg_gen_movi_i64(tcg_rt, s->current_el << 2);\n\n        return;\n\n    case ARM_CP_DC_ZVA:\n\n        /* Writes clear the aligned block of memory which rt points into. */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        gen_helper_dc_zva(cpu_env, tcg_rt);\n\n        return;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        gen_io_start();\n\n    }\n\n\n\n    tcg_rt = cpu_reg(s, rt);\n\n\n\n    if (isread) {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            tcg_gen_movi_i64(tcg_rt, ri->resetvalue);\n\n        } else if (ri->readfn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_get_cp_reg64(tcg_rt, cpu_env, tmpptr);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_ld_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    } else {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            /* If not forbidden by access permissions, treat as WI */\n\n            return;\n\n        } else if (ri->writefn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_set_cp_reg64(cpu_env, tmpptr, tcg_rt);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_st_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        /* I/O operations must end the TB here (whether read or write) */\n\n        gen_io_end();\n\n        s->is_jmp = DISAS_UPDATE;\n\n    } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n\n        /* We default to ending the TB on a coprocessor register write,\n\n         * but allow this to be suppressed by the register definition\n\n         * (usually only necessary to work around guest bugs).\n\n         */\n\n        s->is_jmp = DISAS_UPDATE;\n\n    }\n\n}\n", "idx": 17082, "substitutes": {"s": ["a", "ies", "hs", "ds", "cs", "os", "scl", "t", "i", "p", "sb", "as", "ses", "ins", "changes", "sq", "h", "sm", "ctx", "is", "e", "south", "sv", "rs", "gs", "S", "ss", "sw", "ns", "v", "sts", "ties", "ps", "sys", "js", "c", "j", "es", "ats", "r", "n", "fs", "ts", "ls", "ains", "an", "stats", "ms", "serv", "sc", "y", "its", "m"], "insn": ["nsnv", "nsn", "arsc", "rsc", "rsnv", "rsn", "rsnw", "arsnw", "nsc", "insnv", "arsn", "arsnv", "insc", "insnw", "nsnw"], "isread": ["Iswrite", " isreader", "isreader", " isRead", "Isreadable", "isfreading", " isreading", "misreading", "iREAD", "iwrite", "isfreadable", "isfread", "isfwrite", "iread", " indiswrite", "ISread", "bisreadable", "iswrite", "tisreadable", " indisRead", "ireader", " isreadable", "bisread", "isreading", "Isread", "isREAD", "misread", "ISreader", "bisreader", "ISreadable", "isRead", " isREAD", " iswrite", "Isreader", "tisreader", "tiswrite", "tisread", " indisread", "ISwrite", "miswrite", "IsRead", "IsREAD", " indisreadable", "isreadable", "misreadable"], "op0": ["oper0", "rop25", "top1", "OP0", "hop2", "op25", "tip1", "op5", "op02", "oper5", "OP00", "hop00", " op25", "cop00", "oper00", "hop0", "OP25", "op00", " op00", "tip0", "tip02", "cop5", "hop1", "rop0", "OP2", "rop2", "rop1", "cop0", "oper02", "top5", "OP1", "top00", "top0", "oper1", "cop1", " op02"], "op1": ["top1", "pop0", "OP16", "top16", "oom01", "pop01", "oom16", "op3", "OP01", "opp3", "oom2", " op3", "pop3", "opp01", "iop1", "op01", "op51", "opp0", "top01", " op51", "opp51", "iop51", "OP2", " op01", "top2", "oom1", "opp2", "op16", "pop2", "iop3", "OP1", "iop0", "pop1", "opp1"], "op2": ["oper0", "OP0", "pop0", " op4", "op3", "pop02", "op4", "Op2", "hop2", "hop4", "op02", "ops4", " op3", "hop3", " op6", "oper2", "Op3", "Op6", "oper6", "OP02", "ops2", "OP6", "OP3", "oop4", "OP2", "hop02", "oop3", "ops02", "oop2", "pop2", "oper3", "OP1", "op6", "oop6", "ops3", "Op4", "pop1", " op02"], "crn": ["prn", "CrN", "cyl", " crN", "cyns", "prw", "rcm", "prns", "crns", "trns", "crl", "crnt", "trn", " crns", " crw", "rcnt", "ocrm", "rcn", "ocrw", "rcN", "ctrn", "Crn", "Crm", "crN", " crg", "ocrns", "ctrl", "crg", "ctrns", "prm", "Crg", "trm", "cym", "rcg", "ocrn", "trl", "crw", "cyn", "ctrm", "rcns", "ocrnt", " crnt"], "crm": ["prn", "crpm", "Crr", "prml", "crl", "crmt", "ocrl", "Crnm", "chenm", "cher", " crpm", "prmt", "prpm", " crmt", "sprn", "sprml", "ocrm", " crmn", "solm", "crv", "solv", "prv", "sprm", "prl", "Crm", "crml", "solpm", " crr", "Crmn", " crl", "prm", " crnm", "crmn", " crv", "crnm", "ocrn", " crml", "chemn", "ocrmt", "soln", "crr", "chem"], "rt": ["rm", "irt", "tri", "nt", "tc", "t", "tx", "dt", "vt", "rx", "rw", "ctx", "ret", "rs", "rin", "rr", "wt", "mt", "ct", "rec", "reg", "ptr", "sys", "addr", "rd", "pt", "rot", "r", "rid", "ti", "rb", "RT", "tm", "rat", "sr", "rn", "ro", "rc", "tt", "vr", "it", "src", "rf", "rl"], "ri": ["vi", "tri", "rob", "ico", "si", "ara", "ci", "ra", "i", "hi", "rise", "ki", "rir", "rx", "ir", "ry", "li", "ru", "ati", "rik", "adr", "rom", "reci", "ni", "rin", "ai", "udi", "co", "ric", "iro", "RI", "io", "di", "uti", "mi", "pi", "via", "ria", "iri", "re", "xi", "rid", "ti", "rip", "rio", "wi", "uri", "fi", "stri", "cu", "ini", "ro", "ris", "rf", "rie", "ii"], "tcg_rt": ["tcG_rl", "tcg_addr", "tcg_vr", "tcgi_rel", "tcg_rn", "tcG_fr", "tcgi__vr", "tcge_rt", "tcg__RT", "tcG__tx", "tcfg_rn", "tcG__rt", "tcg___rt", "tcge_RT", "tcg_tx", "tcg_rec", "tcg__tx", "tcgi__RT", "tcg__fr", "tcfg_rt", "tcg_fr", "tcg__rel", "tcgi__rt", "tcg__rt", "tcgi_vr", "tcg__rl", "tcg_RT", "tcg_rl", "tcge_addr", "tcG__fr", "tcfg_rec", "tcgi_rt", "tcg___rl", "tcg_rel", "tcG_rt", "tcg___tx", "tcgi_RT", "tcfg_vt", "tcgi__rel", "tcg__vr", "tcg_vt", "tcG_tx", "tcG__rl", "tcg___fr", "tcg_pt", "tcge_pt"], "tmpptr": ["tmippt", "tmppstr", "tmmkmt", "tmpstr", "htmippt", "simPPptr", "tmPPptr", "tmmppr", "tmpxvr", " tempptr", "tmpxt", "tcppTR", "simppdr", "tmpxTr", "tmppdr", "tmmpgr", "tmptTR", "tmPPgr", "tmippptr", " temppTr", "htmppvr", "tmipptr", "tmPPpr", "tmpxpr", " tempxpr", "tmppsTR", "tmippvr", "tmmktr", "tmmpptr", "tmmptr", "simpptr", "tmppsmt", "tmpxtr", "tcppsth", "htmipptr", "simppt", "tmppTr", "htmppt", "tmPPTr", "tmpsTR", "tmpxTR", "tmmpt", "tmpttr", "tmmpdr", "tcppstr", "tcppmt", " tempppr", "tmmpTr", "tcpptr", "htmippvr", "tmippdr", "tmppmt", "tmppth", "simppptr", " temppgr", "tmptvr", "tmppTR", "simPPdr", "tcppth", "tmppgr", "tmmkth", "tmPPdr", " tempxTr", "tmPPt", "tmptt", "tmppt", "simPPtr", "tmPPtr", "tmpxgr", "simPPt", " tempxtr", "tmpsth", "tmppvr", "tmmkTR", "tmpsmt", "tcppsmt", "tmppptr", " tempxgr", "tmippTR", "tcppsTR", "tmppsth", "htmpptr", "tmpppr", "htmippTR", "htmppTR"], "tcg_syn": ["tcg____sy", "tcsg_trans", "tcog_rec", "tcg_trans", "tcmg_syn", "tcmg___yn", "tcg___win", "tcmg___syn", "tcsg_icon", "tcmg___mn", "tcgb_sy", "tcg_mn", "tcsg___syn", "tcg___trans", "tcg_icon", "tcg_win", "tcg___yn", "tcg_rec", "tcg____sim", "tcgb____syn", "tcog_chron", "tcsg_syn", "tcg___mn", "tcsg___win", "tcgb_sn", "tcmg___sym", "tcgb_sim", "tcg____sn", "tcmg_yn", "tcmg_sym", "tcsg___trans", "tcog_sim", "tcg_sim", "tcg_sy", "tcg___icon", "tcg_sym", "tcog_syn", "tcgb____sy", "tcsg___icon", "tcg___sym", "tcgb____sim", "tcg____syn", "tcg_yn", "tcmg_mn", "tcgb_syn", "tcg_sn", "tcsg_win", "tcgb____sn", "tcg_chron", "tcg___syn"], "syndrome": ["Syddrom", "cyntrone", "Syntrome", "syundroma", "cyntrom", "syndrom", "cyntrome", "syddropy", "syntrome", "Syddrome", "sycondrom", "Syndrome", "syddrace", "symdolor", "cyndropy", "syrdolor", "syundrom", "syddrom", "syrdrom", "sycondrome", "Syndolor", "syrdrome", "syntroma", "symdroma", "Syntrom", "Syntroma", "syntrone", "sycondrone", "Syddroma", "syndropy", "Syndrom", "syndrace", "syddrone", "syntrace", "syrdroma", "syddroma", "Syntolor", "syntropy", "syndroma", "Syndroma", "cyndrone", "syndolor", "syntolor", "syndrone", "cyntropy", "syntrom", "symdrom", "syddrome", "cyndrome", "Syddrace", "syundrace", "Syndrace", "cyndrom", "syundrome", "sycondropy", "symdrome"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    return visitor_input_test_init_internal(data, json_string, NULL);\n\n}\n", "idx": 17085, "substitutes": {"data": ["window", "valid", "input", "zero", "device", "with", "normal", "ata", "map", "load", "initial", "dat", "group", "image", "accept", "partial", "DATA", "session", "d", "mu", "Data", "db", "read", "reader", "da", "json", "batch", "join", "table", "raw", "def", "state", "cache", "info", "block", "from", "entry"], "json_string": ["json1data", "son_format", "json_format", "jsonitystring", "jsonityformat", " json_component", "json_str", "son_string", "son_data", "json_data", " json_String", "json_component", "jsonletstring", "son_block", "jsonletcomponent", " json_str", "json1format", "jsonitydata", "json_String", "json1block", "json_block", "jsonletString", "json1string", "jsonletstr", "jsonityblock"]}}
{"project": "qemu", "commit_id": "4a19f1eced611e7c3a0fba07d13515cbc73da09f", "target": 0, "func": "static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n", "idx": 17092, "substitutes": {"mon": ["Mon", "mons", "sam", "MON", "san", "mm", "dis", "ran", "tem", "mitter", "dat", "mos", "mn", "ann", "mt", "mat", "mun", "monitor", "mi", "mont", "wat", "admin", "dm", "den", "pers", "met", "dom", "cond", "jon", "mill", "ston", "sim", "an", "demon", "mut", "meter", "dem", "man"]}}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}", "idx": 17101, "substitutes": {"ivgen": ["iverstore", "IVmsg", "iverdef", "ivGen", "ivergeneration", " ivmsg", "iveconfig", "ivgate", "ivergate", "actdef", "ivegener", "ivestore", "ivbuild", "actconfig", "IVgeneration", "evgd", "ivemsg", "iverget", " ivgeneration", "ivgeneration", "IVbuild", " ivGen", "ivconfig", "evgen", "ivdef", "actgener", "ivegd", "ivergener", "ivedef", "evlen", "ivegen", "IVgen", "ivergen", "iverrange", "iverGen", "ivgener", "ivstore", "ivegeneration", "iveGen", "evgener", " ivgener", "ivget", "actgen", "iverconfig", "iverbuild", "ivegate", " ivgd", " ivstore", " ivrange", "ivlen", "iverange", "ivrange", "actgeneration", " ivgate", "ivmsg", "ivermsg", "actget", " ivbuild", " ivlen", "iveget", "ivelen", "ivgd"], "key": ["a", "check", "air", "mac", "seed", "box", "sk", "i", "Key", "p", "query", "hash", "ke", "ice", "ey", "password", "name", "ch", "v", "k", "keys", "ip", "iv", "ay", "data", "id", "mk", "et", "icon", "pair", "act", "source", "x", "by", "chain", "y", "KEY", "ek"], "nkey": ["NKey", "pnmix", "pnhash", "ynmix", "nKey", "nmix", "ntime", "ynkey", "Nhash", "snKey", "niv", " nmix", "yniv", "snhash", " nKey", " ntime", "Ntime", "pniv", "pnkey", " niv", "ynhash", "sntime", "snkey", "Nkey"], "errp": ["errh", "errps", " errr", " errpa", " erp", "errorp", "errorpp", "errorP", "eorps", " errpp", " errping", "eorr", "lerpc", " erping", "errorh", "errorpc", "errpa", "erp", "lerr", "errr", "errpc", " errpc", "errpp", "erps", " errps", "eorp", "errping", " errh", "eorpa", "errorr", " erP", "errP", "lerpp", " erh", "lerp", "erpa", " errP", "errorping", "err"], "salt": ["sodium", "nsiv", "nsALT", "sref", "asodium", " sALT", "asalt", "asiv", "Salt", "nsref", " sref", "nsall", " sodium", "nsig", " salted", "ssalt", "ssalted", "ssamp", " sig", " sall", " samp", "ssodium", "Sref", "sall", " siv", "salted", "SALT", "siv", "Sass", "sALT", "asALT", "sass", "sig", "samp", "nsodium", " sass", "nsass"], "nhash": [" nh", "cnmac", "nusearch", "Nh", "dsum", "Nhandle", "nuhash", "dhash", "nsum", "snHash", "ckey", "snmessage", "onhash", "onh", "dmessage", "cnkey", "cnmessage", "Nfilter", "nuHash", "nchash", "nukey", "ncmac", "dhex", "csum", "nh", "dkey", "onkey", "mhash", "nhex", "Nhash", "numac", "ntrust", "Ntrust", "cnhash", "dmac", " nsum", "NHash", "nfilter", "msearch", "nHash", "nhandle", "snhash", " nhex", "mkey", "mmac", "onhandle", "chash", "nmessage", "nufilter", "nsearch", "nckey", "nmac", "snkey", "Nkey", "ncsearch", "nutrust", "snmac", "sntrust", " nhandle", "chex", "snfilter"], "nsalt": [" nsplain", "nasash", "nisnum", "nsal", "NSash", "nasort", "nasole", "namesalted", "stsplain", "netsort", "nasalt", "nishot", "nisalt", "namesalt", "NSalt", "nsig", "nisalted", "stsalt", " nsalted", "nasul", " nsash", "namesnum", " nsal", " nshot", "unsplain", "netsul", "nsort", " nsig", "stsig", "nsole", "unsalt", "nsnum", " nsul", "nsash", "nasalted", "nameshot", " nsort", "NSalted", " nsnum", "netsole", " nsole", "unsal", "netsalt", "nshot", "unsig", "nsalted", "nsplain", "nsul", "stsal", "NSole"], "essiv": ["ssistor", "ccessiver", "essij", "hessij", "assiv", "cessistor", "ossiver", "assij", "ensiv", "ensiver", "ccessiv", "essesistor", "ossive", "ssive", "essiov", "cessiver", "ensvv", "esive", "ccessive", "essesiv", "essediv", "hessiov", "essesiver", "ossiva", "accessiv", "esiv", " essiver", "cessiv", "cessive", " essive", "ossiv", "hessiv", "essesive", "hessiver", "ccessistor", "accessivation", "essediver", "essedivation", "essistor", "ensivation", "ssiver", "hessive", "accessvv", "esistor", "essediov", "hessistor", "essedvv", "ssiva", "essiva", "ensive", "ensiva", " essiva", "essvv", "essivation", "essedij", "ssiv", "essiver", "assiov", "accessiver", "esiver", "cessiva", "assiver", "essive"]}}
{"project": "FFmpeg", "commit_id": "bb6f51aeab88a252cf08f5a0ec26ab41ae2d74a2", "target": 1, "func": "static void mpeg1_encode_sequence_header(MpegEncContext *s)\n\n{\n\n        unsigned int vbv_buffer_size;\n\n        unsigned int fps, v;\n\n        int n;\n\n        UINT64 time_code;\n\n        \n\n        if ((s->picture_number % s->gop_size) == 0) {\n\n            /* mpeg1 header repeated every gop */\n\n            put_header(s, SEQ_START_CODE);\n\n            \n\n            /* search closest frame rate */\n\n            {\n\n                int i, dmin, d;\n\n                s->frame_rate_index = 0;\n\n                dmin = 0x7fffffff;\n\n                for(i=1;i<9;i++) {\n\n                    d = abs(s->frame_rate - frame_rate_tab[i]);\n\n                    if (d < dmin) {\n\n                        dmin = d;\n\n                        s->frame_rate_index = i;\n\n                    }\n\n                }\n\n            }\n\n \n\n            put_bits(&s->pb, 12, s->width);\n\n            put_bits(&s->pb, 12, s->height);\n\n            put_bits(&s->pb, 4, 1); /* 1/1 aspect ratio */\n\n            put_bits(&s->pb, 4, s->frame_rate_index);\n\n            v = s->bit_rate / 400;\n\n            if (v > 0x3ffff)\n\n                v = 0x3ffff;\n\n            put_bits(&s->pb, 18, v);\n\n            put_bits(&s->pb, 1, 1); /* marker */\n\n            /* vbv buffer size: slightly greater than an I frame. We add\n\n               some margin just in case */\n\n            vbv_buffer_size = (3 * s->I_frame_bits) / (2 * 8);\n\n            put_bits(&s->pb, 10, (vbv_buffer_size + 16383) / 16384); \n\n            put_bits(&s->pb, 1, 1); /* constrained parameter flag */\n\n            put_bits(&s->pb, 1, 0); /* no custom intra matrix */\n\n            put_bits(&s->pb, 1, 0); /* no custom non intra matrix */\n\n\n\n            put_header(s, GOP_START_CODE);\n\n            put_bits(&s->pb, 1, 0); /* do drop frame */\n\n            /* time code : we must convert from the real frame rate to a\n\n               fake mpeg frame rate in case of low frame rate */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            time_code = s->fake_picture_number * FRAME_RATE_BASE;\n\n            s->gop_picture_number = s->fake_picture_number;\n\n            put_bits(&s->pb, 5, (UINT32)((time_code / (fps * 3600)) % 24));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / (fps * 60)) % 60));\n\n            put_bits(&s->pb, 1, 1);\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / fps) % 60));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code % fps) / FRAME_RATE_BASE));\n\n            put_bits(&s->pb, 1, 1); /* closed gop */\n\n            put_bits(&s->pb, 1, 0); /* broken link */\n\n        }\n\n\n\n        if (s->frame_rate < (24 * FRAME_RATE_BASE) && s->picture_number > 0) {\n\n            /* insert empty P pictures to slow down to the desired\n\n               frame rate. Each fake pictures takes about 20 bytes */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            n = ((s->picture_number * fps) / s->frame_rate) - 1;\n\n            while (s->fake_picture_number < n) {\n\n                mpeg1_skip_picture(s, s->fake_picture_number - \n\n                                   s->gop_picture_number); \n\n                s->fake_picture_number++;\n\n            }\n\n\n\n        }\n\n        s->fake_picture_number++;\n\n}\n", "idx": 17113, "substitutes": {"s": ["sg", "details", "results", "ches", "rs", "vs", "se", "self", "sys", "ants", "c", "es", "comm", "fs", "er", "params", "spec", "sis", "os", "ops", "t", "settings", "events", "qs", "S", "ss", "sts", "ps", "xs", "my", "ts", "ls", "parts", "ains", "stats", "bis", "eds", "comments", "a", "ies", "ds", "cs", "l", "w", "sb", "as", "ses", "changes", "als", "sv", "sw", "js", "an", "tests", "y", "m", "hs", "args", "p", "ins", "ers", "sq", "aws", "h", "is", "bs", "gs", "ports", "ns", "sports", "tes", "pers", "ats", "r", "eps", "less", "ims", "ms", "search", "us", "sql", "conf", "its"], "vbv_buffer_size": ["vbv_buffer_Size", "vbv_buffer_number", "vbv_Buffer_size", "vbv_buffer_length", "vbv_Buffer_SIZE", "vbv_Buffer_length", "vbv_buffer_SIZE", "vbv_Buffer_Size"], "fps": ["frame", "res", "px", "bits", "mins", "flags", "rates", "pps", "hz", "frames", "html", "bps", "base", "bs", "vals", "pins", "points", "vp", "xp", "ips", "amps", "ports", "ns", "bytes", "vs", "Mbps", "aps", "ps", "js", "ats", "Hz", "eps", "fs", "ints", "ts", "faces", "ims", "ls", "f", "ms", "fp", "iles", "photos", "seconds", "its", " frames"], "v": ["vi", "cv", "lv", "ov", "l", "qv", "t", "w", "bits", "wire", "p", "vt", "h", "q", "va", "nv", "html", "av", "g", "sv", "vp", "u", "vc", "conv", "all", "uv", "vs", "ve", "value", "iv", "rev", "inv", "j", "dev", "r", "ev", "version", "val", "V", "current", "o", "x", "mint", "vo", "vv", "vol", "ver", "vr", "vid", "f", "it", "tv", "b", "y", "m"], "n": ["na", " N", "l", "z", " len", "t", "p", "ne", "e", "g", "ni", "name", "ns", "nn", " ns", "Ns", " fn", "o", "N", "nan", "nm", "x", " nan", " ni", " m", "no", "f", "b"], "time_code": ["time_count", "time_Code", "time67code", "time_page", "Time_page", "Time_code", "timelycode", "time2codes", " time_count", "time67count", " time2Code", "timelyCode", "Time_number", " time_codes", " time_Code", " time2code", "Time_Code", "time2Code", "time_rate", "time2code", "time_codes", " time2count", "timelynumber", "timelypage", " time_rate", "time67Code", "time_number", "time2count", "time2rate"], "i": ["init", "ic", "index", "l", "si", "t", "ci", "im", "p", "hi", "qi", "me", "q", "li", "is", "\u0438", "point", "I", " ii", "ai", "phi", "di", "iter", "ip", "mi", "pi", "my", "ind", " j", "id", "j", "oi", "xi", "ti", "ui", "batch", "gi", "print", "ji", "multi", "uri", "fi", "bi", "x", " x", "ims", "info", "zi", "ini", "sim", "ie", "us", "ix", "it", "ms", "iu", "y", "ii", "m"], "dmin": ["dmid", "Dminute", " dmins", "dminute", " dminimum", "Dmin", " dmax", "dcmin", " donly", "Dm", "dmax", "Dmax", "ponly", " dMin", "dcmax", "adMin", "djm", "djmin", "pMin", "djMin", "dminimum", "admin", "dm", "Donly", " dminute", "dMin", "Dminimum", "Dmid", "Dmins", "djmins", " dmid", "adminute", "dmins", "dcMin", "dcmid", "DMin", "pminimum", " dm", "pmin", "donly"], "d": ["ds", "fd", "dp", "l", "t", "deg", "de", "dist", "p", "dt", "dj", "dn", "md", "dL", "dot", "delay", "g", "dq", "dat", "dl", "done", "bd", "des", "db", "di", "cd", "da", "dr", "sd", "dig", "ind", "dm", "dev", "min", "pd", "dom", "dos", "def", "diff", "D", "dy", "digit", "du", "df", "dim", "del", "dh", "day", "did", "f", "ded", "dra", "dd", "m"], "fake_picture_number": ["fake_picture_no", "fake_photo_no", "fake_picture_num", "fake_picture__code", "fake_picture__no", "fake_picture__name", "fake_picture_code", "fake_photo_num", "fake_picture__num", "fake_photo_code", "fake_picture__number", "fake_picture_name", "fake_photo_name", "fake_photo_number"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src + stride - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n", "idx": 17118, "substitutes": {"dst": ["ddest", "dsv", "fdst", " dest", "dssrc", "dv", "fdest", "rdest", "dsest", "Dst", "dsst", "Dv", "fddest", "rst", " ddest", "fdpt", "dpt", "dsrc", "Dest", "rpt", "Dsrc", " dv", " dpt", "rest", " dsrc", "dest"], "src": ["loc", "ur", "sl", "dist", "img", "sb", "ins", "st", "input", "sq", "uint", "rt", "cur", "usc", "dq", "rs", "cc", "sec", "start", "ptr", "cont", "supp", "iv", "sys", "sn", "RC", "addr", "req", "in", "ind", "inner", "inst", "r", "str", "now", "source", "txt", "sr", "gin", "s", "rc", "urg", "comp", "ctr", "sc", "b", "dest", "ser", "rl", "hl"], "stride": ["STRime", "STRiding", "slride", " strid", "streamipe", " strime", "Strend", "constime", " strride", "tride", " strange", "slime", "strend", "constider", " striding", "STRides", "slipe", "STRid", "privide", "strider", "Strride", " strider", "strange", "privange", " strides", "STRride", "STRide", "trid", "strime", "striding", "constide", "strid", " strend", "dride", "stripe", "streamride", "prividing", "privride", " stripe", "drime", "dripe", "streamend", "drride", "slide", "trides", "Stride", "STRider", "trider", "streamide", "strides", "strride", "Stripe", "STRange", "constride"]}}
{"project": "FFmpeg", "commit_id": "57cd2f7777a316a447301a7d4b5d1c01da200661", "target": 0, "func": "static av_cold int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, h264_id, mps_id, ac3_id, dts_id, lpcm_id, j;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n    int audio_bitrate;\n\n    int video_bitrate;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd   =  (CONFIG_MPEG1VCD_MUXER  && ctx->oformat == &ff_mpeg1vcd_muxer);\n\n    s->is_svcd  =  (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer);\n\n    s->is_mpeg2 = ((CONFIG_MPEG2VOB_MUXER  && ctx->oformat == &ff_mpeg2vob_muxer) ||\n\n                   (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer) ||\n\n                   (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer));\n\n    s->is_dvd   =  (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer);\n\n\n\n    if (ctx->packet_size) {\n\n        if (ctx->packet_size < 20 || ctx->packet_size > (1 << 23) + 10) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Invalid packet size %d\\n\",\n\n                   ctx->packet_size);\n\n            goto fail;\n\n        }\n\n        s->packet_size = ctx->packet_size;\n\n    } else\n\n        s->packet_size = 2048;\n\n    if (ctx->max_delay < 0)     /* Not set by the caller */\n\n        ctx->max_delay = AV_TIME_BASE*7/10;\n\n\n\n    s->vcd_padding_bytes_written = 0;\n\n    s->vcd_padding_bitrate_num   = 0;\n\n\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n\n\n    mpa_id  = AUDIO_ID;\n\n    ac3_id  = AC3_ID;\n\n    dts_id  = DTS_ID;\n\n    mpv_id  = VIDEO_ID;\n\n    h264_id = H264_ID;\n\n    mps_id  = SUB_ID;\n\n    lpcm_id = LPCM_ID;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        st     = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        avpriv_set_pts_info(st, 64, 1, 90000);\n\n\n\n        switch (st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (!s->is_mpeg2 &&\n\n                (st->codec->codec_id == AV_CODEC_ID_AC3 ||\n\n                 st->codec->codec_id == AV_CODEC_ID_DTS ||\n\n                 st->codec->codec_id == AV_CODEC_ID_PCM_S16BE))\n\n                 av_log(ctx, AV_LOG_WARNING,\n\n                        \"%s in MPEG-1 system streams is not widely supported, \"\n\n                        \"consider using the vob or the dvd muxer \"\n\n                        \"to force a MPEG-2 program stream.\\n\",\n\n                        avcodec_get_name(st->codec->codec_id));\n\n            if (st->codec->codec_id == AV_CODEC_ID_AC3) {\n\n                stream->id = ac3_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_DTS) {\n\n                stream->id = dts_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_PCM_S16BE) {\n\n                stream->id = lpcm_id++;\n\n                for (j = 0; j < 4; j++) {\n\n                    if (lpcm_freq_tab[j] == st->codec->sample_rate)\n\n                        break;\n\n                }\n\n                if (j == 4)\n\n                    goto fail;\n\n                if (st->codec->channels > 8)\n\n                    return -1;\n\n                stream->lpcm_header[0] = 0x0c;\n\n                stream->lpcm_header[1] = (st->codec->channels - 1) | (j << 4);\n\n                stream->lpcm_header[2] = 0x80;\n\n                stream->lpcm_align     = st->codec->channels * 2;\n\n            } else {\n\n                stream->id = mpa_id++;\n\n            }\n\n\n\n            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).\n\n             * Right now it is also used for everything else. */\n\n            stream->max_buffer_size = 4 * 1024;\n\n            s->audio_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (st->codec->codec_id == AV_CODEC_ID_H264)\n\n                stream->id = h264_id++;\n\n            else\n\n                stream->id = mpv_id++;\n\n            if (st->codec->rc_buffer_size)\n\n                stream->max_buffer_size = 6 * 1024 + st->codec->rc_buffer_size / 8;\n\n            else {\n\n                av_log(ctx, AV_LOG_WARNING,\n\n                       \"VBV buffer size not set, using default size of 130KB\\n\"\n\n                       \"If you want the mpeg file to be compliant to some specification\\n\"\n\n                       \"Like DVD, VCD or others, make sure you set the correct buffer size\\n\");\n\n                // FIXME: this is probably too small as default\n\n                stream->max_buffer_size = 230 * 1024;\n\n            }\n\n            if (stream->max_buffer_size > 1024 * 8191) {\n\n                av_log(ctx, AV_LOG_WARNING, \"buffer size %d, too large\\n\", stream->max_buffer_size);\n\n                stream->max_buffer_size = 1024 * 8191;\n\n            }\n\n            s->video_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            stream->id              = mps_id++;\n\n            stream->max_buffer_size = 16 * 1024;\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n        stream->fifo = av_fifo_alloc(16);\n\n        if (!stream->fifo)\n\n            goto fail;\n\n    }\n\n    bitrate       = 0;\n\n    audio_bitrate = 0;\n\n    video_bitrate = 0;\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        int codec_rate;\n\n        st     = ctx->streams[i];\n\n        stream = (StreamInfo *)st->priv_data;\n\n\n\n        if (st->codec->rc_max_rate ||\n\n            st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            codec_rate = st->codec->rc_max_rate;\n\n        else\n\n            codec_rate = st->codec->bit_rate;\n\n\n\n        if (!codec_rate)\n\n            codec_rate = (1 << 21) * 8 * 50 / ctx->nb_streams;\n\n\n\n        bitrate += codec_rate;\n\n\n\n        if ((stream->id & 0xe0) == AUDIO_ID)\n\n            audio_bitrate += codec_rate;\n\n        else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            video_bitrate += codec_rate;\n\n    }\n\n\n\n    if (s->user_mux_rate) {\n\n        s->mux_rate = (s->user_mux_rate + (8 * 50) - 1) / (8 * 50);\n\n    } else {\n\n        /* we increase slightly the bitrate to take into account the\n\n         * headers. XXX: compute it exactly */\n\n        bitrate    += bitrate / 20;\n\n        bitrate    += 10000;\n\n        s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n        if (s->mux_rate >= (1<<22)) {\n\n            av_log(ctx, AV_LOG_WARNING, \"mux rate %d is too large\\n\", s->mux_rate);\n\n            s->mux_rate = (1<<22) - 1;\n\n        }\n\n    }\n\n\n\n    if (s->is_vcd) {\n\n        int64_t overhead_rate;\n\n\n\n        /* The VCD standard mandates that the mux_rate field is 3528\n\n         * (see standard p. IV-6).\n\n         * The value is actually \"wrong\", i.e. if you calculate\n\n         * it using the normal formula and the 75 sectors per second transfer\n\n         * rate you get a different value because the real pack size is 2324,\n\n         * not 2352. But the standard explicitly specifies that the mux_rate\n\n         * field in the header must have this value. */\n\n        // s->mux_rate = 2352 * 75 / 50;    /* = 3528 */\n\n\n\n        /* The VCD standard states that the muxed stream must be\n\n         * exactly 75 packs / second (the data rate of a single speed cdrom).\n\n         * Since the video bitrate (probably 1150000 bits/sec) will be below\n\n         * the theoretical maximum we have to add some padding packets\n\n         * to make up for the lower data rate.\n\n         * (cf. VCD standard p. IV-6 ) */\n\n\n\n        /* Add the header overhead to the data rate.\n\n         * 2279 data bytes per audio pack, 2294 data bytes per video pack */\n\n        overhead_rate  = audio_bitrate * 2294LL * (2324 - 2279);\n\n        overhead_rate += video_bitrate * 2279LL * (2324 - 2294);\n\n\n\n        /* Add padding so that the full bitrate is 2324*75 bytes/sec */\n\n        s->vcd_padding_bitrate_num = (2324LL * 75 * 8 - bitrate) * 2279 * 2294 - overhead_rate;\n\n#define VCD_PADDING_BITRATE_DEN (2279 * 2294)\n\n    }\n\n\n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n        s->pack_header_freq = 1;\n\n\n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* the standard mandates that there are only two system headers\n\n         * in the whole file: one in the first packet of each stream.\n\n         * (see standard p. IV-7 and IV-8) */\n\n        s->system_header_freq = 0x7fffffff;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        stream                = ctx->streams[i]->priv_data;\n\n        stream->packet_number = 0;\n\n    }\n\n    s->system_header_size = get_system_header_size(ctx);\n\n    s->last_scr           = AV_NOPTS_VALUE;\n\n    return 0;\n\n\n\nfail:\n\n    for (i = 0; i < ctx->nb_streams; i++)\n\n        av_freep(&ctx->streams[i]->priv_data);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 17120, "substitutes": {"ctx": ["loc", "ck", "tx", "dt", "setup", "crit", "kw", "aus", "conv", "obj", "sys", "req", "c", "jp", "context", "cm", "dc", "aux", "github", "xc", "abc", "check", "cv", "np", "aka", "desc", "mc", "timeout", "ct", "etc", "hw", "xs", "pkg", "nih", "kl", "ctrl", "fc", "cu", "x", "resp", "wcs", "sc", "ctl", "tc", "nt", "wp", "proc", "rx", "kt", "unc", "cf", "xp", "prefix", "jac", "ann", "cc", "bc", "alloc", "ka", "co", "addr", "std", "cfg", "cmp", "act", "Context", "txt", "cp", "tnc", "grad", " cx", "tz", "gc", "cas", "config", "wx", "that", "conn", "cmd", "func", "inst", "ref", "pool", "cb", "nc", "anc", "except", "conf"], "s": ["sg", "details", "results", "g", "rs", "vs", "se", "sets", "c", "es", "fs", "su", "ows", "spec", "os", "scl", "t", "settings", "csv", "q", "set", "qs", "S", "ss", "so", "v", "sts", "ps", "sn", "ids", "ts", "x", "ls", "locks", "stats", "bis", "status", "services", "ds", "cs", "sb", "changes", "als", "sv", "sw", "js", "b", "y", "rates", "m", "utils", "hs", "uploads", "p", "ins", "sq", "aws", "is", "bs", "gs", "ports", "ns", "sports", "pers", "ats", "less", "actions", "ims", "ms", "its"], "bitrate": [" bitRate", " bitrates", "bandrate", "BitRate", " bitwidth", "bandrates", "bitRate", "Bitwidth", "Bitrates", "bitwidth", "bandwidth", "Bitrate", "bitrates", "bandRate"], "i": ["a", "index", "ij", "b", "l", "t", "ci", "p", "ir", "e", "I", "v", "io", "ip", "mi", "pi", "c", "id", "ti", "n", "f", "it", "ia", "iu", "y", "ii", "m"], "mpa_id": ["mpo_type", "mpa_name", "mpba_mid", "mpa___mid", "mpba_info", "mpa_ID", "mpaoeid", "mpbaoemid", "mpa___name", "mpaoeinfo", "mpa___ID", "mpaoemid", "mpba_id", "mpa_type", "mpo_ID", "mpba_name", "mpaoename", "mpa___id", "mpbaoeinfo", "mpa_mid", "mpbaoeid", "mpa___info", "mpbaoename", "mpa_info", "mpa___type", "mpo_id"], "mpv_id": ["mpb_id", "mpv_ID", "mpb_ID", "mpb_mid", "mpb_no", "mpv_mid", "mpv_no"], "h264_id": ["h264__ids", "h264_name", "h264__name", "h264__ID", "hv_ID", "hv_name", "hv_ids", "h264_ID", "h264__id", "h264_ids", "hv_id"], "mps_id": ["mcs_mid", "mpsgid", "mps_ids", "mps_mid", "mcs_id", "mpsgmid", "mpsetids", "mpsetid", "mpsetmid", "mcs_type", "mpsettype", "mpsgtype", "mcs_ids", "mpsgids", "mps_type"], "ac3_id": ["ac3_m", "ac3___ids", "acd_id", "acd_db", "ac3___id", "ac3_ids", "acd_type", "ac3_mid", "ac3___type", "ac3_db", "acd_ids", "acd_m", "acd_mid", "ac3_type", "ac3___db"], "dts_id": ["ctl", "dts_ID", "dtsgmid", "dts__id", "dts__ids", "dtsgids", "config", "_", "dss_mid", "jpg", "conv", "dss__mid", "dss__id", "dtsgID", "call", "cmd", "dss_id", "func", "dts_ids", "dts_mid", "new", "cmp", "def", "dss__ID", "dtsgid", "dss_ID", "dts__ID", "dss__ids", "dss_ids", "dts__mid"], "lpcm_id": ["lpcm_ids", "lpcm_num", "lpm_ID", "lpm_ids", "lpm_id", "lpm_num", "lpcm_ID"], "j": ["ij", "jj", "l", "z", "p", "dj", "kj", "q", "uj", "g", "J", "jit", "v", "k", "js", "json", "jp", "job", "ji", "n", "o", "jump", "gm", "f", "jc", "b", "m"], "st": ["sc", "ist", "sh", "sp", "th", "sm", "sv", "tmp", "ss", "ste", "ct", "mt", "ch", "sw", "St", "sts", "se", "sn", "sth", "inst", "std", "ST", "str", "sta", "rest", "us", "serv", "sl"], "stream": ["form", "sl", "tx", "REAM", "ream", "sw", "v", "io", "video", "instance", "iv", "ive", "sn", "data", "Stream", "cm", "o", "info", "ack", "src", "spec", "sc", " info", "status"], "audio_bitrate": ["audio_bitsRate", "audio_byterate", "audio_boardRate", "audio_boardrate", "audio_byteRate", "audio_bitRate", "audio_bitnumber", "audio_bitsrate", "audio_boardnumber", "audio_bytenumber", "audio_bitsnumber"], "video_bitrate": ["video_minram", "video_minrace", "video_bitrace", "video_minrate", "video_byterate", "video_bitRate", "video_byterace", "video_bitram", "video_byteram", "video_minRate", "video_byteRate"], "audio_bound": ["volume_bound", "audio_connected", "volume_connected", "audio_bind", "audio___bind", "audio___connected", "audio___max", "volume_max", "audio___bound", "volume_bind", "audio_max"], "video_bound": ["channel_position", "video_position", "channel_bound", "channel_device", "video_device", "channel_bind", "video_bind"]}}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,\n\n                              int mm_flags)\n\n{\n\n    const int bit_depth      = avctx->bits_per_raw_sample;\n\n    const int high_bit_depth = bit_depth > 8;\n\n\n\n    c->prefetch = prefetch_mmx2;\n\n\n\n    if (!high_bit_depth) {\n\n        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;\n\n        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;\n\n        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;\n\n        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;\n\n\n\n        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;\n\n        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;\n\n        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;\n\n        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;\n\n    }\n\n\n\n    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {\n\n        if (!high_bit_depth) {\n\n            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;\n\n\n\n            c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;\n\n            c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;\n\n        }\n\n\n\n        if (CONFIG_VP3_DECODER && HAVE_YASM) {\n\n            c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;\n\n            c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;\n\n        }\n\n    }\n\n    if (CONFIG_VP3_DECODER && HAVE_YASM)\n\n        c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;\n\n\n\n    if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 ||\n\n                               avctx->codec_id == CODEC_ID_THEORA)) {\n\n        c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;\n\n        c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;\n\n    }\n\n\n\n    if (CONFIG_H264QPEL) {\n\n        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );\n\n\n\n        if (!high_bit_depth) {\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );\n\n        } else if (bit_depth == 10) {\n\n#if HAVE_YASM\n\n#if !ARCH_X86_64\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n#endif\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n#endif\n\n        }\n\n\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );\n\n    }\n\n\n\n#if HAVE_YASM\n\n    if (!high_bit_depth && CONFIG_H264CHROMA) {\n\n        c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;\n\n    }\n\n    if (bit_depth == 10 && CONFIG_H264CHROMA) {\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;\n\n        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;\n\n    }\n\n\n\n    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;\n\n\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;\n\n\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;\n\n    } else {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext;\n\n    }\n\n#endif\n\n}\n", "idx": 17124, "substitutes": {"c": ["check", "con", "ic", "cs", "tc", "l", "ca", "z", "t", "can", "ci", "w", "p", "mc", "ec", "enc", "at", "ctx", "unc", "pc", "gc", "e", "g", "cam", "config", "cf", "cc", "bc", "ct", "co", "d", "v", "etc", "cont", "call", "uc", "cr", "lc", "cm", "dc", "C", "coll", "fc", "ce", "cu", "cache", "nc", "anc", "xc", "com", "cp", "rc", "ac", "f", "abc", "chain", "arc", "sc", "b", "conf"], "avctx": ["navcv", "AVctx", "navcontext", "avertxt", " avcontext", " avcv", "avcv", "averjac", "AVtmp", "savtmp", "AVcontext", "avercv", "navjac", "avjac", "navjp", "avcontext", "avcmp", "navhw", "averjp", "averhw", "AVcmp", "avhw", "avtxt", "averctx", " avhw", "avectx", "avetxt", "navtxt", "avtmp", " avtmp", "avjp", "avejac", "navctx", "savcontext", "avercontext", "avejp", " avcmp", "savctx", "savcmp"], "mm_flags": ["MM00features", "MM00Flags", "mm_flag", "MM_flags", "MM_flag", "MM00flags", "mm00Flags", "MM00flag", "mm00features", "mm00flags", "mm_features", "mm00flag", "mm2flag", "MM_features", "mm2Flags", "mm_Flags", "mm2flags", "MM_Flags", "mm2features"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferH264   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH264Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        vseq->seq_parameter_set_id = 0;\n\n\n\n        vseq->level_idc = avctx->level;\n\n\n\n        vseq->max_num_ref_frames = 2;\n\n\n\n        vseq->picture_width_in_mbs  = priv->mb_width;\n\n        vseq->picture_height_in_mbs = priv->mb_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1;\n\n        vseq->seq_fields.bits.frame_mbs_only_flag = 1;\n\n        vseq->seq_fields.bits.direct_8x8_inference_flag = 1;\n\n        vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4;\n\n        vseq->seq_fields.bits.pic_order_cnt_type = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            vseq->frame_cropping_flag = 1;\n\n\n\n            vseq->frame_crop_left_offset   = 0;\n\n            vseq->frame_crop_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            vseq->frame_crop_top_offset    = 0;\n\n            vseq->frame_crop_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            vseq->frame_cropping_flag = 0;\n\n        }\n\n\n\n        vseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            vseq->vui_fields.bits.aspect_ratio_info_present_flag = 1;\n\n            // There is a large enum of these which we could support\n\n            // individually rather than using the generic X/Y form?\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                vseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                vseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                vseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                vseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n\n            avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||\n\n            avctx->colorspace      != AVCOL_SPC_UNSPECIFIED) {\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format             = 5; // Unspecified.\n\n            mseq->video_full_range_flag    = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            // These enums are derived from the standard and hence\n\n            // we can just use the values directly.\n\n            mseq->colour_primaries         = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coefficients      = avctx->colorspace;\n\n        }\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n\n\n        vseq->vui_fields.bits.timing_info_present_flag = 1;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->num_units_in_tick = avctx->framerate.num;\n\n            vseq->time_scale        = 2 * avctx->framerate.den;\n\n            mseq->fixed_frame_rate_flag = 1;\n\n        } else {\n\n            vseq->num_units_in_tick = avctx->time_base.num;\n\n            vseq->time_scale        = 2 * avctx->time_base.den;\n\n            mseq->fixed_frame_rate_flag = 0;\n\n        }\n\n\n\n        if (ctx->va_rc_mode == VA_RC_CBR) {\n\n            priv->send_timing_sei = 1;\n\n            mseq->nal_hrd_parameters_present_flag = 1;\n\n\n\n            mseq->cpb_cnt_minus1 = 0;\n\n\n\n            // Try to scale these to a sensible range so that the\n\n            // golomb encode of the value is not overlong.\n\n            mseq->bit_rate_scale =\n\n                av_clip_uintp2(av_log2(avctx->bit_rate) - 15 - 6, 4);\n\n            mseq->bit_rate_value_minus1[0] =\n\n                (avctx->bit_rate >> mseq->bit_rate_scale + 6) - 1;\n\n\n\n            mseq->cpb_size_scale =\n\n                av_clip_uintp2(av_log2(priv->hrd_params.hrd.buffer_size) - 15 - 4, 4);\n\n            mseq->cpb_size_value_minus1[0] =\n\n                (priv->hrd_params.hrd.buffer_size >> mseq->cpb_size_scale + 4) - 1;\n\n\n\n            // CBR mode isn't actually available here, despite naming.\n\n            mseq->cbr_flag[0] = 0;\n\n\n\n            mseq->initial_cpb_removal_delay_length_minus1 = 23;\n\n            mseq->cpb_removal_delay_length_minus1         = 23;\n\n            mseq->dpb_output_delay_length_minus1          = 7;\n\n            mseq->time_offset_length = 0;\n\n\n\n            // This calculation can easily overflow 32 bits.\n\n            mseq->initial_cpb_removal_delay = 90000 *\n\n                (uint64_t)priv->hrd_params.hrd.initial_buffer_fullness /\n\n                priv->hrd_params.hrd.buffer_size;\n\n\n\n            mseq->initial_cpb_removal_delay_offset = 0;\n\n        } else {\n\n            priv->send_timing_sei = 0;\n\n            mseq->nal_hrd_parameters_present_flag = 0;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->CurrPic.picture_id = VA_INVALID_ID;\n\n        vpic->CurrPic.flags      = VA_PICTURE_H264_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) {\n\n            vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID;\n\n            vpic->ReferenceFrames[i].flags      = VA_PICTURE_H264_INVALID;\n\n        }\n\n\n\n        vpic->coded_buf = VA_INVALID_ID;\n\n\n\n        vpic->pic_parameter_set_id = 0;\n\n        vpic->seq_parameter_set_id = 0;\n\n\n\n        vpic->num_ref_idx_l0_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_active_minus1 = 0;\n\n\n\n        vpic->pic_fields.bits.entropy_coding_mode_flag =\n\n            ((avctx->profile & 0xff) != 66);\n\n        vpic->pic_fields.bits.weighted_pred_flag = 0;\n\n        vpic->pic_fields.bits.weighted_bipred_idc = 0;\n\n        vpic->pic_fields.bits.transform_8x8_mode_flag =\n\n            ((avctx->profile & 0xff) >= 100);\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n    }\n\n\n\n    {\n\n        mseq->profile_idc = avctx->profile & 0xff;\n\n\n\n        if (avctx->profile & FF_PROFILE_H264_CONSTRAINED)\n\n            mseq->constraint_set1_flag = 1;\n\n        if (avctx->profile & FF_PROFILE_H264_INTRA)\n\n            mseq->constraint_set3_flag = 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17128, "substitutes": {"avctx": ["AVctx", "vcontext", "vtx", " avcontext", "cvcmp", "AVconn", "varctx", "svcmp", "svctx", "avconn", "AVcontext", "vardoc", "avcontext", "avcfg", "navconf", "avcmp", "svcontext", " avtx", " avconn", "avdoc", "vrtx", "avconf", "navcfg", "navdoc", "svcfg", "vrcfg", "vrdoc", "AVtx", "varconf", "vcfg", "cvtx", "vrctx", "varcfg", "navctx", "avtx", "cvcontext", "vconn", "vrconf", "vcmp", " avcmp", "vrcontext", "svtx", "vctx", "cvctx"], "ctx": ["loc", "wordpress", "tx", "lib", "rt", "setup", "kw", "obj", "sys", "req", "comm", "context", "eu", "aux", "net", "xc", "abc", "exec", "mem", "cv", "np", "fn", "perm", "desc", "mc", "tmp", "handle", "ct", "etc", "hw", "pb", "doc", "pri", "xs", "pkg", "root", "ctrl", "fc", "cu", "resp", "urg", "org", "err", "ctl", "tc", "nt", "wp", "proc", "rect", "kt", "unc", "expr", "cf", "xp", "kb", "prefix", "aco", "bc", "alloc", "auth", "ptr", "addr", "cmp", "cfg", "def", "act", "txt", "cp", "rc", "policy", "history", "grad", "lbs", "gc", "util", "config", "pg", "wx", "that", "conn", "cmd", "func", "mk", "offic", "ppo", "cb", "conf", "phys", "iat"], "vseq": ["Vseq", " vtest", "vvsel", " vdesc", "varcoll", "wiresim", "vtsequ", "vartest", "nvzip", "tvstruct", "invzip", " vsim", "vtest", "evseq", "vttest", "varzip", "evbuf", "vmbuf", "vbuf", " vref", "vsim", "vmcomp", "invsequ", "svtest", "varqueue", "Vsequ", "nvvec", "tvsel", "Vtest", "Vsequence", " vbuf", "vsequence", "revzip", "fzip", "vpse", " vsequ", "freq", "revseq", "invseq", "Vvec", "vtseq", "vtnext", "avcrit", " vclus", "lbuf", "revdesc", "svseq", "lseq", "varcrit", "vstr", "avsequ", " vpse", "svbuf", "tvclus", "vnext", " vstr", "convseq", " vqueue", "fsequ", "vvclus", "varseq", "varsequ", "avpse", "varbuf", "nvsequ", "wireseq", "vtdesc", "avvec", "vervec", "evpse", "vmvec", "verseq", "vcomp", "lstruct", "vdesc", "vzip", "varvec", "invprintf", "nvpse", "invsequence", " vstruct", "avseq", "vsequ", " vvec", "varprintf", "wirezip", "lsequ", "vvsequ", "vvtest", "versim", " vsel", "vvec", "revnext", "vvvec", "fpse", "versequence", " vcomp", "varsequence", "vmstr", "evqueue", " vzip", "ftest", "fvec", "vmseq", "vstruct", "svcomp", "vqueue", "vsel", "vref", "tvseq", "vvseq", "vvstruct", "invreq", "vmsequ", " vcoll", "svsequ", "verdesc", "vmtest", "vtzip", "svstr", " vnext", "evsequ", "vclus", " vreq", "Vbuf", "verzip", " vcrit", "vcrit", "convcoll", "fseq", "Vpse", "evzip", "invref", "avsequence", "evtest", "convtest", "invvec", " vsequence", "versequ", "vcoll", "convsequence", "nvseq", "wiredesc", "Vstruct", "Vref", "vreq", "Vzip"], "vpic": ["mfp", "mpict", "vpict", "avseq", " vpict", "avpic", "avpict", "vfp", "mpic", " vfp", "avfp"], "priv": ["mem", "cap", "riv", "pub", "loc", "perm", "Priv", "pr", "tx", "lib", "sp", "proc", "pres", "eas", "cam", "config", "caps", "prop", "alloc", "sec", "pg", "rep", "pro", "gov", "auth", "attr", "pri", "soc", "conn", "pkg", "rev", "pi", "rot", "dev", "rel", "private", "cfg", "env", "txt", "info", "org", "Pri", "cp", "policy", "serv", "conf", "phys", "err"], "mseq": ["tvec", "vmsequ", "vmsequence", "tsequ", " mvec", " msequence", "vmvec", " msequ", "mvec", "msequ", "msequence", "tsequence", "vmseq", "tseq"], "i": ["a", "ij", "t", "im", "p", "ei", " out", "h", "li", " pi", "I", " ii", " l", "v", " gp", " li", "c", " j", "id", "j", "n", "x", " init", " c", " bi", "b", "ii", "m"]}}
{"project": "qemu", "commit_id": "0d6ff71ae3c7ac3a446d295ef71884a05093b37c", "target": 0, "func": "void if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    bool from_batchq, next_from_batchq;\n\n    struct mbuf *ifm, *ifm_next, *ifqt;\n\n\n\n    DEBUG_CALL(\"if_start\");\n\n\n\n    if (slirp->if_start_busy) {\n\n        return;\n\n    }\n\n    slirp->if_start_busy = true;\n\n\n\n    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n        ifm_next = slirp->if_fastq.ifq_next;\n\n        next_from_batchq = false;\n\n    } else if (slirp->next_m != &slirp->if_batchq) {\n\n        /* Nothing on fastq, pick up from batchq via next_m */\n\n        ifm_next = slirp->next_m;\n\n        next_from_batchq = true;\n\n    } else {\n\n        ifm_next = NULL;\n\n    }\n\n\n\n    while (ifm_next) {\n\n        ifm = ifm_next;\n\n        from_batchq = next_from_batchq;\n\n\n\n        ifm_next = ifm->ifq_next;\n\n        if (ifm_next == &slirp->if_fastq) {\n\n            /* No more packets in fastq, switch to batchq */\n\n            ifm_next = slirp->next_m;\n\n            next_from_batchq = true;\n\n        }\n\n        if (ifm_next == &slirp->if_batchq) {\n\n            /* end of batchq */\n\n            ifm_next = NULL;\n\n        }\n\n\n\n        /* Try to send packet unless it already expired */\n\n        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {\n\n            /* Packet is delayed due to pending ARP resolution */\n\n            continue;\n\n        }\n\n\n\n        if (ifm == slirp->next_m) {\n\n            /* Set which packet to send on next iteration */\n\n            slirp->next_m = ifm->ifq_next;\n\n        }\n\n\n\n        /* Remove it from the queue */\n\n        ifqt = ifm->ifq_prev;\n\n        remque(ifm);\n\n\n\n        /* If there are more packets for this session, re-queue them */\n\n        if (ifm->ifs_next != ifm) {\n\n            struct mbuf *next = ifm->ifs_next;\n\n\n\n            insque(next, ifqt);\n\n            ifs_remque(ifm);\n\n\n\n            if (!from_batchq) {\n\n                /* Next packet in fastq is from the same session */\n\n                ifm_next = next;\n\n                next_from_batchq = false;\n\n            } else if (slirp->next_m == &slirp->if_batchq) {\n\n                /* Set next_m and ifm_next if the session packet is now the\n\n                 * only one on batchq */\n\n                slirp->next_m = ifm_next = next;\n\n            }\n\n        }\n\n\n\n        /* Update so_queued */\n\n        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {\n\n            /* If there's no more queued, reset nqueued */\n\n            ifm->ifq_so->so_nqueued = 0;\n\n        }\n\n\n\n        m_free(ifm);\n\n    }\n\n\n\n    slirp->if_start_busy = false;\n\n}\n", "idx": 17133, "substitutes": {"slirp": ["slirapar", "slyrpi", "slirpart", "blibrph", "slrirpkg", "blibrpa", "Slpircp", "slwarpi", "slererpad", "sliverps", "blibrp", "slwarpress", "slarpre", "sliterq", "slyrp", "dlirlc", "slrirpad", "slrirpre", "slpirp", "blirpid", "slirpe", "slererpar", "sslierl", "scheirpid", "slpirq", "sliberpi", "collirapad", "isldirp", "slibrp", "slibrpc", "slibrcp", "slrircp", "slarpy", "splircp", "slererp", "plibrping", "slircp", "slmirpart", "slarp", "blirph", "sligrq", "sliercp", "slvrpy", "slierc", "slierpe", "slrirpar", "islirping", "slwarpre", "slrirph", "slierpa", "plirpi", "splwarpart", "slirop", "sslierpe", "slmirpre", "dlirr", "slirpre", "slibrr", "scheiverp", "slirl", "scheirps", "slrirpi", "blirp", "slirapkg", "slibrpid", "isldirpi", "slibrc", "slirel", "slierpy", "slwarr", "sligrpa", "slrirp", "slibrping", "slpirc", "sliterpi", "slarpe", "scheiverpid", "sslierpy", "slrirpatch", "islirp", "islibrp", "slierpad", "slvrpid", "slirer", "ssliert", "splirpress", "sliberp", "splwarpre", "dlirlpa", "dlirp", "slyrpart", "slpirpad", "slmirpa", "islircp", "scheirp", "blibrping", "collirp", "slirlr", "slmirpi", "slirpkg", "slierp", "slirpa", "slirm", "sldirpa", "spldirpa", "pliterp", "scheirpatch", "sliropatch", "slvrping", "plibrp", "slierr", "slirypy", "collirap", "slpirpi", "slpirpre", "sliert", "sslire_", "islirpress", "sslirpre", "slwarp", "slibrph", "slirq", "Slirp", "slirc", "splarp", "Slircp", "plirp", "slibrpre", "slirepress", "slmirph", "splirp", "sliberping", "blirping", "blirpi", "islirl", "slirt", "slyr_", "Slpirpatch", "slarcp", "slpirl", "slrirpa", "dlirlr", "slarpid", "slierq", "islibrpress", "Slpirm", "sslpirpre", "sldirp", "slirlpa", "slwarpart", "spldirq", "sliryp", "slirap", "slIRping", "blirpre", "collirpkg", "spldirp", "slibrl", "sligrp", "splarpad", "slmirp", "slrirping", "splirpre", "sliryt", "blibrpi", "blibrpre", "slirepa", "slirlc", "slrirm", "splirpa", "scheiverps", "slibrpatch", "spldirpress", "slIRp", "sliterp", "slirpress", "Slirm", "plirq", "blibrpid", "plirc", "slirops", "slibrpress", "sliterc", "dlirc", "slwarl", "sldircp", "splwarp", "sliryl", "splwarpi", "slibrps", "sslpirpy", "slyrpre", "slIRpy", "slpirpy", "slire_", "slarpi", "splarcp", "slirec", "islirr", "scheiverpatch", "plibrc", "islibrr", "splirpid", "slibrpi", "slierpre", "dlirlp", "pliterc", "slpirpatch", "blirpc", "sslpirp", "sldirpi", "sldirping", "sliropi", "slibrq", "splirpad", "sslirl", "blibrpy", "splirq", "sslirp", "slarpad", "slierl", "slarping", "slierpress", "sliverpi", "slpirm", "slpircp", "sliterps", "splirpart", "sliberc", "sslirpi", "blibrpc", "sslirpy", "slirpatch", "slirpid", "sslir_", "slirpi", "slirep", "sslierping", "slirpad", "islirpi", "slpirpid", "blibrps", "slvrp", "slibr_", "sliverpatch", "plibrpi", "slererpkg", "slierpid", "sliverp", "sslierp", "slierpatch", "Slpirp", "pliterq", "Slirpatch", "slpirping", "sslierpi", "plirping", "sliropid", "slir_", "splirpi", "sslirping", "slirps", "sslpirpi", "isldirping", "slibrpa", "collirpad", "slirpar", "collirpar", "slierpi", "slirph", "slirr", "blirps", "slierping", "slirpc", "sligrpress", "sliverpid", "slirping", "sliverpe", "sliverping", "sliterpc", "sliterping", "dlirpa", "slirlp", "sslirpe", "islibrl", "isldircp", "sldirq", "slibrpy", "slpirt", "slirpy", "splarpid", "pliterping", "slirapad", "blirpa", "collirapar", "collirapkg", "slIRpid", "blirpy", "slibrm", "sslirt", "sliropc", "sldirpress", "slierps"], "from_batchq": ["from_batchfresh", "from_batck", "from_batQ", "from_batqueue", "from_workqs", "from_queueq", "from_batchqq", "from_queueqs", "from_blockqs", "from_fastQ", "from_queuequeue", "from_batchqu", "from_blockqueue", "from_batchQ", "from_batchqueue", "from_batqs", "from_batqq", "from_queueqq", "from_fastq", "from_fastfresh", "from_fastqueue", "from_workq", "from_batchck", "from_batfresh", "from_workqu", "from_batq", "from_blockqq", "from_blockq", "from_batchqs", "from_workck", "from_batqu"], "next_from_batchq": ["next_from_batchdq", "next_from_batchqueue", "next_from_cleandq", "next_from2batchq", "next_from_patchq", "next_from__atchdq", "next_from_patchqu", "next_from_flatquery", "next_from_workaq", "next_from_flatQ", "next_from_batQ", "next_from_batcheq", "next_from_cacheqs", "next_from_broadqu", "next_fromvbatchqs", "next_from_batchqs", "next_from_flatrequ", "next_from_launchqueue", "next_from_batchaq", "next_from_broadQ", "next_from_atchdq", "next_fromvfastrequ", "next_from_launchz", "next_from_globalaq", "next_from_flatqu", "next_from2batchqu", "next_fromvfastq", "next_from_batk", "next_from_flateq", "next_from_globalQ", "next_from_globalk", "next_from_fasteq", "next_from_launchqu", "next_from_fastlock", "next_from_atchq", "next_from__batchlock", "next_from_launchg", "next_from_globalq", "next_from_broadquery", "next_from_batq", "next_fromvfasteq", "next_from2fastqu", "next_from_fastquery", "next_from_fastqu", "next_fromvbatchq", "next_from_cacheq", "next_from_batchQ", "next_from_atchz", "next_from_atchg", "next_from_patchQ", "next_from_atchquery", "next_from_fastq", "next_from2fastquery", "next_from__batchquery", "next_from_batchg", "next_from_batg", "next_from_batchqu", "next_from__atchlock", "next_from_cleanquery", "next_from_batchz", "next_from2fastq", "next_from_cleanq", "next_from_workq", "next_from__atchq", "next_from_patchqueue", "next_from__atchquery", "next_from_fastrequ", "next_fromvfastqs", "next_from_batchrequ", "next_from_batchlock", "next_from_workQ", "next_fromvbatcheq", "next_from_batchk", "next_from_fastdq", "next_from_cleanlock", "next_from_atchlock", "next_from_batchquery", "next_from_workk", "next_from_launchq", "next_from_bataq", "next_from_flatqs", "next_fromvbatchrequ", "next_from_cacherequ", "next_from2batchquery", "next_from_broadq", "next_from2fastQ", "next_from2batchQ", "next_from__batchdq", "next_from_launchQ", "next_from_batz", "next_from_fastQ", "next_from_flatq", "next_from__batchq", "next_from_cacheeq", "next_from_fastqs"], "ifm": ["imd", "IFdm", "itermm", "iftom", "iftarm", "ibp", " ifmi", "invm", " ifM", "tifm", "iwm", "iftM", "ifmt", "ibd", "ifmodule", "tifgm", "elsemn", "IFM", "fifm", "efmn", "actM", "mitM", "actma", "iffrm", "iwmt", "itmt", "ifdm", "ifma", "actgm", "iwmd", "ifp", "ibm", "immi", "iamom", "efmd", "actmt", "ibmm", "iammi", "affmodule", "itgm", " ifd", "fifmodule", " ifcm", "ifnum", "iamma", "iammt", " ifmt", "uhmi", " ifan", "itermodule", "ifan", "invgm", " ifp", "fifmt", " ifarm", "actmi", "iftnm", " ifmodule", "expmd", "ifom", "IFm", "elsem", "mitmi", "ifmm", "Ifm", "ifd", "iftmodule", "ifmd", "ifpm", "itd", "affname", "affm", " ifname", "uhm", "ifrm", "IfM", "iftd", "iftnum", "itM", "imcm", "iftname", "affM", "iwmn", "mitom", "fifd", "mitm", "iffnum", "ifmn", "invnm", "iterm", "uhM", "ifmi", "iamm", "iterd", "fifan", "ibmt", "imma", "tifnm", "ifgm", "fifmn", "expm", "iamarm", "ifM", "fifmi", "immt", "elsemt", "iffM", "iffm", "tifpm", "itermn", "actm", "itermt", "Ifgm", "ifcm", "iterp", "imm", "ifarm", "iffdm", "iman", "Ifmt", "iftmi", "ifnm", " ifdm", "iftm", "fifmm", "efm", " ifpm", " ifom", "itermi", " ifgm", "itm", "expmt", "elsemi", "ifname", "invpm", "fifcm", " ifrm", "efmt", "IFrm", "itnm", "iffnm", "itnum", " ifnm", "ibmodule", "iffd", "uhom", "expmn"], "ifm_next": ["ifm__dn", "ifm_prev", "ifgm___next", "ifm_be", "ifm__pred", "ifm___future", "ifmUne", "ifm_continue", "ifn_next", "ifmiistnext", "ifmi_be", "ifnm_continue", "ifam_future", "ifn_ne", "ifm_future", "ifmiistoutput", "ifr__buf", "ifgm___future", "ifm_inv", "ifma_pre", "ifr__prev", "ifm___next", "ifmUdev", "ifam_ne", "ifm_output", "ifma_ne", "ifm_link", "ifm___adj", "ifm__prev", "ifgm_prev", "ifm__future", "ifgm_want", "ifr_Next", "ifmistnext", "ifm_adj", "ifmUnext", "ifr_prev", "ifm___want", "ifn_inv", "ifm_Next", "ifr_buf", "ifr_forward", "ifm_dev", "ifr_pre", "ifm__next", "ifgm_next", "ifgm_future", "ifm_buf", "ifr__next", "ifgm___dn", "ifgm_dn", "ifnm_ne", "ifm__Next", "ifmistpred", "ifmi_next", "ifam_link", "ifgm_adj", "ifmi_pred", "ifnm_prev", "ifma_dev", "ifr_next", "ifmistoutput", "ifm___prev", "ifmUpre", "ifnm_next", "ifm____inv", "ifr__Next", "ifr_ne", "ifm____ne", "ifm_chain", "iflem_trace", "ifm_trace", "ifm__buf", "ifmi_dev", "ifmi_prev", "ifm____chain", "ifm_pred", "iflem_gen", "ifm_pre", "iflem_conn", "ifm____next", "ifm_conn", "ifn_chain", "ifm__output", "ifm_gen", "ifmiistpred", "ifm_ne", "ifm_forward", "ifgm___prev", "ifm_want", "ifm_dn", "ifam_next", "ifmi_output", "ifm___dn", "ifma_next", "iflem_next"], "ifqt": ["IFreq", "ifq", "gifvt", "ifqa", "imqt", "iffvt", "ifvt", "ifreq", "limqt", " ifq", "limvt", "IFqt", "exqa", "ifbt", " ifqa", "exvt", "gifqt", " ifreq", "IFqa", "gifqq", "IFvt", "gifq", "exqt", "iffbt", "iffqt", "imq", " ifqq", " ifbt", "limqa", "iffqa", "ifqq", "imvt", "limbt", "exreq", " ifvt", "imqq"], "next": ["missing", "prev", "z", "future", "front", "big", "max", "false", "valid", "result", "last", "li", "ne", "end", "set", "zero", "append", "ng", "tmp", "link", "node", "step", "send", "gov", " NEXT", "start", "ptr", "iter", "head", "response", "first", "latest", "data", "target", "Next", "nl", "to", "j", "skip", "new", "line", "draw", "current", "obs", "path", "network", "txt", "null", "info", "forward", "nd", "after"]}}
{"project": "qemu", "commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "target": 0, "func": "static void handle_ti(ESPState *s)\n\n{\n\n    uint32_t dmalen, minlen;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_ti;\n\n        return;\n\n    }\n\n\n\n    dmalen = s->rregs[ESP_TCLO];\n\n    dmalen |= s->rregs[ESP_TCMID] << 8;\n\n    dmalen |= s->rregs[ESP_TCHI] << 16;\n\n    if (dmalen==0) {\n\n      dmalen=0x10000;\n\n    }\n\n    s->dma_counter = dmalen;\n\n\n\n    if (s->do_cmd)\n\n        minlen = (dmalen < 32) ? dmalen : 32;\n\n    else if (s->ti_size < 0)\n\n        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;\n\n    else\n\n        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;\n\n    trace_esp_handle_ti(minlen);\n\n    if (s->dma) {\n\n        s->dma_left = minlen;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        esp_do_dma(s);\n\n    }\n\n    if (s->do_cmd) {\n\n        trace_esp_handle_ti_cmd(s->cmdlen);\n\n        s->ti_size = 0;\n\n        s->cmdlen = 0;\n\n        s->do_cmd = 0;\n\n        do_cmd(s, s->cmdbuf);\n\n    }\n\n}\n", "idx": 17141, "substitutes": {"s": ["z", "bits", "details", "st", "e", "g", "rs", "vs", "se", "self", "sys", "c", "es", "sync", "comm", "fs", "sol", "spec", "serv", "sl", "os", "ops", "t", "settings", "events", "sp", "sm", "set", "qs", "S", "ss", "so", "sts", "ps", "xs", "https", "n", "ts", "ls", "parts", "stats", "a", "ds", "cs", "as", "sb", "ses", "changes", "als", "ar", "sv", "sw", "http", "js", "j", "gets", "ssl", "an", "states", "b", "has", "m", "hs", "args", "p", "ins", "ers", "sq", "aws", "h", "is", "bs", "gs", "ns", "ties", "sports", "ats", "r", "less", "reads", "ims", "ms", "us", "conf", "its"], "dmalen": ["dstalen", "dlayenge", "dlayener", "dmalender", "dbaloen", "dcolmener", "dmalenc", "dmaden", "dlayenn", "dmalresh", "delmalatten", "dhalEN", "dltallender", "dlasenn", " dmlener", " dmasim", "Dstalen", "dtallaren", "dtallender", "dmelength", "dchloren", "datallen", "dlasens", "dmilens", "dmaloen", "delmanen", " dmasan", " dmalan", " dstalens", " dstalenge", "Dmalener", "dmadan", "datalense", "dlmalEN", "dmleng", "dbalenge", "didmaloen", "dmacender", "dmanhen", "dmetalen", "redmacens", "dmaceni", "dmacenn", "didchloroen", "damatenge", "dlayaren", "dmalenge", "dmasener", " dmasEN", "dstalaren", "dstromen", "dmalength", "dstallen", "delmenener", "dmanaren", "dmaleni", "dmaleng", "dmetalhen", "Dstalresh", "dmasen", " dmalener", "datalener", "dstalens", "dmurenc", "delmenen", "dlhalenc", "delmaneni", " dmasen", "dmacens", "dlayender", "dmillen", "Dstalener", "dcolmain", "dbalien", "dmalense", "dmurense", " dstalen", "dmlenn", "didchlorien", " dmalens", "dmlen", "dlmalaren", "dstromien", "dmatah", " dstalain", "dmalency", " dmalenge", "delmalaren", "dstalEN", " dmlenn", "Dmalen", "damatah", " dmaseng", "dmadength", "dtallenn", "dstalenge", "dmonency", "dmacen", "dmasEN", "datalenc", "dltallaren", "didchlorsten", "dmuren", "dmetalaren", "dmacaren", "dmalEN", "dhalense", "damaten", "delmalen", "redmacenn", " dstalener", "dlmalenc", "dstalain", "dbalener", "dltallen", "dmanen", "dmoneng", "dmalain", "redmalaren", "redmacen", "dbalsten", "dmaten", "dmilener", "dmilen", "damalan", "delmenenge", " dmlen", "dmalener", "dmanenge", "dstaleng", "dmallen", "Dmalresh", "dmaseng", "dbalen", "dstalatten", "dmalaren", "dmonen", "dstromsten", " dmalength", "damalen", "didmalen", "dlmalense", "dmetaleni", "dmelim", "dmelen", "dmanah", "dltallenn", "datalEN", "dmalim", "dlayatten", "dmurEN", " dmalim", "dmalens", "dmasim", "dlhalense", "dlasen", "delmalhen", "datalens", "damalenge", "dmlenge", "dmonenn", "delmaleni", "dmalah", "dmlan", "dmatenge", " dmasener", "dlmalen", "delmenatten", "dmasength", " dmalain", "delmanaren", "dlayen", "dmelan", "Dmalency", " dmaleng", "dmalhen", "dmlener", "dmenen", "damatan", "dmalien", "Dstalency", "dstalenn", "dstalency", "dmalenn", "didchloren", "dmanan", "dstalener", " dstallen", "datalen", "dlhalEN", "redmalenn", "damalah", "didmalsten", "dlasaren", "delmalener", "dchlorien", "dchlorsten", "dmachen", "dmasan", "dmalatten", "delmalenge", "redmacaren", "dlmalender", "dchloroen", "dstromoen", "dtallen", "redmalen", "dmenenge", " dmleng", "dcolmEN", "dmonresh", "dbalain", "dmalsten", "dhalen", "dmalan", "dmlah", "dmenatten", "didmalien", "delmanhen", " dmalenn", "dhalenc", "dmatan", "dmenener", "dlhalen", " dmallen", "dmadim", "dstalresh", "dcolmenge", "redmalens", " dmasength", "dmonener", " dmalEN", "dcolmen", "dmaneni", "dcolmeng", "dlmalenn"], "minlen": ["MINlen", "Minelt", "rainlon", "Minen", " minlength", "aminlength", "memberlength", "minlength", "MINlon", "smalllf", "smallfin", "Minlen", "minelt", "Minln", "rainlen", "Mincompl", "MINen", "minimumlon", "rainlength", " minfin", "smallcompl", "MINcompl", " mincompl", "partiallength", "minimumlen", "mincompl", "minimumlength", "MINlength", " minlf", "partialcoll", "rainelt", " minlon", " mincoll", "Minfin", "minlf", "minimumln", "minimumfin", "minen", "memberlen", "minfin", "aminelt", " minen", "minlon", "smallcoll", "partiallf", "memberln", "minln", "aminlen", "mincoll", "Minlon", "smalllength", "smalllen", "Minlength", "minimumcompl", "aminlon", "partiallen", "memberfin"]}}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void lsi53c895a_register_devices(void)\n\n{\n\n    type_register_static(&lsi_info);\n\n    type_register_static_alias(&lsi_info, \"lsi\");\n\n}\n", "idx": 17152, "substitutes": {}}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n", "idx": 17172, "substitutes": {"scon": [" sco", "smon", "inscons", "asconv", "rsco", "sdial", "asconn", "wsconv", " scons", "jscons", "hsconn", "sconst", " sgate", "statsmon", "wscon", "isconn", "sco", "Sconv", "sconv", "inscon", " sdo", "jsco", "jscon", "sCon", "hsbon", "jsCon", "stsdial", "statsgate", " sbon", "rsmon", "rsCon", "insconn", "SCon", "ascon", "insconst", "Sco", "insgate", "stsconst", "ascons", "stscon", "hscon", "sgate", "jsdo", "jsbon", "jsconn", "rsconn", "insmon", "statscon", "scons", "sdo", "Scons", "iscons", "insbon", " sdial", "sconn", "rscon", "wscons", "Sconst", "sbon", "wsconn", "Sdial", " sconn", " smon", "hsdo", "statsconst", "Scon", "ismon", "iscon", "rscons", "stsconn", " sCon", "Sconn", " sconst"], "buf": ["mem", "cap", "cv", "Buff", "window", "img", "p", "bb", "fb", "vec", "cur", "map", " buffer", "queue", "BU", "bc", "v", "bytes", "wb", "doc", "data", "msg", "ref", "new", "bound", "rb", "txt", "cb", "block", "uf", "que", "buffer", "Buffer", "buff", "b", "seq", "br"], "size": ["z", "format", "shift", "scale", "e", "g", "length", "get", "c", "sha", "number", "space", "use", "t", "equal", "sp", "en", "port", "set", "zero", "device", "sum", "shape", "amount", "fee", "sn", "scope", "n", "ze", "len", "small", "code", "style", "l", "num", "send", "name", "address", "sw", "capacity", "time", " Size", "to", "storage", "body", "height", "Size", "notice", "SIZE", "info", "go", "sample", "m", "needed", "pos", "see", "sent", "count", "empty", "padding", "area", "ize", "message", "now", "type"]}}
{"project": "qemu", "commit_id": "d3aea641a4002e0abe940c65d318ef38eda245df", "target": 1, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n\n\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}", "idx": 17199, "substitutes": {"opaque": ["opsoch", "Opaque", "octacity", " opque", "opsaco", "Opoch", "octaques", "opaques", " opaques", "opaco", "Opque", " Opque", "opsaque", "ipaques", "opoch", "Opaco", "ipque", " Opoch", "ipacity", " Opaco", " Opaque", " opacity", "opacity", "opque", "ipaque", "octque", "octaque", "opsque"], "dev": ["pub", "loc", " door", "pad", "pr", "av", "hd", "cam", "cast", "ad", "pro", " av", "obj", "priv", "den", "develop", "cho", "gu", "dem", "spec", "serv", "om", "mem", " dw", "die", "form", "desc", "var", "app", "device", "stick", "cur", "unknown", "d", "v", "hw", "doc", "add", "pkg", "env", "ver", "patch", " device", "nt", "w", " des", "term", "proc", "ow", "van", "DEV", "buf", "prop", "des", "attr", "addr", " mem", "det", "att", "ev", "fo", "def", "raw", "go", "der", "nav", "dn", "debug", "Dev", "out", "db", "ve", "wd", "conn", " adm", "cmd", "watch", "val"]}}
{"project": "FFmpeg", "commit_id": "e62ef8f2dbf1ac0a197310f2be69c93b89f838c2", "target": 0, "func": "static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)\n\n{\n\n    int ch, bw_code;\n\n\n\n    if (cutoff) {\n\n        /* calculate bandwidth based on user-specified cutoff frequency */\n\n        int fbw_coeffs;\n\n        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);\n\n        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;\n\n        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);\n\n    } else {\n\n        /* use default bandwidth setting */\n\n        /* XXX: should compute the bandwidth according to the frame\n\n           size, so that we avoid annoying high frequency artifacts */\n\n        bw_code = 50;\n\n    }\n\n\n\n    /* set number of coefficients for each channel */\n\n    for (ch = 0; ch < s->fbw_channels; ch++) {\n\n        s->bandwidth_code[ch] = bw_code;\n\n        s->nb_coefs[ch]       = bw_code * 3 + 73;\n\n    }\n\n    if (s->lfe_on)\n\n        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */\n\n}\n", "idx": 17203, "substitutes": {"s": ["a", "services", "hs", "ds", "cs", "os", "ops", "t", "w", "settings", "p", "sb", "details", "ins", "als", "sq", "aws", "h", "qs", "is", "bs", "e", "g", "sv", "rs", "gs", "S", "ss", "so", "conv", "sw", "ns", "v", "sts", "vs", "se", "aps", "sports", "ps", "sys", "js", "ex", "service", "c", "ants", "es", "ats", "r", "comm", "eps", "n", "fs", "less", "ts", "ssl", "ls", "ims", "stats", "spec", "sc", "bis", "status", "its", "comments"], "cutoff": ["dropdown", "limitpoint", "celloffer", "cuttingoffset", "limitoffset", "celloff", "limitfunction", "cutoffer", "cutOff", "utOff", "cutfunction", "CutOff", "utoffs", " cutoffer", "utoffset", " cutdown", "cutdown", "payfunction", "cutpoint", "cutoffset", "Cutoffset", "dropoffset", " cutoffs", "bitoff", "paypoint", " cutoffset", "cuttingpoint", "cuttingoff", "paydown", "dropOff", "bitoffs", "Cutoffs", "payoffset", "bitoffset", "Cutoff", "payoff", "limitoff", "bitoffer", "dropoffs", " cutOff", "payoffer", "celloffs", "celloffset", "dropoff", "utoff", "cutoffs", "dropoffer", "cuttingfunction"], "ch": ["br", " CH", "chart", "history", "channel", "sch", "el", "chron", "chu", "sk", "ach", " chip", "p", "i", "kh", "sh", "ich", "cell", "qu", "client", "bot", "h", "th", "Ch", "q", "cl", "chip", "cur", "ht", " unch", "ot", "cht", "CH", " chunk", "v", "anch", "isch", "k", "ih", "ay", "chan", "c", "ind", "j", "ble", "bat", "wh", "batch", "mk", "ph", "zh", "och", "cho", "x", "pl", "tch", "uch", "go", "ech", "chn", "cp", "cha", "y", "col", "chat"], "bw_code": ["bw___code", "bwk_ode", "bwk_mode", "bag_code", "bw_Code", "bwareStatusode", "bag_Code", "bwa_Code", "bag_codes", "bsw_code", "bwStatusclass", "bwStatuscode", "bwareStatuscode", "bw_coded", "bwStatusode", "bw_ode", "bagmycodes", "bagmycoded", "bagmycode", "bsw_channel", "bw__ode", "bw___div", "bwStatuscodes", "bware_code", "bwmycodes", "bw__class", "bsw_div", "bware_ode", "bwk_Code", "bw___channel", "bw_channel", "bw__codes", "bwa_codes", "bw_mode", "bw_class", "bware_codes", "bware_class", "bwmycode", "bsw_codes", "bw__code", "bw___codes", "bwa_line", "bwareStatusclass", "bag_coded", "bwmycoded", "bw_line", "bwk_code", "bwmyCode", "bwa_code", "bw_div", "bw_codes", "bwareStatuscodes", "bagmyCode"], "fbw_coeffs": ["fbw_coeffices", "fbw_Coeffls", "fbw_coefficS", "fbw_coofls", "fbw_cofficts", "fbw_coeffts", "fbw_Coffls", "fbw_coff_", "fbw_coefS", "fbw_coffS", "fbw_coof_", "fbw_coofs", "fbw_Coeffs", "fbw_coefficls", "fbw_coeffS", "fbw_cofficls", "fbw_goeffices", "fbw_coffics", "fbw_coefes", "fbw_coef_", "fbw_coeffes", "fbw_coefficts", "fbw_goeffs", "fbw_coefls", "fbw_cofficS", "fbw_goeffS", "fbw_goeffes", "fbw_coeffls", "fbw_goeffics", "fbw_coefs", "fbw_coffes", "fbw_coefts", "fbw_Coeff_", "fbw_coffls", "fbw_Coff_", "fbw_Coffs", "fbw_goefficS", "fbw_coffs", "fbw_coofS", "fbw_coeffics", "fbw_CoffS", "fbw_coeff_", "fbw_CoeffS"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"movq \"MANGLE(bm01010101)\", %%mm4           \\n\\t\"\n\n        \"mov                    %0, %%\"REG_a\"       \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq    (%1, %%\"REG_a\",4), %%mm0           \\n\\t\"\n\n        \"movq   8(%1, %%\"REG_a\",4), %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"psrlw                  $8, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm0           \\n\\t\"\n\n        \"movq                %%mm0, %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"pand                %%mm4, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm0, %%mm0           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm1           \\n\\t\"\n\n        \"movd                %%mm0, (%3, %%\"REG_a\") \\n\\t\"\n\n        \"movd                %%mm1, (%2, %%\"REG_a\") \\n\\t\"\n\n        \"add                    $4, %%\"REG_a\"       \\n\\t\"\n\n        \" js                    1b                  \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        dstU[i]= src1[4*i + 1];\n\n        dstV[i]= src1[4*i + 3];\n\n    }\n\n#endif\n\n    assert(src1 == src2);\n\n}\n", "idx": 17206, "substitutes": {"dstU": ["ddestU", "dstO", "dsetEU", "fdstBU", "dstoreO", "dstUV", "dstoreU", "dstru", "fdstO", "dSTUV", "dputUT", "dostU", "fdostBU", "dstEU", "fdostU", " dSTUT", "dndUp", "dputUp", "fdostO", "dSTU", "fdostUD", "dstrEU", " ddestu", " dstO", " dstu", "dSTUT", "dndU", "dstUT", "dndUV", "dstUp", " dstUV", "dostUD", "dsetU", " ddestO", "dmtO", "dostBU", " dstUp", "dputU", "fdstUD", "dstoreUD", "ddestO", "dstrU", "dputUV", "dstBU", " dSTUV", "ddestEU", "dostO", " dSTUp", " dstUT", "dstUD", " ddestU", "dsetu", " ddestEU", " dSTU", "dstoreBU", "dmtBU", "dndUT", "fdstU", "dSTUp", " dstEU", "dstrO", "dsetO", "dmtU", "ddestu", "dstu", "dmtUD"], "dstV": [" dndG", " dndVI", "srcN", "dsrcU", "dcpUV", "dcpJ", " dndV", "ddestV", "dstUV", "ddestL", "dSTUV", "dndVI", "ddestUV", "drcN", "dportU", "srcV", "srcU", "sstVI", " dSTV", "ddestJ", "dputN", "dndU", " dstUV", "dndG", "sstU", "dstL", "dportVI", "dstG", "dputU", "srcVI", " dstL", "dSTL", "dsrcG", "dsrcV", "dndV", "dportV", " dstVI", "drcV", "sstN", "drcVI", " dSTUV", " dSTL", "dcpL", " dstG", "sstV", " dSTJ", "dsrcVI", "dputVI", "drcU", "dstN", "dSTJ", "dstJ", "dndN", "dstVI", " dndU", "dcpV", "dSTV", "dputV", " dstJ", "dportG"], "src1": ["inst0", "rc0", "inst2", "source3", "sourceOne", "supp1", "supp2", " srcOne", "rc4", "rc1", "src0", "source0", "source1", "inst4", "rc2", "inst1", "rc3", "rcOne", "source2", " src3", "src3", "supp0", "srcOne", " src0", "source4", "src4"], "src2": ["rc0", "source3", "rc5", "src5", "rc1", "src0", "source0", "source1", "rc2", "rc3", "source2", " src3", "src3", " src5", " src0", "source5"], "unused": ["unchecked", "Unchecked", "unUsed", " unchecked", "Unused", "unalused", "UnUsed", " unuse", "unaluse", "Unuse", "unalUsed", " unUsed", "unalchecked", "unuse"], "i": ["li", "span", "ri", "point", "I", "ai", "di", "mi", "M", "gu", "chain", "ex", "multi", "ii", "index", "ij", "ci", "sp", "\u0438", "phi", "v", "cli", "pi", "parent", "gi", "n", "bi", "zi", " err", "ini", "f", "it", "iu", "status", "err", "init", "ic", "slice", "ei", "qi", "me", " ii", "name", " j", "j", "ti", "print", " I", "ami", "uri", "info", "php", "ix", "b", "m", "si", "ki", "remote", "is", "out", "oi", "ind", "in", "id", "xi", "r", "batch", "ui", "key", " v", "sim", "us", "this"]}}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "func": "static void xtensa_kc705_init(MachineState *machine)\n\n{\n\n    static const LxBoardDesc kc705_board = {\n\n        .flash_base = 0xf0000000,\n\n        .flash_size = 0x08000000,\n\n        .flash_boot_base = 0x06000000,\n\n        .flash_sector_size = 0x20000,\n\n        .sram_size = 0x2000000,\n\n    };\n\n    lx_init(&kc705_board, machine);\n\n}\n", "idx": 17240, "substitutes": {"machine": ["iso", "connection", "history", "zone", "process", "channel", "money", "cell", "me", "sm", "domain", "STATE", "handler", "power", "device", "normal", "model", "config", "library", "agent", "ch", "session", "achine", "vm", "instance", "self", "Machine", "monitor", "mass", "manager", "parent", "template", "world", "module", "state", "network", "shell", "sim", "chain", "policy", "dem", "spin", "task", "m"]}}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,\n\n                               unsigned int len)\n\n{\n\n    unsigned int offset;\n\n    int i;\n\n\n\n    offset = 0;\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n\n                                  elem->in_sg[i].iov_len,\n\n                                  1, size);\n\n\n\n        offset += size;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++)\n\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n\n                                  elem->out_sg[i].iov_len,\n\n                                  0, elem->out_sg[i].iov_len);\n\n}\n", "idx": 17242, "substitutes": {"vq": ["vqu", "fqu", " vque", "fue", " vue", "vpq", "vue", "fque", "vque", "vpqu", "vpue", "fq", "vpque", " vqu"], "elem": ["edlem", "beom", "eom", " ept", "eoe", "belete", "ensell", "eept", "eelem", "edom", "eterm", "eleg", " eoe", "belem", "emn", "ell", "edlements", "execlement", "eleelement", "elelete", "eld", "elelem", " ell", "seelev", "elete", "edlement", " elems", "oelement", "meterm", " eterm", " elete", " eleg", "felement", "gelement", "execoe", "celev", "enselem", "delem", "elements", "celeg", "Elev", "elell", "eleterm", "delev", "Elem", "celems", "felem", "gelem", "feterm", "entlem", " element", "eleom", "gelev", " elev", "execlem", "eelement", "seemn", "seelem", "Elems", "seelement", "entlement", "entld", " eom", "ept", "element", "oemn", " elements", "felems", "celem", "eeld", "oelev", " emn", "geleg", "execlev", "melems", "entpt", "melement", "enseelement", "celement", "elelements", "melem", "elelement", "delement", "deoe", "elems", "Element", " eld", " eelement", "belement", "oelem", "elev", "enseterm"], "len": ["pos", "lp", "mem", "l", "el", "size", "t", "lon", "lf", "en", "list", "ll", "end", "le", "count", "il", "length", "all", "ln", "bytes", "limit", "ptr", "nn", "addr", "nl", "kl", "L", "cmp", "lc", "n", "lan", "ls", "un", "full", "Len", "elt", "seq", "hl"], "offset": ["a", "pos", "Offset", "index", "loc", "error", "l", "seed", "location", "size", "t", "window", "offs", "max", "pad", "set", "shift", "end", "base", "le", "point", "ace", "map", "prefix", "padding", "initial", "length", "position", "off", "address", "seek", "scroll", "start", "pointer", "limit", "mask", "reset", " size", "oid", "et", "origin", "table", "o", "align", "bound", "space", "alias", "SIZE", "attribute", "buffer", "tile", "OFF", "trace", "oe"], "i": ["ski", "li", "ri", "e", "g", "point", "I", "ai", "di", "mi", "ji", "gu", "chain", "series", "multi", "ii", "index", "ij", "ci", "list", "\u0438", "phi", "v", "cli", "pi", "json", "my", "parent", "gi", "fi", "bi", "x", "zi", "ini", "f", "it", "iu", "status", "init", "ic", "ei", "qi", " ti", "me", " ii", "name", "ip", "any", " j", "j", "ti", "print", " I", "ami", "uri", "source", "info", "go", " bi", "ix", "y", "m", "history", "si", "im", "ki", "at", "remote", "is", "oi", "ind", "id", "in", "xi", "ui", "batch", "ims", "sim", "this"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n", "idx": 17246, "substitutes": {"state": ["error", "st", "test", "base", "resource", "ace", "point", "self", "se", "local", "space", "cache", "shell", "trust", "spec", "check", "t", "list", "q", "port", "device", "output", "initial", "S", "command", "start", "call", "range", "up", "estate", "scope", "n", "al", "stats", "status", "trans", "init", "l", "style", "close", "State", "the", "STATE", "stat", "name", "print", "request", "info", "policy", "states", "m", "see", "history", "component", "p", "store", "h", "is", "config", "out", "area", "that", "monitor", "tag", "current", "now", "this", "trace"], "queue": ["grid", "quote", "frame", "ue", "channel", "question", "pipe", "ques", "qu", "menu", "list", "test", "Queue", "q", "port", "\u00fc", "buf", "prefix", "command", "force", "archive", "stack", "ued", "range", "msg", "req", "Q", "pool", "batch", "line", "message", "space", "sequence", "cache", "block", "topic", "entry", "que", "buffer", "ux", "f", "seq", "file", "dq"], "errp": ["erpe", "errps", "cerpa", "ererpa", " errpa", "errorp", "errorP", "ererP", "cerpc", "cerp", "ererpc", "errpa", "erp", "errpc", " errpc", "erps", " errps", "errpe", "ererp", "errP", " errpe", "cerP", "errorps", "erP", " errP", "errorpe"], "s": ["a", "hs", "ds", "sam", "cs", "os", "si", "sh", "sb", "p", "sp", "ses", "ins", "als", "sq", "h", "sm", "set", "qs", "is", "bs", "g", "south", "sv", "rs", "gs", "sa", "S", "ss", "so", "sw", "ns", "sts", "se", "ps", "sys", "ast", "js", "j", "es", "ats", "n", "fs", "less", "space", "ts", "ssl", "ls", "ims", "shell", "stats", "ms", "series", "serv", "sl", "b"], "i": ["init", "ic", "index", "ij", "si", "t", "ci", "im", "hi", "p", "ei", "ki", "qi", "me", "li", "\u0438", "ri", "I", " ii", "ai", "phi", "name", "ori", "iq", "v", "di", "io", "cli", "ip", "mi", "pi", "oi", "ind", " j", "j", "xi", "ti", "ui", "batch", "gi", "o", " I", "ji", "multi", "uri", "key", "fi", "bi", "fire", "x", "ims", "info", "zi", "ini", "sim", " bi", "gu", "it", "ix", "iu", "y", "ii", "m"], "e": ["a", "ea", "ue", "el", "l", "t", "de", "p", "ei", "EEE", "ec", "eeee", "ne", "le", "ge", "ae", "ibe", "g", "eur", "te", "u", "se", "ef", "ee", "ye", "entity", "es", "r", "ev", "et", "element", "est", "o", "eff", "ze", "ele", "eu", "ce", "er", "ent", "xe", "be", "E", "ie", "f", "eg", "ed", "eb", "pe", "ex", "it", "b", "oe"]}}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static inline void tcg_out_goto_label(TCGContext *s, int label_index)\n\n{\n\n    TCGLabel *l = &s->labels[label_index];\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);\n\n        tcg_out_goto_noaddr(s);\n\n    } else {\n\n        tcg_out_goto(s, l->u.value_ptr);\n\n    }\n\n}\n", "idx": 17258, "substitutes": {"s": ["a", "sc", "ds", "cs", "os", "scl", "sg", "t", "w", "i", "sb", "p", "ses", "ins", "sq", "h", "q", "sm", "set", "ctx", "qs", "is", "g", "south", "sv", "rs", "gs", "S", "ss", "sw", "session", "ns", "sts", "ties", "se", "self", "ps", "sys", "js", "c", "j", "es", "ats", "r", "comm", "n", "fs", "space", "source", "ts", "x", "ims", "ls", "an", "us", "sl", "b", "its"], "label_index": ["label_number", "label___len", "label_i", "label_num", " label_number", "label___pos", "label___index", " label_pos", " label_axis", "l_index", "label___number", "l_num", "label_len", "label_axis", "label_Index", "label_pos", " label_len", "l_Index", " label_i", "l_i"], "l": ["lp", "lv", "el", "b", "p", "dL", "ll", "ml", "li", "le", "lu", "g", "dl", "il", "NL", "v", "ln", "label", "lt", "jl", "rl", "nl", "j", "L", "kl", "lc", "la", "ls", "pl", "ld", " m", " lit", "lay", " pl", "ol", "yl", "sl", "tl", "lis", "lr", "lb", "m"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_map (PCIDevice *pci_dev, int region_num,\n\n                      uint32_t addr, uint32_t size, int type)\n\n{\n\n    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;\n\n    AC97LinkState *s = &d->ac97;\n\n\n\n    if (!region_num) {\n\n        s->base[0] = addr;\n\n        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);\n\n        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);\n\n        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);\n\n        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);\n\n        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);\n\n        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);\n\n    }\n\n    else {\n\n        s->base[1] = addr;\n\n        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);\n\n        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);\n\n        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);\n\n        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);\n\n        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);\n\n        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);\n\n    }\n\n}\n", "idx": 17266, "substitutes": {"pci_dev": ["pci__Dev", "pci_Dev", "pct_device", "pdi_dev", "pci2ev", "pdi_Dev", "pdi_ev", "pci__dev", "pci2device", "pci2dev", "pdi_device", "pci_device", "pci2Dev", "pct_Dev", "pci__ev", "pci__device", "pci_ev", "pct_dev", "pct_ev"], "region_num": [" region_um", "region_um", "Region1no", "region_mon", "region_no", "region0num", " region_mon", "region_nom", "Region1nom", " region_NUM", "region0no", "region0mon", "Region_num", "Region_nom", "region1no", "region_NUM", "Region1num", "Region_mon", "Region_no", "region1num", "Region1mon", "region1mon", "region0nom", "region1nom"], "addr": ["ag", "pad", "hash", "ctx", "rt", "hd", "lat", "ad", "obj", "sys", "req", "dir", "rid", "host", "url", "hl", "offset", "eth", "mem", "index", "np", "var", "sp", "port", "ha", "on", "handle", "add", "msg", "pkg", "align", "usr", "arch", "x", "Address", "urg", "elt", "err", "res", "ord", "adr", "prefix", "alloc", "address", "attr", "ptr", "ip", "js", "order", "ash", "str", "act", "alt", "fx", "rc", "arp", "gt", "ix", "gate", "pos", "grad", "arr", "store", "at", "map", "off", "db", "dr", "wd", "conn", "rev", "cmd", "id", "ext", "rel", "ref", "r", "mg", "coord", "dh", "src", "phys", "iat"], "size": ["offset", "mem", "loc", "z", "sh", "max", "desc", "st", "set", "scale", "sy", "count", "g", "length", "iz", "name", "address", "bytes", "fee", "sn", "msg", "ize", "body", "Size", "ram", "len", "mode"], "type": ["error", "style", " t", "t", "p", " typ", "dt", "ype", "op", "name", "address", "start", "kind", "typ", " ty", "types", "time", "id", "TYPE", "tag", "state", " TYPE", "Type", " Type", "pe", "y"], "d": ["ds", "fd", "z", "l", "w", "de", "p", "dt", "dj", "md", "dal", "result", "mod", "g", "dl", "dat", "done", "bd", "des", "ct", "m", "ad", "db", "v", "di", "cd", "da", "k", "add", "sd", "rd", "c", "json", "ind", "id", "dm", "j", "r", "pd", "send", "new", "dos", "dom", "D", "n", "o", "dc", "du", "dict", "del", "dh", "er", "ld", "red", "dx", "f", "it", "ed", "der", "b", "y", "dd", "dn"], "s": ["a", "ds", "os", "t", "w", "i", "p", "sb", "sp", "store", "sq", "h", "set", "is", "bs", "e", "sv", "rs", "gs", "S", "ss", "ns", "sts", "v", "se", "ps", "sys", "js", "sd", "spec", "c", "r", "n", "fs", "ts", "ssl", "stats", "sis", "b", "bis", "y", "m"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 17267, "substitutes": {"dev": ["mem", "ds", "nt", "w", "de", "Dev", "md", "dis", "device", "DEV", "cam", "des", "ad", "pro", "sw", "v", "serial", "hw", "sd", "det", "dm", "att", "ev", "def", "ver", "dem", "serv", "dd"], "vmsd": ["vmesds", "mmsdk", "vpsn", "mmsd", "vmsdn", "mmessd", "vtsd", "vvsD", "vmsdk", "vmssd", "vmsn", "mmesn", "vmsds", "vpsD", "vpsds", "vvsdn", "mtssd", "mmsdn", "mtsd", "vomsd", "mmesd", "mtsdk", "vpsdn", "vvssd", "vtsdk", "vomsds", "vvsd", "mmesD", "vpssd", "mtsds", "mmsD", "vomsdk", "vmesdn", "mmsn", "vvsn", "vmsD", "vomssd", "vvsds", "vpsd", "mmesds", "vmesn", "vvsdk", "vmesd", "vmesD", "vmessd", "mmesdn", "mmssd", "vtssd", "vtsds", "mmsds"], "opaque": [" opaco", "compacement", "Opaque", "opasus", "ospaque", "opacement", "ospacement", "bitadic", " opulence", "opatile", "ipasus", "opaco", "Opasus", "oppadic", "ipulence", "oppaco", " opadic", "oppacity", "compacity", "ospacity", " opasus", "Opacity", "ipatile", "opadic", "oppaque", "ipacity", "compatile", "opulence", "compaque", "Opulence", "bitacity", " opacity", "opacity", "ipaque", "ospatile", "bitaque", "bitaco", "ipacement"], "se": ["see", "ue", "sel", "sl", "sea", "ses", "SE", "he", "we", "ry", "sle", "set", "ne", "le", "ke", "ge", "ae", "te", "e", "ace", "sv", "sa", "ase", "ense", "so", "send", "sec", "sem", "ste", "ve", "ide", "ade", "ene", "try", "es", "Se", "sed", "she", "est", "ze", "ele", "ine", "ce", "sex", "pse", "ent", "exe", "sche", "cle", "spe", "entry", "ie", "pe", "parse", "ese", "ser"], "new_se": ["new__ge", " new_ge", "new__se", "new_ge", "new_sel", " new_sel", "new__sel", "new_ke", "new_pe", " new_ce", "new__ce", " new_pe", "new_ce", " new_ke"]}}
{"project": "qemu", "commit_id": "47d3df2387ed6927732584ffa4159c26d9f4dee8", "target": 0, "func": "static int xenfb_send_motion(struct XenInput *xenfb,\n\n\t\t\t     int rel_x, int rel_y, int rel_z)\n\n{\n\n    union xenkbd_in_event event;\n\n\n\n    memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n\n    event.type = XENKBD_TYPE_MOTION;\n\n    event.motion.rel_x = rel_x;\n\n    event.motion.rel_y = rel_y;\n\n#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207\n\n    event.motion.rel_z = rel_z;\n\n#endif\n\n\n\n    return xenfb_kbd_event(xenfb, &event);\n\n}\n", "idx": 17274, "substitutes": {"xenfb": [" xopenframework", "xenframework", "xENframework", "txoenplug", "xoenfb", "txoenwb", " xopenfab", "xENfb", "xenwb", "xenplug", " xenbb", "xeenfb", "xensenfb", "xopenfab", " xenfab", "xenbb", "xedenframework", "xopenbb", "txenwb", "xopenframework", "xoenfab", "xedenfb", " xenframework", "xenfab", "xeenplug", "xopenfb", "xoenwb", "txenfab", "txenfb", "xedenbb", "xeenfab", "xeenwb", "txoenfab", "xensenfab", "xedenfab", "txoenfb", "xensenplug", "xensenwb", "xENbb", " xopenbb", "xENfab", "xoenplug", "txenplug", " xopenfb"], "rel_x": ["rel_ex", "relixz", "rel_xs", "relixy", "relixwx", "rel__x", "relactex", "relactfull", "attrityx", "rel_width", "attr_width", "broadixwx", "broadixz", "relityxp", " rel__m", "relityxs", " rel__x", "broad_x", "broad_z", "attrityxs", "rel_xp", "broadixx", "attritywidth", "attr_xs", " rel_ex", " rel__ex", " rel_full", " rel_m", "rel_wx", "rel__ex", "attrityxp", "rel_m", "attr_x", " rel__full", "broadixy", "rel__m", "rel__full", "rel_full", "relitywidth", "relixx", "broad_wx", "relactm", "relactx", "relityx", "broad_y", "attr_xp"], "rel_y": ["rep_Y", "rep_x", "repaxyp", "relaxyy", "rel_p", "reljx", "relityy", "ref_x", "reljy", "repaxyx", "rel_target", "reljtarget", "rel2Y", "rel_ya", "reljz", "rel_yt", "rel_lon", "repaxyyt", "rep_ya", "repaxyy", "rep_y", "ref_z", "rep_yt", "rep_lon", "relaxyp", "rep_p", "relityp", "relityyt", "ref_y", "rel_Y", "relityx", "ref_target", "relaxyx", "rel2y", "relaxyyt", "rel2lon", "rel2ya"], "rel_z": ["rel_zh", "ref_pos", "rel_cos", " rel_zh", "relmtZ", "relaxyz", "relaxyuz", "relptpos", "ref_Z", "rel_uz", "relmtpos", "compl_pos", "relmtz", "compl_z", "ref_z", "rel_Z", "relptz", "relmtcos", "ref_cos", "relptcos", "relaxypos", "relptZ", "compl_uz", "rel_pos"], "event": ["error", "ception", "test", "handler", "e", "exc", "point", "vent", "header", "Event", "se", "self", "object", "ee", "commit", " ev", "context", "attribute", " message", "import", "spec", "alert", "frame", "index", "ame", "t", " exception", "result", "app", "on", "device", "output", " e", "initial", "command", "content", "response", "msg", "json", "dev", " events", "condition", "post", "complete", "ent", "ack", " err", "entry", "view", "task", "after", "style", "comment", " msg", "load", "name", "address", "all", "session", "instance", " arg", "ev", " image", "cal", "act", "claim", "request", "state", "network", "info", "policy", "text", " error", "component", "action", "age", "config", "empty", "press", "reason", "out", "image", "entity", "tag", "message", "package", " exc", "advert", "except", "full", "rule"]}}
{"project": "FFmpeg", "commit_id": "435535e41159fbe7423a12078d684329a554776d", "target": 1, "func": "static int read_header(AVFormatContext *s,\n\n                       AVFormatParameters *ap)\n\n{\n\n    JVDemuxContext *jv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *vst, *ast;\n\n    int64_t audio_pts = 0;\n\n    int64_t offset;\n\n    int i;\n\n\n\n    avio_skip(pb, 80);\n\n\n\n    ast = av_new_stream(s, 0);\n\n    vst = av_new_stream(s, 1);\n\n    if (!ast || !vst)\n\n        return AVERROR(ENOMEM);\n\n\n\n    vst->codec->codec_type  = CODEC_TYPE_VIDEO;\n\n    vst->codec->codec_id    = CODEC_ID_JV;\n\n    vst->codec->codec_tag   = 0; /* no fourcc */\n\n    vst->codec->width       = avio_rl16(pb);\n\n    vst->codec->height      = avio_rl16(pb);\n\n    vst->nb_frames          =\n\n    ast->nb_index_entries   = avio_rl16(pb);\n\n    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);\n\n\n\n    avio_skip(pb, 4);\n\n\n\n    ast->codec->codec_type  = CODEC_TYPE_AUDIO;\n\n    ast->codec->codec_id    = CODEC_ID_PCM_U8;\n\n    ast->codec->codec_tag   = 0; /* no fourcc */\n\n    ast->codec->sample_rate = avio_rl16(pb);\n\n    ast->codec->channels    = 1;\n\n    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);\n\n\n\n    avio_skip(pb, 10);\n\n\n\n    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));\n\n    if (!ast->index_entries)\n\n        return AVERROR(ENOMEM);\n\n\n\n    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));\n\n    if (!jv->frames)\n\n        return AVERROR(ENOMEM);\n\n\n\n    offset = 0x68 + ast->nb_index_entries * 16;\n\n    for(i = 0; i < ast->nb_index_entries; i++) {\n\n        AVIndexEntry *e   = ast->index_entries + i;\n\n        JVFrame      *jvf = jv->frames + i;\n\n\n\n        /* total frame size including audio, video, palette data and padding */\n\n        e->size         = avio_rl32(pb);\n\n        e->timestamp    = i;\n\n        e->pos          = offset;\n\n        offset         += e->size;\n\n\n\n        jvf->audio_size = avio_rl32(pb);\n\n        jvf->video_size = avio_rl32(pb);\n\n        jvf->palette_size = avio_r8(pb) ? 768 : 0;\n\n\n\n        if (avio_r8(pb))\n\n             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");\n\n        jvf->video_type = avio_r8(pb);\n\n        avio_skip(pb, 1);\n\n\n\n        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;\n\n        audio_pts += jvf->audio_size;\n\n\n\n        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;\n\n    }\n\n\n\n    jv->state = JV_AUDIO;\n\n    return 0;\n\n}", "idx": 17280, "substitutes": {"s": ["a", "snap", "hs", "ds", "cs", "os", "t", "sg", "p", "sb", "as", "ses", "ins", "proc", "sq", "aws", "bp", "is", "pc", "bs", "span", "g", "sv", "rs", "gs", "S", "ss", "aus", "v", "ns", "sts", "ps", "sys", "js", "c", "in", "j", "es", "ats", "comm", "n", "fs", "ts", "ls", "ms", "sc", "b", "its", "m"], "ap": ["cap", "am", "np", "pp", " mp", "sp", "amp", "tap", "bp", "ar", "ape", "op", "tp", " p", "aps", "ip", "ps", "mp", "att", " sap", "apt", "pl", " sp", "ep", "pa", "al", "cp", "ac"], "jv": ["gv", "jvp", "jvc", "jj", "JV", " jj", "jjj", "jjtv", " jvr", "jjV", "jjvp", "jpvm", " jtv", " jvp", "jvm", "jV", "jpv", "Jvc", " jvc", " jV", "jjv", "jvr", "jjvr", "gtv", "jpvr", "jpj", "Jvp", "gvp", "jtv", " jvm", "jjvm", "jjvc", "Jv", "gvr"], "pb": ["td", "snap", "lp", "cv", "np", "tc", "dp", "wp", "sb", "p", "pp", "sp", "proc", "emb", "bb", "asm", "bot", "bp", "ctx", "ub", "pid", "pc", "fb", "ob", "span", "buf", "gc", "xp", "vp", "tp", "mt", "lb", "pg", "conv", "bj", "db", "tf", "wb", "stab", "vm", "obj", "pm", "tab", "typ", "mp", "nb", "PB", "pkg", "pt", "req", "erb", "pool", "jp", "tk", "bf", "gp", "rb", "ib", "oa", "cb", "pl", "txt", "pa", "uf", "resp", "cp", "fp", "eb", "b", "prot"], "vst": ["vST", "svse", "evST", "avst", "uvstd", "vrstd", "vstore", "verso", "jost", "webest", "avstd", "svst", "vrest", "vrstra", "cvost", " vsw", " vrest", "vect", "vust", " vstd", "vrst", "uvstra", " vust", "vso", "svstore", "svste", "svust", " vest", " vstore", "svth", "verth", " vso", "vste", "avrest", "jst", "ovost", "vestore", "svrest", "avust", "cvstra", "vpst", "ovust", "vstable", "evstd", "just", "avstable", "vth", "evstable", "verrest", "svso", "vstra", "webrest", " vct", "vpstd", "versw", "vpest", "ovst", " vste", " vstable", " vse", "vct", "jstra", "vstd", "svstd", "svsw", "vpstable", "vrST", "webstable", "svct", "uvst", " vth", "vrste", "avest", "vsw", "webst", "svest", "evstra", "vesw", "avth", "cvst", "vrust", "vrse", "evest", "cvust", "ovstra", "vest", "verust", "evst", "vse", "verst", "vost", "uvST"], "ast": ["am", "and", "ist", "ess", "st", "test", "aste", "ank", "aw", "esta", "hd", "av", "eas", "ace", "ase", "cast", "ad", "ait", "art", "rank", "apt", "af", "irst", "wal", "ah", "exec", "ost", "mem", "aster", "asts", "command", "ma", "sts", "ab", "access", "aid", "walk", "ain", "some", "post", "AST", "ts", "asting", "rest", "best", "ed", "past", "a", "amd", "wp", "as", "acl", "Ast", "tar", "ard", "mt", "all", "sw", "archive", "mast", "each", "any", "att", "asted", "master", "um", "std", "raw", "quest", "an", "tt", "ief", "md", "asm", "must", "store", "core", "aft", "empty", "ance", "inst", "ust", "est", "sta", "anc", "was", "ac", "stan"], "offset": ["next", "pos", "frame", "Offset", "index", "error", "location", "pad", "slot", "timeout", "set", "shift", "count", "annot", "point", "audio", "padding", "length", "amount", "position", "off", "address", "seek", "scroll", "start", "pointer", "data", "skip", "ref", "origin", "o", "metadata", "unk", "tile"], "i": ["a", "index", "ij", "z", "si", "l", "t", "ci", "im", "slice", "p", "err", "set", "li", "I", " ii", "u", "ai", "v", "di", "k", "iter", "ip", "mi", "pi", "c", " j", "id", "j", "xi", "r", "ui", "o", "n", "bi", "x", " bi", "f", "b", "y", "ii", "m"]}}
{"project": "FFmpeg", "commit_id": "4fb3efd2c17c419cb7a170e5438b35453ceaaf30", "target": 0, "func": "static int mov_write_colr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/_index.html#//apple_ref/doc/uid/DTS40013070-CH1-TNTAG9\n\n    // Ref (MP4): ISO/IEC 14496-12:2012\n\n\n\n    if (track->enc->color_primaries == AVCOL_PRI_UNSPECIFIED &&\n\n        track->enc->color_trc == AVCOL_TRC_UNSPECIFIED &&\n\n        track->enc->colorspace == AVCOL_SPC_UNSPECIFIED) {\n\n        if ((track->enc->width >= 1920 && track->enc->height >= 1080)\n\n          || (track->enc->width == 1280 && track->enc->height == 720)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt709\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT709;\n\n        } else if (track->enc->width == 720 && track->height == 576) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt470bg\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT470BG;\n\n        } else if (track->enc->width == 720 &&\n\n                   (track->height == 486 || track->height == 480)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming smpte170\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;\n\n        } else {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, unable to assume anything\\n\");\n\n        }\n\n        switch (track->enc->color_primaries) {\n\n        case AVCOL_PRI_BT709:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_BT709;\n\n            break;\n\n        case AVCOL_PRI_SMPTE170M:\n\n        case AVCOL_PRI_BT470BG:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_SMPTE170M;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* We should only ever be called by MOV or MP4. */\n\n    av_assert0(track->mode == MODE_MOV || track->mode == MODE_MP4);\n\n\n\n    avio_wb32(pb, 18 + (track->mode == MODE_MP4));\n\n    ffio_wfourcc(pb, \"colr\");\n\n    if (track->mode == MODE_MP4)\n\n        ffio_wfourcc(pb, \"nclx\");\n\n    else\n\n        ffio_wfourcc(pb, \"nclc\");\n\n    switch (track->enc->color_primaries) {\n\n    case AVCOL_PRI_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_PRI_SMPTE170M:\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_BT470BG:   avio_wb16(pb, 5); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->color_trc) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_TRC_SMPTE170M: avio_wb16(pb, 1); break; // remapped\n\n    case AVCOL_TRC_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->colorspace) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_SPC_BT470BG:\n\n    case AVCOL_PRI_SMPTE170M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n\n\n    if (track->mode == MODE_MP4) {\n\n        int full_range = track->enc->color_range == AVCOL_RANGE_JPEG;\n\n        avio_w8(pb, full_range << 7);\n\n        return 19;\n\n    } else {\n\n        return 18;\n\n    }\n\n}\n", "idx": 17288, "substitutes": {"pb": ["lp", "cv", "np", "tc", "dp", "wp", "px", "p", "pp", "sb", "bb", "emb", "amp", "tap", "bp", "ctx", "pc", "fb", "bs", "gc", "buf", "tmp", "vp", "bsp", "tp", "mb", "pg", "bj", "wb", "pm", "mp", "PB", "pkg", "pt", "erb", "pool", "jp", "tk", "rb", "cb", "pl", "pa", "uf", "resp", "cp", "buffer", "fp", "buff", "b", "lb"], "track": ["round", "Track", "ck", "report", "sound", "feature", "move", "rt", "setup", "rr", "tp", "req", "trip", "sync", "tk", "rank", "project", "kick", "metadata", "tm", "token", "jump", "check", "form", "sort", "trak", "list", "btn", "find", "care", "handle", "seek", "install", "upload", "tf", "stab", "add", "tab", "call", "pkg", "mont", "skip", "try", "trade", "met", "review", "summary", "complete", "follow", "ack", "rack", "task", "tracking", "jj", "comment", "query", "tr", "match", "stat", "send", "mt", "session", "att", "note", "transform", "claim", "contact", "txt", "row", "consider", "tt", "scan", "require", "work", "store", "tn", "roll", "cmd", "allow", "record", "batch", "train", "reflect", "package", "tracks", "sur", "search", "rule", "trace"]}}
{"project": "qemu", "commit_id": "eaf136f9a21e02a2f55346e44d2d88df37b2cde3", "target": 0, "func": "static int slirp_socket_load(QEMUFile *f, struct socket *so)\n\n{\n\n    if (tcp_attach(so) < 0)\n\n        return -ENOMEM;\n\n\n\n    so->so_urgc = qemu_get_be32(f);\n\n    so->so_ffamily = qemu_get_be16(f);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        so->so_faddr.s_addr = qemu_get_be32(f);\n\n        so->so_fport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_faddr and so_lport\\n\");\n\n    }\n\n    so->so_lfamily = qemu_get_be16(f);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        so->so_laddr.s_addr = qemu_get_be32(f);\n\n        so->so_lport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_laddr and so_lport\\n\");\n\n    }\n\n    so->so_iptos = qemu_get_byte(f);\n\n    so->so_emu = qemu_get_byte(f);\n\n    so->so_type = qemu_get_byte(f);\n\n    so->so_state = qemu_get_be32(f);\n\n    if (slirp_sbuf_load(f, &so->so_rcv) < 0)\n\n        return -ENOMEM;\n\n    if (slirp_sbuf_load(f, &so->so_snd) < 0)\n\n        return -ENOMEM;\n\n    slirp_tcp_load(f, so->so_tcpcb);\n\n\n\n    return 0;\n\n}\n", "idx": 17301, "substitutes": {"f": ["fed", "fd", "l", "fn", "of", "form", "t", "w", "inf", "z", "p", "F", "lf", "sf", "h", "q", "fb", "e", "fr", "g", "cf", "fac", "ct", "out", "m", "d", "xf", "v", "fe", "tf", "k", "ft", "ef", "ile", "ex", "c", "ff", "r", "um", "fo", "bf", "fi", "fc", "fs", "fm", "o", "y", "fa", "fx", "fw", "uf", "ac", "it", "fp", "rf", "full", "b", "conf", "file", "fl"], "so": ["iso", "ico", "hi", "ski", "li", "lah", "py", "ox", "pro", "di", "se", "obj", "sync", " o", "ce", "since", "cho", "cache", "dll", "su", "s", "yes", "sl", "sky", "os", "server", "oh", "sel", "sh", "sp", "where", "set", "le", "sum", "sy", "syn", "sa", "shi", "ss", "soc", "sn", "dev", "o", "usr", "cu", "ro", "ver", "esh", "sc", "po", "sam", "ho", "num", "ow", "th", "ne", " s", "co", "sw", "mo", "stro", "sing", "say", "thus", "fo", "ko", "stone", "ssl", "info", "go", "no", "oso", "see", "si", "So", "must", "bo", "bs", "out", "dylib", "ve", "inho", "SO", "lo", "sim", "rh", "oooo"]}}
{"project": "qemu", "commit_id": "22f2e344748370b2e13888ba1057ebea2579970c", "target": 0, "func": "static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)\n\n{\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\",\n\n                    info->name, info->bus_info->name);\n\n    if (info->alias)\n\n        pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias);\n\n    if (info->desc)\n\n        pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc);\n\n    if (info->no_user)\n\n        pos += snprintf(dest+pos, len-pos, \", no-user\");\n\n    return pos;\n\n}\n", "idx": 17307, "substitutes": {"info": ["init", "check", "help", "index", "history", "work", "error", "inf", "about", "os", "hi", "comment", "i", "details", "ki", "num", "report", "interface", "query", "where", "good", "jo", "Info", "ion", "op", "tif", "information", "py", "unknown", "name", "off", "address", "one", "doc", "iter", "kind", "add", " Info", "http", "tab", "success", "fee", "data", "req", "INFO", "update", "id", "try", "note", "local", "fo", "def", "job", "now", "follow", "fi", "request", "notice", "txt", "by", "entry", "f", "it", " inf", "exec", "parse", "show", "conf", "ii", "type"], "dest": ["temp", "pos", "loc", "ord", "deg", "w", "dist", "desc", "sp", "st", "test", "port", "decl", "end", "buf", "global", "dat", "tmp", "prop", "tr", "sec", "out", "d", "gov", "v", "ptr", "cont", "iter", "addr", "asc", "sys", "cat", "priv", "req", "target", "lit", "master", "rel", "dev", "origin", "neg", "est", "dc", "n", "path", "pas", "alt", "orig", "coord", "source", "Dest", "txt", "net", "rest", "chain", "src", "gen", "seq", "trans", "gate"], "len": [" length", "mem", "pos", " pos", "el", "yn", "l", "size", "t", "lon", "imm", "sp", " n", "en", " en", "ll", " le", "enc", "lf", "fil", "compl", "le", "mil", "syn", "vec", "wid", " l", "length", "name", "mat", "mun", "fin", "ln", "bytes", "iter", "inv", "lit", "den", "rel", "von", "val", "cmp", "ell", "coll", "n", "mult", " bl", " offset", "cond", "lan", "alt", " Len", "gn", "lim", "ls", "ld", "vol", "mid", "fun", "Len", "gen", " lang", "elt", "seq", "fl"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)\n\n{\n\n    int next_avc    = h->is_avc ? 0 : buf_size;\n\n    int nal_index   = 0;\n\n    int buf_index   = 0;\n\n    int nals_needed = 0;\n\n\n\n    while(1) {\n\n        int nalsize = 0;\n\n        int dst_length, bit_length, consumed;\n\n        const uint8_t *ptr;\n\n\n\n        if (buf_index >= next_avc) {\n\n            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);\n\n            if (nalsize < 0)\n\n                break;\n\n            next_avc = buf_index + nalsize;\n\n        } else {\n\n            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);\n\n            if (buf_index >= buf_size)\n\n                break;\n\n        }\n\n\n\n        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,\n\n                                 next_avc - buf_index);\n\n\n\n        if (ptr == NULL || dst_length < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        buf_index += consumed;\n\n\n\n        bit_length = get_bit_length(h, buf, ptr, dst_length,\n\n                                    buf_index, next_avc);\n\n        nal_index++;\n\n\n\n        /* packets can sometimes contain multiple PPS/SPS,\n\n         * e.g. two PAFF field pictures in one packet, or a demuxer\n\n         * which splits NALs strangely if so, when frame threading we\n\n         * can't start the next thread until we've read all of them */\n\n        switch (h->nal_unit_type) {\n\n        case NAL_SPS:\n\n        case NAL_PPS:\n\n            nals_needed = nal_index;\n\n            break;\n\n        case NAL_DPA:\n\n        case NAL_IDR_SLICE:\n\n        case NAL_SLICE:\n\n            init_get_bits(&h->gb, ptr, bit_length);\n\n            if (!get_ue_golomb(&h->gb))\n\n                nals_needed = nal_index;\n\n        }\n\n    }\n\n\n\n    return nals_needed;\n\n}\n", "idx": 17308, "substitutes": {"h": ["hs", "history", "l", "oh", "hh", "t", "w", "sh", "kh", "p", "he", "hz", "bh", "hash", "q", "ctx", "hd", "ht", "handle", "ch", "m", "v", "hw", "k", "self", "H", "ih", "c", "hm", "hp", "j", "dev", "r", "comm", "host", "context", "ph", "act", "rh", "ah", "f", "ac", "hal", "b", "event", "eh", "hl"], "buf": ["late", "mem", "cap", "cv", "Buff", "np", "aka", "arr", "box", "window", "p", "bar", "proc", "bh", "bp", "bag", "ob", "vec", "cur", "cf", "cam", "tmp", "vp", "queue", "bc", "alloc", "v", "bytes", "doc", "pb", "wb", "msg", "cmd", "pkg", "data", "foo", "batch", "raw", "bf", "rb", "cache", "txt", "cb", "block", "bin", "uf", "que", "cp", "buffer", "Buffer", "buff", "b", "seq", "ff", "br"], "buf_size": ["buf_SIZE", "buf00index", " buf_limit", "buf00string", "buf2scale", "buf2SIZE", "buf_type", " buf_index", " buf2size", "buff_type", " buf_length", "buf_scale", "buf_index", "buf00limit", "buf2size", "buf00size", " buf2speed", "uf_SIZE", "buff_index", "buff_length", " buf_string", " buf_scale", " buf_SIZE", "buf2length", "buf_limit", " buf2index", "buf_length", "buff_size", "buf2speed", " buf2length", "buf_string", "uf_index", "buf2index", "uf_size", " buf_speed", "buf_speed"], "dst_length": ["dst_len", "dsttLength", "dst_translation", "dstabletranslation", "dstableLength", "dst_Length", "dtd_shape", "dst___len", "dest_index", "dst_count", "dsttlength", "dest_Length", "dstablelength", "dst_distance", "dsttshape", "dstableshape", "dest_distance", "dst___length", "dest_len", "dst_index", "dsttindex", "dest_length", "dtdablelength", "dst_code", "dtdabletranslation", "dest_code", "dst___index", "dtd_length", "dtd_translation", "dtd_Length", "dest_count", "dtdableLength", "dtdableshape", "dsttlen", "dstttranslation", "dst___count", "dsttcount", "dst_shape"], "bit_length": ["bit_vector", "port5length", "block_length", "port_len", "bit_needed", "port_needed", "bit5Length", "bitmatinfo", "block48code", "bit36code", "port5needed", "bit5length", "block48info", "bit2needed", "bit_Length", " bit_distance", "port_length", "bitmatlength", " bit_Length", "block_code", "bit_info", "bit2length", "port5Length", "block_info", "bit36position", "block48length", "bit48code", "bit2len", "block_position", "bit48length", " bit_vector", "bit36info", "block48position", "bit5len", "port_Length", "bit48info", "bitmatcode", "bit2Length", "bit_len", "bit_position", "bit48position", "bit36length", "bit5needed", "bit_distance", "bit_code", "bitmatposition", "port5len"], "consumed": [" consuming", "preserved", "presume", " consume", "conserved", "conume", "csused", " unconsuming", "conumption", "consumption", " unconsumption", "Consused", "conumed", "presumed", "Consumption", "csumed", "csumption", "Consuming", "presumption", "cserved", "conused", " unconsumed", "Consumed", "consuming", "Consume", " consumption", "Conserved", "consused", " unconsume", "consume", "csume"], "ptr": ["next", "offset", "mem", "pos", "temp", "index", "td", "loc", "np", "arr", "Ptr", "pr", "pad", "p", "dep", "crop", "sp", "ctx", "rect", "pc", "cur", "copy", "cut", "tr", "tp", "alloc", "handle", "address", "rep", "pointers", "pointer", "dr", "inter", "iter", "push", "addr", "iv", "cmd", "pt", "ind", "j", "ref", "r", "jp", "coord", "ts", "prime", "inters", "rc", "buffer", "fp", "buff", "code", "ctr", "br", "err"], "nal_index": ["nal_Index", "nalixin", "nbal_index", "nale_value", "naldixindex", "nalixindex", "nald_offset", "nalixid", "naldixid", "nbal_ind", "nbal_level", "naldixoffset", "nbal_number", "nbal_Index", "naldixin", "nal_in", "nale_Index", "nal_value", "nald_in", "nal_number", "nald_index", "nald_id", "naltpoint", "nal_ind", "nal_point", "nal_id", "nalixoffset", "naltindex", "nale_index", "nal_level", "nbal_point", "nal_offset", "naltnumber"]}}
{"project": "qemu", "commit_id": "e514fc7e1231c6d95011e448e6c626f2bb6f3cd8", "target": 0, "func": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n\n                             const E1000E_RxRing *rxr,\n\n                             const E1000E_RSSInfo *rss_info)\n\n{\n\n    PCIDevice *d = core->owner;\n\n    dma_addr_t base;\n\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n\n    size_t desc_size;\n\n    size_t desc_offset = 0;\n\n    size_t iov_ofs = 0;\n\n\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n\n    size_t size = net_rx_pkt_get_total_len(pkt);\n\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n\n    const E1000E_RingInfo *rxi;\n\n    size_t ps_hdr_len = 0;\n\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n\n\n\n    rxi = rxr->i;\n\n\n\n    do {\n\n        hwaddr ba[MAX_PS_BUFFERS];\n\n        e1000e_ba_state bastate = { { 0 } };\n\n        bool is_last = false;\n\n        bool is_first = true;\n\n\n\n        desc_size = total_size - desc_offset;\n\n\n\n        if (desc_size > core->rx_desc_buf_size) {\n\n            desc_size = core->rx_desc_buf_size;\n\n        }\n\n\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n\n\n        if (ba[0]) {\n\n            if (desc_offset < size) {\n\n                static const uint32_t fcs_pad;\n\n                size_t iov_copy;\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > core->rx_desc_buf_size) {\n\n                    copy_size = core->rx_desc_buf_size;\n\n                }\n\n\n\n                /* For PS mode copy the packet header first */\n\n                if (do_ps) {\n\n                    if (is_first) {\n\n                        size_t ps_hdr_copied = 0;\n\n                        do {\n\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n\n                                           iov->iov_len - iov_ofs);\n\n\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                      iov->iov_base, iov_copy);\n\n\n\n                            copy_size -= iov_copy;\n\n                            ps_hdr_copied += iov_copy;\n\n\n\n                            iov_ofs += iov_copy;\n\n                            if (iov_ofs == iov->iov_len) {\n\n                                iov++;\n\n                                iov_ofs = 0;\n\n                            }\n\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n\n\n                        is_first = false;\n\n                    } else {\n\n                        /* Leave buffer 0 of each descriptor except first */\n\n                        /* empty as per spec 7.1.5.1                      */\n\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                       NULL, 0);\n\n                    }\n\n                }\n\n\n\n                /* Copy packet payload */\n\n                while (copy_size) {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n\n\n                    copy_size -= iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                }\n\n\n\n                if (desc_offset + desc_size >= total_size) {\n\n                    /* Simulate FCS checksum presence in the last descriptor */\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n\n                }\n\n            }\n\n            desc_offset += desc_size;\n\n            if (desc_offset >= total_size) {\n\n                is_last = true;\n\n            }\n\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n\n            trace_e1000e_rx_null_descriptor();\n\n        }\n\n\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n\n\n        e1000e_ring_advance(core, rxi,\n\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n\n\n    } while (desc_offset < total_size);\n\n\n\n    e1000e_update_rx_stats(core, size, total_size);\n\n}\n", "idx": 17314, "substitutes": {"d": ["ds", "fd", "l", "t", "w", "p", "dt", "h", "core", "e", "dq", "bd", "m", "ad", "db", "di", "cd", "da", "dr", "c", "dir", "id", "dm", "r", "dom", "D", "dc", "du", "dh", "dx", "did", "f", "dra", "b", "dd", "dn"], "base": ["bal", "offset", "index", "stable", "server", "size", "basic", "back", "pad", "i", "p", "client", "bar", "store", "h", "bp", "domain", "bo", "bas", "set", "kit", "bs", "end", "ase", "prefix", "based", "length", "address", "ias", "ma", "db", "m", "start", "da", "bid", "area", "bottom", "bit", "id", "bu", "parent", "origin", "root", "extra", "bound", "orig", "bi", "pa", "meta", "len", "f", "buffer", "it", "chain", "b", "file", "Base"], "desc": ["init", "mem", "loc", "res", "dist", "disc", "comment", "sub", "ctx", "err", "Desc", "ript", "buf", "bd", "des", "name", "rec", "pro", "label", "cd", "esc", "doc", "cont", "pb", "asc", "description", "msg", "req", "cmd", "dir", "ext", "cmp", "def", "dc", "DES", "dict", "txt", "ribe", "resp", "rc", "code", "rib", "sc", "seq"], "desc_size": ["comment67size", "desc67size", "Desc_sum", "descalheight", "comment_start", "desc10len", "dest_len", "Desc_offset", "dest10size", "desc10offset", "desc_offset", "dest_unit", "des_sum", "comment_size", "comment67height", "desc_sum", "Desc_size", "dest_offset", "desc67go", "desc_length", "des_ize", "desc_len", "desc_start", "comment67go", "desc67height", "dest10unit", "desc_unit", "dest10len", "des_size", "comment_height", "desc67start", "desc_go", "Desc_length", "dest_size", "descalstart", "desc_copy", "desc10unit", "dest10offset", "descalgo", "comment_go", "desc_height", "des_copy", "desc10size", "desc_ize", "comment67start", "descalsize"], "iov": ["iam", "server", "iph", "uart", "ei", "ever", "iw", "iop", "vp", "ilo", "conv", "v", "io", "ih", "verb", "iv", "vers", "veh", "ev", "voc", "rio", "vo", "vr", "inn", "serv", "iol", "iu", "river"], "rxi": ["Rfi", "rofi", " rpi", "roXi", " rci", "rozi", "rpi", "Rzi", "rri", "wci", "RXi", "rXi", "rmi", "Rxi", "rdfi", "roxi", "hci", "rci", "Rri", "hxi", "rori", "roci", "hXi", "wxi", "rdxi", "Rci", "rfi", "rdXi", "rtmi", "rtxi", "wXi", "rtci", " rXi", " rri", "wpi", "rtri", "rdri", "rzi", "rdci", " rmi", "hpi", "rdmi", " rzi"], "ba": ["a", "na", "ea", "bean", "aaaa", " br", "box", "ca", "rab", "ta", " a", "ra", "as", "bar", "bp", "ha", "BA", "bo", "va", "bs", "buf", "ava", "sa", "aco", "bd", "bc", "aa", " ca", "ka", "da", "pb", "wa", "bl", "ps", "aaa", "bu", "ena", "dc", "fa", " bl", "oa", "la", "aos", "pa", "aba", "ro", "abc", " BA", "una", " b", "b", "br"], "fcs_pad": ["fcsitysize", "fls_pad", "fcs__free", "fcs__pad", "fcs_free", "fcsityfree", "fls_free", "fcs_size", "fls__size", "fls_offset", "fcs__size", "fcs__offset", "fls__pad", "fcsityoffset", "fls__offset", "fls_size", "fls__free", "fcsitypad", "fcs_offset"], "iov_copy": ["io_offset", "io_repeat", "iovaccop", "iov_offset", "iov_cop", "io_cop", "io_copy", "iov_repeat", "iovaccopy", "iovacrepeat", "iovacoffset"]}}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static int cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n\n{\n\n    int sx = 0, sy = 0;\n\n    int dx = 0, dy = 0;\n\n    int depth = 0;\n\n    int notify = 0;\n\n\n\n    /* make sure to only copy if it's a plain copy ROP */\n\n    if (*s->cirrus_rop == cirrus_bitblt_rop_fwd_src ||\n\n        *s->cirrus_rop == cirrus_bitblt_rop_bkwd_src) {\n\n\n\n        int width, height;\n\n\n\n        depth = s->vga.get_bpp(&s->vga) / 8;\n\n        if (!depth) {\n\n            return 0;\n\n        }\n\n        s->vga.get_resolution(&s->vga, &width, &height);\n\n\n\n        /* extra x, y */\n\n        sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;\n\n        sy = (src / ABS(s->cirrus_blt_srcpitch));\n\n        dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;\n\n        dy = (dst / ABS(s->cirrus_blt_dstpitch));\n\n\n\n        /* normalize width */\n\n        w /= depth;\n\n\n\n        /* if we're doing a backward copy, we have to adjust\n\n           our x/y to be the upper left corner (instead of the lower\n\n           right corner) */\n\n        if (s->cirrus_blt_dstpitch < 0) {\n\n            sx -= (s->cirrus_blt_width / depth) - 1;\n\n            dx -= (s->cirrus_blt_width / depth) - 1;\n\n            sy -= s->cirrus_blt_height - 1;\n\n            dy -= s->cirrus_blt_height - 1;\n\n        }\n\n\n\n        /* are we in the visible portion of memory? */\n\n        if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\n            (sx + w) <= width && (sy + h) <= height &&\n\n            (dx + w) <= width && (dy + h) <= height) {\n\n            notify = 1;\n\n        }\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n\n                      s->vga.vram_ptr + s->cirrus_blt_srcaddr,\n\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n\n\n    if (notify) {\n\n        dpy_gfx_update(s->vga.con, dx, dy,\n\n                       s->cirrus_blt_width / depth,\n\n                       s->cirrus_blt_height);\n\n    }\n\n\n\n    /* we don't have to notify the display that this portion has\n\n       changed since qemu_console_copy implies this */\n\n\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t\ts->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t\ts->cirrus_blt_height);\n\n\n\n    return 1;\n\n}\n", "idx": 17325, "substitutes": {"s": ["bits", "details", "ges", "results", "g", "rs", "vs", "se", "self", "sys", "ants", "es", "comm", "rows", "fs", "params", "ex", "sis", "ows", "spec", "os", "ops", "t", "settings", "events", "qs", "S", "ss", "sts", "v", "ps", "erences", "ids", "ts", "ls", "parts", "stats", "bes", "bis", "eds", "reports", "ies", "ds", "cs", "l", "terms", "sb", "as", "ses", "changes", "als", "south", "sv", "grades", "sw", "js", "gets", "mods", "tests", "states", "has", "y", "hs", "args", "ins", "sq", "aws", "is", "bs", "gs", "ports", "ns", "sports", "ats", "r", "eps", "less", "reads", "ims", "ms", "conf", "its"], "dst": ["rth", " dnt", "ddest", "dsts", "nst", "gst", "hST", "rset", "hyn", " dST", " dost", "gST", "hth", "ddst", " dth", "ddyn", "hst", " dset", "dyn", "dST", "Dst", "gost", "dnt", " dsts", "dset", "hnt", "gnt", "host", "rst", "nth", "rsts", "nset", "nsts", "Dest", "Dyn", "dth", "ddth", "dost", "hest", "Dth", "dest"], "src": ["sc", "eth", "loc", "desc", "sub", "ins", "st", "sq", "th", "rx", "bh", "hr", "rt", "syn", "g", "cur", "sec", "v", "start", "ptr", "iv", "addr", "sys", "req", "in", "dir", "inst", "r", "sync", "std", "origin", "obs", "usr", "source", "txt", "sr", "fw", "rc", "vr", "urg", "ctr", "sl", "b", "dest", "ser", "lr", "rl", "hl"], "w": ["l", "weight", "window", "p", "ow", "rw", "th", "win", "we", "q", "iw", "g", "wid", "wl", "wt", "nw", "ch", "kw", "sw", "v", "wr", "d", "ew", "wa", "hw", "wb", "wx", "wd", "r", "wh", "ww", "wi", "W", "x", "fw", "ex", "y", "m"], "h": ["a", "hs", "ho", "hh", "oh", "l", "z", "t", "hl", "hi", "sh", "i", "p", "ish", "depth", "he", "hz", "bh", "q", "hash", "ha", "hr", "html", "hd", "e", "g", "ht", "ch", "d", "v", "hw", "ih", "head", "H", "c", "hm", "j", "r", "hei", "ph", "n", "x", "f", "b", "y", "hop", "m"], "height": ["history", "sky", "hh", "density", "size", "depth", "weight", "total", "window", "max", "gravity", "hang", "xy", "radius", "hash", "power", "scale", "html", "volume", "count", "ht", "shape", "resolution", "padding", "length", "ch", "v", "capacity", "ih", "time", "wh", "headers", "high", "ph", "hei", "rank", "dim", "x", "buffer", "angle", "ows", "ty", "Height", "y"]}}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17328, "substitutes": {"bs": ["hs", "ds", "cs", "lbs", "las", "outs", "bits", "BS", "sb", "ses", "blog", "als", "ubs", "aws", "bh", "bp", "gs", "ss", "bc", "aus", "ubis", "ns", "sts", "vs", "bos", "bes", "js", "iss", "obs", "cks", "fs", "acs", "ts", "aos", "ls", "ms", "b", "bis", "its"], "l1_index": ["l1__index", "l1__num", "l1__position", "l1_Index", "l7__index", "l3_index", "l7_index", "l3_position", "l3_address", "l1__address", "l1_label", "l1_ind", "l1_num", "l1__label", "l1_position", "l7__Index", "l1__Index", "l7__ind", "l7_Index", "l3_num", "l7__label", "l7_label", "l7_ind", "l1__ind", "l1_address"], "s": ["a", "ies", "hs", "ds", "cs", "os", "sb", "p", "ses", "ins", "sq", "aws", "h", "qs", "is", "sv", "rs", "gs", "serv", "S", "sa", "ss", "ns", "sts", "v", "vs", "ps", "sys", "sn", "js", "http", "css", "ats", "fs", "ts", "ssl", "ls", "stats", "sis", "b", "bis", "y", "its"], "buf": ["next", "mem", "cap", "cv", "arr", "window", "img", "desc", "var", "bar", "result", "rw", "port", "text", "ctx", "fb", "bag", "fr", "vec", "cam", "cf", "cur", "tmp", "tr", " buffer", "queue", "bc", "ctr", "alph", "v", "bytes", "pb", "iter", "bl", "wb", "tab", "data", "cmd", "pkg", "msg", "ref", "pool", "raw", "pack", "str", "rb", "txt", "cb", "block", "uf", "cp", "buffer", "loop", "Buffer", "eb", "buff", "code", "b", "seq", "ff", "br", "err"], "l1_start_index": ["l1_end_position", "l1_start_length", "l1_stop_ind", "l1_stop_index", "l1_end_Index", "l1_start_Index", "l1_stop_Index", "l1_end_length", "l1_end_index", "l1_start_point", "l1_start_position", "l1_start_len", "l1_start_ind", "l1_end_point", "l1_end_len"], "i": ["init", "a", "yi", "ic", "index", "ij", "l", "si", "or", "t", "ci", "im", "p", "qi", "me", "port", "li", "is", "\u0438", "span", "e", "ri", "point", "I", " ii", "ai", "phi", "iq", "v", "io", "di", "k", "iter", "ip", "mi", "pi", "my", "ind", " j", "in", "j", "xi", "inner", "c", "ti", "ui", "gi", "n", " I", "o", "multi", "print", "uri", "ji", "bi", "fi", "x", "ims", "zi", "ini", "sim", "ie", "it", "ix", "ms", "iu", "y", "ii", "m"], "ret": ["mem", "nt", "res", "pret", "arr", "t", "back", "deg", "git", "flag", "ter", "dt", "xt", "result", "ll", "Ret", "en", "err", "vet", "rt", "gc", "ben", "arg", "tr", "mt", "nz", "out", "tf", "ptr", "cont", "lt", "ft", "addr", "rem", "RET", "re", "det", "cmd", "ext", "try", "att", "r", "val", "def", "leg", "print", "fi", "usr", "alt", "aux", "txt", "len", "no", "it", "gt", "fun", "code", "elt", "status", "red", "rets"]}}
{"project": "qemu", "commit_id": "2ce68e4cf5be9b5176a3c3c372948d6340724d2d", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n                   VhostBackendType backend_type)\n{\n    uint64_t features;\n    int i, r;\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n        close((uintptr_t)opaque);\n        return -1;\n    }\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n        close((uintptr_t)opaque);\n        return -errno;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n    if (r < 0) {\n        goto fail;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n    if (r < 0) {\n        goto fail;\n    }\n    for (i = 0; i < hdev->nvqs; ++i) {\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, hdev->vq_index + i);\n        if (r < 0) {\n            goto fail_vq;\n        }\n    }\n    hdev->features = features;\n    hdev->memory_listener = (MemoryListener) {\n        .begin = vhost_begin,\n        .commit = vhost_commit,\n        .region_add = vhost_region_add,\n        .region_del = vhost_region_del,\n        .region_nop = vhost_region_nop,\n        .log_start = vhost_log_start,\n        .log_stop = vhost_log_stop,\n        .log_sync = vhost_log_sync,\n        .log_global_start = vhost_log_global_start,\n        .log_global_stop = vhost_log_global_stop,\n        .eventfd_add = vhost_eventfd_add,\n        .eventfd_del = vhost_eventfd_del,\n        .priority = 10\n    };\n    hdev->migration_blocker = NULL;\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n        error_setg(&hdev->migration_blocker,\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n        migrate_add_blocker(hdev->migration_blocker);\n    }\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n    hdev->n_mem_sections = 0;\n    hdev->mem_sections = NULL;\n    hdev->log = NULL;\n    hdev->log_size = 0;\n    hdev->log_enabled = false;\n    hdev->started = false;\n    hdev->memory_changed = false;\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n    return 0;\nfail_vq:\n    while (--i >= 0) {\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n    }\nfail:\n    r = -errno;\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n    QLIST_REMOVE(hdev, entry);\n    return r;\n}", "idx": 17329, "substitutes": {"hdev": [" hver", "ehcast", "shcast", "ohev", "ehpad", " hcast", "hddevice", "thDevice", "hcache", "hdDEV", " hcache", "hidevice", "htdev", "bhDevice", "hostdevice", "Hsys", "ohpad", "ahdev", "hostserial", "hmdev", "ahdevice", "vDEV", "hobj", "hdef", "hdserial", "Hdef", "hconn", "hDEV", "hmwindow", "hdebug", " hcam", "vdev", " hserial", "vev", "hwindow", "ohdata", " hsys", "hdevice", " hcase", "vdevice", " hwindow", "ehdevice", "bhdev", "hicase", "hvar", "ohDEV", "htdevice", "hmdevice", "hcam", "shev", "ehcache", "ehdebug", "Hconn", "hostdev", "ehdef", " hobj", "hcast", "ahDEV", " hDEV", "ohcase", "bhcast", "bhdevice", "ahcmd", "shdev", "hpad", "hostev", "Hev", "Hserial", " hvar", " hDevice", "htev", "ohdebug", "ohserial", "ohdevice", "thdev", "hmvar", "vdata", "thdevice", "Hver", "hserial", " hev", "hddev", "ehdata", "ehsys", "Hcam", "vdef", "ohobj", "hidev", " hinfo", "ohcache", "hcase", "hcmd", "ehdev", " hdata", "ehconn", "htDEV", "ehev", " hdebug", "ohwindow", "Hdevice", "vcam", "ehDEV", "hinfo", " hdevice", "thcast", "ehcmd", "hsys", "hev", "hver", "hiobj", "Hdata", "ehcam", "Hdev", " hcmd", "Hinfo", "ohvar", "ohver", "hDevice", " hdef", "vconn", "shdevice", " hpad", "ohdev", "ohinfo", "hdata"], "opaque": [" opaco", "opent", "operacity", "pent", "ocener", "oplay", " oplay", " opque", "ocque", " opatile", "OPacity", "OPserver", "operaques", "play", "obaque", "obacity", "observer", "ocaque", "opaques", "opatile", " opaques", "pserver", "postque", "operatile", " opener", "opaco", "opserver", "obaques", "operlay", "operener", "postacity", "operque", "operaco", " opent", " opacity", "opacity", "opque", "paque", "postaque", "operaque", "pacity", "OPaques", "opener", "paques", "OPaque", "operent", "ocaco", "postatile"], "backend_type": ["backend_role", "backendetypath", "backserver_role", "backbind_type", "backend7name", "backendetytypes", "backendetyname", "backbindetyype", "backserver_type", "backbindetytype", "backbind_ype", "backbind_name", "backbindetyclass", "backendpypath", "backend_name", "backend7ype", "backend_ype", "backendpytype", "backend_path", "backendetyype", "backserver_path", "backbind_class", "backendetytype", "backendpytypes", "backserver_types", "backendetyrole", "backend_class", "backendpyrole", "backbindetyname", "backend7type", "backendetyclass", "backend7class", "backend_types"], "features": ["services", "fields", "acts", "format", "flags", "bits", "settings", "details", "classes", "events", "changes", "fixes", "abilities", "results", "feature", "frames", "bugs", "versions", "Features", "words", "ensions", "vals", "plugins", "fts", "pins", "files", "tags", " capabilities", "players", "properties", "ports", "relations", " feat", "feat", "modules", "mas", "types", "issues", "ributes", "options", "rows", "sections", "workers", "fc", "effects", "ints", "reports", "weights", "faces", "actions", "eatures", "facts", "tests", " Features", "stats", "devices", "orts", "names", "states", "performance", "items", "forms", " interfaces", " frames"], "i": ["ic", "index", "l", "si", "t", "ci", "im", "hi", "p", "ei", "qi", "me", "q", "h", "err", "li", "is", "\u0438", "e", "I", " ii", "u", "ai", "phi", "v", "io", "di", "cli", "ip", "mi", "pi", "c", "ind", "id", "try", "j", "xi", "ti", "batch", "ui", "gi", "n", "ji", "ami", "multi", "bi", "x", "info", "asi", "zi", "ini", "ie", "f", "chain", "it", "ia", "ix", "iu", "y", "ii", "m"], "r": ["rm", "ren", "error", "res", "arr", "or", "ur", "t", "pr", "p", "result", "rw", "h", "ir", "q", "ar", "kr", "radius", "hr", "rt", "ry", "ret", "g", "fr", "resource", "rs", "mr", "run", "rr", "tr", "d", "attr", "dr", "rar", "response", "lr", "rem", "rd", "re", "c", "cr", "record", "j", "R", "rg", "repl", "er", "rb", "sr", "row", "rn", "ro", "nr", "entry", "rc", "rf", "br", "err", "m"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}", "idx": 17337, "substitutes": {"bs": ["hs", "ds", "cs", "lbs", "boxes", "las", "fps", "outs", "bits", "sb", "BS", "ses", "blog", "ins", "hz", "ubs", "ics", "bh", "als", "bp", "ks", "bas", "qs", "bps", "rs", "gs", "ss", "bc", "aus", "ubis", "ns", "bytes", "sts", "vs", "soc", "bos", "ps", "sys", "bes", "js", "iss", "irms", "es", "ats", "obs", "cks", "fs", "ts", "aos", "ls", "ims", "ms", "b", "bis", "its", "bn"], "sector_num": ["unit_dec", "sector_hex", "unit_hex", "sectorNameident", "sector9hex", "sectoritydec", "unit_num", "unititydec", "sectorNamedec", "sectorityident", "sector9dec", " sector_nu", "sectorNameNum", "unit_ident", "sector_nom", "unitityhex", "sector9ident", "sector_dec", "sectorNamenu", "sectorNamesym", " sector_pub", "sectorityhex", "sectorNamepub", "sector_Num", "sector9num", "unititynum", "unitityident", "sector_sym", " sector_nom", " sector_sym", "sectoritynum", "sectorNamehex", "sector_ident", "sector_pub", " sector_Num", "sector_nu", "sectorNamenum", "sectorNamenom"], "buf": ["mem", "cap", "cv", "Buff", "aka", "window", "img", "p", "bar", "proc", "q", "fb", "vec", "cur", "tmp", "queue", "bc", "BU", "alloc", "db", "v", "bytes", "pb", "read", "doc", "wb", "data", "cmd", "msg", "batch", "raw", "str", "rb", "txt", "cb", "block", "bin", "uf", "buffer", "Buffer", "buff", "b", "seq", "br"], "nb_sectors": ["nb_seors", "nb_psectors", "nb_psevers", "nb_pecs", "nb_heors", "nb_veriers", "nb_pseors", "nb_vevers", "nb_serivers", "nb_estors", "nb_ieors", "nb_hectors", "nb_pevers", "nb_sears", "nb_severs", "nb_seriers", "nb_veivers", "nb_hechers", "nb_estriers", "nb_vecs", "nb_serriers", "nb_serors", "nb_estctors", "nb_peors", "nb_pectors", "nb_seivers", "nb_vectors", "nb_psecs", "nb_iectors", "nb_sechers", "nb_veors", "nb_hears", "nb_serctors", "nb_vears", "nb_vechers", "nb_iears", "nb_secs", "nb_estivers", "nb_iechers"], "drv": ["Drve", "Drver", "vrj", "delver", "dervr", "rdl", "ldv", "drive", "srch", "drvs", " drj", "drch", "rdj", "Drv", "vrv", " drve", " drV", "mrv", "rdx", "ldch", "drf", "vrf", "crc", "drivr", "rdvr", "rdv", "rdc", " drver", "crvs", "DRV", "crv", "drvr", "mrc", "delav", "srvs", "drj", "ldvs", "mrx", " drav", "ldc", "Drw", "drve", "delv", "drav", "drx", "mrl", "derj", " drw", "drh", "rdf", "vrvr", " drvr", "DRvr", "srv", "drih", "derV", "srl", "derv", "drw", "Drav", " drf", "drl", "drver", " drh", "driv", "Drh", "crch", "DRv", "delw", "srx", "DRj", "drc", "Drvr", "src", "drV"], "ret": ["mem", " RET", "res", "nt", "pret", "deg", "back", "t", "el", "arr", "flag", "ter", "num", "xt", "result", "ll", "en", "vet", "compl", "rt", "arg", "out", "fin", "cont", "get", "lt", " Ret", "rem", "RET", "rev", "re", "det", "reset", "cmd", "lit", "ext", "rot", "ref", "r", "val", "def", "rets", "leg", "str", "alt", "repl", "del", "txt", "cert", "resp", "gt", "fun", "code", "elt", " alt", "red", "err", "Ret"], "len": ["mem", "pos", "lp", "l", "el", "nt", "size", "lon", "els", "t", "valid", "lib", "sp", "lf", "en", "ll", "li", "compl", "le", "fil", "syn", "vec", "empty", "dl", "length", "all", "fin", "ln", "bytes", "lt", "nl", "lit", "val", "L", "cmp", "ell", "str", "n", "lan", "del", "lim", "ls", "pl", "ld", "vol", "resp", "fun", "lis", "Len", "full", "sl", "elt", "seq", "fl"], "rd_ops": ["rdpoops", "rdporeads", "dr_oper", "rdpobytes", "rdpooper", "rdLops", "rdLbytes", "dr_ops", "drLoper", "dr_bytes", "drLreads", "dr_reads", "rdLreads", "rd_reads", "rd_oper", "rdLoper", "rd_bytes", "drLops", "drLbytes"]}}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1]<<16;\n\n    return (b+r) << 1;\n\n}\n", "idx": 17341, "substitutes": {"p1": ["tp2", "P2", "v1", "P81", "POne", " p0", "P0", "tp1", "perm0", "tp0", " pOne", "P3", "perm3", "v81", "v0", "tpOne", "P1", "p0", "perm1", "p81", "p3", "pOne", "perm81", "v3"], "p2": [" p02", "tp2", "jp0", "cp02", "cp2", "jp6", "point6", "cp1", "cp6", "jp2", "p02", " p0", "point2", "point02", "tp0", "point1", " p6", "p0", "p6", "tp6"], "cdt": ["sdt", " cdte", "codg", " cddt", " cdx", "pdts", " cdts", "sddt", "cdte", "cedt", "ctx", "codts", "cdtd", "ctte", "cdrt", "cdg", "cttd", "sdrt", "cdts", "pdt", "codrt", "pde", "cdx", "cedx", "cde", " cdrt", " cde", " cdtd", "cddt", "sdg", "ctt", "codt", "cedte", " cdg", "code", "pdte", "codte", "coddt", "cedtd"], "r": ["rm", "res", "ur", "t", "i", "p", "q", "h", "ar", "rt", "ri", "fr", "g", "rs", "mr", "u", "rr", "tr", "d", "v", "attr", "dr", "rar", "lr", "rd", "range", "re", "c", "cr", "R", "rb", "er", "sr", "rate", "rn", "ro", "nr", "vr", "rc", "f", "it", "rf", "red", "br", "err", "m"], "b": ["a", "l", "t", "back", "i", "p", "sb", "bb", "bar", "h", "bh", "reb", "bo", "base", "fb", "bs", "ob", "bg", "bc", "mb", "d", "db", "v", "wb", "bl", "B", "ab", "nb", "gb", "c", "body", "bu", "ble", "binary", "bound", "blue", "bf", "rb", "bi", "ib", "cb", "be", "ba", "bin", "eb", "br"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,\n\n                        const AVFrame *ref)\n\n{\n\n    PSNRContext *s = ctx->priv;\n\n    double comp_mse[4], mse = 0;\n\n    int j, c;\n\n    AVDictionary **metadata = avpriv_frame_get_metadatap(main);\n\n\n\n    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,\n\n                      (const uint8_t **)ref->data, ref->linesize,\n\n                       main->width, main->height, comp_mse);\n\n\n\n    for (j = 0; j < s->nb_components; j++)\n\n        mse += comp_mse[j] * s->planeweight[j];\n\n\n\n    s->min_mse = FFMIN(s->min_mse, mse);\n\n    s->max_mse = FFMAX(s->max_mse, mse);\n\n\n\n    s->mse += mse;\n\n    for (j = 0; j < s->nb_components; j++)\n\n        s->mse_comp[j] += comp_mse[j];\n\n    s->nb_frames++;\n\n\n\n    for (j = 0; j < s->nb_components; j++) {\n\n        c = s->is_rgb ? s->rgba_map[j] : j;\n\n        set_meta(metadata, \"lavfi.psnr.mse.\", s->comps[j], comp_mse[c]);\n\n        set_meta(metadata, \"lavfi.psnr.psnr.\", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));\n\n    }\n\n    set_meta(metadata, \"lavfi.psnr.mse_avg\", 0, mse);\n\n    set_meta(metadata, \"lavfi.psnr.psnr_avg\", 0, get_psnr(mse, 1, s->average_max));\n\n\n\n    if (s->stats_file) {\n\n        fprintf(s->stats_file, \"n:%\"PRId64\" mse_avg:%0.2f \", s->nb_frames, mse);\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"mse_%c:%0.2f \", s->comps[j], comp_mse[c]);\n\n        }\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"psnr_%c:%0.2f \", s->comps[j],\n\n                    get_psnr(comp_mse[c], 1, s->max[c]));\n\n        }\n\n        fprintf(s->stats_file, \"\\n\");\n\n    }\n\n\n\n    return main;\n\n}\n", "idx": 17350, "substitutes": {"ctx": ["init", "con", "cv", "ic", " cx", "tc", "np", "lex", "ck", "tx", "p", "mc", "tmp", "jac", "ct", "bc", "cc", "conv", "kw", "hw", "k", "obj", "js", "conn", "cmd", "pkg", "jp", "mk", "context", "cm", "act", "x", "Context", "anc", "xc", "cp", "ac", "sc", "conf"], "ref": ["mem", "br", "res", "p", "lib", "q", "base", "ob", "fr", "g", "Ref", "REF", "link", "foreign", "primary", "db", "v", "reference", "vm", "self", "ef", "rem", "tab", "rev", "re", "Reference", "range", "ror", "rel", "r", "master", "external", "def", "repl", "alt", "info", "ro", "rc", "f", "rf", "b", "conf", "phys", "m"], "s": ["export", "z", "scripts", "details", "st", "e", "g", "rs", "tags", "vs", "se", "self", "sys", "es", "comm", "fs", "space", "er", "series", "spec", "sl", "ex", "os", "sort", "t", "settings", "csv", "sm", "set", "qs", "sym", "sa", "S", "ss", "so", "sts", "v", "single", "tools", "ps", "service", "styles", "https", "n", "o", "ts", "ls", "parts", "stats", "f", "comments", "a", "services", "ds", "sam", "l", "w", "sb", "as", "ses", "changes", "als", "esm", "south", "sv", "sw", "http", "js", "storage", "state", "info", "tests", "b", "y", "m", "utils", "hs", "shared", "simple", "args", "i", "p", "store", "sq", "aws", "h", "is", "bs", "gs", "ns", "sd", "ats", "less", "ims", "ms", "search", "sql", "us", "this", "its"], "comp_mse": ["comp_mste", "comp_fmge", "comp_rmsee", "comp_cte", "comp_imze", "comp_msese", "comp_pse", "comp_rest", "comp_fmte", "comp_msex", "comp_fmse", "comp_ppe", "comp_amene", "comp_pese", "comp_nsee", "comp_amte", "comp_nte", "comp_lme", "comp_lze", "comp_lene", "comp_pte", "comp_Mte", "comp_imse", "comp_Mze", "comp_amsex", "comp_ampe", "comp_mssex", "comp_fmene", "comp_Mpe", "comp_lpe", "comp_msse", "comp_nese", "comp_msee", "comp_msze", "comp_Mse", "comp_mene", "comp_emte", "comp_lte", "comp_rmest", "comp_emge", "comp_msme", "comp_rsee", "comp_mge", "comp_nse", "comp_lse", "comp_mest", "comp_amge", "comp_amese", "comp_amse", "comp_amze", "comp_mpe", "comp_cene", "comp_rse", "comp_msene", "comp_emene", "comp_mze", "comp_rmse", "comp_cme", "comp_cse", "comp_npe", "comp_mte", "comp_rte", "comp_imsex", "comp_lese", "comp_rmte", "comp_nest", "comp_emse", "comp_mese", "comp_imese", "comp_mme"], "j": ["z", "kj", "g", "fr", "je", "jit", "obj", "req", "oj", "jp", "ji", "er", "jump", "eg", " i", "ij", "el", "t", "kat", "adj", " n", "q", "ja", "jo", " J", "ot", "v", "json", "pt", "ju", "n", "o", " dj", "aj", "jah", "x", "it", "jj", "l", "ion", " ii", "J", "jac", "tr", "ijk", "ch", "k", "jl", "js", "jet", "att", "ev", "str", "by", "ie", "ix", "jc", "b", "y", "m", "Ja", "im", "i", "p", "dj", "at", "bo", "uj", "ng", "off", "bj", "kid", "dr", "ind", "job", "br"], "c": ["sc", "cv", "cs", "l", "ca", "t", "ci", "i", "p", "mc", "cn", "ec", "h", "color", "unc", "gc", "count", "g", "cf", "u", "cut", "cc", "bc", "ct", "ch", "co", "v", "cd", "k", "cont", "cor", "uc", "cr", "r", "lc", "cm", "dc", "C", "o", "fc", "ce", "cu", "cache", "cb", "com", "cp", "f", "ac", "chain", "abc", "code", "rc", "jc", "col", "m"], "metadata": ["managed", "mem", "chart", "shared", "generic", "np", "memory", "settings", "java", "definition", "csv", "details", "sample", "md", "tar", "xxx", "annot", "setup", "config", "header", "ata", "vp", "pdf", "mt", "ka", "primary", "partial", "detail", "magic", "latest", "data", "json", "adata", "mx", "cmd", "storage", "wrapper", "met", "ATA", "note", "template", "binary", "options", "message", "summary", "directory", "package", "source", "xml", "layout", "meta", "params", "rpm", "license", "dd", "drm", "database", "m"], "nb_frames": ["num_frame", "nb__obs", "nb_flows", "nb_frame", "num_series", "nb__flows", "nb_obs", "nb__series", "nb__frames", "num_flows", "num_obs", "nb_images", "nb_series", "nb__frame", "nb__images", "num_frames", "num_images"]}}
{"project": "FFmpeg", "commit_id": "eb9fb508b0e09d85d234fe694333b2005e1d7a7e", "target": 1, "func": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska)\n\n{\n\n    EbmlList *index_list;\n\n    MatroskaIndex *index;\n\n    int index_scale = 1;\n\n    int i, j;\n\n\n\n    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)\n\n        return;\n\n\n\n    index_list = &matroska->index;\n\n    index      = index_list->elem;\n\n    if (index_list->nb_elem &&\n\n        index[0].time > 1E14 / matroska->time_scale) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");\n\n        index_scale = matroska->time_scale;\n\n    }\n\n    for (i = 0; i < index_list->nb_elem; i++) {\n\n        EbmlList *pos_list    = &index[i].pos;\n\n        MatroskaIndexPos *pos = pos_list->elem;\n\n        for (j = 0; j < pos_list->nb_elem; j++) {\n\n            MatroskaTrack *track = matroska_find_track_by_num(matroska,\n\n                                                              pos[j].track);\n\n            if (track && track->stream)\n\n                av_add_index_entry(track->stream,\n\n                                   pos[j].pos + matroska->segment_start,\n\n                                   index[i].time / index_scale, 0, 0,\n\n                                   AVINDEX_KEYFRAME);\n\n        }\n\n    }\n\n}\n", "idx": 17353, "substitutes": {"matroska": ["matrasha", "mitrosha", "matrosaka", "macrisko", "matrisko", "matstrosko", "matrasica", "matrusko", "atroskas", "matresko", "matraska", "matroaka", "matrisaka", "matroskaya", "matrorska", "atrotskas", "matcosaka", "matrisica", "macrisaka", "macroskas", "catroska", "catrickska", "matstroseka", "macriska", "matrski", "matrotski", "Matroski", "matstroskaya", "matrocki", "mitroski", "matrosku", "matrasko", "macriskas", "mitreseka", "Matriska", "mitroseka", "matriskaya", "matrusky", "matrorsica", "matrusaka", "matrosha", "matroko", "catroskaya", "matrsaka", "matroky", "mitrosaka", "mrisko", "mitreska", "atrosku", "matraski", "matrosrika", "matrosky", "mitrosko", "matrotsku", "catrickskaya", "matrotsha", "matroha", "matrotskas", "Matrsaka", "catrosaka", "matreska", "matrisky", "matrsko", "mroska", "mitrasha", "matreseka", "matrisku", "matroseka", "mriska", "atrotskaya", "matrotsaka", "matrickska", "matrickscki", "Matrosky", "atrotsku", "Matrski", "matruska", "matrosica", "mrisica", "matroskas", "matriskas", "matruskas", "macroska", "Matrisaka", "atroska", "matrorsrika", "matcoska", "matrotskaya", "Matrosaka", "Matrisko", "matriska", "catricksaka", "mitrasaka", "matreskaya", "matrisrika", "mitreskaya", "macrosaka", "macrosko", "Matrska", "matricksaka", "matrasrika", "matrickskas", "matroka", "matroski", "matriseka", "Matroska", "atrotska", "Matrisky", "matstroska", "matroki", "matrickskaya", "catrickscki", "matcoscki", "matruskaya", "atroskaya", "matroscki", "mrosko", "catroscki", "mrosica", "Matrsko", "matrusku", "Matrosko", "matrokaya", "matrosko", "matrorsko", "matrasaka", "matrokas", "matcoskaya", "matrotska", "mitroska", "mrosrika", "mitroskaya", "mitraski", "mitresko", "mrisrika", "matricksko", "mitraska", "matrska"], "index_list": ["index1List", "index1pair", "index_li", " index_List", "list_list", "index1list", "list_List", "pos2LIST", "index2table", "zeroinglist", "ind_List", "zeroingstack", "index09stack", "zeroingLIST", "index09string", "zero_stack", "index_len", "index2LIST", "pos_len", "list_lists", " index_table", "index_lists", "pos2len", "index2len", "pos_listed", "index2listed", " index_dict", "index_pair", "indexingstring", "indexinglen", "index2list", "pos2list", "index09list", "index_dict", "zero_LIST", "index_List", "indexinglist", "index2dict", "index2List", "index09LIST", "zeroingstring", "ind_pair", "index_table", "index_listed", "index_LIST", "list_set", "ind_list", "index_stack", "index1li", "index09table", "indexinglisted", "ind_li", "index09dict", "pos_LIST", "indexingstack", "pos2listed", "zero_string", "index09List", "index_set", "indexingLIST", "zero_list", "index_string"], "index": ["check", "offset", "see", "loc", "error", "can", "sort", "slice", "delete", "num", "list", "only", "store", "query", "test", "zero", "level", "find", "scale", "action", "count", "lock", "point", "config", "map", "cycle", "link", "node", "Index", "length", "address", "seek", "position", "axis", "image", "archive", "name", "select", "instance", "route", "value", "order", "range", "allow", "update", "ind", "id", "note", "date", "post", "table", "connect", "path", "n", "rank", "key", "cache", "info", "x", "attribute", "row", "view", "search", "version", "active", "create", "type"], "i": ["yi", "ic", "ij", "l", "si", "ci", "im", "hi", "p", "ei", "ki", "me", "at", "q", "li", "is", "ri", "e", "g", "I", " ii", "u", "ai", "phi", "v", "di", "io", "ip", "mi", "pi", "my", "in", "ind", "xi", "ti", "ui", "gi", "n", "ji", "ami", "multi", "uri", "o", "bi", "x", "ims", "info", "by", "zi", "ini", "sim", "ie", "it", "ix", "us", "ex", "ia", "iu", "y", "ii", "m"], "j": ["next", "ij", "jj", "z", "l", "el", "pr", "p", "dj", "kj", "bot", "q", "ja", "bo", "jo", "e", "uj", "fr", "g", "je", "J", "tr", "other", "jit", "bj", "v", "k", "obj", "jl", "js", "c", "json", "att", "oj", "jp", "ev", "job", "n", "ji", "o", "aj", "key", "x", "by", "jump", "it", "jc", "b", "y", "br", "m"], "pos_list": ["po_lists", "po_list", "pos2lists", "rot_list", "po_LIST", "po2list", "po2LIST", " pos_listed", "pos_List", " pos_dict", "pos2dict", "po_List", "pos2List", "pos2LIST", "pos_listed", "pos_LIST", "pos_pool", "pos_lists", "rot_pool", "rot_queue", "rotetList", "pos2listed", "pos_dict", "posetList", "posetqueue", "po2lists", "posetlist", "posetpool", "rotetpool", "pos2list", "rotetlist", "rotetqueue", "pos_queue", " pos_lists", "rot_List", "po2List"], "pos": ["offset", "Pos", "loc", "os", "res", "px", "nos", "pr", "p", "tx", "slot", "num", "port", "oss", "on", "pc", "find", "pres", "point", "points", "lat", "position", "seek", "off", "pro", "co", "ports", "start", "doc", "ps", "POS", "pet", "pi", "pt", "id", "rot", "rel", "ref", "tag", "val", "def", "cond", "rank", "path", "coord", "info", "pl", "pose", "row", "no", "resp", "params", "us", "spec", "po", "seq", "serv"], "track": ["check", "require", "round", "sort", "form", "Track", "comment", "trak", "stage", "store", "report", "num", "stream", "port", "sound", "mount", "task", "find", "hold", "tmp", "node", "tr", "match", "rr", "handle", "step", "seek", "rec", "band", "session", "tab", "mark", "race", "roll", "cmd", "skip", "try", "record", "tag", "field", "batch", "trip", "sync", "train", "table", "transform", "rank", "claim", "kick", "fire", "reflect", "contact", "ack", "metadata", "tracks", "txt", "row", "token", "tm", "deck", "search", "rack", "ctr", "trace", "tracking", "song"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;\n\n    }\n\n}\n", "idx": 17357, "substitutes": {"samples": ["alschanges", "jsults", "assamples", "istracks", "sresults", "itsamples", "camps", "spled", "tsongs", "commples", "tsamples", " serences", "isples", "samamples", "commamples", "camples", "messamples", "slamples", "isensions", "alsamples", "seramples", "wsiffs", "insensions", "isamples", " sples", "serfaces", "sples", "alsourses", "wstracks", " sprints", "cpled", "wsamples", "alsresults", "subes", "aronents", "songs", "messonents", "commongs", " sfaces", "sprints", "sonents", "sfaces", "unstracks", "ssamples", "servples", "stracks", "sampled", "commources", "assubes", "itsviews", "schanges", "ssacks", "cviews", "insples", "servensions", "isults", "unsamples", "servamples", "sererences", "slacks", "aramples", "assprints", "sacks", "samps", "messviews", "sans", "commourses", " sviews", "sourses", "serences", "cans", "assources", " sonents", "slources", "wsensions", "sviews", "samviews", "sensions", "insults", "jsamps", " samps", " sults", "servults", "sults", "sources", " sans", "ssamps", "cults", " subes", "sreports", "slamps", "ssources", "commprints", "unsourses", "seronents", "unsensions", "commchanges", " songs", "jsans", "jsamples", "itsonents", "messreports", " spled", " sreports", "samamps", "commubes", "unschanges", "isiffs", " sacks", "arfaces", "siffs", "arerences", "tsprints", "tsples", " sources", "unsiffs", "commresults", "unsresults", "itsreports", "insamples"], "i": ["z", "ir", "li", "ri", "g", "I", " key", "ai", "di", "iter", "esi", "mi", "ji", " axis", "asi", " iter", "chain", "multi", "ii", "index", "ij", "t", "ci", "\u0438", "phi", " multi", "v", "cli", "io", "pi", " me", "gi", "o", "fi", "bi", "x", "zi", " err", "ini", "it", " it", "iu", "init", "ic", "ei", "qi", " ti", "me", " ii", " index", "name", "iq", " mi", "ip", " li", " j", "iri", "j", "ti", " is", " ki", "print", " I", "ami", "uri", " di", " bi", "ix", "y", "m", "si", "im", " my", "ki", "at", " pi", "is", "oi", "ind", "id", "in", "xi", "ui", "batch", "key", "ims", " ni", " m", "sim", "us", "this"]}}
{"project": "qemu", "commit_id": "fb506e701e9bafa3e0685747c1c98962c52d1962", "target": 1, "func": "static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */\n\n    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&\n\n        !kvm_irqchip_is_split()) {\n\n        error_setg(errp, \"Intel Interrupt Remapping cannot work with \"\n\n                         \"kernel-irqchip=on, please use 'split|off'.\");\n\n        return false;\n\n    }\n\n    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {\n\n        error_setg(errp, \"eim=on cannot be selected without intremap=on\");\n\n        return false;\n\n    }\n\n\n\n    if (s->intr_eim == ON_OFF_AUTO_AUTO) {\n\n        s->intr_eim = x86_iommu->intr_supported ?\n\n                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 17362, "substitutes": {"s": ["services", "ies", "hs", "ds", "cs", "ops", "t", "args", "settings", "i", "p", "sb", "events", "ses", "changes", "details", "sq", "aws", "h", "qs", "is", "bs", "e", "sv", "rs", "gs", "S", "ss", "d", "sw", "sts", "v", "ns", "vs", "ports", "se", "sports", "ps", "sys", "js", "spec", "c", "j", "es", "ats", "r", "comm", "sync", "n", "fs", "less", "ears", "ts", "ls", "aunts", "tests", "stats", "params", "sis", "m"], "errp": ["errps", "nerp", "eorpress", "diep", "eorpad", "errpad", "errpress", "errorp", "errorpad", "nerpad", "errjp", "errorpc", "derjp", "errpa", "diepe", "erp", "derps", "nerpress", "errpc", "derp", "rrping", "rrp", "nerjp", "erjp", "errorpa", "erps", "errpe", "eorp", "errping", "dieping", "nerP", "nerpa", "eorpa", "derP", "errP", "errorpress", "rrpe", "nerps", "diepc", "rrpc", "erP", "errorpe", "errorping"], "x86_iommu": ["x86_iophermu", "x86_iormu", "x86_iromu", "x86_iompu", "x86_iemsuu", "x86_piommu", "x86_iommtu", "x86_iommuu", "x86_iopherus", "x86_iomn", "x86_tommmu", "x86_tomus", "x86_iomus", "x86_iopheru", "x86_iomptu", "x86_iomacu", "x86_iuommu", "x86_iomu", "x86_iummmu", "x86_iuemsuu", "x86_iuemsu", "x86_piomcu", "x86_piommue", "x86_iummu", "x86_iemsu", "x86_iromul", "x86_tommu", "x86_iompn", "x86_iommul", "x86_iormue", "x86_iemsul", "x86_iompcu", "x86_piommul", "x86_piomue", "x86_tommus", "x86_piomn", "x86_iomue", "x86_iomuu", "x86_tomu", "x86_iomau", "x86_iromn", "x86_iomcu", "x86_iormuu", "x86_piommn", "x86_iuemsue", "x86_iuommuu", "x86_iuemsul", "x86_iomtu", "x86_iomul", "x86_piomu", "x86_iummus", "x86_piomtu", "x86_iomamu", "x86_iuommue", "x86_piommcu", "x86_piomul", "x86_iemsue", "x86_iommmu", "x86_iommn", "x86_iommus", "x86_iompue", "x86_iuommul", "x86_piommmu", "x86_iompul", "x86_iommue", "x86_iormul", "x86_iompmu", "x86_piommtu", "x86_iomatu", "x86_iromue", "x86_iommcu"]}}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int no_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n", "idx": 17370, "substitutes": {"hw": ["him", "hs", "hh", "wp", "w", "phy", "sh", "ich", "ow", "hz", "aws", "h", "we", "ha", "ctx", "iw", "irm", "hd", "ht", "vc", "how", "nw", "ew", "ih", "ksh", "igh", "wx", "ay", "wd", "hm", "cmd", "pkg", "hp", "mph", "haw", "wi", "act", "igm", "ether", "dh", "hip", "shake", "rh", "fw", " inh", "wind", "hop", "dq"], "as": ["a", " am", "mes", "am", "las", "ag", " os", "ras", " As", "oss", "ar", "ars", "bs", " us", "sa", "ase", "aus", "ias", "ak", " av", "ams", "ast", " AS", "ass", "ais", "AS", "As", "pas", "acs", "asa", "aos", "pa", "sac", "an", "nas", "was", "ac", "us", "has", "ap"]}}
{"project": "FFmpeg", "commit_id": "fe6eea99efac66839052af547426518efd970b24", "target": 1, "func": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n\n{\n\n    NSVContext *nsv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st[2] = {NULL, NULL};\n\n    NSVStream *nst;\n\n    AVPacket *pkt;\n\n    int i, err = 0;\n\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n\n    uint32_t vsize;\n\n    uint16_t asize;\n\n    uint16_t auxsize;\n\n\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\n\n\nnull_chunk_retry:\n\n    if (pb->eof_reached)\n\n        return -1;\n\n\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n\n        err = nsv_resync(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state == NSV_FOUND_NSVS)\n\n        err = nsv_parse_NSVs_header(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n\n        return -1;\n\n\n\n    auxcount = avio_r8(pb);\n\n    vsize = avio_rl16(pb);\n\n    asize = avio_rl16(pb);\n\n    vsize = (vsize << 4) | (auxcount >> 4);\n\n    auxcount &= 0x0f;\n\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n\n           auxcount, vsize, asize);\n\n    /* skip aux stuff */\n\n    for (i = 0; i < auxcount; i++) {\n\n        uint32_t av_unused auxtag;\n\n        auxsize = avio_rl16(pb);\n\n        auxtag = avio_rl32(pb);\n\n        avio_skip(pb, auxsize);\n\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n\n    }\n\n\n\n    if (pb->eof_reached)\n\n        return -1;\n\n    if (!vsize && !asize) {\n\n        nsv->state = NSV_UNSYNC;\n\n        goto null_chunk_retry;\n\n    }\n\n\n\n    /* map back streams to v,a */\n\n    if (s->nb_streams > 0)\n\n        st[s->streams[0]->id] = s->streams[0];\n\n    if (s->nb_streams > 1)\n\n        st[s->streams[1]->id] = s->streams[1];\n\n\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n\n        nst = st[NSV_ST_VIDEO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n\n        av_get_packet(pb, pkt, vsize);\n\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n\n        pkt->dts = nst->frame_offset;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        for (i = 0; i < FFMIN(8, vsize); i++)\n\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n\n                   i, pkt->data[i]);\n\n    }\n\n    if(st[NSV_ST_VIDEO])\n\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n\n\n    if (asize && st[NSV_ST_AUDIO]) {\n\n        nst = st[NSV_ST_AUDIO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n\n        /* read raw audio specific header on the first audio chunk... */\n\n        /* on ALL audio chunks ?? seems so! */\n\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n\n            uint8_t bps;\n\n            uint8_t channels;\n\n            uint16_t samplerate;\n\n            bps = avio_r8(pb);\n\n            channels = avio_r8(pb);\n\n            samplerate = avio_rl16(pb);\n\n            if (!channels || !samplerate)\n\n                return AVERROR_INVALIDDATA;\n\n            asize-=4;\n\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                   bps, channels, samplerate);\n\n            if (fill_header) {\n\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n\n                if (bps != 16) {\n\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n\n                }\n\n                bps /= channels; // ???\n\n                if (bps == 8)\n\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n\n                samplerate /= 4;/* UGH ??? XXX */\n\n                channels = 1;\n\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                       bps, channels, samplerate);\n\n            }\n\n        }\n\n        av_get_packet(pb, pkt, asize);\n\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n\n            /* on a nsvs frame we have new information on a/v sync */\n\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n\n                   nsv->avsync, pkt->dts);\n\n        }\n\n        nst->frame_offset++;\n\n    }\n\n\n\n    nsv->state = NSV_UNSYNC;\n\n    return 0;\n\n}\n", "idx": 17381, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "scl", "t", "w", "p", "sb", "sp", "ses", "ins", "sq", "aws", "ctx", "set", "qs", "is", "span", "bs", "e", "g", "sv", "rs", "gs", "S", "ss", "ns", "v", "sts", "socket", "ps", "sys", "js", "c", "pkg", "j", "es", "ats", "comm", "n", "fs", "ts", "ls", "stats", "sc", "b", "conf", "its", "m"], "fill_header": ["Fill_head", " fill_headers", " fill2head", "Fill_header", " fill2headers", " fill2header", "Fill_headers", "Fill_Header", " fill_Header", " fill2Header", " fill_head"], "nsv": ["lsV", "nsvs", "nsve", "msvs", "nvt", "namestv", "rotsver", "csvc", "csv", "stsver", "namesvp", "sntv", "snvc", "tsvc", "rotsvp", "nvc", "lstv", "atsv", "nv", "msvc", "stspr", "lspr", "lsv", "csvs", "csvt", "namesvc", "stsvp", "stsv", "stsvc", "snv", "nsvm", "namesV", "msvr", "nvs", "snvr", " nspr", "nsvr", "rotsvm", "nsvp", "snve", "tsvs", "lsvr", "namesvr", "csvr", "namesv", "namesve", " nsvt", "snvs", "nstv", "stsvm", "nsvc", "nsV", "atsV", "tsvr", "namesver", "lsvt", "namesvm", "nsver", "csve", "atsvc", "rotsv", "tsv", " nsvc", "nspr", "namesvs", "lsvc", "stsvt", "msv", "snvt", "nsvt", "atsvs", "lsvs"], "pb": ["td", "snap", "lp", "cv", "np", "tc", "dp", "wp", "p", "pp", "sb", "tx", "proc", "sp", "client", "emb", "amp", "bh", "ctx", "bp", "pc", "span", "bs", "buf", "xp", "vp", "tif", "prefix", "pan", "tp", "mt", "lb", "pg", "conv", "db", "pro", "bj", "tf", "stab", "wb", "ps", "sys", "pm", "peer", "mp", "PB", "pkg", "pt", "cmd", "erb", "pool", "jp", "pd", "tk", "gp", "rb", "tm", "cb", "pl", "ssl", "pa", "uf", "cp", "fp", "buff", "rpm", "sc", "b", "ap", "phys", "prot"], "st": ["ist", "sh", "sp", "cl", "ss", "so", "ct", "mt", "ste", "sw", "St", "sts", "se", "bl", "ft", "sth", "pt", "std", "ust", "ST", "est", "sta", "nd", "rest", "us", "it", "sl", "ut"], "nst": ["Nst", "Nct", "cnct", "Nsw", " nct", "nsts", "cnsw", "cnst", " nsts", "cnsts", "nsw", " nsw", "nct", "Nsts"], "pkt": ["cpqt", "prqt", "pqt", "cpnt", "pracket", "cpacket", "prnt", " packet", "prkt", "packet", " pqt", "pnt", "cpkt", " pnt"], "i": ["ic", "index", "ij", "l", "si", "gu", "t", "ci", "im", "hi", "ei", "ki", "qi", " ti", "me", "q", "err", "li", "\u0438", "g", "I", " ii", "ai", "phi", "di", "cli", "ip", "mi", "pi", "c", "ind", " j", "oi", "j", "xi", "in", "ti", "ui", "batch", "gi", "n", "print", "ami", "multi", "bi", "x", "iy", " x", "ims", "asi", " m", "zi", " err", "sim", " bi", "ini", "go", "chain", "it", "ix", "us", "ex", "iu", "y", "ii", "m"], "auxcount": ["auount", "avcount", " auxcounter", "uxmatch", "auCount", "uxCount", " auxCount", "auxc", " auxc", "uxcount", "faxmatch", "ausize", "uxc", "avount", "auxCount", "faxCount", "faxcounter", "avsize", " auxount", "uxcounter", "aucount", "faxsize", "avc", "avCount", "auxmatch", "auxount", "faxcount", "auxcounter", " auxmatch", "uxsize"], "vsize": ["svwidth", "uvsize", " vwidth", "avtotal", "vcount", "varize", "avcount", "avoffset", "vcexport", " vcount", "varset", "evize", "vtotal", "vheight", "avize", "voffset", "svsize", "vgrow", " vgrow", "svtotal", "uvoffset", "vvsize", "cvgrow", " vstorage", " vize", "uvize", "cvsize", "cvunit", "avstorage", " vexport", "evsize", "evwidth", "vwidth", "vvstorage", "Vize", "vSIZE", "uvSIZE", "iverset", "evstorage", "cvexport", "avSIZE", "avwidth", "vvheight", "vexport", "iverstorage", "vcgrow", "svize", "vvSIZE", "avsize", "Vheight", "avset", "vunit", "vstorage", "vcunit", "iverize", "iversize", "vvize", "Vstorage", " vunit", "vcsize", "vset", " vtotal", "vize", "Vsize", "varsize", "avheight", "varstorage", "vvoffset", "svcount"], "asize": ["aosize", "rasize", "atsizer", "msiz", "aosized", "Asource", "msource", "Asized", "msizer", "alsiz", "Asize", "rasiz", "atsource", "_", "asizer", "asource", "alsize", " asizer", "msize", "asiz", "atsize", "c", "Asizer", "func", "atsiz", "alsized", "rasizer", " asized", "aosource", "txt", "arsize", "aosizer", "rasource", "rasized", "asized", " asource", "arsizer", "alsizer", "arsiz", "arsized"], "auxsize": ["vcount", "avcount", "auxsum", "avize", " auxize", "vSize", "auize", "auxize", "uxcount", " auxmem", " auxsum", "ausize", "afcount", "uxsum", "avsize", "ausum", "afsize", "aucount", "auxmem", "uxmem", "afize", "avSize", "afmem", "vize", "uxSize", " auxSize", "auxSize", "uxsize", "uxize"], "av_unused": ["av2unuse", "av2unused", "av2Unuse", "av_Unus", "av_nonset", "av_unuse", "av2Unset", "av_nuse", "av2Unus", "av_nused", "av_nus", "av_Unused", "av_unus", "av_nonused", "av_unset", "av_Unset", "av_Unuse", "av_nset", "av2unset", "av_nonuse", "av2Unused", "av_nonus", "av2unus"], "NSVStream": ["CSVStream", "CSVStreamer", "CSVView", "NSVView", "NSVCStreamer", "NSVStatus", "NSVGView", "NSVCStream", "NSVSView", "NSVCView", "NSVCStatus", "CSVSStream", "NSVSStatus", "CSVSView", "CSVSStatus", "CSVStatus", "NSVSStream", "NSVGStreamer", "NSVGStream", "NSVSStreamer", "NSVStreamer", "CSVSStreamer", "NSVGStatus"], "priv_data": ["priv___block", "priv___buf", "public_cache", "public_data", "priv__cache", "priv___cache", "privmsgcache", "priv__block", "privmsgblock", "public___block", "privmsgbuf", "priv__buf", "priv__data", "priv___data", "priv_buf", "priv_cache", "public___cache", "public___data", "public_buf", "public___buf", "priv_block", "privmsgdata", "public_block"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n", "idx": 17411, "substitutes": {"f": ["fd", "fn", "form", "l", "t", "w", "window", "p", "lf", "sf", "h", "q", "fb", "e", "fr", "g", "cf", "fac", "out", "d", "xf", "v", "tf", "c", "ff", "r", "fo", "o", "fs", "fi", "df", "fc", "fm", "bf", "af", "fa", "x", "fw", "uf", "ac", "full", "fp", "rf", "F", "b", "file", "m"], "opaque": ["opacity", "ipaque", "ipent", "opaques", "Opaque", "opent", "compacity", "compaques", "Opacity", "compent", "Opaques", "ipaques", "ipacity", "compaque", "Opent"], "ret": ["back", "rier", "rt", "arg", "nz", "mb", "inter", "cat", "jp", "nil", "cert", "net", "rets", " jet", " RET", "t", "flag", "desc", "result", "ry", "vet", "end", "ber", "RET", "reset", "re", "try", "len", "resp", "code", "ctr", "elt", "after", "err", "rm", "res", "nt", "pret", "ter", "ben", "tr", "mt", "reg", "lt", "ft", " Ret", "det", "j", "att", "def", "print", "alt", "txt", "gt", "bool", " res", " alt", "grad", "deg", "git", "final", " fut", "out", "cont", "rem", "rev", "cmd", "ext", "lit", "ref", "val", "new", "reflect", "red", "Ret"]}}
{"project": "FFmpeg", "commit_id": "51e1cc16d3e89a785f3231065c4eb898a0401a93", "target": 1, "func": "matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n                     int64_t pos, uint64_t cluster_time, uint64_t duration,\n                     int is_keyframe, int is_bframe)\n{\n    int res = 0;\n    int track;\n    AVStream *st;\n    AVPacket *pkt;\n    uint8_t *origdata = data;\n    int16_t block_time;\n    uint32_t *lace_size = NULL;\n    int n, flags, laces = 0;\n    uint64_t num;\n    int stream_index;\n    /* first byte(s): tracknum */\n    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");\n        av_free(origdata);\n        return res;\n    }\n    data += n;\n    size -= n;\n    /* fetch track from num */\n    track = matroska_find_track_by_num(matroska, num);\n    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %d or size %u\\n\", track, size);\n        av_free(origdata);\n        return res;\n    }\n    stream_index = matroska->tracks[track]->stream_index;\n    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {\n        av_free(origdata);\n        return res;\n    }\n    st = matroska->ctx->streams[stream_index];\n    if (st->discard >= AVDISCARD_ALL) {\n        av_free(origdata);\n        return res;\n    }\n    if (duration == AV_NOPTS_VALUE)\n        duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n    /* block_time (relative to cluster time) */\n    block_time = AV_RB16(data);\n    data += 2;\n    flags = *data++;\n    size -= 3;\n    if (is_keyframe == -1)\n        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;\n    if (matroska->skip_to_keyframe) {\n        if (!is_keyframe || st != matroska->skip_to_stream) {\n            av_free(origdata);\n            return res;\n        }\n        matroska->skip_to_keyframe = 0;\n    }\n    switch ((flags & 0x06) >> 1) {\n        case 0x0: /* no lacing */\n            laces = 1;\n            lace_size = av_mallocz(sizeof(int));\n            lace_size[0] = size;\n            break;\n        case 0x1: /* xiph lacing */\n        case 0x2: /* fixed-size lacing */\n        case 0x3: /* EBML lacing */\n            assert(size>0); // size <=3 is checked before size-=3 above\n            laces = (*data) + 1;\n            data += 1;\n            size -= 1;\n            lace_size = av_mallocz(laces * sizeof(int));\n            switch ((flags & 0x06) >> 1) {\n                case 0x1: /* xiph lacing */ {\n                    uint8_t temp;\n                    uint32_t total = 0;\n                    for (n = 0; res == 0 && n < laces - 1; n++) {\n                        while (1) {\n                            if (size == 0) {\n                                res = -1;\n                                break;\n                            }\n                            temp = *data;\n                            lace_size[n] += temp;\n                            data += 1;\n                            size -= 1;\n                            if (temp != 0xff)\n                                break;\n                        }\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n                case 0x2: /* fixed-size lacing */\n                    for (n = 0; n < laces; n++)\n                        lace_size[n] = size / laces;\n                    break;\n                case 0x3: /* EBML lacing */ {\n                    uint32_t total;\n                    n = matroska_ebmlnum_uint(data, size, &num);\n                    if (n < 0) {\n                        av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\");\n                        break;\n                    }\n                    data += n;\n                    size -= n;\n                    total = lace_size[0] = num;\n                    for (n = 1; res == 0 && n < laces - 1; n++) {\n                        int64_t snum;\n                        int r;\n                        r = matroska_ebmlnum_sint (data, size, &snum);\n                        if (r < 0) {\n                            av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\");\n                            break;\n                        }\n                        data += r;\n                        size -= r;\n                        lace_size[n] = lace_size[n - 1] + snum;\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n            }\n            break;\n    }\n    if (res == 0) {\n        uint64_t timecode = AV_NOPTS_VALUE;\n        if (cluster_time != (uint64_t)-1\n            && (block_time >= 0 || cluster_time >= -block_time))\n            timecode = cluster_time + block_time;\n        for (n = 0; n < laces; n++) {\n            if (st->codec->codec_id == CODEC_ID_RA_288 ||\n                st->codec->codec_id == CODEC_ID_COOK ||\n                st->codec->codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n                int a = st->codec->block_align;\n                int sps = audiotrack->sub_packet_size;\n                int cfs = audiotrack->coded_framesize;\n                int h = audiotrack->sub_packet_h;\n                int y = audiotrack->sub_packet_cnt;\n                int w = audiotrack->frame_size;\n                int x;\n                if (!audiotrack->pkt_cnt) {\n                    if (st->codec->codec_id == CODEC_ID_RA_288)\n                        for (x=0; x<h/2; x++)\n                            memcpy(audiotrack->buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs);\n                    else\n                        for (x=0; x<w/sps; x++)\n                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n                    if (++audiotrack->sub_packet_cnt >= h) {\n                        audiotrack->sub_packet_cnt = 0;\n                        audiotrack->pkt_cnt = h*w / a;\n                    }\n                }\n                while (audiotrack->pkt_cnt) {\n                    pkt = av_mallocz(sizeof(AVPacket));\n                    av_new_packet(pkt, a);\n                    memcpy(pkt->data, audiotrack->buf\n                           + a * (h*w / a - audiotrack->pkt_cnt--), a);\n                    pkt->pos = pos;\n                    pkt->stream_index = stream_index;\n                    matroska_queue_packet(matroska, pkt);\n                }\n            } else {\n                int result, offset = 0, ilen, olen, pkt_size = lace_size[n];\n                uint8_t *pkt_data = data;\n                if (matroska->tracks[track]->encoding_scope & 1) {\n                    switch (matroska->tracks[track]->encoding_algo) {\n                    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n                        offset = matroska->tracks[track]->encoding_settings_len;\n                        break;\n                    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n                        pkt_data = NULL;\n                        do {\n                            ilen = lace_size[n];\n                            olen = pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data,\n                                                  pkt_size+LZO_OUTPUT_PADDING);\n                            result = lzo1x_decode(pkt_data, &olen, data, &ilen);\n                        } while (result==LZO_OUTPUT_FULL && pkt_size<10000000);\n                        if (result) {\n                            continue;\n                        }\n                        pkt_size -= olen;\n                        break;\n#ifdef CONFIG_ZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n                        z_stream zstream = {0};\n                        pkt_data = NULL;\n                        if (inflateInit(&zstream) != Z_OK)\n                            continue;\n                        zstream.next_in = data;\n                        zstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            zstream.avail_out = pkt_size - zstream.total_out;\n                            zstream.next_out = pkt_data + zstream.total_out;\n                            result = inflate(&zstream, Z_NO_FLUSH);\n                        } while (result==Z_OK && pkt_size<10000000);\n                        pkt_size = zstream.total_out;\n                        inflateEnd(&zstream);\n                        if (result != Z_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n#ifdef CONFIG_BZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n                        bz_stream bzstream = {0};\n                        pkt_data = NULL;\n                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n                            continue;\n                        bzstream.next_in = data;\n                        bzstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n                            result = BZ2_bzDecompress(&bzstream);\n                        } while (result==BZ_OK && pkt_size<10000000);\n                        pkt_size = bzstream.total_out_lo32;\n                        BZ2_bzDecompressEnd(&bzstream);\n                        if (result != BZ_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n                    }\n                }\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, pkt_size+offset) < 0) {\n                    av_free(pkt);\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                if (offset)\n                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n                memcpy (pkt->data+offset, pkt_data, pkt_size);\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n                matroska_queue_packet(matroska, pkt);\n            }\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}", "idx": 17412, "substitutes": {"track": ["offset", "check", "round", "rm", "index", "sort", "nt", "form", "ord", "t", "Track", "dist", "dd", "trak", "store", "stream", "tar", "port", "set", "mount", "move", "find", "count", "hold", "tn", "tr", "match", "step", "ct", "seek", "rec", "name", "stat", "handle", "rack", "attr", "dr", "head", "tab", "mark", "time", "order", "race", "cmd", "roll", "ind", "record", "tag", "field", "sync", "train", "str", "pack", "transform", "rank", "path", "claim", "fire", "ack", "metadata", "tracks", "txt", "token", "row", "brand", "bind", "ctr", "trace", "col", "tracking"], "st": ["sc", "sam", "stable", "nt", "z", "t", "p", "sp", "stage", "store", "stream", "th", "h", "end", "set", "rt", "fr", "station", "tmp", "tr", "cast", "ste", "mt", "stat", "ch", "stop", "sw", "ct", "St", "sts", "start", "se", "dr", "obj", "sn", "step", "ost", "storage", "pt", "inst", "std", "ST", "str", "sta", "est", "ack", "bt", "irst", "nd", "s", "tt", "rest", "src", "sl", "stack"], "pkt": ["pwk", "pft", " pwk", " pft", "cpqt", "pbft", "pqt", "pbkt", "pbwk", "cpwk", "cpft", " pqt", "pbqt", "cpkt"], "origdata": ["limdata", "liminput", "originbytes", "coorddata", "Origdat", "origbytes", " origata", "coordstr", "limdat", "coorddat", "originata", "originstr", "origstr", "origdat", "originalinput", "originaldat", "origata", "coordata", "coordbytes", "originalata", "origindata", "originaldata", " origstr", " originput", "originput", "Origdata", "Origata", " origdat", " origbytes", "Origbytes", "limata", "origindat"], "block_time": ["lock_times", " block_length", "blockingrate", "block_times", "block_length", "blockinginfo", "lock_length", "blockingtime", "block_size", "blockinglength", " block_info", " block_rate", "block_info", "block_rate", "lock_time", "lock_size"], "lace_size": ["line_len", "block_length", "line_length", "line_speed", "block2speed", "block2size", "block_size", "blockmentspeed", "blockmentlength", "block_len", "blockmentlen", "block_speed", "line_size", "block2length", "blockmentsize", "block2len"], "n": ["na", "pos", "np", "nt", "z", "l", "size", "t", "i", "p", "en", "cn", "dn", "h", "ne", "count", "g", "ni", "mn", "d", "ns", "ln", "k", "nn", "nor", "sn", "nb", "c", "nu", "number", "N", "nan", "o", "nm", "nc", "len", "nr", "s", "an", "y", "m"], "flags": ["fields", "times", "fps", "ops", "args", "flag", "bits", "settings", "events", "members", "frames", "vals", "values", "tags", "mask", "ants", "types", "styles", "ats", "options", "fs", "ags", "acks", "ints", "weights", "ts", "faces", "features", "tracks", "actions", "locks", "links", "metadata", "FLAG", "parts", "stats", "ms", "heads", "lag", "items", "status", "Flags", "comments"], "num": ["offset", "snap", "mem", "index", "nom", "sam", "ord", "window", "max", "valid", "th", "end", "set", "zero", "sum", "count", "annot", "node", "mn", "rec", "reg", "add", "rem", "sn", "mark", "nb", "msg", "nu", "id", "common", "um", "uni", "new", "cal", "local", "mon", "number", "Num", "extra", "mult", "dim", "coord", "nm", "block", "row", "pn", "no", "un", "nr", "NUM", "nam", "m"], "stream_index": ["streamxaddress", "video_position", "streammatchindex", "drawityinstance", "box_index", "stream_name", "reammatchid", "track_interface", "stream_position", "draw_instance", "streamtloc", "thread_info", "stream_id", "streamityseed", "stream_instance", "video_no", "boxityindex", "thread_pos", "reammatchindex", "streamxinterface", "streamzval", "draw_val", "box_success", "box_id", "stream_i", "streamityinstance", "streamesuccess", "track_address", "streamzi", "stream9address", "stream_ind", "reammatchloc", "streamityi", "streamityid", "streamzinstance", "stream_loc", "boxitysuccess", "drawityindex", "stream_address", "streamityval", "streamtid", "track_id", "stream9index", "video_index", "streameindex", "ream_loc", "track_index", "thread_index", "streamtname", "draw_i", "boxityseed", "video_ind", "ream_index", "streameseed", "stream9id", "ream_name", "streamitysuccess", "streamxid", "stream_success", "box_seed", "streamityindex", "boxityid", "streameid", "stream_no", "streamtindex", "streammatchname", "stream_pos", "ream_id", "stream9interface", "streamxindex", "drawityi", "draw_index", "reammatchname", "drawityval", "thread_id", "stream_val", "streamzindex", "streammatchloc", "stream_interface", "stream_info", "streammatchid", "stream_seed"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)\n\n{\n\n    c->high = 255;\n\n    c->bits = -16;\n\n    c->buffer = buf;\n\n    c->end = buf + buf_size;\n\n    c->code_word = bytestream_get_be24(&c->buffer);\n\n}\n", "idx": 17413, "substitutes": {"c": ["con", "ic", "cs", "cv", "tc", "l", "ca", "z", "ci", "p", "mc", "ec", "h", "enc", "at", "err", "cand", "pc", "ae", "gc", "e", "count", "cam", "config", "cf", "content", "cc", "ct", "bc", "ch", "d", "co", "v", "etc", "cd", "conv", "cont", "cr", "lc", "coll", "dc", "C", "cm", "fc", "ce", "cod", "cu", "cache", "nc", "anc", "xc", "com", "cp", "rc", "ac", "abc", "sc", "b", "conf"], "buf": ["mem", "cap", "pos", "cv", "Buff", "loc", "window", "img", "max", "p", "bb", "bar", "num", "bh", "h", "bp", "ctx", "port", "fb", "count", "vec", "cur", "map", "tmp", " buffer", "queue", "off", "db", "v", "pb", "ptr", "iter", "wb", "msg", "cmd", "ref", "batch", "bound", "rb", "orig", "coord", "cache", "txt", "cb", "block", "true", "uf", "buffer", "ah", "Buffer", "buff", "begin", "b", "seq", "ff", "br", "ered"], "buf_size": ["bufwhandle", "buf_SIZE", "buf1handle", "bufwheight", "buff1offset", " buf_count", "buf2size", " buf_len", "buf1height", "buff1handle", "bufwoffset", "buf1size", "buff_offset", "buff1height", " buf_SIZE", "buf2SIZE", "buf_height", "buf2len", "buf_offset", "buff1size", "buf1offset", "buf_len", "buff_height", "buf_handle", "buff_handle", "buff_size", "buf2count", "bufwsize", "buf_count"]}}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "int vring_pop(VirtIODevice *vdev, Vring *vring,\n\n              VirtQueueElement **p_elem)\n\n{\n\n    struct vring_desc desc;\n\n    unsigned int i, head, found = 0, num = vring->vr.num;\n\n    uint16_t avail_idx, last_avail_idx;\n\n    VirtQueueElement *elem = NULL;\n\n    int ret;\n\n\n\n    /* If there was a fatal error then refuse operation */\n\n    if (vring->broken) {\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* Check it isn't doing very strange things with descriptor numbers. */\n\n    last_avail_idx = vring->last_avail_idx;\n\n    avail_idx = vring->vr.avail->idx;\n\n    barrier(); /* load indices now and not again later */\n\n\n\n    if (unlikely((uint16_t)(avail_idx - last_avail_idx) > num)) {\n\n        error_report(\"Guest moved used index from %u to %u\",\n\n                     last_avail_idx, avail_idx);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* If there's nothing new since last we looked. */\n\n    if (avail_idx == last_avail_idx) {\n\n        ret = -EAGAIN;\n\n        goto out;\n\n    }\n\n\n\n    /* Only get avail ring entries after they have been exposed by guest. */\n\n    smp_rmb();\n\n\n\n    /* Grab the next descriptor number they're advertising, and increment\n\n     * the index we've seen. */\n\n    head = vring->vr.avail->ring[last_avail_idx % num];\n\n\n\n    elem = g_slice_new(VirtQueueElement);\n\n    elem->index = head;\n\n    elem->in_num = elem->out_num = 0;\n\n    \n\n    /* If their number is silly, that's an error. */\n\n    if (unlikely(head >= num)) {\n\n        error_report(\"Guest says index %u > %u is available\", head, num);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    if (vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\n        vring_avail_event(&vring->vr) = vring->vr.avail->idx;\n\n    }\n\n\n\n    i = head;\n\n    do {\n\n        if (unlikely(i >= num)) {\n\n            error_report(\"Desc index is %u > %u, head = %u\", i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        if (unlikely(++found > num)) {\n\n            error_report(\"Loop detected: last one at %u vq size %u head %u\",\n\n                         i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        desc = vring->vr.desc[i];\n\n\n\n        /* Ensure descriptor is loaded before accessing fields */\n\n        barrier();\n\n\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n\n            ret = get_indirect(vring, elem, &desc);\n\n            if (ret < 0) {\n\n                goto out;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        ret = get_desc(vring, elem, &desc);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        i = desc.next;\n\n    } while (desc.flags & VRING_DESC_F_NEXT);\n\n\n\n    /* On success, increment avail index. */\n\n    vring->last_avail_idx++;\n\n    *p_elem = elem;\n\n    return head;\n\n\n\nout:\n\n    assert(ret < 0);\n\n    if (ret == -EFAULT) {\n\n        vring->broken = true;\n\n    }\n\n    if (elem) {\n\n        vring_unmap_element(elem);\n\n        g_slice_free(VirtQueueElement, elem);\n\n    }\n\n    *p_elem = NULL;\n\n    return ret;\n\n}\n", "idx": 17428, "substitutes": {"vdev": ["wscan", "vscan", "gswitch", "qDEV", " vconn", "vmswitch", "vswitch", "vdevice", "gdev", "vmdev", "vmdevice", " vdevice", "qdevice", "tdevice", "wDEV", "qscan", "wdevice", " vswitch", "vmconn", "gconn", "vDEV", "tdev", "tDEV", "tscan", "wdev", "vconn", "gdevice", "qdev"], "vring": ["varling", "avrap", "avringe", "vtringe", "svrig", "veding", "avpacking", "veending", "avring", " vning", " vringe", "vng", " varp", "vending", " vling", "vbing", "evning", "svning", "vjing", " vding", "varbinding", "vearp", "svpacking", " vro", " vping", "varjing", "vebinding", "vping", "verap", "avbing", "wring", "vejing", "verding", "veing", "voss", " vpacking", " vbing", "vtbing", "vding", " vbinding", "vpacking", "svringe", "varrap", "verig", "svring", " vjing", "wstring", "vararp", "varring", "evping", "svstring", "wro", "yjing", "vstring", "svping", "vling", "uvning", "vtring", "varng", "varing", "avending", "vbinding", "vringe", "vrap", "avping", "avray", "vning", "verring", "wringe", "svding", "avning", "uvrig", " vng", "vtrap", "uvping", "vray", "svro", "veling", "ving", " ving", " vrap", "yring", "varp", "svjing", "yng", "veray", "verrig", "vro", "avding", " vstring", "evrig", "uvring", "yoss", "evring", " vray", " vending", "vering", " voss", "vrig", "vaross", "verjing"], "p_elem": ["p_elev", "p_selement", "p_selem", "pqelem", "p_Elev", "p_selt", "p_selev", "p_Element", "p_Elem", "p_entlement", "pqselt", "p_Elt", "pqelt", "pqselement", "pqselem", "p_entlt", "p_entlev", "pqselev", "p_entlem", "pqelev", "p_elt", "pqelement", "p_element"], "desc": ["sc", "ds", " enc", "loc", "prev", "dist", "de", "disc", " doc", " des", "sub", " description", "md", " dist", "ec", " diff", "decl", " cont", "Desc", "ript", "buf", " msg", "cur", " dc", "des", "bc", " shr", "rec", "sec", "label", "cd", "esc", " docs", "doc", " cd", "dr", "ef", "asc", " prot", " describe", "description", "cont", "req", "ind", "dir", " dir", "ext", "dev", " resp", "cmp", " de", "def", "dc", "lc", " dep", "dict", "summary", "diff", "str", "ent", "info", "txt", "meta", " det", " sect", " rev", "seq"], "i": ["a", "init", "ic", "index", "ij", "si", "ci", "im", "p", "ki", "list", "num", "h", "ir", "li", "is", "e", "I", " ii", "u", "ai", "phi", "v", "io", "di", "start", "ip", "mi", "pi", "c", "ind", "in", "id", "j", "xi", "inst", "ti", "ui", "n", "o", "ami", "fi", "multi", "bi", "x", "ini", "f", "it", "ix", "us", "b", "y", "ii", "m"], "head": ["size", "back", "ck", "hang", "shift", "hd", "header", "length", "first", "headed", "origin", "headers", "med", "rank", "orig", "foot", "heading", "heads", "offset", "mem", "check", "index", "form", "max", "front", "list", "then", "end", "set", "sum", "start", "doc", "add", "Head", "root", "n", "len", "it", "begin", "min", "init", "depth", "mm", "num", "th", "tr", "each", "body", "height", "um", "high", "dict", "block", "row", "loop", "next", "pos", "pop", "window", "ax", "before", "md", "h", "count", "map", "off", "dr", "push", "cmd", "ind", "id", "new", "top", "HEAD", "tail", "us", "ff"], "avail_idx": ["availitystartxf", "avail_idxf", "avail_dc", "avail_Idox", "avail_idxt", "availityidxf", "availitystartx", "avail_dx", "avail_idxc", "avail_dxc", "avail_ridx", "availityidx", "avail_idexes", "availityidox", "avail_codexc", "avail_idexc", "avail_midb", "avail_startx", "avail_idb", "avail_ridxc", "avail_startxf", "avail_keyxes", "avail_ridxt", "avail_ideox", "avail_idc", "avail_codex", "avail_startox", "avail_midxc", "availitystartox", "avail_midxf", "avail_codext", "avail_midx", "avail_Idxf", "avail_idec", "avail_idexs", "avail_dxf", "avail_idox", "avail_keyxc", "avail_db", "avail_idxs", "avail_idex", "avail_midc", "avail_keyxs", "avail_idxes", "avail_keyx", "avail_Idx", "avail_idexf"], "last_avail_idx": ["last_avail_idp", "last_avail_midx", "last_avail_Idx", "last_avail_idg", "last_avail_Idxc", "last_avail_indx", "last_avail_uidc", "last_avail_ridp", "last_avail_idxs", "last_avail_idsxc", "last_avail_ideg", "last_avail_idec", "last_avail_ridn", "last_avail_indy", "last_avail_idexf", "last_avail_inn", "last_avail_uidj", "last_avail_idsy", "last_avail_indxf", "last_avail_uidy", "last_avail_ridx", "last_avail_idey", "last_avail_idsx", "last_avail_ity", "last_avail_idj", "last_avail_idexs", "last_avail_ing", "last_avail_idxf", "last_avail_itc", "last_avail_iny", "last_avail_midn", "last_avail_uidx", "last_avail_indn", "last_avail_idy", "last_avail_idxc", "last_avail_itj", "last_avail_iden", "last_avail_idej", "last_avail_midp", "last_avail_inx", "last_avail_inxs", "last_avail_itx", "last_avail_Idg", "last_avail_idex", "last_avail_idn", "last_avail_idc", "last_avail_idsxs", "last_avail_idexc"], "elem": ["berem", "endom", " erem", "neom", "selev", "entlev", "entlem", "endlev", "legem", " element", "nelement", "beom", "eom", " elev", " ept", "pelev", "selement", "elegem", "erlev", "nelem", "erem", "belev", "eelement", "eept", "perem", "erlem", "eelem", "seom", "egem", "lelem", "elelement", "endlement", "enlev", "endlem", "engem", "entval", "lelev", "lelement", "entlement", "aeld", "pelem", "eval", " eom", "ept", "erlement", "enlem", "belem", "nelev", "selem", "element", " eld", "aelem", "aelement", "aept", "eeld", "peom", "eld", " eval", "elelem", "enlement", "elelev", "elev", "erval"], "ret": ["mem", "rm", " RET", "res", "nt", "t", "back", "opt", "dt", "result", "ll", "at", "over", "err", "rt", "arg", "mt", "nz", "out", "Return", "cont", "dr", "lt", "ft", " Ret", "rem", "sys", "cat", "RET", "reset", "re", "det", "pt", "rev", "lit", "att", "try", "nl", "ref", "cmd", "ext", "addr", "val", " resp", "def", "str", "print", "alt", "ts", "ert", "net", "resp", "gt", "url", " res", "elt", "rets", "Ret"], "found": ["missing", "needed", "pos", "index", "killed", "loaded", "stable", "fd", "used", "sent", "valid", "front", "num", "required", "good", "find", "count", "done", "Found", "fat", "failed", "fe", "built", "d", "iter", " Found", "body", "finished", "inner", "recent", "n", "finder", "f", "seen", "fun", "ff", "old", "fl"]}}
{"project": "FFmpeg", "commit_id": "bc29acdc76fdbf70700cdc2f85fc2afb46e19e47", "target": 0, "func": "static int ftp_connect_control_connection(URLContext *h)\n\n{\n\n    char buf[CONTROL_BUFFER_SIZE], opts_format[20];\n\n    int err;\n\n    AVDictionary *opts = NULL;\n\n    FTPContext *s = h->priv_data;\n\n    const int connect_codes[] = {220, 0};\n\n\n\n    s->conn_control_block_flag = 0;\n\n\n\n    if (!s->conn_control) {\n\n        ff_url_join(buf, sizeof(buf), \"tcp\", NULL,\n\n                    s->hostname, s->server_control_port, NULL);\n\n        if (s->rw_timeout != -1) {\n\n            snprintf(opts_format, sizeof(opts_format), \"%d\", s->rw_timeout);\n\n            av_dict_set(&opts, \"timeout\", opts_format, 0);\n\n        } /* if option is not given, don't pass it and let tcp use its own default */\n\n        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,\n\n                         &s->conn_control_interrupt_cb, &opts);\n\n        av_dict_free(&opts);\n\n        if (err < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Cannot open control connection\\n\");\n\n            return err;\n\n        }\n\n\n\n        /* consume all messages from server */\n\n        if (!ftp_status(s, NULL, connect_codes)) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP server not ready for new users\\n\");\n\n            err = AVERROR(EACCES);\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_auth(s)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP authentication failed\\n\");\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_type(s)) < 0) {\n\n            av_dlog(h, \"Set content type failed\\n\");\n\n            return err;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17439, "substitutes": {"h": ["help", "hs", "history", "here", "hh", "oh", "z", "w", "hi", "sh", "kh", "p", "he", "hz", "th", "hash", "bh", "ha", "hr", "hd", "ht", "tr", "handle", "m", "her", "ch", "v", "hw", "k", "H", "ih", "http", "hm", "c", "hp", "j", "r", "host", "ph", "zh", "dh", "rh", "ah", "f", "hal", "b", "y", "eh", "hl"], "buf": ["xff", "cap", "cv", "Buff", "box", "window", "w", "p", "proc", "rw", "port", "bh", "ctx", "fr", "cur", "tmp", "vp", "tr", " buffer", "queue", "BU", "off", "pg", "conv", "v", "bytes", "ptr", "iter", "wb", "data", "cmd", "msg", "ref", "pool", "batch", "raw", "str", "rb", "txt", "cb", "block", "bin", "uf", "rc", "buffer", "cp", "Buffer", "fp", "buff", " b", "b", "seq", "ff", "br"], "opts_format": ["opts_Format", "opts_mat", "optsxFormat", "optsxformat", "opts_style", "opts_data", "optsxstring", "opt_format", "opts_size", "opt_data", "opt_Format", "optx_format", "opts_string", "ops_Format", "optx_style", "opt_string", "opts_form", "optx_size", "ops_style", "optsxdata", "ops_mat", "ops_data", "optx_Format", "ops_form", "ops_format"], "err": ["error", "pr", "score", "test", "kr", "e", "eas", "fr", " terr", "rs", " ptr", "rr", "fer", " score", "iter", "aaa", "sys", "plain", "diff", "errors", "er", "eor", "rn", "lr", "here", "die", "or", " len", "t", "norm", "gz", "end", " Err", "mr", "fee", "msg", "cr", "usr", " ec", "resp", "urg", "it", "org", "ctr", "elt", "res", " cr", "term", "ner", "actor", "eh", " er", "all", "warn", "ptr", "attr", "js", "order", "any", "ev", " resp", "cmp", "cfg", "raw", "str", "act", "rb", "notice", "txt", "nr", "rc", "der", " res", "arr", " rc", "deg", "i", "timer", "empty", "out", "off", "Er", "dr", "rev", "cmd", "ind", "r", "cer", "dy", "coord", "cb", "conf", "trace", "br"], "opts": ["OPcs", "popps", "atts", "oppt", "iopps", "OPts", "optcs", "opt", "iopouts", "copts", "optpt", "OPps", "pps", "poppt", "pts", "optfs", "popTS", "iopfs", "optuts", "copTS", "iopcs", "opcs", "coprs", "copfs", "opouts", "optts", "oprs", "coppt", "pt", "oputs", "att", "ioprs", "optouts", "copt", "popts", "optTS", "opTS", "iopt", "opps", "atuts", "opfs", "optrs", "atps", "copps", "iopts", "OPouts", "optt", "optps"], "s": ["a", "sc", "hs", "ds", "cs", "os", "l", "z", "t", "w", "i", "sh", "p", "sb", "sp", "details", "changes", "as", "sq", "its", "th", "aws", "set", "qs", "is", "bs", "sym", "g", "sv", "rs", "gs", "S", "ss", "so", "sw", "ns", "v", "sts", "vs", "self", "se", "ps", "sys", "js", "c", "j", "es", "ats", "r", "comm", "https", "n", "fs", "source", "ts", "x", "ssl", "ls", "parts", "ims", "stats", "spec", "sl", "b", "y", "serv", "m"], "connect_codes": ["connectablelines", "connectablecode", "connectablecodes", " connect_lines", "connectableodes", "connectingcodes", " connect_files", "connect_files", " connect_code", "connect_lines", "connectinglines", "connect_code", " connect_odes", "connectablefiles", "connect_ids", "connectableids", "connect_odes", " connect_ids", "connectingids"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n", "idx": 17449, "substitutes": {"dev": ["debug", " device", "mem", "die", "nt", "w", "window", "de", "pad", "p", "dep", "Dev", "var", "desc", "md", "store", "test", "h", "end", "device", "stick", "DEV", "cam", "link", "ad", "d", "v", "di", "serial", "hw", "ve", "addr", "spec", "driver", "gate", "watch", "ev", "def", "develop", "env", "info", "block", "Device", "go", "ver", "devices", "dem", "exec", "event", "dd", "serv"], "data": ["a", "mem", "offset", "t", "window", "pad", "p", "as", "tx", "aw", "device", "ata", "dat", "map", "image", "ad", "d", "DATA", "address", "bytes", "reg", "da", "Data", "ptr", "attr", "add", "start", "addr", "obj", "any", "id", "r", "val", "batch", "n", "nd", "buffer", "m"], "buf": ["mem", "cap", "cv", "Buff", "box", "arr", "pad", "var", "bar", "bh", "vec", " msg", "map", " buffer", "bg", "queue", "bc", "v", "bytes", "doc", "bl", "cmd", " bu", "msg", "ref", "batch", "bf", " bl", " avail", "cb", "block", "uf", "bin", " buff", "buffer", "Buffer", "buff", "b", "seq", "ff", "br"], "len": [" length", "mem", "pos", "cap", "loc", "l", "el", "nt", "size", "num", "en", "lf", "ll", "h", "enc", "end", "fil", "ret", "vec", "wid", " l", "length", "fin", "ln", "bytes", "nl", "lit", "ref", "n", " bl", "lan", "lim", " clen", "Len", "elt", "seq", "trans"]}}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static int is_intra_more_likely(ERContext *s)\n\n{\n\n    int is_intra_likely, i, j, undamaged_count, skip_amount, mb_x, mb_y;\n\n\n\n    if (!s->last_pic.f || !s->last_pic.f->data[0])\n\n        return 1; // no previous frame available -> use spatial prediction\n\n\n\n    undamaged_count = 0;\n\n    for (i = 0; i < s->mb_num; i++) {\n\n        const int mb_xy = s->mb_index2xy[i];\n\n        const int error = s->error_status_table[mb_xy];\n\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n\n            undamaged_count++;\n\n    }\n\n\n\n    if (s->avctx->codec_id == AV_CODEC_ID_H264 && s->ref_count <= 0)\n\n        return 1;\n\n\n\n    if (undamaged_count < 5)\n\n        return 0; // almost all MBs damaged -> use temporal prediction\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    // prevent dsp.sad() check, that requires access to the image\n\n    if (CONFIG_MPEG_XVMC_DECODER    &&\n\n        s->avctx->xvmc_acceleration &&\n\n        s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I)\n\n        return 1;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs\n\n    is_intra_likely = 0;\n\n\n\n    j = 0;\n\n    for (mb_y = 0; mb_y < s->mb_height - 1; mb_y++) {\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int error;\n\n            const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n\n\n            error = s->error_status_table[mb_xy];\n\n            if ((error & ER_DC_ERROR) && (error & ER_MV_ERROR))\n\n                continue; // skip damaged\n\n\n\n            j++;\n\n            // skip a few to speed things up\n\n            if ((j % skip_amount) != 0)\n\n                continue;\n\n\n\n            if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I) {\n\n                int *linesize = s->cur_pic.f->linesize;\n\n                uint8_t *mb_ptr      = s->cur_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n                uint8_t *last_mb_ptr = s->last_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n\n\n                if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n\n                    // FIXME\n\n                } else {\n\n                    ff_thread_await_progress(s->last_pic.tf, mb_y, 0);\n\n                }\n\n                is_intra_likely += s->mecc->sad[0](NULL, last_mb_ptr, mb_ptr,\n\n                                                   linesize[0], 16);\n\n                is_intra_likely -= s->mecc->sad[0](NULL, last_mb_ptr,\n\n                                                   last_mb_ptr + linesize[0] * 16,\n\n                                                   linesize[0], 16);\n\n            } else {\n\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n\n                   is_intra_likely++;\n\n                else\n\n                   is_intra_likely--;\n\n            }\n\n        }\n\n    }\n\n    return is_intra_likely > 0;\n\n}\n", "idx": 17452, "substitutes": {"s": ["sg", "bits", "details", "results", "e", "g", "rs", "vs", "self", "sys", "ants", "c", "comm", "fs", "space", "er", "sac", "series", "ex", "spec", "os", "ops", "scl", "t", "events", "qs", "S", "ss", "sts", "v", "ps", "n", "ts", "ls", "parts", "ains", "aunts", "stats", "a", "ies", "services", "ds", "cs", "times", "as", "sb", "ses", "changes", "als", "sv", "sw", "http", "js", "source", "states", "b", "has", "hs", "p", "ins", "sq", "aws", "h", "is", "bs", "gs", "ns", "ties", "sports", "ats", "r", "less", "ims", "full", "its"], "is_intra_likely": ["is_intraOlikely", "is_intras_specific", "is_intra_light", "is_intras_li", "is_intras___likely", "is_intras___lit", "is_intra___similar", "is_intraOsimple", "is_intra_li", "is_intra___specific", "is_intra___li", "is_intra___lit", "is_intra_simple", "is_intra___simple", "is_intra_lit", "is_intra_specific", "is_intra_similar", "is_intras_similar", "is_intraOlit", "is_intra___light", "is_intras_simple", "is_intras___li", "is_intras_likely", "is_intras_light", "is_intras___simple", "is_intraOli", "is_intras_lit", "is_intra___likely"], "i": ["init", "ic", "index", "ij", "si", "ci", "im", "p", "ki", "qi", "me", "h", "li", "is", "\u0438", "e", "point", "I", "u", "ai", "phi", "ori", "v", "di", "cli", "ip", "PI", "any", "mi", "pi", "my", "ind", "id", "in", "xi", "try", "oi", "ti", "ui", "gi", "n", "multi", "bi", "x", "ims", "by", "zi", "sim", "ini", "ie", "f", "chain", "it", "ix", "us", "ex", "iu", "y", "ii", "m"], "j": ["index", "jj", "ij", "l", "z", "t", "p", "sp", "dj", "kj", "q", "bp", "count", "uj", "g", "fr", "J", "jit", "out", "bj", "v", "k", "jl", "js", "json", "ind", "r", "jp", "job", "n", "ji", "o", "aj", "jump", "nr", "f", "it", "jc", "b", "y", "br", "m"], "undamaged_count": ["undamarded_found", "undamaged7flag", "undamaged_total", "undamaged_c", "undamaged_call", "undamaged_counter", "undamagedtCount", "undamined_count", "undamages_c", "undaminedtCount", "undamage_num", "undamage_try", "undamaged___Count", "undaminedtcounter", "undamageditytotal", "undamages_call", "undamageditycount", "undamage_Count", "undamaged__num", "undamagedptindex", "undamaged__try", "undamages_total", "undamarded_type", "undamagedptflag", "undamagedtmax", "undaminedtmax", "undamagedtcounter", "undamined_counter", "undamaged_index", "undamaged7count", "undamaged___try", "undamagedityc", "undamaged_num", "undamaged__Count", "undamaged_flag", "undamaged_found", "undamage_flag", "undamage_index", "undamaged___count", "undamaged_type", "undamages_count", "undamagedtcount", "undamaged__count", "undamageditycall", "undamaged_max", "undamaged7index", "undamaged_try", "undamined_max", "undamined_Count", "undamarded_count", "undaminedtcount", "undamage_count", "undamaged_Count", "undamaged___num", "undamagedptcount"], "skip_amount": [" skip_factor", "sleep_add", "skip2amount", " skip_Amount", "skipTimefactor", "skip2Amount", "skipTimeAmount", "sleep_amount", "skip_add", "sleep_count", "skipTimeamount", "skip_count", "skip_Amount", "skip_factor", "sleep_Amount"], "mb_x": ["mop_x", "emb_ix", "meta_x", "mb_xy", "ib_x", "mb__xp", "mb__x", "mb__y", "mbaxyy", "umb_y", "mb_only", "mb_name", "mb_column", "mop_w", "mbaxyox", "umb_column", "mb_lex", "mb_ox", "metaaxylex", "mbaxyname", "umbaxyx", "mb___y", "meta_ox", "umb_x", "emb_y", "umbaxyex", "meta_name", "mb_width", "ib__xp", "mb_ix", "mbaxyx", "emb_xy", "mb_w", "ib__x", "ib_xp", "mop_only", "mb___x", "mbaxyex", "mb_xx", "metaaxyox", "ib__width", "ib_y", "ib_width", "mbaxylex", "metaaxyx", "umbaxyy", "emb_x", "mop_xx", "mbaxycolumn", "meta_lex", "mb_xp", "ib__y", "mb___width", "mb___xp", "umbaxycolumn", "umb_ex", "mb__width", "metaaxyname", "mb_ex"], "mb_y": ["gb_asy", "mb_xy", "mb_yn", "mb___iy", "mb__y", "mbaxyy", "mb_year", "gb_iy", "mg_yn", "mb____y", "mp_py", "mb_py", "gb_y", "mb____ye", "MB_yy", "mb___y", "mg_ny", "mb_ye", "mb____iy", "mb_ny", "mb___Y", "mb__yy", "mb_yl", "gb_ye", "mb___yl", "mp_xy", "mg_year", "mbaxyyn", "mbaxyyear", "mx_y", "mb_yy", "mx_iy", "mb__Y", "mb_my", "mb_ey", "mx_Y", "mbaxyny", "MB_Y", "MB_y", "mb_iy", "mp_y", "mb__my", "mg_y", "mx_yl", "mp_ey", "mb_asy", "MB_my", "mb____asy", "mb_Y"], "AV_PICTURE_TYPE_I": ["AV_PICTURE_TYPE__III", "AV_PICTURE_TYPE_P", "AV_PICTURE_TYPE_IN", "AV_PICTURE_TYPE__IN", "AV_PICTURE_TYPE_II", "AV_PICTURE_Type_III", "AV_PICTURE_Type_I", "AV_PICTURE_TYPE__II", "AV_PICTURE_Type_INFO", "AV_PICTURE_Type_P", "AV_PICTURE_TYPE__P", "AV_PICTURE_TYPE_III", "AV_PICTURE_TYPE__I", "AV_PICTURE_Type_II", "AV_PICTURE_Type_IN", "AV_PICTURE_TYPE__INFO", "AV_PICTURE_TYPE_INFO"], "error": ["iso", "valid", "ception", "feature", "option", "ERROR", "ace", "owner", "raise", "relation", "rank", "errors", "er", "attribute", "angle", "danger", "check", "channel", "or", " Error", "ory", "result", "timeout", "lock", "link", "command", "force", "detail", "description", "re", "ror", "try", "root", "complete", "entry", "it", "code", "event", "err", "style", "terror", "comment", "close", "query", "stroke", "ion", "address", "bug", "serial", "progress", "instance", "order", "warning", "storage", "ignore", "panic", "info", "row", "alpha", "no", "machine", "debug", "rage", "delete", "Error", "change", "volume", "success", "data", "ance", "id", "r", "extra", "alias", "function", "type"], "linesize": ["inesize", "elsiz", "elsizer", "linesz", " linesiz", "lsizer", "elsize", "lsize", "lsiz", "elsz", " linespace", "linespace", "lspace", "pointsiz", "pointsz", "pointsize", "pointsizer", "linesizer", "linesiz", "inesizer", " linesizer", "pointspace", "inesiz", "inesz"]}}
{"project": "FFmpeg", "commit_id": "4d321bff85cf1e9b6a18b915af185494b5ea94b6", "target": 1, "func": "void Release(void *ctx)\n\n{\n\n    ContextInfo *ci;\n\n    ci = (ContextInfo *) ctx;\n\n\n\n    if (ci->cache) {\n\n        imlib_context_set_image(ci->cache->image);\n\n        imlib_free_image();\n\n        av_free(ci->cache);\n\n    }\n\n    if (ctx) {\n\n        if (ci->imageOverlaid) {\n\n            imlib_context_set_image(ci->imageOverlaid);\n\n            imlib_free_image();\n\n        }\n\n        ff_eval_free(ci->expr_x);\n\n        ff_eval_free(ci->expr_y);\n\n        ff_eval_free(ci->expr_R);\n\n        ff_eval_free(ci->expr_G);\n\n        ff_eval_free(ci->expr_B);\n\n        sws_freeContext(ci->toRGB_convert_ctx);\n\n        sws_freeContext(ci->fromRGB_convert_ctx);\n\n        av_free(ctx);\n\n    }\n\n}\n", "idx": 17480, "substitutes": {"ctx": ["cv", "cs", "tc", "ca", "ck", "tx", "mc", "bh", "kt", "rect", "ja", "unc", "pc", "rt", "gc", "cas", "cf", "xp", "tmp", "sci", "crit", "jac", "vc", "cc", "ct", "bc", "kw", "co", "hw", "obj", "wx", "xs", "cmd", "pkg", "ind", "msg", "jp", "context", "cmp", "cfg", "voc", "cm", "act", "ce", "cu", "txt", "info", "x", "cb", "unk", "anc", "qt", "xc", "resp", "cp", "que", "ia", "sc"], "ci": ["yi", "vi", "ctl", "ic", "cs", "see", "ico", "cgi", "ca", "slice", "i", "CI", "ki", "qi", "ani", "cand", "ati", "ice", "ni", "ace", "cf", "sci", "link", "aci", "ai", "jac", "cc", "ct", "cci", "co", "cit", "di", "cli", "cont", "coe", "cor", "mi", "c", "pi", "cia", "uci", "oci", "cil", "ti", "imi", "ctrl", "adi", "lc", "cm", "fi", "cod", "ce", "lic", "fc", "cu", "circ", "zi", "ini", "com", "cp", "icc", "ix", "irc", "parse", "ii"]}}
{"project": "qemu", "commit_id": "6e5d97d01d9da6f295f9888d4b34e29fd737861a", "target": 1, "func": "void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n", "idx": 17482, "substitutes": {"node": ["index", "fn", "nt", "server", "t", "window", "component", "desc", "num", "bar", "proc", "list", "remote", "ctx", "handler", "good", "normal", "child", "tmp", "tree", "handle", "nw", "image", "name", "k", "self", "nn", "instance", "obj", "peer", "object", "manager", "container", "c", "holder", "page", "id", "msg", "cmd", "note", "Node", "ref", "master", "parent", "field", "host", "root", "local", "post", "n", "ode", "scene", "key", "source", "cache", "info", "cb", "row", "type", "entry", "f", "slave", "event", "m"], "ret": ["round", "rm", "pub", "res", "nt", "pret", "arr", "t", "deg", "flag", "ter", "num", "vt", "result", "Ret", "vet", "ount", "compl", "rt", "fr", " terr", "tmp", "tr", "mt", "nz", "out", "mb", "v", "inter", "lt", "ft", "rem", "success", "cat", "RET", "quad", "re", "cmd", "det", "ext", "j", "val", " resp", " sr", "rets", "def", "print", "pat", "pas", "usr", "alt", "mult", "ert", "cert", "net", "len", "resp", "gt", " res", "elt", " alt", "red", "err"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n", "idx": 17513, "substitutes": {"s": ["a", "ds", "cs", "scl", "sg", "w", "p", "sb", "as", "sq", "aws", "h", "is", "e", "sv", "sa", "gs", "rs", "S", "ss", "ns", "ps", "c", "es", "ats", "fs"], "pb": ["bm", "lp", "cv", "np", "wp", "sb", "p", "pp", "bb", "bp", "ub", "pc", "bps", "vp", "tp", " p", "pm", "mp", "xb", " cp", "pd", "jp", "rb", "pa", "uf", "cp", "fp", "lb"], "in": ["IN", "In", "inf", "t", "p", "ins", "input", "ar", "rin", "mat", "data", "ind", "id", "inner", "r", "val", "bin", "gin", "inn", "f", "pin", "inc", "m"], "out": ["OUT", "can", "point", "cast", "conv", "one", "self", "bit", "sync", "cache", "net", "buffer", "chain", "boot", "serv", "check", "os", "server", "t", "list", "result", "ret", "device", "output", "ot", "v", "update", "quiet", "post", "n", "o", "null", "it", "version", "status", "old", "help", "w", "soft", "ne", "Out", "other", "all", "co", "att", "note", "print", "bool", "b", "con", "arr", "outs", "p", "client", "store", "u", "off", "unit", "data", "cmd", "r", "new", "batch", "table", "flat", "over"], "scaled": ["scanded", "ascales", "escalled", "escales", "ascalled", "expales", "ascaled", "expaled", "expalled", "expanded", "escanded", "scalled", "ascanded", "scales", "escaled"], "size": ["offset", "zone", "z", "si", "equal", "max", "num", "set", "shift", "zero", "scale", "count", "g", "empty", "shape", "resolution", "group", "length", "send", "name", "capacity", "area", "sn", "range", "ize", "scope", "number", "dim", "space", "Size", "SIZE", "x", "len", "small", "code", "sc", "sample"], "scale_idx": ["scale_indx", "scale_adxc", "scale_adc", "scale_indxs", "scale_Idxs", "scale_Idxc", "scale_Idc", "scale_indc", "scale_adxs", "scale_idc", "scale_idxc", "scale_Idx", "scale_adx", "scale_indxc", "scale_idxs"], "cb": ["callback", "check", "comb", "cap", "cv", "crop", "bar", "xy", "bp", "family", "cl", "cf", "checked", "func", "clip", "cm", "dc", "bound", "align", "CV", "CB", "coord", "nm", "rc", "loop", "fun", "src", "lr", "lb"], "lambda": ["comb", "dist", "slice", "beta", "aug", "tap", "decl", "imp", "lu", "igma", "distance", "prop", "phi", "lab", "mu", "da", "ima", "mas", "pha", "clip", "lc", "lam", "appa", "margin", "alpha", "params", "fun", "lr"], "uplim": ["uiplrim", "uiplim", "iuppam", "uplrim", "iupprim", "uiplam", "iuplrim", "uppim", "uppib", "upprim", "iuplib", "iuppim", "umlim", "iuplam", "uppam", "uiplib", "umlam", "iuppib", "umlrim", "umlib", "uplib", "iuplim", "uplam"], "bits": ["cs", "ops", "blocks", "fps", "units", "outs", "bool", "limits", "flags", "groups", "ions", "base", "bps", "words", "bs", "planes", "vals", "checks", "pins", "points", "jobs", "ns", "bands", "bytes", "holes", "keys", "ps", "bit", "bis", "ats", "codes", "batch", "bf", "ints", "weights", "ims", "parts", "boot", "heads", "b", "items", "its", "rates"], "ROUNDING": [" ROUNDED", "RINDED", " Roundinging", "RoundingNING", "RINDING", "Roundinging", "ROUNDNING", "RINDNING", "RANDED", "ROUNDED", " RoundingED", " RoundingNING", "RANDING", "RoundingING", " RoundingING", "RINDing", "RoundingED", "ROUNDing", "RANDNING", "RANDing", " ROUNDNING", " ROUNDing"], "i": ["init", "ic", "index", "ij", "this", "si", "t", "ci", "im", "slice", "p", "ei", "qi", "list", "me", "li", "is", "ri", "g", "point", "I", " ii", "prefix", "shape", "ai", "phi", "name", "iq", "v", "di", "cli", "ip", "mi", "pi", "c", "ind", "id", "j", "xi", "ti", "ui", "batch", "gi", "n", "print", "ami", "multi", "uri", "key", "sequence", "bi", "fi", "x", "info", "ims", "iy", "sim", "ini", "zi", "status", "loop", "chain", "it", "ix", "us", "iu", "y", "ii", "m"]}}
{"project": "qemu", "commit_id": "dbb7405d8caad0814ceddd568cb49f163a847561", "target": 1, "func": "static int xen_platform_initfn(PCIDevice *dev)\n{\n    PCIXenPlatformState *d = XEN_PLATFORM(dev);\n    uint8_t *pci_conf;\n    pci_conf = dev->config;\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n    pci_config_set_prog_interface(pci_conf, 0);\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n    platform_ioport_bar_setup(d);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);\n    /* reserve 16MB mmio address for share memory*/\n    platform_mmio_setup(d);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &d->mmio_bar);\n    platform_fixed_ioport_init(d);\n    return 0;\n}", "idx": 17518, "substitutes": {"dev": ["patch", "mem", "debug", "adv", "form", "nt", "server", "dist", "w", "de", "pad", "p", "desc", "Dev", "var", "proc", "en", "app", "test", "ctx", "device", "stick", "DEV", "av", "cam", "des", "ad", "out", "pro", "v", "serial", "hw", "hid", "obj", "ve", "sys", "conn", "sd", "priv", "cmd", "det", "range", "prom", "ev", "val", "draw", "def", "raw", "develop", "n", "er", "info", "Device", "go", "ver", "devices", "scan", "it", "dem", "spec", "conf", "serv"], "d": ["debug", "ds", "fd", "z", "l", "t", "w", "de", "p", "dt", "dj", "md", "h", "dis", "g", "dat", "dl", "done", "bd", "m", "ad", "db", "v", "di", "out", "da", "dr", "sd", "data", "c", "ind", "dm", "j", "r", "pd", "std", "dom", "def", "dc", "D", "n", "dict", "o", "dh", "ld", "nd", "dx", "f", "dd", "drivers", "dn"], "pci_conf": ["pcu_config", "pci_config", "pcu_con", "pdi_conf", "pdi_config", "pki_con", "pcgi_con", "pci__config", "pki_cfg", "pai_conf", "pai_conn", "pci_conn", "pki_conn", "pci_map", "pci__conf", "pcu_conn", "pci_cfg", "pai_con", "pci__cfg", "pai_config", "pcu_conf", "pci_con", "pcgi_config", "pci__map", "pdi_cfg", "pki_conf", "pcgi_conn", "pcgi_conf", "pdi_map"]}}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static void mmap_release_buffer(AVPacket *pkt)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res, fd;\n\n    struct buff_data *buf_descriptor = pkt->priv;\n\n\n\n    if (pkt->data == NULL)\n\n        return;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    buf.index = buf_descriptor->index;\n\n    fd = buf_descriptor->fd;\n\n    av_free(buf_descriptor);\n\n\n\n    res = ioctl(fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0)\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n               strerror(errno));\n\n\n\n    pkt->data = NULL;\n\n    pkt->size = 0;\n\n}\n", "idx": 17534, "substitutes": {"pkt": ["spnt", "reprt", " pdu", "pst", "cpnt", "perkt", "spdu", "repkt", "Pkg", "Packet", "pct", "spkt", " pcmd", "psst", "pekg", "pernt", "spacket", "opkt", "packet", "Pnt", "pdu", "cpkt", " prt", "cpct", "cpacket", "opacket", "prt", "pkg", "Pct", "repst", "opnt", " packet", " pkg", " pst", "pnt", "Pdu", "Pkt", "perkg", "pekt", "pskt", "pecmd", "psrt", " pct", "Pcmd", "repacket", "opkg", "pcmd", "psacket", "peracket", "pect", " pnt"], "buf": ["pub", " wr", "img", " bo", "bag", "cam", "cast", "iter", "wb", "nb", "req", "orig", " avail", " bar", "buffer", " b", "mem", "cap", "cv", "Buff", "np", "max", "desc", "var", "bh", "cur", "dat", "tmp", "fac", "pb", "pkg", "pack", "buff", " foo", "begin", " br", "box", "opt", "bar", "proc", " cmd", " msg", "vec", "prop", "tr", "bc", "BU", "alloc", "queue", "ptr", " resp", "cmp", " bl", "rb", "txt", "block", " buff", "b", " arr", "arr", "bs", " buffer", "off", " vec", "feat", " ab", "data", " bu", "cmd", "func", " tmp", "coord", "cb", "uf", "Buffer", "seq", "ff", "br", "bn"], "res": ["pos", "cs", "rez", "os", "nt", "arr", "max", "result", "results", "ress", "ret", "cons", "expr", "bs", "vals", "pres", "rs", "mr", "resolution", "des", "out", "reg", "Res", "ps", "rem", "js", "reset", "rev", "re", "func", "pers", "rel", "r", "val", "gr", "def", "RES", "pas", "act", "sol", "state", "resp", "vol", "rc", "rest", " Res", "ms", "ver", "us", "has", "red", "err"], "fd": ["td", "fed", "ds", "index", "duration", "fn", "size", "window", "desc", "dt", "port", "ctx", "pid", "fr", "dl", "dat", "handle", "seek", "d", "db", "fin", "socket", "ns", "da", "ptr", "addr", "sd", "ind", "dir", "ff", "id", "ud", "dc", "file", "fs", "fi", "fc", "bf", "df", "FD", "gd", "nc", "cb", "fine", "ld", "nd", "f", "buffer", "poll", "fp", "dd", "fl"], "buf_descriptor": ["buf_desccriptors", "buf_descoter", "buf_deccriptor", "buf_desccription", "buf_describory", "buf_escriptory", "buf_escribory", "buf_desccriptory", "buf_escribee", "buf_descdescor", "buf_desccriptive", "buf_desccripter", "buf_describee", "buf_deccriptory", "buf_escriptor", "buf_desccriptee", "buf_descryption", "buf_describeur", "buf_escriptors", "buf_description", "buf_descripter", "buf_descructory", "buf_descripteur", "buf_deccripteur", "buf_descveyive", "buf_descdescors", "buf_descdescee", "buf_describive", "buf_descryptor", "buf_deccripter", "buf_descriptors", "buf_escribor", "buf_descructor", "buf_descrypter", "buf_descryptors", "buf_descriptive", "buf_describer", "buf_desccriptor", "buf_descveyors", "buf_descotion", "buf_describor", "buf_decriptor", "buf_decriptory", "buf_descructeur", "buf_descriptee", "buf_escribors", "buf_descotor", "buf_desriptor", "buf_descructer", "buf_decripter", "buf_decripteur", "buf_desripter", "buf_descriptory", "buf_descdescory", "buf_desriptors", "buf_desriptive", "buf_descotors", "buf_descveyor", "buf_escriptee", "buf_desriptory", "buf_describors", "buf_desription", "buf_desccripteur", "buf_descveyory"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n", "idx": 17548, "substitutes": {"opaque": ["obient", "Opaque", "Oplation", "opient", "operaques", "obaque", "iopque", "opaques", "obity", "operlation", "Opque", "Opaques", "obaques", "oplation", "operque", "iopaque", "obque", "opity", "operient", "opque", "operity", "oblation", "operaque", "iopity", "iopient"], "c2": [" c02", "cp2", "cp1", "c1", " c6", "cc2", "cc1", "gctwo", "p02", "ptwo", "cTwo", "cc6", "p2", " c1", "gc1", "ctwo", "gc2", "cptwo", "c02", "gcTwo", "p6", "pTwo", "cpTwo", "cc02", "c6", "p1"]}}
{"project": "qemu", "commit_id": "9217e26f43df4aab7deaea35b21caacc1f1f854b", "target": 1, "func": "static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n", "idx": 17553, "substitutes": {"bs": ["bm", "hs", "ds", "cs", "lbs", "os", "sb", "BS", "ses", "blog", "ubs", "bp", "ks", "rs", "gs", "ss", "bc", "aus", "ns", "sts", "vs", "bl", "ps", "js", "iss", "ats", "obs", "fs", "ts", "aos", "ls", "ms", "b", "its"], "sector_num": ["sector_id", " sector_id", "sector_Num", " sector_Num", "sector_number", " sector_number"], "buffer": ["channel", "face", "window", "comment", "input", "result", "base", "buf", "command", "length", "address", "bytes", "document", "data", "ref", "binary", "batch", "message", "table", "vector", "cache", "block", "uf", "Buffer", "buff", "byte"], "nb_sectors": ["nb_seors", "nb_specs", "nb_pecs", "nb_speds", "nb_peds", "nb_veds", "nb_seds", "nb_vecs", "nb_peors", "nb_pectors", "nb_speors", "nb_vectors", "nb_spectors", "nb_veors", "nb_secs"], "s": ["ies", "ds", "cs", "t", "sb", "p", "as", "ses", "sq", "h", "set", "qs", "is", "sv", "rs", "gs", "sa", "S", "ss", "ns", "v", "sts", "ps", "js", "j", "es", "ats", "n", "fs", "less", "ts", "ls", "an", "stats", "sis", "sl", "b", "its"]}}
{"project": "FFmpeg", "commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "target": 1, "func": "static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n", "idx": 17554, "substitutes": {"fmt_ctx": ["fmt2context", "fnt_cb", "fnt_pkg", "fwk_pkg", "fmt2pkg", "fmt_cm", "flt_pkg", "fmt_context", "fwk_cm", "fwk_ctx", "fmt2ctx", "flt_context", "fmt2tx", "fnt_ctx", "fnt_context", "fmt_pkg", "flt_tx", "fwk_context", "fmt_cb", "fmt_tx", "flt_ctx"], "pkt": ["promt", "lpct", " pmt", "cpnt", "ppkg", "Packet", "pct", "paynt", "lpkg", "pac", "pmt", "ppac", "ppacket", "ppct", "lpkt", "proac", "cpet", "packet", "pcacket", "proacket", "Pnt", "cpkt", "ppet", "lpacket", "pet", "cpacket", "pkg", "pckt", " packet", " pkg", "pnt", "payacket", " pac", "Pkt", "Pet", " pct", "ppmt", "payet", "ppnt", "ppkt", "pcnt", "prokt", "paykt", "pcet"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17576, "substitutes": {"s": ["bits", "details", "st", "rs", "vs", "se", "self", "sys", "c", "es", "comm", "sync", "fs", "acs", "spec", "serv", "sl", "os", "ops", "t", "sh", "set", "qs", "cons", "syn", "S", "ss", "so", "d", "sts", "v", "ps", "n", "ts", "ls", "parts", "stats", "rest", "sc", "bis", "comments", "services", "ds", "cs", "sb", "changes", "ses", "als", "sv", "stat", "sw", "http", "js", "gets", "states", "hs", "p", "store", "sq", "asm", "h", "is", "bs", "gs", "plays", "out", "ports", "ns", "sports", "pers", "ats", "r", "eps", "less", "ims", "search", "its"], "value": ["index", "ue", " amount", "memory", "VALUE", "weight", "total", "max", "we", "feature", " instance", "sum", "expression", "property", "padding", "length", "values", "Value", "address", "position", "image", " input", "v", "unit", "variable", "ay", " measurement", "description", "data", " Value", "field", "val", "message", "V", "hello", "number", "key", " data", "cache", "x", "attribute", "block", " v", " message", "buffer", " quantity", "code", "byte", "type"], "size": ["offset", "needed", "index", "see", "zone", "z", "si", "equal", "num", "set", "zero", "scale", "sum", "is", "count", "e", "empty", "shape", "length", "send", "position", "name", "start", "capacity", "fee", "ize", "id", "body", "height", "message", "n", "number", "space", "Size", "SIZE", "len", "small", "code"], "i": ["init", "ic", "index", "l", " t", "si", "im", "ci", " count", "p", " n", " ti", "at", "li", "is", "e", "g", "I", " ii", "u", "ai", "phi", " index", " multi", "v", "di", "iter", "ip", "mi", "pi", "c", "ind", " j", "id", "j", "xi", "ti", "batch", "ui", "gi", "n", " I", "o", "multi", "fi", "bi", "x", " m", "sim", "ini", "zi", " bi", "gu", "ie", "chain", "it", "ix", "us", "iu", "y", "ii", "m"], "data_count": ["data_sum", " data_cache", "DATA_length", " data_Count", "dataCountcounter", "data__length", "DATA_code", "dataCountmax", " data_max", "data__index", " data_length", " data_index", "data__count", "DATA_current", "data_Count", "data_code", "DATA_id", "DATA_count", "data_max", "data_index", "dataCountcount", "DATA_cache", "dataCountCount", "DATA_sum", "data_current", "data__cache", "data_cache", " data_counter", "data_counter", "data_length", "data_id"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x14:\t/* IT_STATUS */\n\n        ret = s->ulpd_pm_regs[addr >> 2];\n\n        s->ulpd_pm_regs[addr >> 2] = 0;\n\n        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);\n\n        return ret;\n\n\n\n    case 0x18:\t/* Reserved */\n\n    case 0x1c:\t/* Reserved */\n\n    case 0x20:\t/* Reserved */\n\n    case 0x28:\t/* Reserved */\n\n    case 0x2c:\t/* Reserved */\n\n        OMAP_BAD_REG(addr);\n\n    case 0x00:\t/* COUNTER_32_LSB */\n\n    case 0x04:\t/* COUNTER_32_MSB */\n\n    case 0x08:\t/* COUNTER_HIGH_FREQ_LSB */\n\n    case 0x0c:\t/* COUNTER_HIGH_FREQ_MSB */\n\n    case 0x10:\t/* GAUGING_CTRL */\n\n    case 0x24:\t/* SETUP_ANALOG_CELL3_ULPD1 */\n\n    case 0x30:\t/* CLOCK_CTRL */\n\n    case 0x34:\t/* SOFT_REQ */\n\n    case 0x38:\t/* COUNTER_32_FIQ */\n\n    case 0x3c:\t/* DPLL_CTRL */\n\n    case 0x40:\t/* STATUS_REQ */\n\n        /* XXX: check clk::usecount state for every clock */\n\n    case 0x48:\t/* LOCL_TIME */\n\n    case 0x4c:\t/* APLL_CTRL */\n\n    case 0x50:\t/* POWER_CTRL */\n\n        return s->ulpd_pm_regs[addr >> 2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 17581, "substitutes": {"opaque": ["OPus", "metque", "metca", "Opus", "Opaque", "ipene", "oeter", "obatile", "oplay", " oplay", " opque", "oque", " opatile", "opus", "metene", " opene", "oatile", "obaque", " opeter", "opatile", " opus", "OPque", "Opque", "oaque", "opene", "metaque", "OPlay", "ipque", "opeter", " opca", "obque", "obeter", "opque", "ipaque", "opca", "OPaque", "ipca", "Oplay"], "addr": ["loc", "error", "pad", "tx", "hash", "ctx", "arg", "point", "ad", "inter", "obj", "sha", "bound", "pat", "aro", "hl", "offset", "mem", "index", "np", "var", "sp", "adj", "end", "handle", "start", "hw", "add", "pkg", "align", "usr", "confirmed", "arch", "x", "ack", "Address", "len", "urg", "ctr", "err", "res", "ord", "expr", "adr", "alloc", "name", "address", "reg", "ock", "adder", "ptr", "attr", "order", "act", "alt", "state", "row", "arp", "gt", "ix", "gate", "pos", "work", "arr", "args", "i", "store", "map", "off", "dr", "conn", "data", "cmd", "rev", "ind", "id", "ref", "r", "now", "alias", "coord", "dh", "added", "src"], "size": ["grow", "offset", "l", "z", "sh", "sp", "num", "gz", "scale", "sum", "e", "count", "sy", "g", "empty", "shape", "length", "iz", "send", "address", "m", "area", "fee", "sn", "ize", "scope", "message", "sha", "n", "number", "ze", "space", "Size", "state", "SIZE", "len", "small", "code", "type"], "s": ["services", "a", "hs", "ds", "sam", "states", "cs", "os", "l", "t", "bits", "p", "details", "ess", "ses", "ins", "store", "sq", "als", "sb", "sp", "h", "sm", "is", "bs", "g", "ares", "sv", "rs", "gs", "S", "ss", "sts", "ns", "vs", "aps", "ps", "sys", "js", "service", "c", "xs", "ants", "j", "es", "ats", "r", "fs", "sol", "acs", "ts", "ssl", "ls", "ims", "stats", "spec", "sl", "b", "its", "m"], "ret": ["mem", "rm", " RET", "res", "nt", "pret", "l", "t", "flag", "xt", "result", "last", "rt", "arg", "g", "tr", "mt", "out", "v", "reg", "cont", "get", "lt", "value", " Ret", "rem", "RET", "rev", "re", "det", "reset", "lit", "try", "ref", "r", "jp", "val", "new", "print", "alt", "txt", "len", "uf", "jump", "rest", "f", "gt", "it", "status", "rets", "Ret"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n", "idx": 17587, "substitutes": {"dev": ["mem", " device", "ds", "adv", "os", "nt", "w", "de", "window", "pad", "ach", "p", "Dev", "md", "dis", "h", "ctx", "kr", "device", "DEV", "buf", "cam", "usb", "disk", "des", "ad", "d", "pro", "v", "sw", "serial", "hw", "ptr", "obj", "ve", "priv", "pi", "dm", "ref", "ev", "def", "Device", "ver", "vr", "devices", "dem", "serv", "od", "dd"], "s": ["services", "hs", "ds", "cs", "sam", "l", "sand", "t", "w", "settings", "i", "sb", "as", "details", "ses", "changes", "p", "sq", "sp", "aws", "h", "set", "qs", "is", "g", "sv", "rs", "gs", "sa", "S", "ss", "d", "ports", "ns", "sts", "v", "se", "ps", "sports", "js", "spec", "c", "j", "es", "ats", "r", "sync", "comm", "n", "fs", "sol", "ts", "ls", "su", "stats", "ms", "sis", "sl", "b", "conf", "its", "m"], "dinfo": ["dxinfo", " dfo", " dinf", " dInfo", "Dci", "pinfo", "dxInfo", "dlinformation", "pinf", "DInfo", "finf", "lInfo", "lfo", "dlinfo", "Dinformation", "Dinfo", "fInfo", "dInfo", "dinformation", "ffo", "dlinf", "Dfo", "dxci", "linfo", "finfo", "dinf", "dxinf", " dci", "pInfo", "dci", " dinformation", "dfo", "pfo", "Dinf", "linf", "dlInfo"], "bs": ["bm", "ds", "cs", "lbs", "bits", "its", "sb", "BS", "bb", "ubs", "bh", "bp", "ks", "bas", "bps", "is", "rs", "gs", "ss", "bg", "bd", "bc", "ns", "vs", "pb", "bos", "bl", "ps", "bes", "js", "sys", "gb", "es", "obs", "fs", "bi", "ts", "aos", "ls", "ms", "eb", "us", "b", "bis", "bus", "bn"]}}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup_internal(TestOutputVisitorData *data,\n\n                                          bool human)\n\n{\n\n    data->human = human;\n\n    data->sov = string_output_visitor_new(human);\n\n    g_assert(data->sov);\n\n    data->ov = string_output_get_visitor(data->sov);\n\n    g_assert(data->ov);\n\n}\n", "idx": 17596, "substitutes": {"data": ["rew", "size", "format", "definition", "valid", "details", "dal", "report", "good", "ae", "step", "ad", "pro", "DATA", "di", "cache", "exec", "display", "check", "defined", "form", "desc", "list", "input", "where", "set", "made", "output", "dat", "ata", "initial", "unknown", "content", "d", "mu", "da", "add", "call", "up", "dev", "root", "some", "date", "o", "complete", "entry", "al", "old", "num", "query", "name", "partial", "auth", "draw", "def", "str", "state", "info", "text", "missing", "debug", "work", "window", "ready", "client", "final", "map", "done", "out", "db", "control", "Data", "area", "id", "rel", "batch", "table"], "human": ["hidden", "person", "history", "nice", "check", "stable", "money", "echo", "soft", "ghost", "valid", "sudo", "input", "only", "user", "hard", "readable", "always", "display", "natural", "public", "sufficient", "fast", "normal", "model", "shown", "dirty", "native", " Human", "pure", "initial", "weak", "virtual", "unknown", "serial", "Human", "mouse", "pretty", "you", "physical", "hun", "local", "host", "high", "raw", "hello", "humans", "visible", "transform", "friendly", "low", "null", "wind", "machine", "demon", "broad", "localhost", "full", "graph", "health", "show", "own", "relative"]}}
{"project": "FFmpeg", "commit_id": "570a4a0189946c2c983da41d37fdd67fa13266e7", "target": 0, "func": "static int get_riff(AVFormatContext *s, AVIOContext *pb)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    char header[8];\n\n    int i;\n\n\n\n    /* check RIFF header */\n\n    avio_read(pb, header, 4);\n\n    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */\n\n    avi->riff_end += avio_tell(pb); /* RIFF chunk end */\n\n    avio_read(pb, header+4, 4);\n\n\n\n    for(i=0; avi_headers[i][0]; i++)\n\n        if(!memcmp(header, avi_headers[i], 8))\n\n            break;\n\n    if(!avi_headers[i][0])\n\n        return -1;\n\n\n\n    if(header[7] == 0x19)\n\n        av_log(s, AV_LOG_INFO, \"This file has been generated by a totally broken muxer.\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 17597, "substitutes": {"s": ["a", "ds", "cs", "os", "scl", "t", "w", "sg", "p", "as", "sp", "ses", "ins", "sq", "aws", "ctx", "is", "bs", "g", "sv", "rs", "gs", "sa", "S", "ss", "aus", "conv", "ns", "v", "sts", "ps", "sys", "js", "c", "es", "ats", "n", "fs", "ts", "ls", "ex", "sc", "b", "conf", "m"], "pb": ["td", "lp", "cv", "np", "tc", "dp", "wp", "px", "phy", "p", "pp", "sb", "bb", "proc", "client", "amp", "bp", "ctx", "ub", "pc", "fb", "bs", "buf", "vp", "pan", "tp", "bc", "pg", "pro", "bj", "apy", "db", "wb", "vm", "ps", "mp", "PB", "pkg", "pt", "func", "jp", "tk", "gp", "cb", "pl", "pa", "tg", "uf", "cp", "b", "phys", "lb"], "avi": ["vi", "au", "ij", "am", "ta", "wire", "ani", "eni", "opus", "iga", "ja", "ano", "av", "eas", "cam", "audio", "vp", "audi", "ai", "ave", "jac", "pan", "ahi", "apy", "v", "gra", "AV", " av", "cli", "aaa", "avan", "oi", "mi", "pi", "iii", "ti", "oti", "adi", "wi", "apa", "ami", "bi", "eric", "nav", "iac", "liv", "pai", "bis", "ap"], "header": ["lp", "error", "size", "format", "pr", "dt", "hash", "shift", "span", "length", "line", "Header", "headers", "er", "metadata", "topic", "section", "heading", "buffer", "title", "lr", "offset", "frame", "index", "channel", "fn", "server", "pp", "list", "timeout", "port", "command", "scroll", "summary", "len", "ver", "part", "version", "event", "cover", "comment", "num", "query", "layer", "column", "buf", "tr", "head", "time", "body", "info", "txt", "block", "row", "text", "border", "sample", "window", "p", "h", "padding", "position", "dr", "data", "tag", "message", "table", "top", "key", "HEAD", "vv", "filter", "prot", "type"], "i": ["tim", "ic", "index", "ij", "l", "si", "t", "ci", "im", "p", "ei", "ki", " ti", "me", "ski", "li", "is", "\u0438", "span", "ri", "g", "I", " ii", "ai", "phi", " multi", " index", "iq", "v", "di", " p", "io", " mi", "ip", " li", "mi", "pi", "oi", "ind", " j", "to", "j", "xi", "id", "in", "ti", "batch", "ui", "gi", "n", " I", "multi", "uri", "bi", "x", "ims", "asi", " ni", " m", " v", "ini", "zi", " bi", "sim", "it", "ix", "ex", "iu", "y", "ii", "m"]}}
{"project": "qemu", "commit_id": "b2caa3b82edca29ccb5e7d6311ffcf841b9b7786", "target": 1, "func": "_eth_get_rss_ex_src_addr(const struct iovec *pkt, int pkt_frags,\n\n                        size_t dsthdr_offset,\n\n                        struct ip6_ext_hdr *ext_hdr,\n\n                        struct in6_address *src_addr)\n\n{\n\n    size_t bytes_left = (ext_hdr->ip6r_len + 1) * 8 - sizeof(*ext_hdr);\n\n    struct ip6_option_hdr opthdr;\n\n    size_t opt_offset = dsthdr_offset + sizeof(*ext_hdr);\n\n\n\n    while (bytes_left > sizeof(opthdr)) {\n\n        size_t input_size = iov_size(pkt, pkt_frags);\n\n        size_t bytes_read, optlen;\n\n\n\n        if (input_size < opt_offset) {\n\n            return false;\n\n        }\n\n\n\n        bytes_read = iov_to_buf(pkt, pkt_frags, opt_offset,\n\n                                &opthdr, sizeof(opthdr));\n\n\n\n        if (bytes_read != sizeof(opthdr)) {\n\n            return false;\n\n        }\n\n\n\n        optlen = (opthdr.type == IP6_OPT_PAD1) ? 1\n\n                                               : (opthdr.len + sizeof(opthdr));\n\n\n\n        if (optlen > bytes_left) {\n\n            return false;\n\n        }\n\n\n\n        if (opthdr.type == IP6_OPT_HOME) {\n\n            size_t input_size = iov_size(pkt, pkt_frags);\n\n\n\n            if (input_size < opt_offset + sizeof(opthdr)) {\n\n                return false;\n\n            }\n\n\n\n            bytes_read = iov_to_buf(pkt, pkt_frags,\n\n                                    opt_offset + sizeof(opthdr),\n\n                                    src_addr, sizeof(*src_addr));\n\n\n\n            return bytes_read == sizeof(src_addr);\n\n        }\n\n\n\n        opt_offset += optlen;\n\n        bytes_left -= optlen;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 17611, "substitutes": {"pkt": ["pingacket", "pvc", "spkt", "compunct", "compkg", "pix", "pingkt", "hkt", "het", " pvc", "compkt", "packkt", "spacket", "cpet", "packet", " pix", "mkt", " pet", "cpkt", "compet", "ipkg", "cpix", "pett", "packett", "pet", "cpacket", "pingunct", "pkg", "mett", "spet", "met", " packet", "ipkt", " pkg", "macket", "hacket", "mkg", "packacket", " punct", "spix", "pingkg", "hett", "ipvc", "pingvc", "pinget", "punct", "compacket", "ipacket"], "pkt_frags": ["pkt_Frags", "pkt_brgs", "pkt_flag", "pkt_flages", "pkt_flats", "pkt_dragg", "pkt_tragged", "pkt_Fragged", "pkt_flags", "pkt_Frager", "pkt_trages", "pkt_frands", "pkt_plages", "pkt_plagged", "pkt_fragged", "pkt_bragged", "pkt_plags", "pkt_brands", "pkt_frats", "pkt_flands", "pkt_fratts", "pkt_frag", "pkt_Frages", "pkt_drats", "pkt_drands", "pkt_flatts", "pkt_finatts", "pkt_drag", "pkt_finag", "pkt_trag", "pkt_brats", "pkt_flagged", "pkt_fragg", "pkt_plager", "pkt_drages", "pkt_bragg", "pkt_fings", "pkt_frgs", "pkt_brags", "pkt_trats", "pkt_frages", "pkt_flagg", "pkt_trgs", "pkt_frager", "pkt_drags", "pkt_finags", "pkt_flager", "pkt_finagged", "pkt_finagg", "pkt_tragg", "pkt_bratts", "pkt_brag", "pkt_trags"], "dsthdr_offset": ["dsthdr_off", "dsthdr_position", "dsthdr_Offset", "dsthld_off", "dsthdr_len", "dsthld_Offset", "dsthld_position", "dsthld_offset", "dsthdr_size"], "ext_hdr": ["ext2haddr", "ext2thdr", "ext2hld", "ext_phDR", "ext_thld", "ext2thDR", "ext_thr", "ext_thdef", "ext_hdef", "ext_shdr", "ext2hdr", "ext_hr", "ext_phaddr", "ext_thaddr", "ext_thdr", "ext_whdr", "ext_phr", "ext_thDR", "ext2hr", "ext_haddr", "ext2shdr", "ext2shaddr", "ext2shDR", "ext2hDR", "ext2thld", "ext2thaddr", "ext_hDR", "ext_phdr", "ext_whdef", "ext2shr", "ext_shDR", "ext_whr", "ext_phld", "ext_shr", "ext_hld", "ext_whDR", "ext_shaddr"], "opthdr": ["opghr", "optrdr", "pthheader", "OPphr", "opphrr", " opthld", "optherdr", "okthDR", "opstrr", "optherder", "opkhrid", "opphr", "opstr", "opkhdr", "opghdr", "opbyterdr", "hopthrid", "opthop", "opTHg", "copothrer", "hopthsdr", "opthrid", " opTHld", "opothdr", " optholder", "hopthdr", "optherg", "optrrid", "opThdr", "opkhheader", "pTHr", "topthdr", "topTHg", "opTHder", "optrr", "hopthsrr", "pthr", "copthld", "opphrid", " opphr", "opkhook", "optholder", "opthsrr", "hopthsr", "opthook", "opphop", "opthr", "optrld", "opTHDR", "optherDR", "copthrer", "opTHr", "opthld", "opphres", "pthook", "OPthrr", "hopthr", "OPthop", "opthres", "opkhr", "opithrid", "opTHolder", "pTHres", "coptherr", "opothld", "topTHDR", "opthheader", "opThrid", " opphdr", "OPthr", "optherr", "hopthsrid", "opTHook", "pthdr", "hopthrr", "okthdr", "okthook", "pTHdr", "opTHrer", "okTHook", "opethDR", "opbyterrer", "opTHheader", "pTHook", "opphdr", "optwheader", " oppholder", "opithop", "opothrer", "opthsr", "opbyterld", " opTHr", "opthder", "opThr", "optwres", " optrrid", "topTHdr", "opTHres", "copothdr", "optwr", "OPthrid", "opThrr", "okTHdr", "pthres", " optrdr", "oppholder", "opethdr", " opthrid", "OPphop", "opethrid", "opthDR", " opTHdr", "opphld", "topTHder", "opghrr", "optwook", "opthrer", "opthsook", " optrDR", "optwdr", "opthrr", "opbytererr", "OPthdr", "opthsdr", "topthder", "opthsrid", " opthr", "opthg", "opTHrid", "opithdr", "OPphrr", "OPphdr", "opthsDR", "opotherr", "okTHDR", "opTHdr", "opkhop", "copotherr", "opstdr", "pTHheader", "opothDR", "opkholder", "topthg", "opTHerr", "copothld", "opithr", "opTHld", "topthDR", " opthDR", "opothder", "optrook", "OPphrid", "optrDR", "copthdr", "opothg"], "bytes_read": ["services_reader", "bytes42Read", "services_read", "services42received", "bytes42read", "bytes_readable", "services42read", "bytes___read", "tes_used", "bytes2received", "tes_reader", "services_Read", "tes_left", "tes_received", "bytes5read", "bytes2READ", "bytes_find", "bytes42reader", "bytes_READ", "bytes2read", "tes_write", "services42Read", "bytes64left", "bytes___find", "services42reader", "bytes_reader", "bytes64read", "tes_Read", "bytes5READ", "bytes2used", "bytes_used", "tes_find", "bytes___readable", "bytes_received", "bytes64Read", "bytes64used", "bytes_write", "tes_readable", "bytes2left", "tes_read", "services_received", "bytes_left", "bytes42received", "bytes5received", "bytes2Read", "bytes_Read", "tes_READ"], "optlen": ["optfun", "potl", "optLen", "opteden", " optLen", "oopno", "optedlon", "opten", "potfun", "optl", "optgz", "opfun", "optimLen", "optedln", "opteddel", "opno", "altln", "oopgz", "altLen", "optedcoll", "optcoll", "optimlen", "optln", " optfun", "opl", "ooplen", "optimdel", " optcoll", "potLen", " optln", "optedlen", "opgz", "potlen", "optimgz", "optedLen", "altl", "optdel", "optno", " optl", "oplen", "optimno", " optdel", "optlon", "oopLen", "opln", "oplon", "optimen", " opten", "altlen", "altlon", "optimcoll", "opLen"]}}
{"project": "FFmpeg", "commit_id": "582552fb56ba6559cb1d094a7e7ae5dde3073c5c", "target": 0, "func": "static int altivec_uyvy_rgb32 (SwsContext *c,\n\n\t\t\t       unsigned char **in, int *instrides,\n\n\t\t\t       int srcSliceY,\tint srcSliceH,\n\n\t\t\t       unsigned char **oplanes, int *outstrides)\n\n{\n\n  int w = c->srcW;\n\n  int h = srcSliceH;\n\n  int i,j;\n\n  vector unsigned char uyvy;\n\n  vector signed   short Y,U,V;\n\n  vector signed   short vx,ux,uvx;\n\n  vector signed   short R0,G0,B0,R1,G1,B1;\n\n  vector unsigned char  R,G,B;\n\n  vector unsigned char *out;\n\n  ubyte *img;\n\n\n\n  img = in[0];\n\n  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);\n\n\n\n  for (i=0;i<h;i++) {\n\n    for (j=0;j<w/16;j++) {\n\n      uyvy = vec_ld (0, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);\n\n\n\n      uyvy = vec_ld (16, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);\n\n\n\n      R  = vec_packclp (R0,R1);\n\n      G  = vec_packclp (G0,G1);\n\n      B  = vec_packclp (B0,B1);\n\n\n\n      //      vec_mstbgr24 (R,G,B, out);\n\n      out_rgba (R,G,B,out);\n\n\n\n      img += 32;\n\n    }\n\n  }\n\n  return srcSliceH;\n\n}\n", "idx": 17615, "substitutes": {"c": ["a", "con", "cv", "cs", "ic", "l", "tc", "ca", "t", "w", "ci", "p", "h", "ctx", "e", "conf", "g", "cam", "u", "cc", "ct", "ch", "co", "v", "cont", "r", "lc", "coll", "dc", "C", "fc", "ce", "cache", "s", "rc", "cp", "f", "ac", "b", "y", "m"], "in": ["con", "IN", "In", "ic", "l", "inf", "t", "im", "p", "mm", "as", "ins", "input", "at", "imp", "is", "data", "up", "inner", "r", "raw", "n", "din", "info", "bin", "gin", "s", "inn", "f", "ac", "arp", "src", "it", "ex", "inc", "conf", "serv", "err", "m"], "instrides": ["inctride", "inctrades", "inctrides", "instruments", "outStrides", "instsuments", "outStride", "instsides", "outstruments", "inStride", "outStruments", "inStrides", "instsades", "inStrades", "outstride", "inctruments", "outStrades", "outstrades", "instrades", "inStruments", "instside", "instride"], "srcSliceY": ["srcsliceY", "srcSlaceX", "srcSlideX", "srcSlsliceHeight", "srcSlaceZ", "srcSlsliceH", "srcPlICEZ", "srcSlideH", "srcPliceY", "srcslsliceY", "srcSlideHeight", "srcSliceHeight", "srcSlICEHeight", "srcSlaceH", "srcSlsliceX", "srcsliceX", "srcPliceZ", "srcSliceX", "srcPliceH", "srcPlICEH", "srcslsliceH", "srcslsliceHeight", "srcSlICEZ", "srcSliceZ", "srcsliceHeight", "srcslsliceX", "srcSlsliceY", "srcsliceH", "srcPlICEY", "srcSlaceY", "srcSlICEY", "srcSlICEH", "srcSlideY", "srcSlideZ", "srcPliceX", "srcSlICEX", "srcPlICEX"], "srcSliceH": ["srcSlideW", "srcSlideH", "srcPliceY", "srcSliceHT", "srcPliceW", "srcSlipY", "srcPlipY", "srcPlipHT", "srcPlipH", "srcPliceH", "srcSlideHT", "srcSlideY", "srcSlipW", "srcSlICEY", "srcSlICEHT", "srcSlipHT", "srcSlICEH", "srcPlipW", "srcSlICEW", "srcPliceHT", "srcSlipH", "srcSliceW"], "oplanes": [" overledes", "oplanguages", "oplasms", "oplane", "iplane", "oclanguages", "oclanes", " overlasms", "ixeledes", "opledes", "ixelushes", "planes", " overlushes", "plane", "iplanes", "opanes", "oplushes", "oplubes", " overlanes", "opasms", "oclubes", "oclane", "iplanguages", "planguages", "ixelasms", "iplubes", "opushes", "opedes", "ixelanes", "plubes"], "outstrides": [" outstride", "outStrends", "outslends", "outctride", "outstrids", "outspride", "instriders", "outStrride", " outslide", " outslides", "outctrends", "outStrids", "outstriiders", "outStrides", "outStride", "outStriders", "outslide", "outctrids", " outstrends", "inStride", "outstrride", "inStrides", " outslids", "outstride", "outstriide", "outstriders", "outslids", "outslides", "outstrends", "outspides", "instrride", "outspide", "outctrides", "outstriides", " outstrids", "inStriders", "outspiders", " outslends", "inStrride", "instride", "outstriride"], "i": ["a", "init", "ic", "index", "ij", "jj", "l", "z", "si", "w", "ci", "im", "p", "ki", "me", "h", "li", "is", "I", " ii", "ai", "phi", "v", "di", "k", "ip", "mi", "pi", "ind", "xi", "id", "r", "ti", "ui", "n", "o", "ji", "bi", "iu", "x", "by", "zi", "sim", "ini", "ie", "it", "ia", "ix", "ex", "b", "y", "ii", "m"], "j": ["jj", "ij", "z", "l", "el", "p", "dj", "adj", "kj", "q", "h", "at", "ja", "jo", "bs", "ion", "g", "uj", "fr", "u", "J", "jit", "bj", "v", "k", "obj", "jl", "js", "json", "try", "oj", "r", "jp", "o", "n", "ji", "aj", "key", "x", "jump", "ie", "it", "ix", "jc", "b", "y", "br", "m"], "uyvy": ["uuty", "oywy", "kyvy", "uyjoy", "inkyvy", "yuvin", "ailyvy", "kybil", "yuvc", "yuvoy", "uymire", "ujbil", "yuachy", "ujvy", "yucam", "yuwy", "uyuffy", "uuxy", "kyvre", "yuxy", "oyvt", "yuuffy", "kymy", "yujoy", "inkywy", "kywx", "ujmire", "oyvc", "uywx", "kywy", "uyvc", "uyvt", "uycam", "oyjoy", "ailymy", "yumire", "oyvy", "kyvoy", "kyxy", "yuty", "icyvre", "uyvre", "ailywy", "uyachy", "uuvy", " toyvy", "uymy", "ujwy", "icywy", "uyty", "oywx", "yuvt", "etchupvc", "uyvin", "yuvy", "kyuffy", "icyvy", " toycam", "uybil", "kyjoy", "icymire", "uuwy", "etchupwy", "uuvre", "icyvoy", " toyvt", "uyxy", " toywy", "uyvoy", "ujvre", "kyvin", "oycam", "uuuffy", "uywy", "etchupvy", "inkyjoy", "yubil", "yumy", "ailyvin", "etchupjoy", "yuvre", "ujachy", "inkywx", "icyachy", "kyty"], "Y": ["AM", "FY", "Year", "My", "Py", " y", "EY", "HT", "Gy", "I", "J", "S", "BY", "SY", "Ty", "TY", "H", "X", "TH", "XY", "ANY", "M", "Q", "L", "W", "C", "YC", "N", "A", "RY", "YY", "Z", "GY", "MY", "E", "P", "O", "y", "T"], "U": ["UV", "Us", "Tu", "UI", "URI", "UID", "Up", "MU", " u", "GU", "I", "UP", "u", "S", "UT", "Users", "CU", "H", "X", "UR", "UU", "AU", "UE", "M", "UD", "UC", "You", "User", "Ut", "L", "OU", "C", "W", "EU", "PU", "LU", "UL", "A", "Thu", "Lu", "Unit", "UF", "SU", "P", "Mu", "UX", "T", "US"], "V": ["UV", "VOL", "UI", "Vector", "VW", "VAL", "Va", "TV", "I", "J", "VA", "S", "BY", "VI", "Ver", "v", "VG", "H", "X", "VO", "Ve", "M", "USB", "Q", "L", "NV", "W", "C", "It", "VC", "VM", "VS", "A", "IV", "Z", "GV", "E", "P", "F", "T"], "vx": ["nvy", "vX", "uvX", "vxx", "nvx", "cvxx", "cvy", "vy", "uvxx", "nvxx", "cvX", "cvx", "uvy", "nvX"], "ux": ["au", "ue", "linux", "uu", "tx", "rx", "lu", "vp", "u", "XX", "ox", "conv", "etc", "uv", "select", "wx", "uc", "foo", "lux", "ui", "xx", "def", "aux", "lang", "uf", "rc", "us", "ix", "UX"], "uvx": ["uvw", "ufxy", "cvx", "cvw", "uuX", "uvX", "ufX", "uuxy", "uuw", "uvxy", "ufx", "ufw", "uux", "cvX", "cvxy"], "R0": ["BZero", "GZero", "RAZero", "G2", "RA1", "B2", "R2", "Ros", "RId", "BId", "RA02", "RT0", "RT1", "RAId", "Gos", "GId", " Ros", " R02", "RA2", " R2", "R02", "RA0", "G02", "RTos", "RZero"], "G0": ["G5", " G5", " Gold", "Group0", "G06", "Greg048", "Group06", "GID", "Greg1", "Greg06", "GGold", "g0", "B5", "RID", "Bold", "Gold", "Greg0", "Group048", "g1", "G048", "BID", " G048", "GG5", "GG1", " G06", "Group1", "GG0", "gID"], "B0": ["BT0", " Borg", "BR0", "Gzero", "Bzero", "V1", "Y0", "G2", "BRzero", "B2", "BT2", "V0", "Gorg", "Y1", "BT1", "Yzero", " B2", "Borg", "BR1", "BTorg"], "R1": ["L3", "L1", "V1", "RR0", "RA3", "LPU", "RAONE", "RMap", "RA1", "VONE", "GONE", "VMap", " R3", "RONE", "V0", "RR1", "R3", "RPU", "ROne", "RAPU", "L0", " RPU", "BOne", "RROne", "RA0", "RAMap", "GMap", "GOne"], "G1": [" GPU", " Gone", "Group0", "GAP", " GAP", "V1", "G2", "V001", "Gone", "Gr0", "GONE", "R2", " G001", "VPU", " G2", "Gr001", "GrONE", "GPU", "V0", "Grone", "V2", "Groupone", "Gr1", "RPU", "VAP", "GroupONE", "GrAP", "Group1", "G001", " GONE"], "B1": ["C0", "V1", "G2", "G4", " BOne", "B2", "T0", "G01", "C2", "V01", "COne", "C1", "V0", "B4", "V2", " B01", " B2", "B01", "BOne", "T1", " B4", "T4", "T2", "GOne"], "R": ["GR", "RR", "DR", "AR", "RO", "RGB", "I", "S", " r", "H", "X", "M", "ER", "BR", "Q", "r", "L", "W", "C", "D", "RA", "N", "RT", "A", "RG", "E", "RL", "P"], "G": ["GR", "Graph", "Ge", "BG", "GU", "g", "GA", "GRE", "GG", "J", "Gr", "GB", "Graphics", "H", "GP", "Group", "GS", "M", "PG", "L", "Gu", "LG", "C", "GT", "GI", "D", "W", "GV", "RG", "GROUP", "Go", "P"], "B": ["BG", "BA", "BT", "BW", "NB", "I", "J", "BY", "GB", "Bi", "LB", "BD", "H", "BM", "BC", "Bar", "M", "BR", "O", "L", "W", "C", "D", "N", "BL", "BO", "BI", "GO", "A", "BB", "AB", "DB", "P", "b", "WB", "T"], "out": ["a", "OUT", "res", "outs", "t", "w", "p", "array", "result", "at", "output", "buf", "g", "Out", "tmp", "u", "ot", "ch", "v", "io", "bit", "data", "cmd", "to", "ref", "r", "str", "o", "n", "bin", "buffer", "it", "b", "err"], "img": ["pixel", "png", "ij", "np", "arr", "im", "p", "aug", "emb", "th", "h", "og", "gif", "pic", "imp", "html", "fb", "ob", "buf", "g", "fr", "anim", "ht", "tmp", "bg", "jpg", "ch", "image", "uv", "attr", "obj", "bl", "mp", "gb", "up", "ref", "jp", "um", "raw", "str", "orig", "rb", "imag", "images", "uf", "gm", "f", "Image", "src", "url", "it", "br", "err", "m"]}}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static void inc_refcounts(BlockDriverState *bs,\n\n                          BdrvCheckResult *res,\n\n                          uint16_t *refcount_table,\n\n                          int refcount_table_size,\n\n                          int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0)\n\n        return;\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17627, "substitutes": {"bs": ["hs", "ds", "cs", "lbs", "os", "bits", "bles", "sb", "BS", "bb", "als", "ubs", "bh", "bps", "rs", "gs", "ss", "bc", "ubis", "ns", "vs", "bos", "ps", "iss", "js", "cks", "fs", "ts", "aos", "ls", "asis", "b", "bis", "its"], "res": ["rek", "rez", "pr", "details", "ins", "proc", "result", "ress", "ret", "cons", "expr", "ber", "pres", "vals", "crit", "rs", "resolution", "reg", "Res", "resh", "response", "rem", "js", "reset", "req", "re", "rel", "pers", "r", "scope", "comm", "gr", "def", "cond", "rss", "RES", "pas", "usr", "ack", "ro", "resp", "rc", "rest", "wcs", "red", "err"], "refcount_table": ["refCount_table", "refcount_info", "refCount_Table", "refcountingtype", "refCount_tab", "refCount_info", "refcount_map", "refcountingmap", "refcountingtable", "refcount_Table", "refcount_tab", "refcount_type"], "refcount_table_size": ["refcount_table_SIZE", "refcount_TABLE2offset", "refcount_TABLE2number", "refcount_tab_size", "refcount_table_number", "refcount_TABLE_offset", "refcount_table2offset", "refcount_TABLE_size", "refcount_table2number", "refcount_tab_SIZE", "refcount_tab_number", "refcount_TABLE_SIZE", "refcount_TABLE_number", "refcount_table2size", "refcount_TABLE2size", "refcount_table2SIZE", "refcount_table_offset", "refcount_TABLE2SIZE"], "offset": ["init", "pos", "index", "Offset", "error", "location", "seed", "slice", "slot", "set", "end", "shift", "base", "point", "prefix", "padding", "length", "amount", "seek", "address", "off", "position", "pointer", "ptr", "peer", "addr", "first", "reset", "ref", "origin", "et", "oid", "o", "align", "key", "alias", "sector", "attribute", "block", "row", "tile", "fp", "trace", "type"], "size": ["zone", "style", "si", "window", "gravity", "total", "max", "timeout", "shift", "zero", "scale", "sum", "count", "sized", "south", "empty", "shape", "resolution", "padding", "length", "amount", "position", "name", "scroll", "bytes", "capacity", "fee", "sn", "range", "ize", "storage", "height", "number", "since", "Size", "state", "SIZE", "len", "small", "dimension", "type"], "s": ["a", "ies", "hs", "ds", "cs", "sam", "os", "settings", "sb", "p", "sp", "ses", "ins", "als", "sq", "ges", "aws", "h", "abilities", "qs", "g", "south", "sv", "rs", "gs", "S", "ss", "sw", "ns", "sts", "ps", "http", "sn", "js", "c", "xs", "ats", "comm", "eps", "fs", "less", "ts", "ims", "ls", "parts", "stats", "sl", "b", "bis", "its"], "start": ["init", "next", "pos", "check", "index", "use", "ist", "max", "p", "ish", "before", "sp", "st", "store", "end", "set", "Start", "base", "shift", "starting", "step", "started", "stop", "seek", "iter", "head", "get", "first", "range", "arts", "origin", "art", "rank", "top", "pre", "info", " Start", "from", "wind", "it", "import", "part", "begin"], "last": ["next", "highest", "stable", "l", "las", "prev", "total", "max", "close", "final", "st", "end", "largest", "base", "most", "based", "length", "stop", "bottom", "ast", "first", "latest", "scope", "table", "est", "n", "worst", "Last", "since", "tail", "reverse", "nd", "vol", "rest", "best", "full", "show", "after"], "cluster_offset": ["cluster__offset", "cluster_Offset", "clust_offset", "clluster_tile", "clust_pointer", "clicaxslice", "cluster32offset", "cluster_tile", "clusters_offset", "cluster64address", "cluster__position", "cluster32point", "clust_address", "clica_point", "cluster_name", "clust_slice", "clust_point", "cluster_off", "cluster64Offset", "clica_off", "cluster64offset", "clluster_point", "cluster____slice", "clicaxoffset", "clicaxoff", "cluster32off", "clusterxpoint", "clusters_pointer", "clust_position", "clusters_Offset", "cluster_index", "cluster__metadata", "cluster_point", "cluster_slice", "clust_metadata", "cluster_id", "clicaxpoint", "clica_offset", "clluster_offset", "clust_name", "cluster_metadata", "clusterxoff", "clluster_index", "clica_slice", "cluster64pointer", "cluster_address", "cluster_pointer", "clusterxslice", "cluster____offset", "cluster____name", "cluster_position", "cluster____position", "clust_id", "clust_Offset", "cluster32slice", "clusterxoffset"], "k": ["km", "jj", "z", "sk", "ck", "kh", "i", "p", "uk", "kn", "kj", "q", "ks", "ik", "kr", "ke", "g", "u", "ku", "ka", "kan", "m", "kw", "d", "ak", "kid", "kind", "kk", "j", "ikk", "mk", "kl", "ko", "isk", "n", "key", "acc", "ack", "unk", "K", "ac", "wk", "ek"], "check_errors": ["checkingerrors", "checkingresults", "read_results", "check_results", "check_error", "read_error", "checkingerror", "read_errors"], "corruptions": ["corartions", "interreges", "corregibles", "corartes", "interregibles", "interruptations", "corartations", "corritibles", "corrites", "corruptibles", "interregions", "corruptes", "corregions", "correges", "corritations", "interruptes", "corritions", "interruptions", "corartibles", "interregations", "corregations", "interruptibles", "corruptations"]}}
{"project": "qemu", "commit_id": "733f0b02c80c3a7106d8327a83948ab68db10ea7", "target": 0, "func": "void stw_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t v = tswap16(val);\n\n    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);\n\n}\n", "idx": 17641, "substitutes": {"addr": ["mem", "eth", "offset", "pos", "work", "a", "arr", "ag", "t", "pad", "store", "asm", "h", "at", "ctx", "adr", "tr", "handle", "ad", "address", "d", "hw", "ptr", "obj", "attr", "add", "ay", "dr", "cmd", "pkg", "id", "ref", "r", "host", "ash", "dh", "ack", "x", "Address", "ix", "src", "gate", "err", "hl"], "val": ["bal", "mem", "Val", "rol", "sel", "t", "pr", "valid", "tx", "slot", "vt", "test", "VAL", "abl", "vals", "pol", "arg", "aval", "all", "v", "reg", "value", "fee", "bit", "data", "pal", "ref", "cal", "sol", "state", "bin", "vol", "al", "ac", "serv", "type"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_branch(DisasContext *ctx, int insn_bytes)\n\n{\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;\n\n        /* Branches completion */\n\n        ctx->hflags &= ~MIPS_HFLAG_BMASK;\n\n        ctx->bstate = BS_BRANCH;\n\n        save_cpu_state(ctx, 0);\n\n        /* FIXME: Need to clear can_do_io.  */\n\n        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {\n\n        case MIPS_HFLAG_FBNSLOT:\n\n            MIPS_DEBUG(\"forbidden slot\");\n\n            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);\n\n            break;\n\n        case MIPS_HFLAG_B:\n\n            /* unconditional branch */\n\n            MIPS_DEBUG(\"unconditional branch\");\n\n            if (proc_hflags & MIPS_HFLAG_BX) {\n\n                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);\n\n            }\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BL:\n\n            /* blikely taken case */\n\n            MIPS_DEBUG(\"blikely branch taken\");\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                int l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 17653, "substitutes": {"ctx": ["loc", "lex", "ck", "tx", "setup", "crit", "kw", "conv", "obj", "sys", "req", "c", "jp", "context", "cm", "aux", "tm", "xc", "abc", "exec", "mem", "check", "cv", "np", "scl", "desc", "timeout", "gz", "tmp", "command", "ct", "etc", "hw", "ksh", "xs", "pkg", "scope", "kl", "ctrl", "fc", "cu", "x", "qt", "resp", "wcs", "ctr", "sc", "ctl", "tc", "nt", "ca", "proc", "HK", "kt", "unc", "expr", "cl", "mom", "cf", "xp", "prefix", "jac", "ka", "cc", "alloc", "co", "warn", "document", "std", "cfg", "cmp", "act", "Context", "cp", "rc", "utils", "work", "history", " cx", "window", "gc", "cas", "config", "cpu", "wx", "wd", "that", "conn", "cmd", "ind", "func", "mk", "batch", "lc", "today", "cb", "nc", "conf"], "insn_bytes": ["insnYerrors", "insn_tags", "insn3steps", "insen_pieces", "insnpypieces", "insn__bytes", "inszn__errors", "insen_results", "inszn_tags", "insN_bytes", "insn_results", "insn3times", "insnYitems", "insnpyresults", "inszn__bytes", "inszn__tags", "insn__items", "insn8times", "insn8steps", "insn__tags", "insn8bytes", "insn_errors", "insnpybytes", "insN_times", "insnYbytes", "insn_pieces", "inszn_errors", "inszn_items", "insn_steps", "insen_bytes", "insnYtags", "insn3bytes", "insn_items", "insn__errors", "inszn__items", "inszn_bytes", "insn_times", "insN_steps"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n", "idx": 17664, "substitutes": {"slirp": ["slibrf", "swirpa", "sliropa", "selircg", "slirlg", "swirp", "SLierping", "selircp", "slirpi", "slirep", "slirepa", "glirlp", "slircpi", "sliroping", "swirpc", "selirpi", "swrirr", "slirg", "slrirr", "SLirP", "plpirpy", "slierp", "slirpa", "Slpirp", "slpirf", "glirg", "slierP", "plpirp", "SLierp", "slirepc", "slpirp", "slvirse", "Slirl", "Slpirse", "slrirpc", "slibrp", "slarpy", "SLierpa", "slierv", "slircp", "slibrg", "plpirl", "slarp", "slirf", "slirr", "plirpy", "sliraphp", "Slpirl", "slierping", "slirpc", "slircf", "SLirp", "slrirl", "slircg", "Slirf", "slirphp", "Slirp", "slirtg", "slirv", "slirP", "slirping", "SLirping", "swrirpa", "slierpa", "swrirp", "slpirpy", "Slirse", "glirv", "plirp", "slvirl", "selirp", "glirpa", "glirp", "glirlg", "slirlping", "glirlpa", "plirl", "slirop", "plpirphp", "slvirp", "slirlp", "slibrpi", "selircpi", "slpirr", "selirg", "slirl", "slarphp", "selircf", "slirtv", "slrirpi", "slpirpa", "selirf", "plirphp", "swirr", "slpirl", "slrirpa", "slirlP", "slirse", "swrirpc", "slpirphp", "slierg", "slarl", "slirlv", "slrirp", "slirtpa", "slirpy", "slpirpc", "sliral", "slirlpa", "sliroP", "SLirpa", "glirlv", "slvirf", "slpirse", "slrirg", "Slpirf", "slrirse", "slirtp", "slirap", "SLierP", "slirapy", "slirer", "slrirf"]}}
{"project": "qemu", "commit_id": "eda470e41a753070e057380a9a71e2ad7347f667", "target": 0, "func": "void scsi_req_abort(SCSIRequest *req, int status)\n\n{\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->ops->cancel_io) {\n\n        req->ops->cancel_io(req);\n\n    }\n\n    scsi_req_complete(req, status);\n\n    scsi_req_unref(req);\n\n}\n", "idx": 17670, "substitutes": {"req": ["pub", "tx", "ctx", "good", "fr", "crit", "requ", "rr", "tek", "pro", "obj", "esp", "inv", "comm", "jp", "bound", "aux", "exec", "pp", "desc", "required", "q", "compl", "cur", "ps", "call", "pkg", "forced", "usr", "low", "qt", "resp", "rest", "urg", "org", "ctr", "task", "init", "res", "proc", "query", "bp", "expr", "buf", "prefix", "subject", "iq", "js", "any", "gr", "cmp", "def", "quest", "rb", "request", "txt", "qq", "needed", "require", "history", "p", "dep", "md", "wx", "rem", "cmd", "ind", "ext", "rel", "ref", "job", "comp", "seq", "dq"], "status": ["check", "error", "size", "Status", "atus", "deg", "flag", "score", "details", "result", "set", "compl", "scale", "wait", "count", "prefix", "tr", "stat", "unknown", "ity", "sw", "progress", "success", "msg", "id", " Status", "sync", "current", "str", "uses", "state", "ssl", "resp", "code", "spec", "sc", "active", "type"]}}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_free_extradata (PayloadContext *rdt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_STREAMS; i++)\n\n        if (rdt->rmst[i]) {\n\n            ff_rm_free_rmstream(rdt->rmst[i]);\n\n            av_freep(&rdt->rmst[i]);\n\n        }\n\n    if (rdt->rmctx)\n\n        av_close_input_stream(rdt->rmctx);\n\n    av_freep(&rdt->mlti_data);\n\n    av_free(rdt);\n\n}\n", "idx": 17678, "substitutes": {"i": ["gl", "ski", "li", "e", "point", "I", " key", "ai", "di", "mi", "ji", " iter", "chain", "ex", "multi", "ii", "index", "ij", "ci", "list", "q", "\u0438", "phi", " multi", "v", "cli", "pi", "gi", "bi", "x", "zi", "ini", "it", " it", "iu", "init", "ic", "l", "qi", " ti", "me", " ii", "iq", " mi", "ip", " li", " j", "j", "ti", " ki", " Ti", " I", "uri", "info", " si", " di", "go", " bi", "ix", "y", "m", "si", "im", " my", "p", "ki", " Li", " pi", "is", " wi", "ind", "id", "in", "xi", "ui", "key", "ims", " ni", " m", "sim", "ms"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    /*\n\n                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                        Rewrite to take IRQ from TPM device model and\n\n                        fix default IRQ value there to use some unused IRQ\n\n                     */\n\n                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 17682, "substitutes": {"entry": ["channel", "cell", "interface", "query", "ry", "cur", "link", "match", "inter", "se", "Entry", "range", "record", "member", "def", "table", "diff", "key", "alias", "ent", "info", "row", "machine", "scan", "import", "spec"], "dsdt": ["adsdat", "sdtd", "dosdk", "dDT", "dtp", "sdat", "adsdt", "dosdt", "ksdat", "jsdt", "sDT", "testd", "sddp", "esdp", "kstp", "ysdt", "myssth", "mysdt", "bsdt", "ksdt", "nsDT", "destp", "dsdm", "sddat", "sdt", "mysDT", "desdt", "esdm", "dtd", "dssth", "jsdat", "esdt", "desdat", "dstp", "myst", "cstd", "yst", "dsdp", "bsdat", "dsstab", "jsDT", "estd", "stsdp", "ksDT", "bstd", "dlstab", "mysdat", "sds", "insdl", "csdl", "dsdk", "teswt", "ysdat", "jsds", "esdat", "ststd", "sdstab", "mysdk", "csstab", "checksdm", "stsdt", "dswt", "insdat", "mysstab", "mystd", "tesdt", "dsdl", "checkswt", "dldk", "adsDT", "stsdat", "std", "dossth", "sdDT", "nstp", "sddl", "dlsth", "dldt", "desDT", "dst", "dsds", "csDT", "sddt", "csdt", "tesdm", "sdtp", "cstp", "dosstab", "dstd", "dsDT", "ystd", "nstd", "eswt", "bstp", "nsdt", "ddt", "dsdat", "csdp", "instd", "checkstd", "adsds", "checksdt", "csdat", "insdt", "sdp"], "sb_scope": ["bh___case", "sb___context", "sb___case", "sbptstore", "sb_window", "sg_Scope", "sg_device", "bg_map", "sbptcycle", "sbptspace", "sblydepth", "sb_case", "sf_depth", "sb_map", "bh___context", "bh_context", "sb___cycle", "sg_shape", "sb_close", "sg_store", "sg_scope", "sb_push", "sblyclose", "sf_push", "sb_sp", "sb___scope", "sg_cycle", "sb_shape", "sbptscope", "bg_sc", "sf_scope", "sblypush", "sb_depth", "sb_store", "sg_window", "bh___cycle", "bh_cycle", "bh_scope", "sg_space", "sb_sc", "sf_close", "sb_context", "sblyscope", "bg_scope", "bg_sp", "bh___scope", "sb_space", "sg_sc", "sb_device", "sb_cycle", "bh_case", "sb_Scope"], "scope": ["index", "style", "window", "var", "port", "device", "resource", "group", "serial", "kind", "trigger", "range", "id", "dir", "ev", "root", "project", "module", "env", "scan", "chain", "src", "spec", "sc", "mode"], "dev": ["mem", " device", "debug", "adv", "loc", "stable", "el", "nt", "window", "de", "pad", "var", "Dev", "app", "device", "stick", "util", "DEV", "buf", "development", "normal", "av", "usb", "link", "disk", "pu", "des", "ch", "db", "pro", "v", "serial", "attr", "reader", "ve", "wd", "addr", "iv", "conn", "sd", "range", "data", "priv", "cmd", "push", "den", "ev", "val", "def", "develop", "env", "cho", "block", "row", "gu", "go", "ver", "tech", "devices", "scan", "Device", "vol", "dem", "dd"], "method": ["Method", "depth", "proc", "mount", "action", "util", "mod", "property", "op", "prop", "m", "serial", "attr", "magic", "cmd", "access", "func", "package", "module", "METHOD", "function", "mid", "fun", "src", "spec", "mode", "class"], "field": ["pos", "fields", "comment", "var", "mount", "util", "prefix", "prop", "address", "label", "attr", "param", "msg", "ff", "id", "dir", "tag", "table", "key", "module", "Field", "f", "fun", "spec", "file", "col", "class"], "pkg": ["init", "pub", "lib", "ctx", "imp", "family", "util", "prefix", "db", "packages", "plugin", "kind", "sys", "addr", "msg", "priv", "cmd", "dir", "plug", "kg", "cmp", "pack", "package", "aux", "gp", "alias", "cp", "gen", "phys"], "crs": ["acrs", "acps", "cps", "vcs", "pcrs", "pccs", "pcds", "vps", "cds", "accs", "vrs", "pcps", "vds", "acds", "ccs"], "mem_ranges": ["mem_erists", "mem_eranges", "mem_arranges", "mem_erots", "mem_aranges", "mem_arays", "mem_rays", "mem_rots", "mem_erays", "mem_rists", "mem_arrists", "mem_arists", "mem_arrays", "mem_arrots", "mem_arots"], "io_ranges": ["io_brates", "io_Rows", "io_rganges", "io_brows", "io_rgows", "io_rgates", "io_rasks", "io_Ranges", "io_Rates", "io_rgasks", "io_rows", "io_rates", "io_branges", "io_brasks", "io_Rasks"], "pcms": ["icms", "ccMS", "ccmb", "icMS", "ccvs", "pcMS", "picMS", "picmb", "pcvs", "pcmb", "icmb", "ccms", "picvs", "picms", "icvs"], "bus": ["box", "board", "back", "proc", "port", "mount", "lock", "config", "usb", "bug", "bid", "bolt", "Bus", "BUS", "plug", "bank", "card", "cache", "block", "machine", "book", "chain", "us", "boot", "way", "task"], "i": ["a", "l", "si", "t", "ci", "p", "li", " pi", "e", "g", "I", "v", "di", "io", "k", "pi", "c", " j", "j", "bi", "x", " v", " bi", " b", "b", "y", "ii", "m"]}}
{"project": "qemu", "commit_id": "3d6f761713745dfed7d2ccfe98077d213a6a6eba", "target": 0, "func": "static void arm_cpu_do_interrupt_aarch64(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    unsigned int new_el = env->exception.target_el;\n\n    target_ulong addr = env->cp15.vbar_el[new_el];\n\n    unsigned int new_mode = aarch64_pstate_mode(new_el, true);\n\n\n\n    if (arm_current_el(env) < new_el) {\n\n        if (env->aarch64) {\n\n            addr += 0x400;\n\n        } else {\n\n            addr += 0x600;\n\n        }\n\n    } else if (pstate_read(env) & PSTATE_SP) {\n\n        addr += 0x200;\n\n    }\n\n\n\n    switch (cs->exception_index) {\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        env->cp15.far_el[new_el] = env->exception.vaddress;\n\n        qemu_log_mask(CPU_LOG_INT, \"...with FAR 0x%\" PRIx64 \"\\n\",\n\n                      env->cp15.far_el[new_el]);\n\n        /* fall through */\n\n    case EXCP_BKPT:\n\n    case EXCP_UDEF:\n\n    case EXCP_SWI:\n\n    case EXCP_HVC:\n\n    case EXCP_HYP_TRAP:\n\n    case EXCP_SMC:\n\n        env->cp15.esr_el[new_el] = env->exception.syndrome;\n\n        break;\n\n    case EXCP_IRQ:\n\n    case EXCP_VIRQ:\n\n        addr += 0x80;\n\n        break;\n\n    case EXCP_FIQ:\n\n    case EXCP_VFIQ:\n\n        addr += 0x100;\n\n        break;\n\n    case EXCP_SEMIHOST:\n\n        qemu_log_mask(CPU_LOG_INT,\n\n                      \"...handling as semihosting call 0x%\" PRIx64 \"\\n\",\n\n                      env->xregs[0]);\n\n        env->xregs[0] = do_arm_semihosting(env);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n    }\n\n\n\n    if (is_a64(env)) {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);\n\n        aarch64_save_sp(env, arm_current_el(env));\n\n        env->elr_el[new_el] = env->pc;\n\n    } else {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);\n\n        if (!env->thumb) {\n\n            env->cp15.esr_el[new_el] |= 1 << 25;\n\n        }\n\n        env->elr_el[new_el] = env->regs[15];\n\n\n\n        aarch64_sync_32_to_64(env);\n\n\n\n        env->condexec_bits = 0;\n\n    }\n\n    qemu_log_mask(CPU_LOG_INT, \"...with ELR 0x%\" PRIx64 \"\\n\",\n\n                  env->elr_el[new_el]);\n\n\n\n    pstate_write(env, PSTATE_DAIF | new_mode);\n\n    env->aarch64 = 1;\n\n    aarch64_restore_sp(env, new_el);\n\n\n\n    env->pc = addr;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\",\n\n                  new_el, env->pc, pstate_read(env));\n\n}\n", "idx": 17699, "substitutes": {"cs": ["hs", "cv", "ds", "acts", "tc", "ys", "ck", "csv", "cell", "ses", "ins", "ec", "cases", "otes", "ks", "ctx", "cons", "qs", "bs", "ares", "caps", "rs", "gs", "cc", "ces", "sts", "ns", "vs", "ps", "js", "c", "css", "rys", "cm", "cks", "fs", "acs", "ce", "er", "ts", "uns", "ls", "cus", "s", "cp", "rc", "CS", "icks", "wcs", "ms", "sc"], "cpu": ["mem", "cow", "np", "nic", "ck", "proc", "ork", "cn", "ec", "ctx", "pc", "rom", "core", "gc", "chip", "ola", "node", "pu", "ka", "stat", "alloc", "ox", "tp", "hw", "vm", "clock", "conn", "c", "mx", "cmd", "bench", "processor", "runner", "gpu", "cu", "arch", "nc", "net", "cp", "CPU", "ex", "process"], "env": ["enter", "ctx", "e", "eur", "eas", "vp", "email", "vs", "obj", "gear", "era", "iv", "ee", "manager", "esp", "inv", "den", "context", "eu", "er", "net", "ah", "eg", "serv", "environment", "cv", "here", "np", "el", "server", "desc", "var", "en", "eni", "end", "nv", "em", "v", "ew", "hw", "dev", "forge", "arm", "ent", "entry", "org", "sc", "event", "worker", "err", "ov", "console", "ei", "enc", "ner", "esm", "buf", "ect", "uv", "ef", "addr", "order", "ev", "docker", "def", "erd", "viron", "eve", "ie", "cp", "der", "vd", "dn", "next", "ten", "eng", "window", "stage", "ec", "erv", "equ", "config", "timer", "engine", "db", "esc", "vm", "ve", "outer", "conn", "cmd", "et", "dh", "nc", "eh", "oe"]}}
{"project": "qemu", "commit_id": "5fe79386ba3cdc86fd808dde301bfc5bb7e9bded", "target": 0, "func": "static bool pc_machine_get_nvdimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->nvdimm;\n\n}\n", "idx": 17700, "substitutes": {"obj": ["Object", "os", "nt", "t", "opt", "pr", "og", "xy", "ctx", "bh", "bo", "expr", "ob", "tmp", "onet", "ot", "attr", "cont", "object", "js", "typ", "any", "cmd", "pkg", "id", "att", "oj", "ref", "inst", "Obj", "obs", "o", "act", "cod", "txt", "resp", "org", "po", "elt", "objects"], "errp": [" errpp", "Erp", "errr", "errpp", "errP", "erP", " errr", "erpp", "erp", "Err", "Erpp", " errP", "ErP", "err"], "pcms": ["pacms", "cpmm", " lacmas", "pcmes", " lacmn", "pccms", "cpfs", "cpms", "czmes", " lacms", "pacmas", " laccms", " pcmes", " pcmm", "czms", "cpmes", "pcmn", "micmn", "czfs", "paccms", "pcmm", "pcmas", "czmm", " pcfs", "pcfs", "micms", "micmas", "miccms", "pacmn"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_header(GArray *linker, GArray *table_data,\n\n             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n\n             const char *oem_table_id)\n\n{\n\n    memcpy(&h->signature, sig, 4);\n\n    h->length = cpu_to_le32(len);\n\n    h->revision = rev;\n\n    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n\n\n\n    if (oem_table_id) {\n\n        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n\n    } else {\n\n        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n\n        memcpy(h->oem_table_id + 4, sig, 4);\n\n    }\n\n\n\n    h->oem_revision = cpu_to_le32(1);\n\n    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n\n    h->asl_compiler_revision = cpu_to_le32(1);\n\n    h->checksum = 0;\n\n    /* Checksum to be filled in by Guest linker */\n\n    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,\n\n                                    table_data->data, h, len, &h->checksum);\n\n}\n", "idx": 17710, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "3dfbdb328ed9e88cebc6462c56cfe61e55850b2e", "target": 0, "func": "static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n\n{\n\n    int v;\n\n    int i = 0;\n\n    uint8_t state[CONTEXT_SIZE];\n\n\n\n    memset(state, 128, sizeof(state));\n\n\n\n    for (v = 0; i < 128; v++) {\n\n        unsigned len = get_symbol(c, state, 0) + 1;\n\n\n\n        if (len > 128 - i)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        while (len--) {\n\n            quant_table[i] = scale * v;\n\n            i++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < 128; i++)\n\n        quant_table[256 - i] = -quant_table[i];\n\n    quant_table[128] = -quant_table[127];\n\n\n\n    return 2 * v - 1;\n\n}\n", "idx": 17723, "substitutes": {"c": ["con", "cs", "l", "tc", "t", "ci", "p", "ec", "h", "unc", "e", "g", "cf", "u", "cc", "ct", "ch", "d", "cont", "cr", "r", "lc", "dc", "C", "fc", "ce", "cu", "cb", "xc", "com", "rc", "f", "cp", "abc", "ac", "sc", "b", "m"], "quant_table": ["Quant_file", "quant2TABLE", "quant12translation", "quantationdatabase", "quant_translation", "quant_total", "privateityinterface", "privateitytable", "quant8cache", "quant10file", "quant2buffer", "quantitytotal", "quant12cache", "quant_filter", "draw_tree", "private_TABLE", "quant_file", "quantitytab", "quantationtable", "private_table", " quant_tab", " quant2cache", "quant_manager", "quant_buffer", "privateitytab", "quant10cache", "quant8table", "quantityinterface", " quant2buffer", "quant12table", "quant2cache", "quantitytable", "quant_interface", "quantationtree", "draw_database", "quantitybuffer", "private_tab", "draw8tree", " quant_manager", "quant8filter", "draw8interface", "Quant_translation", " quant_TABLE", "private_buffer", "quant8interface", "privateitybuffer", "private_database", "quantationbuffer", " quant_buffer", " quant2TABLE", "quant_tree", "quant8buffer", "quant8database", "quantitymanager", "private8database", "quant2table", "quantationtab", "quant10translation", "quant8TABLE", "quant_database", "quant12file", "quant10table", "draw_interface", "Quant_table", "private_interface", "quant_tab", "quantationinterface", " quant2table", "quant_TABLE", "draw_table", "Quant_cache", "quant_cache", "private_filter", "draw8table", "private8TABLE", " quant_cache", " quant_total", "quant8tree", "draw8database", "private8filter", "private8table"], "scale": ["check", "offset", "Scale", "error", "si", "seed", "size", "deg", "weight", "slice", "ALE", "score", "sup", "cale", "radius", "shift", "base", " Scale", "fail", "ale", "step", "force", "sign", "unit", "axis", "value", "fee", "order", "draw", "transform", "alias", "rate", "grade", "alpha", "code", "sc", "type"], "v": ["cv", "lv", "ov", "l", "b", "qv", "z", "t", "w", "im", "ach", "p", "var", "vt", " V", "q", "h", "at", "va", "nv", "av", "g", "vert", "sv", "u", "vc", "conv", "d", "uv", "vs", "k", "vm", "ve", "ip", "iv", "value", "tv", "pi", "j", "ev", "val", "um", "V", "o", "n", "vector", "x", "vv", "s", "f", "it", "iver", "version", "y", "ii", "m"], "state": ["next", "mem", "init", "index", "cs", "l", "memory", "seed", "size", "t", "ate", "State", "st", "list", "result", "store", "test", "q", "hash", "h", "STATE", "output", "count", "lock", "config", "length", "handle", "queue", "name", "out", "start", "pointer", "self", "se", "data", "range", "in", "id", "tag", "local", "new", "context", "n", "key", "cache", "info", "null", "block", "row", "al", "buffer", "scan", "code", "states", "type"], "len": ["mem", "lp", "lv", "fn", "l", "el", "z", "size", "t", "lon", "var", "gl", "lf", "en", "ll", "h", "li", "le", "vec", "dl", " l", "il", "length", "mn", "fin", "ln", "nn", "data", "nl", "den", "val", "L", "kl", "lc", "str", "coll", "n", "ell", "lan", "ls", "pl", "ld", "s", "al", "full", "Len", "sl", "elt", "seq", "fl"], "i": ["a", "ic", "index", "ij", "l", "si", "z", "ci", "im", "hi", "p", "ei", "ki", "qi", "me", "h", "q", "li", "is", "\u0438", "e", "I", " ii", "u", "ai", "phi", "di", "cli", "k", "iter", "ip", "PI", "mi", "pi", "oi", "in", " j", "id", "j", "xi", "ind", "ti", "ui", "gi", "o", "n", "ji", "fi", "uri", "multi", "bi", "iu", "x", "asi", "zi", "ini", "gu", "s", "f", "it", "ix", "b", "y", "ii", "m"]}}
{"project": "FFmpeg", "commit_id": "1eb57e1d9b59db0aa63348c21bf3290bd3f5efcb", "target": 0, "func": "static int tb_unreliable(AVCodecContext *c)\n\n{\n\n    if (c->time_base.den >= 101L * c->time_base.num ||\n\n        c->time_base.den <    5L * c->time_base.num ||\n\n        // c->codec_tag == AV_RL32(\"DIVX\") ||\n\n        // c->codec_tag == AV_RL32(\"XVID\") ||\n\n        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n        c->codec_id == AV_CODEC_ID_H264)\n\n        return 1;\n\n    return 0;\n\n}\n", "idx": 17735, "substitutes": {"c": ["a", "con", "cv", "cs", "ic", "tc", "t", "ci", "p", "desc", "mc", "ec", "enc", "ctx", "err", "pc", "gc", "e", "cl", "g", "cf", "vc", "cc", "bc", "ct", "content", "co", "ch", "v", "etc", "cont", "cr", "comm", "cmp", "lc", "cm", "dc", "C", "n", "fc", "ce", "cod", "cu", "cache", "nc", "anc", "com", "cp", "abc", "rc", "f", "ac", "sc", "b", "conf"]}}
{"project": "FFmpeg", "commit_id": "0232f788b6b0855db1771dbf8d7174e2eda2ff45", "target": 1, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n\n\n    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);\n\n    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);\n\n    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);\n\n    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->in_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->out_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;\n\n\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16 currently\\n\"); //FIXME\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\nav_assert0(s-> in.ch_count);\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);\n\n    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);\n\n    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n    s->in_buffer= s->in;\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count=\n\n        s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;\n\n    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;\n\n\n\n\n\n    if(s->rematrix)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 17737, "substitutes": {"s": ["z", "bits", "details", "rs", "vs", "se", "obj", "sys", "c", "es", "comm", "fs", "params", "serv", "spec", "os", "ops", "t", "settings", "events", "sm", "set", "qs", "S", "ss", "v", "sts", "ps", "styles", "erences", "n", "ts", "ls", "parts", "stats", "sc", "eds", "comments", "a", "services", "ies", "ds", "cs", "sam", "l", "w", "as", "sb", "ses", "changes", "als", "esm", "south", "sv", "sw", "js", "gets", "state", "source", "tests", "states", "b", "has", "y", "rates", "m", "hs", "simple", "args", "p", "ins", "ers", "aws", "h", "is", "bs", "gs", "ports", "ns", "sports", "in", "tes", "pers", "ats", "r", "eps", "less", "ims", "ms", "us", "conf", "its"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int svq1_decode_init(AVCodecContext *avctx)\n\n{\n\n    MpegEncContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    MPV_decode_defaults(s);\n\n\n\n    s->avctx = avctx;\n\n    s->width = (avctx->width+3)&~3;\n\n    s->height = (avctx->height+3)&~3;\n\n    s->codec_id= avctx->codec->id;\n\n    avctx->pix_fmt = PIX_FMT_YUV410P;\n\n    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames\n\n    s->flags= avctx->flags;\n\n    if (MPV_common_init(s) < 0) return -1;\n\n\n\n    init_vlc(&svq1_block_type, 2, 4,\n\n        &svq1_block_type_vlc[0][1], 2, 1,\n\n        &svq1_block_type_vlc[0][0], 2, 1);\n\n\n\n    init_vlc(&svq1_motion_component, 7, 33,\n\n        &mvtab[0][1], 2, 1,\n\n        &mvtab[0][0], 2, 1);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        init_vlc(&svq1_intra_multistage[i], 3, 8,\n\n            &svq1_intra_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_intra_multistage_vlc[i][0][0], 2, 1);\n\n        init_vlc(&svq1_inter_multistage[i], 3, 8,\n\n            &svq1_inter_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_inter_multistage_vlc[i][0][0], 2, 1);\n\n    }\n\n\n\n    init_vlc(&svq1_intra_mean, 8, 256,\n\n        &svq1_intra_mean_vlc[0][1], 4, 2,\n\n        &svq1_intra_mean_vlc[0][0], 4, 2);\n\n\n\n    init_vlc(&svq1_inter_mean, 9, 512,\n\n        &svq1_inter_mean_vlc[0][1], 4, 2,\n\n        &svq1_inter_mean_vlc[0][0], 4, 2);\n\n\n\n    return 0;\n\n}\n", "idx": 17742, "substitutes": {"avctx": ["AVctx", "avctl", "avercb", "navcb", " avcontext", "avegp", " avcmd", "averconfig", " avctl", "avekb", "avjac", " avconfig", "afctx", "avpkg", "avgp", "afconfig", "AVgp", "avcmd", " avjac", "navcv", "avecontext", "ajcmd", "avecmp", "averjac", "ajkb", "afreq", " avcam", "avertx", "AVcontext", "avepkg", "avercv", "avconfig", " avtx", "aversys", "avecp", " avreq", "AVcmd", "avcam", "vrpkg", "avcp", "avecb", "avcb", "avehandle", "averhandle", "avercontext", "ajconfig", "absys", "ajreq", "avcv", "avecv", "afctl", " avcfg", "avcontext", "avcfg", "avectl", "devctx", "avkb", "vrgp", "AVcmp", "ayjac", "ajjac", "ajcontext", "aveconfig", "avectx", "ajctl", "navhandle", " avcmp", "avercam", "afcontext", "ajcv", "avreq", "ajcam", "afcp", "averkb", "avsys", "abcmp", " avcp", "aycfg", "abtx", "afcmp", "avcmp", "ajctx", "ayctx", "avhandle", "devcmp", "devtx", "averctx", "abcontext", "aycmd", "AVtx", "vrctx", "ajcfg", "avecmd", "navctx", "avtx", "vrcmd", "abctx", "AVpkg", "devsys", "avercmp"], "s": ["ds", "cs", "uploads", "os", "l", "sg", "t", "p", "sb", "ses", "ins", "sq", "aws", "h", "set", "qs", "is", "bs", "g", "sv", "rs", "gs", "S", "ss", "aus", "d", "ports", "v", "ns", "sts", "sw", "ps", "sports", "js", "c", "es", "pers", "ats", "comm", "fs", "less", "ts", "x", "ims", "ls", "sac", "stats", "ms", "us", "ows", "sc", "b", "conf", "its", "m"], "i": ["hi", "li", "span", "ri", "e", "g", "I", "ai", "di", "mi", "c", "ji", "er", "asi", " iter", "gu", "ex", "multi", "ii", "tim", "index", "ij", "t", "ci", "\u0438", " e", "phi", " multi", "cli", "pi", "gi", "bi", "x", " x", "zi", "ini", "it", "iu", "status", "err", "ic", " pos", "qi", " ti", "me", " ii", " index", " mi", "ip", " j", "j", "ti", "print", " I", "ami", "info", " si", " di", " bi", "ix", "y", "m", "si", "p", "ki", "h", " pi", "is", " p", "oi", "ind", "in", "xi", "ui", " ni", " m", " v", "sim", "us"]}}
{"project": "FFmpeg", "commit_id": "bf87908cd8da31e8f8fe75c06577170928ea70a8", "target": 1, "func": "static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,\n\n                                     AVStream *st, RMStream *ast, int read_all)\n\n{\n\n    char buf[256];\n\n    uint32_t version;\n\n    int ret;\n\n\n\n    /* ra type header */\n\n    version = avio_rb16(pb); /* version */\n\n    if (version == 3) {\n\n        unsigned bytes_per_minute;\n\n        int header_size = avio_rb16(pb);\n\n        int64_t startpos = avio_tell(pb);\n\n        avio_skip(pb, 8);\n\n        bytes_per_minute = avio_rb16(pb);\n\n        avio_skip(pb, 4);\n\n        rm_read_metadata(s, 0);\n\n        if ((startpos + header_size) >= avio_tell(pb) + 2) {\n\n            // fourcc (should always be \"lpcJ\")\n\n            avio_r8(pb);\n\n            get_str8(pb, buf, sizeof(buf));\n\n        }\n\n        // Skip extra header crap (this should never happen)\n\n        if ((startpos + header_size) > avio_tell(pb))\n\n            avio_skip(pb, header_size + startpos - avio_tell(pb));\n\n        if (bytes_per_minute)\n\n            st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        st->codec->sample_rate = 8000;\n\n        st->codec->channels = 1;\n\n        st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = AV_CODEC_ID_RA_144;\n\n        ast->deint_id = DEINT_ID_INT0;\n\n    } else {\n\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n\n        int codecdata_length;\n\n        unsigned bytes_per_minute;\n\n        /* old version (4) */\n\n        avio_skip(pb, 2); /* unused */\n\n        avio_rb32(pb); /* .ra4 */\n\n        avio_rb32(pb); /* data size */\n\n        avio_rb16(pb); /* version2 */\n\n        avio_rb32(pb); /* header size */\n\n        flavor= avio_rb16(pb); /* add codec info / flavor */\n\n        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */\n\n        avio_rb32(pb); /* ??? */\n\n        bytes_per_minute = avio_rb32(pb);\n\n        if (version == 4) {\n\n            if (bytes_per_minute)\n\n                st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        }\n\n        avio_rb32(pb); /* ??? */\n\n        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */\n\n        st->codec->block_align= avio_rb16(pb); /* frame size */\n\n        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */\n\n        avio_rb16(pb); /* ??? */\n\n        if (version == 5) {\n\n            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);\n\n        }\n\n        st->codec->sample_rate = avio_rb16(pb);\n\n        avio_rb32(pb);\n\n        st->codec->channels = avio_rb16(pb);\n\n        if (version == 5) {\n\n            ast->deint_id = avio_rl32(pb);\n\n            avio_read(pb, buf, 4);\n\n            buf[4] = 0;\n\n        } else {\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n            ast->deint_id = AV_RL32(buf);\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n        }\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(buf);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n\n\n        switch (st->codec->codec_id) {\n\n        case AV_CODEC_ID_AC3:\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n            break;\n\n        case AV_CODEC_ID_RA_288:\n\n            st->codec->extradata_size= 0;\n\n            ast->audio_framesize = st->codec->block_align;\n\n            st->codec->block_align = coded_framesize;\n\n            break;\n\n        case AV_CODEC_ID_COOK:\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        case AV_CODEC_ID_ATRAC3:\n\n        case AV_CODEC_ID_SIPR:\n\n            if (read_all) {\n\n                codecdata_length = 0;\n\n            } else {\n\n                avio_rb16(pb); avio_r8(pb);\n\n                if (version == 5)\n\n                    avio_r8(pb);\n\n                codecdata_length = avio_rb32(pb);\n\n                if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                    av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            ast->audio_framesize = st->codec->block_align;\n\n            if (st->codec->codec_id == AV_CODEC_ID_SIPR) {\n\n                if (flavor > 3) {\n\n                    av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\",\n\n                           flavor);\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ff_sipr_subpk_size[flavor];\n\n            } else {\n\n                if(sub_packet_size <= 0){\n\n                    av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ast->sub_packet_size;\n\n            }\n\n            if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0)\n\n                return ret;\n\n\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            avio_rb16(pb); avio_r8(pb);\n\n            if (version == 5)\n\n                avio_r8(pb);\n\n            codecdata_length = avio_rb32(pb);\n\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                return -1;\n\n            }\n\n            if (codecdata_length >= 1) {\n\n                avio_r8(pb);\n\n                if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0)\n\n                    return ret;\n\n            }\n\n            break;\n\n        default:\n\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n\n        }\n\n        if (ast->deint_id == DEINT_ID_INT4 ||\n\n            ast->deint_id == DEINT_ID_GENR ||\n\n            ast->deint_id == DEINT_ID_SIPR) {\n\n            if (st->codec->block_align <= 0 ||\n\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n\n                ast->audio_framesize * sub_packet_h < st->codec->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n        switch (ast->deint_id) {\n\n        case DEINT_ID_INT4:\n\n            if (ast->coded_framesize > ast->audio_framesize ||\n\n                sub_packet_h <= 1 ||\n\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_GENR:\n\n            if (ast->sub_packet_size <= 0 ||\n\n                ast->sub_packet_size > ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_SIPR:\n\n        case DEINT_ID_INT0:\n\n        case DEINT_ID_VBRS:\n\n        case DEINT_ID_VBRF:\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown interleaver %X\\n\", ast->deint_id);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (read_all) {\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            rm_read_metadata(s, 0);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17752, "substitutes": {"s": ["a", "ds", "cs", "os", "t", "p", "as", "ses", "sq", "is", "bs", "e", "sv", "rs", "gs", "sa", "S", "ss", "ns", "v", "sts", "vs", "se", "ps", "sys", "js", "sd", "c", "es", "ats", "fs", "ts", "ls", "spe", "stats", "spec", "sc", "m"], "pb": ["patch", "td", "snap", "lp", "lv", "cv", "np", "tc", "dp", "wp", "px", "p", "sb", "pp", "bb", "proc", "emb", "sp", "amp", "asm", "bot", "ctx", "ub", "bp", "imp", "pc", "span", "ob", "fb", "gc", "xp", "tmp", "vp", "py", "tp", "pg", "pro", "bj", "stab", "vm", "obj", "peer", "pm", "tab", "typ", "mp", "orp", "PB", "pkg", "pt", "msg", "nb", "erb", "pool", "jp", "um", "tk", "rb", "tm", "cb", "pl", "pa", "uf", "resp", "ping", "cp", "eb", "b", "ap", "lb"], "st": ["td", "stable", "nt", "ist", "sh", "sp", "store", "must", "th", "interface", "set", "rt", "fr", "sv", "ste", "mt", "ct", "stat", "stop", "sw", "sty", "St", "sts", "start", "etc", "se", "ft", "sn", "storage", "pt", "inst", "put", "std", "et", "ust", "ST", "art", "sta", "str", "est", "usr", "ts", "irst", "nd", "no", "rest", "tt", "src", "sc", "ut", "ost"], "ast": ["a", "mem", "alert", "amd", "sam", "am", "ist", "as", "ess", "md", "asm", "aster", "acl", "at", "ar", "aw", "ard", "asts", "aft", "cast", "mt", "stat", "ad", "ma", "sw", "ab", "access", "asted", "ref", "master", "std", "ust", "art", "est", "sta", "act", "AST", "ts", "af", "asting", "an", "rest", "tt", "ac", "ost"], "read_all": ["read___all", "read___total", "read_only", "read_default", "read___only", "write_all", "read_total", "write_only", "read___default", "write_default", "write_total"], "buf": ["mem", "cap", "cv", "Buff", "font", "w", "img", "sb", "p", "result", "bh", "port", "text", "fb", "bag", "tmp", " buffer", "bc", "out", "kw", "mb", "pg", "v", "bytes", "wb", "iter", "data", "cmd", "msg", "raw", "rb", "nm", "cb", "bin", "uf", "cp", "buffer", "Buffer", "buff", "b", "seq", "ff", "br", "err"], "version": ["index", "channel", "server", "format", "currency", "depth", "final", "usage", "interface", "stream", "ception", "port", "tar", "feature", "option", "ion", "Version", "vert", "command", "length", "ersion", "step", "position", "major", "v", "class", "vers", "release", "order", "driver", "vision", "fish", "tag", "number", "VERSION", "sequence", "package", "grade", "section", "ver", "VER", "versions", "status", "direction", "mode", "type"], "ret": ["mem", " compat", "flag", "valid", "ter", "final", "num", "result", "Ret", " conv", "ruby", "vals", "prop", "conv", "etc", "Return", "response", "RET", "rev", "val", " resp", "alt", "resp", "buffer"], "bytes_per_minute": ["bytes_per_second", "bytes_Per_minute", "bytes_Per_second", "bytes_perJminute", "bytes_PER_day", "bytes_perJsecond", "bytes_PER_second", "bytes_perThemini", "bytes_per_mini", "bytes_Per_frequency", "bytes_Per_minimum", "bytes_per_day", "bytes_perJframe", "bytes_per_frequency", "bytes_perThemin", "bytes_per_min", "bytes_per_minimum", "bytes_perJmin", "bytes_PER_minute", "bytes_PER_min", "bytes_per_frame", "bytes_perTheminute", "bytes_Per_frame", "bytes_perThesecond", "bytes_Per_mini", "bytes_Per_min"], "flavor": ["FLavour", "flactor", " flavored", "Flavored", "FLavored", "flavour", " flactor", "faver", "favored", "FLaver", "flavored", "Flavour", " flavour", "flaver", "FLavor", "favor", "Flavor", "Flaver", "favour", "factor", "Flactor"], "sub_packet_h": ["sub_packetctlength", "sub_packets_size", "sub_packetctsize", "sub_packets_header", "sub_packets_h", "sub_packets_length", "sub_packet_header", "sub_packetctheader", "sub_packetcth", "sub_packet_length"], "coded_framesize": ["coded_framale", "coded_frameIZE", "coded_imagesicate", "coded_framesiz", "coded_imagesizer", "coded_frameiz", "coded_onesicate", "coded_frameale", "coded_framesicate", "coded_framessize", "coded_frameizer", "coded_framize", "coded_frameize", "coded_fieldsization", "coded_fieldsizer", "coded_minsize", "coded_codesIZE", "coded_onesidate", "coded_minsidate", "coded_codesale", "coded_imagesidate", "coded_codesize", "coded_minsicate", "coded_frameization", "coded_framesizer", "coded_onesizer", "coded_onesize", "coded_framesization", "coded_codessize", "coded_framesale", "coded_framsize", "coded_minsizer", "coded_framesIZE", "coded_framIZE", "coded_framesidate", "coded_fieldsize", "coded_fieldsiz", "coded_imagesize"], "sub_packet_size": ["sub_packet_len", "sub_packets_name", "sub_packets_size", "sub_packet__len", "sub_packet_name", "sub_packets_length", "sub_packet__name", "sub_packet__length", "sub_packets_len", "sub_packet__size", "sub_packet_length"], "codecdata_length": ["codecextra_start", "codecextra_byte", "codecdata_start", "codecdata_byte", "codecextra_length", "codecextra_location", "codecdata_location"]}}
{"project": "FFmpeg", "commit_id": "c5be6192f0a50eb8a2134c32b7d57f1d88736adf", "target": 1, "func": "int show_license(void *optctx, const char *opt, const char *arg)\n\n{\n\n    printf(\n\n#if CONFIG_NONFREE\n\n    \"This version of %s has nonfree parts compiled in.\\n\"\n\n    \"Therefore it is not legally redistributable.\\n\",\n\n    program_name\n\n#elif CONFIG_GPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_GPL\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 2 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_LGPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU Lesser General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#else\n\n    \"%s is free software; you can redistribute it and/or\\n\"\n\n    \"modify it under the terms of the GNU Lesser General Public\\n\"\n\n    \"License as published by the Free Software Foundation; either\\n\"\n\n    \"version 2.1 of the License, or (at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\"\n\n    \"Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public\\n\"\n\n    \"License along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#endif\n\n    );\n\n\n\n    return 0;\n\n}\n", "idx": 17765, "substitutes": {"optctx": ["optioncontext", "optx", "optionctx", "opctx", "optiontx", "optioncb", "optcontext", "opttx", " optcontext", " opttx", "optcb", "opcb", "opcontext", " optcb"], "opt": ["help", "init", "Opt", "tx", "var", "term", "oc", "pot", "ret", "option", "crit", "op", "prop", "doc", "obj", "cmd", "ext", "lit", "ref", "def", "txt", "Arg", "ver", "spec", "dest"], "arg": ["mem", "use", "word", "args", "flag", "ax", "var", "proc", "user", "ret", "op", "reg", "doc", "param", "call", "msg", "cmd", "target", "ext", "argument", "ref", "tag", "par", "block", "Arg", "spec", "event", "ig"]}}
{"project": "FFmpeg", "commit_id": "62c3c8ca78ee2da7dc20c2d6371866266c82966d", "target": 1, "func": "int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,\n\n                              int lower_transport, const char *real_challenge)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int rtx = 0, j, i, err, interleave = 0, port_off;\n\n    RTSPStream *rtsp_st;\n\n    RTSPMessageHeader reply1, *reply = &reply1;\n\n    char cmd[2048];\n\n    const char *trans_pref;\n\n\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n\n        trans_pref = \"x-pn-tng\";\n\n    else\n\n        trans_pref = \"RTP/AVP\";\n\n\n\n    /* default timeout: 1 minute */\n\n    rt->timeout = 60;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n     * RTSP stream */\n\n\n\n    /* Choose a random starting offset within the first half of the\n\n     * port range, to allow for a number of ports to try even if the offset\n\n     * happens to be at the end of the random range. */\n\n    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);\n\n    /* even random offset */\n\n    port_off -= port_off & 0x01;\n\n\n\n    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {\n\n        char transport[2048];\n\n\n\n        /*\n\n         * WMS serves all UDP data over a single connection, the RTX, which\n\n         * isn't necessarily the first in the SDP but has to be the first\n\n         * to be set up, else the second/third SETUP will fail with a 461.\n\n         */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n\n             rt->server_type == RTSP_SERVER_WMS) {\n\n            if (i == 0) {\n\n                /* rtx first */\n\n                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n\n                    int len = strlen(rt->rtsp_streams[rtx]->control_url);\n\n                    if (len >= 4 &&\n\n                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n\n                                \"/rtx\"))\n\n                        break;\n\n                }\n\n                if (rtx == rt->nb_rtsp_streams)\n\n                    return -1; /* no RTX found */\n\n                rtsp_st = rt->rtsp_streams[rtx];\n\n            } else\n\n                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];\n\n        } else\n\n            rtsp_st = rt->rtsp_streams[i];\n\n\n\n        /* RTP/UDP */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {\n\n            char buf[256];\n\n\n\n            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {\n\n                port = reply->transports[0].client_port_min;\n\n                goto have_port;\n\n            }\n\n\n\n            /* first try in specified port range */\n\n            while (j <= rt->rtp_port_max) {\n\n                ff_url_join(buf, sizeof(buf), \"rtp\", NULL, host, -1,\n\n                            \"?localport=%d\", j);\n\n                /* we will use two ports per rtp stream (rtp and rtcp) */\n\n                j += 2;\n\n                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,\n\n                               &s->interrupt_callback, NULL))\n\n                    goto rtp_opened;\n\n            }\n\n\n\n            av_log(s, AV_LOG_ERROR, \"Unable to open an input RTP port\\n\");\n\n            err = AVERROR(EIO);\n\n            goto fail;\n\n\n\n        rtp_opened:\n\n            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);\n\n        have_port:\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;\", trans_pref);\n\n            if (rt->server_type != RTSP_SERVER_REAL)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                     \"client_port=%d\", port);\n\n            if (rt->transport == RTSP_TRANSPORT_RTP &&\n\n                !(rt->server_type == RTSP_SERVER_WMS && i > 0))\n\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n            /* For WMS streams, the application streams are only used for\n\n             * UDP. When trying to set it up for TCP streams, the server\n\n             * will return an error. Therefore, we skip those streams. */\n\n            if (rt->server_type == RTSP_SERVER_WMS &&\n\n                (rtsp_st->stream_index < 0 ||\n\n                 s->streams[rtsp_st->stream_index]->codec->codec_type ==\n\n                    AVMEDIA_TYPE_DATA))\n\n                continue;\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/TCP;\", trans_pref);\n\n            if (rt->transport != RTSP_TRANSPORT_RDT)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                        \"interleaved=%d-%d\",\n\n                        interleave, interleave + 1);\n\n            interleave += 2;\n\n        }\n\n\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;multicast\", trans_pref);\n\n        }\n\n        if (s->oformat) {\n\n            av_strlcat(transport, \";mode=receive\", sizeof(transport));\n\n        } else if (rt->server_type == RTSP_SERVER_REAL ||\n\n                   rt->server_type == RTSP_SERVER_WMS)\n\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n\n        snprintf(cmd, sizeof(cmd),\n\n                 \"Transport: %s\\r\\n\",\n\n                 transport);\n\n        if (rt->accept_dynamic_rate)\n\n            av_strlcat(cmd, \"x-Dynamic-Rate: 0\\r\\n\", sizeof(cmd));\n\n        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {\n\n            char real_res[41], real_csum[9];\n\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n\n                                              real_challenge);\n\n            av_strlcatf(cmd, sizeof(cmd),\n\n                        \"If-Match: %s\\r\\n\"\n\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n\n                        rt->session_id, real_res, real_csum);\n\n        }\n\n        ff_rtsp_send_cmd(s, \"SETUP\", rtsp_st->control_url, cmd, reply, NULL);\n\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n\n            err = 1;\n\n            goto fail;\n\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n\n                   reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].lower_transport != rt->lower_transport ||\n\n                reply->transports[0].transport != rt->transport) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->lower_transport = reply->transports[0].lower_transport;\n\n            rt->transport = reply->transports[0].transport;\n\n        }\n\n\n\n        /* Fail if the server responded with another lower transport mode\n\n         * than what we requested. */\n\n        if (reply->transports[0].lower_transport != lower_transport) {\n\n            av_log(s, AV_LOG_ERROR, \"Nonmatching transport in server reply\\n\");\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        switch(reply->transports[0].lower_transport) {\n\n        case RTSP_LOWER_TRANSPORT_TCP:\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n\n\n        case RTSP_LOWER_TRANSPORT_UDP: {\n\n            char url[1024], options[30] = \"\";\n\n\n\n            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)\n\n                av_strlcpy(options, \"?connect=1\", sizeof(options));\n\n            /* Use source address if specified */\n\n            if (reply->transports[0].source[0]) {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL,\n\n                            reply->transports[0].source,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            } else {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL, host,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            }\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&\n\n                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            /* Try to initialize the connection state in a\n\n             * potential NAT router by sending dummy packets.\n\n             * RTP/RTCP dummy packets are used for RDT, too.\n\n             */\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n\n                CONFIG_RTPDEC)\n\n                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);\n\n            break;\n\n        }\n\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n\n            char url[1024], namebuf[50], optbuf[20] = \"\";\n\n            struct sockaddr_storage addr;\n\n            int port, ttl;\n\n\n\n            if (reply->transports[0].destination.ss_family) {\n\n                addr      = reply->transports[0].destination;\n\n                port      = reply->transports[0].port_min;\n\n                ttl       = reply->transports[0].ttl;\n\n            } else {\n\n                addr      = rtsp_st->sdp_ip;\n\n                port      = rtsp_st->sdp_port;\n\n                ttl       = rtsp_st->sdp_ttl;\n\n            }\n\n            if (ttl > 0)\n\n                snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl);\n\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n\n                        port, \"%s\", optbuf);\n\n            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,\n\n                           &s->interrupt_callback, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            break;\n\n        }\n\n        }\n\n\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n\n            goto fail;\n\n    }\n\n\n\n    if (reply->timeout > 0)\n\n        rt->timeout = reply->timeout;\n\n\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n\n        rt->need_subscription = 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    ff_rtsp_undo_setup(s);\n\n    return err;\n\n}\n", "idx": 17766, "substitutes": {"s": ["a", "hs", "ds", "os", "t", "p", "tx", "sb", "ses", "st", "sq", "h", "set", "is", "e", "sv", "rs", "gs", "sa", "S", "ss", "sec", "ns", "sts", "v", "se", "ps", "sys", "js", "c", "r", "n", "ts", "spec", "sl", "b"], "host": ["connection", "server", "mac", "client", "controller", "hook", "query", "h", "domain", "nick", "header", "owner", "link", "node", "subject", "handle", "address", "ip", "peer", "conn", "target", "origin", "Host", "path", "bind", "localhost", "hop"], "port": ["channel", "Port", "server", "format", "p", "pp", "client", "ort", "stream", "pport", "point", "address", "PORT", "ports", "porter", "eport", "ptr", "ip", "ile", "page", "rot", "gp", "pn", "ocol", "cp", "file", "type"], "lower_transport": ["lower_transflow", "lower_taskband", "lower_transPort", "lower_portport", "lower2transports", "lower2ransport", "lower2transport", "lower_portband", "lower_teleflow", "lower_TransPort", "lower_teleport", "lower2ransports", "lower2transPort", "lower_portpport", "lower_ransocol", "lower_transports", "lower_Transocol", "lower_telepport", "lower_taskdrop", "lower_teleband", "lower_ransPort", "lower2ransPort", "lower_ransports", "lower_transband", "lower_taskport", "lower_ranspport", "lower_transdrop", "lower_teleocol", "lower_Transports", "lower2ransocol", "lower_transocol", "lower_telePort", "lower_teleports", "lower_Transport", "lower_ransdrop", "lower2transocol", "lower_taskflow", "lower_taskpport", "lower_ransflow", "lower_ransband", "lower_ransport", "lower_portdrop", "lower_transpport"], "real_challenge": ["real_challchange", "real_replenge", "real_messenge", "real_replue", "real_messue", "real_Challchange", "real_Challenges", "real_replenges", "real_challue", "real_messchange", "real_replchange", "real_Challue", "real_challenges", "real_messenges", "real_Challenge"], "rt": ["rm", "irt", "nt", "res", "t", "opt", "tx", "dt", "ort", "vt", "rw", "rx", "rect", "kt", "ctx", "ret", "hd", "fr", "rs", "tmp", "ht", "rin", "rr", "vc", "wt", "lat", "mt", "ot", "ct", "rec", "tp", "reg", "etc", "hw", "ptr", "dr", "obj", "lt", "feat", "sys", "rd", "req", "pkg", "ind", "rot", "r", "rid", "et", "NT", "art", "ant", "apt", "rb", "RT", "yt", "txt", "bt", "ssl", "qt", "tm", "rn", "ack", "ro", "rh", "nd", "rc", "tt", "vr", "gt", "it", "rf", "elt", "qq", "rl"], "j": ["jj", "ij", "z", "l", "t", "p", "dj", "ort", "q", "h", "ja", "li", "g", "uj", "fr", "J", "ot", "bj", "v", "k", "jl", "js", "pi", "json", "r", "jp", "job", "n", "ji", "o", "aj", "bi", "x", "jump", "it", "b", "y", "m"], "i": ["ic", "index", "ij", "jj", "b", "si", "l", "t", "ci", "im", "hi", "p", "ei", "ki", "qi", "ir", "li", "ri", "ni", "I", "u", "ai", "phi", "v", "io", "di", "ip", "mi", "pi", "iii", "ind", "id", "iri", "xi", "in", "oi", "ti", "jp", "ui", "r", "iat", "gi", "n", "o", "ami", "multi", "ji", "bi", "x", "ims", "zi", "ini", "it", "ix", "ia", "iu", "y", "ii", "m"], "err": ["init", "error", "res", "arr", "lex", "ei", "test", "gz", "hr", "fr", "rr", "ch", "progress", "dr", "iter", "aaa", "ptr", "req", "msg", "ind", "str", "er", "txt", "cb", "rn", "elt", "lr"], "port_off": ["port_block", "port2Off", "port_Off", "port_of", "port_offs", " port_Off", "PORT_on", "PORT_OFF", "Port_offset", "port_offset", "Port_off", "port_ex", "port_OFF", "port_on", " port_OFF", "Port_on", " port_offset", "PORT_of", "Port_Off", "port2off", "port2ex", " port_block", "Port_ex", "port_pos", "port2on", " port_pos", "PORT_off", " port_offs"], "rtsp_st": ["rtsp__stream", "rtsp_stat", "rtsp___stream", "rtsvp_ost", "rtspe_st", "rtspi_st", "rtsp_str", "rtsp_stream", "rtspe_str", "rtsping_stack", "rtsping_st", "rtsp___ste", "rtsvp_stream", "rtsp_ist", "rtsp_sty", "rtsping_stream", "rtspe_ste", "rtspi_ist", "rtsping_ste", "rtspi_stat", "rtsvp_st", "rtsp_stack", "rtsping___stream", "rtspe_sty", "rtsp_ost", "rtsp___stack", "rtsp__st", "rtsp___st", "rtsping___stack", "rtsp__ost", "rtsping___ste", "rtspi_stack", "rtsp_ste", "rtsping___st"], "reply1": ["response1", "Reply0", "answer2", "Reply1", "response2", "reply_", "reply2", "answer1", "response0", "Reply2", " reply0", "response_", " reply_", " reply2", "answer_", "answer0", "reply0"], "reply": ["frame", "repair", "pipe", "Reply", "report", "query", "ret", "replace", "header", "prefix", "link", "rr", "match", "command", "reason", "rep", "response", "try", "ply", "ignore", "repl", "request", "notice", "resp", "part", "transfer", "answer"], "cmd": ["init", "box", "desc", "ctx", " command", "op", "command", "cast", "handle", "send", "force", "control", "auth", "Cmd", "ip", "req", "msg", "comm", "batch", "cb", " auth", "params", "cp", "bind", "ctr", "Conn", "critical", "mode"], "trans_pref": ["trans_prefixc", "trans_prov", "trans_prv", "trans_pric", "trans_prefixference", "trans_presc", "trans_prfer", "trans_prec", "trans_prefixf", "trans_presf", "trans_proference", "trans_PREference", "trans_presference", "trans_prefixfer", "trans_prof", "trans_prefixv", "trans_prev", "trans_profer", "trans_prf", "trans_prefer", "trans_PREf", "trans_prif", "trans_prference", "trans_PREc", "trans_preference", "trans_prip", "trans_prep", "trans_priference", "trans_prefixp", "trans_PREp", "trans_prifer", "trans_presfer"], "transport": ["ranscmd", "ranscommand", "transcmd", "transports", "transfield", "ransports", "serpport", "switchcommand", "transpport", "transcommand", "serports", "Transport", "switchfield", "ransocol", "switchcmd", "ranspport", "teleocol", "Transcmd", "switchport", "Transfield", "ransport", "telepport", "Transcommand", "serport", "transocol", "ransfield", "serocol", "teleport", "teleports"], "rtx": ["irtx", "latux", "wtlex", "rdix", "prix", "retxe", "ttix", "rrxt", "rtj", "rxi", "htrx", "gtix", "ttx", "laty", "txv", "irtox", "rdX", "wtxx", "rtux", "wtx", "catrx", "retdx", "prox", "rdx", "rrox", "rdrox", "matx", "htx", "ntx", "rdlex", "matX", "latx", "txix", "rtrox", "rtxe", "rtxx", "rtxf", "txlex", "btxi", "ytxx", "catxi", "gtxx", "rox", "ttxt", "rtxt", "matux", "latix", "trux", "rdy", "ytx", "tdux", "ttrx", "ttxi", "ttox", "rty", "rwix", "latox", "rwi", "rtxi", "ytox", "wtox", "tdx", "gtx", "tti", "ntdx", "rtix", "catx", "rwj", "latj", "rx", "gtox", "rtox", "rtv", "txrox", "prxx", "maty", "prx", "wtix", "rtX", "rxt", "txxe", "htxi", "rwx", "txdx", "retv", "ytxt", "trx", "tdox", "rdux", "trxf", "ttxx", "rtlex", "ntxe", "rtrx", "ttdx", "rrx", "trox", "catdx", "retx", "rrxx", "btx", "rtdx", "btox", "lati", "htdx", "latX", "btxt", "txx", "wtrox", "ttj", "rti", "irtxi", "irtxt", "latxf", "tdxf", "ntv"], "buf": ["mem", "cap", "box", "window", "var", "proc", "map", "cast", "alloc", "off", "conv", "ptr", "data", "pool", "comm", "pack", "cb", "block", "bin", "uf", "buffer", "Buffer", "buff", "ctr", "code"]}}
{"project": "FFmpeg", "commit_id": "24130234cd9dd733116d17b724ea4c8e12ce097a", "target": 0, "func": "static int parse_fmtp(AVFormatContext *s,\n\n                      AVStream *stream, PayloadContext *data,\n\n                      const char *attr, const char *value)\n\n{\n\n    AVCodecParameters *par = stream->codecpar;\n\n    int res, i;\n\n\n\n    if (!strcmp(attr, \"config\")) {\n\n        res = parse_fmtp_config(par, value);\n\n\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (par->codec_id == AV_CODEC_ID_AAC) {\n\n        /* Looking for a known attribute */\n\n        for (i = 0; attr_names[i].str; ++i) {\n\n            if (!av_strcasecmp(attr, attr_names[i].str)) {\n\n                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {\n\n                    *(int *)((char *)data+\n\n                        attr_names[i].offset) = atoi(value);\n\n                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)\n\n                    *(char **)((char *)data+\n\n                        attr_names[i].offset) = av_strdup(value);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17786, "substitutes": {"s": ["a", "ds", "cs", "os", "t", "w", "p", "sq", "h", "ar", "is", "e", "sv", "rs", "sw", "d", "v", "se", "ps", "c", "ats", "n", "x", "f", "spec", "sc", "m"], "stream": ["sc", "form", "console", "window", "desc", "st", "store", "ec", "ream", "util", "shape", "rend", "length", "content", "conv", "sw", "v", "read", "instance", "response", "stack", "spect", "spec", "Stream", "pool", "context", "message", "str", "transform", "path", "ack", "ssl", "metadata", "view", "chain", "src", "serv", "sl", "event", "trans"], "data": ["mem", "form", "size", "window", "tx", "result", "ctx", "zero", "device", "action", "buf", "dat", "ata", "map", "done", "length", "reason", "content", "name", "rec", "image", "d", "DATA", "reg", "partial", "mu", "da", "Data", "obj", "addr", "dev", "new", "context", "batch", "val", "table", "str", "extra", "message", "cache", "info", "encrypted", "buffer", "text", "this", "trans"], "attr": ["atts", "spr", "adv", "arr", "perm", "pr", "p", "desc", "var", "adj", "aff", "unc", "rt", "arg", "fr", "rs", "tmp", "prefix", "op", "prop", "rr", "tr", "reg", "addr", "typ", "msg", "cmd", "req", "att", "rel", "r", "tag", "cmp", "str", "act", "apt", "acc", "key", "txt", "attribute", "ack", "vr", "urg", "elt", "br", "err", "type"], "value": ["index", "b", "format", "size", "widget", "VALUE", "comment", "p", "result", "test", "output", "buf", "expression", "property", "config", "vp", "values", "content", "Value", "name", "unit", "v", "variable", "label", "description", "tag", "version", "val", "context", "field", "message", "raw", "now", "key", "attribute", "block", "params", "buffer", "text", "conf", "type"], "par": ["prep", "arr", "pp", "p", "var", "sp", "proc", "tar", "ctx", "ar", "ran", "PAR", "pres", "pol", "per", "rs", "tp", "kar", "pro", "rec", "Par", "dr", "pri", "param", "ps", "rem", "sys", "mp", "pkg", "pers", "rel", "jp", "gr", "cmp", "pair", "pas", "pre", "pa", "car", "params", "cp", "arp", "serv", "parse", "conf"], "res": ["cs", "os", "max", "details", "resources", "result", "results", "ress", "ret", "cons", "sum", "bs", " RES", "pres", "vals", "ber", "resource", "rs", "resolution", "out", "reg", "Res", "ps", "rem", "js", "reset", "req", "re", "rel", "pers", "r", "val", "gr", "RES", "sol", "resp", "vol", "ons", "rest", " Res", "ms", "der", "yes", "conf", "red", "err"], "i": ["init", "yi", "ic", "index", "ij", "si", "z", "ci", "im", "hi", "p", "ei", "gl", "qi", "me", "h", "ir", "li", "ik", "is", "\u0438", "ri", "g", "I", "u", "ai", "phi", "iq", "v", "di", "io", "cli", "them", "ip", "mi", "pi", "c", "ind", "id", "oi", "j", "xi", "try", "ti", "batch", "ui", "gi", "n", "o", "ji", "multi", "uri", "bi", "x", "ims", "info", "zi", "ini", "sim", "status", "f", "chain", "it", "ix", "sql", "iu", "y", "ii", "m"]}}
{"project": "FFmpeg", "commit_id": "4c8ca76965b1c29758246624940cbc529e7141f0", "target": 0, "func": "static int ffserver_set_int_param(int *dest, const char *value, int factor,\n\n                                  int min, int max, FFServerConfig *config,\n\n                                  const char *error_msg, ...)\n\n{\n\n    int tmp;\n\n    char *tailp;\n\n    if (!value || !value[0])\n\n        goto error;\n\n    errno = 0;\n\n    tmp = strtol(value, &tailp, 0);\n\n    if (tmp < min || tmp > max)\n\n        goto error;\n\n    if (factor) {\n\n        if (FFABS(tmp) > INT_MAX / FFABS(factor))\n\n            goto error;\n\n        tmp *= factor;\n\n    }\n\n    if (tailp[0] || errno)\n\n        goto error;\n\n    if (dest)\n\n        *dest = tmp;\n\n    return 0;\n\n  error:\n\n    if (config) {\n\n        va_list vl;\n\n        va_start(vl, error_msg);\n\n        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, error_msg, vl);\n\n        va_end(vl);\n\n    }\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 17787, "substitutes": {"dest": ["temp", "comb", "index", "nom", "loc", "dist", "window", "opt", "desc", "sp", "num", "st", "result", "port", "decl", "end", "buf", "dat", "tif", "prop", "seek", "out", "name", "d", "important", "v", "etc", "start", "ptr", "iter", "obj", "cont", "addr", "spec", "target", "to", "dev", "origin", "est", "usr", "orig", "coord", "source", "del", "Dest", "rest", "src", "slave", "ident", "trans", "err"], "value": ["index", "server", "format", "VALUE", "valid", "ter", "p", "array", "input", "test", "text", "set", "scale", "change", "expression", "property", "initial", "save", "values", "content", "Value", "address", "image", "name", "unit", "v", "variable", "start", "select", "data", "field", "val", "message", "key", "vector", "source", "attribute", "null", "buffer", "code", "ty", "version", "type"], "factor": ["offset", "comb", "font", "fd", "or", "size", "t", "currency", "beta", "term", "power", "scale", "actor", "timer", "per", "fac", "amount", "step", "second", "multipl", "xf", "unit", "force", "area", "fact", "frac", "operator", "product", "Factor", "half", "mult", " factors", "token", "prime", "rate", "tor", "tier", "alpha", "f", " Factor", "part", "rf", "lr", "mode"], "min": ["MIN", "loc", "mins", "p", "sub", "Min", "base", "span", "mod", "mn", "mini", "minimum", "v", "start", "amin", "lt", "param", "range", "mi", "Minimum", "in", "val", "minute", "diff", "mean", "lo", "pre", "len", "from", "small", "lower", "version", "m"], "max": ["cap", "ca", "size", "t", "w", "ax", "pr", "p", "final", "end", "last", "scale", "base", "mod", " MAX", "MAX", "out", "ma", "wrap", "v", "range", "c", "mx", "ext", "master", "flow", "dev", "wh", "current", "n", "med", "Max", "maximum", "x", "prime", "gt", "ex", "m"], "config": ["init", "check", "con", "connection", "channel", "format", "t", "complex", "component", "settings", "desc", "client", "secure", "capt", "list", "adj", "interface", "remote", "ctx", "cand", "scale", "spec", "communication", "setup", "cf", "command", "subject", "bc", "sec", "ct", "unknown", "address", "gov", "etc", "control", "cont", "apache", "param", "service", "conn", "driver", "data", "c", "cmd", "msg", "commit", "storage", "operator", "ogg", "account", "comm", "figure", "cfg", "fig", "fc", "state", "cache", "txt", "attribute", "Config", "FIG", "rc", "abc", "chain", "com", "exec", "sc", "conf", "file", "gate", "process"], "error_msg": ["error_Msg", "debug_cfg", "debug_msg", "error___md", "error___message", "error_mess", "error___msg", "debug_mag", "debug_mg", "ror_Msg", "ror_msg", "error_mag", " error_mess", "error_mg", "ror_message", "error_cfg", " error_mag", "error_message", " error_Msg", "error___Msg", "ror_md", "error_md"], "tmp": ["temp", "nom", "loc", " t", "img", "sup", "test", " pts", "ctx", " mk", "rt", "copy", " ptr", "tp", "mb", "obj", "aaa", "mp", "nb", "jp", " amp", "orig", "cache", " np", "tm", " sp", "emp", "td", "offset", "cv", "np", "perm", "t", " dst", "sp", "var", "timeout", " temp", "sum", "cur", "fac", "ot", "etc", "tf", "msg", "pkg", " ta", "resp", " old", "mut", "buff", "elt", "snap", "tc", "nt", " prev", "term", "tar", "expr", "prefix", "prop", " src", "partial", "uv", "ptr", "attr", "verb", " resp", "cmp", "txt", "prime", "tg", "cp", "tt", "stuff", "pos", " temporary", " mp", "p", "vt", "sq", "tn", "Temp", " tid", "cont", "ind", "clip", "mk", " quot", "src"], "tailp": ["gestpa", "tailpa", "gypb", "gestP", "tailps", " tailjp", "gyP", " tailP", "gestpb", "ailjp", "gestp", " tailps", " TailP", "ailps", "tailjp", "gyp", "lengthP", "gypa", " tailpb", " tailpa", "ailp", "ailP", "lengthps", "tailP", " Tailp", "lengthp", "tailpb", " Tailjp"], "vl": ["vel", "vi", "lv", "ul", "l", "qv", " sl", "ival", "itle", "isl", "acl", "ll", "ml", "vet", "VL", "abl", "tle", "ava", "sv", "dl", "vp", "wl", "vc", "aval", "v", "uv", "lvl", "ln", "pel", "ipl", "ve", "ptr", "iv", " li", "ibl", "nl", " ml", " lvl", "ev", "kl", "lic", "ele", "lan", "ls", "pl", "vo", "vv", "vol", "bol", "vr", "vid", " pl", "sl", "tl", "rl", "fl"]}}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n\n{\n\n    unsigned int tag;\n\n    int64_t size;\n\n\n\n    for (;;) {\n\n        if (url_feof(pb))\n\n            return AVERROR_EOF;\n\n        size = next_tag(pb, &tag);\n\n        if (tag == tag1)\n\n            break;\n\n        wav_seek_tag(pb, size, SEEK_CUR);\n\n    }\n\n    return size;\n\n}\n", "idx": 17792, "substitutes": {"pb": ["lp", "cv", "np", "tc", "wp", "px", "p", "pp", "bb", "sb", "emb", "bp", "ub", "pc", "fb", "bs", "gc", "buf", "vp", "tp", "bc", "pg", "bj", "aus", "wb", "ab", "mp", "gb", "PB", "xb", "pkg", "pt", "jp", "obb", "tk", "rb", "ib", "pread", "cb", "pa", "uf", "cp", "eb", "fp", "b", "lb"], "tag1": ["tagOne", " tagOne", "TagOne", "ag2", "Tag1", "Tag0", "Tag2", "ag1", "tag2", "TAG0", "TAG1", "tag0", "TAGOne", "agOne", "TAG2", " tag0", " tag2"], "tag": ["next", "offset", "pos", "word", " error", "style", "ag", "t", "format", " event", "comment", "ping", " flag", "p", "var", "tar", "sum", "qual", " TAG", "match", "length", "stat", "name", "bug", "reg", "feat", "cat", "TAG", "msg", "id", "field", "message", "date", "pack", "Tag", "pair", "key", "ack", "attribute", "token", "tail", "type", "tg", " Tag", "len", "status", "code", "event", "task", " match", "ig"], "size": ["offset", "needed", "pos", "index", "zone", "loc", "z", "t", "slice", "max", "sp", "num", "ose", "port", "set", "end", "scale", "sum", "span", "count", "g", "shape", "length", "send", "position", "name", "v", "capacity", "start", "fee", "time", "msg", "ize", "speed", "message", "summary", "n", "now", "number", "rank", "dim", "space", "Size", "SIZE", "len", "loss", "status", "s", "buffer", "small", "large", "code", "dimension", "type"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_6REGS && HAVE_INLINE_ASM\n\n    if (INLINE_AMD3DNOWEXT(cpu_flags)) {\n\n        fdsp->vector_fmul_window  = vector_fmul_window_3dnowext;\n\n    }\n\n    if (INLINE_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul_window = vector_fmul_window_sse;\n\n    }\n\n#endif\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_sse;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;\n\n        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_sse;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;\n\n        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;\n\n        fdsp->butterflies_float   = ff_butterflies_float_sse;\n\n    }\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;\n\n    }\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_avx;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_avx;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;\n\n    }\n\n}\n", "idx": 17803, "substitutes": {"fdsp": ["fredserv", "fdstr", "ftss", "fmpy", "condns", "fedsw", "dfspace", "FDserv", "fcns", "fredpl", "ldserv", "dfscope", "fredblock", "fcpl", "fredsw", "fdspe", "dfstr", "fdpl", "dlSP", "finsw", "vdSP", "dfip", "dfpy", "condsp", "formstr", "dfsc", "dlsp", "fredpy", "fredns", "fdset", "dfse", "montserv", "fcsync", "gdsp", "dfsw", "dfsm", "fdpt", "rodscope", "dnsc", "gdserv", "erdsp", "gdservice", "fredss", "fdns", "dfpl", "formservice", "fdblock", "ondsc", "dfns", "gdsync", "iddsp", "fdservice", "fdpy", "fcsp", "fcsm", "ftsp", "fmsw", "vdpp", "fdgp", "fredip", "condsm", "fdse", "iddserv", "fcspe", "dnspe", "dftp", "ffspace", "fdspace", "dfblock", "FDspace", "iddstr", "ondsp", "rodstr", "fedgp", "fedsp", "finspace", "fdsc", "dfserv", "FDsp", "fdsm", "fredset", "dfsync", "fdsync", "montsp", "iddse", "fredsync", "designsp", "fdpp", "fdss", "ondblock", "fingp", "ffservice", "rodservice", "ondset", "iddsync", "ffns", "dfSP", "dfgp", "iddservice", "dfservice", "erdscope", "rodsp", "montpt", "erdservice", "dfpt", "fdSP", "ondspe", "fcpy", "ftstr", "formsp", "montss", "vdsp", "fredstr", "ffpage", "dlsc", "ldsp", "fredspe", "fdpage", "fredservice", "fcip", "fredsp", "fcservice", "dlpp", "ftip", "designpt", "fredpage", "designsync", "fdip", "fedspace", "dfsp", "fdsw", "fmpt", "dnsp", "FDtp", "fdtp", "ffsp", "formse", "fdscope", "fmsp", "ffspe", "fcsw", "ldspace", "dfss", "condservice", "montsync", "vdsc", "montservice", "ffsync", "dnspace", "ffsc", "ondservice", "dfset", "dfpp", "finsp", "designss", "erdstr", "ldtp", "fdserv", "dfspe", "ffserv", "dfpage", "ondspace", "fcpt"]}}
{"project": "qemu", "commit_id": "096685fc2a955ea17d5363ab452e301be2b43873", "target": 1, "func": "static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n\n    int offset = addr;\n\n    int bank_no, line_no;\n\n    struct omap_intr_handler_bank_s *bank = NULL;\n\n\n\n    if ((offset & 0xf80) == 0x80) {\n\n        bank_no = (offset & 0x60) >> 5;\n\n        if (bank_no < s->nbanks) {\n\n            offset &= ~0x60;\n\n            bank = &s->bank[bank_no];\n\n\n\n\n        }\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* INTC_REVISION */\n\n        return s->revision;\n\n\n\n    case 0x10:\t/* INTC_SYSCONFIG */\n\n        return (s->autoidle >> 2) & 1;\n\n\n\n    case 0x14:\t/* INTC_SYSSTATUS */\n\n        return 1;\t\t\t\t\t\t/* RESETDONE */\n\n\n\n    case 0x40:\t/* INTC_SIR_IRQ */\n\n        return s->sir_intr[0];\n\n\n\n    case 0x44:\t/* INTC_SIR_FIQ */\n\n        return s->sir_intr[1];\n\n\n\n    case 0x48:\t/* INTC_CONTROL */\n\n        return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */\n\n\n\n    case 0x4c:\t/* INTC_PROTECTION */\n\n\n\n\n    case 0x50:\t/* INTC_IDLE */\n\n        return s->autoidle & 3;\n\n\n\n    /* Per-bank registers */\n\n    case 0x80:\t/* INTC_ITR */\n\n        return bank->inputs;\n\n\n\n    case 0x84:\t/* INTC_MIR */\n\n        return bank->mask;\n\n\n\n    case 0x88:\t/* INTC_MIR_CLEAR */\n\n    case 0x8c:\t/* INTC_MIR_SET */\n\n\n\n\n    case 0x90:\t/* INTC_ISR_SET */\n\n        return bank->swi;\n\n\n\n    case 0x94:\t/* INTC_ISR_CLEAR */\n\n\n\n\n    case 0x98:\t/* INTC_PENDING_IRQ */\n\n        return bank->irqs & ~bank->mask & ~bank->fiq;\n\n\n\n    case 0x9c:\t/* INTC_PENDING_FIQ */\n\n        return bank->irqs & ~bank->mask & bank->fiq;\n\n\n\n    /* Per-line registers */\n\n    case 0x100 ... 0x300:\t/* INTC_ILR */\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        return (bank->priority[line_no] << 2) |\n\n                ((bank->fiq >> line_no) & 1);\n\n    }\n\n\n\n}", "idx": 17805, "substitutes": {"opaque": ["opent", "pent", " opatile", "OPac", "opaques", "opatile", " opaques", "oppatile", "oplaque", "oppent", "opac", "OPcache", "oppacity", "oplac", "oplcache", "oppaque", " opcache", " opent", " opacity", " opac", "opacity", "paque", "OPaques", "pacity", "opcache", "patile", "OPaque", "oplaques"], "addr": ["offset", "pos", "work", "loc", "location", "res", "ord", "pad", "i", "var", "store", "asm", "at", "hash", "kt", "adr", "map", "prefix", "mt", "alloc", "seek", "ad", "address", "off", "start", "inter", "ptr", "add", "order", "ref", "r", "bound", "align", "aro", "coord", "dh", "arch", "Address", "len", "arp", "rc", "url", "src", "ix", "gate"], "size": ["mem", "offset", "z", "args", "weight", "pad", "sp", "num", "set", "e", "count", "length", "send", "name", "address", "start", "area", "fee", "data", "ize", "message", "align", "n", "Size", "SIZE", "len", "type"], "s": ["scripts", "ges", "ing", "ubs", "ches", "span", "g", "rs", "conv", "parser", "sys", "resses", "ants", "es", "comm", "iffs", "fs", "er", "browser", "serv", "spec", "sl", "os", "t", "ays", "sp", "app", "qs", "sa", "S", "ss", "sts", "v", "soc", "ments", "ps", "service", "erences", "n", "ts", "ls", "locks", "ains", "stats", "ed", "bes", "eds", "services", "a", "ies", "ds", "sam", "l", "sb", "changes", "als", "south", "sv", "grades", "session", "js", "storage", "ances", "ssl", "states", "b", "m", "rates", "utils", "hs", "ists", "outs", "p", "ings", "store", "sq", "ions", "aws", "h", "ers", "asm", "ands", "is", "bs", "gs", "ports", "ns", "ations", "sports", "flows", "ats", "r", "less", "ashes", "actions", "ms", "its"], "bank_no": ["bank_No", "bank_n", " bank_yes", "ank_na", "bank_number", "ank_no", "bank_value", " bank_n", " bank_index", "bank_yes", "bank_nos", "ank_number", "brain_by", "board_eno", "ank_yes", "board_po", "bank_name", "brain_yes", "brain_value", "bank_po", "ank_nos", " bank_number", "bank08value", " bank_No", "brain_no", "board_no", "ank_eno", "ank_0", " bank_num", "bank_index", "bank_num", "board_na", "bank08by", "bank_na", "bank08yes", "bank_0", " bank_name", "bank_eno", "bank_by", "bank08no"], "line_no": ["LINE_len", "line_num", "line2name", "line_NO", "LINE_ne", "block_no", " line_spec", "point_num", "line_number", "line_name", "point_NO", " line_go", " line_No", "line2NO", "block_ko", "line_ko", "LINE_NO", "line2no", "block_number", "block_num", "point_no", "line_len", "LINE_no", "line_spec", "line_go", "line2num", "line_No", "point_name", "line_ne"], "bank": ["leaf", "country", "back", "lib", "banks", "ank", "journal", "base", "option", "bag", "bay", "Bank", "parser", "black", "account", "field", "rank", "ger", "er", "cache", "bin", "jump", "book", "buffer", "import", "browser", "ang", "bet", "bb", "var", "sp", "v", "pb", "plugin", "service", "ab", " banks", "dev", "root", "vote", "pack", "acc", "ram", "ack", "lang", "view", "bang", "sam", "slice", "comment", "sb", "rule", "bush", "query", "script", "buf", "node", "disk", "ANK", "fork", "band", "session", "instance", "storage", "agency", "rb", "block", "an", "go", "zer", "scan", "b", "process", "bridge", "board", "p", "cell", "ob", "volume", "ban", "library", "author", "gem", "db", "pod", "bid", "flow", "tag", "batch", "jam", "table", "package", "alias", "conf", "file", "type"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)\n\n{\n\n    *range = 8 * (1 << (f_code - 1));\n\n    /* XXX: temporary kludge to avoid overflow for msmpeg4 */\n\n    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)\n\n\t*range *= 2;\n\n\n\n    if (s->unrestricted_mv) {\n\n        *xmin = -16;\n\n        *ymin = -16;\n\n        if (s->h263_plus)\n\n            *range *= 2;\n\n        if(s->avctx->codec->id!=CODEC_ID_MPEG4){\n\n            *xmax = s->mb_width*16;\n\n            *ymax = s->mb_height*16;\n\n        }else {\n\n            *xmax = s->width;\n\n            *ymax = s->height;\n\n        }\n\n    } else {\n\n        *xmin = 0;\n\n        *ymin = 0;\n\n        *xmax = s->mb_width*16 - 16;\n\n        *ymax = s->mb_height*16 - 16;\n\n    }\n\n}\n", "idx": 17807, "substitutes": {"s": ["ies", "hs", "ds", "cs", "os", "ops", "sg", "t", "p", "details", "sb", "ses", "changes", "als", "as", "ins", "aws", "h", "sq", "set", "qs", "is", "bs", "south", "sv", "rs", "gs", "S", "ss", "comments", "sw", "ns", "sts", "v", "vs", "se", "ps", "sports", "sys", "js", "http", "spec", "c", "es", "ats", "comm", "eps", "fs", "less", "ts", "ims", "ls", "parts", "ains", "aunts", "params", "stats", "ms", "ex", "states", "bis", "m"], "range": ["offset", "error", "res", "repeat", "size", "slice", "max", "valid", "array", "q", "radius", "remote", "set", "domain", "feature", "ge", "scale", "rang", "rad", "resource", "resolution", "length", "force", "axis", "limit", "mask", "route", "spread", "call", "release", "random", "scope", "ref", "r", "ange", "diff", "align", "bound", "ANGE", "lim", "block", "view", "panel", "scan", "chain", "filter", "broad", "angle", "lag", "Range", "conf", "trace"], "xmin": ["oxfrom", "oxmax", "ixonly", "oxmin", "ixmod", "axstart", "rxmin", "ixstart", "oxman", "exonly", "xonly", "mxmin", "xman", "axmod", "xbegin", "axmin", "ixfrom", "mxfrom", "mxmax", "xmod", "xstart", "exbegin", "exmax", "axpos", "ixman", "ixpos", "mxman", "exmin", "imin", "xpos", "istart", "ipos", "rxonly", "ixmax", "imod", "rxmax", "ixmin", "rxbegin", "xfrom", "ixbegin"], "ymin": ["mmin", "symin", "xprev", "mmax", "ypart", " yman", "mmon", "nystart", "ystart", "xside", "cyprev", "mman", "ymman", "nypart", "cystart", "cymin", "ymmin", "ymmon", "cyside", "symax", "ymon", "cypart", "ymmax", "yside", "nyside", " ymon", "systart", "cymax", "yman", "nymin", "yprev", "syside", "syprev", "sypart"], "xmax": ["axmax", "xax", "axlimit", "Xmin", "oxmax", "xend", "oxmin", "ixax", "extotal", "rxmin", "xMAX", "exlimit", "oxax", "xref", "rxax", "ixlimit", "rxref", "axtotal", "XMAX", "axax", "xtotal", "rxend", "yMAX", "exmax", "oxend", "exMAX", "exax", "yax", "exmin", "xlimit", "exend", "exref", "ixmax", "Xmax", "rxmax", "ixmin", "Xax", "ixref", "ixtotal"], "ymax": ["ymake", "ypin", "symale", "pmmax", "dmaja", "ythajor", "dmaz", "ypake", "dmax", "hemax", "esmake", "esmajor", "ymmin", "symmax", "ythax", "dmatch", "symax", "pmatch", "iamac", "ymaja", "ymmax", "ymale", "hemaja", "ypatch", "pmaz", "ymajor", "ythux", "symaja", "esmax", "ymatch", "ymain", "ypmax", "ypux", "ymmac", "ymac", "pmax", "hemale", "iamax", "ymaz", "ypajor", "ypaz", "iamin", "iamain", "dmmax", "dmale", "esmux", "ypain", "ymmain", "hemmax", "ypac", "ypax", "ythake", "ymux"], "f_code": [" f_error", "f_Code", "tf_value", "f8error", " f_Code", "tf_code", "f_value", "tf_flag", "f_flag", "f8Code", "f_error", "f8code"]}}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "static int device_try_init(AVFormatContext *ctx,\n\n                           enum AVPixelFormat pix_fmt,\n\n                           int *width,\n\n                           int *height,\n\n                           uint32_t *desired_format,\n\n                           enum AVCodecID *codec_id)\n\n{\n\n    int ret, i;\n\n\n\n    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);\n\n\n\n    if (*desired_format) {\n\n        ret = device_init(ctx, width, height, *desired_format);\n\n        if (ret < 0) {\n\n            *desired_format = 0;\n\n            if (ret != AVERROR(EINVAL))\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    if (!*desired_format) {\n\n        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n\n            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||\n\n                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {\n\n                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",\n\n                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),\n\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));\n\n\n\n                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;\n\n                ret = device_init(ctx, width, height, *desired_format);\n\n                if (ret >= 0)\n\n                    break;\n\n                else if (ret != AVERROR(EINVAL))\n\n                    return ret;\n\n                *desired_format = 0;\n\n            }\n\n        }\n\n\n\n        if (*desired_format == 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"\n\n                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",\n\n                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,\n\n                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    *codec_id = avpriv_fmt_v4l2codec(*desired_format);\n\n    av_assert0(*codec_id != AV_CODEC_ID_NONE);\n\n    return ret;\n\n}\n", "idx": 17808, "substitutes": {"ctx": ["ck", "tx", "kj", "rt", "setup", "crit", "kw", "obj", "sys", "req", "comm", "jp", "context", "tk", "cm", "dc", "tm", "xc", "abc", "check", "cv", "np", "fn", "mc", "gz", "cur", "ct", "etc", "hw", "pkg", "kl", "fc", "cu", "resp", "wcs", "sc", "ctl", "tc", "ca", "wp", "proc", "cn", "kt", "unc", "cl", "cf", "xp", "prefix", "jac", "ka", "cc", "bc", "co", "addr", "cmp", "cfg", "act", "cp", "rc", "tnc", "history", "work", "this", "pause", "tz", "window", "pc", "gc", "cas", "config", "wx", "wd", "conn", "cmd", "batch", "lc", "cb", "nc", "conf", "iat"], "pix_fmt": ["pix__fmt", "pix_flt", "pix2ftx", "pix__vtm", "pix_tmt", "pix__vmt", "pix__ftm", "pix2flt", "pix_twt", "pix_llt", "pix_ctx", "pix_vformat", "pix__fformat", "pix__vformat", "pix__fwt", "pix_vmt", "pix_ltx", "pix_vwt", "pix_fwt", "pix_tformat", "pix_ctm", "pix_ftm", "pix_fformat", "pix_clt", "pix_lmt", "pix2fmt", "pix_cmt", "pix_lformat", "pix_vtm", "pix_ltm", "pix_lwt", "pix_ftx", "pix_ttm", "pix2ftm", "pix__vwt"], "height": ["grow", "offset", "history", "style", "size", "density", "window", "depth", "w", "hang", "th", "h", "hash", "frames", "radius", "html", "volume", "count", "inches", "ht", "shape", "padding", "resolution", "length", "upper", "ch", "capacity", "bottom", "range", " heights", "through", "above", "host", "rows", "headers", "rank", "row", "angle", "ows", "ty", "y"], "desired_format": ["desiredexistingtype", "desired_unit", "desired_title", "desiredUtitle", "desiredlyformat", "desired_data", "desired___filter", "desire_value", "desiry___filter", "desired___feat", "desfulexistingerror", "desfulexistingformat", "desired7position", "desired_form", "desire_status", "desirement_format", "desired_spec", "desirementxcolor", "desired__value", "desires__feat", "desiredlyfilter", "desitted_format", "desful_error", "desires__type", "desitted_unit", "desinished_type", "desired7format", "desire_type", "desired67format", "desirementxsource", "desired67limit", "desful_list", "desiredexistingformat", "desired__feat", "desired_feat", "desiredxtitle", "desirement_source", "desiredachescale", "desiry___limit", "desired___format", "desired67filter", "desitted_form", "desiredexistingerror", "desiredlyspec", "desires_format", "desired_prefix", "desful_valid", "desiredexistinglist", "desiredUformat", "desiredexistingchannel", "desired_error", "desired_feature", "desiredurestatus", "desired___init", "desiredurecache", "desired__init", "desired_init", "desiry_filter", "desirable_version", "desired_valid", "desired_status", "desired_cache", "desired_version", "desiredUsource", "desires__init", "desired_scale", "desirementxtitle", "desired7size", "desirement_color", "desiry_data", "desiredexistingFormat", "desired_color", "desired_position", "desires__format", "desired_list", "desiredureprefix", "desiry_spec", "desired___type", "desiredureformat", "desired_limit", "desiredacheformat", "desirable_format", "desires_init", "desired__type", "desiredlylimit", "desired___limit", "desired_value", "desful_format", "desirement_title", "desired_type", "desire_cache", "desirable_feature", "desiredxsource", "desiredUcolor", "desiredexistingvalid", "desiredachefeature", "desire_prefix", "desinished_format", "desired_size", "desinished_Format", "desired_source", "desired_filter", "desiredxcolor", "desired___spec", "desiredacheversion", "desinished_channel", "desfulexistingvalid", "desiry_position", "desirable_scale", "desired__format", "desiry_limit", "desire_format", "desiredxformat", "desired_write", "desires_feat", "desfulexistinglist", "desiry_size", "desired67spec", "desired7data", "desired_Format", "desires_type", "desiry___format", "desired_channel", "desirementxformat", "desiry___spec", "desiry_format", "desitted_write"], "codec_id": ["codec_oid", "codecaphport", "codecalityid", "codisc_info", "codec___id", "codendor_code", "codiscityname", "codecalityname", "codisc_oid", "codecaphid", "codendor_id", "codec_info", "codecityname", "codec_name", "codiscityoid", "codec_code", "codiscityinfo", "codoc_port", "codec_iden", "codisc_id", "codendor_info", "codendor___bid", "codendor___name", "codecaphname", "codecityinfo", "codendor_name", "codec_port", "codec___bid", "codendor___id", "codecalitybid", "codoc_iden", "codecityid", "codiscityid", "codendor___file", "codecityoid", "codoc_name", "codisc_name", "codec___file", "codec___name", "codecaphiden", "codoc_id", "codec_bid", "codendor_file", "codendor_bid", "codecalityfile", "codec_file"], "ret": ["back", "valid", "dt", "report", "rt", "fr", "tif", "mat", "inter", "iter", "get", "sys", "jp", "RT", "ert", "net", "rets", "mem", "t", "desc", "result", "ry", "port", "RET", "reset", "re", "try", "len", "resp", "f", "rest", "fun", "it", "elt", "err", "rm", "res", "nt", "ter", "rect", "expr", "il", "tr", "mt", "reg", "lt", "ft", "att", " resp", "def", "print", "alt", "txt", "gt", " res", "arr", "deg", "ort", "ll", "last", " fut", "out", "rep", "cont", "dr", "rem", "success", "rev", "cmd", "func", "ext", "ref", "r", "val", "reflect", "uf", "Ret"], "i": ["ic", "index", "ij", "si", "t", "ci", "im", "hi", "p", "ei", "ki", "ski", "ir", "err", "li", "is", "\u0438", "ri", "g", "json", "I", "ai", "phi", "v", "di", "io", "inter", "cli", "iter", "ip", "mi", "pi", "oi", "ind", "id", "iri", "j", "xi", "c", "in", "try", "ti", "to", "batch", "ui", "iat", "gi", "n", "ji", "multi", "uri", "bi", "info", "ims", "sim", "ini", "go", "status", "s", "f", "chain", "it", "ix", "zi", "iu", "bis", "y", "ii", "m"]}}
{"project": "qemu", "commit_id": "2f0772c5b4818d4b2078be9dace0036d1030faee", "target": 1, "func": "static void lsi_soft_reset(LSIState *s)\n\n{\n\n    lsi_request *p;\n\n\n\n    DPRINTF(\"Reset\\n\");\n\n    s->carry = 0;\n\n\n\n    s->msg_action = 0;\n\n    s->msg_len = 0;\n\n    s->waiting = 0;\n\n    s->dsa = 0;\n\n    s->dnad = 0;\n\n    s->dbc = 0;\n\n    s->temp = 0;\n\n    memset(s->scratch, 0, sizeof(s->scratch));\n\n    s->istat0 = 0;\n\n    s->istat1 = 0;\n\n    s->dcmd = 0x40;\n\n    s->dstat = LSI_DSTAT_DFE;\n\n    s->dien = 0;\n\n    s->sist0 = 0;\n\n    s->sist1 = 0;\n\n    s->sien0 = 0;\n\n    s->sien1 = 0;\n\n    s->mbox0 = 0;\n\n    s->mbox1 = 0;\n\n    s->dfifo = 0;\n\n    s->ctest2 = LSI_CTEST2_DACK;\n\n    s->ctest3 = 0;\n\n    s->ctest4 = 0;\n\n    s->ctest5 = 0;\n\n    s->ccntl0 = 0;\n\n    s->ccntl1 = 0;\n\n    s->dsp = 0;\n\n    s->dsps = 0;\n\n    s->dmode = 0;\n\n    s->dcntl = 0;\n\n    s->scntl0 = 0xc0;\n\n    s->scntl1 = 0;\n\n    s->scntl2 = 0;\n\n    s->scntl3 = 0;\n\n    s->sstat0 = 0;\n\n    s->sstat1 = 0;\n\n    s->scid = 7;\n\n    s->sxfer = 0;\n\n    s->socl = 0;\n\n    s->sdid = 0;\n\n    s->ssid = 0;\n\n    s->stest1 = 0;\n\n    s->stest2 = 0;\n\n    s->stest3 = 0;\n\n    s->sidl = 0;\n\n    s->stime0 = 0;\n\n    s->respid0 = 0x80;\n\n    s->respid1 = 0;\n\n    s->mmrs = 0;\n\n    s->mmws = 0;\n\n    s->sfs = 0;\n\n    s->drs = 0;\n\n    s->sbms = 0;\n\n    s->dbms = 0;\n\n    s->dnad64 = 0;\n\n    s->pmjad1 = 0;\n\n    s->pmjad2 = 0;\n\n    s->rbc = 0;\n\n    s->ua = 0;\n\n    s->ia = 0;\n\n    s->sbc = 0;\n\n    s->csbc = 0;\n\n    s->sbr = 0;\n\n    while (!QTAILQ_EMPTY(&s->queue)) {\n\n        p = QTAILQ_FIRST(&s->queue);\n\n        QTAILQ_REMOVE(&s->queue, p, next);\n\n        g_free(p);\n\n    }\n\n    if (s->current) {\n\n        g_free(s->current);\n\n        s->current = NULL;\n\n    }\n\n}\n", "idx": 17833, "substitutes": {"s": ["sg", "details", "results", "g", "rs", "vs", "se", "bl", "sys", "es", "sync", "fs", "sol", "space", "er", "params", "spec", "os", "settings", "sp", "set", "qs", "_", "S", "ss", "sts", "ps", "call", "n", "o", "ts", "ls", "parts", "ads", "stats", "rest", "bes", "bis", "comments", "services", "ies", "ctl", "ds", "cs", "l", "terms", "as", "ses", "changes", "als", "num", "ar", "sv", "all", "http", "js", "gets", "def", "mods", "an", "ix", "has", "y", "m", "hs", "con", "i", "ins", "ers", "h", "is", "bs", "gs", "ports", "ns", "cont", "cmd", "pers", "ats", "r", "new", "less", "ims", "ms", "us", "full", "search", "comp", "conf", "its"], "p": ["lp", "np", "t", "w", "i", "pp", "sp", "h", "q", "bp", "pc", "e", "g", "tp", "d", "v", "pb", "ps", "c", "j", "r", "o", "n", "cp", "P", "b", "y", "m"]}}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n\n{\n\n    int ich, i;\n\n    int order        = s->mclms_order;\n\n    int num_channels = s->num_channels;\n\n\n\n    for (ich = 0; ich < num_channels; ich++) {\n\n        pred[ich] = 0;\n\n        if (!s->is_channel_coded[ich])\n\n            continue;\n\n        for (i = 0; i < order * num_channels; i++)\n\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n\n                         s->mclms_coeffs[i + order * num_channels * ich];\n\n        for (i = 0; i < ich; i++)\n\n            pred[ich] += s->channel_residues[i][icoef] *\n\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n\n        pred[ich] += 1 << s->mclms_scaling - 1;\n\n        pred[ich] >>= s->mclms_scaling;\n\n        s->channel_residues[ich][icoef] += pred[ich];\n\n    }\n\n}\n", "idx": 17877, "substitutes": {"s": ["bits", "details", "ess", "e", "conf", "g", "rs", "conv", "vs", "se", "obj", "sys", "c", "es", "comm", "acs", "series", "ex", "spec", "os", "ops", "t", "settings", "set", "qs", "S", "ss", "sts", "v", "ps", "xs", "ts", "ls", "ains", "stats", "bes", "status", "ds", "cs", "as", "sb", "ses", "changes", "als", "sv", "sw", "js", "source", "state", "states", "b", "has", "rates", "hs", "args", "p", "ins", "sq", "ions", "aws", "h", "is", "bs", "gs", "ns", "ats", "eps", "less", "ims", "ms", "this", "its"], "icoef": ["ciefficients", "coeff", " icff", " icalf", "icoalf", "ICOefficients", "ciff", "coalf", "rioeph", "rioEF", "icalf", "rioalf", "cif", "cialf", "groef", "icf", "rioef", "icef", "ciEF", "icof", "icoefficients", "cieph", " icef", "cief", "groalf", "ICOalf", "groEF", "coef", " iceff", "coff", "ICOf", "ICOef", "icoeph", "cieff", "icoEF", "groeph", "icoeff", "icefficients", "icoff"], "pred": ["pub", "prep", "loc", "ist", "pr", "sup", "report", "test", "Pred", "fitted", "cast", "length", "mat", "pro", "surv", "obj", "iv", "priv", "put", "cond", "med", "cho", "pre", "ded", "fn", "inf", "dist", "pp", "adj", "compl", "stick", "tmp", "lab", "ps", "vind", "post", "bind", "buff", "patch", "pret", "proc", "expr", "prop", "ptr", "embed", "dict", "tested", "redict", "rod", "pull", "ned", "text", "like", "debug", "needed", "pop", "arr", "sent", "p", "assert", "pdf", "pod", "vest", "supp", "push", "roll", "ind", "rel", "prof", "binary", "powered", "df", "cod", "repl", "ped", "red", "sim", "ff"], "ich": ["shop", "cloth", "orph", "ank", "imp", "integer", "ox", "conv", "uth", "ait", "resh", "iter", "iv", "esp", "chan", "owl", "host", "ether", "ift", "och", "ench", "unch", "chn", "ill", "ike", "channel", "sky", "icht", "oc", "ish", "animate", "aff", "hist", "irm", "chip", "craft", "cht", "isch", "hw", "ih", "wife", "yout", "iss", "ict", "\u00e7", "utch", "arch", "x", "hai", "Chip", "ig", "bird", "ic", "click", "ord", " chip", "num", "chest", "ik", "html", "ht", "ch", "iq", "clus", "capacity", "clock", "ip", "each", "outh", "mot", "act", "alth", "contact", "txt", "eric", "hip", "uch", "ie", "ech", "machine", "ix", "irc", "y", "iam", "chart", "iban", "igraph", "sch", "ship", "im", "phy", "ach", "iche", "morph", "isc", "chid", "nick", " ch", "anch", "ICH", "choice", "quant", "entity", "chant", "batch", "isk", "world", "iy", "ethical", "rich", "iver", "ick"], "i": ["init", "ic", "index", "ij", "mac", "si", "ci", "im", "hi", "p", "ei", "client", "ki", "qi", "isi", "me", "at", "ir", "remote", "set", "ik", "li", "is", "\u0438", "ri", "ice", "g", "ni", "point", "I", "ai", "phi", "ch", "ori", "v", "di", "cli", "io", "ip", "PI", "mi", "pi", "oi", "ind", "iri", "in", "j", "xi", "ti", "ui", "et", "iat", "gi", "ji", "ami", "multi", "uri", "fi", "ogi", "bi", "zi", "ini", "sim", "gu", "ie", "it", "ix", "us", "ex", "iu", "y", "ii", "m"]}}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "func": "static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs = vd->clients;\n\n    while (vs != NULL) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        else /* TODO */\n\n            vnc_update(vs, dst_x, dst_y, w, h);\n\n        vs = vs->next;\n\n    }\n\n}\n", "idx": 17883, "substitutes": {"ds": ["hs", "cs", "os", "ys", "ks", "Ds", "qs", "bs", "rs", "gs", "dl", "uds", "bd", "des", "irs", "d", "db", "ns", "sts", "sys", "js", "iss", "sd", "xs", "pd", "ods", "dos", "fs", "ims", "ls", "ads", "s", "dds", "DS", "ms", "dd", "eds"], "src_x": [" src_rx", "src_ix", "src__y", "src_ex", "srcptix", " src_ix", "rc_ex", "src__ex", "src__x", "rc_rx", "src_rx", "rc_x", "srcptx", "srcptxi", "src__rx", " src_xi", "srcptrx", "rc_y", "src_xi"], "src_y": ["src_vy", " src_Y", "src_xy", "src2xy", "rc_sy", "rc_vy", "rc_x", "src2Y", " src_xy", "src_yy", "src2yy", "src_sy", "src_Y", "src2y", " src_yy", "rc_y"], "dst_x": ["dest_w", "dstoxxi", "dstoxxd", "dest_ex", "dst__w", "dest_x", "dst_fx", "dst_ex", "dst_w", "dsrc_rx", "dst__ex", "dst__y", "dsrc_x", "dst_rx", "dst_xi", "dnt_xi", "dsrc_w", "dsrc_ex", "dst__x", "dnt_x", "dnt_xd", "dstoxfx", "dnt_fx", "dstoxx", "dst_xd", "dest_y"], "dst_y": ["dout_Y", "dst_ny", "dst_ys", "ddest_ny", "dsrc_ey", "ddest_x", "dout_ys", "dst___o", "dsrc_y", "dout_y", "dst_ey", "dst___x", "dst_Y", "dout_cy", "dsrc_x", "ddest_y", "dst___y", "ddest_o", "dst_o", "dst___ny", "dst_cy"], "w": [" dw", "wp", "window", "weight", "mm", "ow", "rw", "we", "win", "whe", "iw", "aw", "wid", "wl", "wt", "nw", "kw", "sw", "wr", "ew", "wa", "wb", "hw", "wx", "wd", "wh", "ww", "wi", "W", "wn", "x", "fw", "wind", " W", "wal", "ex", "wk"], "h": ["hs", "ho", "hh", "oh", "l", "z", "hi", "hl", "sh", "kh", "p", "ish", "uh", "im", "he", "hz", "th", "bh", "ha", "q", "hr", "hd", "ht", "length", "ch", "v", "H", "ih", "c", "height", "wh", "high", "hei", "ph", "rh", "ah", "b", "m"], "vd": ["td", "lv", "VD", "dj", "dk", "md", "vt", " sd", "nv", "hd", "sv", "dl", "kb", "vc", "uds", "udi", "bd", "irs", "d", "dr", "wd", "sd", "gb", "nl", "xd", "pd", "ud", "du", "df", "dh", "gd", "ld", "nd", "vr", "od", "dd", "eds", "dq"], "vs": ["vi", "hs", "cs", "lbs", "ov", "lv", "atts", "os", "qv", "fps", "flags", "ils", " cs", "ins", "vt", "ubs", "pps", "otes", "ks", "qs", "is", "bs", "av", "ves", "vals", "sv", "rs", "gs", "vp", "alls", "vc", "uds", "ss", "values", "lists", "ports", "v", "ns", "sts", "vm", "uv", "aps", "sys", "ps", "vers", "js", "irms", "xs", "css", "inv", "es", "gets", "iffs", "obs", "eps", "views", "fs", "VS", "ts", "ims", "ls", "Vs", "links", "vr", "stats", "ms", "ues", "tv", "its"]}}
{"project": "qemu", "commit_id": "da5361cc685c004d8bb4e7c5e7b3a52c7aca2c56", "target": 1, "func": "static int emulated_exitfn(CCIDCardState *base)\n\n{\n\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n\n\n\n    vevent_queue_vevent(vevent); /* stop vevent thread */\n\n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n\n    card->quit_apdu_thread = 1; /* stop handle_apdu thread */\n\n    qemu_cond_signal(&card->handle_apdu_cond);\n\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n\n                      &card->apdu_thread_quit_mutex);\n\n    /* handle_apdu thread stopped, can destroy all of it's mutexes */\n\n    qemu_cond_destroy(&card->handle_apdu_cond);\n\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n\n    qemu_mutex_destroy(&card->vreader_mutex);\n\n    qemu_mutex_destroy(&card->event_list_mutex);\n\n    return 0;\n\n}\n", "idx": 17885, "substitutes": {"base": ["init", "na", "ic", "server", "basic", "back", "p", "bar", "store", "bp", "last", "bo", "bas", "gc", "based", "node", "ban", "cast", "out", "mb", "db", "start", "bid", "bit", "c", "re", "in", "id", "bu", "scope", "origin", "raw", "bound", "bf", "pse", "state", "null", "pa", "buffer", "f", "it", "bind", "b", "file", "create", "Base"], "card": ["cap", "wild", "word", "can", "ca", "back", "flag", "game", "ck", "comment", "var", "cards", "controller", "bar", "cell", "report", "play", "rule", "ar", "ard", "compl", "gc", "mod", "cf", "way", "ARD", "copy", "crit", "craft", "cast", "command", "cc", "ad", "control", "star", "flight", "dr", "rar", "add", "cont", "cat", "order", "roll", "c", "cmd", "func", "role", "note", "dev", "pass", "guard", "member", "def", "pack", "Card", "ce", "row", "car", "deck", "brand", "php", "book", "com", "carry", "parse", "event", "man"], "vevent": ["megent", "veent", "sequest", "tegent", "sevent", "meent", "vection", "mequest", "teent", "veevent", "mevent", "avevent", "aveevent", "vegent", "ovevent", "avection", "ovection", "ievent", "ieent", "iegent", "seevent", "oveevent", "ovequest", "iequest", "section", "tequest", "avequest", "vequest", "tevent"]}}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n", "idx": 17893, "substitutes": {"h": ["a", "mem", "hs", "l", "oh", "t", "w", "window", "i", "sh", "p", "pp", "he", "q", "ctx", "bh", "e", "g", "ht", "ch", "d", "v", "hw", "k", "H", "ih", "c", "hm", "hp", "j", "comm", "host", "context", "n", "o", "dh", "f", "ah", "b", "m"], "qscale": [" Qcrop", "QScale", "sqScale", " Qcale", "iqcale", "sqscale", "sqscene", "dqScale", "iqscale", " qcrop", " Qscale", " qcale", " qstep", "qcale", "dqscene", "dqsc", "Qsc", "iqcrop", "iqstep", "qScale", "qscene", "sqsc", "qcrop", "Qscene", "Qscale", "qstep", " Qstep", "qsc", "dqscale"]}}
{"project": "FFmpeg", "commit_id": "fe8c9420dd5bbc7a0c545e479da9118bcf311dd2", "target": 1, "func": "int AAC_RENAME(ff_ps_read_data)(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)\n\n{\n\n    int e;\n\n    int bit_count_start = get_bits_count(gb_host);\n\n    int header;\n\n    int bits_consumed;\n\n    GetBitContext gbc = *gb_host, *gb = &gbc;\n\n\n\n    header = get_bits1(gb);\n\n    if (header) {     //enable_ps_header\n\n        ps->enable_iid = get_bits1(gb);\n\n        if (ps->enable_iid) {\n\n            int iid_mode = get_bits(gb, 3);\n\n            if (iid_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"iid_mode %d is reserved.\\n\",\n\n                       iid_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_iid_par    = nr_iidicc_par_tab[iid_mode];\n\n            ps->iid_quant     = iid_mode > 2;\n\n            ps->nr_ipdopd_par = nr_iidopd_par_tab[iid_mode];\n\n        }\n\n        ps->enable_icc = get_bits1(gb);\n\n        if (ps->enable_icc) {\n\n            ps->icc_mode = get_bits(gb, 3);\n\n            if (ps->icc_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"icc_mode %d is reserved.\\n\",\n\n                       ps->icc_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_icc_par = nr_iidicc_par_tab[ps->icc_mode];\n\n        }\n\n        ps->enable_ext = get_bits1(gb);\n\n    }\n\n\n\n    ps->frame_class = get_bits1(gb);\n\n    ps->num_env_old = ps->num_env;\n\n    ps->num_env     = num_env_tab[ps->frame_class][get_bits(gb, 2)];\n\n\n\n    ps->border_position[0] = -1;\n\n    if (ps->frame_class) {\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = get_bits(gb, 5);\n\n    } else\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = (e * numQMFSlots >> ff_log2_tab[ps->num_env]) - 1;\n\n\n\n    if (ps->enable_iid) {\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_iid_data(avctx, gb, ps, ps->iid_par, huff_iid[2*dt+ps->iid_quant], e, dt))\n\n                goto err;\n\n        }\n\n    } else\n\n        memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n\n\n    if (ps->enable_icc)\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_icc_data(avctx, gb, ps, ps->icc_par, dt ? huff_icc_dt : huff_icc_df, e, dt))\n\n                goto err;\n\n        }\n\n    else\n\n        memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n\n\n    if (ps->enable_ext) {\n\n        int cnt = get_bits(gb, 4);\n\n        if (cnt == 15) {\n\n            cnt += get_bits(gb, 8);\n\n        }\n\n        cnt *= 8;\n\n        while (cnt > 7) {\n\n            int ps_extension_id = get_bits(gb, 2);\n\n            cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);\n\n        }\n\n        if (cnt < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"ps extension overflow %d\\n\", cnt);\n\n            goto err;\n\n        }\n\n        skip_bits(gb, cnt);\n\n    }\n\n\n\n    ps->enable_ipdopd &= !PS_BASELINE;\n\n\n\n    //Fix up envelopes\n\n    if (!ps->num_env || ps->border_position[ps->num_env] < numQMFSlots - 1) {\n\n        //Create a fake envelope\n\n        int source = ps->num_env ? ps->num_env - 1 : ps->num_env_old - 1;\n\n        int b;\n\n        if (source >= 0 && source != ps->num_env) {\n\n            if (ps->enable_iid) {\n\n                memcpy(ps->iid_par+ps->num_env, ps->iid_par+source, sizeof(ps->iid_par[0]));\n\n            }\n\n            if (ps->enable_icc) {\n\n                memcpy(ps->icc_par+ps->num_env, ps->icc_par+source, sizeof(ps->icc_par[0]));\n\n            }\n\n            if (ps->enable_ipdopd) {\n\n                memcpy(ps->ipd_par+ps->num_env, ps->ipd_par+source, sizeof(ps->ipd_par[0]));\n\n                memcpy(ps->opd_par+ps->num_env, ps->opd_par+source, sizeof(ps->opd_par[0]));\n\n            }\n\n        }\n\n        if (ps->enable_iid){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (FFABS(ps->iid_par[ps->num_env][b]) > 7 + 8 * ps->iid_quant) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"iid_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        if (ps->enable_icc){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (ps->icc_par[ps->num_env][b] > 7U) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"icc_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        ps->num_env++;\n\n        ps->border_position[ps->num_env] = numQMFSlots - 1;\n\n    }\n\n\n\n\n\n    ps->is34bands_old = ps->is34bands;\n\n    if (!PS_BASELINE && (ps->enable_iid || ps->enable_icc))\n\n        ps->is34bands = (ps->enable_iid && ps->nr_iid_par == 34) ||\n\n                        (ps->enable_icc && ps->nr_icc_par == 34);\n\n\n\n    //Baseline\n\n    if (!ps->enable_ipdopd) {\n\n        memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n        memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    }\n\n\n\n    if (header)\n\n        ps->start = 1;\n\n\n\n    bits_consumed = get_bits_count(gb) - bit_count_start;\n\n    if (bits_consumed <= bits_left) {\n\n        skip_bits_long(gb_host, bits_consumed);\n\n        return bits_consumed;\n\n    }\n\n    av_log(avctx, AV_LOG_ERROR, \"Expected to read %d PS bits actually read %d.\\n\", bits_left, bits_consumed);\n\nerr:\n\n    ps->start = 0;\n\n    skip_bits_long(gb_host, bits_left);\n\n    memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n    memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n    memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n    memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    return bits_left;\n\n}\n", "idx": 17904, "substitutes": {"avctx": ["avca", "avecontext", "AVctx", "abca", "abcm", "verctx", " avcontext", "avecmp", " avcp", "aveca", "avconn", "AVcf", "avcm", "avecf", "vercp", "Avcontext", "AVcontext", "afca", "avcontext", "abtx", "verconn", "avcmp", "afctx", " avconn", "Avctx", "afcm", "AVcmp", "Avcp", "avcf", "averctx", "avectx", "vercontext", "avcp", "Avconn", "avtx", "avercf", "abctx", "avercontext", "avecm", "avercmp", "aftx", "avetx"], "gb_host": ["gb64server", "nb_host", "nb_server", "db_host", "gb_ost", "gb2Host", "nb_over", "gb2host", "gb_path", "gb_Host", "gb64ost", "db_Host", "gb2server", "cb_server", "gb64host", "db_handle", "gb_handle", "gb2handle", "gb_over", "cb_path", "cb_host", "gb64over", "nb_ost", "gb_server", "db_server"], "ps": ["fields", "pr", "ping", "details", "results", "PS", "ctx", "checks", "vals", "rs", "points", "pins", "ips", "tp", "properties", "vs", "mp", "jp", "fs", "gp", "dates", "pa", "params", "ops", "flags", "pp", "sp", "abilities", "syn", "rots", "sts", "pb", "keys", "pt", "ts", "ls", "parts", "stats", "ds", "cs", "times", "changes", "als", "players", "js", "css", "cp", "rates", "pos", "fps", "ists", "p", "ins", "pps", "posts", "ands", "pc", "bs", "pres", "gs", "plays", "rep", "ports", "ns", "aps", "types", "pers", "ats", "pd", "eps", "pse", "ims", "phys", "ms", "its"], "bits_left": ["bits_lower", " bits_right", " bits_lower", "bits_low", "bits_right", " bits_low"], "e": ["ea", "ge", "ae", "te", "g", "ase", "one", "ffe", "se", "ee", "c", "es", "line", "eu", "ce", "er", "be", "ep", "eg", "pe", "ex", "el", "ame", "t", "de", "en", "eeee", "le", "_", "d", "ade", "ome", "n", "complete", "o", "ent", "x", "xe", "it", "ed", "event", "err", "l", "ei", "me", "ne", "fe", "ef", "ev", "nee", "element", "def", "ele", "ie", "eb", "m", "ue", "ate", "i", "ec", "edge", "ve", "entity", "func", "r", "et", "est", "eps", "eff", "E", "eh", "oe"], "header": ["offset", "check", "frame", "index", "channel", "error", "server", "chron", "size", "format", "flag", "p", "pp", "num", "h", "port", "tar", "layer", "set", "hd", "cf", "padding", "profile", "rr", "tr", "handle", "primary", "name", "ptr", "dr", "head", "iter", "data", "c", "body", "ref", "Header", "member", "headers", "table", "er", "prot", "metadata", "block", "meta", "len", "heading", "buffer", "wcs", "part", "version", "status", "border", "err", "type"], "bits_consumed": ["bits_cserved", "bits_csume", "bits_sume", "bits_consumption", "bits_conserved", "bits_Consume", "bits_sumption", "bits_Conserved", "bits_csumption", "bits_Consumed", "bits_csumed", "bits_consume", "bits_served", "bits_sumed", "bits_Consumption"], "gb": ["bridge", "px", "sg", "img", "csv", "phy", "sb", "bb", "goo", "gif", "ctx", "gz", "xy", "html", "pc", "fb", "gc", "ob", "buf", "g", "bs", "Gb", "ruby", "gnu", "gs", "kb", "py", "bg", "bc", "GB", "pg", "db", "mb", "ch", "bytes", "pb", "wb", "vm", "vg", "nb", "hub", "storage", "gg", "um", "obo", "cfg", "raw", "bf", "rg", "gp", "rb", "got", "gd", "cb", "bt", "tm", "tg", "gh", "cp", "gm", "eg", "buffer", "gt", "eb", "vd"], "num_env": ["num__dev", "num_ee", "nb___ee", "num___den", "nb___env", "Num_dev", "len_ext", "Num_env", "num_conn", "num_environment", "nom_env", "nb___den", "nom_environment", "num__env", "nom_dev", "nb___ext", "num_ev", "nb_den", "num_ext", "num___ext", "Num_conn", "num_dev", "len_environment", "nb_env", "nom_den", "num__ev", "num__ext", "len_ev", "Num_ev", "nb_ee", "num_den", "num___ee", "nb_ext", "num__conn", "len_env", "num___env", "num__environment"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        int size;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        size = pb->buf_end - pb->buf_ptr;\n\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n\n                             .buf_size = size };\n\n        if (!pd.buf)\n\n            goto error;\n\n        memcpy(pd.buf, pb->buf_ptr, size);\n\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n\n        av_freep(&pd.buf);\n\n        if (!sub_demuxer)\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n\n\n        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);\n\n        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 17908, "substitutes": {"s": ["a", "ds", "os", "t", "w", "sg", "p", "sq", "h", "bs", "g", "sv", "sa", "gs", "rs", "S", "ss", "v", "ns", "sts", "ps", "c", "ats", "fs", "ts", "ls", "b"], "st": ["stable", "nt", "sl", "t", "stra", "ist", "sh", "sb", "tx", "sp", "stage", "store", "th", "stream", "rt", "ss", "ste", "mt", "stat", "step", "stop", "sw", "St", "sts", "start", "se", "spect", "sn", "storage", "pt", "inst", "std", "ust", "art", "est", "ST", "str", "pat", "sta", "irst", "nd", "rest", "src", "sc", "ost"], "pkt": [" pdu", "dkl", " pmt", "fkt", "Packet", "pct", "wpvt", "fdu", "pskl", "pmsg", "Pwk", "pmt", " pwk", "Pvt", "wpnt", "dkt", "dacket", "ppacket", "ppct", "opkt", "wpct", "packet", " pvt", "psnt", "Pnt", "ppmsg", "pdu", "rmsg", "dnt", "opacket", " pmsg", "Pct", " packet", " pkl", "opwk", "opdu", "pvt", "pnt", "Pdu", "rkt", "Pmsg", "racket", "pwk", "Pkt", "pskt", "wpkt", "Pmt", " pct", "pkl", "ppmt", "fmsg", "facket", "ppkt", "rdu", "psacket", " pnt"], "desc": ["ds", "sort", " Desc", "dist", "disc", "comment", "sub", "dep", "md", "test", "err", "Desc", "ript", "buf", "vec", "dl", "bd", "des", "name", "rec", "pro", "label", "cd", "esc", "obj", "ptr", "cont", "attr", "asc", "description", "msg", "data", "ext", "dir", "id", "dev", "cmp", "def", "str", "dc", "diff", "dict", "DES", "summary", "dim", "txt", "info", "meta", "ribe", "described", "sc", "text", "seq"], "ret": ["mem", "res", "nt", "dist", "xt", "result", "test", "rt", "gc", "buf", "arg", "tmp", "tr", "mt", "des", "nz", "rep", "pro", "ptr", "dr", "get", "lt", "ft", "rem", "success", "RET", "rev", "re", "reset", "nl", "rel", "ref", "val", "rets", "summary", "alt", "txt", "len", "resp", "buffer", "gt", "fun", "elt", "err", "Ret"], "ast": ["a", "mem", "am", "dist", "and", "ist", "as", "tx", "ess", "store", "aster", "asm", "must", "at", "Ast", "acl", "test", "aw", "ard", "asts", "aft", "ace", "cast", "mt", "ad", "ma", "ait", "mast", "kind", "each", "addr", "ab", "esp", "any", "access", "wat", "att", "asted", "master", "embed", "art", "est", "sta", "pat", "act", "af", "AST", "ts", "ack", "asting", "nd", "rest", "best", "ed", "ief", "tt", "exec", "ost", "past"], "sub_demuxer": ["sub_demxier", "sub_promuxers", "sub_demixed", "sub_democe", "sub_demuxier", "sub_demixe", "sub_promuxe", "sub_promxer", "sub_demixers", "sub_demixer", "sub_demuxor", "sub_demxers", "sub_demxor", "sub_demuploador", "sub_demuxe", "sub_demuploaded", "sub_democier", "sub_demuploade", "sub_democers", "sub_democer", "sub_promxers", "sub_demixor", "sub_demxed", "sub_demixier", "sub_demxer", "sub_promuxier", "sub_promuxer", "sub_demuxers", "sub_promxier", "sub_promxe", "sub_demxe", "sub_demuxed", "sub_demuploader"], "time_base": ["time_bas", "time_Base", "Time_Base", "Time_base", "Time_bas"], "size": ["error", "z", "score", "shift", "scale", "span", "g", "length", "news", "speed", "origin", "number", "space", "year", "offset", "cap", "mem", "use", "t", "max", "sp", "timeout", "ose", "gz", "set", "sum", "shape", "general", "v", "start", "limit", "fee", "sn", "description", "dev", "n", "align", "len", "small", "code", "sc", "status", "min", "mode", "l", "total", "num", "south", "sv", "send", "name", "address", "sw", "capacity", "head", "time", "body", "height", "Size", "notice", "SIZE", "rc", "pos", "sent", "gc", "count", "empty", "out", "bytes", "area", "data", "ize", "id", "message", "extra", "now", "dim", "dump", "loss", "full"], "pb": ["patch", "td", "lp", "cv", "np", "tc", "dp", "wp", "px", "p", "sb", "pp", "bb", "sp", "tx", "tap", "emb", "proc", "bh", "ctx", "ub", "bp", "pc", "bps", "bs", "fb", "buf", "gc", "xp", "tmp", "vp", "py", "pan", "tp", "bc", "pg", "bj", "apy", "wb", "stab", "ps", "pm", "ab", "tab", "mp", "gb", "PB", "pkg", "pt", "nb", "jp", "tk", "apa", "rb", "ib", "cb", "pa", "tg", "uf", "cp", "eb", "buff", "b", "ap", "lb"], "pd": ["td", "ds", "PD", "np", " dw", "fd", "dp", " dab", "px", "pr", "pp", " prod", "dt", "dj", " pdf", "md", "p", " od", "edd", " sd", "pc", "hd", "pard", " pt", "dq", "dl", "vp", "py", " dd", "bd", "tp", "pdf", "ad", "d", "pod", "cd", "da", " cd", " md", "ps", "pm", "sd", "pi", "pkg", " ad", "xd", "ud", "def", " td", "ph", " ep", "pat", "df", "dh", " np", "ppo", "ped", "pl", "ld", "php", "cp", "po", "od", "vd", "dd", "ecd"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n", "idx": 17909, "substitutes": {"d": ["debug", "ds", "fd", "ord", "de", "p", "dt", "dj", "md", "dis", "hd", "dat", "dl", "done", "bd", "ct", "send", "ad", "db", "v", "di", "cd", "da", "dr", "sd", "ind", "dm", "dev", "r", "pd", "dos", "draw", "D", "dc", "n", "du", "dim", "dh", "ld", "dump", "nd", "dx", "did", "dd", "dn"]}}
{"project": "FFmpeg", "commit_id": "ac726a4f0cd2fb8619b478af51312a4282215f0e", "target": 0, "func": "static int movie_request_frame(AVFilterLink *outlink)\n\n{\n\n    AVFilterBufferRef *outpicref;\n\n    MovieContext *movie = outlink->src->priv;\n\n    int ret;\n\n\n\n    if (movie->is_done)\n\n        return AVERROR_EOF;\n\n    if ((ret = movie_get_frame(outlink)) < 0)\n\n        return ret;\n\n\n\n    outpicref = avfilter_ref_buffer(movie->picref, ~0);\n\n    ff_start_frame(outlink, outpicref);\n\n    ff_draw_slice(outlink, 0, outlink->h, 1);\n\n    ff_end_frame(outlink);\n\n    avfilter_unref_buffer(movie->picref);\n\n    movie->picref = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 17913, "substitutes": {"outlink": ["OUTlinked", "otlog", "olink", " outlinked", "devline", "outline", "outlinked", " outLink", " outcheck", "conman", "bootlink", "ol", "bootgroup", "outloop", "outcheck", "OUTstream", "otlink", "taskgroup", "OUTloop", "outzip", "outLink", "outl", "unlinked", "conlock", "cmdink", "OUTlog", " outzip", " outlock", "tasklink", "OutLink", "OUTink", "unlock", " outroute", " outstream", "cmdlinked", "outlog", " outloop", "cmdstream", " outink", "outroute", "otloop", "OUTLink", "conblock", "conlinked", " outlog", "unman", "unlink", "Outline", "olinked", "OUTline", "devlinked", " outline", "oblock", " outman", "OUTzip", "outink", " outl", "Outcheck", "devlink", "outstream", "devzip", "conl", "conlink", " outgroup", "outgroup", "taskroute", "OUTlink", "cmdlink", "outblock", " outblock", "otline", "outman", "bootroute", "outlock", "Outlink", "OUTcheck"], "outpicref": [" outPicref", "outnicmb", "OUTpicturemb", " outPicreference", "OUTpicreference", "outpicdesc", "outpinreference", "outPicdesc", " outPicdesc", "outpicturereference", " outpicdesc", "outpictureref", "OUTpicref", "outnicRef", "outpinref", "OUTpicturereference", " outpicdef", "outmicob", "outpinRef", "outpicreference", "outcamdef", "outpicturemb", "outmicref", " outPicdef", "outpcdesc", "OUTpictureRef", "outnicreference", "outPicref", " outpicob", "outpicmb", "outPicmb", "outpictureRef", " outPicob", "outpicdef", " outpicreference", "outpindesc", "OUTpicRef", "outpcRef", "outPicdef", "outmicreference", "OUTpictureref", "outcamref", "outnicref", " outpicRef", " outPicRef", "outmicdef", "outPicreference", "outpicob", "outcamob", "outPicob", "outpcref", "outpcreference", "outPicRef", "outpicRef", "OUTpicmb", "outcamreference"], "movie": ["frame", "hero", "die", "rage", "film", "menu", "mmm", "feature", "program", "mob", "move", "device", "core", "normal", "voice", "cam", "anim", "actor", "VIDEO", "mpeg", "mobile", "motion", "m", "mo", "image", "bug", "partial", "media", "video", "vm", "tv", "magic", "iframe", "manager", "my", "monster", "maker", "material", "dm", "gallery", "dev", "camera", "message", "member", "job", "runner", "ami", "picture", "ovie", "module", "notice", "flash", "metadata", "Movie", "meta", "player", "mor", "transfer", "mmmm", "scene", "file", "drm", "mode", "milo"], "ret": ["rm", "mel", " RET", "nt", "res", "t", "back", "git", "ter", "result", "test", "rt", "ber", " fut", "match", "tr", "mt", "out", "mat", "v", "reg", "cont", "lt", "ft", "sys", "rem", " Ret", "RET", "reset", "re", "det", "try", "ref", "r", "val", "def", "nil", "alt", "txt", "cert", "len", "resp", "gt", "fun", "it", "elt", "status", "rets", "Ret"]}}
{"project": "FFmpeg", "commit_id": "89d4d7d759a59e8535b267b7f5af757f731da712", "target": 1, "func": "static void process_client(AVIOContext *client, const char *in_uri)\n\n{\n\n    AVIOContext *input = NULL;\n\n    uint8_t buf[1024];\n\n    int ret, n, reply_code;\n\n    uint8_t *resource = NULL;\n\n    while ((ret = avio_handshake(client)) > 0) {\n\n        av_opt_get(client, \"resource\", AV_OPT_SEARCH_CHILDREN, &resource);\n\n        // check for strlen(resource) is necessary, because av_opt_get()\n\n        // may return empty string.\n\n        if (resource && strlen(resource))\n\n            break;\n\n\n    }\n\n    if (ret < 0)\n\n        goto end;\n\n    av_log(client, AV_LOG_TRACE, \"resource=%p\\n\", resource);\n\n    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {\n\n        reply_code = 200;\n\n    } else {\n\n        reply_code = AVERROR_HTTP_NOT_FOUND;\n\n    }\n\n    if ((ret = av_opt_set_int(client, \"reply_code\", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        av_log(client, AV_LOG_ERROR, \"Failed to set reply_code: %s.\\n\", av_err2str(ret));\n\n        goto end;\n\n    }\n\n    av_log(client, AV_LOG_TRACE, \"Set reply code to %d\\n\", reply_code);\n\n\n\n    while ((ret = avio_handshake(client)) > 0);\n\n\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    fprintf(stderr, \"Handshake performed.\\n\");\n\n    if (reply_code != 200)\n\n        goto end;\n\n    fprintf(stderr, \"Opening input file.\\n\");\n\n    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {\n\n        av_log(input, AV_LOG_ERROR, \"Failed to open input: %s: %s.\\n\", in_uri,\n\n               av_err2str(ret));\n\n        goto end;\n\n    }\n\n    for(;;) {\n\n        n = avio_read(input, buf, sizeof(buf));\n\n        if (n < 0) {\n\n            if (n == AVERROR_EOF)\n\n                break;\n\n            av_log(input, AV_LOG_ERROR, \"Error reading from input: %s.\\n\",\n\n                   av_err2str(n));\n\n            break;\n\n        }\n\n        avio_write(client, buf, n);\n\n        avio_flush(client);\n\n    }\n\nend:\n\n    fprintf(stderr, \"Flushing client\\n\");\n\n    avio_flush(client);\n\n    fprintf(stderr, \"Closing client\\n\");\n\n    avio_close(client);\n\n    fprintf(stderr, \"Closing input\\n\");\n\n    avio_close(input);\n\n\n}", "idx": 17929, "substitutes": {"client": ["con", "connection", "channel", "server", "tc", "cgi", "window", "ci", "component", "close", "cell", "secure", "qualified", "user", "remote", "handler", "pc", "public", "core", "cl", "util", "config", "application", "out", "web", "session", "cli", "socket", "self", "plugin", "ip", "response", "http", "service", "conn", "manager", "call", "c", "container", "wrapper", "collection", "product", "cmd", "Client", "parent", "template", "batch", "context", "local", "current", "connect", "bound", "request", "cache", "null", "open", "net", "api", "view", "chain", "this"], "in_uri": [" in_url", "inUURI", "in_file", "in_URI", "inUurl", "inPri", "in_iri", "in_ri", "in_url", " in_ui", " in_iri", "inUuri", " in_URI", "inPURI", "in_ui", " in_ri", "inPfile", "inPuri", " in_file", "inUiri"], "input": ["Input", "init", "hidden", "connection", "form", "cgi", "window", "i", "valid", "interface", "stream", "q", "user", "query", " inputs", "output", " context", "config", "initial", "command", "image", "out", "accept", "io", "start", "cli", "read", "reader", "ip", "PUT", "instance", "http", "conn", "cmd", "in", "inner", "local", "batch", "context", "table", "raw", "request", "source", "attribute", "focus", "open", "view", "entry", "rc", "buffer", "from", "import", "exec", "active", "this"], "buf": ["temp", "mem", "cap", "cv", "Buff", "w", "var", "bar", " buffers", "result", "proc", "rw", "bp", "ctx", "text", "fb", "ob", "output", "bag", "cur", "tmp", "fac", " buffer", "alloc", "bc", "out", "mb", "BU", "queue", "db", "v", "bytes", "wb", "iter", "pb", "read", "data", "msg", "cmd", "ref", "batch", "raw", "rb", "txt", "cb", "uf", "resp", " buff", "buffer", "rc", "Buffer", "buff", "b", "seq", "br", "err"], "ret": ["format", "back", "rier", "dt", "report", "rt", "arg", "tree", "inter", "obj", "iter", "sys", "del", "RT", "cert", "net", "rets", "inf", "t", "desc", "result", "ry", "vet", "ber", "ct", "v", "detail", "response", "RET", "reset", "json", "re", "reply", "pt", "try", "ent", "len", "resp", "it", "fun", "ctr", "elt", "status", "proxy", "rm", "nt", "res", "grain", "ne", "live", "tr", "mt", "progress", "ft", "att", "j", "def", "print", "alt", "got", "gt", "deg", "git", "vt", "ll", "out", "cont", "rem", "success", "rev", "cmd", "ext", "ref", "r", "val", "et", "job", "repl", "red", "Ret"], "n": ["na", "np", "nt", "l", "z", "fn", "t", "none", "size", "i", "p", "num", "en", "norm", "cn", "ll", "dn", "ne", "e", "count", "g", "ng", "name", "d", "ns", "ln", "nn", "nor", "nat", "sn", "nb", "c", "nu", "nl", "j", "note", "r", "non", "o", "N", "nan", "number", "nm", "nc", "len", "net", "nr", "no", "an", "b", "y", "m"], "reply_code": ["replyedcod", "replyEcode", "respond_code", "replECode", "replyedcoe", " reply2code", "repl7code", "replyingstatus", "replyednumber", "reply2code", "reply_reason", "repl7last", " reply2cod", "reply7number", "reply7last", "response_codes", "replEcode", "reply_ce", "reply2number", "repl_co", "reply00cont", "respond_class", "reply_last", "repl7co", " reply2cont", "reply_cod", "reply00status", "reply_coded", "reply_coe", "reply_class", "reply_cont", "respond_coded", "reply00reason", "respond_codes", "replyECode", " reply_status", "reply2coe", "replEstatus", "reply7co", "reply_Code", " reply_reason", "reply2status", " reply2status", "response_ce", "repl_cod", "repl_code", "replyEstatus", "replyingcont", "repl7number", " reply_cont", "repl_number", "replyEcod", "replEcod", "response_code", "reply_co", "reply2cont", "reply_number", " reply_number", " reply_cod", "replyedcode", " reply_coe", "reply2reason", "replyingreason", "replyingcode", "repl_Code", "reply_codes", " reply2reason", " reply2coe", " reply2number", "reply2cod", "reply_status", "repl_status", "reply7code", "repl_last", "reply00code"], "resource": ["controller", "feature", "color", "region", "Resource", "page", "local", "context", "space", "attribute", "buffer", "url", "connection", "channel", "use", "server", "memory", "max", "result", "output", "handle", "pointer", "response", "release", "description", "range", "include", "collection", "scope", "directory", "confirmed", "null", "ro", "rest", "res", "location", "question", "comment", "resources", "prefix", "match", "name", "address", "ptr", "instance", "uri", "source", "network", "exclusive", "row", "byte", "process", "window", "component", "remote", "core", "primary", "image", "reference", "folder", "value", "data", "record", "ref", "r", "binary", "message", "member", "key", "sequence", "coord", "share", "this", "file"]}}
{"project": "FFmpeg", "commit_id": "cec939597722663f322941b4c12e00a583e63504", "target": 1, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int16_t (*l1mv1)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[1][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int8_t *l1ref1 = &h->ref_list[1][0].ref_index[1][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n\n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col)\n\n               && (   (l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1)\n\n                   || (l1ref0[0]  < 0 && l1ref1[0] == 0 && ABS(l1mv1[0][0]) <= 1 && ABS(l1mv1[0][1]) <= 1\n\n                       && (h->x264_build>33 || !h->x264_build)))){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n\n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n\n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && (   l1ref0[x8 + y8*h->b8_stride] == 0\n\n                                              || (l1ref0[x8 + y8*h->b8_stride] < 0 && l1ref1[x8 + y8*h->b8_stride] == 0\n\n                                                  && (h->x264_build>33 || !h->x264_build)))){\n\n                    const int16_t (*l1mv)[2]= l1ref0[x8 + y8*h->b8_stride] == 0 ? l1mv0 : l1mv1;\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0] >= 0 ? h->map_col_to_list0[0][l1ref0[0]]\n\n                                                : h->map_col_to_list0[1][l1ref1[0]];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n                const int16_t (*l1mv)[2]= l1mv0;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n\n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                if(ref0 >= 0)\n\n                    ref0 = h->map_col_to_list0[0][ref0];\n\n                else{\n\n                    ref0 = h->map_col_to_list0[1][l1ref1[x8 + y8*h->b8_stride]];\n\n                    l1mv= l1mv1;\n\n                }\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17932, "substitutes": {"h": ["help", "hs", "history", "here", "hh", "oh", "l", "t", "window", "hl", "sh", "kh", "p", "pp", "he", "hz", "th", "bh", "ctx", "hash", "q", "hd", "g", "ht", "rs", "his", "handle", "cc", "ct", "ch", "her", "sw", "v", "hw", "k", "H", "ih", "each", "http", "c", "hm", "hp", "j", "r", "comm", "host", "context", "ph", "dh", "cache", "rh", "ah", "f", "hal", "b", "ssh", "eh", "m"], "mb_type": ["mbricty", "mp_value", "mbetytype", "mp_tag", "mglytype", "mg_type", "mb_name", "mbricTYPE", "mb_Type", "mopetyid", "mg_TYPE", "mbetyType", "emb_type", "mg_test", "mblytype", "mbrictest", "mp_name", "mb_tag", "mglyTYPE", "mop_type", "emb_Type", "mbrictype", "mb_key", "mbetyid", "mb_value", "mblyTYPE", "mb_id", "mop_Type", "emb_ty", "mopetynumber", "mb_number", "mop_number", "mb_TYPE", "mp_type", "mglytest", "mbetynumber", "mb_ty", "mg_ty", "emb_key", "mopetyType", "mopetytype", "mb_test", "mop_id", "mblyty", "mblytest", "mglyty"], "s": ["a", "hs", "ds", "cs", "shared", "os", "l", "t", "w", "i", "sh", "sb", "p", "as", "ins", "changes", "als", "sq", "qs", "is", "bs", "e", "g", "south", "sv", "rs", "gs", "u", "S", "ss", "conv", "sw", "session", "ns", "v", "sts", "ports", "ps", "sys", "http", "js", "ssh", "c", "xs", "styles", "j", "ats", "r", "comm", "n", "fs", "less", "ts", "ims", "ls", "parts", "mods", "an", "stats", "f", "ms", "spec", "sl", "b", "y", "its", "m"], "l1mv0": ["l1mvc1", "l1mv8", "l1mv10", "l1mV10", "l1mV0", "l1mq0", "l1Mv10", "l1Mv1", "l1mV8", "l1mq1", "l1MV8", "l1mvc10", "l1mvc0", "l1MV1", "l1mq8", "l1Mv8", "l1mV1", "l1mvc8", "l1MV10", "l1Mv0", "l1MV0", "l1mq10"], "l1mv1": ["l1mp1", "l1mav1", "l1Mv2", "l1Mv01", "l1mav2", "l1mv01", "l1mV0", "l1mp2", "l1mV2", "l1mp01", "l1Mv1", "l1mav01", "l1MV01", "l1mp0", "l1MV1", "l1MV2", "l1mV1", "l1mv2", "l1Mv0", "l1mav0", "l1MV0", "l1mV01"], "l1ref0": ["l3reference3", "l3reference1", "l1mem0", "l1reference1", "l3ref0", "l3ref3", "l1ref3", "l1rel1", "l3ref1", "l1ref2", "l1rel2", "l1reference0", "l3reference0", "l1reference2", "l1mem2", "l1mem3", "l1rel3", "l1reference3", "l3reference2", "l1rel0", "l1mem1", "l3ref2"], "l1ref1": ["l1cache0", "l1reference1", "l3rel0", "l3rel8", "l3ref8", "l3rel1", "l1cache1", "l3ref0", "l1rel1", "l3ref1", "l1rel8", "l1ref2", "l1ref8", "l1rel2", "l1reference0", "l1reference2", "l1cache8", "l3rel2", "l1reference8", "l1cache2", "l1rel0", "l3ref2"], "sub_mb_type": ["sub_emb2", "sub_emb_", "sub_db_", "sub_mb_Type", "sub_mbogmode", "sub_mbogtypes", "sub_MB_types", "sub_mb_name", "sub_mb2", "sub_mb_types", "sub_mp_", "sub_mbogtype", "sub_mbogType", "sub_mb_", "sub_mb_mode", "sub_MB_mode", "sub_MB_Type", "sub_mp2", "sub_MB_type", "sub_db2", "sub_MB_name"], "i8": ["mi6", "i16", " i6", " i16", " i82", "i82", "mi82", "ii8", "ii16", "ii82", "ii6", "i6", "mi8", "mi16"], "i4": [" i44", "i2", "i44", "I8", " i2", "I44", "I2", "ii8", "ii2", "I4", "ii44", "ii4"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        error_setg(errp, \"Image not in QED format\");\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        /* image uses unsupported feature bits */\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bdrv_get_device_name(bs), \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Round down file size to the last cluster */\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) /\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    /* Header size calculation must not overflow uint32_t */\n\n    if (s->header.header_size > UINT32_MAX / s->header.cluster_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    /* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     */\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* From here on only known autoclear feature bits are valid */\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* If image was not closed cleanly, check consistency */\n\n    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {\n\n        /* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         */\n\n        if (!bdrv_is_read_only(bs->file) &&\n\n            !(flags & BDRV_O_INCOMING)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (ret) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n", "idx": 17953, "substitutes": {"bs": ["bm", "hs", "ds", "cs", "lbs", "os", "boxes", "fps", "outs", "bits", "bles", "BS", "sb", "bb", "ins", "blog", "als", "ses", "ubs", "bh", "bp", "bas", "bps", "is", "rs", "gs", "bc", "aus", "ubis", "ns", "sts", "vs", "pb", "bl", "bos", "ps", "bes", "js", "sys", "es", "ats", "obs", "fs", "bi", "ts", "cb", "ls", "aos", "locks", "asis", "ads", "ms", "b", "bis", "its", "bn"], "options": ["ptions", "ops", "style", "opt", "settings", "details", "option", "vals", "config", "values", "tags", "kw", "Options", "properties", "ption", "keys", "data", "styles", "es", "scope", "fs", "ts", "metadata", "features", "meta", "params", "stats"], "flags": ["fields", "cs", "ds", "args", "flag", "bits", "settings", "vals", "files", "tags", "properties", "ns", "mask", "kind", "ps", "types", "cmd", "fs", "ags", "ts", "features", "FLAG", "ms", "status", "Flags", "mode"], "errp": ["errps", "ierP", " errr", " erp", "errorp", " errpb", "errpb", "errorpp", "errorP", " errpp", "lerr", "derpb", "errr", "lerps", "derp", "rrr", "iersp", "ierpb", "lersp", "rrp", "errpp", " errpid", " erpp", " errps", "ierp", "dersp", "errpid", "rrps", " erpid", "derP", " erP", "errorpid", "errP", "lerp", "rrsp", " errsp", "errsp", " errP"], "s": ["bits", "details", "ess", "results", "ches", "rs", "vs", "self", "sys", "c", "es", "comm", "fs", "sl", "os", "t", "events", "sp", "set", "qs", "S", "ss", "d", "sts", "v", "ps", "sn", "n", "ts", "ls", "parts", "locks", "stats", "bes", "bis", "orders", "a", "ies", "ds", "cs", "sam", "l", "w", "terms", "as", "sb", "ses", "changes", "als", "sv", "sw", "js", "j", "gets", "ssl", "tests", "states", "b", "y", "m", "rates", "hs", "ys", "p", "ins", "ers", "sq", "ions", "aws", "h", "is", "ares", "gs", "ports", "ns", "sports", "ats", "r", "less", "actions", "ims", "ms", "its"], "le_header": [" le_info", "ile_header", "le_peer", "sle_comment", "le_tag", "le_hash", "LE_hash", "le_Header", "leerpeer", "le_____Header", "sle_peer", "le_____header", "LE_header", "le_____hash", "ile_cover", "leckheader", "sle_header", "leckcomment", "le_comment", " le_comment", "leckinfo", "LE_Header", "le_cover", "le_info", "le_layer", "leerheader", "ile_tag", "leerlayer", "leercomment", "sle_layer"], "file_size": ["page_size", " file2name", "page_space", " file_sent", "file9rate", "fileliststart", "ile_message", "fileXscale", "table_offset", "file9size", "file_space", "file9start", "file_negative", "file64count", "table_size", "file64ize", "file_SIZE", " file2sent", "fileListmessage", "file9space", "image_negative", "file_count", " file2size", "file_sent", "image_size", "file_start", "fileXsize", "page_start", "file_scale", "file64SIZE", "file2sent", "ile_speed", "file64size", " file_SIZE", "filelisttotal", "fileXSIZE", "file_name", "image_scale", "ile_size", "fileListspeed", "file2ize", "table_start", "file_speed", "table_total", "fileXnegative", "file_total", "filelistoffset", "fileListsize", "ile_SIZE", " file2ize", "image_SIZE", "file_rate", "file2name", "fileListSIZE", "filelistsize", " file_count", " file_name", "file_ize", " file_ize", "file_message", "page_rate", "file_offset", "file2size"], "ret": ["mel", " RET", "res", "nt", "t", "deg", "flag", "git", "ter", "final", "num", "result", "ll", "Ret", "ry", "end", "last", "rt", "ber", "count", "ben", "fail", "tr", "mt", "out", "reg", "Return", "inter", "cont", "ft", " Ret", "rem", "value", "RET", "rev", "re", "reset", "cmd", "try", "lit", "ref", "val", "rets", "def", "print", "usr", "alt", "x", "len", "jump", "resp", "gt", "fun", "code", "elt", "status", "err"], "buf": ["mem", "cap", "xff", "cv", "Buff", "font", "box", "img", "pad", "tx", "var", "bar", "result", "rw", "h", "text", "ctx", "fb", "vec", "cf", "tmp", " buffer", "queue", "out", "db", "bytes", "doc", "iter", "tab", "data", "msg", "ref", "pool", "raw", "str", "rb", "txt", "cb", "block", "row", "uf", "cp", "buffer", "Buffer", "buff", "b", "seq", "ff", "br", "err"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_8w_msa(src - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 8);\n\n}\n", "idx": 17954, "substitutes": {"dst": ["ddest", "gst", "dbST", " dest", " dST", "gST", "dssrc", "gpt", "dST", "dsest", "Dst", "dsst", "gest", " ddest", "dpt", "dsrc", "Dest", "Dsrc", "Ddest", " dpt", "dsdest", "dbest", " dsrc", "dest", "dbst", "dbpt"], "src": ["loc", "np", "ur", "sl", "dist", "hl", "img", "sb", "desc", "sub", "ins", "st", "input", "sq", "th", "rt", "cur", "usc", "rs", "rin", "lat", "cc", "sec", "start", "ptr", "ipl", "supp", "sys", "sn", "RC", "addr", "in", "ind", "inst", "r", "str", "now", "source", "sr", "s", "rc", "sur", "comp", "ctr", "sc", "b", "dest", "ser", "inc", "rl", "dq"], "stride": ["stringpe", "STRime", "slride", "shrice", "streampe", "sprie", "strade", " strid", "strick", "strice", "sprine", "stringick", "slice", "strie", "trope", "drade", " strride", "slime", "tride", "strine", "drid", "strpe", "slid", " strick", " strides", "shride", "strope", " strie", "STRride", "trie", "STRide", "sprope", "strime", " strope", "stringide", "strid", "streamides", "dride", " strine", "stringides", "spride", " strpe", "slade", "streamick", "drride", "slide", "STRice", "trine", "shrride", " strade", "streamide", "strides", "strride", "shrime"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState *qemu_chr_open_pipe(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    ChardevHostdev *opts = backend->u.pipe;\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_new0(WinCharState, 1);\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename, errp) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 17972, "substitutes": {"id": ["fd", "uid", "pid", "end", "sid", "wid", "iden", "ad", " rid", "kid", " tid", "hid", "ip", "iv", "Id", "aid", "rid", "ids", "oid", "tag", " pid", "uri", "du", "vid", "kill", "ID", " fid", "ident"], "backend": ["bookends", "bookend", "backse", "throughener", "backender", "audse", "Backse", "throughend", "Backends", "backward", "audend", " backward", "backends", " backender", "Backener", "audener", " backends", "Backward", "Backender", "bookward", "backener", "Backend", "audender", "bookender", "throughse", "throughender"], "ret": ["mem", "rm", "res", "nt", "vt", "Ret", "kt", "rt", "mt", "des", "reg", "pet", "RET", "rev", "re", "det", "lit", "ref", "val", "et", "std", "unt", "repl", "txt", "tor", "resp", "rets"], "errp": ["errps", " Errps", " errr", "lerbp", " errping", "lerping", " errbp", "erp", "errr", "lerps", "rrbp", " Errp", "rrping", "rrp", "erps", " errps", "errping", "errbp", "rrps", "lerp", " Errr", "err"], "opts": ["optjs", "opjs", "prete", "prets", "ioptes", "oppTS", "preTS", "iopTS", "opttes", "iopjs", "optts", "opte", "optes", "optTS", " optes", "oppte", "oppts", "opTS", " opTS", " opjs", "opfs", "prefs", "iopts", "oppfs", " opfs", " opte"], "filename": ["fn", "fd", "ame", "w", "p", "username", "Filename", "stem", "original", "fil", "family", "output", "sid", "ames", "til", "ename", "prefix", "files", "kan", "name", "v", "ername", "r", "str", "o", "n", "path", "uri", "fs", "nil", "source", "nm", "txt", "FN", "f", "fp", "src", "title", "river", "file", "pen", "m"], "chr": ["cyl", " chl", " chrb", "schR", "chnran", "ochrt", "schr", "achro", "achr", "cher", "CHdr", "clrc", "ochdr", "cyrb", "chadr", "schrt", " cher", "chereq", "lookresult", "clran", "chel", "Chr", "chear", "echr", "achar", "Cher", "Char", "achrb", "lookr", " chresult", "Chl", "lookadr", " chro", "chrt", "lookl", "chrb", " chR", "cutrc", "echrc", "ochr", "chran", "chedr", "achrator", "schrc", "CHrc", "cutsr", "achdr", "chero", "cutr", "CHrt", "achl", "chnsr", " chdr", "cherrb", "chnadr", "chreq", "chnrc", "clsr", " chrt", " chrator", "chnl", "cheer", "cherreq", "echrt", "chrc", "chresult", "clr", "chnresult", " chadr", " chrc", "acher", "cyr", "echR", "chnr", "cyrator", "ochrc", "chR", "cherb", "chl", "CHr", "chdr", "cherr", "chrator", "achreq", "chro", "cherar", "chsr", "cutran"], "s": ["a", "ds", "cs", "sam", "si", "t", "w", "i", "p", "sb", "as", "ins", "sq", "h", "qs", "is", "e", "g", "sv", "rs", "gs", "S", "ss", "so", "sw", "ns", "v", "socket", "sts", "ps", "sys", "js", "c", "es", "ats", "r", "n", "fs", "space", "source", "ts", "ims", "ls", "sc", "b", "bis", "m"]}}
{"project": "qemu", "commit_id": "7bbcb0afe715c36545bbbd872441c473927c1a4e", "target": 0, "func": "uint32_t HELPER(clz)(uint32_t x)\n\n{\n\n    int count;\n\n    for (count = 32; x; count--)\n\n        x >>= 1;\n\n    return count;\n\n}\n", "idx": 17981, "substitutes": {"x": ["xff", "check", " cx", " error", "z", "t", "zx", "max", "tx", "p", "xt", "rx", "xy", "ctx", "zero", "e", "xa", "xp", " tx", "u", "checked", "ct", "ox", "xf", "v", " xp", "X", "wx", "bit", "xs", "c", "xi", "xx", " xx", "number", "act", " ex", "xe", "fx", "xc", "xes", "ux", " ax", "f", "ix", "ex", "y"], "count": ["check", "index", "nt", "z", "l", "size", "t", "found", "flag", "total", "depth", "max", "cloud", "num", "list", "result", "q", "hash", "err", "h", "ount", " possible", "sum", "hold", "child", "cycle", "length", "match", "ct", "force", "d", "out", "v", "all", "ptr", "cont", "self", "nb", " caught", "c", "ind", "batch", "val", "current", "n", "Count", "act", "C", "number", "state", "cache", "type", "carry", "loop", "code", "ctr", "counter", "col", " c"]}}
{"project": "qemu", "commit_id": "96c9cff0ab986f3a0606e1a96c5b00e6a7c675c6", "target": 0, "func": "static void kvm_get_fallback_smmu_info(PowerPCCPU *cpu,\n\n                                       struct kvm_ppc_smmu_info *info)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    memset(info, 0, sizeof(*info));\n\n\n\n    /* We don't have the new KVM_PPC_GET_SMMU_INFO ioctl, so\n\n     * need to \"guess\" what the supported page sizes are.\n\n     *\n\n     * For that to work we make a few assumptions:\n\n     *\n\n     * - If KVM_CAP_PPC_GET_PVINFO is supported we are running \"PR\"\n\n     *   KVM which only supports 4K and 16M pages, but supports them\n\n     *   regardless of the backing store characteritics. We also don't\n\n     *   support 1T segments.\n\n     *\n\n     *   This is safe as if HV KVM ever supports that capability or PR\n\n     *   KVM grows supports for more page/segment sizes, those versions\n\n     *   will have implemented KVM_CAP_PPC_GET_SMMU_INFO and thus we\n\n     *   will not hit this fallback\n\n     *\n\n     * - Else we are running HV KVM. This means we only support page\n\n     *   sizes that fit in the backing store. Additionally we only\n\n     *   advertize 64K pages if the processor is ARCH 2.06 and we assume\n\n     *   P7 encodings for the SLB and hash table. Here too, we assume\n\n     *   support for any newer processor will mean a kernel that\n\n     *   implements KVM_CAP_PPC_GET_SMMU_INFO and thus doesn't hit\n\n     *   this fallback.\n\n     */\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO)) {\n\n        /* No flags */\n\n        info->flags = 0;\n\n        info->slb_size = 64;\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[0].page_shift = 12;\n\n        info->sps[0].slb_enc = 0;\n\n        info->sps[0].enc[0].page_shift = 12;\n\n        info->sps[0].enc[0].pte_enc = 0;\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[1].page_shift = 24;\n\n        info->sps[1].slb_enc = SLB_VSID_L;\n\n        info->sps[1].enc[0].page_shift = 24;\n\n        info->sps[1].enc[0].pte_enc = 0;\n\n    } else {\n\n        int i = 0;\n\n\n\n        /* HV KVM has backing store size restrictions */\n\n        info->flags = KVM_PPC_PAGE_SIZES_REAL;\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            info->flags |= KVM_PPC_1T_SEGMENTS;\n\n        }\n\n\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->slb_size = 32;\n\n        } else {\n\n            info->slb_size = 64;\n\n        }\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[i].page_shift = 12;\n\n        info->sps[i].slb_enc = 0;\n\n        info->sps[i].enc[0].page_shift = 12;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n        i++;\n\n\n\n        /* 64K on MMU 2.06 and later */\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->sps[i].page_shift = 16;\n\n            info->sps[i].slb_enc = 0x110;\n\n            info->sps[i].enc[0].page_shift = 16;\n\n            info->sps[i].enc[0].pte_enc = 1;\n\n            i++;\n\n        }\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[i].page_shift = 24;\n\n        info->sps[i].slb_enc = SLB_VSID_L;\n\n        info->sps[i].enc[0].page_shift = 24;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n    }\n\n}\n", "idx": 18015, "substitutes": {"cpu": ["mem", "cow", "np", "mac", "nic", "linux", "ck", "p", "pp", "proc", "ork", "hz", "ec", "ctx", "pid", "pc", "gc", "core", "chip", "node", "pu", "aco", "tp", "cc", "alloc", "mu", "hw", "clock", "vm", "sys", "conn", "c", "processor", "gpu", "o", "cu", "upt", "arch", "nc", "anc", "cp", "CPU", "boot", "sc", "phys", "process"], "info": ["iso", "error", "about", "details", "report", "good", "copy", "label", "iter", "obj", "admin", "local", "options", "cache", "buffer", "import", "mem", "check", "index", "inf", "t", "list", "result", "where", "app", "ret", "sum", "lock", "command", "link", "content", "force", "io", "start", "doc", "response", "fee", "description", "json", "update", "try", "summary", "o", "fi", "ro", "entry", "f", "stats", "it", "buff", "show", "event", "status", "version", "err", "init", "help", "w", "comment", "num", "rule", "query", "user", "Info", "ion", "information", "name", "auth", "ip", "http", "time", "warning", "to", "note", "ti", "fo", "def", "dict", "request", "state", "notice", "txt", "edit", "row", "by", "debug", "history", "si", "translation", "config", "op", "reason", "off", "image", "value", "success", "data", "INFO", "id", "ref", "message", "now", "api", "function", "parse", "create", "conf", "trace", "type"], "env": ["enter", "door", "ctx", "e", "exc", "owner", "vs", "obj", "era", "manager", "esp", "priv", "req", "inv", "den", "context", "project", "eu", "ce", "er", "shell", "net", "ench", "ah", "pe", "gen", "serv", "environment", "cv", "here", "server", "desc", "en", "app", "end", "nv", "cur", "v", "ew", "hw", "dev", "forge", "org", "worker", "init", "proc", "query", "enc", "eco", "buf", "ptr", "ef", "operator", "ev", "act", "eve", "network", "kernel", "cp", "next", "con", "eng", "window", "stage", "ec", "equ", "config", "engine", "web", "esc", "ve", "outer", "conn", "cmd", "ext", "et", "nc", "conf", "eh"], "cs": ["hs", "ds", "os", "tc", "ys", "ck", "proc", "ec", "ks", "ctx", "pc", "bs", "cf", "rs", "cc", "ns", "sts", "vs", "ps", "sys", "js", "c", "css", "Cs", "cks", "fs", "acs", "ts", "ls", "cms", "s", "cp", "cus", "CS", "ac", "wcs", "spec", "sc"], "i": ["hi", "li", "e", "I", "ai", "di", "mi", "ji", "exec", "multi", "ii", "index", "ij", "t", "ci", "list", "phi", "v", "cli", "pi", "try", "gi", "bi", "x", "ini", "f", "it", "iu", "status", "init", "ic", "slice", "ei", "me", "impl", " ii", "ip", "iii", " j", "iri", "j", "ti", "C", "ami", "uri", "ix", "y", "m", "si", "im", "ind", "func", "id", "in", "xi", "ui", "batch", "iy", "sim"]}}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n", "idx": 18020, "substitutes": {"shift": ["next", "offset", "index", "pop", "size", "back", "window", "delete", "sh", "pad", "sup", "set", "power", "scale", "move", "count", "shr", "length", "save", "send", "off", "down", "start", "sleep", "ptr", "push", "add", "reset", "align", "Shift", "hift", "pull", "ix", "ctr"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* The memory barrier implicit in atomic_xchg makes sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    if (atomic_xchg(&bh->scheduled, 1) == 0) {\n\n        aio_notify(ctx);\n\n    }\n\n}\n", "idx": 18038, "substitutes": {"bh": ["hs", "bang", "hh", "phy", "sh", "kh", "ish", "bb", "bn", "hz", "h", "bp", "bo", "bs", "bec", "ht", "bsp", "phi", "oth", "bash", "bj", "osh", "hw", "pb", "hab", "ih", "bl", "hub", "hap", "sbm", "ash", "bf", "zh", "dh", "orth", "bt", "rh", "gh", "bol", " inh", "ah", "FH", "hal", "bis", "br", "lb", "hl"], "ctx": ["mem", "cv", "index", "loc", "np", "tc", "nt", "ca", "ck", "kh", "tx", "p", "mc", "timeout", "q", "kt", "unc", "gc", "cl", "buf", "cur", "cf", "tmp", "kb", "jac", "handle", "ct", "bc", "cc", "kw", "co", "ns", "hw", "obj", "wx", "conn", "req", "c", "pkg", "cmd", "func", "msg", "scope", "parent", "jp", "context", "cmp", "cfg", "ctrl", "cm", "dc", "act", "cu", "Context", "cb", "txt", "anc", "nc", "pa", "go", "cp", "ac", "sc"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)\n\n{\n\n    SpiceTimer *timer;\n\n\n\n    timer = qemu_mallocz(sizeof(*timer));\n\n    timer->timer = qemu_new_timer(rt_clock, func, opaque);\n\n    QTAILQ_INSERT_TAIL(&timers, timer, next);\n\n    return timer;\n\n}\n", "idx": 18044, "substitutes": {"func": ["callback", "con", "fn", "tc", "lambda", "apply", "proc", "ctx", "unc", "util", "cf", "Function", "fac", " fun", "cast", "kw", "conv", "attr", "obj", "sys", "data", "c", "inv", "new", "lc", "cond", "job", "act", "fs", "fc", "aux", "cb", "nc", "function", "from", "vol", "f", "ac", "fun", "FC", "b", "task"], "opaque": ["Opaque", "operacity", " oplucent", "opubis", "oplay", " oplay", " opque", "obubis", "obacity", "obaque", "Oplucent", "opaques", "operubis", " opaques", "Opque", "Opaques", "ipaques", "operlay", "oblay", "ipque", "iplucent", " opubis", " opacity", "oplucent", "opacity", "ipaque", "opque", "operaque"], "timer": ["temp", "ramer", "handler", "span", "tree", "tp", "iter", "peer", "manager", "inner", "context", "minute", "ger", "er", "tm", "player", "buffer", " meter", "mem", "tim", "erer", "icker", "memory", "item", "t", "timeout", "result", "ender", "Timer", "mr", "tmp", "pointer", "usr", "env", "ctr", "event", "task", "counter", "worker", "uler", "tc", "ter", "term", "num", "tick", "hr", "actor", "tr", "loader", " tc", "clock", "ptr", "attr", "instance", "offer", "time", "processor", "runner", " td", "txt", "nm", "mint", "taker", "seconds", "rer", "duration", "window", "final", "imer", "vt", "tn", "writer", "thread", "older", "trigger", "outer", "monitor", "new", "table", "cer", "dim", "cb", "meter", "tv", "ser"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->users == 0) {\n\n        ret = kvm_irqchip_add_msi_route(kvm_state, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        irqfd->virq = ret;\n\n    }\n\n    irqfd->users++;\n\n\n\n    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);\n\n    if (ret < 0) {\n\n        if (--irqfd->users == 0) {\n\n            kvm_irqchip_release_virq(kvm_state, irqfd->virq);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);\n\n    return 0;\n\n}\n", "idx": 18067, "substitutes": {"proxy": ["connection", "server", "clone", "linux", "roxy", "phy", "ping", "p", "client", "interface", "remote", "port", "device", "ion", "cas", "native", "profile", "node", "link", "v", "socket", "reference", "Proxy", "ip", "service", "manager", "driver", "target", "wrapper", "gate", "ref", "parent", "module", "pse", "source", "x", "network", "cache", "shadow", "pin", "super", "slave", "version", "bus"], "queue_no": ["que_No", "que_no", "queue_No", "queue2No", "queue2eno", "que_number", "queueingNo", "queueingnumber", "queue08number", "queue08eno", "queueingno", " queue_eno", "queue2number", "queue08No", "queue_eno", " queue_No", "queue08no", "queueingindex", "queue_index", "queue_number", " queue_number", "queue2no", "que_index"], "vector": [" sensor", " mosquito", "vi", "server", "seed", " sequence", "t", " multiplier", "i", "ctors", "Vector", " version", "query", " matrix", "xy", " vectors", "feature", "ther", "normal", "vec", "point", "sv", " index", "v", " vec", "serial", "ve", " template", " Vector", " random", "VID", "manager", " tv", "random", " counter", "ector", "template", "message", "V", "transform", "hello", "sequence", "alias", "token", "iterator", " v", "row", "series", "tv", "version", " dimension", "counter", " serial"], "msg": ["mem", "sg", "p", "q", "gz", "mag", "g", "vec", "conf", "Message", "gs", "node", "command", "reason", "out", "mat", "ch", "v", "get", "Msg", "data", "cmd", "req", "j", "new", "message", "cfg", "essage", "mg", "gp", "state", "y", "txt", "info", " message", "gm", "ms", "event", "phys", "err", "m"], "vq": ["vequeue", "vch", "veq", "svqueue", "vcl", "qp", "vich", "vrqueue", "quqq", "vque", "vrq", "viqueue", "vsq", "svch", " vp", " vch", "svq", "viq", "vp", " vock", "qup", "quq", "veque", "vicl", " vqueue", " vque", "vock", "vrque", "vqq", " vcl", "vrock", "qsq", "qusq", "svcl", " vqq", "vqueue", "veock", " vsq", "qq", "qqq"], "n": ["na", "np", "nt", "fn", "l", "w", "i", "p", "cn", "ne", "nv", "g", "u", "mn", "node", "nw", "d", "ns", "v", "k", "nn", "nor", "sn", "nb", "nu", "c", "nl", "j", "r", "o", "N", "nm", "nc", "an", "nr", "f", "m"], "irqfd": ["irqf", "irqqpid", "irchargedef", "irdqpid", "irqusfc", "iorqden", "virqdf", "iorqpd", "virqfd", "irqusld", "arqfc", "irqtpd", "irchargefc", "irdqflo", "virqdb", "irsqfd", "iroqfd", "virquestfc", "irqud", "iorqtdisk", "irqden", "irqueryfc", "irqusflag", "irqualdisk", "irqqld", "iorqueryfc", "irqualpd", "pirqdd", "irqafd", "irqdf", "irchargeud", "IRqqdb", "iroquefd", "irqadir", "irquld", "arqflag", "IRqfd", "piriqdb", "irquerydef", "irquestfd", "irqqdb", "irqqf", "virquestfd", "virquestdf", "irqflag", "irqueryfd", "irquefd", "iroqueud", "iriqfd", "irchargedisk", "irqqflag", "iorqueryfd", "iorqueryf", "irqqdd", "virqfc", "pirqdb", "irqueflo", "iorqueryfun", "irqadb", "arqqflag", "irqtdisk", "irqdisk", "irqufc", "arqqfd", "irqdir", "irchargefd", "iorqdisk", "irsqdf", "irqqdf", "irquestdb", "irwikf", "irquestdf", "irqusfd", "irqqfun", "iorqfc", "irdqdb", "irqueryud", "IRqflo", "irquestfc", "arqqfc", "irqld", "irqdb", "irquflag", "iorqf", "irqdd", "irqueryf", "iorqfun", "irdqfd", "irwikfun", "irqqfd", "iroquefc", "IRqdb", "irquedef", "irqtfd", "iroqud", "IRqqfd", "irquepid", "irqpd", "iorqtfd", "iroqdef", "iorqtden", "IRqqpid", "irchargepd", "piriqdd", "arqld", "irqadd", "arqqld", "irchargeden", "irqueud", "irquefc", "irqualfd", "irqueryfun", "irqfc", "irqtden", "iroquedef", "irqualden", "iorqfd", "irqqdir", "irquedb", "irqdef", "arqfd", "piriqdir", "irqflo", "IRqpid", "irsqdb", "irwikfc", "iroqfc", "irqqflo", "IRqqflo", "iriqdir", "irqfun", "pirqfd", "piriqfd", "irqqfc", "iriqdb", "pirqdir", "virquestdb", "irqufd", "iorqtpd", "iriqdd", "irsqfc", "irwikfd", "irqpid"], "ret": ["back", "dt", "report", "hash", "rt", "arg", "nz", "mb", "iter", "del", "cert", "rets", "mem", " RET", "t", "flag", "desc", "result", "ry", "end", "vet", "ber", "tf", "RET", "reset", "re", "reply", "try", "len", "resp", "rest", "fun", "elt", "status", "err", "rm", "res", "nt", "pret", "ter", "Ret", "ben", "prop", "tr", "mt", "reg", "ptr", "ft", " Ret", "mber", "det", "att", "def", "print", "alt", "txt", "gt", " alt", "arr", "deg", " retire", "git", "final", "ll", "last", " fut", "out", "dr", "value", "rem", "success", "rev", "ext", "lit", "ref", "val", "reflect", "repl", "red"], "users": [" Users", "userc", "holders", "uploads", "units", "groups", "classes", "members", "resources", "user", "bugs", "items", "parents", "plugins", "Users", "jobs", "files", "lists", "players", "packages", "keys", "docs", "authors", "vers", "videos", "ids", "rows", "headers", "mails", "workers", "masters", "dates", "owners", "people", "devices", "years", "names", "heads", "states", "versions", "modules", "drivers"]}}
{"project": "FFmpeg", "commit_id": "ddd86a2924b9bc67c406cd66ebb1fc8915cd60f7", "target": 1, "func": "static int output_packet(InputStream *ist,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    }\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = transcode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_ostreams; i++) {\n\n        OutputStream *ost = &ost_table[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18077, "substitutes": {"ist": ["isen", "ush", "ess", "st", "dit", "ilst", "istant", "sys", "meet", "art", "rank", "ift", "reat", "ert", "irst", "dd", "ij", "ism", "rust", "dist", "hist", "irm", "iw", "iop", "arde", "hw", "ick", "tip", "ast", "isted", "IST", "pt", "iste", "ict", "estate", "usr", "istar", "pect", "ire", "istor", "ister", "wp", "iana", "ista", "istance", "xt", "ik", "ard", "empt", "ht", "xp", "il", "ith", "iz", "htt", "elist", "igh", "spect", "each", "wikipedia", "att", "exist", "act", "ird", "erd", "ld", "ix", "istically", "ief", "ont", "work", "pop", "ists", "ort", "isi", "store", "iest", "is", "artist", "assert", "supp", "typ", "ind", "ext", "pick", "pir", "inst", "lect", "et", "ust", "isd", "est", "pas", "isting", "its", "alist", "iat"], "ost_table": ["ostetlist", "ostropool", "ortetstack", "ostlaytable", "ortettable", "ort_pool", "ostlaypool", "ost_pool", "ostrolist", "ortetlist", "ostetpool", "ost_stack", "ostetstack", "ortetpool", "ost_list", "ort_stack", "ostrotable", "ostlaystack", "ostettable", "ostlaylist", "ort_table", "ort_list", "ostrostack"], "nb_ostreams": ["nb_oststreamts", "nb_istreamts", "nb_ostsubls", "nb_oststreamls", "nb_istreams", "nb_ostsubts", "nb_iststreams", "nb_iststreamls", "nb_istreamds", "nb_ostsubs", "nb_ostlogls", "nb_iststreamds", "nb_iststreamts", "nb_oststreamds", "nb_ostreamts", "nb_ostlogs", "nb_ostsubds", "nb_ostlogts", "nb_oststreams", "nb_ostreamds", "nb_istreamls", "nb_ostreamls", "nb_ostlogds"], "pkt": ["apkg", "dett", " pdu", "cpdt", "phpacket", "cpkg", "spkt", "apqt", "apmsg", "spett", "vpkg", "ppacket", "patchacket", "cpet", "pdu", "opet", "cpct", "pet", " pmsg", " packet", "opdu", "pwk", "pingvc", "cpwk", "pingct", "pcnt", "pvc", "Packet", " pqt", " pwt", "pingkt", "pmsg", "pcwk", " pwk", "phpkg", "dkt", "dacket", "opkt", "pcacket", "cpdu", " pet", "cpkt", "pett", "dwt", "pkg", "phpkl", "ppwk", "pwt", "patchwt", "respacket", "Pkt", " pct", "Pvc", "ppnt", "ppshot", "Pshot", " pdt", "vpacket", "cacket", "pct", "cct", "spwk", "pqt", "apshot", "spacket", " pkat", "apkt", "cpacket", "opacket", "respct", "paymsg", "Pct", " pkg", "pnt", "payacket", "apdu", "pshot", "pkl", "ckat", "vpkl", "paykt", "ppdu", "pingacket", "apdt", "pckl", "pckg", " pvc", "patchkt", "cpett", " pett", "vpkt", "packet", "patchett", "payqt", "ckt", "pdt", "pckt", "phpkt", "Pdu", "respkt", "apacket", "pkat", "respkat", "ppkt", " pnt"], "i": ["index", "ij", "si", "t", "ci", "im", "p", "g", "I", "mi", "pi", "ind", "id", "j", "xi", "ti", "n", "fi", "bi", "iu", "x", "info", "f", "ix", "b", "ii", "m"], "got_output": ["handledallbool", "gotalloutput", "handledalloutput", "got___output", " got_put", "got_bool", "handled_output", "handledalldigital", "got_write", "gotalldigital", "got_digital", "gotallwrite", "handledallwrite", "gotallbool", "handled_digital", "got___put", "got_put", "got_Output", "handled_write", "handled_bool", " got_Output", "got___Output"], "avpkt": ["avdacket", "avenpchan", "avmcmd", "avpanet", "aveckg", "aveptt", "avectt", "avptt", "craftpacket", "auxnkt", "cappkt", "avcpacket", "avopkt", "avcpvt", "cappnet", "wavpkl", "wavpwk", "avnacket", "avpaacket", "avpkg", "wavpacket", "avpbct", "avnkg", " avcpck", "avipkg", "avnpkl", "avecacket", " avpck", "avnpdu", "craftpdu", "wavnpwk", "avapkl", "avenpacket", "avtpet", "avjpkt", "craftpadu", "avpacket", "avpct", "cappet", "avpdu", "avcacket", "avepkg", "avnpvt", "avnpkt", "avpet", "aveopet", "avenpkt", "avdkt", "avpbkt", "avnpct", "avmkt", "avopkl", "auxnacket", "avwpkl", "avctt", "avtpkt", "avwpet", "avckg", "avepkl", "wavnpacket", "avpcmd", "avckt", "avcpkt", "avtpdt", "avcpct", "avnpdt", "cappacket", "avopcmd", "avpchan", "cappanet", "craftpkt", "avjpkg", "avpvt", "auxnkg", "cappaacket", "avmct", "avnpacket", "avmck", "avpdt", "avopet", "avipkt", "avepacket", "avapkg", "avpakt", "wavpkt", "avjpacket", "avpadt", "avapacket", "cappakt", "avcpck", "avnpwk", "auxpcmd", "avdwk", "aveckt", " avpct", "avepct", "avcpchan", "avpwk", "auxpkt", "wavnpkt", "avpnet", "craftpaacket", "avnpck", "auxpacket", " avcpvt", "avpadu", "avwpkt", "avpbchan", "auxpkg", "avapkt", "aviptt", " avcpkt", "avapwk", "avepcmd", " avcpct", "avtpacket", "craftpdt", "avnkt", "auxncmd", "aveopcmd", "avapcmd", "avpck", "avenpct", "aveopkt", "cappaet", "avdpkl", "avipacket", "avnpchan", "avjptt", "avdpkt", "avwpcmd", "wavnpkl", "avopacket", "avepet", "avmvt", "avtpnet", "avepchan", "avdkl", "craftpakt", "avpaet", "aveopkl", "avmkg", "avmacket", "avdpcmd", "avepkt", "avdpet", "avpbacket", "avtpdu", "avncmd", "craftpadt", " avpvt", "avpkl", "avopnet"], "duration": ["repeat", " loop", "timeout", "result", "ry", "set", "wait", "run", " wait", "done", " begin", "stop", "progress", "time", "val", " resp", "alt", "true", "resp", "no", "rest", "f", " timeout", "begin", "err"]}}
{"project": "FFmpeg", "commit_id": "af2ee6fc4921a81133c0915985e05781505c2ff8", "target": 0, "func": "static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,\n\n                                       SingleChannelElement *sce,\n\n                                       const float lambda)\n\n{\n\n    int q, w, w2, g, start = 0;\n\n    int i, j;\n\n    int idx;\n\n    TrellisPath paths[TRELLIS_STAGES][TRELLIS_STATES];\n\n    int bandaddr[TRELLIS_STAGES];\n\n    int minq;\n\n    float mincost;\n\n    float q0f = FLT_MAX, q1f = 0.0f, qnrgf = 0.0f;\n\n    int q0, q1, qcnt = 0;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        float t = fabsf(sce->coeffs[i]);\n\n        if (t > 0.0f) {\n\n            q0f = FFMIN(q0f, t);\n\n            q1f = FFMAX(q1f, t);\n\n            qnrgf += t*t;\n\n            qcnt++;\n\n        }\n\n    }\n\n\n\n    if (!qcnt) {\n\n        memset(sce->sf_idx, 0, sizeof(sce->sf_idx));\n\n        memset(sce->zeroes, 1, sizeof(sce->zeroes));\n\n        return;\n\n    }\n\n\n\n    //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n    q0 = av_clip_uint8(log2(q0f)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n    q1 = av_clip_uint8(log2(q1f)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n    if (q1 - q0 > 60) {\n\n        int q0low  = q0;\n\n        int q1high = q1;\n\n        //minimum scalefactor index is when maximum nonzero coefficient after quantizing is not clipped\n\n        int qnrg = av_clip_uint8(log2(sqrt(qnrgf/qcnt))*4 - 31 + SCALE_ONE_POS - SCALE_DIV_512);\n\n        q1 = qnrg + 30;\n\n        q0 = qnrg - 30;\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n        if (q0 < q0low) {\n\n            q1 += q0low - q0;\n\n            q0  = q0low;\n\n        } else if (q1 > q1high) {\n\n            q0 -= q1 - q1high;\n\n            q1  = q1high;\n\n        }\n\n    }\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n\n\n    for (i = 0; i < TRELLIS_STATES; i++) {\n\n        paths[0][i].cost    = 0.0f;\n\n        paths[0][i].prev    = -1;\n\n    }\n\n    for (j = 1; j < TRELLIS_STAGES; j++) {\n\n        for (i = 0; i < TRELLIS_STATES; i++) {\n\n            paths[j][i].cost    = INFINITY;\n\n            paths[j][i].prev    = -2;\n\n        }\n\n    }\n\n    idx = 1;\n\n    abs_pow34_v(s->scoefs, sce->coeffs, 1024);\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {\n\n        start = w*128;\n\n        for (g = 0; g < sce->ics.num_swb; g++) {\n\n            const float *coefs = sce->coeffs + start;\n\n            float qmin, qmax;\n\n            int nz = 0;\n\n\n\n            bandaddr[idx] = w * 16 + g;\n\n            qmin = INT_MAX;\n\n            qmax = 0.0f;\n\n            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                if (band->energy <= band->threshold || band->threshold == 0.0f) {\n\n                    sce->zeroes[(w+w2)*16+g] = 1;\n\n                    continue;\n\n                }\n\n                sce->zeroes[(w+w2)*16+g] = 0;\n\n                nz = 1;\n\n                for (i = 0; i < sce->ics.swb_sizes[g]; i++) {\n\n                    float t = fabsf(coefs[w2*128+i]);\n\n                    if (t > 0.0f)\n\n                        qmin = FFMIN(qmin, t);\n\n                    qmax = FFMAX(qmax, t);\n\n                }\n\n            }\n\n            if (nz) {\n\n                int minscale, maxscale;\n\n                float minrd = INFINITY;\n\n                //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n                minscale = av_clip_uint8(log2(qmin)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n                maxscale = av_clip_uint8(log2(qmax)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                minscale = av_clip(minscale - q0, 0, TRELLIS_STATES - 1);\n\n                maxscale = av_clip(maxscale - q0, 0, TRELLIS_STATES);\n\n                for (q = minscale; q < maxscale; q++) {\n\n                    float dist = 0;\n\n                    int cb = find_min_book(sce->sf_idx[w*16+g], sce->ics.group_len[w], sce->ics.swb_sizes[g], s->scoefs+start);\n\n                    for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                        FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                        dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],\n\n                                                            q + q0, cb, lambda / band->threshold, INFINITY, NULL);\n\n                    }\n\n                    minrd = FFMIN(minrd, dist);\n\n\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + dist\n\n                               + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                for (q = 0; q < q1 - q0; q++) {\n\n                    if (!isinf(paths[idx - 1][q].cost)) {\n\n                        paths[idx][q].cost = paths[idx - 1][q].cost + 1;\n\n                        paths[idx][q].prev = q;\n\n                        continue;\n\n                    }\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            sce->zeroes[w*16+g] = !nz;\n\n            start += sce->ics.swb_sizes[g];\n\n            idx++;\n\n        }\n\n    }\n\n    idx--;\n\n    mincost = paths[idx][0].cost;\n\n    minq    = 0;\n\n    for (i = 1; i < TRELLIS_STATES; i++) {\n\n        if (paths[idx][i].cost < mincost) {\n\n            mincost = paths[idx][i].cost;\n\n            minq = i;\n\n        }\n\n    }\n\n    while (idx) {\n\n        sce->sf_idx[bandaddr[idx]] = minq + q0;\n\n        minq = paths[idx][minq].prev;\n\n        idx--;\n\n    }\n\n    //set the same quantizers inside window groups\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])\n\n        for (g = 0;  g < sce->ics.num_swb; g++)\n\n            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)\n\n                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];\n\n}\n", "idx": 18095, "substitutes": {"avctx": ["avsc", " avsc", " avcp", "avcp", "AVctx", "aversc", "AVsc", "AVcontext", "avercontext", " avcontext", "averctx", "AVcp", "avercp", "avcontext"], "s": ["a", "ds", "cs", "os", "sg", "p", "sb", "sq", "h", "is", "e", "rs", "gs", "S", "ss", "v", "ns", "ps", "js", "c", "es", "ats", "fs", "m"], "sce": ["Sce", "cced", "nsced", "oscer", "desced", "Sced", "osced", "sced", "sck", " sCE", "jsse", " ske", "esce", "nsce", "sse", "jsces", "Ske", " sces", "oscle", "secent", "desce", "sCE", "jsce", "asce", "jsCE", "scing", "cce", " sced", "psced", "secing", " sse", "desces", "asced", "sece", "Sces", "statsced", "scent", "aspe", "pscle", "ske", "csce", "csck", "escent", "psce", "cpe", "Sse", "seck", "sces", "statsce", "cces", "scle", "osce", "nspe", "scer", "cscing", "statscle", "esck", "SCE", "spe", "statscer", "pscer", "nske", "cscent", "escing", "Spe", "despe", "aske", " spe"], "lambda": [" lam", " dw", " func", "ta", " dx", "beta", " delta", " gamma", " alpha", " df", " mu", "igma", "phi", "xf", "mu", "da", " bandwidth", " beta", "pha", " formula", "bf", "appa", "weights", " omega", "alpha", "function", " foo", " sig"], "q": ["ue", "z", "t", "qu", "p", "qi", "sq", "query", "ql", "e", "u", "m", "iq", "v", "ig", "mp", "c", "Q", "aq", "qa", "qt", "f", "ix", "qq", "dq"], "w": ["z", "wp", "window", "weight", "p", "rw", "h", "win", "wl", "wt", "nw", "kw", "v", "wa", "wb", "wx", "wd", "r", "wi", "W", "n", "x", "fw", "m"], "w2": ["width3", "w3", "width2", " w02", "v02", "width4", "w02", "width02", "v4", "w4", "v2", " w3", " w4", "v3"], "g": ["ga", "p", "gz", "ge", "gc", "gs", "G", "group", "bg", "pg", "gain", "v", "msg", "c", "gg", "gi", "mg", "n", "gp", "tg", "go", "gm", "gt", "gen", "b", "m"], "i": ["ic", "index", "ij", "l", "si", "z", "ci", "im", "p", "ei", "ki", "me", "h", "li", "is", "\u0438", "ri", "e", "I", "u", "ai", "phi", "name", "v", "di", "cli", "ip", "counter", "mi", "pi", "c", "in", "id", "oi", "xi", "ti", "ui", "gi", "o", "print", "ji", "multi", "bi", "iu", "x", "info", "asi", "zi", "ini", "sim", "chain", "it", "ix", "ex", "b", "status", "ii", "m"], "j": ["pos", "index", "jj", "ij", "z", "l", "p", "uj", "J", "v", "k", "jl", "js", "c", "r", "jp", "n", "ji", "o", "aj", "bi", "jump", "b", "ii", "m"], "idx": ["midi", "idexs", " idxs", "idi", "idez", "midx", "midxs", "idxs", "idz", "idex", " idz", "idei", " idi", "midz"], "paths": ["dirids", "systemss", "pathss", "threadids", "pathids", "systemds", "dirds", "threadds", "dirs", "threads", "systemids", "systems", "pathds", "threadss", "dirss"], "TRELLIS_STAGES": ["TRELLIS_INSTATES", "TRELLIS_CAGE", "TRELLIS_StATES", "TRELLIS_Stages", "TRELLIS_INSTages", "TRELLIS_STATES", "TRELLIS_StAGE", "TRELLIS_stATES", "TRELLIS_Cages", "TRELLIS_StAGES", "TRELLIS_CATES", "TRELLIS_INSTAGES", "TRELLIS_stAGE", "TRELLIS_STAGE", "TRELLIS_STARS", "TRELLIS_CAGES", "TRELLIS_stAGES", "TRELLIS_INSTAGE", "TRELLIS_CARS", "TRELLIS_StARS", "TRELLIS_stARS", "TRELLIS_STages"], "bandaddr": ["baddr", "bindaddress", "bindaddr", "bindoffset", "bindAddress", "Bandoffset", "Bandaddress", "baddress", "boffset", "bAddress", "Bandaddr", "BandAddress", "bandoffset", "bandAddress", "bandaddress"], "minq": ["maxf", " minf", "maxq", " minqt", "minimumq", "minimumQ", "minimumqt", "minqt", " minQ", "maxqt", "maxQ", "minf", "minimumf", "minQ"], "mincost": [" minst", "modst", "minimumr", "minst", "modr", "minimumcost", "minCost", " minCost", "minimumCost", "minr", "modCost", "minimumst", " minr", "modcost"], "q0": ["dq5", "q4", "iq4", "qk", "qor", "qu4", " qor", "Q2", "lock0", "lock00", "q10", "sq1", "iq0", "requ4", "quor", "sq00", "dq00", "iq1", "queryzero", "dqor", "qu5", " q2", "Q1", " qzero", "query10", "quarg", "requ00", "quest0", "sq4", "qzero", " q00", "qeu", "qi1", "qieu", "dq4", "dqeu", "requ1", "queu", "q5", "dq2", "iqzero", "Q0", "dq10", "lock1", "sq0", "qu1", "quest00", "qq1", "qu2", " q10", "qu00", "sqarg", "q00", "quk", "Qk", "dqzero", "qq0", "questzero", "dqarg", "quzero", "dq1", "qi0", "query00", "qqk", "q2", "sq5", "qi00", "requ0", "dq0", "qu10", "qu0", "qq2", "qarg", "lock10", "query0", "quest10"], "q1": ["iqr", " q2", "dq2", "qur", " qOne", "qone", "qq0", "q4", "iq2", "q01", "qr", "qOne", "dq11", "iqone", "quone", "qu4", "dq1", "qqone", "quest4", "qu1", "quOne", "dq3", "dqOne", "qq3", "qq1", "quest0", "q3", "iq0", "qu2", "q2", "qu01", "quest01", " qone", "qq11", "dq01", "dqone", "quest11", "dqr", "dq4", "dq0", "qu0", " q11", "qq2", "qu3", " q4", " q3", "q11", "qu11", "iq1", "questone", "iqOne", "quest1"], "qcnt": ["qncct", "qrctr", "qcNT", "thinkccount", "nncnt", "ncnt", "qncount", "qcpt", " qncnt", "eqnpt", "qcrnt", "qnount", "quncnt", "nncct", "quncct", "eqcount", "eqnount", "qnccount", "thinknccount", "eqnrowd", "qcountount", "qcctr", "qcount", "thinkncctr", "qcrct", "nncount", "qcrcount", "thinkcct", "thinkncct", "qcountpt", "qrnt", "qCount", " qncount", "qlcnt", "qcountrowd", "eqcnt", "qrct", "qcountNT", "qcrctr", "thinkncnt", "qlcrowd", "qcct", "eqnnt", " qcount", "ncct", "qccount", " qcnc", "quncount", "qrcount", "qrcnc", "qcountnt", "nncnc", "eqcrowd", "qrcnt", "ncount", "thinkcctr", "qCnc", "qCNT", "eqcpt", "qnpt", "qlcpt", "qncctr", "qncnt", " qncnc", "qcrowd", "ncnc", "thinkcnt", "qlcount", "qncNT", "qCnt", "qcountnc", "qncnc", "qcnc", " qcNT", "qnrowd", "qrcct", "quncnc", "qnnt", " qncNT"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)\n\n{\n\n    int ret = -EIO;\n\n\n\n    /* Add footer to total size */\n\n    total_size += 512;\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n    if (lseek(fd, -512, SEEK_END) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 18138, "substitutes": {"fd": ["ctl", "fed", "ds", "fn", "form", "lf", "pid", "handler", "unc", "fb", " df", "hd", "fr", "dl", "dat", "handle", "ad", "d", "db", "fin", "ln", "fat", "da", "ptr", "wd", "sd", "rd", "ino", "ff", "dir", "ind", "dev", "ud", "cond", " td", "fa", "sta", "bf", "fi", "df", "fc", "fs", "fm", "cod", "FD", " ff", "ld", "f", "dra", " fid", "fp", "ed", "elt", "dd", "fl"], "buf": ["cap", "cv", "Buff", "w", "p", "bb", "bar", "fb", "bag", "vec", "map", "tmp", "queue", "bc", "kw", "v", "bytes", "pb", "wb", "doc", "tab", "data", "cmd", "pkg", "msg", "ref", "raw", "pack", "bf", "rb", "orig", "txt", "cb", "block", "uf", "buffer", "Buffer", "buff", "b", "seq", "err"], "total_size": ["totalJsize", "total_SIZE", "totalJcount", "totalTimetype", "Total_Size", "totalTimeSIZE", "totalJSIZE", "total_count", "total_Size", "total_type", "totalJmem", " total_type", "Total_size", "totalTimesize", " total_count", "Total_SIZE", " total_mem", " total_SIZE", "total_mem"]}}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n", "idx": 18142, "substitutes": {"ctx": ["mem", " cx", "tc", "ca", "px", "tx", "unc", "setup", " context", "tmp", "handle", "bc", "cc", "ct", "kw", "obj", "wd", "conn", "xs", "pkg", "cmd", "context", "cmp", "fc", "Context", "cb", "anc", "fx", "xc"], "fs": ["hs", "ds", "cs", "fd", "os", "fps", "tx", "sf", "bs", "cf", "rs", "gs", "files", "irs", "FS", "ns", "vs", "ps", "sys", "Fs", "obs", "bf", "df", "fc", "less", "ts", "ims", "ls", "fx", "fw", "cms", "s", "f", "ms", "file"], "entry": ["index", "form", "item", "desc", "cell", "ry", "command", "match", "image", "inter", "ptr", "se", "obj", "instance", "ident", "Entry", "data", "ind", "ror", "try", "record", "def", "rent", "key", "ent", "attribute", "row", "ary", "cue", "ie", "import", "search", "quick", "spec", "event", "file"], "result": ["res", "Result", "comment", "valid", "desc", "final", "report", "test", "results", "end", "ret", "buf", "cur", "profile", "tr", "out", "response", "success", "description", "data", "json", "page", "dir", "record", "r", "new", "join", "table", "complete", "true", "cache", "block", "row", "su", "nr", "buffer", "event"]}}
{"project": "qemu", "commit_id": "368d25881c94f9e09ef19a3d93e8fec797dbcd05", "target": 0, "func": "static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n\n                                        int w, int h)\n\n{\n\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n\n    size_t bytes;\n\n    int zywrle_level;\n\n\n\n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n\n        if (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) {\n\n            zywrle_level = 0;\n\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n\n        } else if (vs->tight.quality < 3) {\n\n            zywrle_level = 3;\n\n        } else if (vs->tight.quality < 6) {\n\n            zywrle_level = 2;\n\n        } else {\n\n            zywrle_level = 1;\n\n        }\n\n    } else {\n\n        zywrle_level = 0;\n\n    }\n\n\n\n    vnc_zrle_start(vs);\n\n\n\n    switch(vs->clientds.pf.bytes_per_pixel) {\n\n    case 1:\n\n        zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n\n        break;\n\n\n\n    case 2:\n\n        if (vs->clientds.pf.gmax > 0x1F) {\n\n            if (be) {\n\n                zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 4:\n\n    {\n\n        bool fits_in_ls3bytes;\n\n        bool fits_in_ms3bytes;\n\n\n\n        fits_in_ls3bytes =\n\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n\n\n\n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n\n                            vs->clientds.pf.gshift > 7 &&\n\n                            vs->clientds.pf.bshift > 7);\n\n\n\n        if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n\n            if (be) {\n\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n\n          }\n\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n\n            if (be) {\n\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n    }\n\n    break;\n\n    }\n\n\n\n    vnc_zrle_stop(vs);\n\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n\n    vnc_write_u32(vs, bytes);\n\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n\n    return 1;\n\n}\n", "idx": 18150, "substitutes": {"vs": ["vi", "nets", "bits", "details", "ks", "vals", "caps", "rs", "vp", "pages", "sys", "ants", "inv", "es", "iffs", "fs", "verts", "names", "os", "boxes", "ops", "events", "bys", "otes", "tops", "qs", "asts", "lights", "vc", "ss", "sts", "v", "ps", "xs", "styles", "obs", "ts", "Vs", "ls", "aunts", "vr", "stats", "ues", "bes", "ies", "ds", "cs", "ov", "terms", "ils", "changes", "lines", "ves", "sv", "grades", "blogs", "uv", "docs", "js", "vers", "videos", "VS", "orts", "vd", "atts", "lbs", "fps", "ists", "ins", "vt", "pps", "posts", "bs", "gs", "values", "lists", "ports", "ns", "cells", "vm", "helps", "eps", "views", "ires", "ims", "vv", "ms", "its"], "x": ["patch", "ic", "l", "el", "px", "lex", "ax", "i", "p", "tx", "mm", "xt", "rx", "at", "ry", "xy", "on", "ctx", "xp", "op", "ct", "ox", "v", "X", "wx", "ip", "any", "xs", "c", "mx", "pt", "att", "xi", "xd", "yx", "xx", "act", "xml", "fx", "xc", "dx", "it", "ix", "ex", "col", "m"], "y": ["ies", "ic", "z", "ys", "i", "p", "xy", "ry", "axy", "sy", "ey", "ym", "hy", "py", "ot", "v", "obj", "ay", "sys", "ya", "asy", "icy", "ye", "my", "yy", "c", "any", "try", "vy", "entity", "j", "gy", "wy", "uy", "o", "iny", "ery", "ny", "yt", "iy", "by", "Y", "oy", "ia", "yl", "b", "cy", "col"], "w": ["rew", "z", "wp", "weight", "window", "max", "p", "mm", "as", "ow", "rw", "we", "win", "q", "iw", "aw", "wid", "press", "wl", "wt", "nw", "kw", "sw", "wr", "d", "ew", "wa", "wb", "hw", "wx", "wd", "up", "wh", "ww", "wi", "W", "str", "wn", "wal", "ex", "m"], "h": ["hs", "history", "hh", "oh", "z", "hl", "hi", "sh", "kh", "p", "ish", "as", "he", "hz", "th", "bh", "q", "ha", "hash", "hr", "html", "change", "hd", "ht", "ch", "v", "hw", "k", "H", "ih", "c", "height", "wh", "high", "ph", "hei", "rh", "ah", "it", " H", "hal", "b", "eh", "m"], "bytes": ["ies", "ds", "cs", "size", "args", "bits", "Bytes", "frames", "words", "bs", "gs", "ips", "amps", "ns", "io", "ables", "gb", "rees", "tes", "rows", "ints", "ls", "amples", "ms", "iles", "byte", "seconds"], "zywrle_level": ["zywrle_low", "zywrole_vel", "zywrple_type", "zywrnemyerror", "zywrly00depth", "zywrle33level", "zywrle_limit", "zywrnemystream", "zywrse_info", "zywrle_Level", "zywrnemylevel", "zywrlemyerror", "zywrle_layer", "zywrlemmlevels", "zywrle_stream", "zywrlemylevel", "zywrle55stream", "zywrler_levels", "zywrler_level", "zywrple_level", "zywrle_type", "zywrle_info", "zywrly_value", "zywrle_message", "zywrle_vel", "zywrle2label", "zywrple_lvl", "zywrly00value", "zywrle2limit", "zywrLE_levels", "zywrse_field", "zywrole_level", "zywrple_message", "zywrle_mode", "zywrlemylevels", "zywrLE_val", "zywrle2vel", "zywrle_error", "zywrne_error", "zywrle_quality", "zywrnemylevels", "zywrse_Level", "zywrole_levels", "zywrple_levels", "zywrLE_quality", "zywrler_layer", "zywrle_depth", "zywrne_level", "zywrple_mode", "zywrle55error", "zywrlemmlvl", "zywrse_level", "zywrle55level", "zywrole_label", "zywrne_levels", "zywrle00level", "zywrse_limit", "zywrle00depth", "zywrle33low", "zywrne_stream", "zywrle_levels", "zywrle_field", "zywrle33levels", "zywrple_limit", "zywrly_level", "zywrle_val", "zywrLE_level", "zywrle_label", "zywrle2Level", "zywrlemystream", "zywrle_value", "zywrle00value", "zywrole_low", "zywrle_lvl", "zywrle2level", "zywrle55levels", "zywrly00level", "zywrle2levels", "zywrlemmlevel", "zywrse_levels", "zywrler_lvl", "zywrlemmmessage", "zywrly_depth"], "fits_in_ls3bytes": ["fits_in_LS2byte", "fits_in_ls4byte", "fits_in_ls30bits", "fits_in_LS3byte", "fits_in_ls30Bytes", "fits_in_ls3byte", "fits_in_ls4bytes", "fits_in_ls30bytes", "fits_in_ls30byte", "fits_in_LS3bits", "fits_in_LS2bytes", "fits_in_ls2bytes", "fits_in_LS3bytes", "fits_in_ls2bits", "fits_in_ls6bytes", "fits_in_ls2byte", "fits_in_LS3tes", "fits_in_ls6byte", "fits_in_LS2tes", "fits_in_ls6bits", "fits_in_ls2Bytes", "fits_in_LS2bits", "fits_in_ls2tes", "fits_in_ls3Bytes", "fits_in_ls4tes", "fits_in_ls6Bytes", "fits_in_ls3bits", "fits_in_ls3tes", "fits_in_LS2Bytes", "fits_in_LS3Bytes", "fits_in_ls4Bytes"], "fits_in_ms3bytes": ["fits_in_msdBytes", "fits_in_ms3Bytes", "fits_in_ms1Bytes", "fits_in_ms2Bytes", "fits_in_ls3byte", "fits_in_ms3tes", "fits_in_ls2bytes", "fits_in_ms1tes", "fits_in_ms2tes", "fits_in_ls2byte", "fits_in_ms2byte", "fits_in_ms1byte", "fits_in_msdbytes", "fits_in_msdbyte", "fits_in_ls2Bytes", "fits_in_ms2bytes", "fits_in_ms1bytes", "fits_in_msdtes", "fits_in_ls2tes", "fits_in_ls3Bytes", "fits_in_ms3byte", "fits_in_ls3tes"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n    MMIOState *s= opaque;\n\n    return ide_status_read(&s->bus, 0);\n\n}\n", "idx": 18159, "substitutes": {"opaque": ["Opatile", "opsplex", "Opaque", "opplex", " opatile", "catatile", "opaques", "opatile", " opaques", "cataque", "opsaque", "Opaques", "opsaques", " open", "pplex", " opplex", "paque", "open", "Open", "patile", "paques", "cataques", "caten", "opsatile"], "addr": ["eth", "var", "hash", "ha", "kt", "ctx", "adr", "map", "handle", "alloc", "name", "address", "mt", "ad", "db", "start", "ptr", "dr", "attr", "add", "id", "ref", "coord", "dh", "info", "src", "ix", "br"], "size": [" length", "offset", "mem", "args", "h", "sum", "count", "load", "command", "length", "send", "name", "address", "serial", "fee", "data", "ize", "id", "message", "n", "number", "Size", "SIZE", "len", "params", "type"], "s": ["a", "hs", "ds", "os", "t", "i", "p", "sb", "ess", "als", "sq", "h", "sm", "is", "bs", "sv", "rs", "gs", "S", "ss", "sts", "ns", "se", "ps", "spec", "c", "j", "es", "r", "o", "n", "fs", "sol", "less", "ts", "ls", "stats", "sis", "sl", "b", "m"]}}
{"project": "qemu", "commit_id": "e37e6ee6e100ebc355b4a48ae9a7802b38b8dac0", "target": 0, "func": "void tlb_flush_page(CPUState *env, target_ulong addr)\n\n{\n\n    int i;\n\n\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_flush_page: \" TARGET_FMT_lx \"\\n\", addr);\n\n#endif\n\n    /* must reset current TB so that interrupts cannot modify the\n\n       links while we are modifying them */\n\n    env->current_tb = NULL;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    tlb_flush_entry(&env->tlb_table[0][i], addr);\n\n    tlb_flush_entry(&env->tlb_table[1][i], addr);\n\n#if (NB_MMU_MODES >= 3)\n\n    tlb_flush_entry(&env->tlb_table[2][i], addr);\n\n#if (NB_MMU_MODES == 4)\n\n    tlb_flush_entry(&env->tlb_table[3][i], addr);\n\n#endif\n\n#endif\n\n\n\n    tlb_flush_jmp_cache(env, addr);\n\n\n\n#ifdef USE_KQEMU\n\n    if (env->kqemu_enabled) {\n\n        kqemu_flush_page(env, addr);\n\n    }\n\n#endif\n\n}\n", "idx": 18161, "substitutes": {"env": ["export", "enter", "ctx", "e", "te", "vp", "vs", "obj", "gear", "ee", "manager", "esp", "req", "inv", "context", "er", "shell", "net", "ah", "spec", "Environment", "environment", "cv", "here", "server", "desc", "var", "en", "end", "nv", "v", "ew", "hw", "msg", "pkg", "dev", "forge", "view", "code", "org", "event", "stack", "worker", "ov", "console", "w", "expr", "esm", "buf", "sv", "cycle", "node", "queue", "sw", "ef", " environment", "ev", "erd", "viron", "network", "info", "kernel", "eve", "ten", "eng", "window", "vt", "ec", "equ", "config", "engine", "her", "esc", "vm", "ve", "outer", "conn", "cmd", "ext", "nc", "vv", "eh"], "addr": ["loc", "mac", "size", "pad", "tx", "hash", "ctx", "ace", "point", "rs", "rr", "lat", "ad", "inter", "iter", "inv", "host", "lr", "hl", "offset", "mem", "eth", "index", "np", " dst", "adj", "ha", "link", "handle", "hw", "add", "msg", "pkg", "x", "ack", "oa", "Address", "len", "elt", "err", "a", "res", "ord", "ar", "expr", "adr", "mt", "alloc", " address", "address", "ptr", "attr", "ip", "nl", "ash", "act", "alt", "block", "go", "rc", "arp", "gate", "hop", "pos", "work", "p", "store", "asm", "at", "gc", "off", "dr", "cmd", "ref", "r", "now", "pas", "coord", "src"], "i": ["ic", "index", "ij", "l", "si", "res", "t", "imm", "ci", "hi", "p", "ei", "ki", "qi", "err", "li", "is", "ri", "I", " ii", " l", "ai", "phi", "ori", "v", "di", "cli", "io", "k", "ip", "mi", "pi", "ind", " j", "id", "j", "xi", "ti", "ui", "gi", "ami", "fi", "uri", "multi", "bi", "iu", "x", "iy", "info", " ni", " m", " v", "zi", "ini", "it", "ix", "b", "y", "ii", "m"]}}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "void ff_slice_thread_free(AVCodecContext *avctx)\n\n{\n\n    ThreadContext *c = avctx->thread_opaque;\n\n    int i;\n\n\n\n    pthread_mutex_lock(&c->current_job_lock);\n\n    c->done = 1;\n\n    pthread_cond_broadcast(&c->current_job_cond);\n\n    pthread_mutex_unlock(&c->current_job_lock);\n\n\n\n    for (i=0; i<avctx->thread_count; i++)\n\n         pthread_join(c->workers[i], NULL);\n\n\n\n    pthread_mutex_destroy(&c->current_job_lock);\n\n    pthread_cond_destroy(&c->current_job_cond);\n\n    pthread_cond_destroy(&c->last_job_cond);\n\n    av_free(c->workers);\n\n    av_freep(&avctx->thread_opaque);\n\n}\n", "idx": 18171, "substitutes": {"avctx": ["avecontext", "AVctx", "avgc", " avcontext", "wavgc", "ivercontext", "AVkit", "wavpkg", "wavctx", "avehistory", "avhistory", " avgc", "avegc", "avecf", "AVcontext", "iverhistory", "avepkg", " avcf", "avjac", "avcontext", "averjp", "aytx", "ayctx", " avtx", " avjp", "iverctx", "aykit", "wavhistory", "avkit", " avpkg", "avcf", "averctx", " avkit", "avpkg", "wavcontext", "avectx", "AVtx", "avejac", "wavjac", "avjp", "avtx", "avercf", "iverjac", "avejp", "avercontext", "aycontext"], "c": ["a", "con", "cv", "cs", "l", "tc", "ca", "ci", "oc", "p", "mc", "ec", "enc", "h", "ctx", "err", "pc", "gc", "cl", "g", "cam", "cf", "config", "u", "vc", "bc", "cc", "ct", "content", "co", "etc", "v", "cor", "call", "container", "cr", "comm", "lc", "cm", "dc", "C", "coll", "fc", "ce", "cu", "cache", "cb", "anc", "xc", "com", "cp", "abc", "ac", "f", "chain", "rc", "sc", "b", "conf", "col", "m"], "i": ["ic", "index", "ij", "si", "t", "ci", "im", "p", "ei", "ki", "qi", " ti", "me", "ski", "li", "is", "span", "\u0438", "ri", "g", "point", "I", " ii", "ai", "phi", "v", "di", "ip", "mi", "pi", "ind", "oi", "in", "j", "xi", "ti", "batch", "ui", "gi", "n", "print", "ji", "multi", "uri", "key", "fi", "bi", "x", "ims", "asi", "zi", "sim", "ini", "gu", "ms", "ix", "it", "us", "iu", "y", "ii", "m"]}}
{"project": "FFmpeg", "commit_id": "e5dd4ae7284bb290d8dc8e9cd3f2e035d1d77cd0", "target": 1, "func": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 18175, "substitutes": {"avctx": ["AVctx", "ajtx", " avcontext", "wavctx", "AVcfg", " avcfg", "wavcmp", "AVcontext", "avcontext", "avcfg", "avcmp", "ajctx", " avtx", "AVcmp", "wavtx", "ajcontext", "wavcontext", "AVtx", "ajcfg", "avtx", " avcmp"], "data": ["next", "offset", "pos", "rew", "res", "t", "window", "pad", "p", "stream", "win", "end", "device", "action", "buf", "fr", "empty", "dat", "ata", "padding", "prefix", "done", "name", "image", "address", "d", "DATA", "ad", "bytes", "start", "pointer", "Data", "area", "value", "to", "id", "r", "trans", "message", "table", "raw", "str", "extra", "key", "block", " DATA", "row", "buffer", "src", "text", "file", "m"], "got_sub_ptr": ["got_ubvalreq", "got_subvalptr", "got_sub__ptr", "got_ub_pt", "got_sub_pos", "got_sub__pos", "got_sub_req", "got_subvaladdr", "got_sub2pos", "got_sub2ptr", "got_subvalpt", "got_ub_addr", "got_ubvalpt", "got_sel_addr", "got_sub__addr", "got_sub_addr", "got_sub2req", "got_sel_pos", "got_ub_req", "got_sel_ptr", "got_sub2addr", "got_sub__tr", "got_ub_ptr", "got_sub_tr", "got_sub2pt", "got_ubvalptr", "got_subvalreq", "got_sub_pt", "got_sel_tr", "got_ubvaladdr", "got_sub2tr"], "avpkt": ["avjpdu", "avpqt", "avepconn", " avPacket", "avpodkt", "avPkg", " avpdu", "evpkg", "aveppmsg", "avcpbuf", "evppkg", "avpodkat", "avppdu", "avpodmsg", " avcpdu", "avpkg", "avjpmsg", "avewpvc", "avpackkg", "avwpacket", "evpacket", "avPcmd", "avewpacket", "avPct", "avpconn", "avpodconn", "avppconn", "aveppkat", "avepkat", "avpvc", "avjpkt", "avpacket", "avpct", "avewpkt", "avpdu", "avcacket", " avpcmd", "avjpct", "avnpkt", "avPkt", "avwpct", "avjpvc", "avpackqt", "evppqt", "avckg", "avpkat", "avpcmd", "avckt", "avnpkg", "avcpkt", "avcpmsg", "evpkt", "avpmsg", "avnpacket", "avepacket", " avpmsg", "avjpacket", " avPkg", "avPvc", "avwpvc", "aveppkt", " avPcmd", "evppacket", "avppkat", "avpbuf", "avepct", " avpbuf", "avepvc", "avewpct", "avcqt", "avwpkt", "avnpcmd", "aveppconn", " avcpkt", "avpackkt", "avPacket", "avppqt", "avppmsg", "avcpconn", "avppcmd", " avPkt", "avppkt", "avjpbuf", "avepmsg", " avcpbuf", "avpackacket", "avcpdu", " avpacket", " avcpmsg", "avppbuf", "evpqt", " avpkg", "avppkg", "avcpkat", "avppacket", "evppkt", "avepkt"], "ptr": ["offset", "pos", "eth", "td", "index", "lp", "loc", "arr", "pipe", "Ptr", "slice", "pr", "pad", "p", "sp", "proc", "ctx", "end", "pc", "adr", "buf", "fr", "dat", "tmp", "tr", "tp", "alloc", "seek", "address", "rep", "pointers", "inter", "pointer", "dr", "iter", "ps", "addr", "pt", "ind", "rel", "ref", "r", "coord", "pl", "inters", "buffer", "fp", "ctr", "br"], "len": ["mem", "pos", "lp", "duration", "fn", "l", "z", "nt", "t", "el", "size", "lon", "sp", "gl", "lf", "en", "list", "ll", "ml", "num", "end", "li", "compl", "le", "count", "vec", "wid", "il", "length", "all", "fin", "ln", "bytes", "iter", "ler", "Length", "js", "nl", "ref", "val", "L", "cmp", "kl", "lc", "str", "ell", "n", "lan", "lim", "ls", "pl", "ld", "loss", "resp", "fun", "full", "Len", "code", "sl", "elt", "seq", "err"], "dialog": ["ialog", "tdag", "ialect", "dialag", "dialogl", "choogue", "challog", "dialig", "choogl", "dialogue", "ialogue", "challogue", "colog", " dialogue", "colig", "directig", "directogue", " dialect", "slogue", "choig", "colag", "tdogue", "directect", "directag", "dialect", "slog", "directog", "slogl", " dialig", "ialig", "slig", "tdog", "challig", "challogl", "choog", "cologue", "tdig"]}}
{"project": "qemu", "commit_id": "5e003f17ec518cd96f5d2ac23ce9e14144426235", "target": 1, "func": "static int init_blk_migration(QEMUFile *f)\n\n{\n\n    BlockDriverState *bs;\n\n    BlkMigDevState *bmds;\n\n    int64_t sectors;\n\n    BdrvNextIterator it;\n\n    int i, num_bs = 0;\n\n    struct {\n\n        BlkMigDevState *bmds;\n\n        BlockDriverState *bs;\n\n    } *bmds_bs;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    block_mig_state.submitted = 0;\n\n    block_mig_state.read_done = 0;\n\n    block_mig_state.transferred = 0;\n\n    block_mig_state.total_sector_sum = 0;\n\n    block_mig_state.prev_progress = -1;\n\n    block_mig_state.bulk_completed = 0;\n\n    block_mig_state.zero_blocks = migrate_zero_blocks();\n\n\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n\n        num_bs++;\n\n    }\n\n    bmds_bs = g_malloc0(num_bs * sizeof(*bmds_bs));\n\n\n\n    for (i = 0, bs = bdrv_first(&it); bs; bs = bdrv_next(&it), i++) {\n\n        if (bdrv_is_read_only(bs)) {\n\n            continue;\n\n        }\n\n\n\n        sectors = bdrv_nb_sectors(bs);\n\n        if (sectors <= 0) {\n\n            ret = sectors;\n\n\n            goto out;\n\n        }\n\n\n\n        bmds = g_new0(BlkMigDevState, 1);\n\n        bmds->blk = blk_new(BLK_PERM_CONSISTENT_READ, BLK_PERM_ALL);\n\n        bmds->blk_name = g_strdup(bdrv_get_device_name(bs));\n\n        bmds->bulk_completed = 0;\n\n        bmds->total_sectors = sectors;\n\n        bmds->completed_sectors = 0;\n\n        bmds->shared_base = migrate_use_block_incremental();\n\n\n\n        assert(i < num_bs);\n\n        bmds_bs[i].bmds = bmds;\n\n        bmds_bs[i].bs = bs;\n\n\n\n        block_mig_state.total_sector_sum += sectors;\n\n\n\n        if (bmds->shared_base) {\n\n            DPRINTF(\"Start migration for %s with shared base image\\n\",\n\n                    bdrv_get_device_name(bs));\n\n        } else {\n\n            DPRINTF(\"Start full migration for %s\\n\", bdrv_get_device_name(bs));\n\n        }\n\n\n\n        QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n    }\n\n\n\n    /* Can only insert new BDSes now because doing so while iterating block\n\n     * devices may end up in a deadlock (iterating the new BDSes, too). */\n\n    for (i = 0; i < num_bs; i++) {\n\n        BlkMigDevState *bmds = bmds_bs[i].bmds;\n\n        BlockDriverState *bs = bmds_bs[i].bs;\n\n\n\n        if (bmds) {\n\n            ret = blk_insert_bs(bmds->blk, bs, &local_err);\n\n            if (ret < 0) {\n\n                error_report_err(local_err);\n\n                goto out;\n\n            }\n\n\n\n            alloc_aio_bitmap(bmds);\n\n            error_setg(&bmds->blocker, \"block device is in use by migration\");\n\n            bdrv_op_block_all(bs, bmds->blocker);\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    g_free(bmds_bs);\n\n    return ret;\n\n}", "idx": 18187, "substitutes": {"f": ["fd", "fn", "t", "fal", "p", "lf", "sf", "h", "e", "cf", "d", "v", "tf", "c", "fa", "fs", "fi", "fc", "fm", "bf", "af", "fw", "uf", "fp", "rf", "F", "file", "m"], "bs": ["bm", "ds", "cs", "lbs", "os", "boxes", "blocks", "bed", "outs", "nos", "bits", "bles", "sb", "BS", "bb", "ses", "bys", "ubs", "bh", "bp", "bo", "bas", "banks", "bps", "there", "rs", "gs", "bsp", "bc", "ubis", "ns", "vs", "pb", "bos", "bl", "sys", "bes", "js", "vers", "iss", "ps", "bu", "ats", "obs", "fs", "bf", "bi", "ts", "aos", "ls", "bing", "cb", "s", "stats", "eb", "browser", "buff", "boot", "b", "bis", "its", "bn"], "bmds": ["bmdubs", "bmdges", "bbindos", "ccmders", "bndn", "Bndns", "bbdS", "bconfigits", "bnds", "bjectits", "btabds", "bMDns", "wmdjs", "bcmdcs", "bmmds", "bmungets", "bndds", " baddgets", "bcfree", "bmdcs", "wMDjs", "bmindos", "vMDains", " bmnds", "bndS", "wmdS", " bmdubs", "Bndds", "bbinds", "bcmders", "bbindains", "bdepps", "bbdm", "btabcs", "bmdjs", "bdevcs", "wMDS", "bndjs", "bmuns", "bsmns", "bmunits", "bcmdits", "mndjs", "mmds", " bmnps", "bmdps", "bndns", "cmdges", "mnds", "bsmds", "bmms", "bmdains", "bdefs", "bcmdries", "bmdls", "bconfigs", "cmdls", "vmdains", " bmdgets", "badds", "bjects", " baddubs", " bfree", "bmdries", "btabries", "bdevers", "bddps", "bMDds", "baddgets", "bmdS", "cmdcs", "ccmdcs", "bdepds", "bMDm", "bdepS", "bmmries", "Bmdjs", " bto", "bMDains", "bbds", "baddits", "btabers", "bMDjs", " bmns", "bMDos", "mndn", " bmdits", "bmethods", "baddubs", "mmdS", "bddds", "bcmdn", "baddn", "bkgubs", "bmnds", "Bndjs", "mmdn", "bkgs", "bjectges", "bmindains", "mndS", "bMDs", "bcmdjs", "bmnls", "ccmdls", " baddits", "bto", "bmns", "baddjs", "wmdm", "bdefm", "Bmds", "bmdm", "bmunubs", "bdefjs", "wmds", "bdds", "bbdjs", "bkgits", "bmdns", "vMDos", " bmdds", "bmethodds", "Bnds", "nbto", "bmdgets", "mmdjs", " bmdps", "bdevs", "ccmdries", " bmnS", "bconfigges", " badds", "bmdds", "ccmdits", "bcmdls", "vMDs", "bfree", "bcmdds", "nbfree", "cmdds", "baddS", "bsmjs", "cmders", "Bmdds", "bmdos", "bddS", "bcmds", "bmdits", "cmdries", "Bmdns", "ccmdds", "bmethodls", "bminds", "ccmds", "ccmdges", "vmdos", "bmdn", "vmds", "btabs", "bcmdges", " bmdS", "bmnps", "bcto", "bmders", "bdeps", "cmdits", "cmds", "bsms", "bkggets", "wMDm", "wMDs", "bdefS", "bMDS", "bcmdS", "bmnS"], "sectors": ["bellers", "specs", "serters", "vecs", "vectors", " segments", "eters", "severs", "seters", " sevec", "veters", "vevers", "bevers", "vegments", "eors", " severs", "segments", "speors", " sections", "serors", "neors", "spevec", "spevers", "veors", "seors", "spectors", "becs", "spellers", "sevec", " seors", " sellers", "servers", "serctors", "bectors", "nectors", "spegments", "sections", "vections", "secs", "negments", "sellers", " secs", "vevec", "ectors", "necs", "spections", "evers"], "it": ["br", "IT", "ic", "itted", "this", "el", "si", "item", "or", "t", "ci", "p", "ins", "st", "he", "vt", "mit", "at", "q", "h", "is", "e", "op", "ot", "ct", "jit", "v", "io", "ait", "iter", "ip", "you", "bit", "ITS", "in", "lit", "j", "att", "r", "sit", "It", "alt", "rit", "al", "hit", "b", "ut", "its"], "i": ["ic", "index", "ij", "si", "t", "ci", "im", "hi", "p", "ki", "qi", "li", "ri", "I", "ai", "phi", "out", "v", "di", "cli", "iter", "ip", "mi", "pi", "c", "ind", "id", "in", "j", "xi", "try", "ti", "ui", "gi", "n", "ami", "multi", "fi", "bi", "iu", "x", "info", "ims", "zi", "ini", "sim", "go", "ix", "b", "y", "ii", "m"], "bmds_bs": ["bmdns_BS", "bmds2ls", "bmds2bs", "bmds_vs", "bmdjs2BS", "bmdjs_BS", "bmds__ls", "bmds_bas", "bmdjs_bas", "bmdjs_bs", "bmds_its", "bmds__BS", "bmdns_vs", "bmds__vs", "bmds2vs", "bmdns_bs", "bmds_ts", "bmds_BS", "bmdjs2bs", "bmdns_bed", "bmdjs2vs", "bmdjs_vs", "bmds_gs", "bmdjs2ls", "bmds2BS", "bmds__bs", "bmds_bed", "bmds_ls", "bmdjs_ls"], "local_err": ["localErrr", "local_rr", "local_er", "global_er", "global_err", "localErerr", "localErbuf", "localErer", "local_buf", "global_buf", "global_rr"], "ret": ["mem", " RET", "nt", "res", "arr", "args", "ter", "final", "xt", "result", "Ret", "ne", "vals", "rs", " ans", "nz", "Return", "ptr", "iter", "sys", "rem", " Ret", "vers", "RET", "rev", "re", "ext", "try", "j", "val", " resp", "usr", "alt", "ts", "ls", "len", " res", "elt", "status", "rets"], "num_bs": ["num__boxes", "nom_bs", "num_bps", "nom_bps", "num_bits", " num_boxes", "num_bis", " num_bis", "num_vs", "num___bl", "num__bs", "num_blocks", "num_BS", " num_blocks", "nom_ubs", "num___BS", "num__blocks", "num__bits", "num__bis", " num_bits", "num___bs", "num_boxes", "num_cs", " num_bl", " num_cs", "num_bl", " num_vs", "num__vs", "nom_bits", "num__cs", "num___boxes", " num_BS", "num_ubs"]}}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194, "substitutes": {"vs": ["atts", "ds", "cs", "lbs", "ov", "ops", "las", "fps", "flags", "sb", "ins", "changes", "vt", "lines", "ks", "qs", "bs", "vals", "sv", "rs", "gs", "vp", "vc", "ss", "pages", "values", "lists", "blogs", "pg", "v", "ns", "sts", "ps", "sys", "js", "inv", "ev", "obs", "views", "eps", "fs", "VS", "ts", "ims", "Vs", "nc", "ls", "s", "vr", "stats", "ms", "names", "wcs"], "y": ["yi", "ies", "sky", "ly", "z", "ys", "i", "yr", "ry", "xy", "axy", "ady", "sy", "idy", "ey", "ym", "ht", "hy", "py", "ch", "ay", "sys", "ya", "icy", "any", "ye", "my", "yy", "c", "ky", "yer", "vy", "height", "gy", "uy", "iny", "ery", "yo", "ny", "yt", "iy", " Y", "Y", "oy", "yl", "ty", "b", "cy", "col", "m"], "last_x": [" last_X", "tmp_y", "last_y", "last_xx", "tmp_xy", "last_xp", "last_X", " last_left", "last_z", "last_xy", "last____X", " last_y", "last____z", "last_left", " last_z", "last____xp", "tmp_xx", "last____x", " last_xp"], "x": ["index", "l", "px", "w", "ax", "t", "i", "tx", "p", "max", "only", "rx", "xy", "xxx", "xa", "xxxx", "xp", "checked", "step", "ox", "xf", "v", "X", "xs", "xi", "yx", "xx", "act", "xc", "dx", "ix", "ex", "m"], "h": ["His", "hs", "him", "history", "ho", "index", "hh", "oh", "l", "z", "t", "hi", "depth", "ach", "kh", "sh", "ish", "i", "p", "he", "hz", "hang", "th", "bh", "hash", "q", "ha", "hr", "html", "hd", "hold", "g", "count", "ht", "his", "handle", "ch", "m", "uth", "d", "v", "k", "ih", "H", "each", "head", "hm", "c", "pers", "height", "wh", "high", "ph", "zh", "dh", "orth", "rh", "go", "gh", "ah", "f", "it", "hal", "b", "hl"], "tmp_x": ["tp_xes", "tmpMemxml", " tmp_tx", "tmp_ix", "tp_xml", "tmp_ux", "tmp_xml", "tp_x", "tpMemx", "tpMemxes", "tmpMemlength", "tmpMemx", "tmp_xt", "mp_x", " tmp_ch", "tmp__X", " tmp_ix", "tmp_X", "tmp_ch", "tmp__ch", "tmpMemxes", "tpMemlength", "tmp_y", "tmp_wx", "tmp__x", "tpMemxml", "tmp__ex", " tmp_X", "tmp_length", " tmp_wx", " tmp_ex", "tmp__tx", "mp_y", "tmp_ex", "mp_xt", "tmp_xes", "tp_length", "mp_ux", "tmp_tx"]}}
{"project": "qemu", "commit_id": "a0067da1577e3eb0c60758384282568f4b2328fe", "target": 1, "func": "static void test_dispatch_cmd_failure(void)\n\n{\n\n    QDict *req = qdict_new();\n\n\n    QObject *resp;\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n\n\n    /* check that with extra arguments it throws an error */\n\n    req = qdict_new();\n\n    qdict_put(args, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args);\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n}", "idx": 18195, "substitutes": {"req": ["pr", "ck", "tx", "ctx", "rt", "fr", "arg", "crit", "requ", "rr", "tek", "obj", "sys", "esp", "inv", "jp", "aux", "eg", "quick", "form", "dist", "awk", "desc", "var", "required", "q", "compl", "cur", "tmp", "ps", "call", "reset", "pkg", "pt", "fy", "usr", "qt", "qa", "urg", "err", "fresh", "init", "res", "proc", "query", "rx", "hr", "expr", "iq", "reg", "attr", "js", "j", "gr", "def", "quest", "rb", "request", "qq", "needed", "require", "args", "sq", "decl", "wx", "cmd", "ind", "ext", "rel", "ref", "r", "comp", "seq", "dq"], "resp": ["snap", "pos", "res", "arr", "nt", "Resp", "args", "sp", "ess", "proc", "result", "ll", "results", "ctx", "gz", "decl", "ret", "ne", "compl", "arg", "fr", "rs", "dl", "rend", "ps", "rec", "sys", "rep", "gov", "reg", "out", "obj", "respons", "response", "that", "wx", "js", "esp", "conn", "rev", "msg", "reply", "cmd", "inv", "j", "eval", "rel", "ref", "comm", "jp", "ev", "cmp", "def", "str", "RES", "sol", "repl", "acc", "txt", "rex", "respond", "vol", "rest", "gt", "comp", "buff", "serv", "rpm", " res", "seq", "err"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void add_index_entry(AVStream *st,\n\n                            int64_t pos, int64_t timestamp, int flags)\n\n{\n\n    AVIndexEntry *entries, *ie;\n\n    \n\n    entries = av_fast_realloc(st->index_entries,\n\n                              &st->index_entries_allocated_size,\n\n                              (st->nb_index_entries + 1) * \n\n                              sizeof(AVIndexEntry));\n\n    if (entries) {\n\n        st->index_entries = entries;\n\n        ie = &entries[st->nb_index_entries++];\n\n        ie->pos = pos;\n\n        ie->timestamp = timestamp;\n\n        ie->flags = flags;\n\n    }\n\n}\n", "idx": 18200, "substitutes": {"st": ["sc", "td", "sam", "form", "nt", "stable", "ism", "sl", "t", "ist", "sh", "sp", "stage", "store", "th", "h", "sm", "set", "rt", "fr", "sv", "ss", "ste", "mt", "ct", "so", "stat", "d", "sw", "St", "sts", "db", "se", "ft", "spect", "ast", "sn", "sth", "step", "pt", "inst", "std", "ust", "art", "ST", "est", "sta", "str", "ld", "nd", "net", "s", "rest", "tt", "ost", "ut"], "pos": ["offset", "snap", "Pos", "index", "loc", "os", "form", "nt", "size", "pr", "oc", "p", "slot", "port", "pid", "pc", "pres", "point", "op", "points", "position", "pro", "ports", "doc", "ps", "POS", "pi", "pt", "ind", "rot", "ref", "local", "origin", "neg", "def", "cond", "mon", "path", "top", "Position", "cod", "pl", "pose", "len", "resp", "spec", "po", "trans"], "timestamp": ["imest", "Timprint", "scheestamp", "temeness", "temetime", "Timest", "temestamp", "mominal", "timprint", "scheeness", " timprint", "timintage", "timdule", "Timetime", "timeinal", "Timeness", " timest", "metetime", "Timestamp", "imprint", "momestamp", "imintage", "temeline", "meteline", "timedule", "timeline", "timinal", "timetime", "timeness", "timeeness", "momdule", " timintage", "Timintage", "scheinal", "momeness", "meteness", "imestamp", "Timeline", "timeestamp", "timest", "metestamp", "schedule"], "flags": ["atts", "fields", "times", "acts", "ops", "fps", "args", "flag", "bits", "limits", "details", "members", "posts", "frames", "bugs", "bps", "grades", "pins", "files", "comments", "amps", "tags", "ports", "alf", "mask", "aps", "ps", "ants", "types", "ats", "options", "ags", "reports", "ints", "weights", "ts", "faces", "features", "parts", "locks", "levels", "mods", "links", "places", "stats", "ms", "wcs", "heads", "orts", "lag", "issues", "Flags", "rates"], "entries": ["gateies", "sentrys", "gentries", "rentrance", "enties", "rentries", "entents", "entsry", "nties", "senties", "sentries", "gentires", "ntrys", " entrance", "Entires", " enties", "Entrys", "indries", "indities", "conties", "ntrance", "gentrys", "Entries", "gateries", "contries", "entsities", "entires", "gaterys", "Entry", "Entried", "entsents", "contried", "Entities", "entsires", "renties", "ntries", "gateents", " entrys", "entsries", "entried", "rentrys", "contrys", "indents", "entrance", "sentents", " entried", "entities", "indrys", "entsrys", "gentry", "Enties", "entry", "entsies", "Entents", "entrys"], "ie": ["quote", "see", "rice", "ue", "die", "mie", "ife", "i", "ei", "tie", "IE", "ipe", "ince", "nie", "edge", "ne", "le", "ge", "ice", "e", "ibe", "te", "eur", "je", "ni", "ace", "ite", "zip", "ink", "iq", "io", "ide", "ig", "tip", "bie", "ee", "ade", "ip", "ige", "entity", "ere", "ine", "ele", "iere", "ce", "er", "ib", "pse", "sie", "ime", "entry", "eg", "pie", "eb", "ief", "pe", "ike", "oe"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    MpegEncContext *s = avctx->priv_data;\n\n    AVFrame *pict = data;\n\n    int i, ret;\n\n    int slice_count;\n\n    const uint8_t *slices_hdr = NULL;\n\n\n\n    av_dlog(avctx, \"*****frame %d size=%d\\n\", avctx->frame_number, buf_size);\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (!avctx->slice_count) {\n\n        slice_count = (*buf++) + 1;\n\n        buf_size--;\n\n\n\n        if (!slice_count || buf_size <= 8 * slice_count) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid slice count: %d.\\n\",\n\n                   slice_count);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        slices_hdr = buf + 4;\n\n        buf       += 8 * slice_count;\n\n        buf_size  -= 8 * slice_count;\n\n    } else\n\n        slice_count = avctx->slice_count;\n\n\n\n    for (i = 0; i < slice_count; i++) {\n\n        unsigned offset = get_slice_offset(avctx, slices_hdr, i);\n\n        int size, size2;\n\n\n\n        if (offset >= buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (i + 1 == slice_count)\n\n            size = buf_size - offset;\n\n        else\n\n            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;\n\n\n\n        if (i + 2 >= slice_count)\n\n            size2 = buf_size - offset;\n\n        else\n\n            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;\n\n\n\n        if (size <= 0 || size2 <= 0 ||\n\n            offset + FFMAX(size, size2) > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)\n\n            return ret;\n\n\n\n        if (ret > 8 * size)\n\n            i++;\n\n    }\n\n\n\n    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {\n\n        ff_er_frame_end(&s->er);\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            if ((ret = av_frame_ref(pict, &s->current_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            if ((ret = av_frame_ref(pict, &s->last_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->last_picture_ptr);\n\n        }\n\n\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *got_frame = 1;\n\n        }\n\n\n\n        // so we can detect if frame_end was not called (find some nicer solution...)\n\n        s->current_picture_ptr = NULL;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 18202, "substitutes": {"avctx": ["ajpkg", "AVctx", "avctl", "avnp", " avcontext", "aveconn", "AVjp", "abpkg", " avcmd", "wavctx", "avconn", "averconfig", "wavcmp", "savconfig", " avctl", "avjac", "abconn", "afctx", "vrtx", "avpkg", "vercontext", "savjac", "afconfig", "avercfg", "avcmd", " avjac", "avetx", "ajconn", "avecontext", "avcu", "wavconn", "averjac", "avertx", "AVcontext", "avepkg", "avconfig", "navconf", "averjp", " avtx", "aversys", "abconf", "averpkg", "savtx", "verctl", "avewcs", "avesc", "averconn", "avernp", "savsys", "afcfg", "avercontext", "savctx", "vrjp", "verctx", " avcfg", "wavconf", "avcontext", "avcfg", "ajwcs", "savnp", "avesys", "ajjac", "ajcontext", "vertx", "aveconfig", "avectx", "avejac", "wavjac", "ajcu", "avejp", "AVctl", "vrsc", "avecfg", "navcmp", "avercu", "avsys", "abcmp", "wavpkg", "aversc", "avenp", "abtx", "avcmp", "avsc", "ajctx", "savjp", " avconn", "avwcs", "avconf", " avpkg", "averctx", "abcontext", "AVtx", "navpkg", "afjac", "avjp", "vrctx", "avecmd", "navctx", "ajcfg", "avtx", " avcu", "abcmd", "abctx", "AVjac", " avwcs"], "data": ["a", "next", "offset", "frame", "rew", "form", "t", "window", "pad", "p", "input", "feed", "family", "action", "empty", "dat", "ata", "padding", "length", "content", "name", "image", "d", "DATA", "one", "bytes", "mu", "Data", "media", "read", "obj", "value", "response", "json", "to", "rel", "r", "batch", "message", "table", "str", "raw", "received", "def", "sequence", "package", "block", "buffer", "f", "text", "m"], "got_frame": ["received_frame", "got1length", "got1data", "got___data", "received_length", "got___state", "got_length", "got1state", "received_state", "received_data", "got1frame", "got_data", "got_state", "got___frame", "got___length"], "avpkt": ["avPpt", "avnkt", "avpwt", "avcpwt", "avsppt", "avapkg", "avpackunct", "avbpkt", "avcppt", "avspkt", "avcpct", "avapwt", "avnwt", "avpacket", "avpct", "afcpacket", "avcpacket", "afpacket", "avppt", "afpunct", "avpackacket", "avpunct", " avpacket", "avapacket", " avcpacket", "avpj", " avcpkg", "avPkt", "avbpj", "avcpj", "afpj", "afcppt", "avspct", "avbpunct", "avcpunct", " avpkg", "afcpj", "afcpunct", "avnacket", "avspacket", "afpkt", "avpkg", "avcpkg", "avnkg", " avpwt", "avpackj", "avpackkt", "avbpacket", "afppt", " avcpwt", "avapkt", " avcpkt", "afpct", "afcpct", "afcpkt", "avPct", "avcpkt", "avPacket"], "buf": ["late", "mem", "pos", "xff", "cv", "init", "offset", "loc", "box", "window", "img", "pad", "bar", "port", "ctx", "end", "av", "vec", "map", "tmp", "fac", "far", "queue", "bc", "off", "alloc", "db", "v", "bytes", "mu", "limit", "wb", "read", "bl", "ptr", "iter", "doc", "msg", "cmd", "pkg", "half", "ref", "pool", "um", "batch", "raw", "rb", "coord", "orig", "cache", "txt", "cb", "lim", "len", "uf", "buffer", "Buffer", "buff", "begin", "b", "ctr", "br"], "s": ["sc", "a", "ds", "cs", "sam", "sl", "sg", "t", "sb", "p", "ess", "sp", "sq", "set", "sv", "rs", "gs", "sa", "S", "ss", "session", "v", "ns", "sts", "soc", "sys", "js", "c", "fs", "ts", "ssl", "ls", "stats", "spec", "b", "m"], "pict": ["fl", "fd", "ra", " fr", "FR", "original", " e", " frame", "Frame", " p", "ft", " req", "req", "ref", " fn", "raw", " f", " fin", "fi", "fc", "fm", " F", "fw", "rc", "f", "rf", "P", "F", "ff", " frames"], "i": ["hi", "ir", "li", "e", "g", "I", "upper", "ai", "di", "iter", "mi", "c", "origin", "chain", "multi", "ii", "offset", "index", "ij", "item", "t", "ci", "list", "q", "level", "\u0438", "phi", "v", "cli", "limit", "pi", "try", "gi", "n", "o", "bi", "x", "ini", "f", "it", "iu", "status", "err", "init", "a", "ic", "l", "ei", "qi", "me", " ii", "name", "ias", "instance", "ip", "j", "ti", "ami", "info", "go", "ix", "y", "m", "si", "im", "ki", "h", "is", "u", "ind", "id", "in", "xi", "ui", "batch", "key", "ims", "sim"], "ret": ["mem", "offset", "res", "nt", "format", "args", "t", "total", "ter", "xt", "result", "Ret", "err", "rt", "tr", "done", "mt", "get", "tf", "dr", "iter", "cont", "ft", "value", "rem", "success", " Ret", "RET", "rev", "re", "reset", "ext", "try", "rel", "ref", "r", "val", "def", "alt", "aux", "vector", "got", "len", "resp", "f", "gt", "fun", "it", "elt", "status", "rets"], "slice_count": ["slice12sum", "sliceletamount", "slice_flags", "shiftPcount", "sliceercount", "shift_found", "plot_Count", " slice_c", "sliceitynum", "plot_depth", "slave_amount", "slot_info", "slice12depth", "slice67cd", "sample_count", "slice12Count", "slicePcounter", "slaveityamount", "slicetweight", "slice00count", "sliceitycount", "sloternumber", "slice2Count", "slice_sum", "sample_Count", "slice_cmd", "slice00found", "slice_counter", "plot_cmd", "sliceermode", "slice2c", "slice_code", "slice67child", " slice_weight", "plot00found", "plot00Count", "zeroletcd", "slice_Count", "slice1number", "slot_number", "slice_number", "zeroletCount", "slotermode", "plot12Count", "slice2found", "slice1Count", "planeletcount", "slicetCount", "sliceernumber", "plot_sum", "slice_cond", "planeletamount", "slice____flags", "slot____flags", " slice_amount", "slice_c", "slice____count", "plot00count", "sample_weight", " slice_cond", " slice_limit", "slaveitycount", "shift_con", "slice12count", "slice_cd", "zeroletchild", "scale_count", "slicePcon", "plane_amount", "shift_counter", "slot_count", "slave_found", "slice67count", "shiftPcon", "slave_num", "slice67found", "slice____info", "slice_con", "planeletcon", "slice_weight", "slice2count", "slice1found", "slice_amount", "slice67counter", "slice00Count", "slice_info", "zero_Count", "slaveityfound", "slice_limit", "shiftPcounter", "sliceletcount", "slice67weight", "slice67Count", " slice_Count", "slice1cmd", "shift_count", "scale_code", "slice2counter", "slice_depth", "slicetcount", "slice_child", "scale_Count", "slot_Count", "zero_cd", "scale_c", "zeroletcount", "slicePcount", "slice1count", "zero_count", "slot____Count", "slice00cmd", "sliceletchild", "slice1mode", "sliceletcd", "zero_child", "sliceletcon", "slot____count", "slice____Count", "plot12count", "slice_num", "plot12depth", "slice_found", "slice67con", "plane_con", "slot_flags", "plane_count", "slice_mode", "slice67cond", "plot_found", "shiftPfound", "plot12sum", "slot_mode", "plot_count", "slice2con", "sliceletCount", "slotercount", "sliceityfound", "plot00cmd", "slice2code", "slave_count", "slot____info", "slicePfound", "sliceityamount", "slaveitynum"], "slices_hdr": ["slices2hr", "slices_hhook", "slices_holder", "slices_ihdr", "slices_ihfr", "slices_hadr", "slices_trrid", "slices_hrec", "slices_hDR", "slices_trrd", "slices_tholder", "slices_hrmm", "slices2Hbr", "slices_hrDR", "slices_ihDR", "slices_trDR", "slices_iholder", "slices_phdr", "slices_Hr", "slices_hfr", "slices_qrec", "slices_prDR", "slices_qdr", "slices_hhdr", "slices_Hbr", "slices2Hdr", "slices_chDR", "slices_pradr", "slices_lrd", "slices_hmm", "slices_ldr", "slices2hbr", "slices_phr", "slices_lDR", "slices_hook", "slices_trdr", "slices_chbr", "slices_hrid", "slices_prmm", "slices_thdr", "slices_hr", "slices_Hook", "slices_Holder", "slices_chr", "slices_qDR", "slices_prdr", "slices_Hfr", "slices_qook", "slices_hbr", "slices_Hrec", "slices_lrid", "slices_hrd", "slices2hdr", "slices_phbr", "slices_thDR", "slices2Hr", "slices_hhDR", "slices_HDR", "slices2hDR", "slices_Hdr", "slices_phDR", "slices_chdr", "slices_thfr", "slices_hrdr", "slices_hhrec", "slices2HDR", "slices_hradr"], "buf_size": ["buf_SIZE", "bufmlenergy", "Buffer_size", "buf_name", "buff64size", "buftSIZE", "cap_scale", "bufptgroup", "cap_space", "buf2scale", "BufferlenSIZE", "buf64group", "buflensize", "buf2SIZE", "buf8size", "buf2len", "buf_Size", "bufptlen", "buff_len", "buf_status", "buf_storage", "buf_count", "buff_cache", " buf_Size", "buff_SIZE", "uf_scale", "buf64len", "buff64group", " buf_len", "buff8offset", "buf8SIZE", "buf64site", "bufttotal", "byte_length", "buff_site", "Buffer_SIZE", "buf67len", "buf67site", "cap_count", "uf_len", "buf_scale", "bufmlset", "bytemllength", "buf64size", "buf_len", "buf_set", "buf8cache", " buf_storage", "buf_site", "buff64site", "buf67group", "buf2size", "buf_cache", "uf_SIZE", "buff_offset", "Buffer_status", "bufmlsize", "buflenSIZE", "buff_group", " buf_SIZE", "buf67size", "buflenstatus", "bufptsize", "bytemlenergy", "Bufferlensize", "buff8size", "buf_length", "buff_size", "byte_set", "buf2Size", "uf_name", "uf_Size", "buf_energy", "Buffer_total", "bufptsite", " buf_count", "buff64len", "Bufferlenstatus", "buflentotal", "byte_energy", "buff8cache", "bytemlsize", "buf8offset", "buf_total", "Bufferlentotal", "buftstatus", "bytemlset", "buf_space", "buf2storage", "cap_size", "buftsize", "buff8SIZE", "buf_offset", "uf_count", "uf_size", "byte_size", "buf2count", "bufmllength", "buf_group"], "size": ["izes", "error", "z", "format", "weight", "shift", "scale", "g", "length", "news", "get", "speed", "options", "number", "space", " sizes", "city", "offset", "mem", "zone", "equal", "sh", "max", "sp", "ose", "timeout", "set", "zero", "sum", "shape", "general", "content", "scroll", "start", "limit", "read", "fee", "range", "n", "len", "small", "style", "l", "total", "ne", "south", "send", "name", "address", "iz", "sw", "time", "any", "storage", "to", "body", "height", "Size", "notice", "SIZE", "no", "ie", "needed", "si", "window", "sent", "count", "empty", "ify", "unit", "bytes", "magic", "ize", "message", "dim", "ms", "type"], "size2": ["size1", "name1", "size02", "dimension1", "sizeTwo", "SizeTwo", "Size4", " size02", "style2", "dimension162", "size4", "score3", "SIZE4", "timeTwo", "time1", "size3", " sizeTwo", "score52", " size4", "Size1", "size162", "ize2", "ize02", "style3", " size1", "dimension2", "score2", "ize4", "time2", "ize1", "Size2", "dimension02", "name162", " size162", "name2", "name02", "SIZE1", "style52", "time4", "size52", "SIZE2", " size52", " size3"]}}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,\n\n                           AVStream *st, RMStream *rst, int codec_data_size)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(st->codec, AV_LOG_ERROR, \"Unsupported video codec\\n\");\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n//        av_log(s, AV_LOG_DEBUG, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,\n\n                  0x10000, fps, (1 << 30) - 1);\n\n        st->avg_frame_rate = st->r_frame_rate;\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 18203, "substitutes": {"v": ["vi", "cv", "lv", "l", "b", "qv", "format", "t", "w", "i", "p", "qu", "vt", " V", "h", "va", "nv", "av", "g", "vert", "sv", "vp", "u", "vc", "conv", "uv", "vs", "k", "vm", "ve", "value", "iv", "rev", "c", "inv", "j", "ev", "val", "V", "type", "len", "vv", "vol", "ver", "s", "f", "vr", "tv", "version", "y", "m"], "size": ["mem", "offset", "z", "si", "l", "format", "t", "i", "sp", "set", "scale", "sum", "count", "g", "sv", "length", "name", "seek", "sn", "sd", "c", "ize", "n", "Size", "SIZE", "len"], "codec_pos": ["codec__Pos", "codec0pos", "codpeg_position", "codec0info", "codec_loc", "codec0offset", "codec_position", "codoc_Pos", "codpeg_pos", "codec__position", "codpeg_loc", "codoc_pos", "codpeg_Pos", "codoc_info", "codec_Pos", "codec__pos", "codec__loc", "codec_offset", "codec0Pos", "codec_info", "codoc_offset"], "ret": ["mem", " RET", "res", "nt", "pret", "t", "back", "ez", "ter", "final", "result", "ll", "err", "zero", "rt", "ber", "il", "tr", "mt", "out", "tf", "inter", "cont", "ft", "value", "rem", " Ret", "RET", "reset", "re", "det", "nl", "try", "ref", "val", "alt", "ail", "len", "resp", "status", "f", "not", "it", "fun", "gt", "elt", "after", "rets", "Ret"], "fps": ["next", "res", "ffff", "frames", "vals", "failed", "ps", "first", " resp", " fin", "fs", "resp", "err", " frames"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n", "idx": 18211, "substitutes": {"f": ["a", "fd", "form", "l", "inf", "t", "w", "i", "p", "lf", "h", "q", "fb", "e", "fr", "g", "cf", "fac", "d", "fe", "tf", "ile", "c", "elf", "r", "fo", "fs", "fi", "df", "fc", "fm", "af", "fx", "uf", "fp", "F", "b", "conf", "file", "m"], "pv": ["Pj", "mpvt", "parV", "pvi", "pvs", "parvt", " pvs", "parv", "pj", "PV", "parvi", "Pvt", "Pvi", "cpvi", " pvi", "Pv", "pV", "pvt", "Pvs", "cpj", " pj", "mpV", "mpv", "cpvs", "cpv", "mpvi"], "size": [" enc", " len", " sum", " count", "e", "_", " sh", "length", " st", " shr", " scale", " Size", "ize", "n", " resize", " offset", "space", " sized", "Size", "SIZE", "len", " sizes", " notice", "s", " unused"], "v": ["a", "vi", "cv", "lv", "ov", "l", "t", "w", "i", "p", "var", "vt", "q", "va", "nv", "av", "g", "sv", "vp", "u", "uv", "vs", "vm", "iv", "pi", "c", "inv", "j", "r", "ev", "V", "n", "vol", "s", "tv", "b", "y", "m"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n", "idx": 18220, "substitutes": {"json": ["alert", "jj", "ij", "np", "widget", "java", "final", "kj", "result", "query", "ja", "journal", "mson", "jobs", "all", "son", "obj", "javascript", "value", "response", "js", "latest", "data", "j", "new", "root", "needs", "join", "job", "raw", "JSON", "print", "state", "xml", "row", "params", "stats", "bind", "full", "it", "spec", "jack", "database"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_record_dump(void)\n\n{\n\n    PCRecord **pr, *r;\n\n    int i, h;\n\n    FILE *f;\n\n    int64_t total, sum;\n\n\n\n    pr = malloc(sizeof(PCRecord *) * nb_pc_records);\n\n    i = 0;\n\n    total = 0;\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {\n\n            pr[i++] = r;\n\n            total += r->count;\n\n        }\n\n    }\n\n    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);\n\n\n\n    f = fopen(\"/tmp/kqemu.stats\", \"w\");\n\n    if (!f) {\n\n        perror(\"/tmp/kqemu.stats\");\n\n        exit(1);\n\n    }\n\n    fprintf(f, \"total: %\" PRId64 \"\\n\", total);\n\n    sum = 0;\n\n    for(i = 0; i < nb_pc_records; i++) {\n\n        r = pr[i];\n\n        sum += r->count;\n\n        fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\",\n\n                r->pc,\n\n                r->count,\n\n                (double)r->count / (double)total * 100.0,\n\n                (double)sum / (double)total * 100.0);\n\n    }\n\n    fclose(f);\n\n    free(pr);\n\n\n\n    kqemu_record_flush();\n\n}\n", "idx": 18231, "substitutes": {"pr": ["spr", "res", "arr", "por", "ra", "p", "pp", "ins", "list", "kr", "hr", "PR", "pc", "expr", "pol", "fr", "pit", "per", "rs", "mr", "vp", "cur", "rr", "tr", "py", "rec", "ch", "rep", "pro", "wr", "pb", "ptr", "pri", "dr", "ps", "iter", "lr", "rl", "mp", "pi", "pt", "cr", "ocr", "pir", "gr", "print", "repl", "pse", "pre", "par", "pl", "pa", "ro", "ver", "Pr", "po", "br", "err"], "r": ["rer", "br", "rm", "ren", "res", "l", "ur", "or", "t", "w", "p", "result", "q", "err", "ar", "kr", "rect", "hr", "rt", "e", "adr", "fr", "g", "mr", "rs", "rr", "tr", "rec", "d", "v", "reg", "attr", "dr", "rar", "obj", "rem", "rd", "range", "re", "c", "cr", "rel", "gr", "pair", "R", "rg", "usr", "repl", "rb", "er", "sr", "rn", "ro", "nr", "rh", "rc", "vr", "entry", "rf", "b", "lr", "rl"], "i": ["init", "ic", "index", "ij", "l", "si", "or", "ci", "im", "p", "ish", "ei", "hi", "ki", "qi", "me", "li", "is", "\u0438", "ri", "count", "I", " ii", "u", "ai", "phi", "m", "v", "di", "cli", "iter", "ip", "mi", "pi", "ind", "id", "j", "xi", "ti", "ui", "batch", "gi", "o", "n", "ami", "multi", "ji", "uri", "bi", "iu", "x", "zi", "ini", "sim", "ie", "it", "ia", "ix", "b", "y", "ii", "iat"], "h": ["hs", "history", "index", "ho", "hh", "oh", "hu", "t", "w", "hi", "hl", "kh", "p", "sh", "he", "hz", "th", "hash", "ha", "bh", "hr", "hd", "count", "ht", "phi", "his", "ch", "k", "H", "ih", "hm", "hp", "high", "ph", "n", "zh", "pl", "rh", "go", "gh", "ah", "hal", "y", "m"], "f": ["a", "fl", "fd", "fn", "l", "ok", "t", "w", "z", "fab", "p", "lf", "sf", "q", "fb", "e", "fr", "g", "cf", "u", "xf", "d", "v", "tf", "ef", "c", "ff", "j", "fo", "o", "fs", "fi", "fc", "bf", "df", "fm", "fa", "y", "open", "fx", "uf", "s", "ac", "it", "fp", "rf", "F", "b", "conf", "file", "m"], "total": ["size", "valid", "details", "base", "scale", " summed", "tree", "length", "pretty", "Total", "number", "tm", "net", "title", "database", "human", " final", "t", "none", "ta", "equal", "max", "list", "result", "where", "required", " Total", "zero", " TOTAL", "global", "general", "ot", "unknown", "ma", "mu", "doc", "pi", " totals", "summary", "null", "ota", "num", "tar", "ne", "normal", "all", "note", "info", "meta", "eta", "no", " summary", "shared", "si", "final", "pty", "OTAL", "last", "public", "created", "count", "otal", "done", "unit", " tot", "current", "table", "oot", "mean", "now", "ms", "full", " unused", "trace"], "sum": ["missing", "mem", "a", "sam", "index", "si", "nt", "size", "miss", "mm", "sp", "num", "st", "result", "hash", "ne", "zero", "volume", "count", "sa", "Sum", " SUM", "otal", "ss", "amount", "so", "out", "all", "ma", "v", "mu", "se", "add", "um", "summary", "unique", "mean", "diff", "acc", "tm", "info", "tail", "su", "sim", "cum", "vol", "alpha", "stats", "ms", "us", "tu", "average", "multi", "m"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    PCNetState *s = opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n", "idx": 18254, "substitutes": {"opaque": ["Opity", "Opaque", "operac", " opque", "Opac", "Oposter", "opient", "oposter", " opient", " Opient", "Opoid", "opoid", "Opque", " Opque", "opac", "ipac", "opity", " opoid", " Opaque", "Opient", "iposter", " Opoid", "opque", "ipaque", "operity", "ipity", "operaque", "operoster"], "buf": ["mem", "cap", "cv", "Buff", "aka", "box", "w", "img", "text", "ctx", "good", "vec", "map", "tmp", "tr", " buffer", "queue", "BU", "alloc", "bc", "db", "v", "pb", "wb", "iter", "bl", "doc", "msg", "cmd", "data", "pkg", "ref", "pool", "batch", "raw", "rb", "orig", "txt", "cb", "block", "cache", "bin", "uf", "buffer", "broad", "Buffer", "buff", "code", "b", "seq", "ff", "br"], "size": ["z", "format", "scale", "e", "g", "length", "news", "number", "space", "params", "buffer", "grow", "offset", "mem", "equal", "sh", "max", "sp", "timeout", "set", "gz", "zero", "sum", "global", "shape", "v", "start", "limit", "fee", "sn", "len", "small", "code", "status", "style", "l", "total", "num", "send", "name", "address", "sw", "capacity", "time", "storage", "body", "height", "too", "draw", "Size", "notice", "SIZE", "no", "needed", "see", "eng", "window", "sent", "count", "empty", "padding", "negative", "area", "data", "ize", "id", "message", "member", "now", "dim", "large", "type"], "s": ["z", "bits", "g", "rs", "fts", "vs", "self", "obj", "se", "sys", "c", "es", "comm", "fs", "space", "er", "serv", "ex", "sis", "sl", "spec", "os", "or", "t", "sm", "set", "qs", "sa", "S", "ss", "d", "sts", "ps", "sn", "xs", "n", "o", "ts", "sie", "x", "ls", "stats", "a", "ies", "ds", "sam", "w", "sb", "as", "ses", "changes", "als", "ar", "sv", "sw", "js", "j", "ssl", "an", "m", "hs", "args", "ins", "sq", "h", "is", "bs", "gs", "ns", "socket", "sports", "ats", "r", "ims", "ms", "its"], "buf1": [" buf3", "buff2", "uf1", "uf2", "buffer2", "buffer3", "buf3", "buff0", "buf2", "buffer0", "buff3", "buf0", "buffer1", "uf3", "uf0", "buff1", " buf2"], "remaining": [" remmore", "remain", "remmore", "restain", "restained", "restaining", "Remain", "remained", " remained", "Remmore", "restmore", " remain", "Remained", "Remaining"], "rmd": ["rrcmd", "rds", " rmt", "ermd", "mnd", " rcmd", "mmt", "crmt", "rrds", "rmn", "pmt", " rmn", "pcmd", "rnd", "rrMD", "mds", "rrmd", "rcmd", " rnd", "crcmd", "mMD", "rMD", "pnd", "mcmd", "pmd", "rmt", "crmn", "crmd", " rds", "ermn", "ermt", "mmd", " rMD", "ercmd"], "i": ["ic", "index", "l", "si", "ci", "im", "hi", "qi", "me", "li", "\u0438", "e", "I", "u", "ai", "phi", "v", "cli", "di", "MI", "mi", "pi", "oi", "ind", "c", "in", "j", "xi", "ti", "ui", "iat", "gi", "n", "multi", "bi", "x", "ims", "zi", "ini", "it", "ix", "iu", "ii", "m"], "nrda": ["nridao", "nrcan", " Nrca", " Nrda", "nrownA", " nrdba", "nridA", " Nrcata", "nldA", "nrdata", "nrdba", "nrca", "nrandao", "nrcata", "nrdao", " nrownba", "nrandba", "nnddata", " nrownA", " Nrcna", "nnrdo", "nldata", "nrdan", "nldo", "nldna", "nrandA", "nndda", "nrownna", " Nrdan", "nrownata", "nrdo", "nnddo", "nrcna", "nddo", "nridba", "nnddA", "nlda", "nddata", "nranda", "nrownba", " nrdA", "nnrdata", " Nrdata", "nrida", "nrownan", "nnrda", " Nrcan", "nrdna", "nrownao", "nrowno", " nrdao", "nddA", " Nrdna", "ndda", "nldan", "nnrdA", "nrowna", " nrownao", "nrdA", " nrowna"], "rcvrc": ["rcvrrl", "RCvrrr", "rlrevrc", "rcvr", "rcvrRC", "rcvcront", "rcvcmp", "rcvertarc", "rcnvrs", "rcrevrc", "RCvrr", "rcvertRC", "RCvrroc", "RCsvrc", "rcvrarc", "RCvfc", "rcvrrr", "rcvrl", "rcrevarc", "rcvrt", "rcvinroc", "rcvtr", "rcsvRC", "rccvRC", " rcVRC", "rcvert", " rcvrl", "rlrevarc", "rcvcrc", " rcsvarc", "rcvinrc", "rcVrc", " rcvert", "rcvertroc", "rcvinr", "RCsvfc", "rcverterc", "rcvRC", " rcvright", "rcvarc", "rlvrc", "rcvroc", "RCvcmp", "rcvrrc", "rlreverc", "RCvrRC", "rcuvrc", " rcvrt", "rcvrroc", "rcvertrl", "rcuvcmp", "RCsvront", "rcVrl", "rcvinRC", "rcsvrs", "rcvront", "RCsvRC", "rcrevrl", "rcveright", "RCvrrc", "rcsvrl", "rcvirc", "RCvRC", "rcvrs", "rcVRC", "rcsvfc", " rcvarc", " rcsvrc", "rcverc", "rlverc", " rcver", "rcvcfc", " rcVrl", " rcsvrl", "rcnvrc", "rcvrr", "rcvtright", "rcvertrr", " rcsvrs", "rcnvrl", " rcvr", "RCvrc", " rcverc", "RCvirc", "rcsvarc", "RCvroc", "rcsvront", "rcvinrr", "rccvcmp", "rlvrl", "RCvrcmp", "rcvertrc", "rcvrirc", " rcVrc", "rcvright", "rcver", "rccvrc", "rcvtrc", "rcuverc", "rcuvrl", " rcvRC", "rlrevrl", " rcveright", "RCvront", "rcvtrt", "rlvarc", "rcuvirc", "rcvrcmp", "rcvcRC", "rcuvRC", "rccvirc", "RCvrirc", "rcuvarc", "rcvinrt", "rcvfc", "rcnvarc", "rcsvrc", "rcreverc", "rcvinright", "rcvrrs", " rcvrs"], "CSR_RCVRC": ["CSR_RCFRC", "CSR_RCVERRL", "CSR_RCFINC", "CSR_RCVRL", "CSR_RCCVRL", "CSR_RMVLC", "CSR_UCvREF", "CSR_RCVSRC", "CSR_RCvLC", "CSR_RCvINC", "CSR_RMvRS", "CSR_RCVSRFC", "CSR_RCVRS", "CSR_RCVRFC", "CSR_RCVSREF", "CSR_UCvRL", "CSR_UCvRFC", "CSR_RCVERRS", "CSR_UCVRC", "CSR_RMVRL", "CSR_RCCVREF", "CSR_UCVREF", "CSR_RCFRS", "CSR_RMVRC", "CSR_RCVLC", "CSR_RCvRFC", "CSR_UCVRFC", "CSR_RCNRL", "CSR_RCVSRL", "CSR_UCVRL", "CSR_RCCVRC", "CSR_RMVINC", "CSR_RCCVRFC", "CSR_RCVERINC", "CSR_RMvRL", "CSR_RCNLL", "CSR_RCFLL", "CSR_RMvRC", "CSR_RCvRC", "CSR_RCNRC", "CSR_RMVRS", "CSR_RCFLC", "CSR_RMvINC", "CSR_UCvRC", "CSR_RCVREF", "CSR_RCvRL", "CSR_RMvLC", "CSR_RCvLL", "CSR_RCVERRC", "CSR_RCvRS", "CSR_RCVINC", "CSR_RCVLL", "CSR_RCvREF", "CSR_RCFRL", "CSR_RMvLL", "CSR_RMVLL", "CSR_RCNLC"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_reply_ready(void *opaque)\n\n{\n\n    NbdClientSession *s = opaque;\n\n    uint64_t i;\n\n    int ret;\n\n\n\n    if (s->reply.handle == 0) {\n\n        /* No reply already in flight.  Fetch a header.  It is possible\n\n         * that another thread has done the same thing in parallel, so\n\n         * the socket is not readable anymore.\n\n         */\n\n        ret = nbd_receive_reply(s->sock, &s->reply);\n\n        if (ret == -EAGAIN) {\n\n            return;\n\n        }\n\n        if (ret < 0) {\n\n            s->reply.handle = 0;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* There's no need for a mutex on the receive side, because the\n\n     * handler acts as a synchronization point and ensures that only\n\n     * one coroutine is called until the reply finishes.  */\n\n    i = HANDLE_TO_INDEX(s, s->reply.handle);\n\n    if (i >= MAX_NBD_REQUESTS) {\n\n        goto fail;\n\n    }\n\n\n\n    if (s->recv_coroutine[i]) {\n\n        qemu_coroutine_enter(s->recv_coroutine[i], NULL);\n\n        return;\n\n    }\n\n\n\nfail:\n\n    nbd_teardown_connection(s);\n\n}\n", "idx": 18267, "substitutes": {"opaque": ["oppica", "opacement", "opica", "pacement", "psolete", "opsacement", "copaques", "opssolete", "copacement", "opsolete", "opus", " opica", "opaques", " opus", "popus", "popaque", "opsaque", "popica", " opga", "opsaques", "opga", "oppaque", "oppga", "paque", "copsolete", "paques", "copaque", "oppus", "popga"], "s": ["details", "ess", "g", "rs", "self", "sys", "c", "es", "comm", "sync", "fs", "params", "spec", "sis", "sl", "os", "ops", "t", "settings", "events", "sp", "qs", "S", "ss", "sts", "ps", "service", "https", "n", "ts", "ls", "parts", "aunts", "stats", "bis", "a", "ies", "services", "ds", "cs", "w", "Ws", "as", "sb", "ses", "changes", "als", "south", "sv", "sw", "session", "js", "j", "ssl", "states", "b", "has", "y", "hs", "p", "sq", "aws", "h", "is", "bs", "gs", "mos", "ns", "socket", "ties", "sports", "ats", "r", "less", "actions", "ims", "ms", "conf", "its"], "i": ["index", "ij", "l", "si", "ci", "p", "ki", "qi", "li", "ati", "is", "\u0438", "ri", "g", "I", " ii", "ai", "phi", "ity", "ori", "v", "di", "cli", "mi", "pi", "oi", "c", "iri", "in", "j", "xi", "ti", "jp", "ui", "iat", "gi", "n", "fi", "multi", "dim", "uri", "bi", "iy", "zi", "ini", "f", "it", "ix", "iu", "bis", "y", "ii", "m"], "ret": ["rm", " RET", "res", "nt", "pret", "t", "deg", "flag", "back", "ter", "desc", "dt", "result", "Ret", "ry", "rt", "ri", "tr", "mt", "v", "inter", "cont", "iter", "lt", "ft", " Ret", "sys", "cat", "RET", "mi", "re", "reset", "cmd", "ext", "try", "j", "att", "ref", "r", "val", "rets", "def", "fi", "alt", "del", "len", "net", "f", "it", "gt", "fun", "elt", "status", "red", "err"]}}
{"project": "FFmpeg", "commit_id": "5e5f75cf8abd76ada3011790a9b4f0762a72e41a", "target": 0, "func": "static void ffm_write_data(AVFormatContext *s,\n\n                           const uint8_t *buf, int size,\n\n                           int64_t pts, int header)\n\n{\n\n    FFMContext *ffm = s->priv_data;\n\n    int len;\n\n\n\n    if (header && ffm->frame_offset == 0) {\n\n        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;\n\n        ffm->pts = pts;\n\n    }\n\n\n\n    /* write as many packets as needed */\n\n    while (size > 0) {\n\n        len = ffm->packet_end - ffm->packet_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(ffm->packet_ptr, buf, len);\n\n\n\n        ffm->packet_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        if (ffm->packet_ptr >= ffm->packet_end) {\n\n            /* special case : no pts in packet : we leave the current one */\n\n            if (ffm->pts == 0)\n\n                ffm->pts = pts;\n\n\n\n            flush_packet(s);\n\n        }\n\n    }\n\n}\n", "idx": 18268, "substitutes": {"s": ["a", "ds", "cs", "os", "t", "w", "i", "p", "as", "sq", "aws", "h", "qs", "is", "e", "sv", "rs", "gs", "u", "S", "ss", "d", "v", "ns", "sts", "self", "ps", "sys", "js", "c", "ats", "r", "comm", "n", "o", "fs", "acs", "ts", "f", "serv", "sc", "b", "conf", "m"], "buf": ["mem", "xff", "offset", "cv", "Buff", "pos", "arr", "box", "window", "img", "bar", "text", "end", "vec", "cur", "tr", " buffer", "length", "queue", "bc", "off", "v", "bytes", "pb", "ptr", "bl", "read", "addr", "data", "cmd", "msg", "ref", "batch", "raw", "rb", "orig", "cb", "block", "uf", "buffer", "Buffer", "src", "buff", "b", "seq", "ff", "br"], "size": ["offset", "needed", "pos", "zone", "l", "z", "si", "window", "im", "sent", "total", "max", "sp", "num", "en", "ose", "set", "gz", "zero", "scale", "sum", "count", "g", "south", "empty", "shape", "padding", "length", "send", "name", "all", "scroll", "bytes", "capacity", "v", "area", "time", "any", "range", "msg", "ize", "storage", "body", "too", "message", "n", "number", "now", "space", "since", "Size", "notice", "SIZE", "cache", "type", "buffer", "small", "spec", "m"], "pts": ["portns", "pointts", "iptt", "colss", "psts", "portts", "pointrs", "fft", "ptxs", "ptss", "fonts", "ptts", "fontxs", "psns", "colts", "ffgs", "ointt", "pkgt", " ptsials", "prts", "pss", "oints", "fontts", "points", "ipts", "ointials", "ointxs", " ptst", "colxs", "iptds", "ports", "montds", "ctds", "iptss", "ptns", "ffs", "iptxs", "pkggs", " ptss", "ctgs", "pointns", "psrs", " ptt", "prss", "iptts", "monts", " ptials", "ptt", "pointss", "fontss", " ptxs", "montt", "pkgs", "portrs", "prs", "cts", " ptsxs", "ctts", "ptials", "cols", "ptds", "ptgs", "ctt", "montts", "ptrs", "prrs", "pkgts", "psss", "ffts"], "header": ["offset", "hidden", "frame", "debug", "cover", "check", "index", "error", "flag", "comment", "ck", "dt", "only", "required", "h", "layer", "shift", "gz", "empty", "virtual", "padding", "name", "dr", "head", "magic", "first", "half", "body", "forced", "Header", "headers", "table", "extra", "block", "heading", "buffer", "filter", "title", "version", "event", "border", "type"], "ffm": ["ffmc", "effmo", "fftm", "effmm", "fxm", "xffman", "ushmm", " ffg", "ffieldman", "ffnm", "effcm", "effm", "xffmac", "aftmc", "buffM", " ffms", "aftd", "xffg", "xffdm", "buffvm", "xffrm", "uffmc", "ffmd", "aftmd", "ffman", "ffieldcm", "xffnm", "flm", "xffarm", "ffieldnm", "effmt", "ffieldgm", "uffsm", "effM", " ffarm", "uffmo", "ffmm", "flM", "fxrm", "xffmanager", "uffdm", " ffwm", " ffmanager", "effdm", "ffgm", "buffms", "uffms", "ffieldm", "uffmd", "ffarm", "ufftm", "xffem", "uffmi", "effnm", "effmc", "uffmm", "ffieldmat", "ffem", " ffmac", "xffsm", "ffmanager", "uffv", "fferm", "aftm", "effd", "effsm", " ffmm", "uffmac", "effem", "ffv", "effrm", "uffM", "ffvm", "aftcm", " ffmi", "aftmt", "afttm", "effvm", "buffmi", "aftnm", "uffmt", "ffmo", "effmi", "flcm", "ffermm", "uffnm", "buffmo", " ffsm", "buffem", "buffarm", "xffm", "buffm", "ushtm", "ffrm", "effmat", "xffvm", "ffM", "fxsm", "ffersm", "ffsm", "ffms", "xffmi", "buffdm", "aftM", "uffg", "uffm", "fxgm", "buffmanager", "ffdm", "ushm", "uffwm", "ffmat", "xffgm", "uffmat", "fferwm", "effgm", "ffmac", "uffd", "ffg", " ffv", "uffgm", "flmd", "uffem", "uffman", "ffd", "ffcm", "buffv", "xffM", "ffieldem", "ushnm", "ffmi", "ffmt", "efftm", "uffcm", " ffdm", "ffwm"], "len": ["mem", "pos", "lp", "fl", "loc", "l", "el", "z", "lon", "deg", "els", "lib", "sp", "lf", "en", "ll", "enc", "gz", "li", "end", "le", "fil", "compl", "syn", "vec", "wid", "dl", " l", "il", "length", "split", "all", "fin", "ln", "bytes", "limit", "iter", "lt", "ler", "rev", "nl", "lit", "val", "L", "kl", "cmp", "str", "coll", "n", "lic", "lan", "del", "alt", "lim", "ls", "pl", "ld", "vol", "fun", "comp", "Len", "gen", "sl", "full", "elt", "seq", "hl"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n\n                struct vmsvga_cursor_definition_s *c)\n\n{\n\n    QEMUCursor *qc;\n\n    int i, pixels;\n\n\n\n    qc = cursor_alloc(c->width, c->height);\n\n    qc->hot_x = c->hot_x;\n\n    qc->hot_y = c->hot_y;\n\n    switch (c->bpp) {\n\n    case 1:\n\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,\n\n                        1, (void*)c->mask);\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/mono\");\n\n#endif\n\n        break;\n\n    case 32:\n\n        /* fill alpha channel from mask, set color to zero */\n\n        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,\n\n                        1, (void*)c->mask);\n\n        /* add in rgb values */\n\n        pixels = c->width * c->height;\n\n        for (i = 0; i < pixels; i++) {\n\n            qc->data[i] |= c->image[i] & 0xffffff;\n\n        }\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/32bit\");\n\n#endif\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\",\n\n                __FUNCTION__, c->bpp);\n\n        cursor_put(qc);\n\n        qc = cursor_builtin_left_ptr();\n\n    }\n\n\n\n    dpy_cursor_define(s->vga.ds, qc);\n\n    cursor_put(qc);\n\n}\n", "idx": 18272, "substitutes": {"s": ["hs", "ds", "cs", "states", "os", "l", "sl", "t", "p", "sb", "sp", "ses", "ins", "h", "is", "bs", "g", "south", "rs", "gs", "S", "ss", "d", "v", "sts", "ns", "ps", "sys", "sn", "js", "sd", "sports", "es", "r", "n", "ts", "ls", "f", "stats", "sc", "its"], "c": [" C", "con", "cv", "cs", "l", "tc", "t", "w", "p", "desc", "mc", "ec", "enc", "err", "ctx", "unc", "pc", "gc", "cl", "toc", "g", "cur", "config", "cf", "cc", "content", "ct", "bc", "d", "co", "v", "etc", "cd", "sec", "cont", "call", "com", "cmp", "lc", "cm", "dc", "C", "coll", "fc", "ce", "cod", "cu", "cache", "nc", "anc", "xc", "rc", "abc", "chain", "ac", "f", "arc", "cp", "sc", "b", "conf", "col", "m"], "qc": ["qcon", "qp", "checkc", "qucor", "checkpc", "dqgc", " qt", "quf", "aqp", "qdc", "qqfc", "qqpc", "qucon", "qlcache", "iqgc", "qut", "iqc", "qqcu", " qcs", "iqac", "eqfc", "dqcu", "querycu", " qp", "sqcon", "dqpc", " qfc", "qqcache", "sqt", "sqc", "questcs", "queryc", "qup", "sqlc", "iqpc", "qpc", "eqc", "qlc", "iqcache", "aqt", "sqcache", "qfc", "requcache", "requc", "qac", "sqcs", "qt", "qcr", "sqpc", "qucache", "checkcache", "iqf", "qlpc", "eqcache", "eqcu", "iqdc", "qcs", " qcr", "qr", "questc", " qcu", "qcu", "questcon", " qdc", "questlc", "qf", "checkcon", "dqcon", "sqgc", " qgc", "aqr", "dqlc", "querygc", "aqc", "querypc", "qqc", "sqf", "qur", "eqpc", " qcon", "qulc", "dqac", "questt", "iqcu", "eqdc", "dqcache", "questfc", "dqc", "qugc", "qupc", " qr", " qpc", "qqcr", "qqac", "requcu", "qgc", "questcache", "sqfc", "requcr", "qcache", " qcor", "qlcor", "qcor", " qcache", "quc"], "i": ["ic", "index", "ij", "si", "ci", "p", "ei", "ki", "qi", " ti", "me", "remote", "li", "ik", " pi", "is", "\u0438", "span", "ri", "g", "I", " ii", "u", "ai", "phi", "ity", "v", "di", "io", " mi", "iter", "ip", "PI", "mi", "pi", "my", "ind", "in", "id", "j", "xi", "oi", "ti", "batch", "ui", " ki", "gi", "o", "ji", "ami", "multi", "uri", "bi", "x", "ims", " si", "asi", " ni", "zi", "ini", "sim", " bi", "ms", "it", "ix", "iu", "y", "ii", "m"], "pixels": ["Polls", "piles", "spixels", " ports", "pix", "pports", "pips", " piles", "ppixels", " pix", "apixels", "ports", "paixels", "ppips", "miles", "aports", "aprows", "sports", "mixels", " prows", " pips", "prows", "spix", "Pairs", "sprows", " polls", "ppix", "Piles", "molls", " pairs", "paips", "mairs", "pairs", "Pixels", "paix", "apix", "polls", "paorts"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,\n\n                                          ptrdiff_t stride)\n\n{\n\n    int i;\n\n    pixel *pix = (pixel*)_pix;\n\n    const dctcoef *block = (const dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n    for(i=0; i<4; i++){\n\n        pixel v = pix[-1];\n\n        pix[0]= v += block[0];\n\n        pix[1]= v += block[1];\n\n        pix[2]= v += block[2];\n\n        pix[3]= v +  block[3];\n\n        pix+= stride;\n\n        block+= 4;\n\n    }\n\n}\n", "idx": 18279, "substitutes": {"_pix": ["_pich", " _spix", "_npix", "_cpixels", " _pile", "_cpip", "_cpich", "_pip", "_mpile", "_mpix", " _spip", "_mpip", "_jpixels", "_spip", " _spixels", "_npixels", " _pixels", "_spix", "_spile", "_cpix", "_npile", "_cpile", " _pip", "_jpix", "_spixels", "_pixels", "_mpixels", "_jpile", "_npich", " _spile", "_pile", "_jpich"], "_block": ["___list", "___group", " _type", "_group", " _Block", "_chain", "___block", "objgroup", "objblock", "_list", " _link", "___chain", "objchain", "objlist", "_Block", "_type", "_link"], "stride": ["shrice", "strimate", "strice", "shrope", "trope", " strride", "tride", "divope", "STRides", "divride", "sope", "shrimate", "Strride", "shride", "strope", "STRride", "Strice", "Strope", "STRide", "divice", " strimate", "sride", " strope", "trride", "side", "STRope", "divide", "trides", "simate", "Stride", "shrride", "divides", "strides", "strride"], "i": ["init", "ic", "index", "si", "t", "ci", " my", "p", "im", " n", "qi", " ti", "me", "q", "ki", "li", " pi", "is", "e", "g", "I", " ii", "ai", "phi", " multi", "out", "v", "di", " mi", "iter", "ip", "mi", "pi", "c", "ind", " j", "try", "j", "xi", "in", "id", "ti", "batch", "ui", "gi", "n", " I", "print", "multi", "bi", "x", " x", "asi", " m", " iter", "sim", "ini", " bi", "zi", "it", "iu", "ii", "m"], "pix": [" pig", "pixel", "pip", "spip", "publicond", "cpx", "px", " pixels", "cacheix", " pich", "cacheich", "cachefix", "opip", "spIX", " px", " pip", "pixels", "pil", "pig", "spond", "npixels", "pIX", "ipixel", "publicIX", " pixel", "cpig", "pcig", "ipil", "Pix", " pil", "opix", "opixels", "Pip", "cpix", "publicix", "opfix", "npfix", "Px", " pIX", "cpixel", "cpixels", "publicip", " pond", "pfix", "pich", "npix", "cacheIX", "opich", "npip", "spix", "pond", " pfix", "ipx", "pcix", "opIX", "cpil", "cpIX", "cpip", "Pixels", "cpfix", "pcfix", "pcx", "ipix"], "block": ["check", "snap", "offset", "pixel", "use", "word", "channel", "box", "none", "window", "Block", "proc", "list", "rule", "hash", "set", "zero", "cl", "lock", "point", "map", "link", "group", "name", "out", "band", "co", "unit", "wall", "label", "axis", "k", "bl", "bit", "c", "commit", "inv", "event", "record", "ref", "r", "sync", "field", "line", "tag", "join", "def", "version", "pack", "row", "bin", "buffer", "chain", "filter", "part", "b", "byte", "pen", "type"]}}
{"project": "qemu", "commit_id": "6ca8d0fd51154c37b571ea74dd0b3e7a60ab847a", "target": 0, "func": "static void set_proc_name(const char *s)\n\n{\n\n#ifdef __linux__\n\n    char name[16];\n\n    if (!s)\n\n        return;\n\n    name[sizeof(name) - 1] = 0;\n\n    strncpy(name, s, sizeof(name));\n\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n\n       This simple way is enough for `top'. */\n\n    prctl(PR_SET_NAME, name);\n\n#endif    \t\n\n}\n", "idx": 18282, "substitutes": {"s": ["a", "t", "w", "sb", "p", "sq", "h", "text", "is", "g", "sv", "rs", "gs", "S", "ss", "strings", "d", "ns", "v", "sts", "bytes", "ps", "js", "c", "in", "r", "str", "n", "space", "ts", "txt", "ls", "parts", "f", "names", "b", "y", "m"], "name": ["init", "mem", "cap", "word", "l", "ame", "size", "t", "window", "w", "p", "none", "sp", "num", "list", "array", "set", "base", "normal", "map", "prefix", "group", "Name", "out", "all", "ns", "v", "start", "mask", "self", "se", "data", "c", "id", "local", "new", "def", "str", "n", "path", "key", "cache", "info", "null", "nm", "type", "no", "al", "names", "code", "spec", "part", "NAME", "file", "class"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.type = NBD_CMD_FLUSH;\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n", "idx": 18285, "substitutes": {"client": ["con", "connection", "ic", "use", "server", "nt", "t", "window", "component", "close", "p", "cell", "controller", "store", "list", "qualified", "remote", "on", "public", "util", "cl", "core", "lock", "config", "prefix", "application", "node", "ct", "force", "co", "session", "cli", "web", "google", "plugin", "response", "http", "call", "conn", "manager", "service", "c", "cmd", "to", "collection", "master", "Client", "common", "parent", "template", "local", "current", "connect", "n", "complete", "cod", "cache", "network", "null", "open", "net", "api", "pattern"], "request": ["error", "have", "report", "enter", "shift", "setup", "header", "copy", "requ", "accept", " argument", "req", "common", "local", "art", "project", "attribute", "buffer", "import", "frame", "index", "input", "q", "set", " command", "initial", "command", "seek", "start", "response", "call", "reset", "update", "condition", "post", "complete", "Request", "open", "begin", "transfer", "ire", "task", " query", "question", "query", "load", "match", "address", " requested", "execute", "instance", "document", "order", "template", "quest", "print", "transform", "claim", "police", "consider", "QUEST", "require", "component", " attempt", "change", "public", "child", "application", "reference", "select", "push", "param", "cmd", "record", "batch", "message", "new", "current", "connect", "pair", "package", "forward", "type", "search", "parse", "create", "rule", " requesting"], "reply": ["next", "callback", " replies", "bill", "error", "apply", "back", "flag", "echo", "comment", "lib", "ish", "Reply", "result", "report", "query", "output", "onse", "replace", "sett", "prefix", "link", "rr", "match", "command", "queue", "force", "route", "response", "service", "mi", "related", "nl", "ror", "try", "msg", "r", "sync", "message", "relation", "ply", "table", " answer", " response", "job", "dict", "post", "repl", " replied", "notice", "reverse", "shell", "resp", "respond", "write", "part", "transfer", "bis", "proxy", "answer", "err"], "ret": ["mem", "lv", " RET", "round", "rm", "res", "arr", "nt", "pret", "t", "back", "flag", "deg", "desc", "ter", "num", "result", "ry", "err", "rt", "gc", "arg", "tmp", "mt", "nz", "out", "db", "tf", "ptr", "cont", "inter", "lt", "ft", "sys", "backed", "RET", "data", "re", "gb", "det", "ext", "j", "cmd", "ref", "r", "jp", "val", "et", "def", "print", "pat", "alt", "txt", "len", "net", "resp", "f", "fun", "gt", "elt", "status", "rets", "Ret"]}}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,\n\n                                      CL_TRUE,CL_MAP_READ, 0, buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(dst_buf, mapped, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18304, "substitutes": {"dst_buf": ["dest_buffer", "dst_map", "dst_uf", "dst_buff", "ddest_buf", "ddest_uf", "dest_buff", "dest_map", "ddest_buff", "dest_buf", "ddest_buffer", "dst_buffer"], "src_cl_buf": ["src_scl_uf", "src_cl_cv", "src_cl___buf", "src_scl_buf", "src_cl_buffer", "src_cl_buff", "src_cl__buf", "src_scl_buff", "src_cl__uf", "src_scl_buffer", "src_scl_cv", "src_scl_queue", "src_cl_queue", "src_cl__queue", "src_cl__buff", "src_cl___cv", "src_cl_uf", "src_cl___buffer", "src_cl___buff"], "buf_size": ["buf1len", " buf_fee", " buf_Size", "buf_SIZE", "uf2length", "uf2SIZE", "buf2size", "uf_SIZE", "buftSize", "buf1size", " buf_start", "uf2len", "uf2size", "buftstart", "buf2SIZE", "uf_len", "buf2length", "buf2len", "buf_Size", "buftsize", "buf1SIZE", "buf_start", "buf1length", "uf_length", "buf_len", "uf_size", "buf_length", "buf_fee"], "status": ["login", "error", "size", "format", "complex", "valid", "score", "ping", "details", "report", " score", " exists", "esp", "speed", "vis", "sync", " stat", " scr", "s", " success", "spec", "check", "index", " STAT", "Status", "atus", "t", "flag", "sp", "usage", "list", "result", "activation", "doc", "wa", "service", "msg", "json", " Status", "summary", "n", "complete", "confirmed", "stats", "code", "version", "err", "comments", " speed", "binding", "res", "console", "cgi", " count", "user", "html", "wait", "expr", " s", "prefix", " wait", "stat", "sw", "progress", "any", "warning", " j", " usage", "note", "arity", " resp", "str", "uses", "state", "source", "ssl", "xml", "scan", " error", "git", "p", " state", "gc", "count", " sw", " active", " spec", "success", "magic", "id", "record", "r", "current", "sim", " progress", "sql", "active", "ser", "type"], "mapped": [" map", "lap", "smap", "Maped", " maped", "mached", "Mapping", "map", "maped", "smaped", "Map", "mmapping", " mapping", "laped", "lapped", " mached", "mmaped", "Mapped", "smapped", "mmapped", "Mached", "mmached", "smapping", "lapping", "mapping"]}}
{"project": "FFmpeg", "commit_id": "ed9b2a5178d7a7c5a95694da3a808af327f36aff", "target": 1, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id > sc->stsd_count)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 18311, "substitutes": {"c": ["con", "cv", "cs", "tc", "l", "ca", "t", "ci", "p", "mc", "ec", "cn", "enc", "ctx", "pc", "e", "cl", "g", "cf", "config", "cc", "bc", "ct", "ch", "co", "v", "etc", "cd", "cont", "call", "cr", "lc", "cm", "dc", "C", "coll", "n", "fc", "ce", "cu", "cache", "nc", "anc", "com", "rc", "f", "abc", "ac", "conf", "m"], "pb": ["patch", "lp", "np", "tc", "dp", "pause", "px", "wp", "phy", "p", "pp", "sb", "bb", "emb", "sp", "proc", "tap", "asm", "amp", "ctx", "bp", "ub", "pc", "fb", "ob", "bs", "buf", "vp", "pan", "py", "tp", "bc", "pg", "pro", "bj", "conv", "db", "mb", "tf", "stab", "pel", "wb", "pm", "tab", "typ", "mp", "req", "PB", "pkg", "pt", "erb", "jp", "arb", "tk", "pack", "rb", "cb", "pl", "pa", "uf", "resp", "cp", "fp", "buff", "eb", "b", "conf", "lb"], "atom": ["b", "p", " orb", " cmd", " Atom", "orm", " ob", " p", "obj", " buf", " ab", " atoms", "um", "o", "x", "nm", " exc", " sp", " symb", " app", " err", " m", " nm", "om", " om", "m"], "st": ["stable", "t", "stra", "ist", "sh", "p", "sp", "th", "set", "ace", "sv", "tr", "ss", "ste", "stat", "ct", "mt", "so", "sw", "ch", "St", "sts", "start", "sec", "ft", "sn", "ocr", "cr", "inst", "std", "ust", "ST", "est", "sta", "str", "nd", "s", "rest", "src", "ut", "ost"], "sc": ["ctl", "Sc", "cs", "cv", "loc", "psc", "tc", "sch", "scl", "cgi", "can", "ci", "sh", "desc", "sp", "isc", "mc", "ec", "capt", "enc", "ctx", "set", "pc", "scale", "SC", "gc", "cl", "usc", "cam", "sci", "config", "craft", "ss", "cc", "bc", "ch", "sec", "esc", "soc", "sys", "asc", "sd", "uc", "scope", "sync", "cmp", "osc", "lc", "cm", "dc", "cer", "fc", "cu", "sche", "nc", "anc", "scrib", "rc", "scan", "ac", "comp", "spec"], "i": ["hi", "ski", "li", "span", "ri", "e", "I", "ai", "di", "iter", "mi", "s", "series", "multi", "ii", "index", "ij", "t", "ci", "q", "\u0438", "phi", "v", "cli", "pi", "try", "gi", "n", "fi", "bi", "x", "zi", "ini", "f", "it", "iu", "init", "ic", "l", "cgi", "ei", "qi", "me", " ii", "iq", "instance", "ip", "iri", "j", "ti", "ami", "uri", "info", " bi", "ix", "y", "m", "si", "im", "p", "ki", "h", "is", "ice", "oi", "in", "id", "ind", "xi", "batch", "ui", "ims", " ni", "sim", "ms"], "entries": [" entrants", "gentries", "entounters", "enties", "enounters", "entents", "entsry", " entents", "entrates", "Entlements", "entslements", "enrates", "questents", "Entrants", "entsriers", "entsrants", "Entires", " enties", "Entrys", "questries", "entresses", " entires", "centrys", "gentrys", "Entries", "enrys", "entires", "gentounters", "gentresses", "Entrates", "Entriers", "Entry", "entsresses", "entsents", "entriers", "entsires", "gentlements", " entrs", "entrants", " entrys", "entsries", "centries", "Entresses", "centies", "centents", "Entrs", " entriers", "entsrys", "Enties", "entlements", "gentry", "entry", "questrys", "entsies", "gentrates", "enries", "entrs", "Entounters", "Entents", "gentents", "questrs", "entrys"]}}
{"project": "FFmpeg", "commit_id": "8c013a9e55d9065793ef7ca6459d1178927a2b35", "target": 0, "func": "static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,\n\n                        uint32_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    char key[5]     = { 0 };\n\n    char *value;\n\n\n\n    size += (size & 1);\n\n\n\n    if (size == UINT_MAX)\n\n        return AVERROR(EINVAL);\n\n    value = av_malloc(size + 1);\n\n    if (!value)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, value, size);\n\n    value[size] = 0;\n\n\n\n    AV_WL32(key, tag);\n\n\n\n    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,\n\n                       AV_DICT_DONT_STRDUP_VAL);\n\n}\n", "idx": 18323, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "t", "p", "as", "sp", "sb", "sq", "h", "bs", "e", "g", "sv", "rs", "gs", "sa", "S", "ss", "so", "d", "ns", "v", "sts", "se", "ps", "sys", "sn", "sd", "c", "ats", "n", "ts", "ls", "stats", "b", "m"], "st": ["stable", "nt", "t", "ist", "sh", "sb", "sp", "xt", "th", "stream", "sm", "rt", "sv", "rs", "ss", "ste", "mt", "ct", "so", "stop", "sw", "St", "sts", "start", "se", "bl", "ast", "sn", "stack", "sth", "storage", "pt", "inst", "std", "ust", "ST", "str", "sta", "art", "ts", "bt", "nd", "rest", "src", "sc", "ut", "ost"], "tag": ["index", "error", "style", "ag", "format", "flag", "t", "at", "count", "op", "map", "match", "length", "prop", "stat", "tags", "name", "v", "reg", "attr", "kind", "feat", "cat", "TAG", "msg", "id", "field", "date", "Tag", "state", "attribute", "token", "len", "code", "type"], "size": ["grow", "offset", "pos", "mem", "index", "zone", "z", "style", "t", "slice", "total", "sent", "max", "p", "score", "sp", "num", "timeout", "ose", "set", "scale", "sum", "e", "count", "g", "empty", "sv", "shape", "length", "send", "name", "position", "scroll", "v", "capacity", "axis", "area", "fee", "sn", "time", "c", "ize", "storage", "scope", "height", "too", "message", "n", "number", "space", "Size", "dimension", "SIZE", "len", "year", "buffer", "small", "code", "status", "mode", "type"], "pb": ["td", "lp", "cv", "np", "tc", "dp", "p", "pp", "tx", "bb", "sb", "bh", "ctx", "ub", "bp", "pc", "bs", "vp", "tp", "pg", "bj", "aus", "pm", "ab", "cpp", "mp", "typ", "PB", "pkg", "pt", "xb", "jp", "pd", "tk", "cm", "ph", "gp", "rb", "cb", "pl", "pa", "uf", "cp", "fp", "eb", "b", "lb"], "key": ["index", "ek", "item", "ame", "Key", "list", "hash", "set", "option", " KEY", "sum", " Key", "map", "prefix", "link", "prop", "name", "label", "mask", "keys", "k", "ip", "attr", "param", "data", "id", "val", "str", "pair", "path", "x", "attribute", "row", "ac", "chain", "code", "title", "y", "KEY", "type"], "value": ["mem", "index", "ue", "word", "memory", "t", "w", "VALUE", "total", "window", "p", "valid", "var", "ready", "array", "result", "test", "port", "set", "end", "zero", "output", "buf", "sv", "tmp", "padding", "vp", "node", "length", "established", "values", "content", "Value", "name", "image", "position", "all", "v", "variable", "ve", "get", "instance", "iv", "description", "data", "json", "record", "available", "password", "version", "val", "message", "allowed", "new", "current", "state", "cache", "attribute", "null", "row", "entry", "buffer", "code", "tv", "text", "byte", "type"]}}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)\n\n{\n\n    int i, j;\n\n    for (i = 0; i < 5; i++) {\n\n        for (j = 0; j < 38; j++) {\n\n            in[i][j+6][0] = L[0][j][i];\n\n            in[i][j+6][1] = L[1][j][i];\n\n        }\n\n    }\n\n    if (is34) {\n\n        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);\n\n        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);\n\n        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);\n\n        for (i = 0; i < 59; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+32][j][0] = L[0][j][i+5];\n\n                out[i+32][j][1] = L[1][j][i+5];\n\n            }\n\n        }\n\n    } else {\n\n        hybrid6_cx(in[0], out, f20_0_8, len);\n\n        hybrid2_re(in[1], out+6, g1_Q2, len, 1);\n\n        hybrid2_re(in[2], out+8, g1_Q2, len, 0);\n\n        for (i = 0; i < 61; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+10][j][0] = L[0][j][i+3];\n\n                out[i+10][j][1] = L[1][j][i+3];\n\n            }\n\n        }\n\n    }\n\n    //update in_buf\n\n    for (i = 0; i < 5; i++) {\n\n        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));\n\n    }\n\n}\n", "idx": 18324, "substitutes": {"out": ["OUT", "base", "point", "copy", "conv", "one", "sys", "bit", "line", "cache", "bin", "net", "chain", "gen", "ex", "check", "os", "server", "t", "list", "result", "en", "set", "on", "ret", "sum", "output", "ot", "d", "v", "io", "response", "range", "up", "n", "o", "f", "it", "err", "init", "l", "box", "w", "comment", "soft", "user", "ne", "Out", "cut", "all", "co", "clean", "target", "to", "raw", "block", "no", "go", "write", "gt", "b", "m", "con", "outs", "p", "client", "h", "at", "public", "op", "off", "conn", "data", "cmd", "r", "pool", "new", "batch", "table", "ou", "our", "hit", "full", "over", "this", "file", "type"], "in": ["IN", "In", "and", "copy", "rin", "ad", "iter", "bit", "c", "inner", "line", "din", "cache", "bin", "pin", "ex", "serv", "mem", "use", "form", "el", "t", "en", "input", "list", "on", "nin", "sum", "ma", "v", "call", "up", "o", "n", "from", "al", "inn", "it", "inc", "old", "init", "ic", "l", "mm", "query", "isin", "all", "att", " IN", "um", "raw", "str", "act", "source", "info", "scan", "b", "m", "con", "im", "p", "ins", "h", "at", "is", "config", "ind", "id", "r", "vin", "new", "ac"], "L": ["LP", "In", "XL", "l", "LIN", "Line", "dL", "LD", "VL", "Out", "DL", "I", "G", "S", "J", "NL", "LB", "ln", "LM", "H", "LE", "B", "Layout", "M", "LL", "Q", "LI", "LS", "Long", "V", "FL", "W", "C", "LU", "R", "N", "LG", "BL", "List", "LC", "LT", "TL", "Li", "EL", "LR", "P", "F", "mL", "T", "LV"], "is34": ["Is34", "is32", "Is37", " is349", "sis37", "IS34", " is357", "IS357", "sis349", "sis32", "is37", "IS32", "is357", "IS37", " is32", "is349", " is37", "IS349", "Is357", "sis34", "Is32"], "len": ["size", "lon", "lib", "length", "conv", "ln", "iter", "den", "line", "ell", "del", "lim", "bin", "gen", "spec", "hl", "mem", "el", "lig", "en", "ret", "le", "level", "compl", "dl", "fail", "limit", "nn", "kl", "coll", "n", "lif", "ls", "al", "fun", "lis", "Len", "lin", "err", "fl", "init", "l", "nt", "mm", "ne", "il", "all", "nl", "cmp", "lan", "alt", "ail", "pos", "ll", "mil", "fin", "lit", "rot", "rel", "ref", "val", "coord", "vol", "full"], "i": ["iso", "z", "hi", "\u00ed", "ir", "li", "ri", "e", "ql", "I", "ai", "di", "iter", "mi", "ji", "er", "ib", "s", "multi", "ii", "index", "ij", "ci", "ish", "\u0438", "ite", "phi", "ma", "v", "io", "pi", "my", "gi", "o", "bi", "x", "zi", "ini", "f", "it", "ia", "iu", "status", "init", "ic", "l", "ei", "qi", "me", "ik", "aci", "iti", "iq", "ip", "iri", "ti", "um", "ami", "uri", "info", "by", "ie", "ix", "y", "m", "si", "im", "p", "ki", "at", "is", "u", "dr", "oi", "ind", "id", "xi", "ui", "batch", "ims", "sim", "api", "us", "this"], "j": ["z", "pr", "dt", "kj", "ge", "g", "fr", "je", "arg", "py", "jit", "di", "obj", "bl", "yy", "oj", "jp", "art", "ji", "er", "jump", "s", "ah", "yes", "ij", "el", "item", "adj", "q", "ja", "on", "jo", "em", "v", "io", "json", "my", "pt", "try", "ju", "n", "let", "aj", "bi", "qt", "it", "err", "jj", "l", "res", "jas", "user", "J", "ijk", "other", "reg", "k", "jl", "ip", "js", "to", "att", "note", "str", "by", "ie", "ix", "jc", "b", "y", "m", "next", "si", "im", "dj", "at", "xy", "bo", "uj", "ng", "bj", "dr", "ind", "rel", "r", "job", "key", "sim", "this", "br"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n", "idx": 18326, "substitutes": {"f": ["a", "fd", "l", "t", "i", "p", "lf", "h", "q", "fb", "e", "fr", "cf", "v", "fe", "tf", "ef", "c", "j", "r", "fo", "def", "file", "o", "bf", "fi", "df", "fs", "fc", "af", "fw", "uf", "fp", "rf", "F", "b", "ff", "m"], "limit": ["use", "Lim", "size", "format", "limits", "max", "timeout", "Limit", "port", "base", "scale", "util", "lock", "mission", " policy", "cut", "length", "force", "control", "capacity", "value", "bit", "pi", "allow", "target", "lit", "pool", "condition", "local", "line", "join", "lim", "block", "tail", "rate", "len", "entry", "buffer", "policy", "it", "limited"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n", "idx": 18329, "substitutes": {"v": ["vi", "cv", "l", "w", "vim", "i", "p", "vt", "q", "h", "av", "g", "sv", "vp", "u", "vc", "conv", "d", "gov", "uv", "vs", "vm", "iv", "c", "inv", "j", "vy", "r", "ev", "vu", "V", "view", "vr", "f", "tv", "b", "m"], "name": ["a", "missing", "word", "error", "ame", "san", "t", "w", "none", "valid", "p", "false", "var", "num", "required", "q", "err", "known", "g", "prefix", "length", "lat", "Name", "unknown", "named", "ma", "old", "wa", "data", "c", "in", "id", "j", "common", "local", "new", "val", "def", "str", "n", "path", "nan", "key", "nm", "null", "no", "broad", "names", "NAME", "spec", "code", "nam", "type"], "obj": ["pos", "nt", "arr", "res", "ok", "img", "pr", "enc", "ctx", "bo", "expr", "ob", "tmp", "out", "ox", "off", "attr", "self", "object", "addr", "js", "pkg", "pt", "inv", "ref", "val", "Obj", "str", "obs", "o", "act", "ack", "cb", "elt", "resp", "vol", "ool", "objects", "err"], "errp": ["errpen", "ererpen", "iterp", " ErrP", " errpa", "iterpre", " Errpb", "errorp", " errpb", "errpb", " errpen", "errorP", "ererP", "errjp", "rrpre", " Errpen", "errpa", " errjp", "errpre", "ererpb", "ErP", "Erjp", " Errp", "Erpa", "rrp", "errorpa", "ererp", "errorjp", "iterP", "Erp", "errP", " errpre", "rrP", " errP"], "qiv": ["sqiov", "qiver", "dqiov", "quiv", "sqiv", "quiver", "dqiver", "quir", "qir", "quiov", "dqiv", " qir", "sqiver", " qiter", "sqliv", "quiter", "qiov", "sqir", " qiver", "quliv", "sqiter", "dqliv", "qliv", "qiter"], "qobj": ["quertmp", "questrect", " qObj", "querso", "qqobj", "qqnt", "qso", "quobo", "iqso", "questso", "qobject", "quickobo", "quickObj", "eqbool", "qrect", "dqobj", "iqobj", "qqbool", "qobo", "qbis", " qobject", "eqbis", "qtmp", "quobject", "qqbis", "iqrect", "iqtmp", "qObj", "quObj", "dqnt", "eqobj", "qnt", "querrect", "quickobj", "dqbool", " qobo", "eqnt", "questtmp", "questobj", "quobj", "dqbis", "querobj", "quickobject"], "qbool": ["qubis", "sqbinary", "qubool", "qubit", "dqool", "sqbool", "qubo", "qubinary", "sqint", "dqbinary", " qnull", "sqbis", "sqobj", " qint", "aqbo", "aqbool", "qnull", "qunull", "sqool", " qbit", " qbo", "aqbit", " qfloat", "qbis", " qbis", "qufloat", "aqbis", "quint", "qool", "aqfloat", "qbit", "qint", "qbinary", "quconv", "quool", "aqnull", "dqbool", "qbo", "dqfloat", "quobj", "sqfloat", "qconv", "aqconv", " qconv", "qfloat"]}}
{"project": "qemu", "commit_id": "860643bc5aa902f9b736c57b66e301ef08a2b68e", "target": 0, "func": "int kvm_arch_get_registers(CPUState *cs)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_one_reg reg;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    int i, r;\n\n\n\n    /* get the PSW */\n\n    env->psw.addr = cs->kvm_run->psw_addr;\n\n    env->psw.mask = cs->kvm_run->psw_mask;\n\n\n\n    /* the GPRS */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->regs[i] = cs->kvm_run->s.regs.gprs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->regs[i] = regs.gprs[i];\n\n        }\n\n    }\n\n\n\n    /* The ACRS and CRS */\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = cs->kvm_run->s.regs.acrs[i];\n\n            env->cregs[i] = cs->kvm_run->s.regs.crs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = sregs.acrs[i];\n\n            env->cregs[i] = sregs.crs[i];\n\n        }\n\n    }\n\n\n\n    /* The prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        env->psa = cs->kvm_run->s.regs.prefix;\n\n    }\n\n\n\n    /* One Regs */\n\n    reg.id = KVM_REG_S390_CPU_TIMER;\n\n    reg.addr = (__u64)&(env->cputm);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_CLOCK_COMP;\n\n    reg.addr = (__u64)&(env->ckc);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_TODPR;\n\n    reg.addr = (__u64)&(env->todpr);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    if (cap_async_pf) {\n\n        reg.id = KVM_REG_S390_PFTOKEN;\n\n        reg.addr = (__u64)&(env->pfault_token);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFCOMPARE;\n\n        reg.addr = (__u64)&(env->pfault_compare);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFSELECT;\n\n        reg.addr = (__u64)&(env->pfault_select);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18344, "substitutes": {"cs": ["asks", "hs", "ds", "checks", "acts", "times", "tc", "ys", "bits", "ck", "ras", "ins", "yes", "ics", "cases", "otes", "ks", "ands", "ctx", "cons", "ars", "pc", "qs", "bs", "icas", "rics", "ares", "cas", "cing", "caps", "rs", "cf", "ips", "cc", "ces", "ports", "sts", "ns", "cells", "vs", "ps", "js", "ants", "c", "css", "ances", "ats", "cms", "Cs", "comm", "cks", "fs", "act", "fc", "acs", "ce", "ts", "actions", "ims", "ls", "parts", "cus", "s", "cp", "rc", "CS", "ms", "wcs", "icks", "ows", "sc"], "cpu": ["mem", "os", "nic", "linux", "ck", "p", "proc", "ork", "ctx", "base", "pc", "core", "gc", "util", "setup", "node", "pu", "ka", "tp", "cc", "hw", "clock", "vm", "nn", "instance", "sys", "c", "mx", "bench", "processor", "gpu", "upt", "arch", "x", "cp", "CPU", "CP", "boot", "task", "process"], "env": ["export", "dt", "enter", "door", "ctx", "e", "nel", "email", "vs", "obj", "gear", "era", "ee", "ens", "manager", "den", "context", "eu", "er", "shell", "player", "ah", "buffer", "Environment", "environment", "cv", "here", "el", "server", "desc", "en", "app", "eni", "end", "nv", "em", "v", "ew", "response", "estate", "dev", "ent", "entry", "event", "worker", "ov", "console", "ei", "query", "enc", "ner", "esm", "actor", "queue", "uv", "ef", "operator", "ev", "runner", "erd", "viron", "eve", "txt", "dn", "window", "stage", "ec", "ende", "equ", "builder", "engine", "db", "web", "esc", "ve", "outer", "conn", "ext", "et", "message", "eps", "editor", "eh", "oe"], "reg": ["mem", "res", "or", "disc", "var", "proc", "num", "win", "set", "ret", "g", "link", "group", "Reg", "rec", "rep", "istry", "re", "ref", "tag", "gr", "leg", "row", "net", "s", "col", "ig"], "sregs": ["sremrs", " sstatls", "sregisterj", "sregisterid", "sregls", "sregj", " sregj", " sregts", "srenda", " srends", " sregrs", " sregid", " sregches", " srendjs", "srendcs", "sgraphches", "sreams", "sreamd", " sstats", " sregls", "sgraphs", "sstatrs", "sregd", "smemjs", "sremts", "sstatjs", "sstatls", "sreamid", "srendls", "smema", "sstats", "srends", "sregches", " srenda", "sgraphrs", "sregid", " sstatjs", "sremcs", "sregisterd", "srems", "srendts", "sstatches", " sregjs", " srendls", " sregcs", " sstatts", " sstatrs", "sregts", "srega", "smems", " sstatches", " sregd", " sstatcs", "srendjs", "sremls", "srema", "sgraphls", " srega", "sregisters", "sregcs", "sregjs", "sremches", "sregrs", "sstatcs", "sstatts", "sreamj", "sremjs", "smemls"], "regs": ["privs", "replns", "logts", "registers", "defs", "ress", "redd", "redts", "logs", "recjs", "rems", "REGs", "recs", "reds", "regns", "registerjs", "mgains", "REGes", "gregts", "remts", "refs", "defservices", "Regs", "roundjs", "locrs", "regrs", "repls", "remservices", "replers", "resers", "gregservices", "patterns", "reljs", "regins", " regins", "relss", "prives", "refrs", "logd", "patternservices", "roundains", "regers", "prs", "regd", " regservices", " regd", "regains", "prrs", "recss", "regservices", " regers", "logss", "regss", "privers", "locS", " regss", "Regrs", "replrs", " reges", "mgs", "regjs", "refS", "prers", "gregins", "RegS", "rels", "locs", "Regss", "regies", "prns", "defies", "remins", "REGers", "Regjs", " regts", "mgjs", "regS", "patternies", "registerains", "roundies", "resns", "rounds", "resrs", "redss", "reges", "gregs", "regts", "roundservices"], "i": ["iso", "hi", "ski", "li", "span", "ri", "e", "ni", "point", "I", "ai", "di", "mi", "c", "inner", "ji", "er", "chain", "ex", "multi", "ii", "index", "ij", "t", "ci", "menu", "list", "q", "\u0438", "phi", "v", "cli", "io", "json", "pi", "try", "parent", "gi", "fi", "bi", "x", "zi", "ini", "it", "iu", "a", "init", "ic", "ei", "qi", "me", " ii", "prefix", "iq", "ip", " j", "iri", "j", "ti", "ami", "uri", "source", "info", "ie", "ix", "y", "m", "history", "si", "im", "p", "client", "ki", "at", "remote", "is", "dr", "oi", "ind", "in", "xi", "batch", "ui", "key", "sim", "sql", "this"], "r": ["debug", "rm", "error", "res", "l", "ur", "or", "arr", "w", "p", "term", "result", "q", "ir", "ry", "ar", "kr", "h", "hr", "rt", "ret", "ri", "e", "adr", "g", "fr", "resource", "mr", "rs", "run", "rr", "d", "v", "attr", "dr", "rar", "rem", "lr", "rd", "reset", "re", "c", "cr", "try", "record", "rel", "j", "str", "n", "R", "rg", "usr", "repl", "er", "rb", "sr", "rate", "nr", "entry", "rc", "vr", "f", "it", "b", "br", "err", "m"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n    QemuOpts *opts;\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            /* add the device */\n\n            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n            qemu_opt_set(opts, \"driver\", p);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 18345, "substitutes": {"p": ["a", "lp", "l", "t", "w", "pr", "ping", "pp", "sp", "q", "h", "bp", "pc", "e", "g", "point", "op", "vp", "tp", "d", "rep", "v", "pb", "k", "ps", "c", "pkg", "j", "r", "jp", "n", "o", "pat", "path", "pair", "x", "pa", "s", "cp", "f", "pattern", "it", "fp", "pe", "P", "b", "ap", "m"], "model": ["lv", "Model", "details", "controller", "report", "ml", "handler", "tree", "email", "mb", "self", "manager", "mi", "comm", "local", "relation", "project", "er", "module", "pattern", "dem", "spec", "database", "bm", "form", "el", "server", "where", "app", "port", "sm", "domain", "device", "lock", "virtual", "link", "em", "activity", "re", "entry", "view", "mode", "mm", "mod", "method", "dm", "master", "models", "transform", "info", "xml", "machine", "sample", "m", "man", "morph", "client", "cell", "store", "mail", "ll", "core", "config", "map", "save", "image", "db", "vm", "ve", "data", "record", "message", "member", "table", "lc", "job", "sim", "rule"], "opts": ["ioptions", "attns", "ops", "iopps", "OPts", " optte", "OPtions", "OPps", "opns", "OPns", "attte", "optorts", "attorts", " optts", "optts", "optte", "opte", "roptions", "options", " optns", "ropps", "rops", "attts", "opps", "oports", "optns", " optorts", "iopts", "iops", "iopns", "OPs", "ropts", "optps"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);\n\n    VirtQueueElement elem;\n\n    MemoryRegionSection section;\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t offset = 0;\n\n        uint32_t pfn;\n\n\n\n        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {\n\n            ram_addr_t pa;\n\n            ram_addr_t addr;\n\n            int p = virtio_ldl_p(vdev, &pfn);\n\n\n\n            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;\n\n            offset += 4;\n\n\n\n            /* FIXME: remove get_system_memory(), but how? */\n\n            section = memory_region_find(get_system_memory(), pa, 1);\n\n            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))\n\n                continue;\n\n\n\n            trace_virtio_balloon_handle_output(memory_region_name(section.mr),\n\n                                               pa);\n\n            /* Using memory_region_get_ram_ptr is bending the rules a bit, but\n\n               should be OK because we only want a single page.  */\n\n            addr = section.offset_within_region;\n\n            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,\n\n                         !!(vq == s->dvq));\n\n            memory_region_unref(section.mr);\n\n        }\n\n\n\n        virtqueue_push(vq, &elem, offset);\n\n        virtio_notify(vdev, vq);\n\n    }\n\n}\n", "idx": 18351, "substitutes": {"vdev": ["svpad", "vchw", "evdevice", "vdb", "mev", "vdevice", "vhw", "svdev", "vmdevice", "vmdev", "vcdevice", " vhw", "vDev", " vdevice", " vpad", "tdevice", "wpad", "vpad", "evdev", "wDev", "evobj", " vDev", "mdev", "svhw", "vmdb", "vccam", "tcam", "vcdev", "tobj", "thw", "svDev", "wev", " vev", "tdev", " vcam", "mdevice", "mhw", "wdev", "svdevice", "svev", "evdb", "vev", "vmobj", "tdb", "vcam", "vobj"], "vq": ["evque", "svqueue", " vue", "vdq", "vrqueue", "evqq", "vsqs", "vsque", "vque", "mqueue", "vrq", "svdq", "invue", "vsq", " vdq", "svch", " vch", "svque", "svq", "mch", "viq", "hue", "evq", "mdq", "evqs", "nvque", "nvq", "nvqs", "fq", "invqueue", "fue", " vqueue", " vque", "mq", "inviq", "fqueue", "mue", "vriq", "fque", "vue", "vqq", "nvqq", "hqs", "svqs", "hq", "svue", "hdq", "invq", " vqs", "vqs", "vrue", "vsqq", "vqueue", "vch", "miq"], "s": ["hs", "ds", "t", "w", "sb", "sp", "sq", "h", "sm", "qs", "is", "bs", "e", "g", "sv", "rs", "gs", "S", "ss", "d", "sw", "ns", "sts", "self", "ps", "sys", "sn", "service", "js", "c", "sbm", "r", "o", "n", "fs", "state", "ts", "ls", "stats", "spec", "b", "m"], "elem": ["gelem", "veleg", "elete", "gelete", "oelems", "selems", "melement", "velev", "lem", " elems", " element", "oelement", " em", " elev", "elelements", "elementlement", "melem", "melements", "lelems", "selement", "velem", "ielete", "eelement", "lelem", "elelement", "em", "eelem", "Elems", "eleleg", "sem", "eelems", "elelems", "lelement", "ielem", "gelements", "elementlem", " eleg", "eleg", "selem", "element", "elems", "velement", "Element", "gelement", "ielement", "elements", "elementlev", "eelements", "Elev", "ielements", "elelem", "elementlems", "elelev", "melete", "oelem", "Elem", "oelev", "elev", "lelements"], "section": ["division", "lp", "size", "definition", "test", "journal", "option", "point", "header", "length", "step", "se", "region", "Section", "page", "account", "line", "context", "relation", "module", "day", "spec", "mem", "connection", "index", "port", "set", "mr", "second", "sec", "tab", "service", "description", "container", "parent", "sections", "sector", "entry", "part", "mode", "sam", "setting", "comment", "layer", "sect", "mod", "prefix", "profile", "group", "ment", "name", "instance", "j", "side", "element", "tower", "state", "block", "row", "man", "m", "character", "p", "library", "position", "area", "r", "pool", "tag", "portion", "member", "table", "pair", "key", "function"], "pfn": ["npfn", "Pfn", " pfl", "pdn", "Pfc", "pnfl", " pn", "npsn", "pnfn", "pnfc", "ppfn", "ppdn", " pdn", " pfm", " pfc", "Pfl", " psn", "ffn", "pnfunc", "npdn", "pfm", "Pfunc", "jpdn", "pfc", "pfl", "psn", "pfunc", "jpn", "fdn", "ffm", "ppfc", "ffc", "pn", " pfunc", "jpfn", "ppfm", "npn", "jpsn"], "pa": ["na", "offset", "lp", "ca", "ta", "pr", "p", "sb", "ha", "pc", "ppa", "adr", "ape", "sa", "pan", "address", "rep", "ma", "pb", "ptr", "wa", "ps", "pm", "ada", "pet", "mp", "pi", "Pa", "pha", "jp", "pair", "PA", "apa", "pas", "fa", "pse", "ppo", "par", "pn", "eta", "ota", "arp", "fp", "pe", "ia", "po", "pai", "ap"], "addr": ["offset", "a", "pos", "au", "index", "mem", "am", "loc", "np", "ord", "pad", "p", "amp", "tx", "aff", "asm", "at", "port", "ha", "ctx", "ress", "adr", "ace", "point", "map", "prefix", "ai", "mt", " address", "ad", "address", "inter", "ptr", "dr", "attr", "ip", "add", "wd", "pkg", "ref", "r", "art", "sha", "align", "act", "alias", "x", "oa", "Address", "arp", "url", "ia", "ix", "ap", "hop", "m"]}}
{"project": "FFmpeg", "commit_id": "5602a464c9f9e3c0922f5cfeccaf2fa1c40b2401", "target": 0, "func": "static av_cold int vorbis_decode_init(AVCodecContext *avccontext)\n\n{\n\n    vorbis_context *vc = avccontext->priv_data;\n\n    uint8_t *headers   = avccontext->extradata;\n\n    int headers_len    = avccontext->extradata_size;\n\n    uint8_t *header_start[3];\n\n    int header_len[3];\n\n    GetBitContext *gb = &vc->gb;\n\n    int hdr_type, ret;\n\n\n\n    vc->avccontext = avccontext;\n\n    ff_dsputil_init(&vc->dsp, avccontext);\n\n    ff_fmt_convert_init(&vc->fmt_conv, avccontext);\n\n\n\n    if (avccontext->request_sample_fmt == AV_SAMPLE_FMT_FLT) {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_FLT;\n\n        vc->scale_bias = 1.0f;\n\n    } else {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_S16;\n\n        vc->scale_bias = 32768.0f;\n\n    }\n\n\n\n    if (!headers_len) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata missing.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = avpriv_split_xiph_headers(headers, headers_len, 30, header_start, header_len)) < 0) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata corrupt.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[0], header_len[0]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 1) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"First header is not the id header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_id_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Id header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[2], header_len[2]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 5) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Third header is not the setup header.\\n\");\n\n        vorbis_free(vc);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_setup_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Setup header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    if (vc->audio_channels > 8)\n\n        avccontext->channel_layout = 0;\n\n    else\n\n        avccontext->channel_layout = ff_vorbis_channel_layouts[vc->audio_channels - 1];\n\n\n\n    avccontext->channels    = vc->audio_channels;\n\n    avccontext->sample_rate = vc->audio_samplerate;\n\n    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2;\n\n\n\n    avcodec_get_frame_defaults(&vc->frame);\n\n    avccontext->coded_frame = &vc->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18371, "substitutes": {"avccontext": ["avincoconst", "avccxonvert", "avccyntext", "avfconect", "avincocontext", "avccrontext", "avccyncontext", "avcconcontext", "avckantext", "avccoonstant", "avacconconstruct", "avccaxonload", "avccystruct", "avcusontxt", "avscocontext", "avcfaconject", "avcconest", "avckonystruct", "avcconsstruct", "avcusanontxt", "avccxonload", "avcconeject", "avcfonnect", "avccytext", "avfconject", "avctontext", "avccxonstruct", "avcconTEXT", "avccxonconnection", "avCConect", "avccontect", "avcconload", "avccencert", "avacconenconnection", "avccondposition", "avcconcert", "avccanload", "avccyject", "avcconcurrent", "avckoncurrent", "avcccontext", "avcconscontext", "avfconvert", "avpconkey", "avccxonsole", "avccONcert", "avccronconstruct", "avctontcurrent", "avccencurrent", "avcconsload", "avCConstext", "avCConscontext", "avctoncurrent", "avinconject", "avckonytext", "avcconencontext", "avccoretext", "avccoonkey", "avccnontext", "avcusontext", "avaccacontext", "avcconytext", "avcconport", "avccanoncert", "avccancurrent", "avacconentext", "avincoconject", "avccontxt", "avccaxonsole", "avccondsole", "avccanontext", "avccanonect", "avccontex", "avCContext", "avaccaconect", "avccONtxt", "avpcoonkey", "avccONtext", "avcconystruct", "avccrystruct", "avccacontxt", "avccnonstant", "avaccaconstant", "avccxonect", "avccantxt", "avcconsect", "avcconvert", "avccoconject", "avacconcert", "avcconyload", "avctonect", "avccryload", "avcusanonstant", "avcfacontxt", "avccacontext", "avcconsole", "avccaconect", "avccoretxt", "avckontxt", "avccONect", "avcfenstant", "avccONconnection", "avckontext", "avscoconstant", "avccocontex", "avccenect", "avfcronvert", "avcccontxt", "avcusanontext", "avckonject", "avccaonposition", "avcconentext", "avaccontext", "avcconencert", "avcconnect", "avccaonsole", "avccONstruct", "avpconstant", "avcconeconstruct", "avcfontext", "avfcronstruct", "avacconconnection", "avcconfig", "avctonttext", "avcfonject", "avccenstruct", "avccronTEXT", "avccoreject", "avinconst", "avccryport", "avcconstant", "avccronvert", "avccnontxt", "avcconetxt", "avccaconkey", "avccenject", "avpcontext", "avscontex", "avcconposition", "avccanontxt", "avcconst", "avccronstant", "avccronect", "avpcoonstant", "avccronfig", "avccontct", "avccONvert", "avctontect", "avccyntex", "avccynstant", "avccrytext", "avccoontext", "avccaxontext", "avpconfig", "avincontext", "avccontcurrent", "avccONTEXT", "avckonload", "avfconstruct", "avcconeect", "avscontext", "avccontcontext", "avccanonnect", "avccconject", "avctontct", "avcconkey", "avfcrontext", "avcfonstruct", "avccnoncert", "avccondtext", "avcfentext", "avccaconconstruct", "avckonstruct", "avccxontext", "avfconfig", "avacconencert", "avcconstext", "avccontnect", "avfcenstruct", "avccyntxt", "avcconsport", "avsconcontext", "avccanposition", "avckancurrent", "avckonyload", "avacconect", "avpcoontext", "avccocontext", "avcconyport", "avcconct", "avccoconst", "avcfenTEXT", "avccxoncert", "avcfaconnect", "avincocontxt", "avcconstex", "avincontxt", "avccansole", "avfcenject", "avccaxonposition", "avcusonstant", "avcconconstruct", "avccanonstant", "avcconttext", "avccynject", "avcconect", "avccenct", "avcconenconnection", "avccondload", "avckantxt", "avacconcontext", "avccenstant", "avcfonTEXT", "avccoconcontext", "avccONcontext", "avCConnect", "avccyfig", "avccenTEXT", "avccorest", "avccONct", "avccaconfig", "avcconsstant", "avctonct", "avccyncurrent", "avccONstant", "avccONfig", "avscocontex", "avcconsnect", "avccconnect", "avcusanoncert", "avccaonload", "avccentext", "avcfacontext", "avccxoncontext", "avccxonposition", "avccaconnect", "avccocontxt", "avcconestant", "avccanoncontext", "avfcenfig", "avccenfig", "avpcoonfig", "avccentxt", "avfcentext", "avCConcontext", "avccaontext", "avckonport", "avccoonfig", "avccONject", "avscoconcontext", "avsconstant", "avcfontxt", "avcconstruct", "avccronstruct", "avccanject", "avfcronect", "avacconencontext", "avCConsnect", "avcusoncert", "avckonyport", "avcfonstant", "avcconconnection", "avccONcurrent", "avCConsect", "avcconetext", "avccoconstant", "avccantext", "avccONnect", "avccaconstant", "avacconstant", "avckanject", "avaccaconconstruct", "avcfenstruct", "avcconject", "avccronkey", "avfcontext", "avccaconject"], "vc": ["vi", "lp", "lv", "ctx", "rt", "av", "vp", "wl", "conv", "vs", "obj", "ee", "vg", "c", "inv", "ell", "dc", "ce", "ib", "bt", "xc", "serv", "cv", "form", "csv", "var", "bb", "vet", "irm", "nv", "ct", "WC", "v", "etc", "voc", "ctrl", "coll", "fc", "cu", "vr", "ic", "cs", "nt", "ow", "voice", "vec", "sv", "ht", "cf", "cc", "bc", "ch", "uv", "verb", "att", "ev", "act", "VC", "cp", "rc", "fax", "vd", "cow", "vl", "vt", "ll", "ec", "pc", "gc", "vm", "ve", "cmd", "vy", "von", "lc", "bank", "vv", "vol", "vine"], "headers": ["ds", "boxes", "blocks", "bits", "ers", "bys", "h", "lines", "frames", "tops", "qs", "html", "users", "pres", "rs", "header", "files", "cells", "bytes", "keys", "dr", "builders", "vers", "types", "ppers", "ids", "codes", "workers", "writers", "ints", "hands", "parts", "images", "ilers", "names", "heads", "aches", "ters", "items", "drivers"], "header_start": ["header_pos", "header08no", "header_try", "header08start", "header67start", "question_no", " header_open", "header0init", " header_pos", "query_step", "question_pos", "header0start", "query_try", "header_step", "query_start", "header_end", "header_open", "header08pos", "question_error", "header0try", "question_start", " header_end", "header5step", "header_init", "question08start", "header5start", "header_no", "header67no", "header0step", "header_error", "header67pos", "question08no", "header5init", "header67error", "question08error", "query_init", "header08error", "question08pos", "header5try"], "header_len": ["headerLleft", "sector_alt", "header_seq", "history_left", "head_lon", "head2lim", "headerLlen", "history_nos", "header67seq", "headerJlim", "headerLmult", "sector67seq", "code_left", "sector_len", "history___nos", "header2lim", "headerLenleft", "headerJlon", "header_mult", "headerJleft", "header_lim", "header___last", "sector_val", "head2len", "header_lon", "code_last", "header2elt", "history___left", "header_alt", "headerJle", "history_len", "header67val", "header33val", "headerLenmult", "header_left", "codeLenleft", "header___le", "headerJnos", "header___left", "headerJelt", "header67len", "header___len", "header67le", "headerLenlen", "header___nos", "sector_seq", "header_le", "header_val", "codeLenmult", "code_mult", "head_lim", "head_len", "header___mult", "codeLenlen", "head2lon", "sector67alt", "sector67val", "head2elt", "codeLenlast", "header67left", "head_elt", "header_nos", "header67nos", "header2lon", "history___len", "headerLlast", "history___le", "header_elt", "history_le", "header33seq", "code_len", "sector67len", "header2len", "headerLenlast", "headerJlen", "header33alt", "header_last", "header33len", "header67alt"], "gb": ["bm", "cv", "ds", "sg", "img", "gio", "git", "sb", "bb", "gif", "ctx", "rect", "pc", "gc", "bs", "g", "Gb", "gnu", "gs", "kb", "py", "bg", "GB", "mb", "db", "pg", "vm", "wb", "sys", "vg", "nb", "hub", "storage", "yg", "gg", "gy", "cfg", "gpu", "bf", "rg", "rb", "ib", "gp", "gd", "cb", "bt", "tg", "gu", "uf", "gm", "eg", "gt", "eb", "vd", "bn"], "hdr_type": ["hdr_Type", "hdr_name", "hdr__TYPE", "hDR_ty", "hDR_TYPE", "hdr_TYPE", "hr_name", "hdr__type", "hdr_length", "hdr8Type", "hDR_length", "hdr_ty", "hDR_type", "hr_len", "hdr__Type", "hr_Type", "hdr__length", "hdr8len", "hdr8name", "hDR_Type", "hdr_len", "hr_type", "hdr8type"], "ret": ["mem", "rm", "mel", " RET", "res", "nt", "deg", "back", "flag", "ter", "result", "ll", "Ret", "mail", "ry", "end", "ern", "rt", "gc", "ber", "tr", "mt", "out", "reg", "tf", "progress", "ft", "value", "rem", "success", " Ret", "RET", "rev", "re", "reset", "det", "sys", "try", "att", "ref", "val", "rets", "def", "print", "usr", "alt", "txt", "len", "cert", "resp", "gt", "fun", "it", "url", "elt", "status", "err"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n\n{\n\n    int len;\n\n    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;\n\n\n\n    if (block_mig_state.zero_blocks &&\n\n        buffer_is_zero(blk->buf, BLOCK_SIZE)) {\n\n        flags |= BLK_MIG_FLAG_ZERO_BLOCK;\n\n    }\n\n\n\n    /* sector number and flags */\n\n    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)\n\n                     | flags);\n\n\n\n    /* device name */\n\n    len = strlen(bdrv_get_device_name(blk->bmds->bs));\n\n    qemu_put_byte(f, len);\n\n    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);\n\n\n\n    /* if a block is zero we need to flush here since the network\n\n     * bandwidth is now a lot higher than the storage device bandwidth.\n\n     * thus if we queue zero blocks we slow down the migration */\n\n    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {\n\n        qemu_fflush(f);\n\n        return;\n\n    }\n\n\n\n    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);\n\n}\n", "idx": 18384, "substitutes": {"f": ["fl", "fd", "l", "fn", "z", "t", "w", "i", "p", "lf", "sf", "h", "q", "stream", "fb", "e", "fr", "g", "cf", "fac", "out", "xf", "d", "v", "tf", "c", "j", "r", "um", "fo", "file", "o", "fs", "fi", "fc", "fm", "bf", "fa", "af", "fx", "uf", "fw", "buffer", "ac", "fp", "rf", "F", "b", "y", "ff", "m"], "blk": ["BLk", "relak", "rolk", " blke", "blck", "blockak", " blkt", "brk", "relck", "llak", "blej", "blke", "bhck", "relke", "blkid", "bleck", "Blk", "llk", "blkg", "rolck", "brck", " blkid", "blunk", "blek", "bleak", "brkt", "Blkt", "Blj", " blak", "blj", "bhkg", "bhk", "blekid", "blak", "BLck", "rolkg", "blockkg", " blunk", "grck", "rolak", "grunk", " blj", "BLak", "brj", "bleunk", "relk", "grk", " blkg", "bhunk", "Blck", "grkg", "BLunk", "llke", "llck", "blockk", " blck", "blockck", "blkt", "Blkid"], "len": [" length", "mem", "pos", "lp", "offset", "loc", "fn", "el", "l", "z", "t", "size", "els", " el", "lon", "nt", "flags", "sp", "lf", "en", "num", " le", "ll", "end", "ret", "vec", " l", "il", "length", "off", "ln", "bytes", "limit", "Length", "nl", "val", "L", "str", "coll", "n", " bl", "lic", "lan", " Len", "ls", "lim", "pl", "ld", " clen", "Len", "sl", "elt", "fl"]}}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze(Error **err)\n\n{\n\n    int ret = 0, i = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n", "idx": 18409, "substitutes": {"err": ["eth", "error", "res", "arr", "die", "or", "yr", "desc", "norm", "result", "Error", "test", "gz", "kr", "e", "buf", "eas", "exc", "fr", "cur", "mr", "rs", "rr", "mt", "ch", "Er", "ait", "doc", "iter", "obj", "aaa", "attr", "fee", "addr", "order", "msg", "req", "cr", "ocr", "ext", "r", "ev", "gr", "cmp", "cfg", "str", "usr", "er", "txt", "eor", "resp", "ah", "der", "org", "elt", "trace"], "mounts": ["mountedxs", "urlrs", "urlnames", "mountrs", "montls", "materialrs", "dirgs", "dirds", "urll", "materialerences", "mountests", "ountls", "materials", "mdrs", "Mountests", "mountds", "mountts", "mountxs", "ountlist", "mders", "ountgs", "mountedments", "mountgs", "mounteds", "mountnames", "materialnames", "mds", "Mountrs", "Mounts", "ountments", "bindments", "mountedions", "mountlist", "materialts", "mountedands", "mounterences", "materialers", "montions", "mountments", "materiallist", "ountl", "ounterences", "Mountts", "montands", "monts", "materialests", "ountions", "ounters", "ountrs", "binds", "bindxs", "mountands", "materialds", "mountl", "urls", "materialgs", "mounters", "ounts", "ountts", "mdlist", "ountds", "materiall", "mountions", "ountests", "ountnames", "mountls", "ountands", "direrences", "ountxs", "dirs", "mountedls"], "mount": ["mem", "td", "loc", "nt", "perm", "imm", "component", "mm", "proc", "md", "store", "ount", "device", "find", "util", "mod", "lock", "config", "load", "fail", "match", "tr", "handle", "mt", "send", "m", "pod", "mask", "ptr", "stab", "add", "mp", "cmd", "mont", "allow", "pt", "dir", "att", "dev", "field", "local", "um", "touch", "cmp", "draw", "sync", "pair", "complete", "claim", "metadata", "block", "row", "entry", "mounted", "vol", "buffer", "bind", "Mount", "display", "dd", "material", "process"], "local_err": ["locallykr", "localererror", "remote_error", "localmygz", "localererr", "final_gz", "locallyres", "local_usr", "local_exc", "local_my", "local_stat", "localityerr", "local_kr", "final_rs", "localitygz", "old____my", "local_mem", "internal_err", "local67err", "activelyexc", " local_exp", "remote_err", "local_conn", "locallyrs", "localErerror", "internal_error", "localermem", "localmyerr", "old____err", " local_conn", "locallyconn", "localErstat", "localErerr", "localmyrs", "local_error", "finallyerr", " local_er", "local___error", "local_fee", "old_err", "old_fee", "locallyerr", "active_err", "local67my", "old_my", "finallyrs", "finallyexc", "local_res", "final_err", "old____fee", "local67fee", "final_exc", "activelyerr", "localmyexc", "active_exc", "local___err", "internal_stat", "activelykr", "active_kr", "internal_res", "local___exp", "local____err", "locallymem", "local____fee", "locallyusr", "active_res", "local_gz", "localityexc", "finallygz", "activelyres", "local_der", "localityrs", "remote_mem", "local_er", "local___conn", "localerusr", "locallygz", " local_der", "remote_usr", "local_exp", "locallyexp", "locallyerror", "local_rs", "locallyexc", "localErres", " local_error", "local____my"], "fd": ["dt", "ctx", "hd", "fr", " ptr", "ln", "cd", "dig", "dir", "cond", " ft", "fs", "gd", "wind", "fp", "dd", "td", " len", " dst", "stream", "port", "gz", "ret", "dat", "dl", "handle", "d", " fs", "dev", "bf", "fi", "fc", "f", "fl", "ds", " dur", "proc", "cf", "disk", "bd", "ptr", "ft", "addr", " resp", " td", "FD", "ld", " fi", "nd", "window", "lf", "md", "pid", " df", "gc", " fut", "db", "fin", "socket", " tid", "dr", "ond", "sd", "func", "pd", " fin", " f", " ret", " fa", "df", " ff", " ed", " fid", "ff"], "i": ["index", "ij", "z", "si", "l", "t", "ci", "im", "p", "num", "li", "ret", "is", "count", "g", "I", "ai", "phi", "out", "v", "di", "inter", "iter", "ip", "mi", "pi", "ind", "id", "try", "j", "xi", "r", "ti", "val", "n", "multi", "fi", "bi", "x", "ini", "f", "it", "ix", "b", "status", "ii", "m"]}}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n", "idx": 18412, "substitutes": {"fdt": ["dld", "sdt", "flw", "sdl", "fdx", "FDout", "fdT", "dfw", "FDl", "flt", "dfn", "fdout", "fredw", "dlt", "FDt", "dfl", "flT", "fredte", "sdout", "fdd", "dlT", "fdte", "dfT", "fld", "dfout", "fredt", "flte", "dfte", "fdn", "dfx", "dlw", "fdl", "dft", "dfd", "fredx", "flx", "FDn", "sdn", "fdw"], "node_path": ["device_prop", "nodealdepth", "node_format", "device_path", "nodealformat", "node_prop", " node_name", "nodealname", "device_pointer", "node_pointer", "node_name", "nodegpath", "node_depth", "nodealpath", "nodegdepth", " node_depth", "device_name", "nodegname", "nodegformat", " node_format"], "property": [" prop", "p", "term", " prefix", "displayText", "option", "expression", " preference", "prefix", "prop", "node", " field", "primary", "name", "position", "address", "partial", "properties", "pointer", "rue", "value", " attribute", "Property", "description", "field", "tag", "private", "path", "claim", "key", "package", "alias", "attribute", "policy", "text", "ident"], "offset": ["Offset", "error", "size", "slot", "shift", "point", "owner", "length", "peer", "field", "origin", "bound", "path", "metadata", "attribute", "buffer", "url", "fp", "index", "port", "uint", "set", "end", "output", "onet", "seek", "start", "pointer", "range", "parent", "o", "layout", "len", "from", "f", "err", "location", "total", "operation", "address", "ptr", "order", "to", "notation", "info", "row", "meta", "next", "pos", "offs", "window", "component", "count", "padding", "position", "off", "out", "OFF", "value", "outer", "data", "id", "ref", "oid", "et", "onto", "message", "alias", "package", "lag", "trace"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part     = (1 << porder);\n\n    all_bits = 4 * part;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for (i = 0; i < part; i++) {\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n        cnt = n >> porder;\n\n    }\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n", "idx": 18426, "substitutes": {"rc": ["sc", "rm", "cs", "loc", "ra", "ck", "oc", "ec", "rx", "ry", "ctx", "hr", "pc", "rt", "cur", "rs", "auc", "rr", "bc", "cc", "rec", "auth", "RC", "c", "ocr", "cr", "r", "sync", "cmp", "coll", "runner", "rb", "ack", "cb", "nc", "anc", "rn", "roc", "ro", "abc", "ac", "src", "rf", "irc", "arc", "rl"], "porder": ["Pprogress", "Porder", "cover", " porders", "pattr", "ppdepth", "Pder", "pdepth", "ppprogress", " pgrade", " pdepth", "pporder", "Ppriority", "taddress", " pprogress", "ppattr", "pcaddress", "paddr", "Porders", "pder", "Pdepth", "pingOrder", "POrder", "pOrder", " pOrder", "pcorder", "pcder", "paddress", "pgrade", "ccode", "pcdepth", "pcaddr", "corder", "rdepth", "Pcode", "pcOrder", "porders", "ppriority", "pingorders", "Pover", " pover", "permgrade", "pcattr", "pover", "pingpriority", " pcode", " paddress", "tgrade", "permordered", "ppaddress", "pcode", "permorder", " pder", "rorder", "permaddress", " paddr", " ppriority", "pordered", " pordered", "ppOrder", "pingorder", "cOrder", "Paddr", "rattr", "torder", "pprogress", "raddress", "tordered"], "sums": ["isum", "sinum", " sum", "caves", " sods", "hums", "cods", "Sums", "hames", "sum", "isights", "Sights", "Sods", "Sum", "sights", "Sumes", "isums", "cums", "Saves", "sinizes", "sizes", "sinums", "sames", "hizes", "saves", "isumes", "sinames", "hum", " sizes", " sames", "cum", " saves", "sods", "sumes"], "n": ["na", " N", "np", "nt", "fn", "size", "t", "l", "p", "num", "dn", "cn", "ne", "count", "g", "ni", "mn", "v", "ns", "nn", "nat", "sn", "nb", "nu", "c", "pi", "nl", "j", "r", "N", "nan", "nm", "gn", "nc", "len", "net", "pn", "nr", "s", "b", "m"], "pred_order": ["preditynumber", "predictionorder", "predityorder", "predityposition", "ind_position", "pred_offer", "predictionoffer", "predictionorders", "predictionOrder", " pred_orders", " pred_offer", "ind_count", "pred_number", "ind_number", " pred_Order", "pred_Order", "ind_order", "pred_orders", "pred_count", "pred_position", "preditycount"], "i": ["ic", "index", "ij", "this", "l", "si", "ci", "p", "ei", "ish", "ki", "qi", "me", "ski", "li", "is", "\u0438", "ri", "e", "I", "ai", "phi", "v", "di", "io", "inter", "ip", "mi", "pi", "c", "ind", "id", "in", "j", "xi", "to", "iri", "try", "ti", "batch", "ui", "iat", "gi", "ji", " I", "multi", "uri", "o", "bi", "x", "info", "asi", "zi", "ini", "sim", "ie", "status", "it", "ix", "us", "ms", "iu", "y", "ii", "m"], "k": ["km", "ok", "sk", "ck", "kh", "uk", "kat", "kn", "ki", "kj", "p", "ks", "kr", "ik", "ke", "ijk", "ka", "ku", "kan", "kar", "kw", "m", "v", "ak", "kid", "kind", "kk", "ikk", "mk", "kl", "tk", "ko", "key", "ack", "unk", "K", "wk", "ek"], "cnt": ["Cct", " cct", "ucNT", " cnd", "Ctr", "actr", "cust", "ucount", " count", "acNT", "cnc", "cnd", "rcct", "cct", " cust", "sccount", "count", "rcnd", "Cust", " ctr", "rcnt", " cpt", "uncnt", "acnc", "ccount", "Cnt", "ucnc", "cpt", "acpt", " cNT", "acount", "ucnt", "rcount", " ccount", "Count", "scount", "Cpt", "uncount", " cnc", "scust", "uncnc", "cNT", "Cnd", "ctr", "Ccount", "acnt", "scnt"], "part": ["patch", "pos", "offset", "chapter", "perm", "Part", "component", "pad", "p", "pp", "sp", "only", "base", "power", "span", "per", "padding", "group", "step", "split", "position", "partial", "pro", "axis", "start", "kind", "instance", "magic", "PART", "pi", "order", "pt", "half", "inner", "parent", "art", "diff", "mult", "piece", "pair", "ition", "top", "state", "pre", "par", "parts", "block", "type", "no", "version", "m"], "all_bits": ["all___its", " all_its", "all2tops", "all00pots", "all_flags", " all_pins", "all___bits", "all___bit", " all_bs", " all_bit", "all_pins", "all_tops", "all2its", " all_tops", "all_bytes", "all00bits", "all_bit", " all_bytes", "all2bs", "all2bits", "all00bytes", "all___flags", "all_pots", "all_its", " all_pots", " all_flags", "all_bs"]}}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "func": "static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n", "idx": 18437, "substitutes": {"common": ["shared", "stable", "bare", "basic", "component", "Common", "final", "bur", "set", "on", "base", "public", "core", "normal", "initial", "general", "tree", "other", "primary", "session", "head", "instance", "standard", "document", "bolt", "to", "admin", "body", "inner", "parent", "local", "new", "message", "some", "present", "raw", "low", "metadata", "from", "com", "un", "conf", "old", "m"], "state": ["check", "see", "form", "ate", "size", "comment", "close", "client", "State", "rule", "store", "list", "result", "we", "test", "port", "the", "STATE", "power", "is", "core", "count", " states", "ace", "config", "copy", "run", "command", "length", "stat", "all", "start", "area", "that", "cor", "call", "monitor", "data", "range", "operator", "estate", "admin", "event", "scope", "master", "tag", "local", "post", "draw", "job", "runner", "print", "info", "trace", "type", "al", "stats", "rest", "code", "spec", "states", "version", "part", "status", "task", "fresh"]}}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n\n                   int w, int h, enum PixelFormat pix_fmt, int align)\n\n{\n\n    int i, ret;\n\n    uint8_t *buf;\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        linesizes[i] = FFALIGN(linesizes[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n\n        return ret;\n\n    buf = av_malloc(ret + align);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n\n        av_free(buf);\n\n        return ret;\n\n    }\n\n    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)\n\n        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n\n\n\n    return ret;\n\n}\n", "idx": 18438, "substitutes": {"pointers": ["pos", "atts", "shots", "offs", "args", "bits", "flags", "posts", "pieces", "results", "ctx", "qs", "checks", "bs", "pins", "points", "gs", "fts", "pages", "amps", "values", "lists", "ports", "bytes", "cells", "vs", "ptr", "hw", "keys", "aps", "ices", "sets", "ps", "pointer", "stones", "types", "ids", "steps", "feet", "headers", "fs", "ashes", "ints", "weights", "tips", "actions", "ts", "parts", "locks", "links", "inters", "heads", "books", "versions", "eds"], "linesizes": ["elinesitions", "lsized", "linspaces", "lineizing", "linesize", "valseps", "elinesizers", " lineses", "lineseps", "valsizes", "linsizers", " linesizers", "lineses", "lsists", "linesized", "valsizers", "lesizers", "linsize", "linsizations", "elineseps", "lines", "linedize", "linesitions", "linepaces", "linesists", "linizes", "lesizes", " linesitions", "valsizations", "linespaces", "leseps", "linites", "lineize", "linseps", "linsites", "linesizing", "linides", "linedizes", "linesizations", "linsists", "lsizes", "linedists", "linedized", "linedizations", "linsizes", "lesites", "linesizers", " linesized", "lesides", "linsitions", " linesizations", "linsides", "lsizations", " linesists", " linesides", "linesites", "linses", "linizations", "linesides", "linedpaces", "elinesizes", "lineizes", "linedizing", "linsizing", "linists", " lineseps", "lesizations"], "w": ["l", "res", "t", "window", "wp", "p", "rw", "win", "aw", "iw", "wl", "wt", "nw", "sw", "v", "wr", "ew", "wa", "wb", "hw", "wx", "wd", "c", "r", "wh", "wi", "W", "n", "wn", "x", "fw", "s", "wal", "f", " W", "wcs", "b", "m"], "h": ["l", "oh", "z", "size", "t", "hl", "hi", "hh", "kh", "p", "uh", "en", "he", "hz", "bh", "ha", "q", "hash", "hr", "hd", "g", "ht", "shape", "length", "handle", "ch", "v", "hw", "k", "H", "ih", "c", "height", "r", "high", "hei", "n", "o", "x", "ah", "f", "it", " H", "hal", "b", "y", "m"], "pix_fmt": ["pix_fmdr", "pix_Ftx", "pix_ctx", "pix_vformat", "pix_mtx", "pix_vmt", "pix_fldr", "pix_fmnt", "pix_vtx", "pix_lmt", "pix_cmt", "pix_lformat", "pix_vtm", "pix_vdr", "pix_Fmt", "pix_mdr", "pix_virm", "pix_ffmt", "pix_fmmt", "pix_ctm", "pix_ftm", "pix_clt", "pix_cdr", "pix_htm", "pix_hlt", "pix_flirm", "pix_flt", "pix_ffmk", "pix_Ftm", "pix_cmk", "pix_flmt", "pix_ffformat", "pix_Flt", "pix_fformat", "pix_ftx", "pix_fmtx", "pix_fftx", "pix_mmt", "pix_mlt", "pix_mnt", "pix_cformat", "pix_hmt", "pix_fnt", "pix_mtm", "pix_flformat", "pix_fdr", "pix_ltx", "pix_htx", "pix_fmk", "pix_firm", "pix_ltm", "pix_cirm"], "align": ["grow", "offset", "aligned", "mem", "index", "l", "format", "size", "ag", "imm", "pad", "aug", "num", "aff", "hang", "shift", "end", "scale", "padding", "length", "IGN", "xf", "wrap", "attr", "add", "addr", "order", "ext", "rot", "height", "ign", "cal", "act", " alignment", "alias", "coord", "margin", "adjust", "len", "alpha", "al", "ac", "angle", "col", "ignment"], "i": ["ski", "li", "span", "ri", "g", "I", "ai", "di", "iter", "mi", "c", "inner", "ji", "asi", "s", "chain", "multi", "ii", "ij", "t", "ci", " e", "phi", "pi", "gi", "fi", "bi", "x", " x", "zi", " err", "ini", "it", "iu", "status", "ic", "slice", "qi", " ti", "me", " ii", " mi", "ip", " j", "j", "ti", " is", "print", " I", "ami", "uri", "info", " si", " bi", "m", "si", "im", "p", " pi", "is", " p", "oi", "ind", "id", "in", "xi", "ui", "batch", "key", " ni", " m", " v", "sim", "us"], "ret": ["round", "back", "report", "rt", "fr", "iter", "get", "obj", "cat", "jp", "aux", "del", "cert", "net", "buffer", "rets", "mem", "offset", "t", "flag", "result", "ry", "end", "virtual", "fail", "read", "RET", "reset", "re", "try", "len", "resp", "fun", "it", "status", "nt", "res", "rect", "tr", "mt", "all", "reg", "ptr", "progress", "backed", "ft", "addr", "det", "att", "def", "print", "alt", "txt", "gt", "deg", "ll", "last", "gc", "out", "off", "cont", "value", "rem", "success", "rev", "cmd", "lit", "rel", "ref", "val", "uf", "full", "br", "Ret"], "buf": ["mem", "uv", "cv", "Buff", "np", "boxes", "box", "arr", "used", "window", "img", "pad", "max", "bar", "result", "rw", "end", "BA", "bs", "vec", "tmp", "tr", "bd", "bc", "queue", "alloc", "mb", "conv", "BU", "v", "bytes", "out", "db", "pb", "wb", "bl", "ptr", "obj", "iter", "msg", "cmd", "data", "func", "ref", "r", "raw", "bf", "rb", "cache", "txt", "cb", "block", "bin", "uf", "buffer", "Buffer", "fun", "buff", "b", "ff", "br", "bn"]}}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n", "idx": 18439, "substitutes": {"s": ["services", "hs", "ds", "states", "os", "t", "w", "args", "settings", "sb", "p", "sp", "ses", "st", "details", "sq", "store", "aws", "h", "sm", "qs", "is", "bs", "sv", "rs", "gs", "S", "ss", "sts", "ns", "ps", "sys", "js", "spec", "r", "comm", "fs", "less", "ts", "ims", "ls", "stats", "ms", "sis", "sl", "has", "status"], "index": ["loc", "error", "size", "valid", "mount", "point", "Index", "length", "iter", "insert", "local", "context", "number", "ex", "offset", "IND", "connection", "item", "set", "zero", "level", "find", "lock", "seek", "pointer", "call", "update", "available", "scope", "connected", "x", "null", "from", "code", "version", "status", "location", "slice", "num", "interface", "ion", "subject", "address", "capacity", "instance", "document", "j", "height", "draw", "state", "info", "block", "exclusive", "row", "no", "loop", "process", "pos", "window", "i", "is", "count", "empty", "position", "image", "axis", "thread", "select", "value", "success", "ind", "id", "in", "batch", "message", "connect", "key", "dim"], "frame": ["hide", "offset", "zone", "channel", "face", "fram", "window", "component", "AME", "allowed", "flag", "sf", "remote", "frames", "feature", "base", "zero", "fb", "fr", "point", "ace", "owner", "cf", "Frame", "profile", "length", "rame", "send", "image", "position", "xf", "label", "pointer", "tf", "iframe", "reset", "range", "time", "target", "id", "forced", "height", "context", "sequence", "state", "block", "type", "f", "buffer", " Frame", "code", "event", "trace", "process"]}}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n", "idx": 18447, "substitutes": {"vdev": ["svpad", "vcpad", "vdiv", "vdevice", "vcdiv", "svdev", "camdiv", " vpad", "camserv", "svdiv", "vpad", "wserv", "wdevice", "camdevice", "vcdev", "dserv", " vev", "vserv", "ddiv", "vcev", "ddev", "wdev", "svev", "wdiv", "vev", "ddevice", "camdev", " vdiv"], "vq": ["hque", "veq", "vceq", "verue", "vcue", "vcq", "vque", "verq", "sveq", "vereq", " vw", "svque", "svq", "svqu", "hw", "svw", "vQ", "vqu", " vque", "vcqu", "verqu", "svQ", "vue", "hQ", "vw", "hq", "svue", " vQ"], "s": ["a", "hs", "ds", "sam", "cs", "t", "sh", "i", "sb", "p", "sq", "h", "sm", "set", "is", "bs", "g", "sv", "rs", "gs", "S", "ss", "sts", "v", "ns", "self", "se", "ps", "sys", "js", "iss", "c", "j", "es", "ats", "comm", "n", "fs", "sol", "source", "ts", "ls", "su", "stats", "ms", "us", "sis", "sl", "b", "m"]}}
{"project": "qemu", "commit_id": "1a20a032ccbb5800bfdfc75accfcff2ac67f5bcb", "target": 1, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    struct usb_device_info bus_info, dev_info;\n\n    USBDevice *d = NULL;\n\n    USBHostDevice *dev;\n\n    char ctlpath[PATH_MAX + 1];\n\n    char buspath[PATH_MAX + 1];\n\n    int bfd, dfd, bus, address, i;\n\n    int ugendebug = UGEN_DEBUG_LEVEL;\n\n\n\n    if (usb_host_find_device(&bus, &address, devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buspath, PATH_MAX, \"/dev/usb%d\", bus);\n\n\n\n    bfd = open(buspath, O_RDWR);\n\n    if (bfd < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to open usb bus - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n    bus_info.udi_addr = address;\n\n    if (ioctl(bfd, USB_DEVICEINFO, &bus_info) < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to grab bus information - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s\", bus_info.udi_devnames[0]);\n\n#else\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s.00\", bus_info.udi_devnames[0]);\n\n#endif\n\n\n\n    dfd  = open(ctlpath, O_RDWR);\n\n    if (dfd < 0) {\n\n        dfd = open(ctlpath, O_RDONLY);\n\n        if (dfd < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to open usb device %s - %s\\n\",\n\n                   ctlpath, strerror(errno));\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (dfd >= 0) {\n\n        if (ioctl(dfd, USB_GET_DEVICEINFO, &dev_info) < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to grab device info - %s\\n\",\n\n                   strerror(errno));\n\n#endif\n\n            goto fail;\n\n        }\n\n\n\n        d = usb_create(NULL /* FIXME */, \"usb-host\");\n\n        dev = DO_UPCAST(USBHostDevice, dev, d);\n\n\n\n        if (dev_info.udi_speed == 1)\n\n            dev->dev.speed = USB_SPEED_LOW - 1;\n\n        else\n\n            dev->dev.speed = USB_SPEED_FULL - 1;\n\n\n\n        if (strncmp(dev_info.udi_product, \"product\", 7) != 0)\n\n            pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                    dev_info.udi_product);\n\n        else\n\n            snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                     \"host:%s\", devname);\n\n\n\n        pstrcpy(dev->devpath, sizeof(dev->devpath), \"/dev/\");\n\n        pstrcat(dev->devpath, sizeof(dev->devpath), dev_info.udi_devnames[0]);\n\n\n\n        /* Mark the endpoints as not yet open */\n\n        for (i = 0; i < USB_MAX_ENDPOINTS; i++)\n\n           dev->ep_fd[i] = -1;\n\n\n\n        ioctl(dfd, USB_SETDEBUG, &ugendebug);\n\n\n\n        return (USBDevice *)dev;\n\n    }\n\n\n\nfail:\n\n    return NULL;\n\n}\n", "idx": 18457, "substitutes": {"devname": ["deviceName", "evno", "evname", "devno", " Devno", "evNAME", "devicename", " devName", " DevNAME", "devNAME", "deviceno", " devNAME", " devno", " DevName", "evName", "devName", " Devname"], "bus_info": ["boot_Info", "BUS_conf", "bus_Info", "bus_no", "bus___Info", "BUS_INFO", "bus___info", "BUS_status", "bus___dict", "BUS_no", " bus_inf", "BUS_Info", "bus2info", "bus_conf", "bus_fo", "BUS_inf", " bus_id", "bus2inf", "bus_update", "bus___inf", "BUS_update", "bus2Info", "BUS_info", "bus_inf", "bus_status", "bus_dict", "bus2dict", " bus_fo", "boot_inf", "boot_info", "bus_INFO", "boot_dict", "bus_id"], "dev_info": ["dev2inf", "dev_inf", "devJsettings", "dev2info", "dev_try", "ev_info", "Dev_query", "devJinfo", "dev_type", "devJtry", "dev_query", "ev_settings", "dev_settings", "ev_try", "dev2fo", "device_inf", "device_type", "dev_fo", "dev2type", "device_fo", "device_info", "Dev_inf", "Dev_info"], "d": ["ds", "fd", "t", "w", "p", "dt", "h", "device", "e", "g", "dat", "bd", "ad", "db", "v", "di", "od", "da", "dr", "sd", "data", "c", "dm", "r", "pd", "dom", "D", "dc", "o", "n", "du", "dh", "dx", "did", "f", "b", "dd", "dn"], "dev": ["pub", "pad", "endif", "test", "av", "cam", "ad", "stop", "pro", "di", "obj", "iv", "priv", "develop", "gu", "home", "boot", "dem", "spec", "serv", "dd", "mem", "td", "de", "max", "pp", "desc", "set", "device", "_", "usb", "v", "hw", "da", "DE", "n", "o", "fi", "ver", "tech", "f", " device", "ds", "nt", "w", "ow", "dis", "DEV", "buf", "tr", "bd", "des", "serial", "det", "att", "ev", "fo", "def", "info", "block", "vo", "go", "od", "dn", "debug", "adv", "stable", "of", "Dev", "final", "md", "h", "util", "config", "db", "ve", "wd", "sd", "conn", "data", "cmd", "func", "new"], "ctlpath": ["ctpath", "dlog", "ctlopath", "ctxPATH", "ctxPath", "ctlprop", "socpath", "ctrltrace", "ctrltemplate", "socopath", "cmdPath", "ctrllog", "ctrlPATH", "dlPath", "conntrace", "cmdtemplate", "ctrlpointer", "connpath", "dllprop", "ctfile", "ctxpath", "driverprop", "connth", "switchtrace", "cbfile", "cmdth", "cbpointer", "ctrlopath", "cmdpath", "ctlfile", "dpath", "switchopath", "ctrlth", "ctltemplate", "connopath", "ctlth", "conntemplate", "ctlPATH", "switchPath", "ctpointer", "socprop", "dPATH", "ctrlfile", "drivercert", "dllpath", "ctrlPath", "driveropath", "ctltrace", "ctlpointer", "dlprop", "connPath", "ctPath", "ctrlpath", "cbPath", "dlpath", "dPath", "switchpath", "ctrlcert", "dlcert", "ctlPath", "dllPath", "ctxlog", "soccert", "ctlcert", "dllcert", "cbpath", "ctllog", "driverpath", "ctrlprop"], "buspath": ["busPath", "BUStemplate", "buscase", "bustime", "busroot", "stickpath", "boxth", "bcPath", "bccase", "bctime", "busfile", "cbfile", " busfile", "ctlfile", "BUSpath", "cbroot", "ctltime", "BUSurl", " busPath", "ctlth", "busurl", "bcpath", "sticktemplate", "stickurl", "bustemplate", " busroot", "boxPath", "busth", "BUScase", "ctlroot", "bcth", "bcurl", "cbPath", "ctlPath", "boxtime", "boxpath", "cbpath", "stickcase", "bctemplate"], "bfd": [" bsd", "Bdf", "objdd", "abdd", "bdat", "nbdd", "objsd", "nbfunc", "bfunc", "wbfunc", " bdf", "abdf", "nbdf", "obdl", "objbd", " bbd", "Bfd", " bdd", "abfunc", "bbfd", "Bdd", "bgd", "abdat", "obgd", "bdl", "wbgd", "wbfd", "Bdat", "nbfd", " bgd", "abgd", "obdf", "bsd", "bbbd", "objfd", "abfd", "nbgd", " bdl", "bbdd", "bbd", "bbsd", "bdf", "bdd", "wbdd", " bdat", "nbdl", "obfd"], "dfd": ["ddds", "pdfcd", "ufd", "fdcd", "fddi", "DFs", "dfdd", "dpd", "DFsd", "olfr", "ufdi", "dfp", "ufn", "dbD", "fddd", "dds", "ddc", "pdfd", "dfdi", "dpD", "dbd", "dpr", "dpc", "tfd", "fds", "dfl", "dfc", "fdds", "fdr", "tffd", "idddid", "iddfd", "olfd", "tfdid", "fdc", "ddl", " dft", "dfr", "olfD", "dpdd", "dft", "ufcd", "dlfd", "ddsd", "dfn", "dfs", "pdfn", "DFp", " dfD", "fdd", "dbt", "dfD", "dbp", "fdp", "fdn", " dfdd", "dffd", " dfdid", " dfp", "fdsd", "olfdd", "dld", " dffd", "idddd", "dlds", "DFd", "ddD", "dfcd", "dpl", "dfds", "ddp", "ddn", "ddfd", "dlp", "dfdid", "fdfd", "ddt", "fdD", "tfdd", "fdl", "pdfdi", "iddd", "dpn", "dfsd", "ddd"], "bus": ["connection", "binding", "os", "bridge", "board", "box", "back", "lib", "controller", "interface", "user", "port", "mount", "family", "base", "bs", "usb", "prefix", "handle", "ch", "bug", "bid", "ip", "service", "bit", "Bus", "id", "BUS", "product", "host", "uses", "card", "alias", "block", "type", "brand", "home", "us", "boot", "chain", "b", "proxy", "loop", "class"], "address": ["a", "connection", "index", "location", "ca", "p", "controller", "interface", "port", "domain", "ress", "device", "ace", "point", "resource", "ai", "command", "name", "position", "reference", "ip", "route", "addr", "service", "description", "order", "pi", "id", "host", "ash", "context", "message", "number", "path", "directory", "alias", "network", "attribute", "Address", "api", "angle", "active", "type"], "i": ["a", "index", "l", "z", "t", "p", "interface", "e", "I", "ai", "v", "io", "di", "k", "ip", "mi", "pi", "c", "in", "id", "j", "r", "n", "f", "b", "ii", "m"]}}
{"project": "FFmpeg", "commit_id": "98b377004d9c6fa1c1756c814efe9882b65f96b9", "target": 0, "func": "static av_cold int twin_decode_init(AVCodecContext *avctx)\n\n{\n\n    int ret;\n\n    TwinContext *tctx = avctx->priv_data;\n\n    int isampf, ibps;\n\n\n\n    tctx->avctx       = avctx;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    if (!avctx->extradata || avctx->extradata_size < 12) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = AV_RB32(avctx->extradata    ) + 1;\n\n    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;\n\n    isampf          = AV_RB32(avctx->extradata + 8);\n\n\n\n    if (isampf < 8 || isampf > 44) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (isampf) {\n\n    case 44: avctx->sample_rate = 44100;         break;\n\n    case 22: avctx->sample_rate = 22050;         break;\n\n    case 11: avctx->sample_rate = 11025;         break;\n\n    default: avctx->sample_rate = isampf * 1000; break;\n\n    }\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",\n\n               avctx->channels);\n\n        return -1;\n\n    }\n\n    avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO :\n\n                                                   AV_CH_LAYOUT_STEREO;\n\n\n\n    ibps = avctx->bit_rate / (1000 * avctx->channels);\n\n\n\n    if (ibps > 255) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((isampf << 8) +  ibps) {\n\n    case (8 <<8) +  8: tctx->mtab = &mode_08_08; break;\n\n    case (11<<8) +  8: tctx->mtab = &mode_11_08; break;\n\n    case (11<<8) + 10: tctx->mtab = &mode_11_10; break;\n\n    case (16<<8) + 16: tctx->mtab = &mode_16_16; break;\n\n    case (22<<8) + 20: tctx->mtab = &mode_22_20; break;\n\n    case (22<<8) + 24: tctx->mtab = &mode_22_24; break;\n\n    case (22<<8) + 32: tctx->mtab = &mode_22_32; break;\n\n    case (44<<8) + 40: tctx->mtab = &mode_44_40; break;\n\n    case (44<<8) + 48: tctx->mtab = &mode_44_48; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);\n\n        return -1;\n\n    }\n\n\n\n    ff_dsputil_init(&tctx->dsp, avctx);\n\n    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    if ((ret = init_mdct_win(tctx))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        twin_decode_close(avctx);\n\n        return ret;\n\n    }\n\n    init_bitstream_params(tctx);\n\n\n\n    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));\n\n\n\n    avcodec_get_frame_defaults(&tctx->frame);\n\n    avctx->coded_frame = &tctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18462, "substitutes": {"avctx": ["navtx", "ajpkg", "avctl", "afresp", "ajresp", " avcrit", "avgc", " avcontext", "wavparams", "averct", " avcontent", "varctx", "wavcv", "avobj", "wavctx", " avcmd", "avconn", "averdl", "wavreq", "wavcmp", "varcu", " avca", "afkt", "verpkg", " avctl", " avkl", "avercp", "ahctx", "abconn", "aveparams", "afctx", "varcookie", "vargc", "afconf", "awctx", "afcv", "avpkg", "afpkg", "wavcontext", "vercrit", "vercontext", "wavct", "cvcontext", "avect", "varcontext", "awcu", "avekl", "avcmd", "afcmd", "avetx", "ahobj", "avecontext", "averparams", "afobj", "avcrit", "wavcrit", "cvcmp", "varcrit", "avcu", "avercmd", "wavconn", "avecmp", "aveca", "afreq", "aucontext", "wavaddr", "avertx", "avercv", "avepkg", "avecookie", "wavdl", "averjp", " avcookie", "avdl", " avtx", " avkt", "wavctl", "avecp", " avreq", "averresp", "wavcp", "wavcu", "avcp", "avecontent", "avercontent", "avercontext", "wavcmd", "aftx", "afpid", "avca", "aucp", "afkl", " avpid", " avloc", "afparams", "verctx", "ajtx", "afloc", " avcv", "avcv", "avecv", "auctx", "afctl", " avgc", "avegc", "averca", "afcrit", "wavconf", "autx", "avkl", "avcontext", " avaddr", "vertx", "avectx", "awtx", "navcrit", "avcontent", "avpid", "abaddr", "avejp", " avcmp", "verkt", "avecu", "afcontext", "avedl", "cvctx", "averkt", "avkt", "averpid", "avreq", "navpid", "ahcontext", "afcp", "avercmp", "avcookie", "awcontext", "afcu", "ahcrit", "avercu", "wavpkg", " avcp", "awcv", " avobj", "vartx", "navkt", "wavkt", "afcmp", "abtx", "avcmp", "ajctx", "ajkt", " avconn", "avconf", " avpkg", "averctx", "wavtx", "navctl", "avparams", "avloc", "ajconf", "aveloc", "cvtx", "avjp", " avcu", "avecmd", "navctx", "vercu", "avtx", "abctx", "avresp", "ajparams", "afjp", "avct", "avecrit", "avaddr"], "ret": ["mem", " RET", "result", "Ret", "vals", "pol", " reply", "ral", "Return", "value", "RET", "rev", "val", " resp", "alt", "resp", "urn", "gt", " res"], "tctx": ["mtx", "ptx", " tresp", "tmctx", "tentxt", "tcu", "wcontext", "tmcmp", "wctx", "tcontext", "tscontext", "atcontext", "tmtx", "atctx", "tcmd", "ttx", "tscmd", "tstx", " tcmd", "rcmp", "tmcu", "tentx", "mctx", "pcp", "pcontext", "ttxt", "tenresp", "attx", "pctx", " ttxt", "rtx", "mcmp", "atcp", "tresp", "rctx", " tcontext", "wtx", "tsctx", "rcu", "mcu", " ttx", "wtxt", "wresp", "wcp", "tenctx", "tencontext", "tcp", "tcmp", "tencmd"], "isampf": [" IsapF", "isampsf", " isampleh", "isaramif", "bsarmf", "isampleh", "Isampf", "isarmfc", "isamplf", "isampc", "isamF", "isamfr", "Isamptf", "isufffc", "isrpmf", "isammf", "isamph", "endsampff", " Isapbf", " isamplef", "ispptf", "endsampfc", " Isampbf", "Isppfort", "bsampf", "isambf", "ismpfac", "isarml", "endsampif", "isampfr", "isampedff", " isamplefl", "isampfc", "isarmfs", "isampfs", "ismpf", "istsarmfac", "isampxf", "isampsfs", "isampfac", "isaph", " isampfl", " isampc", "isippfort", "isapf", "isufffr", "istsamplf", "isapfl", "Isampfort", "isampedf", "isipptf", "ismplf", "isamplef", "isamxf", "istsampf", " isamplec", "istsampfac", "endsampf", "isamff", "isamh", "isammfac", " IsampF", "isampl", "endsampedf", "isarmif", "ismpfc", "bsarml", "isarmfr", "isamptf", "isppf", "isampfort", "isampsl", "bsarmfs", "isaramf", "endsampedxf", "endsarmif", "isreamF", "isarmlf", "isreamf", "isppF", "isreamfort", "isppfs", "bsampfs", "isampff", "isampedfr", "isuffif", "isaramfc", "bsampF", "endsampedff", "isapc", "isampfl", "isarmfac", "endsampedfr", "isarmF", "isampF", "Ispptf", "isrpmfr", " Isapf", "isamfl", "isampif", "isampbf", "isarmf", "isaramfr", "isppfort", "isppl", "istsampfc", "istsarmfc", "isamc", "endsarmfr", "istsarmlf", "isrpmff", "isampsbf", " isamph", "isamplefl", "isamplec", "istsarmf", "isapF", "isampedxf", "isammfc", "endsampxf", " Isampf", "IsampF", "isampsF", "isreamtf", "bsarmF", "isufff", "endsampfr", "isippf", "bsampl", "isrpmxf", "IsppF", "isapbf", "Isppf", "isamf", "endsarmf", "isammlf", "isippF", "endsarmfc"], "ibps": ["abrs", " ibp", "IBaps", "IBms", "rebms", "imrs", "IBresses", "IBpps", "ibp", "abples", "ibrs", "impps", " ibaps", "ibaps", "ibresses", " ibrs", "ibips", "abps", " ibcs", "ibics", "robps", "ibip", "IBps", "ilibps", "imps", "IBPS", "ibports", "rebps", "ibpps", "abports", "robples", "abms", "ilibpps", "robp", " ibples", "ibms", "ibcs", "robcs", "abpps", "ilibresses", "abresses", "ibiples", "IBples", "imms", "abPS", "ibPS", "ibples", " ibpps", "abaps", "rebports", " ibms", "IBports", "rebples", "ilibPS", " ibPS"]}}
{"project": "FFmpeg", "commit_id": "18ff4d20201ae69fdeb2da2c90bdcbd33f7ac025", "target": 1, "func": "static int copy_chapters(InputFile *ifile, OutputFile *ofile, int copy_metadata)\n\n{\n\n    AVFormatContext *is = ifile->ctx;\n\n    AVFormatContext *os = ofile->ctx;\n\n    int i;\n\n\n\n    for (i = 0; i < is->nb_chapters; i++) {\n\n        AVChapter *in_ch = is->chapters[i], *out_ch;\n\n        int64_t ts_off   = av_rescale_q(ofile->start_time - ifile->ts_offset,\n\n                                       AV_TIME_BASE_Q, in_ch->time_base);\n\n        int64_t rt       = (ofile->recording_time == INT64_MAX) ? INT64_MAX :\n\n                           av_rescale_q(ofile->recording_time, AV_TIME_BASE_Q, in_ch->time_base);\n\n\n\n\n\n        if (in_ch->end < ts_off)\n\n            continue;\n\n        if (rt != INT64_MAX && in_ch->start > rt + ts_off)\n\n            break;\n\n\n\n        out_ch = av_mallocz(sizeof(AVChapter));\n\n        if (!out_ch)\n\n            return AVERROR(ENOMEM);\n\n\n\n        out_ch->id        = in_ch->id;\n\n        out_ch->time_base = in_ch->time_base;\n\n        out_ch->start     = FFMAX(0,  in_ch->start - ts_off);\n\n        out_ch->end       = FFMIN(rt, in_ch->end   - ts_off);\n\n\n\n        if (copy_metadata)\n\n            av_dict_copy(&out_ch->metadata, in_ch->metadata, 0);\n\n\n\n        os->nb_chapters++;\n\n        os->chapters = av_realloc(os->chapters, sizeof(AVChapter) * os->nb_chapters);\n\n        if (!os->chapters)\n\n            return AVERROR(ENOMEM);\n\n        os->chapters[os->nb_chapters - 1] = out_ch;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18474, "substitutes": {"ifile": ["infil", "ifute", "Ifil", "ifiles", "IFile", "IFiles", "IFfile", "infute", "IFil", " ifil", "iffile", "ifil", "isfile", "IFail", "Ifail", "Iffile", "tifiles", "ofil", "tiffile", "tifil", "inffile", " iffile", " ifute", "ofiles", "isfil", "ofail", "Ifile", "tifile", "isffile", "infile", "ifail", "isfute", "offile"], "ofile": ["offime", " offile", "offactory", "sfILE", "Ofate", "OFile", "offfile", "ofactory", "oil", "Ofil", " ofole", "oime", "OFfile", " ofime", "ofILE", "OFail", "OFate", "sfiler", "OFiles", "Ofiles", "ofole", "offole", " ofil", "oactory", "orfiler", "offiles", "ofate", "orfILE", "offail", "oole", "ofil", "offate", "orffile", "ofiler", "sfile", "oile", "ofime", "ofiles", " ofILE", "orfile", "oail", "offil", "OFactory", "ofail", " ofiler", "OFil", "Ofile", "offile", " ofail", "sffile"], "copy_metadata": [" copy_maybe", "copy_meta", "copy__xml", " copy_xml", "copy_mint", "copy_xml", "copy__metadata", "copymaybexml", "copy__meta", " copy_m", "copymaybemetadata", "copy_maybe", " copy_meta", "copymaybemeta", "copy__maybe", "copymaybemaybe", "copy_m", " copy_mint"], "is": ["iso", "ic", "si", "ists", "are", "ist", "bits", "as", "ins", "isc", "isi", "ics", "ir", "oss", "has", "tis", "IS", "ri", "bs", "atis", "iris", "mos", "isal", "aus", "isa", "isf", "iss", "Is", "js", "in", "ais", "obs", "fs", "ois", "s", "ms", "ris", "lis", "sis", "us", "bis", "its", "ii"], "os": ["pos", "oses", "ds", "ops", "oe", "or", "ys", "as", "ose", "at", "oss", "otes", "oos", "bs", "oS", "los", "oids", "mos", "ot", "out", "ox", "ns", "io", "oz", "bos", "sys", "OS", "js", "ols", "ants", "es", "oid", "et", "ros", "dos", "oes", "obs", "osi", "o", "fs", "acs", "er", "ts", "oa", "aos", "s", "ms", "us", "boot", "ows", "ost", "Os"], "i": ["ic", "index", "ij", "si", "ci", "im", "hi", "p", "ki", "qi", " ti", "me", "li", "ri", "g", "I", " ii", "ai", " multi", "name", "out", "v", "di", " mi", "ip", " li", "mi", "pi", "oi", "in", " j", "ind", "j", "xi", "r", "ti", "ui", "batch", "gi", "o", " I", "ji", "multi", "bi", "x", " x", " si", "ims", " ni", "info", " iter", "sim", "ini", " bi", "zi", "ie", "it", "ix", "us", "ex", "iu", "y", "ii", "m"], "in_ch": ["in___ch", "in2chan", " in_ech", "inMatcp", " in_che", "in1ech", "out_chan", "in1arch", "intch", "in_arch", "in___cht", "in_cht", "in_ech", " in_chu", "in1comp", "inpche", "vin_ch", "in_chu", "in_comp", "vin_ich", "in2che", " in_cha", "in_col", "in2ch", "intcomp", " in_sch", "in__chi", "in_chi", "inc_col", " in_cht", "vin__ich", "in_hand", "din_ch", "din___ich", "din_chan", "in___ich", "out_tch", "inxarch", "intarch", "in1cht", "din___ch", "in1ch", "inc_arch", "inxch", " in_chan", "inxche", "in1col", "inwtch", "inc_ch", "in_tch", "vin__chan", "inpech", "in__ch", "din___chan", "in_cp", "in2chi", "vin__ch", " in_cho", "in__chan", " in_arch", "out_cho", "in_chan", "inwchan", "vin__chi", "inMatCh", "vin_chi", "inwcho", "inMatch", "in_che", "inwch", "inc_comp", "in__ich", "inMatchu", "vin_chan", "inxchan", "in_cho", "in___chan", " in_hand", "in2ich", " in_Ch", "in_ich", "din_cht", "in_sch", "in1chan", "in_Ch", "inpch", "din___cht", "inpCh", "intcol", "in_cha", "din_ich", "in2arch", " in_cp"], "out_ch": ["out_Ch", "out___vc", "exp_chan", "cacheptch", "out_chan", "exp_chn", "out_chn", " out_Ch", "out_ech", "exp_ch", "out___uch", "out___ch", "cacheptcor", "outptcho", "check_vc", "out_cl", "outletch", "outptcor", "cache_cho", "check_uch", "check_ich", "cache_chn", "out_ich", "cacheptchn", "cacheptcho", "cache_ch", "outmycha", " out_cho", "Out_cho", "out_cho", "exp_cl", "Out_uch", "Out_Ch", "outmych", "in_chan", "out___ich", "outptch", "outptchn", "outmychan", "outletvc", "out_vc", "Out_chan", "outletuch", " out_chn", "in_ich", "cache_cor", "Out_ech", "check_ch", " out_ech", "Out_ch", "in_cha", "out_cor", "outmyich", "out_cha", "out_uch", "outletich", " out_chan"], "nb_chapters": ["nb__chars", "nb_weunks", "nb_channels", "nb_hearts", "nb_echapters", "nb_echampions", "nb__contannels", "nb_weapters", "nb__chunks", "nb_chunks", "nb_carts", "nb__achunks", "nb_vapters", "nb__chorders", "nb_contorders", "nb_chmakers", "nb_heannels", "nb_achars", "nb_capters", "nb_Chorders", "nb_Chapters", "nb__achants", "nb_vmakers", "nb_achannels", "nb_Chars", "nb_wears", "nb_contars", "nb_achapters", "nb_cars", "nb_hears", "nb_echars", "nb_contapters", "nb__chants", "nb_contannels", "nb_cannels", "nb_Channels", "nb__chapters", "nb_Champions", "nb_Chmakers", "nb_weants", "nb__contars", "nb_cunks", "nb_champions", "nb_heapters", "nb_cants", "nb_ichorders", "nb_ichannels", "nb_achants", "nb__channels", "nb_echmakers", "nb_ichars", "nb_ichapters", "nb_charts", "nb__contapters", "nb__achars", "nb_vars", "nb_chorders", "nb_chants", "nb_vampions", "nb_chars", "nb_achunks", "nb__achapters", "nb__contorders", "nb_acharts"]}}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n", "idx": 18477, "substitutes": {"rec": ["mem", "con", "form", "res", "ok", "nt", "w", "disc", "ck", "desc", "th", "decl", "REC", "rt", "Rec", "fr", "rr", "sec", "fin", "reg", "doc", "obj", "dr", "iter", "rem", "roll", "re", "cmd", "req", "in", "commit", "record", "skip", "rel", "ref", "r", "coll", "ent", "ack", "par", "row", "ro", "resp", "rc", "rest", "col"], "event": ["offset", "frame", "index", "error", "item", "component", "events", " EVENT", "ception", "handler", "feature", "change", "e", "exc", "vent", "command", "name", "image", "address", "Event", "ee", "data", "msg", "cmd", "re", "ext", "id", "record", "entity", "update", "argument", "field", "ev", "new", "message", "context", "ent", " exc", "attribute", "ack", "info", "task", "err", "type"], "datasize": ["datnosize", "datASize", "datalsiz", "datarsized", "datnosiz", "Datalsource", "datatsizer", "datatsized", "Datasize", "datnosource", "datASource", "datalsized", "Datarsized", "datasource", "datasizer", "datalsource", "datarsize", "Datasource", "Datarsiz", "datASiz", "Datasiz", "datarsiz", "datalsize", "datasized", "datatsiz", "Datarsizer", "Datasized", "datASizer", "datarsizer", "Datalsiz", "Datasizer", "datatsize", "datnosizer", "Datalsize", "datalsizer", "Datarsize", "datasiz", "Datalsizer"], "idx": ["indix", " idxc", "indx", "idexc", "ideex", "idew", "Idx", "vidx", " idy", "idey", "idy", "midix", " idxa", "idexf", "idz", "Idw", "Idxy", " idex", "indz", "Idy", "uidix", "Idex", "idez", "idw", "ipex", "idxc", "idxy", "Idix", " idxf", "midxa", " idz", "uidy", "vidxc", "idix", "Idz", "indxf", "ipx", "idexy", "ipxy", "midx", "vidxa", "vidix", " idw", "ideix", "idxa", " idix", "uidx", "Idxc", "uidex", "idex", "idxf", "ipxc", "midxc"], "rec_off": ["discJoff", "rec_opp", "err__offset", "rule_set", "record_offset", "rec2offset", "discJoffer", " Rec_ovi", "record2Off", "rec_of", "rec_o", "rec8along", "record2off", "err_offset", " rec2off", " rec_offset", "decl_along", "scan_Off", "scan_off", "recpyoff", "recPoffset", "recPend", "rec2offs", "record_off", "rec_offs", "rec_offset", "rec_fun", "rec_Off", "decl8off", " rec_of", "rec_offer", "recJoff", "disc_off", "record2offs", "disc_offer", "record_Off", "rec_along", " Rec_off", "rule_off", "recJoffer", "record_end", "recjop", " rec2offer", "err__OFF", "rec_ovi", "record_OFF", "err_off", "rec_on", "err_OFF", "recJoffset", "recPoff", "scan_o", "disc_offs", "recdoff", "rule_opp", " rec2offset", "decl_off", "rec__of", "decl8offer", "rec2Off", "rec_set", "recpyalong", "recdOff", " rec_offer", "record_offs", "rec2off", "err__off", "rec8off", " Rec_offer", "rec__offset", "recpyoffer", "rec2end", "rec_OFF", "scan_offer", "decl_offer", "rec8offer", " Rec_op", "decl8along", "recJoffs", "rec__on", " rec_on", "rec2offer", "recjovi", "rec_end", "rule_fun", "rec__off", "rec__OFF", "recjoffer", "recjoff", "rec_op", "discJoffs", "rec2OFF", "record2OFF"], "old_idx": ["old___idxc", "old_ridxc", "old_midfx", "old_intx", "old_idn", "old_Idz", "old_kidxf", "old_ridn", "old_idb", "old_idxf", "old____idn", "old_idfx", "old_kidx", "old_idp", "old____intb", "old_indp", "old_idey", "old____intfx", "old_idex", "old_idsxs", "old_intb", "old___idsx", "old_idsp", "old_idxs", "old___idsn", "old_Idex", "old_idsx", "old_ridx", "old_ridy", "old_indy", "old_idsy", "old____idb", "old___idy", "old____idx", "old_idexf", "old_Idfx", "old____idfx", "old____intn", "old_Idb", "old_idsxc", "old_intn", "old_midn", "old___idsy", "old_midx", "old_idz", "old_kidy", "old_Idy", "old_idy", "old_idsn", "old_idez", "old_idxc", "old_midb", "old_Idx", "old___idx", "old____intx", "old_Idn", "old___idn", "old_intfx", "old_ideex", "old___idsxc", "old_indxs", "old_indx"], "new_idx": ["new_idxs", "new_pidex", "new_idy", "new_idc", "new_indz", "new_Idn", "new_indx", "new_Idy", "new_kidex", "new_idv", "new_inz", "new_indc", "new_idz", "new_kidx", "new_kidn", "new_pidx", "new_Idxs", "new_kidxs", "new_Idv", "new_pidxs", "new_pidy", "new_idex", "new_pidz", "new_Idex", "new_pidv", "new_inx", "new_pidn", "new_indv", "new_inv", "new_inc", "new_kidy", "new_idn", "new_Idx", "new_Idz"]}}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int16 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x200;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n", "idx": 18493, "substitutes": {"zSign": ["ziDig", "ezExp", "ziPos", "izChange", "ziSet", "ezDig", "ziAct", " zSet", "ziExp", "ZDig", "izExp", "zChange", "ZExp", "ZSign", "ziSign", "ezSet", "ezPos", "ezForm", " zAct", "ziForm", " zForm", "zDig", " zChange", "zAct", "izSign", "izAct", "zSet", "ziChange", "zForm", "ezAct", "ezSign", "zPos", " zPos", " zDig"], "zExp": ["zOp", "zInc", "zExec", "zhEl", "zoneExec", "zenReg", " zEx", "czExp", "czExec", " zEnc", "ezReg", "zoneComp", "zEnc", "ZReg", "zEl", "zipPos", "zExpress", "zPress", "czResp", " zOp", " zReg", "ZSup", "czComp", "zeExpress", "nzExt", " zExpress", "ziEl", "zipExpress", "zenExec", "zhExp", "zipExp", "ziSup", "zipEXP", "zeEXP", "zSup", "ziExp", "zResp", "zEXP", "zEx", "czExt", " zResp", "nzExec", " zPress", "ezEnc", "czEx", "zenEnc", "zhInc", " zComp", "ezEx", "zenEXP", " zPos", " zExec", "ZEx", "zenPress", "zenOp", "czEnc", "zeExp", "ZExp", " zExt", "nzResp", "czInc", "czOp", "zoneExp", "czPress", "ezExt", "zComp", "zReg", "ezExp", "ziInc", "czEl", "zExt", " zEXP", "ezExec", "zePos", "ezPress", "zoneEnc", "ziEx", "zhEx", "zenExp", "ziReg", "zPos", " zSup", "nzExp", "czEXP"], "STATUS_PARAM": ["STATUS_ARams", "STATUS_ARParam", "STATUS_PARParam", "STATUS_ParAMS", "STATUS_PARAMS", "STATUSPARams", "STATUSPPARAM", "STATUS_Vams", "STATUS_ARAM", "STATUSPPARams", "STATUSPARAMS", "STATUSPPARParam", "STATUS_Params", "STATUS_VAM", "STATUSPPARAMS", "STATUS_ARAMS", "STATUS_ParParam", "STATUS_VAMS", "STATUSPARAM", "STATUS_ParAM", "STATUS_PARams", "STATUS_VParam", "STATUSPARParam"], "roundingMode": ["turningModule", "roundningMode", "grouptingModule", "callingMode", "roundizationM", "roundingModel", "roundendingTheme", "roundizationMODE", "roundbingMODE", "roundingForce", "roundendingModule", "roundermode", "runingMODE", "roundtingModel", "roundningMethod", "roundtingManager", "runbingMODE", "roundingManager", "runbingmode", "turntingMODE", "roundingingModel", "roundINGMethod", "grouptingMode", "roundningMODE", "rounderingMode", "rounderMode", "groupingModule", "grouptingModel", "turnlingMethod", "rounderingMODE", "roundizationMode", "turningTheme", "calllingMode", "groupingModel", "turntingMode", "turntingModule", "rounderMODE", "roundINGMode", "roundlingForce", "turntingM", "roundchingTheme", "roundingModule", "roundeningModel", "roundlingMODE", "runingmode", "groupingMode", "roundbingMode", "turntingManager", "roundendingManager", "roundingingMode", "roundtingMode", "roundchingMode", "roundINGMODE", "roundingingModule", "turningMode", "callingMODE", "turningM", "roundtingModule", "runbingMethod", "turningForce", "roundingMethod", "turnlingMODE", "roundingingMethod", "runingMethod", "roundeningMode", "roundeningMODE", "roundingM", "roundeningModule", "grouptingMODE", "roundingingMODE", "roundbingmode", "calllingMODE", "turningMethod", "turnlingForce", "groupingMODE", "runingMode", "rounderMethod", "roundendingMode", "turntingTheme", "roundlingMethod", "turningMODE", "callingMethod", "roundchingModule", "roundINGForce", "roundtingTheme", "roundINGM", "roundchingManager", "roundtingMODE", "roundingTheme", "runbingMode", "rounderingForce", "roundingMODE", "roundINGmode", "calllingMethod", "roundingmode", "roundtingM", "roundbingMethod", "roundlingMode", "turningManager", "turnlingMode", "rounderingMethod"], "roundNearestEven": ["roundneearEven", "roundNeutralEven", "roundneeareven", "roundNeearLong", "roundNearesteven", "roundNarestEven", "roundnearesteven", "roundNeearZero", "roundNeatherEven", "roundNearEven", "roundNeekLong", "roundNeathereven", "roundNeearEven", "roundnearestEven", "roundNeutralZero", "roundNeekeven", "roundNeareven", "roundNeipalZero", "roundNeipalEven", "roundNeeareven", "roundNeutraleven", "roundNearestZero", "roundNearZero", "roundNeekEven", "roundneearLong", "roundNeipaleven", "roundnearestLong", "roundNarestZero", "roundNaresteven", "roundNearestLong"], "roundIncrement": ["rollIncreMENT", "quickSegment", "rollDecrement", "rollDecreMENT", "roundRements", "roundIncrementation", "roundIncrece", "rollDecrembol", "roundAdjustument", "roundMeasurembol", "roundBeginstant", "rollIncrements", "roundincremented", "addincrelement", "roundSegement", "addIncrelement", "roundIncreension", "roundDecreli", "RoundSegments", "roundDecreMENT", "turn_", "rollIncreument", "roundSetmented", "roundMeravior", "roundIncrembol", "RoundSegension", "roundInterments", "roundincreension", "rollDecreli", "roundincrementation", "roundIncrements", "roundBeginmentation", "roundIncremented", "turnIncrema", "roundIncrema", "quickSegmbol", "roundDecrement", "roundincreMENT", "rollIncrembol", "roundReli", "roundIncreMENT", "addincrece", "roundincreement", "turnMermentation", "RoundIncrement", "roundMeasureension", "RoundIncremented", "quickIncrementation", "roundAdjustement", "sort_", "roundMeasurelement", "roundincrece", "quickSegmentation", "roundIncrestant", "RoundIncreement", "roundBeginment", "roundAdjustments", "quickSegstant", "roundMeasurements", "roundMeasuremented", "roundSetce", "roundMermentation", "quickIncrembol", "RoundAdjustments", "turnMeravior", "roundIncreavior", "roundSegmbol", "addIncrece", "addincrement", "roundRement", "roll_", "RoundAdjustement", "turnIncreavior", "roundfloat", "turnMerma", "rollDecrementation", "turnfloat", "roundInterment", "addincremented", "rollDecremented", "roundSegMENT", "rollDecrements", "roundDecrementation", "addIncremented", "roundincrelement", "roundImprovestant", "roundSetlement", "roundDecrements", "roundImprovement", "RoundAdjustmented", "roundincrembol", "roundAdjustment", "roundincrements", "RoundAdjustment", "roundSegments", "roundDecremented", "roundDecreement", "RoundIncrements", "roundMerment", "roundincrement", "roundAdjustmented", "addIncrement", "turnMerment", "roundMeasureement", "roundInterument", "roundIncreement", "rollIncrement", "round_", "rollIncremented", "RoundSegment", "roundBeginmbol", "rollIncreli", "roundIncreli", "roundSegment", "turnIncrement", "roundSegension", "sortfloat", "roundSegstant", "quickIncrement", "roundSetment", "turnIncrementation", "roundSegma", "RoundSegement", "roundRemented", "roundSegavior", "roundDecrembol", "roundIncrelement", "roundMerma", "rollDecreument", "roundIncreument", "roundDecreument", "roundSegmentation", "rollIncrementation", "roundMeasurece", "quickIncrestant", "RoundIncreension", "roundMeasurement", "roundImprovementation", "roundImprovembol", "rollfloat", "roundincreli"], "roundBits": ["roundBitions", "roundOacks", "roundTounds", "callTats", "roundBots", "roundBsits", "callBats", "roundMbits", "roundBugs", "roundPins", "roundSacks", "roundEbits", "roundAliit", "roundBalits", "roundTits", "roundBalbits", "roundBalats", "roundBit", " roundBitions", "roundEigs", "roundOits", "roundMits", "roundbit", "callBbits", "roundOins", "roundPits", " roundMits", "roundAliits", "buildBugs", "roundBsbits", "rollSacks", "roundTbits", "sortBots", "roundAliugs", "roundBigs", "roundbugs", "roundSbits", "callTooks", "roundbins", "roundOITS", "roundAliins", "roundEitions", "roundTooks", "rollSins", "roundBuffits", "roundBooks", "roundBounds", "sortBits", "roundBacks", " roundBigs", "callBooks", "buildbits", "buildbit", " roundMitions", "roundTots", "roundSots", "roundEits", "roundBins", "roundBsigs", "buildbugs", "roundBats", "roundMitions", "rollBITS", "rollBacks", "roundSits", "buildBit", "rollSITS", "roundSins", "callBits", "callTbits", " roundBbits", "roundMigs", "roundBsitions", "rollBins", "roundBuffins", "roundTats", "buildbins", "callTits", "roundBbits", "roundBuffacks", "roundbits", "rollBits", "roundBalooks", " roundMbits", "roundBITS", "roundPugs", "buildBits", "roundPit", "roundSounds", "roundSooks", "sortBbits", "roundSITS", " roundMigs", "sortBounds", "rollSits", "roundSats", "roundBuffITS", "buildBins"], "isTiny": ["isTiet", "isNotiny", "isty", "isNtiny", "istiet", "isTyp", " isTy", "isTrip", "isNail", "isTale", "isNotale", "isDesty", "isUnttiny", " isNotail", "isPortrip", "isUntale", " isNottiny", "isDestiet", " isNotiny", "isStail", " isNotale", "isSandy", "isPortiny", " istyp", "isStrip", "isNottiny", "isUntail", " isTtiny", " isTiet", "isDestyp", "isPortail", "isSandyp", "isNale", "isPortale", "istyp", "istiny", " istiet", " isty", " isTale", "isNotrip", "isTtiny", "isSandiny", "isTy", "isSandiet", " isTrip", "isStiny", " istiny", "isNotail", " isTyp", "isNiny", "isTail", "isStale", " isNotrip", "isDestiny", "isUntiny", " isTail"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n", "idx": 18512, "substitutes": {"entry": ["error", "word", "ck", "enter", "option", "e", "ace", "header", "owner", "se", "insert", "inner", "common", "line", "ce", "attribute", "section", "import", "check", "connection", "index", "form", "server", "or", "result", "ry", "link", "command", "add", "response", "Entry", "up", "try", "escape", "complete", "ent", "ary", "cue", "view", "office", "event", "rance", "existent", "comment", "query", "match", "ment", "archive", "instance", "document", "element", "def", "request", "xml", "row", "no", "ie", "answer", "see", "component", "delete", "client", "cell", "empty", "application", "writer", "engine", "primary", "out", "image", "record", "member", "pair", "key", "RY", "search"], "size": ["izes", "offset", "mem", "index", "zone", "location", "memory", "si", "total", "settings", "max", "details", "win", "scale", "sum", "e", "count", "g", "south", "empty", "owner", "shape", "padding", "length", "password", "name", "address", "position", "ns", "bytes", "capacity", "limit", "area", "fee", "data", "pi", "ize", "storage", "range", "body", "id", "scope", "height", "parent", "message", "table", "number", "now", "space", "Size", "state", "SIZE", "cache", "network", "len", "share", "s", "small", "full", "code", "dimension", "mode", "type"], "address_index": ["Address_slice", " address_value", "Address_Index", "address__slice", " address_address", "address__key", "Address_index", "address__Index", "addressipIndex", "addressableIndex", "address_Index", " address_Index", "addressipbase", "addressptbase", "address_ind", "addressipind", "address_key", "addressablevalue", "address_value", "addressipindex", "address__index", "addressableindex", "Address_key", "address_base", " address_ind", "addressptaddress", "address_address", " address_base", "addressableaddress", "addressptindex", "addressptIndex", "address_slice"], "vaddr_base": ["vaddr7base", "vaddr7no", "vaddress_init", "vaddr8base", "vaddr2bas", "vobj_base", "vaddress_map", "vaddr2base", "vptr_base", "vaddr8index", "vaddrxbase", "vaddr2id", "vaddr_no", "vobj_buffer", "vaddr2Base", "vname7base", "vaddr__server", "vaddr_server", "vaddrxserver", "vaddress__server", "vaddr8no", "vaddr7index", "vaddr_cache", "vaddrxmap", "vaddress2init", "vname_index", "vname7index", "vaddr_map", "vaddr__buffer", "vaddress2Base", "vaddress__cache", "vaddrablebalance", "vaddr_b", "vname7no", "vptr_balance", "vaddr2init", "vaddr7bin", "vaddr_index", "vobj_bas", "vaddr8bin", "vptr_bind", "vname_no", "vaddr___map", "vaddr_balance", "vaddress_buffer", "vaddress_index", "vptr_b", "vaddramBase", "vaddrablebase", "vaddress_bas", "vptr_buffer", "vaddr__cache", "vaddress_cache", "vaddr__index", "vname7bin", "vaddr_bind", "vaddrambase", "vaddr__base", "vaddr2buffer", "vaddr___cache", "vaddr__map", "vaddr___server", "vaddress_Base", "vaddr_Base", "vaddr__bas", "vaddr_init", "vaddr___base", "vaddress__map", "vptr_id", "vaddress_server", "vaddr_id", "vaddrablebind", "vaddress_base", "vaddrxcache", "vaddress2bas", "vaddr_buffer", "vaddr_bin", "vaddress__base", "vaddr_bas", "vobj_id", "vaddrambas", "vname_base", "vname_bin", "vaddraminit", "vaddress2base"], "pfns": ["mfmics", "pfbxs", " pfnis", " pffs", "pfefs", "mfics", "psfnis", "fpfrNs", "pfiens", "fpfns", "pffs", "pfifs", " pfnames", "pcfains", "pcfgs", " pfcons", "pfons", " pcfains", "mfmds", "pfmuns", "psfns", "pfcs", "pfmics", "pfrNs", "mfmuns", "pfnames", " pfcnames", " pfains", "psffs", "pbfgs", "pfbains", "fpfrns", " pfbfs", "pfiNs", " pcfxs", "pfics", "pfpds", "pfcnames", "pfbcs", "mfns", "pfcns", "pfNs", "pfsns", "pfsds", "fpfrfs", "pfbns", "pfxfs", "pcfns", "pfrens", "pfxs", " pfgs", "pcfxs", " pfxs", "pfains", "pcfds", "pfpuns", "pvns", "fpfNs", " pfcds", " pfcs", "pfds", "pbfxs", "pfcons", " pfons", "pfbnis", "pfcds", "pfecs", "pfbfs", " pfbnis", "pfsons", "pfins", "mfuns", "pfsnames", "pfpics", "pcfnames", " pfbcs", "pfenis", "fpfens", " pfcns", "pfmns", "pcfons", "pfuns", " pfbns", "mfmns", "pvuns", "mfds", "pfrns", "pfmds", "pfgs", "pfrfs", "pfxns", " pcfgs", "pfxens", " pcfns", " pfds", "pfbgs", "pfpns", "pbfains", "pfens", "psfcs", "pfnis", "pvds", "pfxNs", "fpffs", "pbfns", "fpfrens", "pvics"], "err": ["rm", "index", "rez", "error", "res", "arr", "or", "args", "ei", "result", "Error", "test", "gz", "kr", "ner", " Err", "e", "buf", "count", "exc", "fr", "eas", "mr", "rs", "gs", "rr", "ns", "cli", "Er", "attr", "iter", "ptr", "dr", "fee", "ef", "rev", "ind", "cr", "try", "inner", "rel", "r", "ev", "gr", "rss", "eps", "extra", "errors", "usr", "sol", "erd", "er", "rb", "notice", "env", "txt", "eor", "cb", "rn", "len", "resp", "orders", "rc", "it", "der", "ctr", "conf", "br", "oe"], "i": ["hi", "li", "span", "ri", "point", "I", "ai", "di", "mi", "c", "ji", "er", "chain", "multi", "ii", "index", "ij", "t", "ci", "q", "port", "\u0438", "phi", "v", "cli", "pi", "parent", "gi", "n", "o", "fi", "bi", "x", "zi", "ini", "f", "it", "iu", "init", "ic", "l", "ei", "qi", " ti", "me", " ii", "k", "instance", "ip", " j", "j", "ti", "print", " I", "ami", " si", " di", " bi", "ix", "b", "y", "m", "si", "im", "p", "ki", "u", "dr", "oi", "ind", "in", "id", "xi", "ui", "key", "ims", " ni", "sim", "us", "this"]}}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n", "idx": 18513, "substitutes": {"dev": ["debug", "mem", "adv", "os", "nt", "t", "w", "window", "pad", "Dev", "var", "md", "van", "th", "device", "nv", "DEV", "av", "development", "cam", "usb", "cast", "ad", "d", "db", "v", "pro", "hw", "doc", "ve", "wd", "iv", "sys", "conn", "sd", "priv", "cmd", "den", "ev", " Dev", "def", "develop", "env", "by", "Device", "api", "ver", "tech", "gu", "go", "devices", "serv", "dd"], "p": ["lp", "pr", "ping", "e", "g", "point", "vp", "tp", "pro", "pm", "c", "jp", "comm", "local", "pat", "cache", "pre", "pl", "pa", "s", "fp", "pe", "np", "dp", "t", "pp", "sp", "app", "q", "port", "d", "v", "pb", "ps", "pkg", "pi", "pt", "post", "n", "f", "it", "part", "a", "patch", "l", "wp", "w", "bp", "progress", "ip", "j", "cp", "php", "P", "b", "y", "m", "i", "h", "at", "pid", "pc", "op", "press", "u", "out", "pg", "rep", "pers", "r", "parse", "ap"], "ep": ["ea", "dp", "el", "eng", "oe", "wp", "pp", "dep", "ei", "yp", "ec", "bp", "ape", "e", "eur", "exc", "point", " e", "xp", "eh", "vp", "ebin", "em", "tp", "rep", "ew", "pb", "esc", "peg", "ip", "ps", "ef", "tip", "ee", "esp", "mp", " pe", "Ep", "pt", "elf", "eq", "EP", "peak", "ev", "et", "eps", "est", "eff", "ele", "eu", "gp", "er", "ent", "lip", "eve", "env", "resp", "cp", "eg", "except", "eb", "pe", "ap", "ek"], "ret": [" RET", "res", "pret", "nt", "t", "back", "flag", "git", "deg", "ter", "result", "vt", "Ret", "vet", "rt", "ben", " fut", "prop", "tr", "mt", "des", "out", "v", "reg", "tf", "cont", "lt", "ft", "rem", "cat", "RET", "rev", "re", "det", "reset", "reply", "lit", "att", "sat", "ref", "val", "def", "print", "alt", "repl", "aux", "got", "txt", "resp", "not", "gt", "bool", "elt", " alt", "rets"]}}
{"project": "FFmpeg", "commit_id": "64e105e051ca3e5088b0db64551244482b2836b4", "target": 0, "func": "static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)\n\n{\n\n    DynBuffer *d = opaque;\n\n    int new_size, new_allocated_size;\n\n    UINT8 *new_buffer;\n\n    \n\n    /* reallocate buffer if needed */\n\n    new_size = d->pos + buf_size;\n\n    new_allocated_size = d->allocated_size;\n\n    while (new_size > new_allocated_size) {\n\n        if (!new_allocated_size)\n\n            new_allocated_size = new_size;\n\n        else\n\n            new_allocated_size = (new_allocated_size * 3) / 2;\n\n    }\n\n    \n\n    if (new_allocated_size > d->allocated_size) {\n\n        new_buffer = av_malloc(new_allocated_size);\n\n        if (!new_buffer)\n\n            return;\n\n        memcpy(new_buffer, d->buffer, d->size);\n\n        av_free(d->buffer);\n\n        d->buffer = new_buffer;\n\n        d->allocated_size = new_allocated_size;\n\n    }\n\n    memcpy(d->buffer + d->pos, buf, buf_size);\n\n    d->pos = new_size;\n\n    if (d->pos > d->size)\n\n        d->size = d->pos;\n\n}\n", "idx": 18518, "substitutes": {"opaque": ["Opatile", "opent", "Opus", "Opaque", "oplus", "iopacity", "Oposter", "oposter", "poster", "obaque", "opus", "opaques", "opatile", "oplent", "Opaques", "oplaque", "obaques", "Opent", "Opacity", "iopatile", "iopaque", "obent", "opacity", "ioposter", "paque", "pacity", "patile", "obus", "oplaques"], "buf": ["mem", "cap", "cv", "Buff", "prev", "arr", "img", "bb", "bar", "proc", "enc", "fb", "vec", " buffer", "bg", "queue", "BU", "bc", "v", "bytes", "pb", "wb", "doc", "data", "cmd", "msg", "func", "batch", "raw", "bf", "rb", "cb", "block", "uf", "buffer", "Buffer", "buff", "b", "br"], "buf_size": ["buf_SIZE", "vecptspace", "buf64weight", "bufptnum", "bufptweight", "bufptspace", "vecptweight", "vecptsize", "buf_weight", "buf_num", "bufLengthsize", "vec_size", " buf_SIZE", " buf_length", "buf64space", "buf_space", "bufptsize", "vec_num", "vecptnum", "buf64size", "buf_index", " buf_index", "vec_space", "bufLengthSIZE", "buf64num", "buf_length", "vec_weight", "bufLengthindex"], "d": ["more", "debug", "td", "ds", "fd", "z", "dp", "ord", "l", "and", "die", "de", "p", "dt", "md", "q", "at", "dot", "mod", "g", "dq", "dl", "dat", "done", "bd", "ad", "m", "db", "di", "da", "dr", "ade", "wd", "add", "sd", "rd", "c", "ind", "dm", "j", "dev", "pd", "new", "dos", "draw", "ud", "dc", "D", "n", "dict", "du", "diff", "del", "dh", "gd", "ld", "dump", "nd", "dx", "did", "rest", "al", "ed", "od", "y", "dd", "dn"], "new_size": ["new7start", " new_Size", "old_name", "new64Size", "recent_name", "new64status", "new64name", "job_code", "new00start", "job67code", "job_size", "new_offset", "old_size", "new67code", "new7size", "recent_size", "new___len", "new_sym", " new_speed", "new00size", "new67start", "normal_len", "new67size", "new64size", "newvalsym", "newvalstatus", "new_send", "newrowscore", "new_name", "job_start", "new67offset", "new_item", "new___send", "new67export", "normal_send", "newrowsend", "new67Size", "newvalsize", "new_speed", "new_Size", "new7export", "job67start", "job_export", "new_export", "recent_item", "old_status", "job67size", "new_score", "newvalname", "new67speed", "new___score", "job67export", "new_start", "new00code", "new64speed", "old_sym", "new64offset", " new_offset", "new_code", "new00export", "new_status", "newrowsize", "new7code", "newrowlen", "normal_size", "normal_score", "new_len", "new___size", "new64sym"], "new_allocated_size": ["new_allocatedamspace", "new_allised_size", "new_allocated_sum", "new_allocated_score", "new_allocated_sequence", "new_allowed_size", "new_allowed_too", "new_allocation_count", "new_allowed_SIZE", "new_allocated_string", "new_allocatingermessage", "new_allocated_SIZE", "new_allocated\u05bcsize", "new_allocateditysize", "new_allocation_size", "new_allocatededname", "new_allocating_sequence", "new_allocatededSIZE", "new_allocated\u05bcsum", "new_allocated_too", "new_allocatingerstring", "new_allocation_Size", "new_allocated\u05bcscore", "new_allocation_scope", "new_allocatedstoo", "new_allocated_count", "new_allised_offset", "new_allocated_storage", "new_allocated_Size", "new_allocated_name", "new_allocatedlysize", "new_allocated_offset", "new_allocation_storage", "new_allocatedlyclient", "new_allocatedlysequence", "new_allocatedityspace", "new_allocation_space", "new_allocatedityoffset", "new_allocated_scope", "new_allised_space", "new_allocation_SIZE", "new_allocated_scale", "new_allocatededsize", "new_allocated_message", "new_allisedamsize", "new_allocatedamsize", "new_allocatederstring", "new_allisedamoffset", "new_allocating_client", "new_allocating_message", "new_allisedamspace", "new_allocatedersize", "new_allocatingersize", "new_allocating_size", "new_allocatededstorage", "new_allocation_sum", "new_allocatededscope", "new_allocation_scale", "new_allocation_name", "new_allocatedsSIZE", "new_allocatedamoffset", "new_allocated_space", "new_allocatedermessage", "new_allocating_string", "new_allocated_client", "new_allocatedssize"], "new_buffer": [" new_button", "new_memory", " new_memory", "newJsize", "new_button", "newJbuffer", " new_window", "current_buff", "newsJbuffer", "free_window", "new__buff", "current_buffer", "free_channel", "new_term", "current_term", "current___term", "new___iter", "current_iter", " new_iter", " new_buff", "news_size", "current___buffer", "new1memory", "new_blank", "new___buffer", "new___buff", "news_buffer", "current___buff", "free_buffer", "newjbuffer", "newptbuff", "newjblank", "new___term", "new1buffer", "new1buff", "new_window", "newptbuffer", "new___binary", "current___iter", "new__memory", "new___window", "newsJblank", "new_binary", "new1iter", "newptiter", "new_iter", "new_variable", "newptterm", "new__buffer", "news_blank", "new_channel", "new___button", "free_variable", "new__iter", "newjsize", " new_binary", "newsJsize", "newJblank", "new_buff"]}}
{"project": "FFmpeg", "commit_id": "20da77449d4427a7152b80e4f9acce6a8c93ee7d", "target": 0, "func": "static inline int RENAME(yuv420_rgb24)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*3 > dstStride[0]) h_size-=8;\n\n    \n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\nYUV2RGB\n\n\t/* mm0=B, %%mm2=G, %%mm1=R */\n\n#ifdef HAVE_MMX2\n\n\t\t\t\"movq \"MANGLE(M24A)\", %%mm4\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(M24C)\", %%mm7\t\\n\\t\"\n\n\t\t\t\"pshufw $0x50, %%mm0, %%mm5\t\\n\\t\" /* B3 B2 B3 B2  B1 B0 B1 B0 */\n\n\t\t\t\"pshufw $0x50, %%mm2, %%mm3\t\\n\\t\" /* G3 G2 G3 G2  G1 G0 G1 G0 */\n\n\t\t\t\"pshufw $0x00, %%mm1, %%mm6\t\\n\\t\" /* R1 R0 R1 R0  R1 R0 R1 R0 */\n\n\n\n\t\t\t\"pand %%mm4, %%mm5\t\t\\n\\t\" /*    B2        B1       B0 */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G2        G1       G0 */\n\n\t\t\t\"pand %%mm7, %%mm6\t\t\\n\\t\" /*       R1        R0       */\n\n\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* G2        G1       G0    */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"psrlq $8, %%mm2\t\t\\n\\t\" /* 00 G7 G6 G5  G4 G3 G2 G1 */\n\n\t\t\t\"pshufw $0xA5, %%mm0, %%mm5\t\\n\\t\" /* B5 B4 B5 B4  B3 B2 B3 B2 */\n\n\t\t\t\"pshufw $0x55, %%mm2, %%mm3\t\\n\\t\" /* G4 G3 G4 G3  G4 G3 G4 G3 */\n\n\t\t\t\"pshufw $0xA5, %%mm1, %%mm6\t\\n\\t\" /* R5 R4 R5 R4  R3 R2 R3 R2 */\n\n\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm5\t\\n\\t\" /* B5       B4        B3    */\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" /*       G4        G3       */\n\n\t\t\t\"pand %%mm4, %%mm6\t\t\\n\\t\" /*    R4        R3       R2 */\n\n\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\" /* B5    G4 B4     G3 B3    */\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"pshufw $0xFF, %%mm0, %%mm5\t\\n\\t\" /* B7 B6 B7 B6  B7 B6 B6 B7 */\n\n\t\t\t\"pshufw $0xFA, %%mm2, %%mm3\t\\n\\t\" /* 00 G7 00 G7  G6 G5 G6 G5 */\n\n\t\t\t\"pshufw $0xFA, %%mm1, %%mm6\t\\n\\t\" /* R7 R6 R7 R6  R5 R4 R5 R4 */\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"pand %%mm7, %%mm5\t\t\\n\\t\" /*       B7        B6       */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G7        G6       G5 */\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm6\t\\n\\t\" /* R7       R6        R5    */\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\\\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 16(%1)\t\t\\n\\t\"\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\n\n#else\n\n\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm0, %%mm5\t\t\\n\\t\" /* B */\n\n\t\t\t\"movq %%mm1, %%mm6\t\t\\n\\t\" /* R */\n\n\t\t\t\"punpcklbw %%mm2, %%mm0\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"punpcklbw %%mm4, %%mm1\t\t\\n\\t\" /* 0R0R0R0R 0 */\n\n\t\t\t\"punpckhbw %%mm2, %%mm5\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpckhbw %%mm4, %%mm6\t\t\\n\\t\" /* 0R0R0R0R 2 */\n\n\t\t\t\"movq %%mm0, %%mm7\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"movq %%mm5, %%mm3\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpcklwd %%mm1, %%mm7\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"punpckhwd %%mm1, %%mm0\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"punpcklwd %%mm6, %%mm5\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"punpckhwd %%mm6, %%mm3\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"movq %%mm7, %%mm2\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"psllq $40, %%mm7\t\t\\n\\t\" /* RGB00000 0 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* RGB00000 1 */\n\n\t\t\t\"psllq $40, %%mm5\t\t\\n\\t\" /* RGB00000 2 */\n\n\t\t\t\"psllq $40, %%mm3\t\t\\n\\t\" /* RGB00000 3 */\n\n\n\n\t\t\t\"punpckhdq %%mm2, %%mm7\t\t\\n\\t\" /* 0RGBRGB0 0 */\n\n\t\t\t\"punpckhdq %%mm6, %%mm0\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"punpckhdq %%mm1, %%mm5\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"punpckhdq %%mm4, %%mm3\t\t\\n\\t\" /* 0RGBRGB0 3 */\n\n\n\n\t\t\t\"psrlq $8, %%mm7\t\t\\n\\t\" /* 00RGBRGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* GB000000 1 */\n\n\t\t\t\"por %%mm0, %%mm7\t\t\\n\\t\" /* GBRGBRGB 0 */\n\n\t\t\tMOVNTQ\" %%mm7, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"psrlq $24, %%mm6\t\t\\n\\t\" /* 0000RGBR 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"psllq $24, %%mm5\t\t\\n\\t\" /* BRGB0000 2 */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" /* BRGBRGBR 1 */\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\n\n\t\t\t\"psrlq $40, %%mm1\t\t\\n\\t\" /* 000000RG 2 */\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* RGBRGB00 3 */\n\n\t\t\t\"por %%mm3, %%mm1\t\t\\n\\t\" /* RGBRGBRG 2 */\n\n\t\t\tMOVNTQ\" %%mm1, 16(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n#endif\n\n\t\t     \n\n\t\t     \"add $24, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\t\t     \n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n    return srcSliceH;\n\n}\n", "idx": 18523, "substitutes": {"c": ["con", "cv", "cs", "tc", "l", "ca", "t", "ci", "p", "ec", "h", "enc", "ctx", "e", "g", "cf", "cc", "bc", "ch", "ct", "d", "co", "v", "etc", "cd", "cont", "cr", "lc", "coll", "dc", "n", "C", "cm", "fc", "ce", "cu", "cb", "s", "cp", "rc", "f", "ac", "b", "conf", "m"], "src": ["sc", "grad", "loc", "sort", "img", "sh", "sb", "lib", "sub", "ins", "st", "proc", "input", "sq", "stream", "bh", "rt", "bs", "cur", "usc", "rs", "conv", "sw", "ptr", "supp", "stab", "iter", "iv", "sys", "sn", "attr", "via", "req", "pkg", "in", "func", "inst", "std", "usr", "fc", "rb", "source", "sr", "s", "rc", "sur", "ctr", "sl", "dest", "ser", "rl", "hl"], "srcStride": ["srcStides", "srcRestrate", "rcStrides", "srcStr", "rcStides", "srcStrrate", "srcConstrate", "rcStrse", "rcStride", "rcStrip", "srcRestide", "srcConstide", "srcStri", "srcSlide", "srcStro", "srcSTride", "srcstr", "srcSlride", "srcStrrip", "srcSTse", "srcSlr", "srcStrri", "rcStro", "srcSTide", "srcStrr", "srcSlri", "srcstride", "srcStse", "srcStope", "rcStope", "srcstide", "rcStide", "rcStrope", "srcStrate", "rcStr", "srcConstope", "rcStrr", "srcStrides", "srcRestride", "srcRestope", "rcStrri", "srcSTrip", "srcStide", "srcstides", "srcSlro", "srcRestro", "srcSlrip", "rcStri", "rcStse", "rcStrrate", "srcStrride", "srcStrro", "srcStrope", "srcConstride", "srcStrip", "srcSTr", "srcStrse", "srcSlse", "rcStrrip", "srcSTides", "rcStrro", "rcStrate", "rcStrride"], "srcSliceY": ["srcSlidey", "srcSLideY", "srcSlideX", "srcSlsliceT", "srcSlICET", "srcSLiceX", "srcSLiceT", "srcSlideH", "srcSlsliceH", "srcSLICEX", "srcSLiceY", "srcSLideT", "srcSLICEH", "srcSLICEY", "srcSlsliceX", "srcSlicey", "srcSliceT", "srcSliceX", "srcSLicey", "srcSLICEy", "srcSLiceH", "srcSlideT", "srcSlICEy", "srcSLideX", "srcSlsliceY", "srcSLideH", "srcSlICEY", "srcSlICEH", "srcSlideY", "srcSlICEX"], "srcSliceH": ["srcsliceHT", "srcSluceY", "srcsliceY", "srcslICEY", "srcSlideW", "srcslICEH", "srcSlideH", "srcSliceHT", "srcsliceSH", "srcSlieHH", "srcSlICESH", "srcSliceSH", "srcSlicedSH", "srcSlideHT", "srcSluceHH", "srcSluceH", "srcsliceH", "srcSlicedHT", "srcSlicedH", "srcSliceHH", "srcSlieY", "srcSlicedY", "srcSlICEY", "srcSlideSH", "srcslICESH", "srcSlICEHT", "srcSlICEH", "srcSlideHH", "srcslICEHT", "srcSlieH", "srcSlideY", "srcSluceW", "srcSlieW", "srcSliceW"], "dst": ["ddest", "dsts", "dasp", "bdest", "Dsts", " dnd", " dest", "Dsp", "rdest", "Dst", " dsts", "dast", "dsp", "bdnd", "bdst", "rst", "Dnd", "dadest", "rsp", "rsts", "Dest", "Ddest", "dnd", "bdsts", "dasts", "dest"], "dstStride": ["dsrcStrause", "dsrcStro", "dstRestide", "dsrcStause", "dstStrause", "dstrStride", "dsrcStr", "dstRestause", "dstEstride", "dsrcStrr", "dstSlide", "dstEstope", "dstDide", "dsrcStrro", "dstRestack", "dstStrride", "dstStack", "dstrStack", "dstRestride", "dsrcStide", "dstStrack", "dstStause", "dstDro", "dstStope", "dstEstr", "dstSlride", "dstStr", "dstrRestack", "dstStrope", "dstSlrip", "dstStide", "dstRestro", "dsrcStrope", "dstDride", "dstDause", "dstStro", "dstStrr", "dstStrip", "dsrcStrride", "dstStrrip", "dsrcStride", "dstrStrip", "dsrcStope", "dstEstide", "dstrRestr", "dstrStr", "dstSlope", "dstrRestrip", "dstStrro", "dstRestrip", "dstrRestride", "dstSlr", "dstSlack", "dstRestr"], "y": ["yi", "ies", "iley", "sky", "ly", " busy", "z", "size", "t", "ys", "i", "yr", "aily", "h", "xy", " ly", "axy", "kit", "ady", " ay", "sy", "ey", "ym", " i", "py", " py", "ot", "ch", "yd", " ye", "scroll", "ay", "say", " ty", "ya", "icy", "my", "ye", "yy", " j", "yer", "j", "vy", "hey", "height", "gy", "wy", "uy", "ley", "try", "dy", "ery", "n", "ny", "key", "yt", "iy", "x", " ya", "by", "Y", "oy", "ky", "yl", "b", "cy", "m"], "h_size": ["h_score", "hr_scroll", "h_group", "h_scroll", " h2len", "bh___Size", "bh_size", "h2SIZE", "bh_Size", " h_score", "h2size", "h___ize", "bh___size", "d_size", "h_len", "huffysize", "h_Size", " h2score", " h2size", "d_storage", "hr_Size", "H_Size", "hr_size", "h2scroll", "h_ize", "h_sized", "h2sized", "huffylen", "H_SIZE", "h_capacity", " h_len", "H_ize", "H_size", "huffyscore", "h___size", "h_SIZE", "hr_capacity", "h2len", "bh_sized", "bh___ize", "h_storage", "bh_ize", "huffySize", " h_Size", "h2capacity", "h2score", "d_ize", "h___sized", " h2Size", "h2ize", "bh___sized", "d_group", "h___Size", "h2Size"], "_image": ["_png", " _png", "_code", "_img", " _img", " _code"], "_py": ["tpy", " _p", " _ps", " _xy", "_ps", "tp", "_xy", "txy", "tps", "_p"], "_pu": ["_mp", " _p", " _pse", "tmp", "tpu", " _mp", "tp", "_pse", "tpse", "_p"], "_pv": ["____cpx", "_pvp", "____pvp", "_spvp", "_cpvp", "____ppt", "____cpvp", "_spv", "_cpx", "_px", "_sppt", "____px", "_cppt", "_Pv", "_Pvp", "_Ppt", "_ppt", "____cppt", "_spx", "_Px", "____pv", "_cpv", "____cpv"]}}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int hex_to_data(uint8_t *data, const char *p)\n\n{\n\n    int c, len, v;\n\n\n\n    len = 0;\n\n    v = 1;\n\n    for(;;) {\n\n        skip_spaces(&p);\n\n        if (*p == '\\0')\n\n            break;\n\n        c = toupper((unsigned char)*p++);\n\n        if (c >= '0' && c <= '9')\n\n            c = c - '0';\n\n        else if (c >= 'A' && c <= 'F')\n\n            c = c - 'A' + 10;\n\n        else\n\n            break;\n\n        v = (v << 4) | c;\n\n        if (v & 0x100) {\n\n            if (data)\n\n                data[len] = v;\n\n            len++;\n\n            v = 1;\n\n        }\n\n    }\n\n    return len;\n\n}\n", "idx": 18529, "substitutes": {"data": ["next", "rew", "np", "bool", "size", "t", "w", "window", "format", "pad", "valid", "list", "h", "text", "e", "buf", "empty", "dat", "ata", "map", "length", "done", "rec", "ad", "d", "DATA", "bytes", "db", "Data", "partial", "image", "to", "rel", "parent", "batch", "options", "message", "table", "def", "str", "o", "extra", "raw", "cache", "block", "bin", "buffer", "full", "b", "this", "br"], "p": ["pos", "lp", "np", "l", "t", "w", "wp", "i", "pp", "sp", "ping", "h", "q", "bp", "pid", "at", "pc", "pard", "g", "point", "vp", "padding", "tp", "d", "pointer", "pb", "k", "ip", "ps", "pt", "pers", "r", "jp", "n", "pat", "par", "pa", "cp", "f", "fp", "part", "P", "pe", "b", "ap", "m"], "c": ["con", "ic", "cs", "cv", "tc", "l", "ca", "mac", "t", " cr", " cc", "z", "ach", "ci", " cur", "mc", "ec", "enc", "h", "err", "unc", "pc", "gc", "cl", "g", "cur", "cf", " ch", "vc", "ct", "cc", "ch", "bc", "co", "conv", "cd", " tc", "cont", "cat", "uc", "r", " mc", "cmp", "lc", "cm", "dc", "C", "fc", "ce", "cod", "cu", "cache", "cb", "nc", "s", "rc", "f", "ac", "cp", "comp", "sc", "b", "cy", "col"], "len": [" length", "offset", "pos", "lp", "ul", "lv", "fl", "loc", "vel", "l", "el", "nt", "size", "fn", "hl", " el", "i", "gl", "lf", "en", " n", "ll", "h", "end", "li", "ret", "e", "fr", "vec", "dl", " l", "il", "length", "d", "ln", "limit", "ptr", "iter", "bl", "lt", "mi", "ind", "nl", " j", "lin", "den", "rel", "val", "kl", "L", "cmp", "ell", "n", "lan", "alt", "x", "lim", "ls", "ld", "vol", "mid", "f", "fp", "Len", "gen", "sl", "elt", "m"], "v": ["vi", "cv", "lv", "l", "qv", "size", "t", "w", "wire", "i", "var", "vt", "q", "va", "nv", "av", "g", "sv", "vp", "u", "vc", "length", "ch", "conv", "d", "uv", "limit", "vs", "ve", "iv", "value", "j", "ev", "val", "version", "V", "n", "x", "mint", "vo", "vol", "ver", "vv", "f", "tv", "b", "vd", "m"]}}
{"project": "FFmpeg", "commit_id": "fa30a0a54854cd291008c065dfaf45d610e3cd04", "target": 0, "func": "static int RENAME(dct_quantize)(MpegEncContext *s,\n\n                            int16_t *block, int n,\n\n                            int qscale, int *overflow)\n\n{\n\n    x86_reg last_non_zero_p1;\n\n    int level=0, q; //=0 is because gcc says uninitialized ...\n\n    const uint16_t *qmat, *bias;\n\n    LOCAL_ALIGNED_16(int16_t, temp_block, [64]);\n\n\n\n    av_assert2((7&(int)(&temp_block[0])) == 0); //did gcc align it correctly?\n\n\n\n    //s->fdct (block);\n\n    RENAME_FDCT(ff_fdct)(block); // cannot be anything else ...\n\n\n\n    if(s->dct_error_sum)\n\n        s->denoise_dct(s, block);\n\n\n\n    if (s->mb_intra) {\n\n        int dummy;\n\n        if (n < 4){\n\n            q = s->y_dc_scale;\n\n            bias = s->q_intra_matrix16[qscale][1];\n\n            qmat = s->q_intra_matrix16[qscale][0];\n\n        }else{\n\n            q = s->c_dc_scale;\n\n            bias = s->q_chroma_intra_matrix16[qscale][1];\n\n            qmat = s->q_chroma_intra_matrix16[qscale][0];\n\n        }\n\n        /* note: block[0] is assumed to be positive */\n\n        if (!s->h263_aic) {\n\n        __asm__ volatile (\n\n                \"mul %%ecx                \\n\\t\"\n\n                : \"=d\" (level), \"=a\"(dummy)\n\n                : \"a\" ((block[0]>>2) + q), \"c\" (ff_inverse[q<<1])\n\n        );\n\n        } else\n\n            /* For AIC we skip quant/dequant of INTRADC */\n\n            level = (block[0] + 4)>>3;\n\n\n\n        block[0]=0; //avoid fake overflow\n\n//        temp_block[0] = (block[0] + (q >> 1)) / q;\n\n        last_non_zero_p1 = 1;\n\n    } else {\n\n        last_non_zero_p1 = 0;\n\n        bias = s->q_inter_matrix16[qscale][1];\n\n        qmat = s->q_inter_matrix16[qscale][0];\n\n    }\n\n\n\n    if((s->out_format == FMT_H263 || s->out_format == FMT_H261) && s->mpeg_quant==0){\n\n\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            MOVQ\" (%2), \"MM\"5                   \\n\\t\" // qmat[0]\n\n            \"pxor \"MM\"6, \"MM\"6                  \\n\\t\"\n\n            \"psubw (%3), \"MM\"6                  \\n\\t\" // -bias[0]\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            \"psubusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat), \"r\" (bias),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }else{ // FMT_H263\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            MOVQ\" (%3, %%\"FF_REG_a\"), \"MM\"6     \\n\\t\" // bias[0]\n\n            \"paddusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            MOVQ\" (%2, %%\"FF_REG_a\"), \"MM\"5     \\n\\t\" // qmat[i]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] + bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat+64), \"r\" (bias+64),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }\n\n    __asm__ volatile(\n\n        \"movd %1, \"MM\"1                     \\n\\t\" // max_qcoeff\n\n        SPREADW(MM\"1\")\n\n        \"psubusw \"MM\"1, \"MM\"4               \\n\\t\"\n\n        \"packuswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#if COMPILE_TEMPLATE_SSE2\n\n        \"packsswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#endif\n\n        \"movd \"MM\"4, %0                     \\n\\t\" // *overflow\n\n        : \"=g\" (*overflow)\n\n        : \"g\" (s->max_qcoeff)\n\n    );\n\n\n\n    if(s->mb_intra) block[0]= level;\n\n    else            block[0]= temp_block[0];\n\n\n\n    if (s->idsp.perm_type == FF_IDCT_PERM_SIMPLE) {\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x08] = temp_block[0x01]; block[0x10] = temp_block[0x08];\n\n        block[0x20] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x18] = temp_block[0x09]; block[0x04] = temp_block[0x02];\n\n        block[0x09] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x14] = temp_block[0x0A]; block[0x28] = temp_block[0x11];\n\n        block[0x12] = temp_block[0x18]; block[0x02] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1A] = temp_block[0x19]; block[0x24] = temp_block[0x12];\n\n        block[0x19] = temp_block[0x0B]; block[0x01] = temp_block[0x04];\n\n        block[0x0C] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x11] = temp_block[0x0C]; block[0x29] = temp_block[0x13];\n\n        block[0x16] = temp_block[0x1A]; block[0x0A] = temp_block[0x21];\n\n        block[0x30] = temp_block[0x28]; block[0x22] = temp_block[0x30];\n\n        block[0x38] = temp_block[0x29]; block[0x06] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x21] = temp_block[0x14];\n\n        block[0x1C] = temp_block[0x0D]; block[0x05] = temp_block[0x06];\n\n        block[0x0D] = temp_block[0x07]; block[0x15] = temp_block[0x0E];\n\n        block[0x2C] = temp_block[0x15]; block[0x13] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x0B] = temp_block[0x23]; block[0x34] = temp_block[0x2A];\n\n        block[0x2A] = temp_block[0x31]; block[0x32] = temp_block[0x38];\n\n        block[0x3A] = temp_block[0x39]; block[0x26] = temp_block[0x32];\n\n        block[0x39] = temp_block[0x2B]; block[0x03] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x25] = temp_block[0x16];\n\n        block[0x1D] = temp_block[0x0F]; block[0x2D] = temp_block[0x17];\n\n        block[0x17] = temp_block[0x1E]; block[0x0E] = temp_block[0x25];\n\n        block[0x31] = temp_block[0x2C]; block[0x2B] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x36] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x23] = temp_block[0x34]; block[0x3C] = temp_block[0x2D];\n\n        block[0x07] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x0F] = temp_block[0x27]; block[0x35] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x2E] = temp_block[0x35]; block[0x33] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x27] = temp_block[0x36];\n\n        block[0x3D] = temp_block[0x2F]; block[0x2F] = temp_block[0x37];\n\n        block[0x37] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else if(s->idsp.perm_type == FF_IDCT_PERM_LIBMPEG2){\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x04] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x0C] = temp_block[0x09]; block[0x01] = temp_block[0x02];\n\n        block[0x05] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x09] = temp_block[0x0A]; block[0x14] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1C] = temp_block[0x19];\n\n        block[0x11] = temp_block[0x12]; block[0x0D] = temp_block[0x0B];\n\n        block[0x02] = temp_block[0x04]; block[0x06] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0A] = temp_block[0x0C]; block[0x15] = temp_block[0x13];\n\n        block[0x19] = temp_block[0x1A]; block[0x24] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x2C] = temp_block[0x29]; block[0x21] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1D] = temp_block[0x1B]; block[0x12] = temp_block[0x14];\n\n        block[0x0E] = temp_block[0x0D]; block[0x03] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0B] = temp_block[0x0E];\n\n        block[0x16] = temp_block[0x15]; block[0x1A] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x25] = temp_block[0x23]; block[0x29] = temp_block[0x2A];\n\n        block[0x34] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x3C] = temp_block[0x39]; block[0x31] = temp_block[0x32];\n\n        block[0x2D] = temp_block[0x2B]; block[0x22] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x13] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1B] = temp_block[0x1E]; block[0x26] = temp_block[0x25];\n\n        block[0x2A] = temp_block[0x2C]; block[0x35] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x39] = temp_block[0x3A]; block[0x3D] = temp_block[0x3B];\n\n        block[0x32] = temp_block[0x34]; block[0x2E] = temp_block[0x2D];\n\n            block[0x23] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2B] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x36] = temp_block[0x35]; block[0x3A] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x33] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3B] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else{\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x01] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x09] = temp_block[0x09]; block[0x02] = temp_block[0x02];\n\n        block[0x03] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x0A] = temp_block[0x0A]; block[0x11] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x19] = temp_block[0x19];\n\n        block[0x12] = temp_block[0x12]; block[0x0B] = temp_block[0x0B];\n\n        block[0x04] = temp_block[0x04]; block[0x05] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0C] = temp_block[0x0C]; block[0x13] = temp_block[0x13];\n\n        block[0x1A] = temp_block[0x1A]; block[0x21] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x29] = temp_block[0x29]; block[0x22] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x14] = temp_block[0x14];\n\n        block[0x0D] = temp_block[0x0D]; block[0x06] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0E] = temp_block[0x0E];\n\n        block[0x15] = temp_block[0x15]; block[0x1C] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x23] = temp_block[0x23]; block[0x2A] = temp_block[0x2A];\n\n        block[0x31] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x39] = temp_block[0x39]; block[0x32] = temp_block[0x32];\n\n        block[0x2B] = temp_block[0x2B]; block[0x24] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1D] = temp_block[0x1D]; block[0x16] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1E] = temp_block[0x1E]; block[0x25] = temp_block[0x25];\n\n        block[0x2C] = temp_block[0x2C]; block[0x33] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x3A] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x34] = temp_block[0x34]; block[0x2D] = temp_block[0x2D];\n\n        block[0x26] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2E] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x35] = temp_block[0x35]; block[0x3C] = temp_block[0x3C];\n\n        block[0x3D] = temp_block[0x3D]; block[0x36] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3E] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }\n\n    end:\n\n    return last_non_zero_p1 - 1;\n\n}\n", "idx": 18545, "substitutes": {"s": ["z", "sg", "bits", "details", "ctx", "e", "g", "rs", "vs", "se", "self", "sys", "ants", "c", "es", "comm", "fs", "space", "er", "params", "series", "spec", "os", "ops", "t", "set", "S", "ss", "v", "sts", "ps", "steps", "ts", "ls", "stats", "sc", "comments", "a", "ds", "cs", "times", "l", "w", "sb", "ses", "changes", "als", "sv", "grades", "stat", "sw", "js", "b", "rates", "m", "hs", "args", "i", "p", "ins", "aws", "h", "is", "bs", "gs", "ns", "ats", "eps", "less", "ims", "ms", "its"], "block": ["init", "mem", "check", "frame", "channel", "word", "pop", "box", "blocks", "none", "w", "window", "ck", "Block", "tx", "pad", "proc", "list", "ml", "hash", "set", "base", "buf", "lock", "cl", "point", "empty", "map", "load", "shape", "link", "group", "disk", "length", "prefix", "other", "bc", "out", "image", "wall", "off", "limit", "k", "bl", "ip", "bit", "range", "in", "inv", "record", "ref", "sync", "line", "context", "join", "raw", "pack", "number", "blocking", "network", "x", "row", "bin", "panel", "buffer", "chain", "b", "byte", "loop", "type"], "n": ["na", " N", "nt", "l", "z", "np", "t", "size", "w", "i", "p", "num", "h", "count", "g", "name", "d", "v", "ns", "k", "nn", "nor", "sn", "nb", "c", "nl", "j", "r", "N", "nan", "nm", "x", "nc", "len", "b", "m"], "qscale": ["queryscan", "QScale", "qspec", "dqspec", "sqsync", "qqsystem", "sqscale", "qudelay", "iqserver", "qmap", "eqscale", "sqsche", "qradius", " qcale", "sqradius", "quspec", "qcale", "qmode", "qtscale", "qutest", "qusche", "queryscale", "iqsche", "quanttest", "sqstore", "quscale", "quradius", "quanttype", "quantscale", "querydelay", "qustore", "qtsystem", "sqmap", "iqscale", "sqmode", " qspec", "qtsync", "sqscan", "eqtest", "qumap", "sqmask", "Qcale", "qstore", "qtest", "eqmask", "qrate", "qtype", "quserver", "queryseries", "qutype", "dqscale", "eqdelay", "qsync", "querymode", "dqScale", "dqcale", "quantdelay", "queryrate", "qscan", "sqspec", "qumode", "qScale", "Qscale", "eqtype", "qmask", "querysync", "qdelay", "sqdelay", "iqspec", "qsystem", "Qspec", "sqsystem", "sqseries", "sqrate", "sqserver", "eqradius", "eqmap", "qseries", "qserver", "querysystem", "qqscale", "qqscan", "querystore", "qurate", " qScale", "qtseries", "qumask", "qqdelay", "qsche"], "overflow": ["overload", "overwrite", "underload", " overflows", "Overwrite", " overload", "Overload", "underflows", "Overflow", " overwrite", "underflow", "Overflows", "overflows", "underwrite"], "last_non_zero_p1": ["last_non_zero_fp1", "last_non_zero_t2", "last_non_zero_P3", "last_non_zero_P1", "last_non_zero_pc5", "last_non_zero_d3", "last_non_zero_pc3", "last_non_zero_d0", "last_non_zero_dons", "last_non_zero_fpons", "last_non_zero_Pons", "last_non_zero_t3", "last_non_zero_d1", "last_non_zero_pc2", "last_non_zero_p0", "last_non_zero_d2", "last_non_zero_pons", "last_non_zero_fp2", "last_non_zero_P0", "last_non_zero_fp3", "last_non_zero_p3", "last_non_zero_t5", "last_non_zero_pc1", "last_non_zero_p2", "last_non_zero_p5", "last_non_zero_P5", "last_non_zero_t1", "last_non_zero_P2"], "q": ["ue", "z", "qv", "t", "w", "depth", "question", "ck", "qu", "p", "pp", "qi", "sq", "ll", "query", "h", "qs", "level", "qual", "g", "lock", "load", "u", "quality", "queue", "ch", "iq", "d", "v", "charge", "k", "ip", "bit", "quad", "quant", "pkg", "eq", "j", "Q", "aq", "y", "qa", "qt", "f", "quit", "ix", "quick", "qq", "dq"], "qmat": ["qqformat", "quercmd", "qhat", "dqmat", "qumat", "sqformat", "qMat", " qhat", "sqmat", " qmem", "dqcol", "dqMat", "qcmd", "qmap", "eqmat", " qformat", "sqrix", "eqcol", "qrix", "qqmat", "qqrix", "querhat", "lockmat", "questmat", "dqman", "eqMat", "qqhat", "querscale", "qumap", "lockcmd", " qrix", "quermat", " qtar", "sqhat", "qman", "questtar", "qqcmd", "qutar", "qtar", "qqscale", " qmap", " qman", "qformat", " qcol", "questmem", "qcol", "lockscale", "qumem", "qmem", " qMat", "lockhat", "questmap", "eqman"], "bias": ["erbui", "biaid", "ebaid", "baid", "bbau", "ebabel", "ebui", "paid", " bali", "pias", "rbased", "brias", "erbaz", "rbias", "balias", "bbias", "based", " bia", "biia", "erbali", " bui", "bralias", " bau", "bui", "ebias", " baz", "rbali", "biabel", "baz", "biias", "bbali", "bia", "bbaz", "brased", "ebali", "pia", "bali", "rbalias", "pabel", "babel", "brali", "erbia", " based", "erbau", "erbias", " balias", "ebia", "bau"], "dummy": ["indummy", "indessert", "adatum", "dummies", " delta", "sdummies", " dummies", "Datum", "Dump", "adump", "dessert", "indummies", "sdummy", " dump", " dessert", "Delta", "datum", "adummy", "dump", "Dummy", "delta", "sdessert", " datum", "adelta"]}}
{"project": "FFmpeg", "commit_id": "491eaf35ae1f9b619441314bec33766e31580184", "target": 1, "func": "static void qdm2_fft_decode_tones (QDM2Context *q, int duration, GetBitContext *gb, int b)\n\n{\n\n    int channel, stereo, phase, exp;\n\n    int local_int_4,  local_int_8,  stereo_phase,  local_int_10;\n\n    int local_int_14, stereo_exp, local_int_20, local_int_28;\n\n    int n, offset;\n\n\n\n    local_int_4 = 0;\n\n    local_int_28 = 0;\n\n    local_int_20 = 2;\n\n    local_int_8 = (4 - duration);\n\n    local_int_10 = 1 << (q->group_order - duration - 1);\n\n    offset = 1;\n\n\n\n    while (1) {\n\n        if (q->superblocktype_2_3) {\n\n            while ((n = qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2)) < 2) {\n\n                offset = 1;\n\n                if (n == 0) {\n\n                    local_int_4 += local_int_10;\n\n                    local_int_28 += (1 << local_int_8);\n\n                } else {\n\n                    local_int_4 += 8*local_int_10;\n\n                    local_int_28 += (8 << local_int_8);\n\n                }\n\n            }\n\n            offset += (n - 2);\n\n        } else {\n\n            offset += qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2);\n\n            while (offset >= (local_int_10 - 1)) {\n\n                offset += (1 - (local_int_10 - 1));\n\n                local_int_4  += local_int_10;\n\n                local_int_28 += (1 << local_int_8);\n\n            }\n\n        }\n\n\n\n        if (local_int_4 >= q->group_size)\n\n\n\n\n        local_int_14 = (offset >> local_int_8);\n\n\n\n\n\n        if (q->nb_channels > 1) {\n\n            channel = get_bits1(gb);\n\n            stereo = get_bits1(gb);\n\n        } else {\n\n            channel = 0;\n\n            stereo = 0;\n\n        }\n\n\n\n        exp = qdm2_get_vlc(gb, (b ? &fft_level_exp_vlc : &fft_level_exp_alt_vlc), 0, 2);\n\n        exp += q->fft_level_exp[fft_level_index_table[local_int_14]];\n\n        exp = (exp < 0) ? 0 : exp;\n\n\n\n        phase = get_bits(gb, 3);\n\n        stereo_exp = 0;\n\n        stereo_phase = 0;\n\n\n\n        if (stereo) {\n\n            stereo_exp = (exp - qdm2_get_vlc(gb, &fft_stereo_exp_vlc, 0, 1));\n\n            stereo_phase = (phase - qdm2_get_vlc(gb, &fft_stereo_phase_vlc, 0, 1));\n\n            if (stereo_phase < 0)\n\n                stereo_phase += 8;\n\n        }\n\n\n\n        if (q->frequency_range > (local_int_14 + 1)) {\n\n            int sub_packet = (local_int_20 + local_int_28);\n\n\n\n            qdm2_fft_init_coefficient(q, sub_packet, offset, duration, channel, exp, phase);\n\n            if (stereo)\n\n                qdm2_fft_init_coefficient(q, sub_packet, offset, duration, (1 - channel), stereo_exp, stereo_phase);\n\n        }\n\n\n\n        offset++;\n\n    }\n\n}", "idx": 18556, "substitutes": {"q": ["ue", "z", "question", "t", "w", "ck", "qu", "p", "qi", "sq", "query", "h", "qs", " qu", "e", "conf", "g", "requ", "queue", "ch", "iq", "v", "k", "ve", "req", "c", "pkg", "eq", "Q", "r", "comm", "local", "aq", "quest", "qa", "qt", "f", "quit", "qq", "dq"], "duration": ["repeat", "format", "t", "window", "depth", "total", "i", "component", "p", "size", "dt", "bb", "timeout", "h", "uration", "base", "span", "count", "delay", "distance", "resolution", "padding", "length", "position", "m", "name", "db", "d", "v", "gain", "start", "Duration", "bid", "time", "nb", "c", "id", "record", "days", "date", "number", "dim", "sequence", "nr", "frequency", "gap", "version", "y", "seconds", "direction", "type"], "gb": ["bm", "cv", "bridge", "cgi", "phy", "gio", "sb", "bb", "emb", "gif", "gz", "gram", "fb", "gc", "pc", "bs", "g", "Gb", "gnu", "gs", "usb", "kb", "vc", "bg", "bc", "GB", "mb", "db", "ubis", "pg", "ch", "pb", "wb", "vg", "nb", "hub", "yg", "gg", "ogg", "gy", "cfg", "arb", "bf", "rg", "rb", "ib", "gd", "cb", "ug", "tg", "gin", "gm", "chn", "gt", "eb", "bn"], "b": ["bm", "a", "l", "t", "w", "i", "p", "sb", "bb", "bh", "bp", "base", "bs", "e", "g", "bg", "bc", "db", "d", "v", "B", "nb", "c", "r", "bf", "bank", "bi", "cb", "bt", "be", "ba", "buffer", "f", "eb", "y", "m"], "channel": ["chart", "frame", "pixel", "connection", "console", "chron", "component", "depth", "client", "annels", "color", "chip", "course", "cam", "button", "voice", "ann", "ch", "unit", "axis", "label", "chan", "c", "mode", "scope", "field", "version", "batch", "message", "member", "context", "camera", "Channel", "cho", "focus", "chn", "chain", "broad", "frequency", "byte", "direction", "category"], "stereo": ["spectipple", " stuster", "stuster", "STortion", " stochemistry", "Structure", "stipple", "Stereo", "STructure", "STereo", "ustructure", "stochemistry", "structochemistry", "spectereo", "Stere", " stopic", "steuster", " stere", "ustereo", "steopic", "spectortion", " stipple", "structopic", "stopic", "steereo", " structure", " stortion", "structuster", "stere", "Stipple", "ustere", "structereo", "steochemistry", "structure", "spectructure", "STipple", "ustipple", "stortion"], "phase": ["phy", "amp", "pid", "scale", "ape", "xp", "ase", "shape", "pro", "unit", "axis", "Phase", "ome", "pha", "id", "ref", "scope", "ph", "path", "dim", "ep", "phrase", "mid", "frequency", "version", "mode", "sample"], "local_int_4": ["local_iter_44", "local_int644", "local_int6444", "local_int108", "local_inc445", "local_ip_4", "local_int3240", "local_int00428", "local_int_r", "local_int_428", "local_inc_504", "local_int0045", "local_intc4", "local_int10410", "local_iter_10", "local_inc44", "local_int004", "local_float_04", "local_int___504", "local_iter_Four", "local_ip_four", "local_ip_8", "local_intcFour", "local_int_40", "local_intc04", "local_int___428", "local_int1040", "local_int3216", "local_int3204", "local_inc4504", "local_int1016", "local_int_44", "local_int64r", "local_int324", "local_int_Four", "local_int44", "local_int___45", "local_iter_04", "local_int106", "local_int4504", "local_float_16", "local_int_6", "local_float_40", "local_float_4", "local_int_45", "local_int4428", "local_ip_44", "local_int104", "local_str_6", "local_int_04", "local_int___4", "local_int6404", "local_int_504", "local_int_410", "local_str_8", "local_intc10", "local_inc_45", "local_int_16", "local_int_four", "local_int445", "local_int1004", "local_inc_4", "local_inc4428", "local_str_410", "local_iter_r", "local_int00504", "local_inc_428", "local_str_4", "local_iter_4"], "local_int_8": ["local_uint_08", "local_int108", "local_short_32", "local_str_810", "local_int_08", "local_int4808", "local_i_rin", "local_short0828", "local_intx18", "local_int48810", "local_int_18", "local_int488", "local_short_28", "local_int_i", "local_int_810", "local_inter_11", "local_int6411", "local_int10i", "local_inter_14", "local_intx08", "local_str_08", "local_int489", "local_int_0", "local_int_9", "local_uint_8", "local_int648", "local_str_0", "local_i_18", "local_float_08", "local_intx14", "local_inter_8", "local_float_4", "local_inter_08", "local_int104", "local_short0832", "local_int0832", "local_int_32", "local_short0810", "local_i_8", "local_int_rin", "local_int088", "local_str_8", "local_uint_18", "local_str_9", "local_i_14", "local_i_4", "local_i_08", "local_int1008", "local_str_10", "local_int6408", "local_short_10", "local_short_8", "local_int0828", "local_i_10", "local_uint_14", "local_int_11", "local_float_i", "local_short088", "local_intx8", "local_int0810", "local_int6414", "local_float_8", "local_str_4"], "stereo_phase": ["stadium_phase", "stadium_mid", "stadium_amp", "stereo_mid", "stereo_amp", "stadium_exp"], "local_int_10": ["local_int6420", "local_point_14", "local_int_08", "local_point_1000", "local_out_10", "local_point_iter", "local_int6440", "local_int3610", "local_point_ten", "local_int_40", "local_int_110", "local_int67iter", "local_int368", "local_point_20", "local_point_40", "local_out_5", "local_int6711", "local_int_1000", "local_point_9", "local_int_iter", "local_out98", "local_int_9", "local_int98", "local_int3612", "local_int_5", "local_int648", "local_int95", "local_point_8", "local_int678", "local_point_10", "local_int3608", "local_point_12", "local_out9110", "local_point_11", "local_out95", "local_int_11", "local_int6710", "local_int9110", "local_out_8", "local_int6410", "local_int_12", "local_out_110", "local_int_ten", "local_int910", "local_out910"], "local_int_14": ["local_int428", "local_INT_12", "local_int6714", "local_long428", "local_int4ml", "local_long4ml", "local_int67ml", "local_long_28", "local_INT_8", "local_int_15", "local_INT_28", "local_long_15", "local_long_14", "local_int414", "local_int_ml", "local_int6728", "local_long414", "local_int_12", "local_long415", "local_INT_14", "local_long_ml", "local_int415", "local_int6715"], "stereo_exp": ["stereo_scale", "stereo_comp", "stereo_xp", "stere_xp", "stere_exp", "stere_scale", "stere_comp"], "local_int_20": ["local_int17len", "local_uint_60", "local_int1720", "local_inst_20", "local_inst_8", "local_inst178", "local_inst_60", "local_int1760", "local_int178", "local_int_len", "local_int_60", "local_int_40", "local_inst1720", "local_inst1760", "local_uint_28", "local_inst_len", "local_uint_40", "local_inst17len", "local_uint_20"], "local_int_28": ["local_point_14", "local_bit_32", "local_int258", "local_int_58", "local_inter6721", "local_int_21", "local_bit_28", "local_bit_8", "local_int2558", "local_inter678", "local_int_23", "local_INT_28", "local_bit_14", "local_point_28", "local_inter_21", "local_int_27", "local_int6728", "local_int_29", "local_INT_58", "local_point_8", "local_int678", "local_inter6728", "local_inter_8", "local_int_32", "local_inter_28", "local_point_29", "local_bit_23", "local_int_148", "local_int6721", "local_int2528", "local_INT_8", "local_bit_27", "local_int25148", "local_INT_148"], "n": ["a", "na", " N", "nt", "l", "np", "fn", "t", "z", "i", "p", "num", "norm", "cn", "dn", "h", "ne", "e", "count", "g", "ni", "u", "name", "out", "d", "ns", "v", "k", "nn", "nor", "sn", "nb", "nu", "c", "nl", "j", "new", "number", "N", "o", "nan", "nm", "nc", "len", "net", "no", "y", "m"], "offset": ["Offset", "error", "size", "pad", "slot", "shift", "base", "balance", "e", "point", "upper", "length", "step", "stop", "origin", "attribute", "buffer", "url", "fp", "angle", "index", "usage", "timeout", "set", "end", "output", "onet", "amount", "scroll", "start", "pointer", "limit", "reset", "range", "skip", "o", "align", "len", "entry", "f", "it", "a", "location", "seed", "delay", "address", "instance", "addr", "time", "notation", "block", "lower", "pos", "window", "i", "translation", "p", "padding", "position", "off", "OFF", "reference", "area", "value", "data", "id", "ref", "message", "onto", "now", "alias", "frequency", "lag", "trace", "type"]}}
{"project": "qemu", "commit_id": "ff472a5badf8e6d964455de39ca67ea3a7758dea", "target": 1, "func": "static void cuda_receive_packet(CUDAState *s,\n\n                                const uint8_t *data, int len)\n\n{\n\n    uint8_t obuf[16] = { CUDA_PACKET, 0, data[0] };\n\n    int autopoll;\n\n    uint32_t ti;\n\n\n\n    switch(data[0]) {\n\n    case CUDA_AUTOPOLL:\n\n        autopoll = (data[1] != 0);\n\n        if (autopoll != s->autopoll) {\n\n            s->autopoll = autopoll;\n\n            if (autopoll) {\n\n                timer_mod(s->adb_poll_timer,\n\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n\n                               (get_ticks_per_sec() / CUDA_ADB_POLL_FREQ));\n\n            } else {\n\n                timer_del(s->adb_poll_timer);\n\n            }\n\n        }\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_6805_ADDR:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_SET_TIME:\n\n        ti = (((uint32_t)data[1]) << 24) + (((uint32_t)data[2]) << 16) + (((uint32_t)data[3]) << 8) + data[4];\n\n        s->tick_offset = ti - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_TIME:\n\n        ti = s->tick_offset + (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        obuf[3] = ti >> 24;\n\n        obuf[4] = ti >> 16;\n\n        obuf[5] = ti >> 8;\n\n        obuf[6] = ti;\n\n        cuda_send_packet_to_host(s, obuf, 7);\n\n        break;\n\n    case CUDA_FILE_SERVER_FLAG:\n\n    case CUDA_SET_DEVICE_LIST:\n\n    case CUDA_SET_AUTO_RATE:\n\n    case CUDA_SET_POWER_MESSAGES:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_POWERDOWN:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_shutdown_request();\n\n        break;\n\n    case CUDA_RESET_SYSTEM:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_reset_request();\n\n        break;\n\n    case CUDA_COMBINED_FORMAT_IIC:\n\n\n        obuf[1] = 0x5;\n\n\n\n\n        break;\n\n    case CUDA_GET_SET_IIC:\n\n        if (len == 4) {\n\n            cuda_send_packet_to_host(s, obuf, 3);\n\n        } else {\n\n\n\n\n\n\n        }\n\n        break;\n\n    default:\n\n\n\n\n\n\n        break;\n\n    }\n\n}", "idx": 18559, "substitutes": {"s": ["services", "hs", "ds", "sam", "cs", "os", "l", "z", "t", "p", "sb", "sp", "ses", "st", "store", "sq", "as", "h", "set", "qs", "is", "bs", "conf", "g", "south", "sv", "rs", "gs", "S", "ss", "so", "d", "sw", "ns", "v", "sts", "vs", "ps", "sports", "sn", "js", "sys", "service", "c", "es", "r", "comm", "sync", "n", "fs", "less", "space", "er", "ts", "ssl", "ls", "stats", "us", "spec", "b", "y", "its", "m"], "data": ["size", "bits", "valid", "results", "hash", "shift", "aw", "vals", "pins", "windows", "ad", "mat", "DATA", "options", "join", "cache", "params", "buffer", "chain", "offset", "ops", "none", "t", "kat", "apps", "zero", "dat", "ata", "d", "v", "da", "keys", "n", "o", "entry", "bus", "a", "ds", "res", "box", "buf", "normal", "match", "partial", "session", "att", "def", "raw", "str", "info", "block", " DATA", "no", "text", "byte", "next", "pos", "blocks", "args", "window", "p", "final", "empty", "done", "values", "ns", "bytes", "Data", "value", "batch", "message", "table", "extra", "key", "share", "type"], "len": [" length", "pos", "l", "el", "z", "size", "t", " count", "sp", " n", "en", "num", "h", "count", " l", "length", "all", "ln", "bytes", "Length", "nl", "id", "n", "lan", "un", "Len", "type"], "obuf": ["obull", " ibull", "ouff", "webuf", "obsuffer", "webalf", "obuff", "ofg", " obather", "obsbuff", "webfg", "objbuf", "oyuff", "obalf", "robbuf", "obf", " ibuf", " obull", "obbbuf", "obsbuf", "obuffer", "obsert", "obather", "objuffer", "OBuff", "robbuff", " obbuff", "oinather", "objoster", " obfac", " obuff", " ibbuf", "obbfg", "robuf", " oboster", "robert", "obfac", " ibbuff", "objuf", "obbalf", " obfg", "objbuff", "robfac", "obsfac", " dbbuf", " obbuf", "obsuf", "obsoster", "OBuf", "obsuff", "obbuff", "oyuf", "oboster", "robuff", "objert", " obert", "obsf", "obsather", "objf", "oyfg", " dbuf", " obuffer", "oyalf", " dbull", "webuff", "OBbuff", "oinfac", "oinf", "obfg", "objuff", "oinuf", "OBbuf", "ouf", "obbuf", "obert", " obf", " dbbuff"], "autopoll": ["autoplool", "autoplull", "autoool", "autompull", "autopell", "acopll", "autool", "autoopell", "autropull", " autospll", "autmopoll", "acopool", "autopsell", " autopll", "autooll", "authopoll", "autosproc", " autorot", "autmoproc", "autippoll", "autompol", "autoploll", "autoorpell", " autipll", " autosppoll", " autompool", "autopsol", "autospoll", "autipoll", "autopull", "autopol", "authropoly", "autropoly", "autopsull", "autorpull", "autoplol", " autooll", "autoppoll", "autopsoll", "autipool", "autoopoll", "autospol", "autosppoll", "autorpell", "autompool", "autompell", "autospoly", " autipol", " autompoller", "autompoller", "authropoll", "autoorpol", " autool", "autoproc", "automprot", " autoproc", "autoroc", "autorpol", "autopoller", "autipoller", "autpll", "autospoller", "authropull", "autoll", "autipol", "autorot", "autopool", "autipll", "autpool", "autorpoll", "autmopool", "autropool", "autompoll", "autospull", "acoppoll", " autopoller", "authopoly", " autoool", "authopull", "authopool", " autoprot", "autospool", "autropoll", "autospll", "autopll", "acosppoll", "autoprot", "acospll", "acospoll", " autopol", "authropool", "autoploly", "autpoll", " autopool", "autoopull", "autoopol", "autoplrot", "acopoll", " autosproc", " autipoll", " autipool", " autoppoll", "autmopll", "autopoly", "autmoppoll", "autpol", " autospoll", " autompol", "autoorpoll", "autoorpull", " autompoll", "acospool"], "ti": ["yi", "tri", "si", "t", "ta", "ci", "i", "hi", "wit", "tie", "Ti", "ki", "isi", "qi", "aki", "ski", "tis", "mit", "li", "ati", "alli", "ri", "te", "tone", "ita", "ni", "ite", "tif", "ai", "iti", "wt", "phi", "ste", "VI", "tree", "di", "tip", "TA", "Tai", "MI", "uti", "mi", " li", "pi", "tw", "xi", "ui", " ki", " psi", "TI", "wei", "wi", "gi", "Xi", "fi", "ami", "fa", "bi", "tm", " di", "qt", " ni", "trace", "zi", "tt", "tile", "it", "tv", "tu", "hea", "ii", "iat"]}}
{"project": "qemu", "commit_id": "b6b75a99dab760c902c3d355519e0dc2616872e1", "target": 1, "func": "static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);", "idx": 18562, "substitutes": {"bm": ["rm", "sam", "mm", "wm", "bb", "mc", "bh", "bp", "bo", "irm", "bs", "mr", "umi", "mn", "em", "mt", "lb", "mu", "amm", "bl", "ay", "BM", "pm", "nb", "mi", "hm", "mx", "gb", "dm", "sbm", "cm", "bf", "bi", "tm", "bt", "bol", "gm", "b", "br", "bn", "m"]}}
{"project": "FFmpeg", "commit_id": "513a3494396d0a20233273b3cadcb5ee86485d5c", "target": 1, "func": "static int vp6_parse_coeff(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = s->ccp;\n\n    VP56Model *model = s->modelp;\n\n    uint8_t *permute = s->idct_scantable;\n\n    uint8_t *model1, *model2, *model3;\n\n    int coeff, sign, coeff_idx;\n\n    int b, i, cg, idx, ctx;\n\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    if (c->end >= c->buffer && c->bits >= 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"End of AC stream reached in vp6_parse_coeff\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (b=0; b<6; b++) {\n\n        int ct = 1;    /* code type */\n\n        int run = 1;\n\n\n\n        if (b > 3) pt = 1;\n\n\n\n        ctx = s->left_block[ff_vp56_b6to4[b]].not_null_dc\n\n              + s->above_blocks[s->above_block_idx[b]].not_null_dc;\n\n        model1 = model->coeff_dccv[pt];\n\n        model2 = model->coeff_dcct[pt][ctx];\n\n\n\n        coeff_idx = 0;\n\n        for (;;) {\n\n            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {\n\n                /* parse a coeff */\n\n                if (vp56_rac_get_prob_branchy(c, model2[2])) {\n\n                    if (vp56_rac_get_prob_branchy(c, model2[3])) {\n\n                        idx = vp56_rac_get_tree(c, ff_vp56_pc_tree, model1);\n\n                        coeff = ff_vp56_coeff_bias[idx+5];\n\n                        for (i=ff_vp56_coeff_bit_length[idx]; i>=0; i--)\n\n                            coeff += vp56_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;\n\n                    } else {\n\n                        if (vp56_rac_get_prob_branchy(c, model2[4]))\n\n                            coeff = 3 + vp56_rac_get_prob(c, model1[5]);\n\n                        else\n\n                            coeff = 2;\n\n                    }\n\n                    ct = 2;\n\n                } else {\n\n                    ct = 1;\n\n                    coeff = 1;\n\n                }\n\n                sign = vp56_rac_get(c);\n\n                coeff = (coeff ^ -sign) + sign;\n\n                if (coeff_idx)\n\n                    coeff *= s->dequant_ac;\n\n                idx = model->coeff_index_to_pos[coeff_idx];\n\n                s->block_coeff[b][permute[idx]] = coeff;\n\n                run = 1;\n\n            } else {\n\n                /* parse a run */\n\n                ct = 0;\n\n                if (coeff_idx > 0) {\n\n                    if (!vp56_rac_get_prob_branchy(c, model2[1]))\n\n                        break;\n\n\n\n                    model3 = model->coeff_runv[coeff_idx >= 6];\n\n                    run = vp56_rac_get_tree(c, vp6_pcr_tree, model3);\n\n                    if (!run)\n\n                        for (run=9, i=0; i<6; i++)\n\n                            run += vp56_rac_get_prob(c, model3[i+8]) << i;\n\n                }\n\n            }\n\n            coeff_idx += run;\n\n            if (coeff_idx >= 64)\n\n                break;\n\n            cg = vp6_coeff_groups[coeff_idx];\n\n            model1 = model2 = model->coeff_ract[pt][ct][cg];\n\n        }\n\n\n\n        s->left_block[ff_vp56_b6to4[b]].not_null_dc =\n\n        s->above_blocks[s->above_block_idx[b]].not_null_dc = !!s->block_coeff[b][0];\n\n    }\n\n    return 0;\n\n}\n", "idx": 18578, "substitutes": {"s": ["a", "services", "hs", "ds", "cs", "times", "os", "t", "args", "settings", "p", "sb", "as", "ses", "ins", "sq", "aws", "h", "qs", "is", "bs", "e", "ares", "sv", "rs", "gs", "sa", "S", "ss", "sw", "ns", "sts", "v", "se", "self", "ps", "sets", "sports", "js", "sys", "es", "erences", "ats", "r", "n", "fs", "source", "ts", "ims", "ls", "stats", "spec", "sc", "its", "m"], "c": ["a", "con", "cv", "cs", "ic", "this", "tc", "ca", "t", "p", "mc", "ec", "cn", "h", "enc", "unc", "gc", "cl", "g", "cur", "cf", "vc", "cc", "bc", "ct", "ch", "co", "conv", "v", "etc", "cd", "cont", "container", "uc", "cr", "r", "cmp", "lc", "cm", "dc", "C", "n", "fc", "ce", "cu", "cache", "cb", "anc", "nc", "xc", "cp", "f", "rc", "ac", "com", "cus", "chain", "conf", "m"], "model": ["bm", "mem", "form", "el", "server", "Model", "p", "mm", "cell", "controller", "sm", "feature", "le", "device", "zero", "mod", "config", "map", "link", "tree", "command", "library", "m", "address", "v", "variable", "vm", "ve", "param", "re", "dev", "condition", "table", "lc", "transform", "models", "bank", "module", "vector", "network", "sim", "go", "ver", "f", "policy", "dem", "spec", "mode", "man"], "permute": ["mututable", "mute", "modulate", "modute", "modutable", "modutation", "mutulate", "mutation", "mututation", "mulate", "mutable", "mutute", "permutable", "permulate", "permutation"], "model1": ["Model1", "templateb", " model0", "model0", "link3", "Model0", " modelb", "link1", "server1", "model4", "table1", "cell3", " model4", "table0", "link2", "template0", "server4", "Model3", "template1", "cell0", "server0", "template4", "cell1", "table3", "link0", "serverb", "modelb", "Model2"], "model2": ["module2", "dem12", "Model1", "modeltwo", " modelTwo", "moduleb", "server15", "model52", "team6", "example02", "server22", "image12", "model12", "templateb", "server02", "teamtwo", "model6", "project3", " model02", "dem2", "model22", "image2", "imageTwo", "project2", " modelb", "model15", "feature22", "layer2", "example2", "template52", "feature2", "team3", "layer1", "module52", " model6", "layer3", "layer02", "server2", " modeltwo", "feature02", "modelTwo", "projecttwo", "example22", "demTwo", "feature15", "model02", " model12", "dem3", "Model3", "Model02", " model52", "modelb", "image3", "example15", "project6", "template2", "Model2", "team2"], "model3": [" model6", "gem6", "gem1", "module1", "gem3", "model03", "module3", "module03", "module6", "model6", "gem03", " model03"], "coeff": ["coefficient", "coffee", " coefficient", "COffee", " coef", " coff", "Coef", "noff", "COefficient", "Coff", "conefficient", "noefficient", "coneff", " coffee", "COff", "Coefficient", "noeff", "coef", "COeff", "noef", "COef", "coff", "Coeff", "conef", "conffee"], "sign": ["cap", "pos", "round", "ca", "big", "sb", "sp", "scale", "sum", "mod", "sa", "shape", "ai", "cc", "name", "ch", "ind", "ign", "cmp", "act", "gn", "go", "comp", "sc", "br", "err", "ig"], "coeff_idx": ["coeff_ridn", "coeff_Idindex", "coeff_ideindex", "coeff_ridy", "coeff_indix", "coeff_ridindex", "coeff_Idy", "coeff_indx", "coeff_idex", "coeff_Idex", "coeff_idix", "coeff_idz", "coeff_idey", "coeff_midx", "coeff_ideix", "coeff_idindex", "coeff_Idw", "coeff_ridz", "coeff_idw", "coeff_ridix", "coeff_midix", "coeff_midn", "coeff_idew", "coeff_Idix", "coeff_midz", "coeff_ridex", "coeff_idn", "coeff_ridx", "coeff_idy", "coeff_ideex", "coeff_Idx", "coeff_indw"], "b": ["a", "l", "z", "t", "back", "ach", "p", "sb", "bb", "bh", "h", "bp", "ub", "bo", "base", "fb", "bs", "e", "ob", "g", "bg", "byte", "bc", "bd", "ch", "mb", "db", "d", "v", "pb", "bl", "B", "ab", "nb", "gb", "j", "bu", "r", "batch", "bound", "bf", "rb", "bi", "ib", "x", "cb", "bt", "be", "by", "ba", "bin", "go", "f", "eb", "bis", "y", "br", "m"], "i": ["ic", "index", "ij", "si", "l", "size", "t", "ci", "hi", "p", "ki", "qi", "h", "li", "is", "\u0438", "ri", "g", "ni", "I", "u", "ai", "phi", "length", "d", "v", "cli", "di", "io", "ip", "mi", "pi", "oi", "id", "j", "xi", "ti", "ui", "gi", "o", "n", "multi", "bi", "ib", "x", "zi", "ini", "f", "it", "ix", "iu", "y", "ii", "m"], "cg": ["fcg", "fcgp", "lcgp", "cge", "lcgs", "cgs", " cgs", "lcge", "fcgs", "lcg", " cge", "fcge", "cgp", " cgp"], "idx": ["indix", "mainx", "ridX", "ridx", "indx", "idxes", "Idx", "idX", " idon", " idX", " idy", "edy", "IDon", "idy", "odon", " idindex", "mainxes", "odxs", "ridex", "mainy", "ridix", "tryindex", "IDx", " idex", "Idex", " idxes", "IDix", "odix", "IDy", "idxs", "Idix", "tryix", "idindex", "indxs", "edx", "odx", "ody", "tryy", "idix", "indindex", " idxs", "edix", "idon", " idix", "idex", "indy", "tryx", "edxes", "mainix", "IdX"], "ctx": ["td", "pos", "index", "loc", "np", "tc", "nt", "ca", "tz", "tx", "sp", "timeout", "kt", "unc", "pc", "rt", "gc", "cas", "point", "cf", "ht", "tmp", "jac", "tp", "ct", "cc", "bc", "kw", "co", "ptr", "conn", "cmd", "pt", "pkg", "height", "jp", "context", "cmp", "dc", "act", "pat", "gp", "cu", "Context", "cb", "txt", "qt", "pa", "nd", "cp", "ac", "iat"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_passive_mode_epsv(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    static const char d = '|';\n\n    static const char *command = \"EPSV\\r\\n\";\n\n    static const int epsv_codes[] = {229, 0};\n\n\n\n    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '(') {\n\n            start = res + i + 1;\n\n        } else if (res[i] == ')') {\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n    if (!start || !end)\n\n        goto fail;\n\n\n\n    *end = '\\0';\n\n    if (strlen(start) < 5)\n\n        goto fail;\n\n    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n\n        goto fail;\n\n    start += 3;\n\n    end[-1] = '\\0';\n\n\n\n    s->server_data_port = atoi(start);\n\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    s->server_data_port = -1;\n\n    return AVERROR(ENOSYS);\n\n}\n", "idx": 18583, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "z", "scl", "t", "w", "sg", "p", "sb", "as", "ses", "st", "store", "sq", "als", "aws", "h", "ctx", "set", "qs", "is", "esm", "bs", "g", "south", "sv", "rs", "gs", "S", "ss", "sw", "ns", "sts", "v", "self", "se", "ps", "sys", "sn", "js", "c", "j", "es", "ats", "r", "n", "o", "fs", "less", "acs", "ts", "ssl", "ls", "an", "f", "stats", "spec", "sc", "b", "conf", "m"], "res": ["bits", "tx", "details", "results", "ress", "rt", "ri", "vals", "resource", "rs", "req", "RES", "mem", "os", "result", "ret", "cons", "resolution", "response", "ps", "reset", "msg", "re", "range", "x", "resp", "rest", "trans", "err", "fresh", "init", "cs", "resources", "rx", "expr", "prefix", "des", "ch", "reg", "progress", "addr", "j", "gr", "def", "str", "raw", "got", "prime", "rc", "ix", "arr", "p", "ins", "pres", "reason", "out", "rep", "Res", "rem", "success", "conn", "rev", "cmd", "data", "rel", "r", "val", "ires", "pas", "ms", "ris", "ser", "red"], "start": ["pad", "st", "shift", "point", "lat", "step", "stop", "star", "iter", "get", "first", "req", "art", "path", "space", "pre", "be", "wind", "need", "offset", "check", "index", "use", "t", "ish", "sp", "set", "starting", "seek", "d", "add", "reset", "range", "arts", "skip", "try", "root", "date", "len", "from", "entry", "rest", "it", "part", "begin", "middle", "trans", "init", "prev", "Start", "name", "time", "j", "ST", "str", "state", "row", "no", "ie", "next", "pos", "p", "before", "last", "started", "ind", "id", "r", "top", "key"], "end": ["next", "offset", "until", "ue", "eng", "and", "termin", "max", "close", "final", "st", "en", "ort", "ender", "port", "win", "last", "then", "e", "append", "point", "fail", "rend", "length", "send", "out", "stop", "off", "fin", "v", "ad", "all", "add", "ending", "eval", "range", "reset", "id", "east", "ext", "val", "hend", "est", "ell", "bound", "eff", "End", "alt", "ent", "pend", "END", "be", "tail", "len", "ended", "nd", "wind", "rest", "it", "except", "begin", "dest"], "i": ["ic", "index", "ij", "z", "si", "b", "l", "t", "ci", "im", "p", "ei", "hi", "slice", "list", "qi", "me", "q", "li", "is", "ri", "g", "I", "u", "ai", "phi", "ori", "v", "di", "io", "k", "dr", "iter", "ip", "mi", "pi", "json", "ind", " j", "iri", "j", "xi", "ti", "ui", "iat", "gi", "o", "ji", "multi", "fi", "uri", "bi", "x", "info", "zi", "ini", "sim", "it", "ix", "iu", "y", "ii", "m"], "command": ["frame", "word", "form", "sword", "comment", "definition", "menu", "query", "Command", "text", "program", "power", "action", "prefix", "password", "reason", "send", "method", "force", "execute", "response", "call", "description", "cmd", "argument", "template", "message", "sequence", "request", "attribute", "function", "pattern", "phrase", "code", "direction", "status", " Command", "mode", "process"], "epsv_codes": ["epsv_code", "epv_code", "epsv2lines", "epsv_cod", "epv2lines", "epsv2code", "epv2cod", "epv_lines", "epv_cod", "epv2code", "epsv2cod", "epv2codes", "epsv2codes", "epv_codes", "epsv_lines"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qemu_enqueue_packet(VLANClientState *sender,\n\n                                const uint8_t *buf, int size,\n\n                                NetPacketSent *sent_cb)\n\n{\n\n    VLANPacket *packet;\n\n\n\n    packet = qemu_malloc(sizeof(VLANPacket) + size);\n\n    packet->sender = sender;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);\n\n}\n", "idx": 18596, "substitutes": {"sender": ["insend", "dsender", "sending", "Sender", " sorter", "Snd", "bend", " send", "dsend", "criber", "cink", "Sorter", "send", "Sendor", " sriber", "snd", "dsorter", " sink", "bendor", "sorter", "insnd", "borter", " sendor", "bender", "csend", "csorter", "insorter", "sriber", " sending", "Sending", "cender", "csender", "sink", "sendor", "Send", "insriber", "insink", "csnd", "dsending", "cend", "insender"], "buf": ["mem", "cap", "cv", "Buff", "img", "bar", "bp", "ctx", "fb", "bag", "ob", "vec", "cur", "map", "tmp", " buffer", "queue", "bc", "db", "bytes", "pb", "doc", "wb", "data", "msg", "pkg", "func", "raw", "bound", "bf", "rb", "orig", "txt", "cb", "block", "bin", "uf", "buffer", "Buffer", "buff", "b", "br"], "size": ["needed", "offset", "pos", "index", "zone", "format", "sent", "total", "max", "sp", "num", "timeout", "set", "scale", "sum", "count", "g", "empty", "shape", "length", "amount", "password", "send", "name", "address", "capacity", "start", "limit", "area", "fee", "sn", "time", "data", "ize", "storage", "body", "scope", "height", "message", "cmp", "number", "space", "package", "Size", "state", "SIZE", "x", "notice", "since", "len", "city", "small", "type"], "sent_cb": ["sentswcallback", "send_callback", "sentswqueue", "sent___fn", " sent_callback", "sent____callback", "send_rb", "send__fee", "sent__fee", "sent___callback", "send__fn", "send_fee", "send_queue", "sent__fn", "sent___cb", "sent_cf", "sentswrb", "sent____cb", "sent__dt", "sentpfn", "send_fn", "sent__cb", "sentpfee", "sent_queue", "send_cb", "sentpcb", "send_dt", "sent_fn", "sent____fn", "sent____cf", "sent_callback", " sent_cf", "send__dt", "sent___cf", " sent_fn", "send__cb", "sentswcb", "sent_dt", "sent_fee", "sent_rb", "sentpdt"], "packet": ["tagpet", "packageets", "packeter", "packedet", "makepet", "packkt", " packata", "ppacket", "packpet", "pakant", "ppeter", "octpet", "codacket", "payeter", "tagset", " packacket", "Packet", "lookacket", "packageest", "lookset", "tagacket", "placket", "looket", "packata", "creatant", "packedest", "plet", "codect", "codet", "packect", "presentet", "packedacket", "packagekt", "packset", "packacket", "plest", "creatacket", "octeter", "paypet", "paket", "presentpet", "octkt", "makeet", "makeacket", "packets", "creatpet", "packedets", "lookpet", "packest", "octant", "packageet", "presentacket", "pppet", "buckacket", "pakpet", "ppant", "packant", "payacket", "payet", "Packacket", "Packect", "payant", "octet", "plets", "taget", "bucket", "packageacket", " packect", "buckpet", "makeset", "tageter", "ppet", "presentant", "createt", "bucketer", "pakacket", "ppkt", "packageeter", "octacket", "Packata", "codata"]}}
{"project": "qemu", "commit_id": "7d6b1daedd00b35e50ce87ea835f662b36a23160", "target": 0, "func": "static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)\n\n{\n\n    /* TO FIX */\n\n    return 0;\n\n}\n", "idx": 18597, "substitutes": {"env": ["w", "proc", "en", "end", "e", "buf", "config", " e", "sv", " st", "db", "Ev", "uv", "v", "vs", "obj", "param", "scope", "dev", " environment", "ev", "context", "txt", "cb", "code", "pe", "stack", "environment"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n", "idx": 18598, "substitutes": {"length": ["offset", "ength", "lp", "history", "duration", "loc", "l", "size", "phy", "total", "pad", "p", "pp", "sp", "term", "lib", "th", "h", "family", "count", "ENGTH", "load", "padding", "command", "other", "position", "address", "name", "ptr", "kind", "head", "Length", "time", "range", "data", "height", "message", "path", "block", "len", "buffer", "url", "full", "Len", "bus", "type"], "proto": [" prob", "portto", "protpro", "Prob", " proTo", "Proto", "portpro", "Propro", "propro", "protTo", "protto", "ProTo", "prob", "protb", "proTo", "portTo"], "addrs": [" addr", "atts", "adds", " adds", "addls", " addls", "attresses", "adr", "adls", "attls", "Addresses", "addr", "adresses", "Adds", " addresses", "addresses", "adrs", "ads", "Addr", "attrs", "Addrs"], "buf": ["mem", "cap", "xff", "cv", "Buff", "np", "box", "arr", "window", "p", "port", "vec", "cur", "queue", "alloc", "bytes", "pb", "ptr", "addr", "data", "msg", "pkg", "batch", "raw", "pack", "rb", "cb", "block", "bin", "uf", "cp", "buffer", "Buffer", "buff", "b", "seq", "br"]}}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "void cpu_loop_exit(CPUState *env1)\n\n{\n\n    env1->current_tb = NULL;\n\n    longjmp(env1->jmp_env, 1);\n\n}\n", "idx": 18614, "substitutes": {"env1": [" env8", "engine2", "v1", "engine1", "env0", "dooronce", " env0", "envOne", "environment2", "environment8", "door001", " env2", "en1", " env001", "engine0", " envOne", "v0", "env8", "engineOne", "v2", "env2", "en2", "v8", "enonce", "en001", "envonce", "vOne", "door1", "environment0", " envonce", "door2", "env001", "environment1"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void ppc_hw_interrupt (CPUPPCState *env)\n\n{\n\n    int raised = 0;\n\n\n\n#if 1\n\n    if (loglevel & CPU_LOG_INT) {\n\n        fprintf(logfile, \"%s: %p pending %08x req %08x me %d ee %d\\n\",\n\n                __func__, env, env->pending_interrupts,\n\n                env->interrupt_request, msr_me, msr_ee);\n\n    }\n\n#endif\n\n    /* Raise it */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n\n        /* External reset / critical input */\n\n        /* XXX: critical input should be handled another way.\n\n         *      This code is not correct !\n\n         */\n\n        env->exception_index = EXCP_RESET;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n\n        raised = 1;\n\n    }\n\n    if (raised == 0 && msr_me != 0) {\n\n        /* Machine check exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n\n            env->exception_index = EXCP_MACHINE_CHECK;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n\n            raised = 1;\n\n        }\n\n    }\n\n    if (raised == 0 && msr_ee != 0) {\n\n#if defined(TARGET_PPC64H) /* PowerPC 64 with hypervisor mode support */\n\n        /* Hypervisor decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {\n\n            env->exception_index = EXCP_HDECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);\n\n            raised = 1;\n\n        } else\n\n#endif\n\n        /* Decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n\n            env->exception_index = EXCP_DECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n\n            raised = 1;\n\n        /* Programmable interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n\n            env->exception_index = EXCP_40x_PIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            raised = 1;\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->exception_index = EXCP_40x_FIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            raised = 1;\n\n        /* Watchdog timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->exception_index = EXCP_40x_WATCHDOG;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            raised = 1;\n\n        /* External interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            env->exception_index = EXCP_EXTERNAL;\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            raised = 1;\n\n#if 0 // TODO\n\n        /* Thermal interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->exception_index = EXCP_970_THRM;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            raised = 1;\n\n#endif\n\n        }\n\n#if 0 // TODO\n\n    /* External debug exception */\n\n    } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->exception_index = EXCP_xxx;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        raised = 1;\n\n#endif\n\n    }\n\n    if (raised != 0) {\n\n        env->error_code = 0;\n\n        do_interrupt(env);\n\n    }\n\n}\n", "idx": 18619, "substitutes": {"env": ["dt", "door", "ctx", "e", "conf", "eas", "vs", "obj", "gear", "self", "era", "ee", "manager", "req", "inv", "context", "cause", "er", "cache", "shell", "net", "ah", "buffer", "exec", "Environment", "environment", "cv", "here", "el", "server", "die", "t", "desc", "en", "end", "nv", "cur", "em", "v", "etc", "start", "ew", "doc", "response", "msg", "up", "dev", "entry", "org", "event", "worker", "err", "init", "ov", "w", "ter", "proc", "query", "enc", "ner", "buf", "subject", "queue", "loader", "agent", "uv", "addr", "operator", " environment", "ev", "erd", "rb", "viron", "state", "txt", "info", "policy", "nav", "answer", "dn", "next", "ten", "eng", "window", "stage", "vt", "ec", "ener", "equ", "config", "timer", "engine", "db", "ve", "conn", "cmd", "ext", "ref", "message", "dh", "cb", "vv", "this", "eh"]}}
{"project": "qemu", "commit_id": "23979dc5411befabe9049e37075b2b6320debc4e", "target": 0, "func": "gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,\n\n                               int search_pc)\n\n{\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    struct DisasContext ctx;\n\n    struct DisasContext *dc = &ctx;\n\n    uint32_t next_page_start, org_flags;\n\n    target_ulong npc;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    qemu_log_try_set_file(stderr);\n\n\n\n    pc_start = tb->pc;\n\n    dc->env = env;\n\n    dc->tb = tb;\n\n    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;\n\n\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->jmp = 0;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->cpustate_changed = 0;\n\n    dc->abort_at_next_insn = 0;\n\n    dc->nr_nops = 0;\n\n\n\n    if (pc_start & 3)\n\n        cpu_abort(env, \"Microblaze: unaligned PC=%x\\n\", pc_start);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n#if !SIM_COMPAT\n\n        qemu_log(\"--------------\\n\");\n\n        log_cpu_state(env, 0);\n\n#endif\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    do\n\n    {\n\n#if SIM_COMPAT\n\n        if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);\n\n            gen_helper_debug();\n\n        }\n\n#endif\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n                        gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        dc->clear_imm = 1;\n\n\tdecode(dc);\n\n        if (dc->clear_imm)\n\n            dc->tb_flags &= ~IMM_FLAG;\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                if (dc->tb_flags & DRTI_FLAG)\n\n                    do_rti(dc);\n\n                 if (dc->tb_flags & DRTB_FLAG)\n\n                    do_rtb(dc);\n\n                if (dc->tb_flags & DRTE_FLAG)\n\n                    do_rte(dc);\n\n                /* Clear the delay slot flag.  */\n\n                dc->tb_flags &= ~D_FLAG;\n\n                /* If it is a direct jump, try direct chaining.  */\n\n                if (dc->jmp != JMP_DIRECT) {\n\n                    eval_cond_jmp(dc, env_btarget, tcg_const_tl(dc->pc));\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (env->singlestep_enabled)\n\n            break;\n\n    } while (!dc->is_jmp && !dc->cpustate_changed\n\n         && gen_opc_ptr < gen_opc_end\n\n                 && !singlestep\n\n         && (dc->pc < next_page_start)\n\n                 && num_insns < max_insns);\n\n\n\n    npc = dc->pc;\n\n    if (dc->jmp == JMP_DIRECT) {\n\n        if (dc->tb_flags & D_FLAG) {\n\n            dc->is_jmp = DISAS_UPDATE;\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n            sync_jmpstate(dc);\n\n        } else\n\n            npc = dc->jmp_pc;\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Force an update if the per-tb cpu state has changed.  */\n\n    if (dc->is_jmp == DISAS_NEXT\n\n        && (dc->cpustate_changed || org_flags != dc->tb_flags)) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    }\n\n    t_sync_flags(dc);\n\n\n\n    if (unlikely(env->singlestep_enabled)) {\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n        if (dc->is_jmp == DISAS_NEXT)\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n            case DISAS_NEXT:\n\n                gen_goto_tb(dc, 1, npc);\n\n                break;\n\n            default:\n\n            case DISAS_JUMP:\n\n            case DISAS_UPDATE:\n\n                /* indicate that the hash table must be used\n\n                   to find the next TB */\n\n                tcg_gen_exit_tb(0);\n\n                break;\n\n            case DISAS_TB_JUMP:\n\n                /* nothing more to generate */\n\n                break;\n\n        }\n\n    }\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n                tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n#if !SIM_COMPAT\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n#if DISAS_GNU\n\n        log_target_disas(pc_start, dc->pc - pc_start, 0);\n\n#endif\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, gen_opc_ptr - gen_opc_buf);\n\n    }\n\n#endif\n\n#endif\n\n    assert(!dc->abort_at_next_insn);\n\n}\n", "idx": 18620, "substitutes": {"gen_opc_end": ["gen_opc__END", "gen_opc__ends", "gen_opc_start", "gen_opC__ends", "gen_opc__end", "gen_opc_ends", "gen_opc__start", "gen_opC_END", "gen_opC_end", "gen_opC__END", "gen_opf_start", "gen_opc_END", "gen_opC__end", "gen_opC_ends", "gen_opf_end", "gen_opc_buf", "gen_opC__start", "gen_opf_buf", "gen_opf_ends", "gen_opC_start"], "pc_start": ["PC_part", "pc7end", "pc__begin", "pc_source", "pc_next", "pc_init", "pcityend", "tc_start", "proc_size", "PC_step", "pc_begin", "PC_begin", "pc_part", "pc__start", "pc__init", "pc7offset", "pc_send", "proc_begin", "PC_start", "pc___start", "pc2part", "PC_offset", "tc_send", "tc_source", "pc_step", "pc___source", "pc2end", "proc_start", "PC_int", "pc_size", "pc2int", "pcitybegin", "proc_init", "PC_next", "pc2start", "pc_end", "pc_int", "pcitystart", "pc_offset", "pc7step", "pc7start", "pcitynext", "pc___send", "PC_end", "proc_end", "pc__end"], "j": ["next", "ij", "jj", "z", "l", "i", "ort", "kj", "shift", "count", "uj", " ii", "J", "step", "jit", "ch", "v", "k", "js", "jp", "job", "n", "ji", "jump", "it", "jc", " jump"], "lj": [" ljs", "lig", "slj", "mJ", "lij", "sljs", " ln", "nJ", " lg", "liJ", "lJ", "njs", "ng", "mn", "ljs", "ln", "mj", "sln", "slJ", "lijs", "lg", " lJ", "mjs", "nj"], "ctx": ["cv", "loc", " cx", "tc", "np", "ca", "nt", " cc", "tx", "xy", "kt", "pc", " context", "cf", " sc", "tmp", "jac", "ct", "cc", "bc", "kw", " waiter", "co", " tc", "obj", "cmd", "pkg", "c", " cp", "parent", "context", "lc", "cm", "fc", "cu", "txt", "cb", "nc", " err", "xc", "abc", "cp", "ctr"], "dc": ["mac", "currency", "tx", "dt", "direct", "controller", "nz", "kw", "di", "cd", "obj", "cat", "driver", "c", "admin", "cm", "tm", "city", "exec", "dd", "dp", "ci", "oc", "desc", "mc", "dl", "dat", "_", "d", "da", "doc", "fee", "cr", "condition", "ctrl", "fc", "drm", "design", "ctl", "ds", "cs", "tc", "ca", "ga", "wp", "disc", "comment", "cca", "cc", "bc", "document", "css", "cfg", "draw", "cmp", "def", "txt", "rc", "cp", "central", "ec", "remote", "pc", "gc", "rec", "dr", "cont", "cmd", "func", "lc", "df", "dim", "coord", "nc", "api", "DC", "ac"], "next_page_start": ["next_page2end", "next_page2length", "next_page_size", "next_page_length", "next_page_begin", "next_pagexoffset", "next_page_offset", "next_pages_size", "next_pages_offset", "next_page2offset", "next_pagexend", "next_pagexstart", "next_pages_end", "next_pagexlength", "next_page2start", "next_pages_length", "next_pages_start", "next_page_end", "next_pages_begin"], "org_flags": ["org__mask", "org__flag", "org_mask", "org_Flags", "pg_Flags", "pg_flags", " org_flag", "pg_flag", " org_mask", "org__Flags", "org__flags", "org_flag", " org_Flags"], "npc": ["nnpc", "nrlp", "numcc", "nrc", "nrpc", "nncc", "nlp", "nrcc", "ncc", "numpc", "nnrc", "numrc", "nrrc", "nnlp", "numlp"], "num_insns": ["num_insn", "num_csns", "num_insne", "num_inne", "num_asns", "num_vsms", "num_insvs", "num_risn", "num_insms", "num_asvs", "num_inms", "num_csms", "num_vsns", "num_invs", "num_inns", "num_csn", "num_vsons", "num_risne", "num_vsn", "num_insons", "num_asne", "num_risvs", "num_inons", "num_asn", "num_csons", "num_inn", "num_risns"], "max_insns": ["max_cinons", "max_presxs", "max_ainsns", "max_insms", "max_insxs", "max_insains", "max_presn", "max_csns", "max_insons", "max_inn", "max_itsains", "max_inuns", "max_inons", "max_incms", "max_inms", "max_kinsn", "max_itsn", "max_presuns", "max_csms", "max_itsns", "max_cinn", "max_insuns", "max_kinspires", "max_presns", "max_insn", "max_incn", "max_cinuns", "max_ainsn", "max_inspires", "max_kinsains", "max_csxs", "max_ainsuns", "max_ainsxs", "max_csn", "max_ainsons", "max_incns", "max_inxs", "max_cinns", "max_itspires", "max_inns", "max_inains", "max_kinsns", "max_inpires", "max_incxs"], "delayed_branch": ["delayed_frranch", "delayed_franches", "delayed_blranch", "delayed_frag", "delayed_tranch", "delayed_franch", "delayed_trranch", "delayed_brag", "delayed_blanches", "delayed_tranches", "delayed_branches", "delayed_brranch", "delayed_blag", "delayed_trag", "delayed_blanch"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n\n{\n\n    long i;\n\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n\n        long a = *(long *)(src1 + i);\n\n        long b = *(long *)(src2 + i);\n\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n\n    }\n\n    for (; i < w; i++)\n\n        dst[i] = src1[i] + src2[i];\n\n}\n", "idx": 18624, "substitutes": {"dst": ["ddest", "dbr", "Dbr", "gst", " dnd", " dct", " dest", "dlest", "dsmt", "gmt", "dlst", "gstr", "dbl", "lbl", " dbl", "lst", "dsest", "lbr", "Dst", "dlnd", "dsst", "dsstr", "gest", "dstr", "bmt", "Dnd", " ddest", "bst", "Dbl", "dlct", "Dest", "dmt", "dct", " dbr", "Ddest", "Dct", "dnd", "best", "ldest", "dest", "bstr"], "src1": ["rc0", "source3", "selOne", " srcOne", "rc1", "src0", " src7", "source0", "source1", "rc2", "rc3", "sel7", "rcOne", "source2", "sel2", " src3", "src3", "srcOne", " src0", "rc7", "src7", "sel1"], "src2": ["rc0", "source7", "srcb", "source3", "rc02", "rcb", "rc1", "src0", " src7", "source0", "src02", "source1", "rc2", "rc3", "sourceb", "source2", " src3", "ser0", "src3", "source02", "rc7", "ser2", " src02", "serb", "src7", "ser1"], "w": ["word", "l", "z", "wp", "window", "weight", "p", "rw", "h", "we", "win", "iw", "wt", "nw", "kw", "d", "sw", "wr", "v", "ew", "wa", "wb", "k", "wx", "hw", "c", "r", "wh", "W", "n", "wi", "x", " W", "wcs", "y", "m"], "i": ["vi", "hi", "ski", "li", "span", "ri", "g", "I", "ai", "di", "iter", "mi", "jp", "ji", "asi", "gu", "chain", "multi", "ii", "yi", "tim", "index", "ij", "ci", "\u0438", "phi", "v", "cli", "pi", "try", "wi", "gi", "o", "fi", "bi", "x", "zi", " err", "ini", "f", "it", "iu", "a", "init", "ic", "l", "ei", "qi", " ti", "me", "ik", " ii", "ip", " li", " j", "iri", "j", "ti", "um", "uli", " I", "ami", "uri", "go", " bi", "ix", "b", "y", "m", "si", "im", "p", "ki", "at", "h", "remote", " pi", "is", " wi", "ind", "id", "in", "xi", "ui", "batch", "iy", "ims", " ni", "sim"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 18629, "substitutes": {"bs": ["bm", "hs", "ds", "cs", "lbs", "os", "fps", "boxes", "outs", "bits", "bles", "sb", "BS", "ses", "blog", "hz", "ubs", "bh", "oss", "bp", "banks", "bo", "bas", "bps", "rs", "gs", "bc", "aus", "ubis", "ns", "bytes", "vs", "bos", "ps", "bl", "bes", "js", "irms", "obs", "cks", "fs", "ts", "aos", "ls", "ims", "ris", "b", "bis", "its"], "res": ["mer", "resy", "ren", "cs", "rez", "os", "pr", "details", "changes", "report", "result", "results", "ry", "rect", "ress", "cons", "expr", "ber", "pres", "vals", "vec", "resource", "ri", "rs", "resolution", "rec", "pro", "reg", "Res", "resh", "ps", "response", "rem", "vre", "js", "reset", "rev", "re", "req", "css", "es", "rel", "pers", "r", "gr", "def", "cond", "RES", "pas", "sol", "aux", "ro", "resp", "rc", "rest", "stats", "ms", " Res", "der", "conf", "red", "err"], "fix": ["init", "check", " cond", " rem", "patch", "repair", " repair", " fixes", " doc", " commit", " Fix", " prefix", " diff", "fixes", "set", " FIX", " msg", "dirty", "prefix", " patch", "fail", "force", " mut", "add", "clean", "call", "FIX", " add", "update", " fixing", "new", "def", " edit", "Fix", " call", " apply", "fx", " change", "f", " pack", "ix", "conf", "err"], "rebuild": ["rbuild", "creconstruct", "rbuilt", "rebuilder", "reconstruct", " rebuilt", "reuse", "reuild", "ryuild", "rybuild", " reuse", "reebuilder", "rconstruct", "relbuild", "rebuilt", "reeconstruct", "crebuild", "reluild", "relbuilt", "crebuilt", "reebuilt", "reluse", "crebuilder", "ryuse", "reebuild", "rybuilt", " reuild", "rbuilder"], "refcount_table": ["refcount_array", "refcountingdb", "refcountabletotal", "refCount_array", "refcountablearray", "refcount_stable", "refcountingtmp", "refcount64task", "refsize_option", "refcountpleoption", "refcountingtable", "refcountpleserver", "refcount_trace", "refcount64table", "refstring64user", "refcountpletype", "refbalancepletmp", "refsize_server", "refcountptoption", "refcount_user", "refstatingdb", "refcountablelist", "refstring64type", "refbalance_trace", "refcountpletask", "refsizepleoption", "refcount64user", "refstring64table", "refcountingtotal", "refbalancepletable", "refcountptstable", "refcountpletable", "refstat_db", "refCount_Table", "refcount_db", "refcount_list", "refCount_tab", "refcountredtable", "refcount1total", "refstring64task", "refstring_table", "refcountpleuser", "refount_list", "refount_table", "refcountredtrace", "refcount_server", "refcountsTable", "refsizepletable", "refCount_TABLE", "refcount_Table", "refsize_stable", "refstatingtable", "refcount_tab", "refcount_task", "refsizepleserver", "refcount1table", "refcountredtmp", "refcountplestable", "refcount_type", "refbalance_table", "refcountsTABLE", "refCount_list", "refstring_task", "refstat_trace", "refcounttlist", "refCount_table", "refcountptserver", "refstring_user", "refcount_option", "refount_total", "refstat_table", "refcountpletmp", "refcount_TABLE", "refcountttotal", "refcountpletrace", "refstatingtotal", "refcount_tmp", "refcountingtrace", "refcount1db", "refcountabletable", "refstat_total", "refcount1trace", "refstatingtrace", "refcountableTABLE", "refbalance_tmp", "refbalancepletrace", "refcountabledb", "refcount64type", "refcountttable", "refcountstable", "refcount_total", "refcountabletrace", "refcountstab", "refsizeplestable", "refcountpttable", "refstring_type", "refsize_table"], "nb_clusters": ["nb_gluster", "nb_oclicators", "nb_clocations", "nb_combanches", "nb_oclanches", "nb_oclayers", "nb_cloci", "nb_occuers", "nb_loconents", "nb_CLusters", "nb_ciders", "nb_clroups", "nb_Clroups", "nb_clayers", "nb_ocluster", "nb_klusters", "nb_clusiffs", "nb_clicators", "nb_aclicals", "nb_glusters", "nb_CLiders", "nb_aclocations", "nb_chusters", "nb_clicas", "nb_occiffs", "nb_aclusters", "nblyclusitors", "nblycliffs", "nb_kluster", "nb_locaves", "nb_ucanches", "nb_cluster", "nb_colluster", "nb_ucamps", "nb_clusoci", "nblyclususters", "nb_CLuster", "nb_custers", "nb_Clanches", "nb_occusters", "nb_chanches", "nb_collows", "nb_clanches", "nb_combuster", "nb_collaves", "nb_declanches", "nb_oclamps", "nb_highonents", "nb_declannels", "nb_locusters", "nb_locows", "nb_highows", "nb_blicals", "nb_commannels", "nb_combocations", "nb_helitors", "nb_combusters", "nb_collusters", "nb_clusitors", "nb_cliffs", "nblyclusiffs", "nb_glayers", "nb_collonents", "nb_ucusters", "nb_clamps", "nb_spliders", "nb_klayers", "nb_custer", "nb_clususters", "nb_croups", "nb_commusters", "nb_clows", "nb_blusters", "nb_occitors", "nb_glicas", "nb_cluers", "nb_clusannels", "nb_decloci", "nb_collocations", "nb_splocations", "nb_CLroups", "nb_splicals", "nb_ucicators", "nb_clannels", "nb_clitors", "nblyclusuers", "nb_oclicas", "nb_clicals", "nb_chicators", "nb_commoci", "nb_blocations", "nb_bliders", "nb_commanches", "nb_clusanches", "nblyclitors", "nblyclusters", "nb_champs", "nb_highaves", "nb_heliffs", "nb_Clocations", "nb_cliders", "nb_claves", "nb_clonents", "nb_clusuers", "nblycluers", "nb_helusters", "nb_declusters", "nb_acliders", "nb_Clusters", "nb_Cliders", "nb_klicas", "nb_splusters", "nb_oclusters", "nb_Cluster", "nb_collanches", "nb_heluers", "nb_highusters"], "s": ["hs", "ds", "cs", "sam", "states", "os", "l", "ys", "bits", "sb", "p", "details", "as", "ins", "als", "sq", "ses", "aws", "h", "changes", "results", "qs", "is", "sym", "g", "sv", "rs", "gs", "serv", "S", "ss", "ns", "sts", "v", "vs", "obj", "ps", "sys", "js", "xs", "es", "ats", "comm", "eps", "fs", "less", "y", "state", "ts", "ssl", "ls", "ims", "stats", "ms", "spec", "sl", "b", "bis", "conf", "its", "m"], "i": ["init", "ic", "index", "ij", "l", "si", "t", "ci", "im", "hi", "p", "ei", "ki", "qi", " ti", "me", "li", "is", "ri", "e", "I", " ii", "u", "ai", "phi", "v", "di", "cli", "iter", "ip", "mi", "pi", "ind", " j", "j", "xi", "ti", "ui", "gi", "n", "uli", "multi", "fi", "bi", "iu", "x", " si", " di", "zi", "ini", "sim", " bi", "gu", "it", "ia", "ix", "us", "b", "y", "ii", "m"], "sn": ["sc", "snap", "sam", "Sn", "cs", "fn", "si", "scl", "sk", "sh", "sb", "sp", "kn", "dn", "sq", "cn", "sf", "sm", "span", "syn", "pres", "sv", "sa", "tn", "mn", "ss", "sw", "ns", "ln", "news", "nn", "sys", "sd", "nl", "nex", "sbm", "SN", "n", "wn", "sol", "ny", "gn", "txt", "ls", "sr", "nm", "rn", "pn", "nr", "inn", "sl", "bn"], "ret": ["format", "back", "dt", "report", "test", "rt", "vals", "arg", "fer", "mat", "alg", "obj", "get", "cat", "eval", "plain", "jp", "nil", "del", "cert", "net", "not", "url", "rets", " RET", "result", "ry", "vet", "compl", "irm", "ber", "virt", "detail", "reset", "RET", "re", "try", "usr", "len", "resp", "it", "fun", "elt", "status", "err", "rm", "nt", "pret", "ter", "term", "rect", "expr", "prop", "tr", "mt", "reg", "lt", "ft", " Ret", "det", "att", "def", "print", "alt", "txt", "gt", "deg", "git", "final", "ject", "ll", "last", "out", "rep", "web", "Return", "cont", "value", "rem", "rev", "cmd", "ext", "lit", "ref", "r", "val", "repl", "over", "red", "Ret"], "check_errors": ["read_failed", "checkerrfailed", "read_stats", "checkporesults", "checkerrerrors", "read_results", "check_failed", "checkpoerrors", "checkpostats", "check_results", "checkpofailed", "checkerrresults", "check_stats", "checkerrstats", "read_errors"]}}
{"project": "qemu", "commit_id": "40545f84cfcbe4b73cca040b3043a1c2de935762", "target": 1, "func": "static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    NE2000State *s = opaque;\n\n    int offset, page;\n\n\n\n    addr &= 0xf;\n\n#ifdef DEBUG_NE2000\n\n    printf(\"NE2000: write addr=0x%x val=0x%02x\\n\", addr, val);\n\n#endif\n\n    if (addr == E8390_CMD) {\n\n        /* control register */\n\n        s->cmd = val;\n\n        if (val & E8390_START) {\n\n            s->isr &= ~ENISR_RESET;\n\n            /* test specific case: zero length transfert */\n\n            if ((val & (E8390_RREAD | E8390_RWRITE)) &&\n\n                s->rcnt == 0) {\n\n                s->isr |= ENISR_RDC;\n\n                ne2000_update_irq(s);\n\n            }\n\n            if (val & E8390_TRANS) {\n\n                qemu_send_packet(s->nd, s->mem + (s->tpsr << 8), s->tcnt);\n\n                /* signal end of transfert */\n\n                s->tsr = ENTSR_PTX;\n\n                s->isr |= ENISR_TX;\n\n                ne2000_update_irq(s);\n\n            }\n\n        }\n\n    } else {\n\n        page = s->cmd >> 6;\n\n        offset = addr | (page << 4);\n\n        switch(offset) {\n\n        case EN0_STARTPG:\n\n            s->start = val << 8;\n\n            break;\n\n        case EN0_STOPPG:\n\n            s->stop = val << 8;\n\n            break;\n\n        case EN0_BOUNDARY:\n\n            s->boundary = val;\n\n            break;\n\n        case EN0_IMR:\n\n            s->imr = val;\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN0_TPSR:\n\n            s->tpsr = val;\n\n            break;\n\n        case EN0_TCNTLO:\n\n            s->tcnt = (s->tcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_TCNTHI:\n\n            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RSARLO:\n\n            s->rsar = (s->rsar & 0xff00) | val;\n\n            break;\n\n        case EN0_RSARHI:\n\n            s->rsar = (s->rsar & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RCNTLO:\n\n            s->rcnt = (s->rcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_RCNTHI:\n\n            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_DCFG:\n\n            s->dcfg = val;\n\n            break;\n\n        case EN0_ISR:\n\n            s->isr &= ~(val & 0x7f);\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN1_PHYS ... EN1_PHYS + 5:\n\n            s->phys[offset - EN1_PHYS] = val;\n\n            break;\n\n        case EN1_CURPAG:\n\n            s->curpag = val;\n\n            break;\n\n        case EN1_MULT ... EN1_MULT + 7:\n\n            s->mult[offset - EN1_MULT] = val;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 18640, "substitutes": {"opaque": ["opane", "iopacity", "OPsole", "pane", " opque", " Opatile", " opatile", "opsole", "iopque", "OPane", "opatile", "pque", "iopane", "iopaque", " opsole", " opane", " opacity", " Opaque", " Opane", "opacity", "opque", "paque", "pacity", "OPatile", " Opsole", "OPaque"], "addr": ["eth", "mem", "pos", "index", "loc", "arr", "ord", "pad", "tx", "amp", "var", "sp", "md", "aff", "at", "hash", "ctx", "set", "adr", "buf", "ace", "point", "map", "prefix", "link", "mt", "alloc", " address", "ad", "address", "db", "off", "v", "start", "inter", "ptr", "attr", "dr", "add", "clock", "order", "req", "cmd", "pkg", "id", "rev", "ref", "tag", "seek", "host", "align", "alt", "alias", "coord", "env", "ack", "name", "x", "Address", "phys", "url", "ix", "gate", "err"], "val": ["lv", "ival", "valid", "tx", "slot", "test", "hash", "ctx", "vals", "arg", "point", "crit", "Value", "obj", "bl", "eval", "req", "bit", "orig", "cho", "bin", "buffer", "url", "serv", "exec", "mem", "index", "Val", "el", "item", "sel", "var", "always", "ret", "find", " value", "fail", "v", "call", "msg", "pt", "dev", "x", "len", "resp", "al", "it", "volt", "elt", "status", "ul", "res", "style", "comment", "hz", "buf", "pol", "mod", "stat", "reg", "pal", "cal", "cmp", "def", "str", "print", "alt", "txt", "block", "bool", "byte", "p", "vt", "xy", "VAL", "bo", "util", "empty", "aval", "values", "value", "data", "ref", "tag", "extra", "vol", "conf"], "s": ["bits", "details", "ess", "results", "rs", "tags", "vs", "se", "obj", "sys", "c", "es", "comm", "sync", "fs", "sol", "params", "spec", "sis", "sl", "serv", "ows", "os", "ops", "t", "settings", "flags", "sm", "set", "qs", "S", "ss", "d", "sts", "ps", "service", "xs", "ts", "x", "ls", "parts", "ads", "stats", "bis", "status", "comments", "services", "ies", "ds", "cs", "sam", "l", "terms", "sb", "as", "ses", "changes", "als", "sv", "grades", "stat", "des", "sw", "session", "js", "j", "ssl", "mods", "an", "states", "b", "y", "m", "hs", "ys", "i", "p", "ins", "store", "sq", "aws", "h", "is", "bs", "gs", "ns", "tes", "pers", "ats", "r", "less", "actions", "ms", "search", "items", "conf", "its"], "offset": ["next", "pos", "index", "Offset", "error", "location", "style", "tz", "size", "window", "slice", "pad", "slot", "sp", "timeout", "set", "shift", "end", "option", "count", "point", "oint", "op", "prefix", "command", "onet", "ot", "seek", "address", "off", "out", "position", "start", "pointer", "mask", "area", "tab", "order", "range", "update", "line", "et", "oid", "o", "bound", "key", "alias", "row", "type", "part", "trace", "oe"], "page": ["next", "pos", "frame", "index", "window", "total", "pad", "pp", "p", "slot", "result", "port", "base", "Page", "age", "count", "point", "cycle", "node", "step", "position", "seek", "pg", "address", "limit", "pointer", "ptr", "ip", "mark", "tab", "order", "range", "cmd", "ref", "line", "message", "number", "block", "row", "net", "buffer", "code", "phase", "hop", "loop"]}}
{"project": "FFmpeg", "commit_id": "0a359cf157957f3eb37760f731fa75dd320fd659", "target": 0, "func": "static int vc1_filter_line(uint8_t* src, int stride, int pq){\n\n    int a0, a1, a2, a3, d, clip, filt3 = 0;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;\n\n    if(FFABS(a0) < pq){\n\n        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;\n\n        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3;\n\n        a3 = FFMIN(FFABS(a1), FFABS(a2));\n\n        if(a3 < FFABS(a0)){\n\n            d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8;\n\n            clip = (src[-1*stride] - src[ 0*stride])/2;\n\n            if(clip){\n\n                filt3 = 1;\n\n                if(clip > 0)\n\n                    d = av_clip(d, 0, clip);\n\n                else\n\n                    d = av_clip(d, clip, 0);\n\n                src[-1*stride] = cm[src[-1*stride] - d];\n\n                src[ 0*stride] = cm[src[ 0*stride] + d];\n\n            }\n\n        }\n\n    }\n\n    return filt3;\n\n}\n", "idx": 18646, "substitutes": {"src": ["loc", "ser", "ur", "img", "ck", "lib", "st", "rt", "rs", "tp", "conv", "iter", "ipl", "obj", "iv", "sys", "req", "sync", "aux", "sr", "bin", "url", "spec", "sl", "hl", "np", "sort", "bb", "input", "stream", "bh", "syn", "cur", "vc", "sec", "stab", "sn", "via", "pkg", "usr", "it", "ctr", "sc", "scene", "sb", "proc", "impl", "usc", "load", "stat", "sw", "http", "cmp", "str", "raw", "act", "rb", "source", "txt", "ssl", "rc", "scan", "ins", "secure", "sq", "config", "supp", "cont", "inst", "r", "sur", "stock", "dest", "seq", "rl"], "stride": ["strice", "Strider", "striope", "slension", "privide", "provice", " strider", "STRuse", "scopeine", "stension", "STRide", "provide", "STRiden", "divice", "slision", "stade", "STRope", "specide", "struster", "gripe", "privride", "STRipe", "scopeuit", "instiden", "divine", "stickider", "instipe", "striden", "arrride", "statususter", "formider", "grine", "drice", "slipe", "specade", "specpace", "gride", "volope", "struit", "formope", "grride", "stringride", "stringipe", "formride", "dride", " strine", "stripe", "stilege", "privension", " stripe", "statusope", "struse", "intice", "fride", "slide", " strice", "strilege", " strade", "formide", "voluster", "intine", "strider", "instide", "instride", "stice", "brride", "slride", "arride", "scopeide", "frride", "slice", "stider", "stickide", "bripe", " strride", "divride", "intpace", "frider", "specice", "STRine", "stision", "volider", "drision", "STRuit", "STRension", "specider", "intipe", "provider", "privipe", "statusider", "slilege", "striide", "divipe", "provension", "divide", "brice", "divider", "striuster", "strension", "STRice", "volice", "stringiden", "arrider", "STRider", "intide", "strride", "arrice", "striider", "slpace", "scopeuse", " struse", "strade", "STRade", "frade", "slider", " struit", "strine", "strision", "Strride", "provride", "bride", "strope", "STRride", "intride", "stope", "drine", "Strade", "stringide", "intider", "drension", "drilege", "specride", "stickride", "drider", "specipe", "volride", "volide", "stine", "stickope", "drride", "Stride", "statuside", "provipe", "strpace", "stide", "sline"], "pq": [" pqu", "cpqt", " pQ", "pqi", "vpue", "vpqu", " pqt", "tpqi", "tpq", "Pq", "pue", "pqt", "tpqu", "cpq", "vpq", " pue", "vpqi", "Pue", "cpQ", "tpue", "pQ", " pqi", "PQ", "Pqt", "cpue", "pqu"], "a0": ["aa1", "ga1", " a7", "aa7", "aa00", "e3", "aa8", "ao0", "ao03", "a7", "a00", "ga7", "ga000", "a8", "aa2", "A8", "e1", "A7", "ba2", "ga03", "e2", "ba000", "aa4", "ao1", " a4", "a03", "A0", "sha00", "ao3", " a8", "e0", "aa0", "ga2", "a000", "A1", "A4", "A2", "ba0", "ba7", "sha0", "ga0", "aa000", "ga3", "ga00", "a4", "e03"], "a1": ["a001", "aa1", " a7", "aa7", "element0", "as01", "a81", "a7", "aa11", "as1", "a01", "a11", "aa2", "aa001", "element81", "A11", " a11", "as7", "A01", "aa01", " a001", "A0", "element2", "as001", "A1", "A2", "A81", " a81", "element1", " a01"], "a2": ["A02", "ga4", "au2", "pa82", "aTwo", "aoTwo", "a8", "a02", "pa5", "A8", "ATwo", " a4", "ao2", "A0", "ga02", " a8", "a5", " a02", "au02", "auTwo", "ga2", " a82", " a5", "pa4", "A2", "ga82", "pa2", "a82", "ga0", "ga8", "ga5", "a4", "ao02"], "a3": ["a6", "au3", "aa1", "aa883", " a03", "u6", "e3", "u1", "ao0", "aa5", "aa003", "ao53", "A3", "a883", "ao03", "au0", "u53", "ga23", "au15", " a15", "e1", "aa23", "ao883", "e2", "A53", " a003", "ao1", " a4", "a003", " a23", "a53", "a03", " a53", "ao3", "a23", " a6", "e4", "a5", " a5", "A1", " a883", "au53", "A4", "ao15", "A2", "a15", "aa03", "ga003", "A6", "ga3", "aa3", "ga5", "a4", "u3"], "d": ["a", "debug", "ds", "fd", "z", "l", "ord", "dist", "t", "de", "pad", "p", "dt", "result", "q", "h", "delay", "g", "mod", "dat", "dl", "done", "length", "bd", "ad", "db", "di", "da", "dr", "add", "sd", "data", "c", "dig", "ind", "dir", "id", "dev", "r", "std", "dom", "draw", "dc", "D", "diff", "n", "dim", "del", "dh", "gd", "nd", "dx", "f", "dra", "ed", "b", "dd", "m"], "clip": ["grow", "offset", "cap", "near", "snap", "keep", "check", "strip", "pop", "z", "clone", "l", "slice", "pad", "close", "sup", "max", "crop", "sp", "client", "sound", "zero", "scale", "ape", "cl", "lock", "op", "copy", "zip", "tif", "cut", " Clip", "split", "seek", "clips", "grab", "pro", "scroll", "deep", "limit", "stop", "progress", "peak", "supp", "tip", "ip", "ps", "mask", "mp", "drop", "skip", "id", " clipped", "cmp", "high", "dc", "just", "diff", "low", "lip", "lim", "pl", "cp", "filter", "tile", "comp", "pe", "sc", "b", "loop"], "cm": ["bm", "cv", "tc", "ca", "px", "ci", "mm", "crop", "wm", "asm", "irm", "cl", "fr", "cam", "mr", "mn", "cut", "ch", "mb", "co", "vm", "cont", "stab", "pm", "mp", "c", "dm", "CM", "um", "tk", "lc", "dc", "fc", "fm", "ram", "tm", "cb", "fine", "nm", "cms", "com", "cp", "gm", "sc", "conf", "m"]}}
{"project": "FFmpeg", "commit_id": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb", "target": 0, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n                      int src_count, int src_size, int dest_len)\n\n{\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            return 0;\n\n        *pd++ = bytestream2_get_byteu(&gb);\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            break;\n\n        l = bytestream2_get_byteu(&gb);\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)\n\n                return bytestream2_tell(&gb);\n\n            bytestream2_get_bufferu(&gb, pd, l);\n\n            pd += l;\n\n        } else {\n\n            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)\n\n                return bytestream2_tell(&gb);\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n            }\n\n            bytestream2_skip(&gb, 2);\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return bytestream2_tell(&gb);\n\n}\n", "idx": 18648, "substitutes": {"src": ["loc", "sel", "img", "sh", "sb", "sup", "sub", "ins", "st", "input", "sq", "buf", "rs", "tmp", "bg", "name", "attr", "cont", "ptr", "iv", "addr", "sn", "sys", "ind", "inst", "str", "usr", "source", "txt", "sr", "bin", "from", "rc", "rest", "scan", "sur", "ctr", "sc"], "dest": ["temp", "init", "loc", "size", "dist", "max", "desc", "sp", "st", "result", "test", "port", "decl", "end", "rw", "sum", "gc", "sv", "tmp", "out", "v", "start", "ptr", "cont", "attr", "self", "priv", "target", "to", "id", "lit", "master", "dev", "through", "origin", "est", "dc", "usr", "orig", "source", "Dest", "txt", "bin", "cp", "rest", "home", "gt", "gen", "way", "trans", "gate"], "src_count": ["source_length", " src_coll", "src_sum", "rc_size", "src00count", "source_count", " src_length", "rc_length", "src2count", "srcitylength", "src_length", "srcitycount", "src00only", "rc_sum", "src_only", "src2size", " src_Count", "src00length", "src00size", "src2coll", "rc_count", "src_coll", "srcitycoll", "source_size", "src_Count", "source_only", "srcitysize", "src2length"], "src_size": ["src_len", " src_len", " src_length", "src_length", "src_scale", "dest_size", "dest_scale", "dest_count"], "dest_len": ["dest___size", "Dest_len", "source_length", "dest___length", "Dest_end", "dest___end", "source_num", "Dest_length", "source_len", "dest_length", "dest_size", "dest___len", "dest_num", "source_size", "Dest_size"], "pd": ["td", "lp", "ds", "PD", "fd", "dp", "por", "np", "wp", "px", "ci", "pr", "p", "pp", "dt", "md", "edd", "pid", "li", "pc", "hd", "pard", "dl", "tmp", "vp", "ht", "phi", "py", "pdf", "tp", "bd", "d", "db", "ln", "cli", "cd", "pod", "pb", "ptr", "ps", "wd", "pm", "sd", "pi", "pt", "ind", "xd", "ud", "isd", "pat", "pread", "ssl", "pl", "ped", "ld", "pn", "php", "cp", "ed", "pe", "po", "dd"], "i": ["a", "lp", "ic", "index", "ij", "si", "ci", "im", "hi", "p", "ish", "ei", "ki", "qi", "me", "li", "is", "\u0438", "ri", "e", "I", " ii", "dl", "u", "ai", "phi", "d", "v", "io", "di", "cli", "ip", "mi", "pi", "c", "ind", "id", "in", "j", "xi", "ti", "ui", "gi", "o", "n", "multi", "lo", "bi", "iu", "x", "iy", "pl", "ims", "zi", "ini", "status", "s", "it", "ix", "b", "y", "ii", "m"], "l": ["lp", "lv", "ul", "loc", "ly", "b", "el", "z", "t", "hl", "isl", "p", "lf", "dL", "list", "ll", "ml", "h", "li", "le", "lu", "g", "dl", "il", "u", "length", "m", "d", "ln", "v", "limit", "lt", "rl", "c", "nl", "lit", "j", "L", "kl", "lc", "n", " L", "o", "lo", "la", "ls", "lang", "pl", "ld", "len", "al", "s", "f", "lis", "ol", "sl", "tl", "lin", "lb", "fl"], "dest_end": ["destvalended", "resultvaledge", "destzlast", "dest_last", "dest__ended", "dest_start", "destvaledge", "result_end", "target_stop", "src_start", "dest_stop", "dest2loc", "result_max", "destvalend", "dest_begin", "dest2start", "dest_loc", "target_size", "resultvalmax", "dest__edge", "destzstart", "result_ended", "dest_size", "resultvalended", "dest__end", "result_edge", "destzloc", "src_end", "destzend", "dest_max", "target_begin", "resultvalend", "dest2end", "dest2last", "target_end", "destvalmax", "dest__max", "dest_ended", "dest_edge", "src_last", "src_loc"], "gb": ["lp", "cv", "ds", "sky", " GB", "bridge", "sg", " pg", "git", "csv", "sb", "lib", "bb", "img", "gif", "bp", "gz", "gram", "gc", "ruby", "g", "Gb", " db", "sv", "tmp", "kb", "gs", "py", "bg", "bd", "GB", "mb", "db", "gov", "pg", "gom", "ubis", "pb", "wb", "vm", "sys", " rg", "nb", "hub", " rgb", "storage", "json", "gg", "cfg", "gpu", "bf", "rg", "rb", "gp", "gd", "cb", "ssl", "gn", "tg", "gu", "gin", "uf", "gm", "eg", "gt", "vd"]}}
{"project": "FFmpeg", "commit_id": "1dff9adcb934175fe1beb14ee139ad0636daa29d", "target": 0, "func": "static int recheck_discard_flags(AVFormatContext *s, int first)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i, changed = 0;\n\n\n\n    /* Check if any new streams are needed */\n\n    for (i = 0; i < c->n_playlists; i++)\n\n        c->playlists[i]->cur_needed = 0;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n\n        if (st->discard < AVDISCARD_ALL)\n\n            pls->cur_needed = 1;\n\n    }\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->cur_needed && !pls->needed) {\n\n            pls->needed = 1;\n\n            changed = 1;\n\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n            pls->pb.eof_reached = 0;\n\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n\n                /* catch up */\n\n                pls->seek_timestamp = c->cur_timestamp;\n\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n\n                pls->seek_stream_index = -1;\n\n            }\n\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n\n        } else if (first && !pls->cur_needed && pls->needed) {\n\n            if (pls->input)\n\n                ff_format_io_close(pls->parent, &pls->input);\n\n            pls->needed = 0;\n\n            changed = 1;\n\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n\n        }\n\n    }\n\n    return changed;\n\n}\n", "idx": 18649, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "simple", "sg", "t", "csv", "p", "as", "sb", "ses", "ins", "changes", "sq", "aws", "h", "ks", "ar", "qs", "is", "bs", "ares", "g", "south", "sv", "rs", "gs", "S", "ss", "ns", "sts", "self", "ps", "sys", "js", "cmd", "es", "ats", "r", "sync", "n", "o", "fs", "less", "acs", "ts", "ims", "ls", "parts", "f", "stats", "ms", "sc", "b", "conf", "its", "eds"], "first": ["next", "prev", "use", "format", "before", "isc", "only", "must", "required", "last", " FIRST", "fast", "count", "fr", "empty", "initial", "second", "primary", "First", "force", "all", "accept", "start", "self", "each", "success", "commit", "same", "forced", "master", "new", "current", "present", "cond", "FIR", "now", "third", "top", "irst", "actual", "f", "full", "bool"], "c": ["con", "cv", "cs", "this", "tc", "l", "ca", "t", "ci", "p", "mc", "ec", "cn", "enc", "ctx", "ar", "gc", "g", "cur", "cf", "u", "vc", "comments", "cc", "bc", "ct", "conv", "co", "v", "etc", "cd", "cont", "cr", "r", "comm", "lc", "cm", "dc", "n", "C", "coll", "fc", "ce", "cu", "cache", "cb", "nc", "xc", "rc", "f", "ac", "cp", "abc", "com", "comp", "sc", "b", "wcs", "conf", "m"], "i": ["hi", "ski", "li", "ri", "g", "point", "I", "ai", "di", "iter", "get", "mi", "ji", "gu", "chain", "multi", "ii", "index", "ij", "t", "ci", "list", "\u0438", "phi", "v", "cli", "my", "pi", "json", "try", "gi", "n", "fi", "bi", "x", "zi", " err", "ini", "it", "iu", "init", "ic", "l", "ei", "qi", "me", " ii", "iq", "ip", " li", "any", "to", " j", "iri", "j", "ti", "print", " I", "ami", "uri", "info", "go", "ie", "ix", "y", "m", "si", "im", "p", "client", "ki", "at", "remote", "h", "is", "u", "oi", "ind", "id", "in", "xi", "batch", "ui", "ims", "sim", "iat"], "st": ["sc", "sam", "stable", "t", "ist", "sh", "sp", "stage", "store", "th", "sm", "set", "tr", "ss", "ste", "mt", "ct", "step", "sw", "sty", "St", "sts", "start", "se", "ft", "ast", "sn", "sth", "storage", "cr", "inst", "std", "et", "ust", "ST", "str", "sta", "est", "be", "irst", "tt", "rest", "sl", "ost"], "pls": ["pll", "palis", "plugges", " plgs", "patxs", "plyves", "pts", "splm", "plis", " plm", "cls", " pljs", " pll", "plongs", "palts", "flds", "PLts", "Pls", "plss", "paljs", "spljs", "patgs", "PLds", "splis", "clds", "plls", "sples", "repls", "splxs", "splongs", "ppts", "clsys", "palges", "flss", "plits", "ples", "patges", "splds", "cljs", "plysys", "plns", "ppjs", "palgs", "patds", "clves", "plts", "plyjs", " plts", "PLis", "plugis", "replds", "Pljs", "complgs", "compls", "prs", "plys", "patts", " ples", "patongs", "fls", "flts", "pals", "pljs", "plds", " plss", "patss", "lls", "prgs", "splsys", "Plts", "plugs", "spll", "spls", " plls", "ppl", " plis", "compljs", "splgs", "palds", " plits", "palongs", "ptm", "llits", "llgs", "plxs", "splts", "plgs", " plns", "ptts", "pps", "PLgs", "replxs", "plsys", "PLs", "plges", "pats", "patis", "plm", "splls", "plugongs", "plves", "ptes", "palns", "Plgs", "prls", "patits", "splves", "ptgs", " plds", "clgs", "clls", "prds", "ptls", "splns"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_transfer(int tpm_fd,\n\n                                         const TPMLocality *locty_data)\n\n{\n\n    return tpm_passthrough_unix_tx_bufs(tpm_fd,\n\n                                        locty_data->w_buffer.buffer,\n\n                                        locty_data->w_offset,\n\n                                        locty_data->r_buffer.buffer,\n\n                                        locty_data->r_buffer.size);\n\n}\n", "idx": 18673, "substitutes": {"tpm_fd": ["tmm_stream", "tpm_fp", "tpm_fin", "tpm__id", "tpm__fp", "tpm__stream", "tpm__pid", "tmm_fd", "tpm_stream", "tpm__fd", "tmm_fp", "tmm_pid", "tpm_id", "tmm_fin", "tpm__fin", "tpm_pid", "tmm_id"], "locty_data": ["locto_Data", "locty__dat", "locty_dat", "locto_results", "locty__rel", "locty_rel", "loctiy_data", "loctory_dat", "locty_Data", "loctiy_default", "loctory_buffer", "locty0extra", "loctyy_extra", "loctyy_vals", "locty_extra", "loctiy_Data", "locty_result", "locto_data", "locty0vals", "locty_vals", "locty_buffer", "locty_default", "loctyy_dat", "loctY_rel", "loctY_dat", "loctyy_data", "loctory_data", "locty0data", "locty__data", "loctiy_result", "loctory_extra", "loctY_data", "locty0dat", "locty_results"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_tw (int flags)\n\n{\n\n    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||\n\n                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||\n\n                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||\n\n                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||\n\n                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n    }\n\n}\n", "idx": 18675, "substitutes": {"flags": ["atts", "pants", "fps", "flag", "bits", "settings", " fps", "limits", "members", "terms", "ages", "posts", "lines", "frames", "oos", "xxx", "bugs", "forces", "planes", "vals", "allows", "grades", "pins", "files", "comments", "ports", "properties", "packages", "mask", " bits", "aps", "types", "func", "days", "lands", "options", "cond", "fs", "workers", "ags", "ints", "reports", "weights", "ts", "faces", "features", "FLAG", "locks", "links", "parts", "levels", "stats", "ms", " Flags", "lag", "ents", "issues", "Flags", "products"]}}
{"project": "qemu", "commit_id": "f85da3081d001909929a19e530e69cea0487f00e", "target": 1, "func": "void sh4_translate_init(void)\n\n{\n\n    int i;\n\n    static const char * const gregnames[24] = {\n\n        \"R0_BANK0\", \"R1_BANK0\", \"R2_BANK0\", \"R3_BANK0\",\n\n        \"R4_BANK0\", \"R5_BANK0\", \"R6_BANK0\", \"R7_BANK0\",\n\n        \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\n\n        \"R0_BANK1\", \"R1_BANK1\", \"R2_BANK1\", \"R3_BANK1\",\n\n        \"R4_BANK1\", \"R5_BANK1\", \"R6_BANK1\", \"R7_BANK1\"\n\n    };\n\n    static const char * const fregnames[32] = {\n\n         \"FPR0_BANK0\",  \"FPR1_BANK0\",  \"FPR2_BANK0\",  \"FPR3_BANK0\",\n\n         \"FPR4_BANK0\",  \"FPR5_BANK0\",  \"FPR6_BANK0\",  \"FPR7_BANK0\",\n\n         \"FPR8_BANK0\",  \"FPR9_BANK0\", \"FPR10_BANK0\", \"FPR11_BANK0\",\n\n        \"FPR12_BANK0\", \"FPR13_BANK0\", \"FPR14_BANK0\", \"FPR15_BANK0\",\n\n         \"FPR0_BANK1\",  \"FPR1_BANK1\",  \"FPR2_BANK1\",  \"FPR3_BANK1\",\n\n         \"FPR4_BANK1\",  \"FPR5_BANK1\",  \"FPR6_BANK1\",  \"FPR7_BANK1\",\n\n         \"FPR8_BANK1\",  \"FPR9_BANK1\", \"FPR10_BANK1\", \"FPR11_BANK1\",\n\n        \"FPR12_BANK1\", \"FPR13_BANK1\", \"FPR14_BANK1\", \"FPR15_BANK1\",\n\n    };\n\n\n\n    for (i = 0; i < 24; i++) {\n\n        cpu_gregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, gregs[i]),\n\n                                              gregnames[i]);\n\n    }\n\n    memcpy(cpu_gregs + 24, cpu_gregs + 8, 8 * sizeof(TCGv));\n\n\n\n    cpu_pc = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pc), \"PC\");\n\n    cpu_sr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, sr), \"SR\");\n\n    cpu_sr_m = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_m), \"SR_M\");\n\n    cpu_sr_q = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_q), \"SR_Q\");\n\n    cpu_sr_t = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_t), \"SR_T\");\n\n    cpu_ssr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, ssr), \"SSR\");\n\n    cpu_spc = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, spc), \"SPC\");\n\n    cpu_gbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, gbr), \"GBR\");\n\n    cpu_vbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, vbr), \"VBR\");\n\n    cpu_sgr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, sgr), \"SGR\");\n\n    cpu_dbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, dbr), \"DBR\");\n\n    cpu_mach = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, mach), \"MACH\");\n\n    cpu_macl = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, macl), \"MACL\");\n\n    cpu_pr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pr), \"PR\");\n\n    cpu_fpscr = tcg_global_mem_new_i32(cpu_env,\n\n                                       offsetof(CPUSH4State, fpscr), \"FPSCR\");\n\n    cpu_fpul = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, fpul), \"FPUL\");\n\n\n\n    cpu_flags = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t       offsetof(CPUSH4State, flags), \"_flags_\");\n\n    cpu_delayed_pc = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t\t    offsetof(CPUSH4State, delayed_pc),\n\n\t\t\t\t\t    \"_delayed_pc_\");\n\n    cpu_delayed_cond = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State,\n\n                                                       delayed_cond),\n\n                                              \"_delayed_cond_\");\n\n    cpu_ldst = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t      offsetof(CPUSH4State, ldst), \"_ldst_\");\n\n\n\n    for (i = 0; i < 32; i++)\n\n        cpu_fregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, fregs[i]),\n\n                                              fregnames[i]);\n\n}\n", "idx": 18696, "substitutes": {"i": ["index", " pos", "ij", "z", " t", "si", "t", "ci", " my", "p", " n", "qi", " ti", "me", "ki", "ski", "li", " pi", "\u0438", "ri", "I", " ii", " l", "ai", "phi", " multi", "iq", "v", " p", "di", "cli", " mi", "io", "ip", "mi", "pi", "ii", "ind", " j", "in", "j", "xi", "oi", "c", "ti", "batch", "ui", "gi", "ji", " I", "n", "multi", "o", "bi", "x", " x", "asi", " v", " m", "zi", " err", "sim", " bi", "ini", "gu", "status", "it", "ix", "ex", "iu", "y", " c", "m"], "gregnames": ["regNames", "regfiles", "regnames", "ggfiles", "ggnames", "regs", "gcnames", "gregNames", "gregcodes", "ggname", "gallnames", "regcodes", "gcNames", "gallname", "regname", "gcs", "ggs", "gregs", "gcfiles", "ggNames", "gallcodes", "gallNames", "gregname", "ggcodes", "gregfiles"], "fregnames": ["fgregtypes", "fregisterNames", "ggregcodes", "frecNames", "freccodes", "fregtypes", "fregcodes", "gregNames", "gregcodes", "fregisternames", "ggregtypes", "ggregnames", "fgregNames", "fregistercodes", "fgregnames", "frecnames", "ggregNames", "fregistertypes", "gregtypes", "fregNames", "frectypes", "fgregcodes"]}}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)\n\n{\n\n    AVCodec *codec;\n\n    AVCodecContext *c;\n\n    AVStream *st;\n\n\n\n    st = av_new_stream(oc, 1);\n\n    if (!st) {\n\n        fprintf(stderr, \"Could not alloc stream\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* find the MP2 encoder */\n\n    codec = avcodec_find_encoder(codec_id);\n\n    if (!codec) {\n\n        fprintf(stderr, \"codec not found\\n\");\n\n        exit(1);\n\n    }\n\n    c = &st->codec;\n\n    c->codec_type = CODEC_TYPE_AUDIO;\n\n\n\n    /* put sample parameters */\n\n    c->bit_rate = 64000;\n\n    c->sample_rate = 44100;\n\n    c->channels = 2;\n\n\n\n    /* open it */\n\n    if (avcodec_open(c, codec) < 0) {\n\n        fprintf(stderr, \"could not open codec\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* init signal generator */\n\n    t = 0;\n\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n\n\n\n    audio_outbuf_size = 10000;\n\n    audio_outbuf = malloc(audio_outbuf_size);\n\n\n\n    /* ugly hack for PCM codecs (will be removed ASAP with new PCM\n\n       support to compute the input frame size in samples */\n\n    if (c->frame_size <= 1) {\n\n        audio_input_frame_size = audio_outbuf_size / c->channels;\n\n        switch(st->codec.codec_id) {\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            audio_input_frame_size >>= 1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    } else {\n\n        audio_input_frame_size = c->frame_size;\n\n    }\n\n    samples = malloc(audio_input_frame_size * 2 * c->channels);\n\n\n\n    return st;\n\n}\n", "idx": 18700, "substitutes": {"oc": ["ic", "loc", "os", "ok", "ax", "ec", "og", "unc", "pc", "ob", "toc", "op", "vc", "ot", "WC", "bc", "cc", "co", "etc", "soc", "ive", "mic", "ocr", "oci", "oco", "voc", "osc", "o", "fc", "nc", "anc", "OC", "roc", "ocol", "vo", "rc", "ac", "irc", "ost", "wo"], "codec_id": ["codecNameident", "codecOinfo", "codec_class", "codec_oid", "codpeg_ident", "codoc_oid", "codpeg_type", "codecNameinfo", "codoc_type", "codpeg_no", "codoc_id", "codecOid", "codecOno", "codpeg_name", "codecNameno", "codoc_class", "codec_type", "codpeg_id", "codec_info", "codec_no", "codecOident", "codec_name", "codpeg_info", "codec_ident", "codecNameid"], "codec": ["codek", "condec", " codenc", "Codoc", "Cododer", "codepeg", "Codenc", "dcon", "desc", "codeesc", "octeca", " codEC", "Codet", "ctoc", "odef", "staenc", "codesc", "codica", "codecon", "codpeg", "odenc", "codoc", " coddec", "chek", "chet", "odoc", " codcon", "codEC", "ctoder", "dpeg", " cododer", " codoc", " codpeg", "Codec", "chec", "odet", "octica", "codet", "staica", "coddec", "ctef", "ctec", "odek", "condoc", " codef", "octenc", "ododer", " codesc", "codeec", "codef", "Coddec", "octec", "codenc", "codeca", "cododer", "odEC", "odeca", "staeca", "choc", "staec", "odec", "CodEC", "condoder", "codcon", "oddec", "odica", "condEC", "Codek"], "c": ["con", "cv", "cs", "ic", "loc", "form", "tc", "z", "ca", "can", "t", "l", "ci", "p", "lib", "mc", "ec", "enc", "ctx", "pc", "gc", "g", "config", "cf", "vc", "cc", "bc", "ct", "ch", "co", "content", "etc", "v", "conv", "cont", "comm", "cmp", "lc", "cm", "dc", "C", "o", "coll", "fc", "ce", "cod", "cu", "cache", "cb", "anc", "xc", "com", "cp", "rc", "ac", "icc", "abc", "comp", "chain", "f", "b", "conf", "col", "m"], "st": ["sc", "a", "stable", "l", "sl", "t", "w", "ist", "sh", "p", "sp", "stage", "store", "th", "stream", "h", "ctx", "set", "rt", "fr", "sv", "tmp", "ste", "mt", "ct", "so", "stop", "sw", "d", "St", "sts", "start", "v", "se", "ast", "sn", "step", "sth", "storage", "inst", "r", "std", "new", "ust", "ST", "est", "str", "sta", "art", "ts", "irst", "nd", "s", "rest", "tt", "f", "src", "it", "stan", "ost", "ut", "stack"]}}
{"project": "FFmpeg", "commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "target": 1, "func": "static av_cold int libopenjpeg_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibOpenJPEGContext *ctx = avctx->priv_data;\n\n    int err = AVERROR(ENOMEM);\n\n\n\n    opj_set_default_encoder_parameters(&ctx->enc_params);\n\n\n\n    ctx->enc_params.cp_rsiz = ctx->profile;\n\n    ctx->enc_params.mode = !!avctx->global_quality;\n\n    ctx->enc_params.cp_cinema = ctx->cinema_mode;\n\n    ctx->enc_params.prog_order = ctx->prog_order;\n\n    ctx->enc_params.numresolution = ctx->numresolution;\n\n    ctx->enc_params.cp_disto_alloc = ctx->disto_alloc;\n\n    ctx->enc_params.cp_fixed_alloc = ctx->fixed_alloc;\n\n    ctx->enc_params.cp_fixed_quality = ctx->fixed_quality;\n\n    ctx->enc_params.tcp_numlayers = ctx->numlayers;\n\n    ctx->enc_params.tcp_rates[0] = FFMAX(avctx->compression_level, 0) * 2;\n\n\n\n    if (ctx->cinema_mode > 0) {\n\n        cinema_parameters(&ctx->enc_params);\n\n    }\n\n\n\n    ctx->compress = opj_create_compress(ctx->format);\n\n    if (!ctx->compress) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the compressor\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    ctx->image = mj2_create_image(avctx, &ctx->enc_params);\n\n    if (!ctx->image) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the mj2 image\\n\");\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error allocating coded frame\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    memset(&ctx->event_mgr, 0, sizeof(opj_event_mgr_t));\n\n    ctx->event_mgr.info_handler    = info_callback;\n\n    ctx->event_mgr.error_handler = error_callback;\n\n    ctx->event_mgr.warning_handler = warning_callback;\n\n    opj_set_event_mgr((opj_common_ptr) ctx->compress, &ctx->event_mgr, avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opj_destroy_compress(ctx->compress);\n\n    ctx->compress = NULL;\n\n    opj_image_destroy(ctx->image);\n\n    ctx->image = NULL;\n\n    av_freep(&avctx->coded_frame);\n\n    return err;\n\n}\n", "idx": 18719, "substitutes": {"avctx": ["AVctx", "avctl", "avercb", " avcrit", " avcontext", "aveconn", "navkb", " avcmd", "wavctx", "avconn", "averdl", " avcb", " avctl", " avkl", "camcp", "afctx", "avercrit", "awctx", "avpkg", "afpkg", "wavcontext", "cvcontext", "avercfg", "avekl", "avcmd", "avetx", "navcontext", "avcrit", "avercmd", "avertx", "AVcontext", "avepkg", "averctl", "avdl", " avtx", "averkl", "avkw", "ajkw", "abconf", "camtx", "avcp", "avecb", "avcb", "averconn", "avercontext", "wavcmd", "aftx", "afkl", "averkw", "ajcb", " avcfg", "wavkl", "avkl", "avcontext", "avcfg", "avectl", " avkb", "avkb", "awcmp", "AVcmp", "cvcp", "avectx", "awtx", "avekw", "navcrit", "wavcb", "ajdl", " avcmp", "avedl", "cvctx", " avkw", "averconf", " avconf", "awcontext", "camctx", "avecfg", "averkb", "wavpkg", " avcp", "abtx", "avcmp", "wavcfg", "ajctx", " avconn", "avconf", "averctx", "wavtx", "abcontext", "AVtx", "cvtx", "avecmd", "navctx", "avtx", "abctx", "camcontext"], "ctx": ["loc", "px", "ck", "tx", "rt", "setup", "crit", "kw", "conv", "obj", "req", "c", "jp", "comm", "context", "tk", "cm", "tm", "pa", "xc", "abc", "yes", "exec", "check", "td", "cv", "index", "fn", "np", "desc", "timeout", "dl", "tmp", "command", "ct", "etc", "hw", "doc", "cpp", "msg", "pkg", "xs", "kl", "ctrl", "fc", "cu", "qt", "resp", "wcs", "ctl", "tc", "nt", "ca", "wp", "proc", "acl", "kt", "unc", "expr", "cl", "cf", "xp", "prefix", "jac", "ka", "cc", "co", "addr", "cfg", "cmp", "act", "txt", "cp", "qq", "col", "utils", "work", " cx", "gc", "config", "wx", "wd", "that", "conn", "cmd", "func", "inst", "val", "lc", "today", "ppo", "cb", "nc", "conf", "iat"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static inline unsigned int msi_nr_vectors(uint16_t flags)\n\n{\n\n    return 1U <<\n\n        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));\n\n}\n", "idx": 18724, "substitutes": {"flags": ["atts", "fields", "lbs", "acts", "fps", "args", "flag", "bits", "settings", "members", "details", "posts", "vals", "count", "aints", "gs", "files", "values", "tags", "properties", "mask", "aps", "ids", "options", "fs", "ags", "ints", "weights", "features", "FLAG", "qa", "levels", "parts", "orts", "names", " Flags", "heads", "states", "lag", "ents", "Flags", "comments"]}}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    OpenRISCCPU *cpu = NULL;\n\n    MemoryRegion *ram;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"or1200\";\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n        main_cpu_reset(cpu);\n\n    }\n\n\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"openrisc.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram);\n\n\n\n    cpu_openrisc_pic_init(cpu);\n\n    cpu_openrisc_clock_init(cpu);\n\n\n\n    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],\n\n                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n\n\n    if (nd_table[0].used) {\n\n        openrisc_sim_net_init(get_system_memory(), 0x92000000,\n\n                              0x92000400, cpu->env.irq[4], nd_table);\n\n    }\n\n\n\n    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);\n\n}\n", "idx": 18727, "substitutes": {"machine": ["iso", "check", "managed", "frame", "connection", "history", "zone", "process", "memory", "linux", "money", "mc", "me", "hard", "handler", "power", "device", "model", "link", "node", "command", "engine", "image", "green", "vm", "achine", "instance", "Machine", "monitor", "manager", "template", "local", "hello", "keeper", "space", "alias", "module", "state", "computer", "network", "shell", "sim", "smart", "chain", "series", "parse", "mode", "m"], "cpu_model": ["cpu_models", "cpumytype", "cpu2model", "cpuetymodel", "cpuetyowner", "pu_library", "pu_command", " cpu_mode", "pu_device", "pu_label", "cpumycommand", "cpu_owner", "cpu_command", "gpu_owner", " cpu_label", "cpu_type", "cpu_module", "cpu2mode", "pu_module", "pu_models", "cpu_mode", "cpu_meta", "cpu____meta", "cpu_device", "cpu____model", "cpumymodel", "gpu_type", "cpuetytype", "pu_type", "cpu____command", "gpu_model", "pu_model", "cpu2label", "cpu2type", "pu_meta", "cpu____type", "gpu_label", "cpuetylabel", "cpumymeta", "cpu_label", "cpu_library", " cpu_type"], "kernel_filename": [" kernel_file", "kernelityskin", "moduleityskin", "moduleitydir", "kernelpyfn", "vm_path", "vmablelocation", "kernel_dir", "kernel___file", "kernelablepath", "kernel___fn", "kernelityfilename", "kernel_fn", "kernelpyskin", "kernelpydir", "kernelityfn", "kernel___nm", "kernel_model", "vm_model", "kernel_skin", "vmablepath", "module_filename", "kernel_nm", "kernelablemodel", "kernelpyfilename", "module_dir", "vm_location", "kernel_location", "kernelablefilename", "kernel_path", "vmablemodel", " kernel_nm", "kernel_file", "vmablefilename", "kernelitydir", " kernel_fn", "kernel___filename", "moduleityfilename", "moduleityfn", "module_fn", "kernelablelocation", "vm_filename", "module_skin"], "cpu": ["mem", "nice", "pixel", "check", "bean", "mac", "memory", "pause", "nic", "linux", "component", "p", "coin", "proc", "cn", "ctx", "bo", "pc", "core", "gc", "util", "chip", "ruby", "cam", "profile", "disk", "pu", "aco", "library", "alloc", "ilo", "execute", "thread", "hw", "clock", "vm", "mu", "call", "conn", "reset", "c", "nu", "mx", "bench", "flow", "pool", "prof", "jp", "processor", "current", "runner", "gpu", "aux", "module", "cu", "computer", "cache", " CPU", "ro", "cum", "cp", "CPU", "home", "comp", "boot", "parse", "pai", "phys", "loop", "process"], "ram": ["mem", "iam", "na", "sam", "am", "sky", "res", "memory", "ra", "rain", "mm", "ras", "ow", "tar", "win", "ran", "ru", "gram", "rom", "core", "sum", "tem", "gc", "cam", "rad", " Ram", "rum", "gem", "mb", "ma", "alloc", "reg", "gra", "hw", "region", "rem", "sd", "gb", "mass", "cr", "dev", "mar", "ray", "root", "rss", "raw", "rank", "lam", "RAM", "bank", "space", "tm", "row", "sim", "ro", "cum", "buffer", "lay", "scan", "Ram", "process"], "n": ["na", "con", "ren", " N", "nt", "yn", "z", " len", "t", "nos", "i", "nia", " count", "en", "num", "ne", "span", "ng", " l", "mn", "nw", "name", "d", "ns", " p", "ln", "nn", "nor", "sn", " ns", "nb", "c", "nl", " j", "in", "j", "note", "non", "o", "N", "nan", "wn", "acc", "number", " num", "x", "gn", "nc", " m", "pn", "an", "s", "un", "nr", "inn", "names", "ex", " i", " missing", " c", "m"]}}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "static void ohci_reset(void *opaque)\n\n{\n\n    OHCIState *ohci = opaque;\n\n    OHCIPort *port;\n\n    int i;\n\n\n\n    ohci_bus_stop(ohci);\n\n    ohci->ctl = 0;\n\n    ohci->old_ctl = 0;\n\n    ohci->status = 0;\n\n    ohci->intr_status = 0;\n\n    ohci->intr = OHCI_INTR_MIE;\n\n\n\n    ohci->hcca = 0;\n\n    ohci->ctrl_head = ohci->ctrl_cur = 0;\n\n    ohci->bulk_head = ohci->bulk_cur = 0;\n\n    ohci->per_cur = 0;\n\n    ohci->done = 0;\n\n    ohci->done_count = 7;\n\n\n\n    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?\n\n     * I took the value linux sets ...\n\n     */\n\n    ohci->fsmps = 0x2778;\n\n    ohci->fi = 0x2edf;\n\n    ohci->fit = 0;\n\n    ohci->frt = 0;\n\n    ohci->frame_number = 0;\n\n    ohci->pstart = 0;\n\n    ohci->lst = OHCI_LS_THRESH;\n\n\n\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n\n    ohci->rhstatus = 0;\n\n\n\n    for (i = 0; i < ohci->num_ports; i++)\n\n      {\n\n        port = &ohci->rhport[i];\n\n        port->ctrl = 0;\n\n        if (port->port.dev) {\n\n            usb_attach(&port->port, port->port.dev);\n\n        }\n\n      }\n\n    if (ohci->async_td) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n    DPRINTF(\"usb-ohci: Reset %s\\n\", ohci->name);\n\n}\n", "idx": 18741, "substitutes": {"opaque": ["operacity", "iopacity", "oque", "oacity", "opiera", "operaques", "obaque", "obacity", "opaques", "oaque", "obiera", "oplaque", "obaques", "pque", "iopiera", "iopaque", "oplacity", "opacity", "opque", "paque", "pacity", "operaque", "operiera", "iopaques", "oplque"], "ohci": ["ahcin", "ovuci", "ighcu", " ohce", "ihcci", "ehcu", "ohnic", "ohuci", "ehpi", " ohcin", "ehmit", "hlcu", "ighcirc", "huci", "ehoci", " ohdi", "ohli", "orthcci", "ihpi", "ohdi", " ohcont", "ehce", "hcci", "okcu", "ohco", "omecci", " ohcci", "ohpi", "ihuci", "ihlc", "hhcci", "bhci", "hcu", "ehdi", "ahce", "ohcin", "ahpi", "ehli", "ohlc", "okoci", "omecgi", "ouchci", "Ohuci", "okdi", "Ohci", "hluci", "oshcit", "ehcgi", "hcin", "ohcit", " ehcin", "ihoci", "omecin", "orthcin", "hhce", "ehcit", "oshci", " ohuci", "hdi", "orthcu", "ohcgi", "ahcci", "ohcirc", "ighcci", "ahcu", "okcit", "hlci", "ovci", "oshcin", "ehcci", "ehcirc", " ohcu", "ihli", " ohcgi", "ahnic", "ahuci", " ehci", "ehlc", "ihcgi", "ohcont", "ehco", "ighli", "omecont", " ohlc", "okuci", "orthci", "omecu", "ohmit", "hci", "hlcci", "ahcirc", "ihcu", "ahlc", "ehci", "ehnic", "bhcci", "ovcci", "ahmit", "ohcu", "okcci", "ouchdi", "ihci", "ahci", "Ohli", "Ohcci", "okcgi", "ohoci", "oshcci", "ohce", "hldi", "okcont", "ouchuci", "ovcu", "ighcit", "ighmit", "okcin", "omeci", "ihco", "hhci", "ahdi", "ohcci", "ihcin", "ouchcci", " ehuci", "ihcit", "hhcin", "ahcit", "ighci", "bhnic", "ahli", "okco", "Ohdi", "oshdi", "okci", "bhce", "ehuci", " ehcci", "ehcin", "okli", "ihdi", "hli", "oshli"], "port": ["export", "boat", "report", "test", "feature", "option", "nel", "point", "cam", "vp", "PORT", "porter", "peer", "page", "line", "host", "project", "path", "gp", "module", "attribute", "player", "buffer", "import", "pe", "spec", "connection", "index", "server", "t", "pipe", "pp", "var", "pport", "device", "find", "link", "handle", "plugin", "tip", "service", "pt", "dev", "post", "let", "entry", "bind", "slave", "proxy", "Port", "interface", "mit", "profile", "mobile", "queue", "address", "eport", "ptr", "target", "note", "print", "fire", "cp", "priority", "bridge", "seat", "window", "phy", "p", "client", "ort", "pid", "pc", "public", "mate", " sport", "position", "ports", "pod", "socket", "select", "ve", "value", "tag", "table", "file", "pair", "key", "tty", "direction", "trace", "type"], "i": ["tim", "ic", "index", " pos", "ij", "b", " t", "si", "z", "t", "ci", "hi", "p", "mc", " ti", "me", "qi", "li", " pi", "is", "\u0438", "ri", "g", "I", " ii", "ai", " multi", " index", "v", "di", "cli", " mi", "ip", " vi", "mi", "pi", "ii", "ind", " j", "c", "j", "xi", "in", "ti", "ui", "batch", "gi", "ji", " I", "ami", "multi", "uri", "bi", "x", "info", " si", " di", " ni", " m", "zi", " v", "asi", " bi", "sim", "ini", "gu", "it", "ix", "iu", "y", " c", "m"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&\n\n                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {\n\n        /* Magnitude subtraction of infinities */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN subtraction */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 18744, "substitutes": {"env": ["here", "ov", "server", "eng", "window", "EN", "desc", "proc", "en", "enter", "ec", "app", "ctx", "end", "walker", "eco", "ner", "e", "te", "exc", "equ", "cur", "engine", "queue", "her", "v", "esc", "ew", "vs", "hw", "vm", "manager", "conn", "req", "msg", "event", "den", "dev", " environment", "ev", "forge", "context", "erd", "er", "viron", "block", "open", "nc", "shell", "qa", "entry", "ah", "code", "pe", "environment", "conf", "worker", "Environment"], "arg1": ["arg01", " arg91", "call01", "call3", " arg3", " argOne", "param1", "group91", "Arg2", "Arg1", "Arg91", "param01", " arg0", " arg01", "group1", "arg0", "arg91", "argOne", "groupOne", "param3", "ArgOne", "param0", "arg3", "group2", "call1", "call0"], "arg2": ["doc2", "argumentTwo", "arg4", "Arg2", "Arg1", "args4", " arg4", "docTwo", "doc1", "argument2", "args1", "Arg4", "argTwo", "args2", "argument1", " argTwo"], "farg1": ["umument1", "farg51", " fargOne", "fbar81", "fumentOne", "forg1", "fmarg91", "fmark51", "Fagg81", "fagg001", "fument81", "varg81", "faggOne", " fargsOne", "farg21", " figOnce", "farp91", "fmvarOne", "fagg81", "fumentone", " fargFirst", "fargsOne", "fuelloc1", "fvalidOne", "fig21", " fargone", "forg81", "figOne", "fvar51", "FaggOne", "Farg1", "farp1", "forgOne", " fargsone", "fargz", "farg91", "fvalidOnce", "vtagone", "fvar91", "fblock1", "fbar1", "fargs1", "fblock21", "fument61", "ftag81", "fmarg1", "fuelargo", "fument001", "fargumentone", "fblockOne", "fbarOne", "fargon", "fmark1", "fuelloc91", "farpz", "farg7", "fmarkon", "fvaron", "fask51", "fargone", "umargz", "fvalid21", "umarg91", "fargsone", "ftag001", "fargumentFirst", " figOne", "farg61", "fArgFirst", "umumentz", "farc001", "fblockOnce", "fargo", "ftagOne", " farg001", "Farg81", "FargOne", " fargs001", "farp3", "faskon", "xfvar1", "fargs91", "floc91", "fargOnce", "fbar001", "fmvar91", "fgrad81", "ftagone", "fask1", " fargOnce", "fArgone", "fgrad1", " fArgFirst", "vargone", "xfarg7", "farcFirst", " fArg1", "Fagg1", "fument3", "fgrado", "fargsz", "fuelloco", "umarg1", " fArgone", "fvar7", "fagg91", "fuelarg91", "vtag81", "farcone", "fargs001", "xfargon", "fflago", "umument3", "ftag61", "fuelloc81", "fflag81", "fArg1", "fflag91", "fArg001", "fmargOne", "fvar001", "fument1", "xfvaron", "fmarg001", "ftag1", "farg3", "fflag1", "fvar1", "fvalid1", "Fagg001", "fargument1", "fargs3", " farg21", "floc1", "fargument61", " fArg001", " fig21", "farc1", "floc81", "fgrad91", "fumentz", "forg001", "varg61", "fask7", "fagg1", "fuelarg1", " fig1", "fargFirst", "fig1", "fargument81", "fmvar1", "fargument001", "fvarOne", "umarg3", "Farg001", "figOnce", "xfvar7", "vtag61", "xfarg51", "farg001", "umument91", " fargs1", "fuelarg81", "fargOne", "floco", "fmvar001", "fmark7", "xfarg1", "fument91", "farg81", "xfvar51", "vtag1", "varg1"], "farg2": ["fang2", "farg102", "fpglet", "farg21", "fadmin21", "floatarg64", "fument2", "fblock9", "ftag9", " farg9", "floatang102", "fgroup2", "floatarg2", "fang21", "fadmin02", "fargtwo", "fpg0", "fang64", "fparam02", "ftag2", "fvalid21", "varg2", "fArg4", "fflag02", "ftagtwo", "fument64", "fadmin2", "farg02", "ftag3", " fArg4", "vagg02", "fblock2", "varg102", " fArg2", "farg64", "fgrouplet", "fflagtwo", "fagg2", " farg3", "fparam3", "fvalid102", "fflag2", "farg9", "fiter2", "fiter9", "fparam2", " farg4", "farg0", "floatang2", " ftag2", "fagg102", " ftagtwo", "farglet", "fpg2", "fagg02", "floatang64", "floatang21", "fument02", " farg0", "vagg102", " farglet", "floatarg102", "fument102", "farg3", "fvalid2", "fparam4", "fang102", " ftag0", "fparamtwo", " ftag3", "fflag3", "ftag02", "fvalid64", "varg02", "floatarg21", "fblock02", "vagg21", " ftag02", " ftag9", " ftaglet", "fadmin102", "fArg2", "ftag0", "varg21", "fiter02", "fagg21", "farg4", "fgroup0", "vagg2", "ftaglet", " farg02", "fument21", " fargtwo"]}}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_connect_init(NetClientState *peer,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            if (errno == EINTR || errno == EWOULDBLOCK) {\n\n                /* continue */\n\n            } else if (errno == EINPROGRESS ||\n\n                       errno == EALREADY ||\n\n                       errno == EINVAL) {\n\n                break;\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(peer, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 18759, "substitutes": {"peer": ["channel", "server", "el", "ca", "component", "p", "client", "sp", "proc", "me", "remote", "handler", "pc", "device", "actor", "owner", "node", "pro", "socket", "ptr", "instance", "pkg", "target", " Peer", "rel", "parent", "context", "member", "message", "cer", "ker", "er", "package", "state", "vr", "chain", "pe"], "model": ["channel", "man", "server", "style", "Model", "controller", "base", "device", "mod", "resource", "link", "command", "image", "address", "m", "method", "label", "serial", "kind", "param", "object", "entity", "dm", "scope", "message", "member", "models", "package", "module", "network", "attribute", "type", "brand", "pattern", "policy", "version", "mode", "process"], "name": ["man", "error", "ame", "comment", "term", "me", "family", "base", "normal", "ename", "prefix", "Name", "ment", "named", "address", "label", "description", "order", "id", "admin", "common", "local", "host", "n", "path", "key", "alias", "package", "net", "no", "names", "NAME", "title", "part", "version", "file", "create", "nam", "type"], "host_str": ["port_str", "host2str", "host_id", "host_br", " host_string", "port_string", "port_id", "host2Str", "host2id", "host2br", " host_Str", "port2id", "host2s", "port2string", "port2str", " host_s", "port_br", "host_string", "host_Str", "host_s", "host2string", "port2br"], "s": ["ies", "hs", "ds", "cs", "sam", "res", "t", "w", "p", "sb", "sp", "ins", "sq", "aws", "h", "results", "qs", "is", "bs", "g", "sv", "rs", "gs", "S", "ss", "comments", "des", "socket", "ns", "sts", "ps", "sports", "sn", "js", "sys", "c", "ats", "comm", "n", "fs", "sol", "less", "ts", "ssl", "ls", "stats", "ms", "sl", "b", "m"], "fd": ["td", "fed", "ds", "fn", "pipe", "window", "ffff", "dt", "lf", "stream", "port", "pid", " df", "fb", "hd", "buf", "fr", "cf", "dat", "dl", "bd", "handle", "d", "fin", "db", "ln", "socket", "ptr", "fee", "addr", "sd", "conn", "ff", "dir", "func", "id", "pd", "file", " fin", "fs", "fi", "df", "fc", "bf", "FD", "cb", "tty", "ld", "fx", "uf", "wind", "f", "fun", "fp", " fid", "ed", "dd", "fl"], "connected": ["hidden", "fed", "connection", "loaded", "approved", "used", "ready", " disconnected", "qualified", "linked", "played", "created", "reported", "done", "established", "checked", "started", "closed", "rolled", "built", "success", "conn", "joined", "changed", "printed", "finished", "enabled", "updated", "ported", "connect", "locked", "powered", "tested", "selected", "confirmed", "released", "opened", "encrypted", "ended", "led", "initialized", "mounted", "added", "ed", "registered", "active"], "ret": ["mem", "rm", "res", "nt", "t", "back", "deg", "flag", "dt", "result", "ll", "Ret", "err", "rect", "gz", "rt", "tn", "tr", "mt", "db", "reg", "inter", "ptr", "cont", "backed", "ft", "success", "rem", "RET", "reset", "re", "det", "nl", "ext", "ref", "val", "fi", "alt", "got", "encrypted", "len", "resp", "f", "fun", "gt", "elt", "red", "rets"], "saddr": ["esaddress", "sysaj", "spkg", "sysaddr", " sattr", "esadd", "wobj", " sadd", "padd", "southinfo", "paddr", "saddress", "Saddr", "sptr", "jsattr", "wattr", "esattr", "waddr", "sinfo", "southpkg", " saj", "wadd", " saddress", "southaddr", "esaddr", "southadd", "sobj", " sobj", "sysaddress", "ssaddr", "ssaddress", "pptr", " sadr", " spkg", "sattr", "sadr", "Saj", "saj", "ssobj", "Saddress", " sptr", "padr", "jsaddress", "jsaddr", "sadd", "ssattr", "jsadd", "waddress", " sinfo"]}}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check where the kernel has been linked */\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}", "idx": 18773, "substitutes": {"kernel_entry": ["kernelxhigh", "kernel_flag", " kernel_name", "kernel__only", "module_zero", "energyityexclusive", "kernel__entry", "kerneltentry", "kernelityentry", "energyityflag", "kernelxentry", " kernel_look", "kernel8option", "energyityexistent", "kernelxcheck", "energy_existent", "kernel__look", "kernel8high", "kernel__name", "kernelityexclusive", "kernel_zero", "module_option", "kernelxoption", "module_check", "kerneltsearch", "kerneltzero", "kernel8entry", "kernelthigh", "kernel_name", "module_search", "kernel_check", "kernelityexistent", "module_high", "energy_flag", "kernel8check", "kernel_only", "kernel_exclusive", "kernelityflag", " kernel_only", "module_entry", "kernel_existent", "kernel_option", "energyityentry", "energy_exclusive", "kernel_look", "kernel_search", "energy_entry"], "kernel_high": [" kernel_index", "kernel_index", "ernel_low", " kernel_low", "kernel_specific", "kernelaxyhigh", "kernel_hi", " kernel_hi", "kernelaxyspecific", "ernel_high", "ernel_specific", "ernel_hi", "kernelaxyhi", "kernelaxylow", "kernel_low", "kernel_higher", " kernel_higher"], "initrd_size": ["initra_size", "initrdLstate", "initrh_size", "initrd_fee", "initrd__ize", "initnd_state", "initrd_Size", "initrd__start", "initrd_state", "initnd67offset", "initrer_size", "initrh_ize", "initra_sum", "initrd67offset", "initra_ize", "initrh_style", "initnd67Size", "initrd_start", "initrd__space", "initnd_offset", "initrd__style", "initra_fee", "initrd_index", "initrh_start", "initrd_name", "initrd__offset", "initrer_SIZE", "initrb_space", "initrb_offset", "initrdLsize", "initrer_max", "initrd__SIZE", "initrs_size", "initrd_style", "initnd_size", "initnd67size", "initrd_SIZE", "initrs_name", "initrer_state", "initrd_sum", "initrb_size", "initrd_space", "initrdLSIZE", "initrd67state", "initrd67size", "initrd_ize", "initrd67Size", "initnd_Size", "initnd67state", "initrs_index", "initrd__size", "initrd_max", "initrb_SIZE", "initrdLmax"], "initrd_offset": ["initrb_start", "initrod__index", "initrd__index", "initrd_left", "initrd__start", "initrb_position", "initrdingleft", "initrod__Offset", "initrd_out", "inithringoffset", "initrd___index", "inithr_address", "inithringOffset", "initrd__Offset", "initrod__off", "inithr_left", "initrd_Offset", "initrd___offset", "initrd_start", "initrd__position", "initrd_index", "initrd__offset", "initrb_offset", "initrb_Offset", "initrd_off", "initrdingaddress", "initrd_position", "initrd___Offset", "initrod_offset", "initrdingOffset", "initrd___out", "inithringleft", "initrd_op", "initrod_Offset", "initrod_index", "initrd_address", "inithr_offset", "initrb_size", "initrdingoffset", "initrb_index", "initrb_op", "inithr_Offset", "initrb_out", "cont", "initrd__off", "func", "initrod_off", "inithringaddress", "initrd__size", "initrd__out", "initrod__offset"], "big_endian": ["big_ndians", "big_endser", "big_crossian", "big_endians", "big_endsIAN", "big_medien", "big_beginian", "big_endsical", "big_endien", "big_medical", "big_medig", "big_beginical", "big_beginIAN", "big_endful", "big_endsian", "big_endsians", "big_ndIAN", "big_median", "big_ndian", "big_endsig", "big_crossful", "big_endsful", "big_endig", "big_medric", "big_ndric", "big_endIAN", "big_endsric", "big_endical", "big_crossIAN", "big_beginians", "big_medIAN", "big_endsien", "big_ndful", "big_meder", "big_medians", "big_ndien", "big_ender", "big_crossians", "big_endric"], "prom_buf": ["promxbuffer", "promxindex", "prom_buffer", "prom_msg", "mem_buf", "mem_buffer", "mem_msg", "promxmsg", "mem_index", "promxbuf"], "prom_size": ["prom__num", "prom__size", "prom2size", "rim__num", "prom2num", "rim__size", "prom__set", "prom_length", "prom__length", "rim__length", "rim_set", "rim_size", "rim__set", "rim_length", "prom_num", "prom2length", "prom_set", "rim_num", "prom2set"], "xlate_to_kseg0": ["xlate_to_kseeg_", "xlate_to_ksem3", "xlate_to_ksegm0", "xlate_to_kseeg1", "xlate_to_kseig2", "xlate_to_kseeg0", "xlate_to_kseg3", "xlate_to_ksep0", "xlate_to_kseg1", "xlate_to_ksegs0", "xlate_to_kseg2", "xlate_to_ksem0", "xlate_to_kseag0", "xlate_to_ksegm1", "xlate_to_kseeg2", "xlate_to_kscheeg2", "xlate_to_kseig3", "xlate_to_ksegs1", "xlate_to_kscheg3", "xlate_to_ksep2", "xlate_to_kscheeg0", "xlate_to_kseig0", "xlate_to_ksegs2", "xlate_to_kseeg3", "xlate_to_kseg_", "xlate_to_ksegm_", "xlate_to_kscheg2", "xlate_to_kseag_", "xlate_to_kseag1", "xlate_to_kscheeg3", "xlate_to_kscheg0", "xlate_to_ksep1", "xlate_to_ksem2"], "opaque": [" openg", "opque", "openaque", "oplay", "openque", "popaque", " oplay", "openeng", "popeng", "openlay", " opque", "openg", "popque", "poplay"], "addr": ["mem", "offset", "arr", "pad", "var", "asm", "hash", "adr", "map", "alloc", "name", "address", "pointer", "attr", "dr", "ptr", "add", "obj", "progress", "order", "id", "ref", "state", "info", "arp", "err", "type"], "prom_index": ["prom_offset", "prom_loc", "promjindex", "prom2offset", "promgoffset", "promgloc", "promjloc", "rem2loc", "prom2index", "rem_loc", "prom2slot", "rem2slot", "rem_index", "prom_slot", "promjslot", "rem_slot", "promjoffset", "rem_offset", "promgslot", "rem2index", "promgindex", "rem2offset", "prom2loc"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_anon(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n", "idx": 18781, "substitutes": {"data": ["missing", "next", "rew", "form", "error", "res", "format", "t", "window", "input", "result", "query", "device", "empty", "ata", "dat", "map", "initial", "group", "step", "accept", "d", "DATA", "mu", "da", "Data", "iter", "reader", "json", "to", "rel", "batch", "context", "join", "def", "table", "raw", "info", "block", "spec", "text", "bus"], "unused": ["sunuse", " uninitialized", "unalinitialized", "unUsed", "unalused", "suninitialized", "uninitialized", " unuse", "unaluse", "sunUsed", "unalUsed", " unUsed", "sunused", "unuse"], "tmp": ["temp", "mem", "MP", "snap", "cv", "sam", "np", "nt", "perm", "t", "imm", "img", "p", "sp", "var", "vt", "xy", "ctx", "nv", "buf", "vp", "Temp", "mb", "uv", "etc", "ptr", "obj", "attr", "tab", "mp", "nb", "pkg", "mk", "cmp", "rb", "aux", "txt", "params", "tt", "mut", "emp", "buff", "src", "mint", "err", "m"], "v": ["vi", "cv", "ov", "l", "t", "w", "i", "p", "var", "vt", "q", "nv", "av", "g", "sv", "vp", "u", "vc", "conv", "uv", "vs", "vm", "c", "j", "vy", "vis", "ev", "V", "x", "vo", "vv", "ver", "vr", "f", "it", "tv", "b", "y", "m"], "errp": ["errps", "errpen", "ererpen", "rrpl", "diep", "ererpa", "errpad", "ererpl", "diepa", "arrp", "attrpa", "rrpa", "arrpid", "errpa", "diecp", "attrp", "diepers", "attrpad", "errpers", "errcp", "attrpen", "erercp", "rrp", "rrpid", "arrpa", "arrps", "lerpa", "ererp", "rrpad", "errpid", "errpl", "attrpl", "ererpers", "attrps", "rrps", "lerpers", "rrpen", "lercp", "attrpid", "lerp", "ererpad"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n", "idx": 18799, "substitutes": {"dev": ["mem", "debug", "os", "nt", "server", "w", "de", "window", "pad", "p", "Dev", "var", "proc", "md", "test", "h", "app", "ctx", "on", "device", "DEV", "g", "buf", "av", "hd", "link", "disk", "handle", "ad", "d", "db", "v", "serial", "hw", "ve", "obj", "conn", "sd", "data", "cmd", "spec", "pt", "att", "ev", "host", "def", "env", "info", "block", "Device", "ver", "dem", "exec", "conf", "dd"], "vq": [" vpl", "vcQ", "sviq", "svqq", "vdq", "evqq", "vcq", "vtqq", "svmsg", "vtq", "vmsg", " vw", " vdq", "vck", "evh", " vck", "hck", "svq", "viq", "evq", " vgr", "vtiq", "vcw", "svgr", "Vqq", "vcpl", "svw", "vQ", "vcgr", "vgr", "svh", "vcdq", "vh", "vqq", "vpl", " vmsg", "hQ", "vth", "eviq", "Vmsg", "vw", "vcck", " vqq", "hq", "hdq", "vv", "svv", " vQ", " vv", "Vq", "svpl", "Vv"], "n": ["na", "index", " N", "nt", "l", "z", "t", "i", "p", "num", "cn", "ne", "ng", "tn", "name", "ity", "d", "ns", "ln", "nn", "nor", "sn", " ns", "nb", "c", "nu", "ind", "nl", "j", "number", "N", "o", "nm", "x", "nc", "nr", " ng", "m"]}}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)\n\n{\n\n    AVFilterContext  *ctx = inlink->dst;\n\n    ATempoContext *atempo = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n\n\n    int ret = 0;\n\n    int n_in = src_buffer->nb_samples;\n\n    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);\n\n\n\n    const uint8_t *src = src_buffer->data[0];\n\n    const uint8_t *src_end = src + n_in * atempo->stride;\n\n\n\n    while (src < src_end) {\n\n        if (!atempo->dst_buffer) {\n\n            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);\n\n            if (!atempo->dst_buffer)\n\n                return AVERROR(ENOMEM);\n\n            av_frame_copy_props(atempo->dst_buffer, src_buffer);\n\n\n\n            atempo->dst = atempo->dst_buffer->data[0];\n\n            atempo->dst_end = atempo->dst + n_out * atempo->stride;\n\n        }\n\n\n\n        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);\n\n\n\n        if (atempo->dst == atempo->dst_end) {\n\n            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /\n\n                             atempo->stride);\n\n            ret = push_samples(atempo, outlink, n_samples);\n\n            if (ret < 0)\n\n                goto end;\n\n        }\n\n    }\n\n\n\n    atempo->nsamples_in += n_in;\n\nend:\n\n    av_frame_free(&src_buffer);\n\n    return ret;\n\n}\n", "idx": 18812, "substitutes": {"inlink": ["dinline", "INmatch", "inmatch", "cinLink", "dinlink", "dinmap", "cinmatch", " inLink", "innlink", "innline", "cinline", "INlink", " inmatch", "dinscan", "inLink", "outline", "outscan", "inscan", "innmap", "INline", "innscan", "inmap", "outmap", "cinlink", "INLink"], "src_buffer": ["src_Buffer", " src_buf", "src_buf", "src2reference", "src___buffer", "sel___Buffer", "rc_uffer", "src_channel", "src_uffer", "rc_buff", "sel___buff", "sel_buffer", "rc_buf", "rc_buffer", "src___buff", " src_channel", "src___Buffer", "sel_Buffer", "sel___buffer", " src_buff", "src_buff", "sel_buff", "src_reference", "src2buffer", "src2buff", "sel___reference", "sel_reference", " src_Buffer", "src2Buffer", "src___reference"], "ctx": ["ctl", "cv", "loc", "np", "tc", "ca", "tz", "tx", "mc", "timeout", "gc", "setup", "cf", "config", "tmp", "jac", "ct", "cc", "bc", "kw", "co", "hw", "obj", "wd", "conn", "kk", "cmd", "pkg", "func", "pool", "jp", "context", "ctrl", "cfg", "cmp", "cm", "lc", "act", "txt", "Context", "nc", "cb", "xc", "cp", "abc", "conf"], "atempo": ["mateota", "paiota", "atomping", "atemhea", "paipi", "ematepo", "atomaco", "animatebo", "mmmmpa", "ampos", "aumpi", "iemmo", "atemping", "iemo", "adempa", "paimo", "atepos", "atembo", "atonpo", "atonaco", "iempo", "aramote", "ematepa", "atenote", "atemaco", "atempa", "aumgo", "atonpi", "atenppo", "atonpty", "mateporter", "atenporal", "tmpr", "tempro", "atenpa", "aumo", "matepa", "aramporal", "tmpot", "monto", "montpa", "aumaco", "addyaco", "animatepo", "atemlo", "atonpro", "ademmo", "atempor", "montpo", "tmmo", "aumpa", "mmmmgo", "atempp", "tmota", "atonporal", "amorphpr", "matepi", "tmpo", "atenpo", "atenping", "addypos", "empping", "atempty", "atenpr", "emacho", "atonpos", "atenpro", "atemppo", "atenpp", "atengo", "atonhea", "matego", "atempro", "atenhea", "amo", "tmo", "atemfo", "atonpot", "atemota", "httlo", "emppo", "mmmmpo", "atomlia", "atemcho", "atenota", "aumporter", "tempp", "montpos", "montpi", "adempo", "atemote", "paio", "atompor", "atepo", "atempos", "atonho", "atemgo", "animatepi", "addypor", "tembo", "amorphpos", "ematefo", "atomho", "atenporter", "eddypa", "eddypo", "atonlo", "atemho", "ademote", "matepo", "paipos", "emapos", "atenaco", "emaota", "emaho", "atenlia", "atenpi", "atempot", "emapa", "emplia", "addypo", "atepi", "temfo", "atompa", "atonote", "iempos", "animatepos", "adempos", "atenpor", "eddypi", "atemlia", "aumote", "ademppo", "ematepos", "tempos", "atemporter", "addypp", "atemo", "atomlo", "aramota", "atongo", "emapo", "iasmpo", "montote", "atoncho", "aumhea", "tempty", "tempo", "adempot", "ammo", "atenpos", "tmpos", "arampo", "iasmpot", "amorphota", "adempi", "atompot", "tmpa", "atenpot", "empho", "tempa", "emaote", "atonpa", "paipo", "paipa", "aumpo", "tempi", "atomota", "ampo", "atonota", "atemporal", "iasmota", "httpo", "temota", "montpty", "httota", "atompo", "amorphpo", "atenho", "temote", "aramppo", "iasmcho", "emateota", "paipot", "mmmmota", "atebo", "paifo", "mateote", "atemmo", "atempi", "aramgo", "emapot", "emago", "eddyote", "atempr", "addypa", "httpot", "paiote", "arampot", "aumho"], "outlink": ["outloop", "fromloop", "fromlink", "outputloop", " outroute", "fromroute", " outloop", "outthread", "outputthread", "outputlink", "outLink", "outroute", "outputroute", "inthread", "fromline", "inLink", "outline", "outputLink", " outLink", " outthread", " outline", "outputline"], "src": ["index", "loc", "sel", "filename", "img", "i", "sb", "sub", "ins", "st", "input", "imp", "rt", "syn", "cur", "rs", "tmp", "length", "ebin", "tp", "bg", "seek", "conv", "ptr", "iter", "cont", "addr", "sys", "sn", "RC", "ind", "inner", "inst", "rel", "r", "origin", "ctrl", "raw", "obs", "str", "now", "usr", "source", "txt", "sr", "s", "rc", "scan", "url", "sur", "ctr", "sc", "comp", "dest", "ser", "trans", "rl"], "src_end": ["src_ends", "rc_end", "src_start", "sec_end", "rc_offset", "rc_ends", "src_offset", "sec_END", "sec_est", "rc_start", "src_END", "rc_END", "sec_start", "src_est"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "struct vhost_net *vhost_net_init(VhostNetOptions *options)\n\n{\n\n    int r;\n\n    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n\n\n    if (!options->net_backend) {\n\n        fprintf(stderr, \"vhost-net requires net backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (backend_kernel) {\n\n        r = vhost_net_get_fd(options->net_backend);\n\n        if (r < 0) {\n\n            goto fail;\n\n        }\n\n        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)\n\n            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);\n\n        net->backend = r;\n\n    } else {\n\n        net->dev.backend_features = 0;\n\n        net->backend = -1;\n\n    }\n\n    net->nc = options->net_backend;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = net->nc->queue_index;\n\n\n\n    r = vhost_dev_init(&net->dev, options->opaque,\n\n                       options->backend_type, options->force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (backend_kernel) {\n\n        if (!qemu_has_vnet_hdr_len(options->net_backend,\n\n                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);\n\n        }\n\n        if (~net->dev.features & net->dev.backend_features) {\n\n            fprintf(stderr, \"vhost lacks feature mask %\" PRIu64\n\n                   \" for backend\\n\",\n\n                   (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n            vhost_dev_cleanup(&net->dev);\n\n            goto fail;\n\n        }\n\n    }\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 18819, "substitutes": {"options": ["ptions", "times", "os", "ops", "outs", "offs", "args", "limits", "settings", "terms", "flags", "details", "false", "changes", "als", "comes", "abilities", "pieces", "lines", "sequence", "tops", "zero", "option", "checks", "public", "vals", "rules", "global", "caps", "config", "points", "pins", "onet", "other", "values", "Options", "plates", "ports", "OP", "properties", "cells", "keys", "tools", "ices", "example", "maker", "lets", "steps", "table", "eps", "errors", "aux", "alias", "weights", "ts", "actions", "faces", "ims", "parts", "meta", "info", "features", "params", "stats", "orts", "names", "objects"], "r": ["ren", "air", "res", "l", "ur", "arr", "t", "i", "p", "client", "result", "rw", "q", "ry", "ir", "ar", "kr", "h", "hr", "rt", "e", "g", "fr", "resource", "rs", "mr", "run", "rr", "d", "v", "attr", "dr", "rar", "ptr", "lr", "rd", "re", "c", "ror", "cr", "record", "like", "j", "n", "R", "rg", "repl", "rb", "er", "sr", "rate", "rn", " err", "ro", "entry", "rc", "f", "nr", "b", "br", "err", "m"], "net": ["grid", "nets", "dt", "test", "rt", "Net", "resource", "tree", "mat", "obj", "sys", "page", "physical", "plain", "art", "number", "ether", "module", "city", "chain", "not", "serv", "mem", "connection", "channel", "np", "server", "t", "list", "result", "port", "set", "domain", "on", "pot", "dat", "tmp", "virtual", "NET", "io", "msg", "n", "ent", "null", " Net", "org", "ut", "init", "hidden", "nt", "res", "nic", "total", "term", "num", "kt", "ne", "vert", "nut", "all", "fat", "ip", "mot", "cart", "non", "network", "no", "write", "gate", "m", "next", "man", "eng", "client", "remote", "ng", "config", "out", "db", "web", "ns", "nat", "conn", "pool", "et", "mult", "ms", "inet", "prot"]}}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n\n\n        filename = p1;\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"usb-storage\");\n\n\n\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    if (qdev_init(&dev->qdev) < 0)\n\n\n\n\n    return dev;\n", "idx": 18820, "substitutes": {"usb_msd_init": ["usb_msb_init", "usb_msd__Init", "usb_msd_new", "usb_msb_new", "usb_msb_info", "usb_msd__new", "usb_msb_Init", "usb_msd_Init", "usb_msd_info", "usb_msd__info", "usb_msd__init"], "filename": ["format", "username", "Filename", "kj", "lua", "length", "which", "black", "path", "fs", "nil", "rn", "url", "fp", "names", "title", "NAME", "spec", "ren", "fn", "np", "ame", "finals", "ames", "til", "files", "sn", "description", "json", "n", "JSON", "directory", "len", "f", "wcs", "status", "png", "fd", "location", "existent", "fil", "xxx", "unc", "ename", "prefix", "subject", "name", "jpg", "nl", "source", "txt", "nm", "bol", "text", "needed", "p", "fle", "config", "mpeg", "pdf", "position", "brace", "ext", "jing", "sequence", "src", "println", "sql", "file"], "id": ["init", "fd", "error", "size", "t", "window", "pad", "uid", "num", "h", "hash", "pid", "end", "base", "sid", " ID", "wid", "name", "d", "kid", "start", " tid", "kind", "ide", "addr", "Id", "dir", "in", "ref", "r", "rid", "ids", "oid", "root", "str", "n", "number", "key", "info", "nd", "no", "status", "mid", "vid", "f", "ID", " fid", "it", "ident", "type"], "opts": ["proct", "optjs", "opct", "ops", " opns", "operTS", "opjs", "OPts", "opt", "opsTS", "optpers", " opouts", "copts", " opt", "opters", "iopets", "OPets", "optct", "opsps", "opspers", " opps", "proters", "optps", "operts", "opsjs", "OPps", "operct", "cophs", "copTS", "opns", "OPns", "copls", "coprs", "opths", "opouts", "opsls", "ophs", "opsct", "optts", "opsts", " oppers", "oprs", "opls", "prots", " opct", " opls", "optTS", "optouts", "optls", "opshs", " oprs", "opTS", " opTS", " opjs", "opps", "opets", " opters", "optrs", "oppers", "iopts", " ops", "iopns", "iops", "OPs", "OPouts", "optt", "optters", "prot", " opets"], "dinfo": [" dfo", " dattr", " dinf", "rinf", " dINFO", " dInfo", "udinf", "DINFO", "dattr", "dINFO", "rfo", "DInfo", "Dno", "ddno", "lINFO", "ddattr", "finf", "Dattr", "lInfo", "Dinformation", "udinformation", "Dinfo", "fInfo", "dInfo", "udinfo", "dinformation", " dno", "rInfo", "ffo", "finfo", "dno", "ddinfo", "linfo", "dinf", " dinformation", "dfo", "Dinf", "ddInfo", "rinfo"], "dev": ["mem", " device", "adv", "ov", "nt", "die", "server", "w", "de", "pad", "Dev", "var", "ow", "van", "door", "end", "device", "DEV", "buf", "cam", "usb", "roller", "tr", "disk", "des", "ad", "out", "pro", "v", "serial", "hw", "ptr", "ve", "obj", "wd", "iv", "hid", "sd", "driver", "data", "DE", "priv", "conn", "cmd", "ev", "new", "fo", " Dev", "def", "develop", "gpu", "env", "info", "vo", "gu", "go", "ver", "tech", "Device", "devices", "serv", "od", "dd"], "fatal_error": ["fatal_ERROR", "fatal__no", "familiar_ror", "fatal___err", "fatal___ror", "fatalityno", "fatal_ror", "fatal_no", "familiar_error", "fatalityror", "fatal__ror", "fatal___error", "fatal__ERROR", "fatal__error", "fatalityerror", "fatalityERROR", "fatal_err", "familiar_ERROR", "familiar_no"], "p1": ["jp0", "P2", "t2", "sp3", "t1", "POne", "jp2", " p0", "P0", "sp2", "P5", "sp1", " pOne", "P3", " p3", "jp1", "P1", "p5", "sp0", "p0", "jp5", "jpOne", "jp7", "p3", "pOne", " p7", "p7", "P7", "t0", " p5", "t3"], "fmt": [" fformat", " flt", "tfmt", "sfprintf", " fMT", "flt", "formt", "fformat", "fmats", " ftm", "tftm", "fats", " fats", "fmmt", "Ftm", "fmformat", "fMT", "FMT", "fortm", "tfformat", "tflt", "forformat", "Fprintf", "Fmt", "sflt", "fmprintf", "sfMT", "sfmt", "Fats", "Flt", "ftm", "forlt", "Fformat"], "nr": ["next", " NR", "np", "nt", " n", "num", "radius", "ar", "kr", "nv", "adr", "ni", "ng", " resid", "mr", "nz", "nw", "inter", "ptr", "iter", "Ni", "nn", "attr", "sys", "sn", "nb", "nl", "NR", "arity", "r", "rid", "oid", "gr", "n", "er", "nc", " ni", "rn", "chain", "ctr", "br", "err"], "p2": ["tp2", "f3", "P2", "op2", " p4", "jp3", "op4", " ptwo", "jp2", "tp1", "p4", "ptwo", "P4", "tp3", "tptwo", "P3", " p3", "op1", "jp1", "f2", "f4", "Ptwo", "P1", "f1", "p3", "optwo", "jp4"]}}
{"project": "FFmpeg", "commit_id": "aacf6b3a2fd8bc8603e3deaa6e612ea03cf08707", "target": 1, "func": "static inline void rv34_mc(RV34DecContext *r, const int block_type,\n\n                          const int xoff, const int yoff, int mv_off,\n\n                          const int width, const int height, int dir,\n\n                          const int thirdpel, int weighted,\n\n                          qpel_mc_func (*qpel_mc)[16],\n\n                          h264_chroma_mc_func (*chroma_mc))\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    uint8_t *Y, *U, *V, *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, umx, umy, lx, ly, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride + mv_off;\n\n    int is16x16 = 1;\n\n\n\n    if(thirdpel){\n\n        int chroma_mx, chroma_my;\n\n        mx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) / 3 - (1 << 24);\n\n        my = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) / 3 - (1 << 24);\n\n        lx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) % 3;\n\n        ly = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) % 3;\n\n        chroma_mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        chroma_my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = (chroma_mx + (3 << 24)) / 3 - (1 << 24);\n\n        umy = (chroma_my + (3 << 24)) / 3 - (1 << 24);\n\n        uvmx = chroma_coeffs[(chroma_mx + (3 << 24)) % 3];\n\n        uvmy = chroma_coeffs[(chroma_my + (3 << 24)) % 3];\n\n    }else{\n\n        int cx, cy;\n\n        mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] >> 2;\n\n        my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] >> 2;\n\n        lx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] & 3;\n\n        ly = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] & 3;\n\n        cx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        cy = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = cx >> 2;\n\n        umy = cy >> 2;\n\n        uvmx = (cx & 3) << 1;\n\n        uvmy = (cy & 3) << 1;\n\n        //due to some flaw RV40 uses the same MC compensation routine for H2V2 and H3V3\n\n        if(uvmx == 6 && uvmy == 6)\n\n            uvmx = uvmy = 4;\n\n    }\n\n    dxy = ly*4 + lx;\n\n    srcY = dir ? s->next_picture_ptr->f.data[0] : s->last_picture_ptr->f.data[0];\n\n    srcU = dir ? s->next_picture_ptr->f.data[1] : s->last_picture_ptr->f.data[1];\n\n    srcV = dir ? s->next_picture_ptr->f.data[2] : s->last_picture_ptr->f.data[2];\n\n    src_x = s->mb_x * 16 + xoff + mx;\n\n    src_y = s->mb_y * 16 + yoff + my;\n\n    uvsrc_x = s->mb_x * 8 + (xoff >> 1) + umx;\n\n    uvsrc_y = s->mb_y * 8 + (yoff >> 1) + umy;\n\n    srcY += src_y * s->linesize + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    if(   (unsigned)(src_x - !!lx*2) > s->h_edge_pos - !!lx*2 - (width <<3) - 4\n\n       || (unsigned)(src_y - !!ly*2) > s->v_edge_pos - !!ly*2 - (height<<3) - 4){\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 22 * s->linesize;\n\n\n\n        srcY -= 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, srcY, s->linesize, (width<<3)+6, (height<<3)+6,\n\n                            src_x - 2, src_y - 2, s->h_edge_pos, s->v_edge_pos);\n\n        srcY = s->edge_emu_buffer + 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(uvbuf     , srcU, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        s->dsp.emulated_edge_mc(uvbuf + 16, srcV, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n    }\n\n    if(!weighted){\n\n        Y = s->dest[0] + xoff      + yoff     *s->linesize;\n\n        U = s->dest[1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = s->dest[2] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }else{\n\n        Y = r->tmp_b_block_y [dir]     +  xoff     +  yoff    *s->linesize;\n\n        U = r->tmp_b_block_uv[dir*2]   + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = r->tmp_b_block_uv[dir*2+1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }\n\n\n\n    if(block_type == RV34_MB_P_16x8){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8;\n\n        srcY += 8;\n\n    }else if(block_type == RV34_MB_P_8x16){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8 * s->linesize;\n\n        srcY += 8 * s->linesize;\n\n    }\n\n    is16x16 = (block_type != RV34_MB_P_8x8) && (block_type != RV34_MB_P_16x8) && (block_type != RV34_MB_P_8x16);\n\n    qpel_mc[!is16x16][dxy](Y, srcY, s->linesize);\n\n    chroma_mc[2-width]   (U, srcU, s->uvlinesize, height*4, uvmx, uvmy);\n\n    chroma_mc[2-width]   (V, srcV, s->uvlinesize, height*4, uvmx, uvmy);\n\n}\n", "idx": 18830, "substitutes": {"r": ["l", "t", "w", "i", "p", "q", "h", "ar", "e", "g", "rs", "mr", "u", "d", "v", "k", "dr", "c", "re", "cr", "j", "n", "R", "rg", "er", "rb", "x", "sr", "rc", "vr", "f", "rf", "b", "m"], "block_type": ["blockblockid", "blockblockkind", "frame_id", "block_id", "blockblocktypes", "blockblocktype", "block_types", "frame_kind", "frame_types", "block_kind", "frame_type"], "xoff": ["Xoff", " xOff", " xoffs", "xoffs", "fxoffs", "xOff", "fxoff", "fxOff", "XOff", "Xoffs"], "yoff": ["Yoff", "Yoffs", "yyoffset", "yOff", "yyoffs", "yyoff", "xoffs", "yyOff", "Yoffset", "xOff", "yoffs", "yoffset", "xoffset", "YOff"], "mv_off": ["mv2on", "mV_no", "mvxoff", "mv_on", "mx_off", "mv2offset", "mvjno", "mx_offset", "mv2Off", "mvjoffs", "mv_Off", "mv_offset", "mvxOff", "mvjoffset", "mv_no", "mx_Off", "mV_offs", "mv_offs", "mvjoff", "mvxoffset", "mv2off", "mV_off", "mvxon", "mx_on", "mV_offset"], "height": ["history", "sky", "style", "density", "size", "gravity", "depth", "hang", "h", "radius", "inches", "resolution", "length", "ch", "bottom", "flow", "wh", "dim", "yt", "gh", "angle", "ty", "Height", "y"], "dir": ["pos", "grad", "channel", "fd", "orient", "dial", "dist", "window", "lib", "desc", "dep", "direct", "dn", "Dir", "ir", "rect", "lock", "rad", "dirty", "ht", "tr", "rec", "method", "d", "db", "di", "ptr", "dr", "kind", "folder", "DIR", "wd", "iter", "manager", "driver", "range", "attr", "det", "ind", "dm", "rot", "dev", "ext", "def", "str", "diff", "dy", "bound", "path", "dict", "directory", "dim", "uri", "tab", "row", "vol", "url", "direction", "file", "draft"], "thirdpel": ["qpan", "dpan", "threepan", "rightpel", "thirdpan", "qpel", "dpel", "threepel", "dpol", "threecel", "thirdpol", "rightcel", "dcel", "qpol", "rightpan", "rightpol", "thirdcel", "qcel", "threepol"], "weighted": ["Weighted", "Weighteds", "weightable", "Weightable", "lighteds", "lighted", "Weightedd", "weighteds", "processeds", "lightable", "processed", "processedd", "weightedd", "lightedd", "processable"], "qpel_mc": ["qpel_pc", "qpel_mac", "qpel_mem", "qpol_mc", "qpol_mac", "qpol_pc", "qpol_mem"], "chroma_mc": ["chromera_mc", "chroma_mic", "chromera_mic", "chromera_fc", "chromera_gc", "chroma_fc", "chroma_gc"], "s": ["z", "scripts", "details", "g", "rs", "conv", "se", "sys", "c", "es", "comm", "fs", "space", "er", "ex", "spec", "sl", "os", "ops", "t", "settings", "qs", "S", "ss", "v", "sts", "ps", "https", "n", "ts", "ls", "stats", "f", "sc", "status", "a", "ds", "cs", "times", "w", "sb", "as", "ses", "als", "south", "sv", "sw", "session", "http", "js", "storage", "source", "state", "ssl", "states", "b", "y", "m", "hs", "fps", "i", "p", "ins", "sq", "h", "is", "gs", "ns", "sports", "ats", "views", "less", "ims", "ms", "src", "sql", "conf", "its"], "Y": ["UV", "My", "YE", "Py", "Sky", "UK", "HT", "I", "J", "G", "S", "Ty", "TY", "H", "X", "B", "XY", "YP", "M", "Q", "W", "YC", "YY", "Z", "MY", "y", "T"], "U": ["UV", "UI", "MU", "UK", "UM", "I", "UT", "u", "S", "Unity", "X", "UU", "UE", "M", "UC", "OU", "C", "D", "R", "W", "A", "E", "P", "F", "UX", "T", "US"], "V": ["UV", "VOL", "TV", "I", "G", "VA", "S", "v", "H", "X", "B", "VO", "M", "Q", "L", "W", "C", "R", "CV", "VC", "VM", "VS", "Z", "E", "P", "F", "T"], "srcY": ["sourceX", "sourceV", "rcTY", "rcV", "rcY", "sourceTY", " srcX", "sourceY", "srcTY", "rcX", " srcTY", "srcX"], "srcU": ["sourceX", "rcU", "rcX", "viaA", "sourceU", "rcA", "viaX", "srcA", "sourceA", "viaU", "srcX"], "srcV": ["sourceX", "rcU", "sourceV", "rcX", "sourceU", "rcT", "rcV", "srcT", " srcX", "sourceT", " srcT", "srcX"], "dxy": ["dwy", "dxf", "tpx", "txf", "sdxy", "sdpx", "zxf", "sdxf", "sdwy", "twy", "dpx", "txy", "zwy", "zpx", "zxy"], "mx": ["mes", "mie", "px", "lex", "zx", "mm", "tx", "colm", "mc", "hz", "ml", "rx", "me", "xy", "ey", "ym", "mr", "mn", "mos", "nz", "ox", "mb", "ma", "wx", "mic", "mi", "mp", "xs", "mus", "mas", "xi", "yx", "mite", "x", "tm", "mis", "xes", "ux", "ms", "mmmm", "y", "m"], "my": ["mem", "iam", "ies", "mes", "mys", "mie", "mm", "me", "xy", "mmm", "ry", "li", "sym", "ym", "mn", "py", "ity", "ma", "ury", "mic", "mi", "mp", "yy", "ky", "yer", "vy", "zy", "fy", "gy", "mon", "ny", "iy", "MY", "by", "mis", "ms", "ty", "y", "m"], "umx": ["ufp", "ubix", "uly", "uminump", "uminumx", "ulpx", "ulp", "ump", "umix", "uminumex", "impx", "ulex", "ubpx", "umpx", "imex", "imx", "imix", "ulx", "ulix", "ufx", "ubx", "ubex", "ufy", "umex", "uminumy", "ufex"], "umy": ["mpsy", "cummy", "uminumx", "ummy", "mpy", "mlx", "mlyy", "mlsy", "mpyy", "cumsy", "mly", "aumsy", "mpx", "uminumsy", "aumy", "umsy", "aummy", "cumry", "umbsy", "umry", "cumy", "umbmy", "umby", "umyy", "umbry", "uminumyy", "uminumy", "aumry"], "lx": ["klpx", "kly", "lly", "klmx", "lex", "slx", " lmx", "klx", "klex", "slw", "llmx", "lpx", " lpx", "llx", "lmx", " lw", "llex", " lex", "slpx", "slmx", "lw", "klw"], "ly": ["lly", "las", "mm", "lib", "ml", "dis", "ry", "xy", "li", "le", "sym", "hy", "py", "gly", "ity", "iem", "sty", "ury", "sys", "mi", "yy", "ky", "vy", "zy", "fy", "gy", "ply", "sol", "ny", "lo", "iy", "by", "shell", "lay", "ley", "ty", "y"], "uvmx": ["upmex", "uvlw", "upmw", "lupmx", "lupmy", "upmy", "uvlx", "lupmw", "luvmex", "uvmex", "luvmw", "uvmw", "uvlex", "luvmy", "umlx", "uvly", "umly", "upmx", "lupmex", "umlw", "umlex", "luvmx"], "uvmy": ["uumx", "ufmy", "uummy", "uumcy", "uumgy", "uugy", "uummx", "ufmx", "uvgy", "uvcy", "ufcy", "ufgy", "uumy", "uucy"], "src_x": ["src_ex", " src_X", " src_ex", "src_X"], "src_y": ["source_x", "source_y", "source_ny", "src_ny", "source_Y", "src_Y"], "uvsrc_x": ["uvrc_rx", "uvsrc__z", "uvsrc_z", "uvsrc_rx", "uvrc_y", "uvrc_x", "uvsrc__rx", "uvsrc__y", "uvrc_z", "uvsrc__x"], "uvsrc_y": ["uvsrc__b", "uvrc_b", "uvsrc_b", "uvrc_y", "uvrc_x", "uvsrc_py", "uvsrc__y", "uvsrc__x", "uvsrc__py", "uvrc_py"], "chroma_mx": ["chromca___x", "chromaogyx", "chromea___mx", "chroma___mx", "chroma___mk", "chroma_py", "chromA_wm", "chroma_mus", "chroma_yx", "chromca___mk", "chroma___mr", "chromea_mx", "chromaogmus", "chroma____py", "chromA__mus", "chroma__yx", "chroma_wm", "chroma___py", "chroma_mn", "chroma____x", "chromea___mn", "chromea_mn", "chroma__wm", "chroma____mx", "chroma___x", "chromca_mx", "chroma____mk", "chroma___mn", "chroma__mx", "chromA_mx", "chromA__wm", "chromaogwm", "chromA__mx", "chromca___mx", "chromca_py", "chroma_x", "chromea___mr", "chromca_x", "chromca_mk", "chroma__mus", "chromea___mk", "chromA_yx", "chroma_mk", "chromA_mus", "chromA__yx", "chromaogmx", "chromea_mr", "chromca___py", "chroma_mr", "chromea_mk"], "chroma_my": ["chroma_yy", "chroma_mi", "chromana___ni", "chromana_mie", "chromera_mid", "chroma___ni", "chromana___yy", "chroma_mys", "chroma__mi", "chromana___mie", "chromana___my", "chromapa_mys", "chromera_ny", "chromana_yy", "chroma_____mie", "chromera__mi", "chroma_____my", "chroma___yy", "chromera_my", "chromera__ny", "chromapa_gy", "chromapa_my", "chromana_ni", "chroma__mid", "chroma_gy", "chroma_____ni", "chromana_my", "chromera_mi", "chroma_ni", "chroma_mid", "chromapa_ny", "chroma___mie", "chromera__mid", "chroma_ny", "chromera__my", "chroma_mie", "chroma_____yy", "chroma__ny", "chroma__my", "chroma___my"]}}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 18833, "substitutes": {"s": ["services", "a", "hs", "ds", "cs", "states", "os", "z", "l", "t", "w", "i", "sb", "details", "events", "ses", "changes", "ins", "sq", "p", "aws", "h", "set", "is", "bs", "e", "g", "south", "sv", "rs", "gs", "sa", "S", "ss", "d", "ports", "ns", "sts", "v", "vs", "se", "ps", "sys", "js", "c", "es", "pers", "ats", "r", "sync", "comm", "fs", "less", "state", "ts", "ims", "ls", "parts", "stats", "ms", "spec", "sl", "b", "y", "its", "m"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405cr_clk_setup (ppc405cr_cpc_t *cpc)\n\n{\n\n    uint64_t VCO_out, PLL_out;\n\n    uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;\n\n    int M, D0, D1, D2;\n\n\n\n    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */\n\n    if (cpc->pllmr & 0x80000000) {\n\n        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */\n\n        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */\n\n        M = D0 * D1 * D2;\n\n        VCO_out = cpc->sysclk * M;\n\n        if (VCO_out < 400000000 || VCO_out > 800000000) {\n\n            /* PLL cannot lock */\n\n            cpc->pllmr &= ~0x80000000;\n\n            goto bypass_pll;\n\n        }\n\n        PLL_out = VCO_out / D2;\n\n    } else {\n\n        /* Bypass PLL */\n\n    bypass_pll:\n\n        M = D0;\n\n        PLL_out = cpc->sysclk * M;\n\n    }\n\n    CPU_clk = PLL_out;\n\n    if (cpc->cr1 & 0x00800000)\n\n        TMR_clk = cpc->sysclk; /* Should have a separate clock */\n\n    else\n\n        TMR_clk = CPU_clk;\n\n    PLB_clk = CPU_clk / D0;\n\n    SDRAM_clk = PLB_clk;\n\n    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;\n\n    OPB_clk = PLB_clk / D0;\n\n    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;\n\n    EXT_clk = PLB_clk / D0;\n\n    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;\n\n    UART_clk = CPU_clk / D0;\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);\n\n    /* Setup time-base clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);\n\n    /* Setup SDRAM clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);\n\n    /* Setup UART clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);\n\n}\n", "idx": 18838, "substitutes": {"cpc": ["copca", "skyc", "cpx", "cmpv", "copcache", "pircache", "cpuc", "pccache", "podpc", "podu", "cmpcin", "skycache", "cpac", " cpcs", "comppc", "plc", "cplc", "cpC", "cryptcin", "cpct", "cpt", " cprc", "arpunc", "cpcin", "compc", "cpucu", "cmpfc", " cpb", " ppk", "cmpx", "pxk", "podcache", "cpv", "pcx", "cpgc", "cpk", "podci", "pcct", "pxc", "pcg", "cptc", " cpk", "privpc", "pccs", "coppc", "ipppc", "copci", "cpcache", "copct", "compcs", "copcu", "pplc", "cmpci", "ppc", "compac", "pb", "cpn", "arppc", "cpp", "pcci", "pt", "cpcu", "capv", "privc", "pctc", "copcin", "privsec", "ippC", "pccall", "compp", " cpcu", "capcs", "ppb", "plci", "cpucache", "cpuunc", "ippc", "podcat", "capac", "cprc", "cmpg", "arpgc", "cpcat", "cpsec", "copC", "copc", "cppc", "privgc", "arpc", "plcache", "arpsec", "capp", "cpg", " cpca", "ippu", "cpunc", "pcp", "compv", "cmpc", "pcfc", "compu", "pcu", "pircin", "podC", "cryptcat", "pxrc", "pcc", " cpcache", "cmpcat", "podc", "pxcs", " cpn", "comptc", " pprc", "copx", "compn", " ppcs", "capn", "podcin", "podcall", "cmpu", "cmpct", "skyca", "pircat", " cpac", "pc", "cryptcache", " cpv", "cpca", " cpt", "plcall", "cpu", "copu", " ppc", " cplc", "cpfc", "cpcs", "copgc", "pirc", "ppt", "cmpcache", "arpcache", "capc", "compfc", "skyunc", "cryptc", "copg", "copsec", "compcin", "compcat", "arpca", "cpci", "captc", "podv", "cpb", "cpuca", "cmppc", "cpcall", "compcache"], "VCO_out": ["VCO_data", "VCo_sum", "VCo_OUT", "VCO____out", "VCo_obj", "VCO_pos", "VCO____pos", "VCo_out", "VCO_set", "VCO_err", "VCO_obj", "VCOzdata", "VOK_in", "VCOPout", "VCO_in", "Vco_sum", "VOK_err", "VCO_ne", "Vco_set", "VCo_no", "VCOPpos", "VOK_out", "VCOzin", "VCo_data", "VOK_ne", "VCO_sum", "VCo_in", "VCOzsum", "VCOzout", "VCO_no", "Vco_pos", "VCOPset", "Vco_out", "VCO_OUT", "VCOPsum", "VCO____sum", "VCO____set"], "PLL_out": ["Pll_in", "PCL_obj", "Pll__loss", "PLL__out", "PLL__Out", "PLC_int", "PLC_Out", "PLL_loss", "PLL__int", "Pll__OUT", "Pll_out", "PLC_in", "PLL__in", "PLL_int", "Pll__in", "PCL_in", "PLL_in", "PCL_int", "PCL_out", "PLL_Out", "PLC_out", "Pll__out", "PLL_ex", "PLL_OUT", "PLL__OUT", "Pll_loss", "Pll_ex", "Pll_OUT", "PLL__loss", "PLL_obj"], "CPU_clk": ["CPU_cleak", "CPU_clek", "CPU_clK", "CPU_____clak", "CPU_declka", "CPU_chak", "CPU_____clik", "CPU_declk", "CPU_plks", "CPU_cltk", "CPU_cletk", "CPU_Clk", "CPU_glq", "CPU_____cleak", "CPU_ClK", "CPU_blck", "CPU_CLK", "CPU_declks", "CPU_CLek", "CPU_____cltk", "CPU_plak", "CPU_slikk", "CPU_plck", "CPU_clikk", "CPU_chikk", "CPU_____cletk", "CPU_Clz", "CPU_CLka", "CPU_____cleik", "CPU_clks", "CPU_slak", "CPU_flak", "CPU_glk", "CPU_CLk", "CPU_Clek", "CPU_chtk", "CPU_declck", "CPU_chek", "CPU_clik", "CPU_sltk", "CPU_slk", "CPU_clz", "CPU_____clek", "CPU_plk", "CPU_synK", "CPU_chK", "CPU_CLz", "CPU_plka", "CPU_plz", "CPU_clck", "CPU_plq", "CPU_slek", "CPU_clq", "CPU_plek", "CPU_synikk", "CPU_blq", "CPU_flck", "CPU_glck", "CPU_synek", "CPU_declz", "CPU_flk", "CPU_chk", "CPU_slK", "CPU_synk", "CPU_plK", "CPU_clak", "CPU_flks", "CPU_CLck", "CPU_cleik", "CPU_slik", "CPU_declak", "CPU_blk", "CPU_clka", "CPU_chik", "CPU_____clk"], "TMR_clk": ["TMR_blck", "TMR_glak", "TMR_shck", "TMR_Clek", "TMR_clq", "TMR_aclik", "TMR_plck", "TMR_glk", "TMR_plik", "TMR_cliker", "TMR_colak", "TMR_Clck", "TMR_plk", "TMR_fullk", "TMR_blk", "TMR_Cln", "TMR_Clk", "TMR_clak", "TMR_plq", "TMR_gliker", "TMR_lck", "TMR_coliker", "TMR_blek", "TMR_clik", "TMR_shik", "TMR_colk", "TMR_fullak", "TMR_bln", "TMR_fulliker", "TMR_aclk", "TMR_glz", "TMR_clek", "TMR_shq", "TMR_aclq", "TMR_lk", "TMR_aclck", "TMR_fullz", "TMR_colz", "TMR_clz", "TMR_lek", "TMR_shk", "TMR_clck", "TMR_ln", "TMR_cln"], "SDRAM_clk": ["SDRAM_plk", "SDRAM_Clek", "SDRAM_Clz", "SDRAM_glek", "SDRAM_plck", "SDRAM_lck", "SDRAM_clz", "SDRAM_glk", "SDRAM_slk", "SDRAM_clck", "SDRAM_flke", "SDRAM_plek", "SDRAM_Clk", "SDRAM_glke", "SDRAM_clK", "SDRAM_flK", "SDRAM_slke", "SDRAM_clke", "SDRAM_lek", "SDRAM_Clck", "SDRAM_flk", "SDRAM_flek", "SDRAM_lz", "SDRAM_lk", "SDRAM_slek", "SDRAM_slK", "SDRAM_plz", "SDRAM_clek", "SDRAM_glK"], "PLB_clk": ["PLB_colark", "PLB_lickk", "PLB_sclark", "PLB_flk", "PLB_nlkk", "PLB_sclk", "PLB_clke", "PLB______colk", "PLB_clock", "PLB_clkk", "PLB_scltk", "PLB_hlkid", "PLB_colck", "PLB_classke", "PLB_cltk", "PLB______clark", "PLB______coltk", "PLB_plck", "PLB_mlkt", "PLB_plock", "PLB_deckt", "PLB_hlkk", "PLB_clark", "PLB_classk", "PLB_deck", "PLB_plK", "PLB_colk", "PLB_pltk", "PLB_mltk", "PLB_plkk", "PLB_nlK", "PLB_nlck", "PLB_plke", "PLB_hlck", "PLB______cltk", "PLB_flck", "PLB_mlck", "PLB_mlke", "PLB_flK", "PLB_plark", "PLB_nlk", "PLB_flkk", "PLB______colck", "PLB_classck", "PLB______colark", "PLB_decck", "PLB_classock", "PLB_clK", "PLB_coltk", "PLB_clkid", "PLB_lick", "PLB_licck", "PLB______clk", "PLB_sclck", "PLB_plk", "PLB_plkid", "PLB______clck", "PLB_hlk", "PLB_lickid", "PLB_clck", "PLB_mlk", "PLB_clkt", "PLB_mlock", "PLB_plkt", "PLB_dectk"], "OPB_clk": ["OPB_clkk", "OPB_rlk", "OPB_lick", "OPB_splark", "OPB_blark", "OPB_deck", "OPB_blck", "OPB_splek", "OPB_rlark", "OPB_splck", "OPB_ckkh", "OPB_blk", "OPB_lickk", "OPB_clek", "OPB_lictk", "OPB_splk", "OPB_rlek", "OPB_ckk", "OPB_cktk", "OPB_lickh", "OPB_ckkk", "OPB_rlck", "OPB_deckh", "OPB_deckk", "OPB_clkh", "OPB_clark", "OPB_cltk", "OPB_clck", "OPB_dectk", "OPB_blek"], "EXT_clk": ["EXT_slk", "EXT_clg", "EXT_blk", "EXT_mlkl", "EXT_slke", "EXT_CLg", "EXT_clak", "EXT_plk", "EXT_plg", "EXT_clck", "EXT_slck", "EXT_plkl", "EXT_slak", "EXT_CLk", "EXT_blak", "EXT_plck", "EXT_clkl", "EXT_toolk", "EXT_toolke", "EXT_toolak", "EXT_mlg", "EXT_mlk", "EXT_blck", "EXT_blke", "EXT_clke", "EXT_mlck", "EXT_CLck", "EXT_toolck", "EXT_CLkl"], "UART_clk": ["UART_____clk", "UART_blk", "UART_____clj", "UART_clj", "UART_plak", "UART_sclj", "UART_plp", "UART_____scln", "UART_____sclak", "UART_sclk", "UART_clck", "UART_Cln", "UART_Clak", "UART_sclak", "UART_____clak", "UART_klck", "UART_blck", "UART_plj", "UART_kln", "UART_Clj", "UART_Clk", "UART_____sclk", "UART_klp", "UART_clp", "UART_____sclj", "UART_klk", "UART_plk", "UART_bln", "UART_blp", "UART_clak", "UART_pln", "UART_plck", "UART_cln", "UART_scln", "UART_____cln"], "M": ["MP", "AM", "DM", " CM", "MU", "MH", "RM", "NM", "MC", "TM", "MO", "I", "S", "G", "J", "MX", "MD", "U", "PM", "LM", "H", "MI", "B", "BM", "MA", "CM", "MT", "L", "V", "D", "C", "N", "MS", "MR", "R", "MN", "VM", " mM", " m", "MAN", "K", "MM", "P", "F", "MIT", "T", "m"], "D0": ["D3", "Do1", "D50", "DOZero", "P0", "Date0", "Mee", "P25", "DD25", "DD2", "Size0", "DD1", "d0", "Sizeee", "Do2", "U780", "DO10", "DI15", "Do780", "Do255", "Dee", "P50", "DINo", "M50", "D780", "Do4", "Date8", " DValue", "DI6", "DInfo", " D9", "D10", "DIValue", " D4", "D4", "DI0", " D780", "DNo", "DoZero", "U0", "D15", "M0", "d1", "D255", "DValue", "DONo", "DO15", " DNo", " D10", " DZero", "DDee", " D3", "D9", "D8", "Size3", "M3", "Do0", "P3", "M1", "d6", "DD6", "DZero", "DI10", " Dee", "DO0", "DDInfo", "DO255", "PInfo", "Doee", "U8", "d4", "dValue", "Size780", "P2", " D50", " D255", "DIt", " D8", "d2", " D6", " DInfo", "PNo", "P6", "M9", "DDNo", "DateIt", " D15", "DD0", "M2", " D25", "P1", "UIt", "Do3", "D6", " DIt", "DD9", "Date780", "D25"], "D1": ["V7", " DOne", "P2", "DOne", "Q1", "DDOne", "V1", "D7", "POne", " D001", "d2", "D01", "V001", " D9", "M7", "D9", "P4", "DD4", "Q7", " D4", "V9", "D4", "DD2", "DD1", " D01", "M1", "d1", "M2", "d01", " D7", "P1", "D001", "Q9", "d7", "M01", "Q001"], "D2": ["Do6", "d3", "Do22", "S0", "D3", "Do10", "P2", " D10", "D20", "d20", "d22", "d2", " D6", "d256", "P0", "D10", " D3", "D22", "DD2", "Do0", "d0", "D256", "Do20", "M0", " D20", "d6", "DD6", "M1", "M02", "Do2", "D02", "S1", "M2", "S02", "d10", "DD256", "P1", "DD3", "Do3", "D6", "S2", " D256", "P02", " D22"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (addr != 2 || size != 1) {\n\n        return ((uint64_t)1 << (size * 8)) - 1;\n\n    }\n\n    return ide_status_read(cmd646bar->bus, addr + 2);\n\n}\n", "idx": 18853, "substitutes": {"opaque": ["Opaque", "opasus", " Opesh", "oacity", "opsasus", " opatile", "withaque", "oatile", "opaques", "opatile", "opsesh", " Opaques", "oaque", "opsaque", "Opaques", "ooch", "opoch", "Opasus", "withoch", "opsaques", " Opasus", "opesh", "Opesh", " opoch", " opacity", " Opaque", "opacity", "withatile", "withacity"], "addr": ["offset", "pos", "work", "here", "loc", "np", "arr", "ord", "pad", "tx", "var", "at", "ctx", "ar", "adr", "arg", "handle", "alloc", " address", "ad", "address", "seek", "off", "ock", "inter", "ptr", "attr", "dr", "add", "ay", "obj", "msg", "cmd", "id", " arg", "arity", "ref", "ash", "oad", "sha", "align", "act", "now", "aj", "alt", "alias", "dh", "coord", "state", "ack", "Address", "src", "ix", "gate", "err"], "size": ["offset", "l", "si", "z", "args", "style", "weight", "sh", "max", "sp", "num", "st", "shift", "scale", "sum", "e", "count", "sy", "shape", "command", "length", "iz", "name", "address", "sec", "send", "news", "se", "sn", "fee", "msg", "ize", "storage", "body", "scope", "message", "number", "n", "align", "space", "Size", "notice", "SIZE", "shell", "len", "year", "small", "code", "type"], "cmd646bar": ["cmd866serv", " cmd736serv", " cmd736bar", "cmd649serv", "cmd866car", "cmd649bar", " cmd645dec", "cmd616bar", "cmd616deb", "cmd646dec", "cmd645bar", "cmd866bar", "cmd645dec", " cmd645bar", "cmd736deb", "cmd736be", "cmd616be", " cmd645be", "cmd736dec", " cmd645deb", "cmd616dec", " cmd736car", " cmd646dec", "cmd736serv", "cmd646car", "cmd646deb", "cmd649car", "cmd736bar", "cmd646serv", "cmd645deb", "cmd645be", " cmd646deb", " cmd646be", "cmd736car", " cmd646serv", "cmd646be", " cmd646car"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t hpet_ram_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    HPETState *s = opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > s->num_timers) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            return timer->config;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            return timer->config >> 32;\n\n        case HPET_TN_CMP: // comparator register\n\n            return timer->cmp;\n\n        case HPET_TN_CMP + 4:\n\n            return timer->cmp >> 32;\n\n        case HPET_TN_ROUTE:\n\n            return timer->fsb;\n\n        case HPET_TN_ROUTE + 4:\n\n            return timer->fsb >> 32;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return s->capability;\n\n        case HPET_PERIOD:\n\n            return s->capability >> 32;\n\n        case HPET_CFG:\n\n            return s->config;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl\\n\");\n\n            return 0;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick >> 32;\n\n        case HPET_STATUS:\n\n            return s->isr;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 18892, "substitutes": {"opaque": ["oplface", "Opaque", " opque", "Oposter", "oposter", "opass", "opaques", "ipface", " opaques", "compque", "Opque", "Opaques", "Opass", "oploster", "oplaque", "Opacity", " opass", "Opface", "ipacity", "compaque", "opface", "oplacity", "iposter", "opacity", "opque", "compass", "ipaque", "compaques"], "addr": ["offset", "pos", "mem", "init", "loc", "z", "arr", "ord", "args", "pad", "i", "tx", "max", "var", "asm", "hash", "ctx", "kt", "gz", "adr", "map", "prefix", "node", "mt", "alloc", "name", "ad", "address", "handle", "bytes", "start", "inter", "ptr", "obj", "dr", "add", "attr", "hw", "data", "cmd", "msg", "pkg", "ref", "r", "host", "oad", "align", "now", "act", "n", "alt", "alias", "dh", "state", "arch", "oa", "x", "block", "ack", "Address", "coord", "len", "arp", "src", "ix", "gate"], "size": ["offset", "mem", "z", "args", "ffff", "sp", "num", "ctx", "count", "length", "name", "m", "address", "bytes", "start", "area", "data", "ize", "id", "cmp", "n", "align", "Size", "SIZE", "len", "type"], "s": ["bits", "ess", "ing", "ches", "vals", "g", "rs", "vs", "se", "obj", "sets", "sys", "ants", "c", "es", "comm", "fs", "er", "serv", "sl", "spec", "os", "ops", "or", "t", "sp", "sm", "qs", "sym", "S", "ss", "d", "sts", "v", "ments", "ps", "service", "erences", "n", "o", "ts", "ls", "parts", "stats", "ed", "eds", "services", "ies", "a", "ds", "sam", "l", "terms", "sb", "as", "changes", "ses", "als", "sv", "sw", "itions", "js", "state", "an", "b", "hs", "ists", "p", "ins", "store", "sq", "ers", "aws", "h", "ands", "is", "bs", "gs", "ports", "ns", "ations", "ties", "aps", "sports", "ats", "less", "actions", "ims", "sim", "ms", "its"], "cur_tick": ["cur_event", "curJwindow", "curjcycle", "cur____time", " cur_poll", "cur_cycle", "cur__poll", " cur_check", "curpttick", "cur_stick", "curJick", " cur_pot", "curJstick", "cur_time", "cur_pot", " cur_cycle", " cur_ick", " cur_icker", "curpttoken", "cur___window", "cur__icker", "curttoken", "ctr_tick", "cur____token", "curptick", "curmmick", "curtcycle", "ctr_cycle", " cur_lock", " cur_stick", "curmltick", "curmmevent", " cur_event", "ctr_token", "cur_check", "curjtick", "cur_poll", "curtevent", "curmltoken", "cur_ick", "curJtime", " cur_pick", "curmmpoll", " cur_window", "cur__ick", "ctr_ick", "cur_token", "curmlick", "curmmtoken", "cur__tick", " cur_token", " cur_time", "curmmtick", "cur___ick", "curmlpot", "curjpoll", "cur____ick", "cur_lock", "curtick", "curptpot", "cur_window", "curttick", "cur_icker", "cur__cycle", "curJtick", "cur____tick", "curJtoken", "cur_pick", "cur___tick", "cur___stick", "curmmcheck", "curjick"], "index": ["init", "offset", "pos", "check", "here", "loc", "error", "location", "seed", "can", "slice", "i", "num", "timeout", "test", "hash", "ctx", "zero", "find", "count", "lock", "point", "shape", "link", "Index", "length", "node", "command", "address", "position", "db", "seek", "label", "axis", "iter", "insert", "order", "range", "ind", "id", "ref", "height", "val", "context", "act", "key", "vector", "x", "info", "block", "open", "row", "no", "scan", "ix", "code", "ex", "status", "dd", "gate", "loop", "type"], "timer": ["temp", "tim", "icker", "duration", "tc", "server", "ramer", "t", "byter", "ter", "tom", "dt", "imer", "menu", "timeout", "tick", "term", "test", "cell", "tar", "handler", "walker", "program", "tool", "task", "tem", "Timer", "actor", "cker", "mr", "header", "iler", "atom", "writer", "loader", "variable", "thread", "clock", "iter", "trigger", "parser", "peer", "reader", "time", "driver", "monitor", "latest", "wrapper", "processor", "recorded", "runner", "cer", "ger", "er", "finder", "state", "tm", "txt", "later", "sim", "function", "player", "buffer", "meter", "browser", "transfer", "taker", "event", "counter", "worker", "type"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,\n\n                            uint16_t vendor, uint16_t device,\n\n                            uint16_t class_code, uint8_t pif)\n\n{\n\n    uint8_t *config;\n\n    uint32_t size;\n\n\n\n    proxy->vdev = vdev;\n\n\n\n    config = proxy->pci_dev.config;\n\n    pci_config_set_vendor_id(config, vendor);\n\n    pci_config_set_device_id(config, device);\n\n\n\n    config[0x08] = VIRTIO_PCI_ABI_VERSION;\n\n\n\n    config[0x09] = pif;\n\n    pci_config_set_class(config, class_code);\n\n\n\n    config[0x2c] = vendor & 0xFF;\n\n    config[0x2d] = (vendor >> 8) & 0xFF;\n\n    config[0x2e] = vdev->device_id & 0xFF;\n\n    config[0x2f] = (vdev->device_id >> 8) & 0xFF;\n\n\n\n    config[0x3d] = 1;\n\n\n\n    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {\n\n        pci_register_bar(&proxy->pci_dev, 1,\n\n                         msix_bar_size(&proxy->pci_dev),\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                         msix_mmio_map);\n\n    } else\n\n        vdev->nvectors = 0;\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n\n\n    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;\n\n    if (size & (size-1))\n\n        size = 1 << qemu_fls(size);\n\n\n\n    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,\n\n                           virtio_map);\n\n\n\n    if (!kvm_has_many_ioeventfds()) {\n\n        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;\n\n    }\n\n\n\n    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);\n\n    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;\n\n    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;\n\n    proxy->host_features = vdev->get_features(vdev, proxy->host_features);\n\n}\n", "idx": 18893, "substitutes": {"proxy": ["connection", "server", "clone", "linux", "roxy", "flag", "phy", "ping", "p", "client", "secure", "report", "mail", "query", "play", "port", "remote", "lock", "cas", "map", "copy", "native", "link", "mos", "profile", "py", "engine", "primary", "pro", "web", "force", "socket", "reference", "push", "Proxy", "friend", "ip", "http", "service", "manager", "reply", "pi", "wrapper", "mi", "target", "master", "pool", "sync", "version", "embed", "connect", "project", "gp", "pse", "alias", "cache", "x", "request", "module", "reverse", "prime", "view", "php", "shadow", "pin", "super", "browser", "slave", "show", "gate"], "vdev": ["wdes", "uvdoc", "vtcomment", " vdoc", "nvdev", "vmDev", " vtx", " vDEV", " vdb", "vtdev", "wdevice", " vserv", "vardist", "pdata", "uvdev", "uvgo", "tdef", " vdes", "vDEV", "hdef", " vcmd", "hconn", " vev", "pdev", "tdev", "hDEV", "vardev", " vdist", "vev", "vdoc", "hdevice", "pdd", "vdevice", "svdev", "nvval", "vval", "vgo", "vtdoc", "hcam", " vdd", "vdes", "vccmd", "vtgo", "pdb", " vmem", "hDev", "vardd", "vcDEV", "wdev", "vardevice", "vctx", "svdef", "vdb", "vtx", "tconn", "pev", "vmdevice", "vcdevice", "vdata", "avserv", "vmem", "vcmd", " vDev", "vdist", "hdev", "vdef", "pdist", "wval", "vardata", "hcmd", " vcomment", "vmcam", "avdev", " vcam", "vserv", "pserv", "vcam", "vcdist", "nvev", "vmdev", "vDev", " vdevice", "avdb", "vdd", "tdevice", " vdata", "uvcomment", "vartx", " vgo", "nvdes", "wdef", "wconn", " vdef", "vcdev", "wev", "vcomment", "svmem", "hmem", " vval", "avdist", "svdevice", "vconn", "varev"], "vendor": ["vmirt", "woid", "birus", "ivirt", "wistor", "lendor", "chendor", "vmender", " vost", "vmendor", "bost", "vender", " virus", "birt", "evirus", "wirus", "voice", "svirt", "virt", "avoice", "chistor", "svendor", "chirt", "avendor", "wendor", "bendor", "ivendor", "evistor", "loice", "avender", "ivirus", "lender", "vistor", "ivost", "evendor", "avirt", "vmoice", "ivistor", "evoid", "svistor", "virus", "vost", "avoid", "lirt", " virt", "svirus", "avirus", "chirus", "avistor"], "device": ["channel", "location", "pipe", "component", "phy", "controller", "interface", "port", "remote", "feature", "power", "family", "volume", "DEV", "model", "drive", "disk", "address", "image", "pod", "di", "serial", "hid", "ve", "instance", "product", "dev", "scope", "date", "project", "directory", "package", "module", "network", "Device", "deck", "devices", "slave", "version", "event", "class"], "class_code": ["classalmode", " class_codes", "class_rule", "classNamecode", "classabilitycodes", " class_rule", "classalcode", "classalcodes", "classabilitycode", "classNameid", "class_cod", "classityid", " class_id", " class_mode", "class_mode", "classityCode", "class_codes", "class_id", "classitycode", "classabilitymode", "class_Code", "classNameCode", "classitycod", "classabilityrule", "classNamecod", " class_Code", " class_cod", "classalrule"], "pif": ["pifer", "pIF", "phpitch", " piff", "ppitch", "ppif", "ciff", "npifer", "piff", "pifi", "cifi", "cif", "cpiff", " pifi", "pitch", "npIF", "cpIF", "ppIF", "cpifi", "npif", " pIF", "ppifer", "cIF", "phpifer", "phpif", "cpif", "npitch", "phpIF"], "config": ["temp", "loc", "mount", "length", "c", "admin", "common", "options", "cond", "dc", "diff", "cache", "attribute", "FIG", "chain", "exec", "spec", "cap", "form", "t", "settings", "desc", "adj", "list", "input", "app", "port", "set", "output", "command", "ct", "content", "etc", "mask", "add", "json", "access", "condition", "complete", "code", "sc", "init", "ctl", "comment", "capt", "interface", "load", "other", "bc", "address", "all", "capacity", "storage", "att", "cfg", "info", "rc", "text", "bitcoin", "debug", "con", "args", "change", "map", "empty", "reason", "control", "cont", "conn", "data", "cmd", "ext", "fig", "table", "connect", "Config", "ac", "search", "lag", "conf"], "size": ["grow", "index", "zone", "z", "l", "window", "settings", "sh", "max", "p", "total", "sp", "set", "shift", "scale", "sum", "power", "count", "g", "zero", "south", "empty", "global", "shape", "length", "send", "name", "iz", "scroll", "limit", "capacity", "fee", "c", "ize", "storage", "scope", "height", "n", "number", "space", "Size", "state", "SIZE", "cache", "len", "city", "s", "large", "small", "code", "sc", "mode", "type"]}}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static int usb_device_add(const char *devname, int is_hotplug)\n\n{\n\n    const char *p;\n\n    USBDevice *dev;\n\n\n\n    if (!free_usb_ports)\n\n        return -1;\n\n\n\n    if (strstart(devname, \"host:\", &p)) {\n\n        dev = usb_host_device_open(p);\n\n    } else if (!strcmp(devname, \"mouse\")) {\n\n        dev = usb_mouse_init();\n\n    } else if (!strcmp(devname, \"tablet\")) {\n\n        dev = usb_tablet_init();\n\n    } else if (!strcmp(devname, \"keyboard\")) {\n\n        dev = usb_keyboard_init();\n\n    } else if (strstart(devname, \"disk:\", &p)) {\n\n        BlockDriverState *bs;\n\n\n\n        dev = usb_msd_init(p, &bs);\n\n        if (!dev)\n\n            return -1;\n\n        if (bdrv_key_required(bs)) {\n\n            autostart = 0;\n\n            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {\n\n                dev->handle_destroy(dev);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (!strcmp(devname, \"wacom-tablet\")) {\n\n        dev = usb_wacom_init();\n\n    } else if (strstart(devname, \"serial:\", &p)) {\n\n        dev = usb_serial_init(p);\n\n#ifdef CONFIG_BRLAPI\n\n    } else if (!strcmp(devname, \"braille\")) {\n\n        dev = usb_baum_init();\n\n#endif\n\n    } else if (strstart(devname, \"net:\", &p)) {\n\n        int nic = nb_nics;\n\n\n\n        if (net_client_init(\"nic\", p) < 0)\n\n            return -1;\n\n        nd_table[nic].model = \"usb\";\n\n        dev = usb_net_init(&nd_table[nic]);\n\n    } else if (!strcmp(devname, \"bt\") || strstart(devname, \"bt:\", &p)) {\n\n        dev = usb_bt_init(devname[2] ? hci_init(p) :\n\n                        bt_new_hci(qemu_find_bt_vlan(0)));\n\n    } else {\n\n        return -1;\n\n    }\n\n    if (!dev)\n\n        return -1;\n\n\n\n    return usb_device_add_dev(dev);\n\n}\n", "idx": 18915, "substitutes": {"devname": ["developrun", "formword", "evname", "devdefault", "evline", "padnames", "testno", "devno", "devcase", "procline", "testcase", "procName", "attrName", "devline", "evnames", "developname", "attrname", "avcase", "varName", " devstart", "divrun", "evName", "devName", "varname", "evcase", "padName", "devicenames", "debugsize", "defnames", "divnames", "teststart", "devicerun", "formstart", " devword", "avname", "devicename", "formsize", "defdefault", "defword", "devcall", "debugword", "developnames", "devnames", "avno", "developdefault", "privstart", "devword", "privname", "developstart", "devma", "evno", "developno", "defstart", "avstart", "developword", "evrun", "procstart", "procname", "attrcall", "evNAME", "evcall", " devnames", "debugName", "divstart", " devName", "debugstart", "varrun", "devNAME", "padname", "deviceno", "debugma", "developcall", "devsize", "defname", "divword", "privName", "deviceword", "attrma", "deviceName", "evstart", "testname", "evword", "privline", " devsize", "formname", "debugcall", "debugname", "divname", " devrun", "evma", " devdefault", "padNAME", "devrun", " devNAME", " devno", "devstart", "varno", " devcall"], "is_hotplug": ["is_hotpl", "is_hotspl", "is_hotslink", "is_smartplug", "is_hardpl", "is_hotsPlug", "is_hotsplug", "is_smartpack", "is_hardPlug", "is_hotpack", "is_hardplug", "is_smartlink", "is_hardpack", "is_hotlink", "is_hotspack", "is_hardlink", "is_hotPlug"], "p": ["a", "lp", "l", "t", "w", "wp", "i", "pp", "sp", "ping", "app", "h", "q", "pid", "bp", "port", "ctx", "pc", "e", "g", "vp", "prop", "tp", "d", "v", "pb", "k", "ip", "ps", "pm", "c", "pi", "pt", "pkg", "j", "pers", "r", "jp", "post", "n", "pat", "path", "pre", "par", "pl", "pa", "pn", "cp", "php", "f", "it", "fp", "part", "P", "pe", "b", "y", "ap", "m"], "dev": ["pad", "test", "hd", "av", "development", "cam", "cast", "ad", "pro", "di", "develop", "cho", "gu", "jump", "dem", "dd", "mem", "form", "de", "sh", "var", "app", "port", "device", "dat", "usb", "link", "vc", "d", "v", "hw", "pi", "ent", "ver", "devices", "bus", "err", "nt", "res", "w", "comment", "proc", "th", "dis", "enc", "query", "buf", "DEV", "normal", "prop", "tr", "disk", "bd", "des", "alloc", "ch", "sw", "serial", "det", "att", "ev", "draw", "def", "raw", "block", "vo", "go", "scan", "nav", "od", "dn", "debug", "adv", "stable", "eng", "ach", "dep", "Dev", "h", "util", "out", "off", "fin", "db", "push", "ve", "sd", "conn", "data", "cmd", "val", "br"], "bs": ["bm", "ds", "cs", "lbs", "bed", "b", "bits", "its", "sb", "BS", "ses", "ubs", "bh", "bp", "ks", "qs", "is", "rs", "gs", "ss", "bd", "bc", "ns", "vs", "pb", "bos", "ps", "iss", "js", "gb", "obs", "cks", "fs", "bi", "ts", "cb", "ls", "aos", "ms", "us", "bes", "bis", "bus"]}}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    SCHIB schib;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {\n\n        return;\n\n    }\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_schib_valid(&schib)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"msch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_msch(sch, &schib);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 18931, "substitutes": {"cpu": ["mem", "np", "nic", "t", "linux", "ck", "uu", "p", "proc", "ork", "ctx", "pc", "core", "gc", "cam", "hog", "node", "pu", "onet", "tp", "stat", "alloc", "cli", "thread", "hw", "vm", "clock", "obj", "apache", "sys", "conn", "c", "nu", "bench", "target", "pool", "prof", "jp", "processor", "runner", "gpu", "cu", "arch", "nc", "net", "cp", "CPU", "boot", "exec", "phys", "process"], "reg1": ["register1", "reg4", "reg0", "register2", "Reg4", "Reg0", "reg2", "REG2", "Reg1", "REG0", "REG1", "REG4", " reg0", "register0", " reg2", "Reg2", "register4"], "ipb": [" sipbp", "IPa", " IPb", "ipa", " sipB", " ipfb", " ipB", " IPa", " clipb", " ipa", "ipB", " sipb", " clipfb", " IPbp", "ipbp", "IPfb", " IPB", " sipa", " ipbp", "ipfb", " clipa", "IPb"], "cssid": ["cmsname", "apside", "csid", "catside", "cside", "apsolid", "cssify", "ssd", "apsid", "ssify", "csside", "sside", "cmsd", "cssolid", "cssname", "csify", "ssname", "catsid", "apsuid", "jsolid", "cssd", "jsid", "icsd", "icsid", "cssID", "icsify", "ssolid", "csuid", "csolid", "rssname", "csd", "cmsid", "cssuid", "jside", "cmsID", "rssid", "rssd", "ssID", "rssID", "jsuid", "catsolid"], "ssid": ["csid", "ksid", "rssit", "ossId", "cssida", "cside", "rssId", "kside", "esside", "rssin", "ksit", "wspid", "sside", "csside", "osside", "ossit", "essit", "ksId", " sside", "ssuid", "essId", " ssuid", "wsida", "ossid", " ssin", "csspid", "ksida", "essid", "csit", "wsid", "rssuid", "wside", "cssuid", "rssid", "kspid", "cssin", "sspid", "csId", "ssida", "ssId", "rsside", "ssin", "ssit"], "schid": ["scid", "orcid", "scpid", "orcib", " schident", "khident", "hashid", " schpid", "chid", "ssit", "khid", "khpid", "scident", "schip", "schit", "scheib", "skib", " schoid", "scoid", "hashib", "scheip", "ssib", "cssib", "skoid", "chit", "orcit", "ssip", "orcide", "hashoid", "cssit", "skid", "schident", "scheide", "khoid", "schpid", "choid", "schide", "scheit", "cssip", "scheid", "chide", "chib", "schoid"], "m": ["bm", "mem", "rm", "man", "l", "perm", "t", "imm", "i", "mm", "p", "md", "mc", "h", "sm", "g", "mr", "mn", "mt", "mat", "d", "v", "vm", "mi", "c", "id", "M", "dm", "r", "cm", "n", "module", "nm", "tm", "s", "gm", "mid", "mut", "ms", "f", "b", "middle"], "sch": ["sc", "squ", "hs", "cs", "sky", "chu", "shop", "sg", "hess", "sk", "sh", "kh", "ach", "sp", "ich", "mc", "isc", "hz", "sm", "kr", "sym", "sy", "orsche", "Sch", "ss", "cht", "ch", "her", "sw", "isch", "soc", "hou", "ksh", "sd", "chan", "css", "cr", "mk", "https", "cfg", "hed", "sol", "sche", "ssl", "sl", "ssh"], "schib": ["sslIB", "scid", "scheIB", "schtab", "scib", "sclib", "skim", "schetab", "sktab", "scheig", "skig", "khim", "scibl", "scheib", "skib", "chlib", " schlib", "scheim", "sslig", "skibl", "schlib", "khig", "khib", "schIB", "sklib", "scIB", " schIB", "schim", "skIB", "chig", "khtab", "schibl", "chIB", "skid", "schig", "schelib", "sslib", "scheid", "scig", "chib", "sslibl"], "addr": ["mem", "a", "offset", "eth", " ip", "res", "arr", "ord", "ap", "ag", "sp", "asm", "hash", " arch", "ret", "rt", "adr", "ace", "rs", "rr", "tr", "mt", " address", "ad", "address", "attr", "ptr", "dr", "add", "ip", "iter", "order", "cmd", "nl", "id", "ref", "r", "arity", "arm", "host", "gr", "cmp", "oad", "art", "align", "aer", "ack", "Address", "rn", " ref", "rc", "arp", "ac", "url", "ix", "trans", "gate", "err"], "cc": ["ctl", "con", "cv", "cs", "tc", "ci", "ck", "bb", "cell", "isc", "mc", "ec", "PC", "erc", "ctx", "ret", "pc", "gc", "count", "cl", "cf", "cycle", "vc", "cast", "cca", "bc", "ct", "cci", "co", "cd", "k", "soc", "fee", "call", "uc", "c", "cmd", "func", "cmp", "CC", "lc", "cond", "dc", "xx", "fc", "acc", "contact", "nc", "ld", "rc", "ac", "ctr", "sc", "inc"], "env": ["next", "ten", "cv", "bean", "style", "eng", "server", "console", "window", "ter", "ei", "term", "proc", "en", "vt", "ec", "desc", "enc", "port", "ctx", "end", "eni", "enter", "ner", "te", "e", "buf", "config", "hw", "engine", "dt", "v", "ew", "ptr", "obj", "ve", "era", "vm", "ef", "esc", "conn", "order", "priv", "esp", "target", "ext", "den", "dev", "scope", "ev", "context", "et", "er", "viron", "info", "network", "ped", "nc", "net", "entry", "pe", "org", "sc", "code", "Environment", "conf", "eh", "environment"], "ar": ["ear", "au", "am", "are", "ara", "ag", "arr", "ra", "AR", "as", "var", "bar", "at", "ir", "tar", "ars", "ard", "adr", "inter", "ptr", "area", "rar", "attr", "war", "ref", "r", "mar", "arm", "dar", "art", "aer", "har", "aro", "er", "par", "car", "ro", "al", "arp", "arc", "ap"]}}
{"project": "qemu", "commit_id": "7e5f90fa3ff32ea31548666d57a78005555ecf34", "target": 1, "func": "int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,\n\n                int *is_linux)\n\n{\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    /* TODO: Implement Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto out;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 18942, "substitutes": {"filename": ["SourceFile", "png", "loc", "fn", "location", "ame", "username", "Filename", "utf", "fil", "family", "buf", "ename", "prefix", "subject", "files", "name", "nw", "jpg", "ln", "dir", "binary", "kl", "n", "path", "nil", "directory", "source", "nm", "txt", "rn", "FN", "f", "url", "fp", "src", "file"], "ep": ["ea", "eth", "np", "dp", "wp", "pipe", "pp", "dep", "p", "sp", "yp", "en", "isp", "ec", "imp", "e", "ape", "ream", "tp", "ew", "peak", "ip", "ps", "ef", "esp", "mp", "Ep", "EP", "ere", "ev", "et", "eps", "ele", "gp", "env", "lip", "cp", "eg", "eb", "pe", "fp", "ap", "ek"], "loadaddr": ["calladdress", "lpad", "loadpad", "addpad", "callpad", "callarg", "laddress", "addaddr", "larg", "addarg", "calladdr", "addaddress", "laddr", "loadaddress", "loadarg"], "is_linux": [" is_Linux", "issuccessLinux", "is_nice", " is_cpu", "issuccessnice", "Is_ubuntu", "is_windows", "is_os", "Is_nice", " is_iso", "issuccesslinux", "Is_Linux", "is_ubuntu", " is_os", " is_windows", "Is_system", "is_iso", "is_microsoft", "Is_linux", "is_Linux", "is_cpu", "issuccesssystem", "Is_microsoft", "is_system"], "fd": ["td", "pos", "fed", "ds", "raf", "fn", "form", "window", "dd", "dt", "lf", "dn", "proc", "stream", "pid", "ctx", "fr", "dat", "dl", "disk", "handle", "out", "d", "fin", "fat", "ln", "db", "pointer", "ptr", "da", "cd", "io", "socket", "sd", "ff", "dir", "func", "ind", "std", "draw", "cond", " fin", "fa", "fs", "fi", "fc", "path", "df", "bf", "FD", "cb", "open", "len", "ini", "wind", "f", "fun", "fp", " fid", "dra", "file", "fl"], "size": ["izes", "mem", "grow", "os", "z", "si", "l", "sh", "max", "sp", "gz", "set", "scale", "sum", "sy", "count", "g", "sized", "empty", "shape", "length", "step", "iz", "name", "send", "sw", "news", "area", "fee", "sn", "c", "ize", "too", "sha", "n", "now", "dim", "space", "Size", "notice", "SIZE", "len", " sizes", "no", "small", "status"], "h": ["hs", "hh", "oh", "l", "t", "hi", "sh", "p", "he", "bh", "hr", "hd", "ht", "header", "m", "d", "v", "hw", "dr", "H", "ih", "head", "hm", "c", "hp", "host", "headers", "ph", "o", "dh", "f", "ah", "hal", "b", "eh", "hl"], "hdr": ["ihstr", "hepr", "helptr", "herdr", "hdel", "hmadr", "achpr", "shvr", "helpdr", " hDR", "ohtar", "Hadr", "shdr", "shr", "phdr", "expstr", "hevr", " htr", "ihtr", "shDR", "hedr", "chadr", "ohadr", "expbr", "holder", "exptar", "hatt", "ehDR", "shmt", "Hr", "oholder", "herpart", " hder", "ohDR", "helpolder", "Hvr", "ehpart", "hmatt", "ohtr", "Hdel", "heDR", "hemt", "hoDR", "ehdr", "hadr", " hr", "ahstr", "hiDR", "headr", "htar", "hmDR", "herDR", "hheader", "hearp", "hodel", " hpart", "htr", "ihdr", " hstr", "hpr", "shadr", "hder", "helpDR", "hebr", "khr", "Hder", "achdr", "Hdr", "hivr", "ohdr", "hopart", "khDR", "Htr", "hepart", "Holder", "hr", " harp", "ehdel", " hadr", "ihheader", "phheader", " hvr", "hidr", "phstr", "hmt", "HDR", "chDR", "hertr", "chvr", "hiarp", "hpart", "ohbr", "ohder", "hodr", "ohatt", "ahdr", "shpr", "hmdr", "hDR", "hestr", "phder", "ohpart", "expdr", "Hpart", "ehvr", "ohstr", "her", "ihder", "hstr", " hbr", "shder", "Hatt", "achDR", "harp", "ahtar", "chdr", "hbr", "achmt", "hvr", "khdr", "ihr", "ahbr", "ohheader", "khder"], "data": ["rew", "error", "format", "valid", "results", "good", "aw", "base", "length", "DATA", "di", "obj", "cache", "bin", "buffer", "index", "channel", "os", "memory", "t", "result", "readable", "end", "zero", "dat", "ata", "d", "mu", "pointer", "start", "read", "dev", "n", "len", "entry", "f", "bus", "mode", "w", "name", "address", "all", "ip", "to", "def", "raw", "str", "block", " DATA", "text", "next", "pos", "window", "p", "final", "empty", "map", "padding", "done", "out", "image", "Data", "area", "id", "record", "message", "table", "extra", "file", "type"], "compressed_data": ["compressed_DATA", "compress_image", "compressed_mem", "compressed___mem", "compress_bytes", "compress_DATA", "comprypted_data", "compressed___info", "compressededDATA", "compressededwindow", "compress_data", "compressed_image", "comprypted_bytes", "compressed___data", "comprypted_mem", "comprypted_info", "compressed_info", "compress_window", "compressed_window", "compressededdata", "compressed___bytes", "compressed_bytes"], "max_bytes": ["max_errors", "tmp_caps", "maxvalbytes", "tmp_windows", "maxlexbytes", "MAX_bits", " MAX_errors", " MAXlexbps", "max____windows", " MAX_bytes", " max_bits", "tmp_sections", "tmp_bytes", "max____caps", "maxvalsections", "tmpingwindows", "tmpingsections", "maxlexbits", "max____sections", "MAX_seconds", "max_sections", " MAXlexbits", " max_lines", "maxlexerrors", " MAX_bps", "maxlypoints", "maxlyseconds", "maxingbytes", "maxingcaps", "max2bits", "maxvalwindows", " MAXlexerrors", "tmpingbytes", " MAXlexbytes", "MAX_bytes", "maxlybits", "tmpingcaps", "max_Bytes", "maxingwindows", "max_bits", "max____bytes", "max2Bytes", "maxvalcaps", " max_Bytes", "maxingsections", "MAX_points", "max_points", " MAX_bits", "max_lines", "maxlybytes", "maxlexbps", "max_seconds", "max_windows", "max2lines", "max_bps", "max2bytes", "max_caps"], "bytes": ["ies", "mem", "offset", "fields", "ds", "blocks", "bits", "flags", "total", "Bytes", "aws", "lines", "frames", "xy", "bps", "bs", "ata", "tmp", "gs", "files", "ips", "values", "pages", "address", "ns", "pointers", "tes", "loads", "body", "es", "trans", "rows", "raw", "errors", "features", "ims", "parts", "images", "len", "meta", "items", "byte", "seconds"]}}
{"project": "FFmpeg", "commit_id": "2e5195646dc5578e1751004b0ac6e787d18637e4", "target": 1, "func": "static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MPCContext *c = s->priv_data;\n\n    int ret, size, size2, curbits, cur = c->curframe;\n\n    int64_t tmp, pos;\n\n\n\n    if (c->curframe >= c->fcount)\n\n        return -1;\n\n\n\n    if(c->curframe != c->lastframe + 1){\n\n        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);\n\n        c->curbits = c->frames[c->curframe].skip;\n\n    }\n\n    c->lastframe = c->curframe;\n\n    c->curframe++;\n\n    curbits = c->curbits;\n\n    pos = url_ftell(s->pb);\n\n    tmp = get_le32(s->pb);\n\n    if(curbits <= 12){\n\n        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;\n\n    }else{\n\n        tmp = (tmp << 32) | get_le32(s->pb);\n\n        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;\n\n    }\n\n    curbits += 20;\n\n    url_fseek(s->pb, pos, SEEK_SET);\n\n\n\n    size = ((size2 + curbits + 31) & ~31) >> 3;\n\n    if(cur == c->frames_noted){\n\n        c->frames[cur].pos = pos;\n\n        c->frames[cur].size = size;\n\n        c->frames[cur].skip = curbits - 20;\n\n        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);\n\n        c->frames_noted++;\n\n    }\n\n    c->curbits = (curbits + size2) & 0x1F;\n\n\n\n    if (av_new_packet(pkt, size) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->data[0] = curbits;\n\n    pkt->data[1] = (c->curframe > c->fcount);\n\n\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pts = cur;\n\n    ret = get_buffer(s->pb, pkt->data + 4, size);\n\n    if(c->curbits)\n\n        url_fseek(s->pb, -4, SEEK_CUR);\n\n    if(ret < size){\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n    pkt->size = ret + 4;\n\n\n\n    return 0;\n\n}", "idx": 18963, "substitutes": {"s": ["ies", "hs", "ds", "cs", "os", "ops", "t", "i", "p", "sb", "ses", "ins", "changes", "sq", "ers", "aws", "als", "oss", "h", "set", "ches", "qs", "is", "bs", "e", "opens", "ares", "sv", "rs", "gs", "fts", "S", "ss", "sw", "ns", "sts", "v", "vs", "ties", "se", "ps", "sys", "sports", "js", "bis", "xs", "ants", "es", "ats", "r", "gets", "https", "fs", "ts", "ims", "ls", "stats", "us", "ms", "serv", "sc", "b", "has", "conf", "its", "m"], "pkt": ["spnt", " pdu", " pmt", "Pkg", "cpnt", "spdu", "opct", "mwk", "Packet", "spkt", "pct", "cpmt", "pingkt", "lpkg", "pmt", "proet", " pwk", "packnt", "packkt", "mck", "packdu", "spacket", "opkt", "lpkt", "cpet", "packet", " pet", "proacket", "pdu", "cpkt", "Pnt", "mkt", "lpacket", "pck", "cpct", "pet", "cpacket", "opacket", "pkg", "rkg", "paet", "met", " packet", " pck", " pkg", "macket", "opnt", "pnt", "rkt", "mkg", "pack", "packacket", "racket", "pwk", "Pkt", "pingkg", "Pet", "Pmt", " pct", "pakt", "pingnt", "prokt", "pinget", "paacket", "lpwk", "prokg", " pnt"], "c": ["con", "cv", "cs", "ic", "tc", "can", "ca", "t", "ci", "i", "p", "mc", "ec", "cn", "enc", "ctx", "unc", "pc", "gc", "count", "g", "cur", "cam", "cf", "config", "vc", "comments", "ct", "cc", "bc", "conv", "co", "v", "etc", "cd", "cont", "uc", "cr", "r", "cmp", "cal", "lc", "cm", "dc", "C", "coll", "fc", "ce", "cu", "cache", "nc", "anc", "xc", "com", "cp", "rc", "ac", "f", "abc", "chain", "comp", "sc", "arc", "conf", "col", "m"], "ret": ["mem", "res", "nt", "t", "back", "total", "opt", "ter", "xt", "ll", "rt", "buf", "tn", "mt", "out", "conv", "v", " Ret", "RET", "rev", "re", "ext", "val", "et", "rets", "alt", "txt", "x", "len", "resp", "it", "gt", "elt", "status", "err", "Ret"], "size": ["z", "format", "score", "shift", "scale", "length", "news", "obj", "speed", "number", "space", "fp", "mem", "offset", "sh", "max", "sp", "timeout", "set", "gz", "zero", "uint", "sum", "shape", "_", "limit", "fee", "sn", "msg", "skip", "n", "len", "small", "total", "num", "send", "name", "sw", "fat", "storage", "body", "height", "cmp", "Size", "notice", "SIZE", "txt", "no", "sent", "pieces", "count", "empty", "bytes", "area", "cont", "data", "ize", "new", "message", "dim", "package", "loss", "type"], "size2": ["size1", "size02", " sizetwo", " size102", "length02", " size02", "sized2", "size4", "speed102", "SIZE4", "score4", "SIZE02", "size3", "timeouttwo", "speed2", "length3", "score52", "SIZE52", " size4", "sizedtwo", "length2", "ize2", "ize02", "size5", "size102", "SIZE3", " size1", " size5", "speed5", "score2", "timeout2", "ize1", "score1", "ize102", "SIZE1", "sizetwo", "size52", "SIZE2", " size52", " size3", "ize5"], "curbits": ["dcurbits", "cubitors", "curbouts", "conturbites", "cambats", "coblits", "scurbits", "bcrubbits", "crubits", "cuberits", "turbit", "curtitions", "cibits", "caudits", "acurbitors", "dcurbats", "curtits", "custerites", "dcurtinates", "bcrubats", "cibates", "cruffits", "curbitions", "bcruffitals", "dcurtabilities", "uncurditions", "uncurbinates", "curit", "decrubits", "cubits", "bcruffital", "decrubitis", "cribinates", "bcurbit", "curdbits", "cruffbits", "decurbitions", "curbit", "curbugs", "curdites", "curtinates", "bcruffits", "crubitable", "cretchats", "cobbites", "cuberital", "truffits", "curbitable", "uncurbugs", "cibitis", "curdits", "contibates", "acrobits", "decrubitions", "crobitors", "coblitals", "cambiting", "uncribits", "curtabilities", "crubugs", "coblit", "cubios", "cerbites", "cerbinates", "coblital", "decurbited", "cubats", "conturbits", "cretchitable", "curgbits", "cambites", "crubites", "uncubios", "curgits", "crobited", "caudabilities", "cobbits", "cuscats", "mribins", "uncurbios", "cubouts", "cibites", "curbited", "cubbs", "cubites", "caudites", "caudats", "bcruffit", "mribits", "cambits", "cribits", "dcurtats", "crubitions", "mribited", "scurgits", "curgites", "acrobitors", "cruffital", "uncribats", "crobites", "turbits", "curbitis", "bcurbitable", "bcurbitals", "murbins", "conturbates", "uncurbites", "curbiting", "uncubits", "scurgites", "acurbins", "curites", "truffites", "curbabilities", "uncurbits", "corbites", "cribats", "cuscits", "cobbbits", "cuscins", "cribabilities", "curtbits", "decurbitis", "uncribites", "corbit", "cobbates", "bcurbbits", "cribited", "curgiting", "murbits", "curtats", "cribins", "curbates", "bcrubitable", "caudugs", " cretchbits", "curits", "dcurbinates", "uncurbitions", "murbited", "uncurbats", "curgitions", "acrobats", "uncribugs", "curbites", "cubins", "cruffitals", "cribbits", "bcurbital", "curditions", "dcurtits", "decurbits", "corbits", "cerbios", "cribites", "curgates", "crobins", "crobats", "truffit", "uncurdites", "curbital", "scurbats", "truffbits", "uncurdbits", "acurbats", " cretchouts", "dcurbabilities", "acurbits", "curbins", "cibitions", " curbbs", "cuscitors", "bcrubits", "custerinates", "corbbits", "cruffites", "acrobins", "curbats", "contibites", "curbbits", "cerbits", "uncubinates", "contibitions", " curbbits", "scurbites", "curbbs", "crobits", "bcurbats", "custerios", "curbios", "curtitis", "cubited", "scurbiting", "caudinates", "cretchouts", "cibited", "cretchits", "turbbits", "curtited", "turbites", "cretchbs", "uncubites", "curgouts", " cretchits", "uncurdits", "curbinates", "curgats", "mribites", "cubinates", "cretchbits", "cobbitions", " curbouts", "cribitable", "crubats", " cretchbs", "custerits", "curgbs", "bcurbits", "curbitors", "murbites", "curtites", "crubited", "cruffit", "curbitals", "cribugs", "scurgiting", "crubitis", "cuberitals", "uncurbbits", "cuberit", "cubiting", "decrubited", "crubbits", "scurgats", "cubbits", "conturbitions", "contibits"], "tmp": ["temp", "stuff", "mem", "snap", "offset", "loc", "np", "nt", " t", "perm", "tz", "t", "img", " mp", "p", "sp", "mm", "vt", "timeout", "test", "tar", "xy", " pts", "ctx", "pot", "rt", "util", "buf", "prop", "tp", "out", "mb", "uv", "etc", "v", "tf", "attr", "obj", "ptr", "bytes", "addr", "js", "mp", "msg", "pkg", "cmd", "nb", "mk", " resp", "cmp", "cache", " np", "cb", "appy", "txt", "tm", "elt", "resp", "cp", "tt", "gt", "emp", "buff", "src", "uff", "m"], "pos": ["offset", "Pos", "snap", "index", "os", "loc", "res", "pad", "pr", "p", "ping", "sp", "proc", "port", "pid", "oss", "ctx", "base", "pc", "pres", "point", "op", "prop", "position", "off", "seq", "pro", "start", "limit", "obj", "ps", "addr", "POS", "reset", "pi", "pkg", "pt", "id", "rot", "rel", "ref", "local", "val", "neg", "cmp", "tell", "cond", "top", "pl", "pose", "open", "len", "resp", "no", "rest", "mut", "part", "spec", "po", "conf", "trans"], "curframe": ["curfeature", "catchsequence", "corframe", "curpanel", "lastfeature", "corfram", "colfram", "ctrframe", "cframe", "rcframe", " curFrame", "cfeature", "lastfram", "foreframe", "lastframe", "serwindow", "curline", "serframe", " cursequence", "currentFrame", "Curline", "rcline", "curFrame", "curfram", "catchpanel", "rctrace", "lastFrame", "Cursequence", "catchframe", "currentframe", "lastsequence", "sersequence", "lastthread", "serfram", "forefram", "catchline", "priFrame", " curtrace", "Curfram", "Curpanel", "ctrfram", "cortrace", "crFrame", "ctrwindow", "prifram", "crfram", "rcfram", "cFrame", " curwindow", "priframe", "corsequence", "Curframe", "crframe", " curfram", "colframe", "currentfeature", "prithread", "curtrace", "rcpanel", "colsequence", "colFrame", "curthread", "cursequence", "foreFrame", "rcsequence", "curwindow", "crthread", "ctrsequence"], "frames_noted": ["frames_notended", "frames_tunefined", "frames_noten", "frames_Noted", "frames_tuned", "frames_Notefined", "frames_noteed", "framesoxnoteed", "frames_tune", "frames_tunended", "frames_tunied", "frames_Notied", "framesoxtune", "frames_notied", "frames_NOTe", "framesoxtuneed", "framesoxnotended", "frames_nten", "frames_tuneed", "frames_ntefined", "frames_note", "frames_NOTed", "framesoxtunended", "frames_tunen", "frames_NOTeed", "frames_notefined", "frames_naeed", "framesoxnote", "frames_ntied", "frames_naended", "frames_NOTended", "framesoxtuned", "frames_nted", "frames_naed", "framesoxnoted", "frames_Noten", "frames_nae"]}}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static void hpet_ram_writel(void *opaque, target_phys_addr_t addr,\n\n                            uint32_t value)\n\n{\n\n    int i;\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t old_val, new_val, val, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_writel at %\" PRIx64 \" = %#x\\n\", addr, value);\n\n    index = addr;\n\n    old_val = hpet_ram_readl(opaque, addr);\n\n    new_val = value;\n\n\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        DPRINTF(\"qemu: hpet_ram_writel timer_id = %#x \\n\", timer_id);\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return;\n\n        }\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CFG\\n\");\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);\n\n                timer->config = (timer->config & 0xffffffff00000000ULL) | val;\n\n                if (new_val & HPET_TN_32BIT) {\n\n                    timer->cmp = (uint32_t)timer->cmp;\n\n                    timer->period = (uint32_t)timer->period;\n\n                }\n\n                if (new_val & HPET_TIMER_TYPE_LEVEL) {\n\n                    printf(\"qemu: level-triggered hpet not supported\\n\");\n\n                    exit (-1);\n\n                }\n\n\n\n                break;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                DPRINTF(\"qemu: invalid HPET_TN_CFG+4 write\\n\");\n\n                break;\n\n            case HPET_TN_CMP: // comparator register\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP \\n\");\n\n                if (timer->config & HPET_TN_32BIT)\n\n                    new_val = (uint32_t)new_val;\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffff00000000ULL)\n\n                                  | new_val;\n\n                if (timer_is_periodic(timer)) {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffff00000000ULL)\n\n                                     | new_val;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_CMP + 4: // comparator register high order\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP + 4\\n\");\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffffULL)\n\n                                  | new_val << 32;\n\n                else {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config\n\n                                & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffffULL)\n\n                                     | new_val << 32;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_ROUTE + 4:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_ROUTE + 4\\n\");\n\n                break;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n                break;\n\n        }\n\n        return;\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return;\n\n            case HPET_CFG:\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);\n\n                s->config = (s->config & 0xffffffff00000000ULL) | val;\n\n                if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Enable main counter and interrupt generation. */\n\n                    s->hpet_offset = ticks_to_ns(s->hpet_counter)\n\n                                     - qemu_get_clock(vm_clock);\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        if ((&s->timer[i])->cmp != ~0ULL)\n\n                            hpet_set_timer(&s->timer[i]);\n\n                }\n\n                else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Halt main counter and disable interrupt generation. */\n\n                    s->hpet_counter = hpet_get_ticks();\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        hpet_del_timer(&s->timer[i]);\n\n                }\n\n                /* i8254 and RTC are disabled when HPET is in legacy mode */\n\n                if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_disable();\n\n                } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_enable();\n\n                }\n\n                break;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG+4 write \\n\");\n\n                break;\n\n            case HPET_STATUS:\n\n                /* FIXME: need to handle level-triggered interrupts */\n\n                break;\n\n            case HPET_COUNTER:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffff00000000ULL)\n\n                                  | value;\n\n               DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            case HPET_COUNTER + 4:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffffULL)\n\n                                  | (((uint64_t)value) << 32);\n\n               DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            default:\n\n               DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n               break;\n\n        }\n\n    }\n\n}\n", "idx": 18969, "substitutes": {"opaque": ["opane", "Opaque", "pane", " opque", " opatile", "OPac", "iopque", "Opane", "ipoch", "OPane", "opaques", "opatile", "compque", "OPque", "operatile", "Opque", "Opaques", "opoch", "opac", "compac", "compane", "ipque", "operque", "pque", "iopane", "ipatile", "iopaque", "compaque", " opane", " opoch", " opac", "opque", "ipaque", "paque", "operoch", "operaque", "paques", "OPaque", "iopaques"], "addr": ["mem", "offset", "pos", "init", "loc", "arr", "ord", "pad", "tx", "adj", "at", "hash", "ctx", "set", "adr", "ace", "point", "prefix", "handle", "alloc", " address", "ad", "address", "seek", "start", "hw", "attr", "ptr", "obj", "add", "ip", "iter", "inter", "conn", "sys", "data", "cmd", "pkg", "ind", "id", "ref", "r", "host", "ash", "cmp", "align", "rank", "act", "aj", "alt", "alias", "dh", "state", "coord", "x", "ack", "Address", "arp", "ix", "src", "gate"], "value": ["mem", "ue", "memory", "size", "format", "w", "VALUE", "weight", "total", "test", "port", "VAL", "initial", "padding", "length", "values", "Value", "address", "name", "unit", "v", "time", "python", "data", "json", "commit", "field", "local", "new", "current", "number", "key", "state", "bin", "buffer", "byte", "type"], "i": [" ip", " pos", " inv", " out", " e", " ii", " l", " ptr", " p", " tid", " ind", " j", "j", " mid", " arg", " conn", " resp", " offset", "x", " x", " m", " iter", " ref", " iii", " bi", " err"], "s": ["services", "hs", "ds", "sam", "os", "t", "p", "sb", "sp", "ses", "sq", "aws", "qs", "is", "sv", "rs", "gs", "S", "ss", "sw", "session", "sts", "socket", "ns", "v", "ps", "sys", "iss", "js", "spec", "fs", "ts", "ssl", "an", "sis", "serv"], "old_val": ["old___bit", "old_VAL", "oldJvalue", "old_loc", "OLD_val", "old___serv", " old_bit", "old_value", "oldJval", " old_serv", "old___value", " old_loc", " old_value", "OLD_VAL", "old___loc", "oldJloc", "OLD_value", "oldJserv", "old_serv", "old_bit", "old___val"], "new_val": ["new___bal", "NEW_vals", "new___val", "new_vals", "new67Val", "new___vals", "new___mem", "old_value", "NEW_mem", "new___len", " new_serv", "NEW_Val", " new_col", "new_value", "new___Val", "newJlen", "new67val", " new_value", "new_Val", "NEW_len", " new_Val", "newJvals", "new___serv", "old_len", "NEW_value", " new_bal", "new_col", "NEW_val", "new_mem", "new_bal", "new67col", "new_serv", "newJvalue", "old_Val", "old_vals", "new_len", "newJval", "new___value"], "val": ["mem", "bal", "Val", "loc", "res", "item", "arr", "rol", "sel", "pr", "valid", "tx", "p", "var", "slot", "test", "ctx", "VAL", "ret", "util", "vals", "pol", "buf", "aval", "v", "reg", "attr", "iv", "eval", "data", "msg", "ind", "func", "dev", "ref", "new", "cal", "cmp", "cho", "pl", "lev", "vol", "resp", "buffer", "serv", "mint", "elt", "col", "err"], "index": ["init", "offset", "pos", "loc", "sort", "error", "ord", "slice", "num", "list", "timeout", "hash", "ctx", "set", "zero", "ion", "point", "Index", "address", "position", "seek", "axis", "inter", "pointer", "iter", "ptr", "add", "order", "ind", "id", "j", "dev", "ref", "context", "key", "coord", "x", "info", "open", "row", "scan", "ix", "code", "gate"], "timer": ["temp", "definition", "dt", "test", "handler", "span", "header", "tp", "iter", "peer", "manager", "driver", "req", "wrapper", "ger", "er", "module", "cache", "tm", "player", "buffer", "browser", "tim", "icker", "t", "menu", "aster", "timeout", "program", "Timer", "mr", "finder", "ctr", "transfer", "event", "counter", "drm", "task", "worker", "err", "tc", "ter", "tom", "term", "tick", "actor", "loader", "clock", "attr", "time", "processor", "runner", "txt", "later", "tg", "nr", "taker", "rer", "duration", "tz", "acher", "byter", "imer", "walker", "tem", "roller", "writer", "her", "thread", "older", "trigger", "outer", "monitor", "cer", "sim", "meter"]}}
{"project": "qemu", "commit_id": "2af3da91839c04a5d73643b4eacce4cd93b9d428", "target": 0, "func": "void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n        int flags)\n\n{\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"PC=%08x\\n\", env->pc);\n\n\n\n    for (i = 0; i < 16; ++i) {\n\n        cpu_fprintf(f, \"A%02d=%08x%c\", i, env->regs[i],\n\n                (i % 4) == 3 ? '\\n' : ' ');\n\n    }\n\n}\n", "idx": 18988, "substitutes": {"env": ["window", "EN", "hess", "sh", "desc", "st", "en", "bar", "me", "ec", "ctx", "walker", "ner", "esm", "te", "buf", "e", "cur", "config", "sv", "db", "v", "esc", "ew", "obj", "ve", "gear", "vs", "ef", "ee", "manager", "cmd", "operator", "estate", "dev", "ev", "context", "def", "erd", "neck", "er", "viron", "org", "shell", "entry", "ah", "code", "pe", "Environment", "environment"], "f": ["fd", "form", "fn", "mac", "t", "w", "p", "lf", "sf", "h", "fb", "e", "fr", "cf", "fac", "out", "xf", "d", "v", "tf", "c", "fo", "file", "bf", "fi", "fc", "fm", "fs", "df", "fx", "uf", "fw", "buffer", "full", "fp", "rf", "F", "b", "ff"], "cpu_fprintf": ["cpu_rprintln", "cpu_cprintln", "cpu_fprint", "cpu_vprintln", "cpu_dprintln", "cpu_lprintf", "cpu_vprint", "cpu_hformat", "cpu_rwrite", "cpu_fformat", "cpu_vformat", "cpu_hprintln", "cpu_dprint", "cpu_lwrite", "cpu_rprint", "cpu_dprintf", "cpu_rprintf", "cpu_hwrite", "cpu_rformat", "cpu_lprintln", "cpu_hprintf", "cpu_vprintf", "cpu_dwrite", "cpu_hprint", "cpu_cprintf", "cpu_fwrite", "cpu_cprint", "cpu_lformat", "cpu_dformat", "cpu_cwrite", "cpu_fprintln"], "flags": ["fields", "cs", "size", "args", "flag", "bits", "settings", "ffff", " flag", "vals", "count", "ensions", "xp", "length", "name", "d", "mask", "ptr", "func", "options", "cond", "fs", "ags", "features", "code", "lag", "ents", "Flags"], "i": ["ic", "index", "ij", "si", "t", "ci", "im", "p", "ei", "ki", "me", "li", "is", "\u0438", "ri", "I", "u", "ai", "phi", "iq", "v", "di", "io", "cli", "ip", "mi", "pi", "c", "oi", "ind", "in", "j", "xi", "id", "ti", "ui", "batch", "gi", "o", "n", "number", "uri", "fi", "key", "ami", "bi", "x", "zi", "ini", "sim", "ie", "s", "chain", "it", "ix", "us", "iu", "y", "multi", "ii", "m"]}}
{"project": "qemu", "commit_id": "8d0bcba8370a4e8606dee602393a14d0c48e8bfc", "target": 0, "func": "int net_init_socket(const NetClientOptions *opts, const char *name,\n\n                    NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    Error *err = NULL;\n\n    const NetdevSocketOptions *sock;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);\n\n    sock = opts->socket;\n\n\n\n    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +\n\n        sock->has_udp != 1) {\n\n        error_report(\"exactly one of fd=, listen=, connect=, mcast= or udp=\"\n\n                     \" is required\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {\n\n        error_report(\"localaddr= is only valid with mcast= or udp=\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_fd) {\n\n        int fd;\n\n\n\n        fd = monitor_fd_param(cur_mon, sock->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n        qemu_set_nonblock(fd);\n\n        if (!net_socket_fd_init(peer, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_listen) {\n\n        if (net_socket_listen_init(peer, \"socket\", name, sock->listen) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_connect) {\n\n        if (net_socket_connect_init(peer, \"socket\", name, sock->connect) ==\n\n            -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_mcast) {\n\n        /* if sock->localaddr is missing, it has been initialized to \"all bits\n\n         * zero\" */\n\n        if (net_socket_mcast_init(peer, \"socket\", name, sock->mcast,\n\n            sock->localaddr) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    assert(sock->has_udp);\n\n    if (!sock->has_localaddr) {\n\n        error_report(\"localaddr= is mandatory with udp=\");\n\n        return -1;\n\n    }\n\n    if (net_socket_udp_init(peer, \"socket\", name, sock->udp, sock->localaddr) ==\n\n        -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 19003, "substitutes": {"opts": ["oppt", "ops", "opttions", "OPte", " dopts", "opt", "OPts", "opers", "operls", " dopt", "optpt", "protions", "operts", "propt", "optfs", "operos", "OPls", " doptions", "optts", " doppt", "opos", "prots", "opls", "OPos", "opte", "optte", "options", "optls", "OPfs", "opfs", "OPs", " ops", "optt", "optos", " opfs", "prot", " opte"], "name": ["mem", "cap", "nom", "word", "ame", "format", "none", "size", "comment", "num", "me", "domain", "family", "base", "normal", "mod", "prefix", "group", "cast", "Name", "named", "ma", "old", "add", "addr", "spec", "order", "time", "id", "admin", "event", "common", "parent", "version", "new", "root", "str", "n", "path", "key", "package", "er", "alias", "nm", "title", "type", "len", "no", "chain", "names", "NAME", "part", "code", "create", "ident", "file", "nam", "class"], "peer": ["connection", "channel", "server", "pipe", "window", "component", "ter", "client", "proc", "enter", "remote", "ctx", "pc", "device", "point", "per", "owner", "resource", "node", "pro", "socket", "pod", "instance", "peak", "older", "outer", "manager", "pkg", "target", "holder", "entity", "inner", "side", "scope", "pool", "parent", "rel", "master", "context", "member", "host", "cer", "ker", "ger", "er", "package", "state", "ssl", "params", "vr", "buffer", "chain", "pe", "part", "finger", "worker"], "errp": [" errpp", "errps", "rrps", "rrp", "errpp", "errP", "erpp", "erps", " errps", "rrpp", "rrP", "erp", "erP", " errP"], "err": ["error", "res", "arr", "or", "proc", "Error", "rx", "test", "gz", "kr", "ner", "e", "buf", "eas", "cur", "exc", "fr", "mr", "rs", "rr", "ch", "out", "Er", "attr", "iter", "obj", "aaa", "sys", "fee", "conn", "msg", "cmd", "c", "cr", "r", "ev", "cfg", "cer", "usr", "er", "txt", "cb", "eor", "resp", "rc", "der", "ex", "conf", "br"], "sock": ["jsock", "isOCK", "synock", "synOCK", "socker", "commock", " song", "resoin", "socked", "sess", "dsocket", "persox", "essockey", "soco", "sallock", " soco", "resock", "osocked", "nlock", "commocker", "commocket", " sockey", "isoy", " sess", "psoin", "ssOCK", "alsocker", "tsoc", "sconn", "svOCK", "sod", "statsocked", " sog", " sck", "synck", "salOCK", "portsoco", "dsocker", "gesox", "dsock", "nsocked", "statsock", " socks", "essoc", "jsoc", "slck", "desockey", "tsOCK", "svocked", "geslock", "soy", "symOCK", "six", "tsock", "ssck", " soc", "tsocked", "stsock", "insocker", "jsox", "dsack", "bsocked", "wck", "psix", "statsOCK", "symck", "alsocket", "portsock", "soc", "salocked", "jsocked", "dsck", "alsock", "desconn", "essock", "persock", "osck", "dsog", "islock", "desocker", "gesock", "desocket", "noy", "persockey", "yslock", "sick", " sod", "wocker", " sox", "stsocked", "nox", "essocked", "ysox", "desocked", "sck", " socked", "isocked", "tsck", "insocket", "persconn", "soin", "desoco", "resOCK", "inslock", "nsock", "gesocked", "symocked", "svock", "sless", "resocked", "dsocked", " slock", "symock", "jsck", "wock", "socks", "psocks", "wox", "ysconn", "insick", "svck", "msocked", "nock", "desock", "commlock", "isock", "desod", "bsocker", "stsack", "psock", "sog", "psocked", "ysockey", "osock", "desox", " sOCK", "nsoy", "sack", "alsOCK", "ysock", "salock", "msock", "insoy", "ssock", "ysocked", "song", "alsocked", "tsocker", "psOCK", "synocked", " sick", "portsod", "salack", " soy", "msOCK", "salong", "msocker", "stsocker", "alslock", "bsock", " six", "isox", "socket", "sox", " sack", "sOCK", "portsockey", "bslock", " socker", "insocked", "nsick", "ysocker", "jsocker", "sockey", "osod", "gesocker", "slox", "ssocked", "statsoin", "gesck", "jsockey", "slock", "osox", "isocker", "insock"], "fd": ["td", "pos", "fed", "ds", "raf", "fn", "size", "pipe", "ffff", "dt", "lf", "port", "pid", "handler", "gz", "fb", "fr", "cf", "dl", "dat", "done", "bd", "handle", "d", "fin", "db", "ln", "fe", "da", "ptr", "fee", "sd", "conn", "rd", "ff", "dir", "ind", "id", "std", "cond", "file", "fa", "fs", "fi", "fc", "df", "dim", "fm", "FD", "cb", "fine", "tty", "ld", "nd", "uf", "ini", "f", "fun", " fid", "fp", "dd", "fl"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 19005, "substitutes": {"v": ["vi", "cv", "l", "t", "w", "i", "pr", "p", "vt", "h", "q", "nv", "e", "av", "g", "sv", "vp", "vc", "conv", "d", "uv", "vs", "k", "vm", "c", "inv", "j", "r", "vis", "ev", "V", "o", "n", "y", "x", "mint", "vv", "view", "ver", "vr", "f", "s", "it", "tv", "b", "om", "m"], "obj": ["Object", " ok", "nt", "ist", "po", "ck", "adj", "bh", "xy", "ctx", "og", "expr", "ob", "impl", "ht", "tmp", "so", "ot", "bj", " ob", "attr", "self", "object", " Obj", "js", "inv", "oj", "ref", "inst", "oid", "et", "Obj", "obs", "o", "act", "ent", "txt", "resp", "phys", "org", "acting", "elt", "objects"], "name": ["missing", "na", "cap", "init", "word", "ame", "t", "w", "comment", "p", "var", " names", "prefix", "Name", "ann", "named", "ma", "ns", "attr", "spec", "data", "cmd", "order", "id", "common", "local", "def", "str", "n", "path", "key", "alias", "nm", "par", "no", "s", "an", "names", "NAME", "part", "text", "ident", "type"], "errp": ["errps", " errr", " errpa", "errm", "errd", "crm", "crps", "rrpa", "rcjp", "rrm", "errjp", "rcps", "rcP", "rrjp", "crp", "errpa", "erp", "erpc", "errr", "errpc", "rrd", "crpa", "rrr", "rcp", " errpc", "rrp", "erjp", "erps", " errps", " errm", "rrps", "erd", "errP", " errd", "rrP", "rrpc", "erP", "err"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)\n\n{\n\n    int d;\n\n    for( d = 0; d < 8; d++ ) {\n\n        const int p0 = pix[-1*xstride];\n\n        const int p1 = pix[-2*xstride];\n\n        const int q0 = pix[0];\n\n        const int q1 = pix[1*xstride];\n\n\n\n        if( FFABS( p0 - q0 ) < alpha &&\n\n            FFABS( p1 - p0 ) < beta &&\n\n            FFABS( q1 - q0 ) < beta ) {\n\n\n\n            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */\n\n            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */\n\n        }\n\n        pix += ystride;\n\n    }\n\n}\n", "idx": 19011, "substitutes": {"av_flatten": ["av_fen", "av_flatt", "av___flen", "av_fatt", "av___flatt", "av_fense", "av_fratt", "av___Flatt", "av_Flense", "av_fatten", "av_Flatt", "av_Flen", "av___Flense", "av_flen", "av_fren", "av___Flen", "av_flense", "av_Flatten", "av_fratten", "av___Flatten", "av_frense", "av___flense", "av___flatten"], "pix": ["spfix", "cpx", "px", "prix", "ppfix", "spixels", " pip", "repixels", "cpac", "pitch", "pact", "apac", "pfx", "apx", "cpact", "psact", "pfix", "tpx", "spix", "pond", " pw", "piip", "apix", "psressed", "pw", "ppip", "pixels", "cpitch", "tpixels", "pressed", "psix", " piv", "Pip", "prond", "Px", "ppx", "psixels", " pac", " pfix", "piIX", "repix", "Pixels", " pressed", "pac", "Piv", "prw", "spIX", "piix", "pIX", "ppixels", "apitch", " pIX", "repfx", " pile", "pile", "Pfx", "cpile", "prressed", " pact", "psw", " pfx", "pip", "tpip", " pixels", " px", "repIX", "Pix", "cpix", "cpixels", " pitch", " pond", "psond", "PIX", "ppix", "piv", "ppIX", "psile", "cpiv", "tpix"], "xstride": ["xSTRace", "xstrice", "xStrides", "xstrace", "xStrider", " xstrride", "Xstrider", "xSTRice", " xstrid", "ySTRimate", "xSTRider", "xgride", "xStrend", "ySTRide", "Xstrides", "xgrider", "Xctrade", "xstringace", "xctrade", "xstringide", " xdivride", "xctride", " xdivause", "xStrace", "xstrride", "xstrause", "ySTRider", "xStrade", "ystrimate", "xstringimate", "xstid", "Xctrides", "xvolride", "xvolimate", "ystrider", "xStride", "xstringice", "xSTRimate", "xgrride", "xSTRend", "xstringid", "xstringause", "xstrimate", "xstrides", "xSTRride", "xctrides", "xctrider", "xstringride", "xdivid", "xgrice", "ySTRend", "xvolace", "xStrice", "xctrice", "ySTRace", "xdivide", "xstrider", "ystrice", "Xstride", "xstause", "xstrend", "ystrend", "xstringend", "ySTRride", "xstrid", "ySTRice", "xctrride", "xdivause", "ystrace", "xSTRide", "Xctrider", "ystrride", "xdivride", "xvolide", "xstide", "xSTRade", " xdivid", "xSTRides", " xdivide", " xstrause", "Xstrade", "xstrade", "Xctride"], "ystride": ["ytrine", "ystriden", "xdividen", "xdivide", "yslide", "ycharension", "xstrride", "ychariden", "ydivride", " ystrate", "yslride", "ysliden", "xstriden", "ytride", "ydivide", " yconstate", "ystrate", " yconstide", "ydividen", "yconstide", "ydivension", "ypride", "xstrension", "ystrension", " ystrine", "yconstine", " yconstine", "yconstate", "yprate", "ycharide", "ystrride", "xdivride", "yprine", "yslension", "ytrate", "ystrine", "xdivension", "ycharride"], "alpha": ["a", "au", "lambda", "ca", "ra", "ta", "ax", "i", "p", "acl", " gamma", "h", "ar", "scale", "xa", "upper", "phi", "ity", "ma", "alph", "star", "da", "asc", "pi", "Alpha", "pha", "height", "HA", "val", "fa", "appa", "alias", "A", "la", "qa", "al", "ac", "phas", "angle", "ia", "inc"], "beta": ["a", "xff", "lambda", "ca", "z", "ta", "p", "term", "bp", "base", "scale", "zero", "igma", "normal", "te", "u", "fty", "phi", "aa", "alph", "v", "mu", "pha", "Alpha", "dev", "binary", "gam", "Beta", "\u03b2", "fa", "alias", "bi", "elta", "qa", "prime", "ba", "broad", "frequency", "filter", "b", "bis", "ii"], "d": ["debug", "ds", "fd", "l", "ord", "t", "w", "de", "back", "i", "p", "dt", " delta", "md", "dal", "e", "mod", "g", "dat", "done", "bd", "out", "ad", "db", "di", "cd", "da", "dr", "c", "dig", "ind", "dir", "j", "den", "dev", "days", "pd", "draw", "def", "D", "n", "dc", "dy", "du", "diff", "dim", "del", "x", " D", "ld", " dim", "nd", "dx", "did", "dra", "b", " de", "dd", "m"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n\n{\n\n    char local[13];\n\n\n\n    memcpy(local, version, 12);\n\n    local[12] = 0;\n\n\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n\n    if (vs->major != 3 ||\n\n        (vs->minor != 3 &&\n\n         vs->minor != 4 &&\n\n         vs->minor != 5 &&\n\n         vs->minor != 7 &&\n\n         vs->minor != 8)) {\n\n        VNC_DEBUG(\"Unsupported client version\\n\");\n\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n        vnc_flush(vs);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n\n     * as equivalent to v3.3 by servers\n\n     */\n\n    if (vs->minor == 4 || vs->minor == 5)\n\n        vs->minor = 3;\n\n\n\n    if (vs->minor == 3) {\n\n        if (vs->auth == VNC_AUTH_NONE) {\n\n            VNC_DEBUG(\"Tell client auth none\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_client_init(vs);\n\n       } else if (vs->auth == VNC_AUTH_VNC) {\n\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_auth_vnc(vs);\n\n       } else {\n\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n            vnc_flush(vs);\n\n            vnc_client_error(vs);\n\n       }\n\n    } else {\n\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n\n        vnc_write_u8(vs, 1); /* num auth */\n\n        vnc_write_u8(vs, vs->auth);\n\n        vnc_read_when(vs, protocol_client_auth, 1);\n\n        vnc_flush(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19023, "substitutes": {"vs": ["lv", "bits", "ks", "words", "checks", "vals", "caps", "rs", "points", "vp", "pages", "ants", "inv", "es", "fs", "names", "heads", "ows", "ops", "otes", "tops", "qs", "vc", "ss", "uds", "v", "sts", "keys", "ps", "xs", "obs", "ts", "ls", "Vs", "parts", "ver", "vr", "stats", "ads", "wcs", "ds", "cs", "times", "terms", "ils", "changes", "lines", "sv", "blogs", "co", "sw", "docs", "vers", "js", "gets", "VS", "vd", "atts", "hs", "lbs", "outs", "args", "ins", "vt", "pps", "posts", "is", "bs", "gs", "values", "lists", "ports", "ns", "vm", "aps", "eps", "views", "ims", "vv", "ms", "its"], "version": ["iso", "binding", "channel", "size", "wire", "bits", "hash", "text", "feature", "uint", "scale", "ion", "Version", "command", "length", "node", "name", "v", "value", "vers", "release", "tag", "message", "pack", "number", "VERSION", "package", "vector", "info", "ver", "VER", "spec", "versions", "byte", "type"], "len": [" length", "lp", "l", "el", "size", "lib", " n", "en", " common", " l", "length", "vc", "v", "bytes", "common", "n", " bl", "lic", "lan", "al", "rc", " clen", "Len", " c", "type"], "local": ["a", "mem", " Local", "shared", "loc", "l", "el", "sel", "server", "window", "close", "p", "valid", "var", "final", " locals", "list", "mail", "where", "client", "as", "remote", "on", "le", "public", "util", "lock", "global", "empty", "initial", "tmp", "foreign", "length", "save", "name", "out", "all", "v", "serial", "self", "data", "pal", "inner", "master", "common", "new", "val", "external", "pack", "n", "state", "cache", "null", "al", "ac", "localhost", "full", "Local", "file", "old", "m"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    struct pxa2xx_pic_state_s *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (struct pxa2xx_pic_state_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n    s->base = base;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x000fffff, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(\"pxa2xx_pic\", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 19027, "substitutes": {"base": ["a", "check", "init", "use", "server", "bare", "size", "back", "i", "p", "as", "bar", "store", "en", "h", "port", "bp", "set", "end", "bas", "scale", "balance", "e", "ase", "based", "prefix", "kb", " Base", "name", "address", "m", "mb", "out", "v", "db", "start", "cpu", "area", "se", "ip", "sys", " bases", "ada", "reset", "range", "pi", "c", "re", "id", "site", "bu", "ref", "origin", "root", "bound", "key", "bi", "source", "type", "pa", "eta", "from", "buffer", "ASE", "f", "b", "file", "create", "Base"], "env": ["con", "cv", "np", "server", "eng", "window", "max", "sb", "ei", "stage", "en", "vt", "ec", "bar", "enc", "h", "ctx", "end", "set", "nv", "e", "buf", "sv", "vp", "v", "vs", "ptr", "obj", "hw", "conn", "req", "site", "dev", "scope", "jp", "ev", "context", "eu", "er", "viron", "network", "cb", "nc", "vr", "home", "pe", "org", "sc", "code", "conf", "pen", "environment"], "s": ["details", "e", "g", "rs", "properties", "vs", "se", "c", "es", "comm", "fs", "acs", "space", "er", "params", "spec", "sl", "os", "ops", "t", "sp", "q", "set", "qs", "sa", "S", "ss", "sts", "v", "ps", "o", "n", "ts", "ls", "parts", "stats", "sc", "a", "services", "ds", "sam", "l", "sb", "as", "ses", "changes", "sv", "js", "storage", "j", "states", "b", "has", "y", "m", "args", "i", "p", "ins", "store", "sq", "ers", "aws", "h", "is", "bs", "gs", "ports", "ns", "socket", "pers", "ats", "r", "less", "actions", "ims", "conf", "its"], "iomemtype": ["iologyemtype", "iomemerplate", "iomotorotype", "iomotortype", "iomemsty", "iomidemvalue", "iomidemtype", "iologyimerType", "iblemstatus", "iomademType", "iomemvalue", "iblemtype", "iemimTYPE", "ibleminstatus", "iomimtype", "iomotorplate", "iomemty", "ibleminotype", "iomimTYPE", "iomemerstatus", "iomemintype", "iomeminstatus", "iomimty", "iemimty", "iologyemType", "iememtype", "iomemstatus", "iomidemplate", "iomemType", "iblemintype", "iememTYPE", "iomemerotype", "iemimType", "iomademtype", "iomimerType", "iologyemplate", "iomeminotype", "iomimervalue", "iologyimertype", "iememty", "iomimerplate", "iologyemvalue", "iblemotype", "iomemotype", "ibleminplate", "iomimType", "iomimplate", "iomemsTYPE", "iomemplate", "iomemTYPE", "iomademTYPE", "iemimtype", "iomademty", "iememType", "iomemsType", "iomimertype", "iomidemType", "iologyimerplate", "iologyimervalue", "iomemstype", "iomemertype", "iomimvalue", "iblemplate", "iomeminplate", "iomotorstatus"], "qi": ["squ", "ique", "cgi", "qv", "si", "\u043e", "i", " sq", "ei", "ki", "sq", " IQ", "query", "q", "eni", " ti", "li", "qs", " pi", "ql", "eas", "ni", "IQ", "quire", " Ni", " MI", "cci", "iq", " cu", "Ni", " cis", "afi", "ifa", "Q", "ui", " q", "igi", "aq", "oka", " ki", "fi", "gui", "cu", " Qt", "agi", "qa", "qt", " ni", " si", "ini", "ia", "iza", "ike", "qq", "ii", "dq"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static int mp_decode_frame(MPADecodeContext *s, OUT_INT **samples,\n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    int i, nb_frames, ch, ret;\n\n    OUT_INT *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);\n\n\n\n    /* skip error protection field */\n\n    if (s->error_protection)\n\n        skip_bits(&s->gb, 16);\n\n\n\n    switch(s->layer) {\n\n    case 1:\n\n        s->avctx->frame_size = 384;\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        s->avctx->frame_size = 1152;\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n        s->avctx->frame_size = s->lsf ? 576 : 1152;\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n\n\n        if (nb_frames < 0)\n\n            return nb_frames;\n\n\n\n        s->last_buf_size=0;\n\n        if (s->in_gb.buffer) {\n\n            align_get_bits(&s->gb);\n\n            i = get_bits_left(&s->gb)>>3;\n\n            if (i >= 0 && i <= BACKSTEP_SIZE) {\n\n                memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb)>>3), i);\n\n                s->last_buf_size=i;\n\n            } else\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid old backstep %d\\n\", i);\n\n            s->gb           = s->in_gb;\n\n            s->in_gb.buffer = NULL;\n\n        }\n\n\n\n        align_get_bits(&s->gb);\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        i = get_bits_left(&s->gb) >> 3;\n\n\n\n        if (i < 0 || i > BACKSTEP_SIZE || nb_frames < 0) {\n\n            if (i < 0)\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid new backstep %d\\n\", i);\n\n            i = FFMIN(BACKSTEP_SIZE, buf_size - HEADER_SIZE);\n\n        }\n\n        assert(i <= buf_size - HEADER_SIZE && i >= 0);\n\n        memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);\n\n        s->last_buf_size += i;\n\n    }\n\n\n\n    /* get output buffer */\n\n    if (!samples) {\n\n        av_assert0(s->frame != NULL);\n\n        s->frame->nb_samples = s->avctx->frame_size;\n\n        if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n        samples = (OUT_INT **)s->frame->extended_data;\n\n    }\n\n\n\n    /* apply the synthesis filter */\n\n    for (ch = 0; ch < s->nb_channels; ch++) {\n\n        int sample_stride;\n\n        if (s->avctx->sample_fmt == OUT_FMT_P) {\n\n            samples_ptr   = samples[ch];\n\n            sample_stride = 1;\n\n        } else {\n\n            samples_ptr   = samples[0] + ch;\n\n            sample_stride = s->nb_channels;\n\n        }\n\n        for (i = 0; i < nb_frames; i++) {\n\n            RENAME(ff_mpa_synth_filter)(&s->mpadsp, s->synth_buf[ch],\n\n                                        &(s->synth_buf_offset[ch]),\n\n                                        RENAME(ff_mpa_synth_window),\n\n                                        &s->dither_state, samples_ptr,\n\n                                        sample_stride, s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * sample_stride;\n\n        }\n\n    }\n\n\n\n    return nb_frames * 32 * sizeof(OUT_INT) * s->nb_channels;\n\n}\n", "idx": 19041, "substitutes": {"s": ["z", "sg", "details", "rs", "vs", "se", "sys", "ants", "c", "es", "comm", "fs", "er", "series", "spec", "serv", "os", "ops", "t", "settings", "set", "qs", "S", "ss", "sts", "v", "ps", "service", "n", "ts", "ls", "parts", "ains", "stats", "bis", "comments", "a", "ies", "services", "ds", "cs", "sam", "w", "sb", "as", "ses", "changes", "als", "ar", "sv", "sw", "still", "js", "j", "source", "state", "an", "has", "m", "utils", "hs", "args", "p", "ins", "sq", "aws", "h", "is", "bs", "gs", "ports", "ns", "ties", "sports", "pers", "ats", "less", "ims", "ms", "us", "conf", "its"], "samples": ["Samples", "specamples", " sample", " samps", "samps", "sents", "specample", "Samps", " sents", "Sents", "specents", "Sample", "specamps", "sample"], "buf": ["mem", "xff", "cv", "Buff", "np", "img", "max", "p", "bar", "fb", "vec", "cur", "tmp", "length", "queue", "BU", "out", "db", "bytes", "pb", "wb", "data", "cmd", "msg", "ref", "raw", "bf", "rb", "cache", "cb", "block", "bin", "uf", "len", "rc", "buffer", "Buffer", "buff", "b", "ff", "br", "err"], "buf_size": ["buf_SIZE", " buf_limit", "buf2SIZE", "buf_Size", "cb__", "buf_count", " buf_Size", "buff_SIZE", "buf__", "cb_f", "buf64SIZE", "bufptf", "buf64size", "buff2count", "buff2SIZE", "buf2size", "buff_count", "buf64Size", "buff_length", " buf_SIZE", "buf2length", "buf_limit", "buf_pos", "buf_length", "buff_size", "buff2length", " buf_pos", "buf_f", "bufpt_", "buf64pos", "buf2count", "buff2size"], "i": ["yi", "ic", "index", "ij", "l", "si", "ci", "hi", "p", "ish", "ei", "qi", " ti", "me", "q", "ir", "h", "li", "is", "g", "I", " ii", "u", "ai", "phi", "length", "ori", "conv", "v", "di", "limit", "cli", "k", "io", "ip", "mi", "pi", "oi", "c", "id", "j", "xi", "ti", "ui", "gi", "n", "o", "ami", "multi", "fi", "bi", "iu", "x", "info", "ims", " ni", "zi", "ini", "sim", " bi", "f", "it", "ia", "ix", "b", "y", "ii", "m"], "nb_frames": ["obb67items", "obbptflows", "nboyframes", "nb___flows", "uniqueoywords", "nboywords", "obb67frames", "obb_flows", "nb_bits", "nb23frames", "unique_flows", "nb____images", "num_bits", "nb_frame", "nb____points", "nb23flows", "NB_flows", "NB_frames", "obb_events", "nbxobs", "nb67flows", "nbJflows", "lenuffyvalues", "nbxbits", "uniqueoyframes", "uniqueoyflows", "nboyblocks", "NB_states", "obb_frames", "nbJobs", "nbptruns", "nbptevents", "abb_frames", "nb67frames", "obbptevents", "nboyflows", "obb67points", "len_frames", "uniqueoyblocks", "nb67events", "obbptruns", "abb_blocks", "obb_runs", "nb_items", "nbJframe", "nb_runs", "lenuffyframes", "NB_hops", "nb_values", "nb_points", "nbJblocks", "nb___states", "nb_flows", "nbxframe", "nbJbits", "nbxframes", "nb67items", "nb_blocks", "numxframe", "lenuffyimages", "nb___frames", "nb23hops", "obbptframes", "obb_points", "nbPitems", "nb_hops", "nbuffyframes", "num_obs", "nbJframes", "nb_images", "numxbits", "len_images", "abb_points", "nbPflows", "unique_blocks", "unique_words", "nbptframes", "nb___hops", "nb_words", "num_frame", "nb23states", "nb67points", "nbPframes", "len_values", "numxobs", "nb____blocks", "nb____frames", "obb_items", "abb_images", "nb_obs", "nbptflows", "nb_states", "nbJwords", "nbuffyimages", "nb67runs", "nb_events", "nbuffyvalues", "numxframes", "obb67flows", "nbPpoints", "num_frames", "unique_frames"], "ch": ["cs", "channel", "sch", "res", "ach", "ich", "th", "chi", "q", "ctx", "pc", "chip", "cur", "ct", "CH", "ih", "chan", "jp", "cmp", "cho", "och", "cb", "tch", "qt", "cp", "sc", "col"], "ret": ["res", "nt", "Ret", "hash", "rt", "tif", "mt", "out", "conv", "ft", "rem", "RET", "reset", "re", "rel", "ref", "jp", "val", "et", "new", "alt", "pert", "txt", "len", "gt", "elt", "status"], "samples_ptr": ["samples_size", "samples_pointer", "samples__Ptr", "samples__ptr", "samples_Ptr", "samples__size", "samples__pointer"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static InetSocketAddress *ssh_config(QDict *options, Error **errp)\n\n{\n\n    InetSocketAddress *inet = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"SSH server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return inet;\n\n}", "idx": 19075, "substitutes": {"options": ["ptions", "atts", "times", "uploads", "ops", "os", "args", "opt", "settings", "flags", "classes", "details", "roots", "tops", "option", "caps", "config", "op", "mt", "tags", "kw", "Options", "properties", "oops", "keys", "aps", "ps", "styles", "some", "ts", "info", "parts", "ans", "meta", "params", "stats", "ms", "spec"], "errp": ["erping", "errps", "rrpg", " errr", " erp", "errorp", " erpg", "errorP", " errpp", "lerpg", " erpa", "errpg", "erpg", "errpa", "erp", "errr", "errorper", "rrping", "rrp", " erper", "errpp", "errorpa", "erps", "erpp", " errps", "rrpp", "lerpa", "errping", "lerper", "errorr", "rrps", "errper", "errP", "errorpg", "lerp", "errorps", "erP", " errP", "errorping", "err"], "inet": ["init", "offset", "eth", " ip", "ds", "connection", " IP", "nt", "tz", "ifi", " dst", "i", "dt", "inel", "client", "interface", " eq", "het", "oss", " dest", "kt", " net", "iw", "ect", "virtual", "prefix", "tif", " anew", "onet", "pton", " target", " socket", "iq", "address", "socket", " xp", " ut", "ip", "iss", "conn", " NI", "afi", " Ethernet", "det", "target", "sat", "binary", "local", "et", " mac", "ant", " VIP", "fi", "network", "anc", " ni", "net", "initialized", " eth", " local", "localhost", "ix", "elt", "iat"], "addr": ["mem", "pos", "os", "arr", "ord", "args", "opt", "pad", "amp", "rect", "ctx", "ress", "rt", "expr", "adr", "ace", "rs", "map", "points", "prefix", "mt", "address", "ad", "db", "ns", "attr", "obj", "dr", "add", "ptr", "news", "aps", "conn", "ip", "cmd", "pkg", "dir", "rel", "ref", "r", "rid", "host", "ash", "art", "align", "act", "alt", "ack", "parts", "Address", "encrypted", "params", "arp", "bind", "url", "ix", "elt", "conf", "err"], "crumpled_addr": ["crumpling_obj", "crumbled_ord", "crumpled_ptr", "crumpled_add", "crumpled___obj", "crumpled2address", "crumpled_obj", "crumbled_add", "crumpled__add", "crumpled_cmd", "crumpling_address", "crumpled__addr", "crumpling_arr", "crumpled2addr", "crumpled_arr", "crumpled___address", "crumpled_mem", "crumpled2obj", "crumpled2cmd", "crumbled_addr", "crumbled_address", "crumbled_obj", "crumpled___addr", "crumbled_ptr", "crumpled_loc", "crumpled___arr", "crumbled_cmd", "crumpled_ord", "crumpled_address", "crumpled__ptr", "crumbled_loc", "crumpling_mem", "crumpling_addr", "crumpled___cmd"], "iv": ["vi", "riv", "ov", "ij", "qv", "ival", "ivo", "i", "iph", "oc", "var", "vt", "ec", "rir", "ient", "ir", "ik", "iw", "nv", "av", "vp", "vc", "VI", "iq", "v", "uv", "iro", "ptr", "iter", "ih", "ip", "ive", "vir", "ev", "voc", "nov", "iov", "Iv", "fi", "ib", "ior", "IV", "vv", "liv", "vr", "it", "tv", "iver", "iva", "iat"], "local_error": ["local_Error", " local_warning", " local_ror", " local_Error", "local____error", " local_danger", "local_warning", "local____detail", "localityError", "local____danger", "localityerror", "local_ror", " local_detail", "global_Error", "global_ror", "global_event", " local_problem", "global_error", "localityevent", "localpydetail", "localpyerror", "local_danger", "local_problem", "localityror", "localpydanger", "local_event", "local_detail"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n\n{\n\n    if ((s->data_count & 0x3) != byte_num) {\n\n        ERRPRINT(\"Non-sequential access to Buffer Data Port register\"\n\n                \"is prohibited\\n\");\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 19082, "substitutes": {}}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n\n{\n\n    ssize_t ret;\n\n    guint watch;\n\n\n\n    assert(qemu_in_coroutine());\n\n    /* Negotiation are always in main loop. */\n\n    watch = qio_channel_add_watch(ioc,\n\n                                  G_IO_OUT,\n\n                                  nbd_negotiate_continue,\n\n                                  qemu_coroutine_self(),\n\n                                  NULL);\n\n    ret = write_sync(ioc, buffer, size, NULL);\n\n    g_source_remove(watch);\n\n    return ret;\n\n}\n", "idx": 19090, "substitutes": {"ioc": ["liroc", "iroc", " iico", "dioc", "liOC", "uioci", "piroc", "ioci", "ooc", "liocal", "ooci", "iico", "diico", " ioci", "oocate", "lioc", " iocate", "ioco", "diroc", "uiosc", "uiocate", "uiico", " ioco", "piOC", "iosc", "pioc", " iosc", "iocate", "dioco", "oosc", " iOC", " iocal", "uioco", "uiroc", "iOC", "iocal", "piocal", "uioc", " iroc"], "buffer": ["channel", "face", "window", "bb", "stream", "base", "paste", "buf", "empty", "map", "command", "length", "queue", "variable", "read", "document", "data", "page", "binary", "batch", "message", "table", "raw", "sequence", "source", "cache", "block", "uf", "phrase", "Buffer", "buff", "b", "byte"], "size": ["offset", "mem", "use", "si", "format", "args", "t", "sent", "timeout", "set", "scale", "sum", "count", "empty", "shape", "length", "iz", "name", "out", "send", "seek", "ptr", "read", "addr", "sn", "fee", "time", " Size", "ize", "scope", "__", "message", "dim", "space", "Size", "SIZE", "len", "code", "type"], "ret": ["mem", " RET", "res", "arr", "nt", "t", "flag", "total", "sp", "st", "result", "rt", "gc", "arg", "g", "run", "match", "tr", "mt", "out", "mb", "limit", "ptr", "cont", "sys", "RET", "cat", "re", "lit", "try", "r", "__", "val", "std", "raw", "print", "alt", "tail", "len", "uf", "gt", "it", "elt", "Ret"], "watch": ["patch", "mem", "check", "cv", "see", "WATCH", "channel", "t", "w", "ach", "rain", "var", "sp", "store", "timeout", "query", "feature", "aw", "wait", "change", "lock", "g", "cam", "match", "seek", "out", "ch", "warn", "v", "ait", "atch", "thread", "track", "read", "push", "call", "cat", "Watch", "priv", "chan", "wat", "sync", "batch", "ignore", "raw", "atcher", "key", "er", "cache", "row", "share", "write", "scan", "serv", "parse", "status"]}}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n    free(ctx);\n\n}\n", "idx": 19102, "substitutes": {"opaque": ["iopent", "opent", "Opaque", "iopque", "obaque", "opaques", "oppaques", "Opque", "popaque", "Opaques", "oplais", "oplaque", "obaques", "Opent", "oppacity", "oppais", "oppaque", "popacity", "iopaque", "popais", "obque", "oplacity", "obent", "opacity", "opque", "popaques", "opais", "oplaques", "iopaques"], "ret": ["mem", "rm", " RET", "nt", "res", "t", "back", "deg", "ter", "Ret", "ry", "hash", "xy", "rt", "count", "arg", "tr", "mt", "ct", "sec", "nz", "tf", "inter", "ft", " Ret", "magic", "RET", "reply", "re", "cmd", "det", "ext", "try", "ref", "jp", "val", "et", "rets", "def", "pat", "alt", "aux", "x", "len", "resp", "gt", "code", "elt", "status", "err"], "ctx": ["ck", "tx", "kj", "rt", "crit", "kw", "obj", "sys", "req", "jp", "context", "tk", "cm", "dc", "kick", "aux", "tm", "xc", "abc", "exec", "td", "check", "cv", "np", "desc", "timeout", " context", "dl", "ct", "etc", "hw", "pkg", "pt", "kl", "ctrl", "fc", "cu", "qt", "resp", "urg", "org", "worker", "init", "ctl", "jj", "tc", "nt", "ca", "proc", "kt", "unc", "expr", "cl", "mom", "cf", "xp", "prefix", "jac", "cc", "alloc", "co", "addr", "std", "cmp", "cfg", "def", "act", "txt", "cp", "work", " cx", "window", "gc", "config", "pg", "bj", "ns", "wx", "conn", "cmd", "dad", "ind", "func", "inst", "batch", "cb", "nc", "conf"], "t2": ["f3", "t5", " t5", "ot2", "T3", " T2", "t1", " T1", "ot1", "f_", "time1", "T0", " t0", " t4", "timetwo", "ttwo", "kttwo", "ot3", "p2", "T5", "f2", "time2", " t1", "p5", "t4", " T3", "f1", "p0", "kt2", " t3", "t_", "T_", " ttwo", "time3", "ot4", "T1", "time4", "kt4", " t_", "T4", "t0", " T4", "T2", "t3", "p1"], "cmp_buf": ["cmp___buffer", "cmp1fac", "cmp__buffer", "cmp_fac", "cmp1vec", "cmp1buf", "comp_fac", "comp_buffer", "comp_buf", "cmp1buffer", "mp_buffer", "mp_vec", "comp_bytes", "comp_bu", "cmp_bu", "cmp__buf", "cmp_buff", "cmp___bu", "cmp___bytes", "comp_vec", "cmp_vec", "comp_buff", "cmp_buffer", "cmp_bytes", "cmp__vec", "cmp___buf", "mp_buf"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 19108, "substitutes": {"ctx": [" cx", "tc", "ok", "ca", "px", "ci", "ck", "tx", "mc", "gc", "cas", "cf", "tmp", "ct", "cc", "bc", "kw", "co", "hw", "obj", "wx", "sys", "conn", "CT", "req", "c", "pkg", "jp", "context", "cfg", "cmp", "cm", "act", "cu", "Context", "cb", "nc", "qt", "xc", "cp"], "gprn": ["Gprn", " gprnb", "gptrna", "gsprnum", "Gprid", "gfrnb", "gpolN", "gprid", " gprna", " gprr", "gwrn", "Gsprid", "gfrna", "gfrn", "gsprN", " gsprn", "gprr", "gwrid", "gsprr", "gsprn", "gsprna", "gprnum", "Gsprn", "GsprN", "Gprnum", " gsprr", "gsprnb", "gptrnb", "gprnb", "gwrN", " gsprna", "gpolid", "gwrnum", "gptrn", "gpoln", "gsprid", "Gsprnum", " gsprnb", "gprna", "gfrr", "GprN", "gptrr", "gpolnum", "gprN"], "sprn": ["sprnr", "prn", "prnr", "prnb", "svn", "krnb", "krN", "sprN", "svN", "krn", "svnr", "prN", "sprnb", "krnr", "svnb"]}}
{"project": "qemu", "commit_id": "732b530c1bd064bdcc29975c0b78fc6de8c47e7f", "target": 0, "func": "static void nvdimm_build_common_dsm(Aml *dev)\n\n{\n\n    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;\n\n    uint8_t byte_list[1];\n\n\n\n    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);\n\n    function = aml_arg(2);\n\n    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);\n\n\n\n    /*\n\n     * do not support any method if DSM memory address has not been\n\n     * patched.\n\n     */\n\n    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));\n\n\n\n    /*\n\n     * function 0 is called to inquire what functions are supported by\n\n     * OSPM\n\n     */\n\n    ifctx = aml_if(aml_equal(function, aml_int(0)));\n\n    byte_list[0] = 0 /* No function Supported */;\n\n    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(unpatched, ifctx);\n\n\n\n    /* No function is supported yet. */\n\n    byte_list[0] = 1 /* Not Supported */;\n\n    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(method, unpatched);\n\n\n\n    /*\n\n     * The HDLE indicates the DSM function is issued from which device,\n\n     * it is not used at this time as no function is supported yet.\n\n     * Currently we make it always be 0 for all the devices and will set\n\n     * the appropriate value once real function is implemented.\n\n     */\n\n    aml_append(method, aml_store(aml_int(0x0), aml_name(\"HDLE\")));\n\n    aml_append(method, aml_store(aml_arg(1), aml_name(\"REVS\")));\n\n    aml_append(method, aml_store(aml_arg(2), aml_name(\"FUNC\")));\n\n\n\n    /*\n\n     * tell QEMU about the real address of DSM memory, then QEMU\n\n     * gets the control and fills the result in DSM memory.\n\n     */\n\n    aml_append(method, aml_store(dsm_mem, aml_name(\"NTFI\")));\n\n\n\n    result_size = aml_local(1);\n\n    aml_append(method, aml_store(aml_name(\"RLEN\"), result_size));\n\n    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),\n\n                                 result_size));\n\n    aml_append(method, aml_create_field(aml_name(\"ODAT\"), aml_int(0),\n\n                                        result_size, \"OBUF\"));\n\n    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(\"OBUF\"),\n\n                                       aml_arg(6)));\n\n    aml_append(method, aml_return(aml_arg(6)));\n\n    aml_append(dev, method);\n\n}\n", "idx": 19115, "substitutes": {"dev": ["eth", "error", "eng", "definition", "var", "proc", "test", "app", "handler", "device", "DEV", "development", "disk", "v", "reader", "ay", "param", "example", "driver", "cmd", "ev", "member", "def", "module", "env", "block", "event"], "method": ["Method", "and", "direct", "test", "handler", "mount", "variable", "self", "manager", "mp", "wrapper", "inner", "field", "context", "med", "path", "module", "attribute", "smart", "spec", "mem", "hod", "eth", "form", "memory", "sm", "property", "command", "call", "service", "met", "arm", "private", "view", "event", "class", "mm", "proc", "interface", "user", "mod", "model", "tr", "name", "session", "attr", "instance", "def", "month", "ident", "man", "process", "m", "history", "im", "cell", "power", "public", "util", "map", "gem", "param", "rem", "magic", "cmd", "func", "message", "member", "job", "top", "package", "METHOD", "sim", "this"], "ifctx": ["Iftx", "IFctx", "iftx", "ifcfg", "iwcfg", "iffcfg", "iwtx", "IFtx", "ifcmd", "Ifctx", " ifcmd", "iffcontext", "IFContext", "ifftc", "iwpkg", "ifcontext", "iftc", "IFcontext", "ifContext", "ifpkg", " ifcontext", "Ifcmd", "Ifcfg", " iftx", "iwcontext", "iffctx", " ifContext", "iwcmd", "iwtc", "Ifcontext", "IfContext", "Ifpkg", "iwctx", "Iftc", " ifpkg"], "function": ["callback", "connection", "functional", "index", "fn", "word", "lambda", "format", "before", "interface", "feature", "handler", "family", "action", "normal", "command", "Function", "length", "operation", "address", "variable", "object", "value", "service", "role", "func", "condition", "context", "relation", "table", "number", "production", "package", "module", "attribute", "section", "f", "fun", "event", "type"], "dsm_mem": ["dmm2ram", "dspace_em", "dsm_mb", "dsm_ram", "dsm2memory", "dsm2ram", "dmm_memory", "dmm_ram", "dmm_mem", "dspace_mem", "dsm_memory", "dspace_memory", "dsm_em", "dSM_mem", "dmm2mem", "dSM_memory", "dsm2mem", "dmm2memory", "dSM_mb"], "unpatched": ["unpached", "unPatched", " unpatached", " unathed", "unliched", " unatatched", "unpatatched", "Unpatching", "unfetching", "unpayached", "unpatching", "unPatatched", "Unpathed", "Unpatced", "unmatized", "unmatched", " unpushed", " unatched", "unpatced", "unminushed", "unpayching", "unpatchching", " unmatced", "unmatatched", "unbatchched", "Unpatchching", "unatching", "unpayched", "unpayhed", "Unpatchatched", "unbatchching", " unpatushed", "unlicched", "unminching", "unpatchatched", "unpatchhed", "unlicching", "unpching", "unpayatched", "unpatchized", " unpching", "unpatchched", "unatched", "unpatushed", "unmathed", "unPathed", " unatching", "unlicced", "Unpatched", "unatatched", "Unpatchced", " unmatatched", "unfetced", "unmatced", "unfetched", "unathed", "unpayushed", " unpathed", " unpached", "Unpatized", "unpatchced", " unpched", " unmathed", "Unpatatched", "unpathed", "unminched", " unpatatched", "unpatached", " unpatced", " unpatching", "Unpatchized", " unmatched", "unpushed", "unfethed", "unpched", "unpatized", "Unpatchched", "Unpatchhed", "unPatching", "unbatchhed", "unminached", "unbatchatched", "unpayized"], "result_size": ["result_store", "result32size", " result_sum", "resultityoffset", " result_length", "result32name", "resultptsign", "resultitysign", " result_store", "resultptsize", "result_sum", "resultLsize", "response_offset", "Result_sent", "Result_size", "result_type", "Result_Size", "Result_sized", "result32sum", "resultitytimeout", "result_sent", "result_name", "resultitysize", "result_loc", "Result_type", "result_offset", "resultLoffset", "resultpttimeout", "result_timeout", "result_Size", "result_length", "resultptoffset", "response_timeout", " result_name", "response_sign", "result_sized", " result_offset", "resultLstore", " result_loc", "result_sign", "Result_name", "result32loc", " result_type", "response_size"], "byte_list": ["byte2list", "byte9list", "Byte2List", "byte2List", "byte9LIST", "Byte_list", "byte_pre", "byte_List", " byte_LIST", "byte_len", "display_LIST", "attributeedpre", "byte67len", " byte_listed", "attributeedlisted", "bytes_list", "byte64string", "bytes_listed", "byte64List", "byte32listed", "byteedlisted", "byte8list", "byte5list", "display_len", "display_list", "byte8listed", "byte2string", "byteedlist", "Byte_string", "byte9listed", "byte32List", "byte64list", "byte8LIST", "attribute_pre", "byte_listed", "display_listed", "attribute_List", "Byte2LIST", "byte5listed", "attributeedlist", "Byte_List", "byte32list", "Byte2string", "attributeedList", "byte67list", "byte8print", "bytes_print", "byte_string", "byte67LIST", "bytes_LIST", "byte64LIST", "byte32pre", "byteedpre", "byte5LIST", "byte5print", "byte_LIST", "byte2LIST", "Byte_LIST", "byte_print", "byteedList", "Byte2list", "attribute_list", "attribute_listed", "byte67listed", "byte9len"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n\tVNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n\treturn NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n", "idx": 19116, "substitutes": {"anon_cred": ["anon_Cid", "anon_Cord", "anon_cld", "anon_acld", "anon_thed", "anon_acord", "anon_sced", "anon_cret", "anon_csld", "anon_scret", "anon_acred", "anon_decid", "anon_ttx", "anon_dectx", "anon_tld", "anon_csged", "anon_Cred", "anon_tged", "anon_scred", "anon_aced", "anon__Cret", "anon_scord", "anon_tred", "anon_acged", "anon__cord", "anon__aced", "anon_scid", "anon_ched", "anon_cord", "anon__acord", "anon__cld", "anon__Cred", "anon__cred", "anon_decord", "anon__Cid", "anon_cid", "anon__acld", "anon_ached", "anon_decred", "anon_decret", "anon__acred", "anon_cged", "anon__ced", "anon_Cret", "anon__cid", "anon_scld", "anon_cshed", "anon__Cord", "anon_Ctx", "anon__cret", "anon_csred", "anon_ctx", "anon_ced", "anon_tid"], "ret": ["mem", "mel", "res", "nt", "t", "back", "deg", "git", "store", "result", "ll", "Ret", "vet", "rt", "tmp", "fail", "tr", "mt", "ct", "out", "v", "reg", "inter", "cont", "lt", "ft", "rem", "cat", "RET", "re", "det", "ref", "r", "val", "def", "rets", "print", "alt", "aux", "x", "len", "resp", "gt", "code", "ctr", "elt", "status", "red", "err"]}}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 19119, "substitutes": {"bs": ["hs", "ds", "cs", "lbs", "os", "boxes", "fps", "outs", "bits", "sb", "BS", "blog", "hz", "ubs", "bh", "bp", "banks", "bps", "uts", "gs", "ss", "bc", "aus", "ubis", "ns", "bytes", "sts", "vs", "bos", "bl", "ps", "bes", "iss", "js", "sys", "obs", "cks", "fs", "acs", "ashes", "ts", "aos", "ls", "asis", "us", "ms", "b", "bis", "its"], "offset": ["pos", "Offset", "index", "error", "os", "seed", "location", "slot", "set", "shift", "end", "base", "zero", "op", "prefix", "seek", "off", "address", "scroll", "start", "pointer", "addr", "reset", "id", " offsets", "ref", "origin", "oid", "o", "top", "key", "attribute", "row", "url"], "nb_clusters": ["nbolyexplusters", "nb__plients", "nb_clocations", "nb_cllicts", "nb_CLusters", "nb_allusters", "nb_plusters", "nb_Closes", "nb_chicas", "nb_Cllicts", "nb_splodes", "nb__pliques", "nbolyexploses", "nb_splust", "nb_flions", "nb_recions", "nb_codes", "nb_chusters", "nb_clicas", "nb_aclusters", "nb_cluster", "nb_clodes", "nbolyexpluster", "nb_groupsust", "nb_cients", "nb__clusters", "nb_Clust", "nb_closes", "nb_chions", "nb_pliques", "nb_aclibraries", "nb_custers", "nb_Closures", "nb_calusters", "nb5clicas", "nb_callicts", "nb_recusters", "nb_CLores", "nb5chusters", "nb__plusters", "nb__clients", "nb_ciques", "nb_plients", "nb_chocations", "nb_spliques", "nbolyclusters", "nb5clocations", "nb_expllicts", "nbolycluster", "nb_recocations", "nb_clores", "nb_clust", "nb_flicas", "nbolycllicts", "nb_splosures", "nb_clibraries", "nb__clodes", "nb_flusters", "nb_allodes", "nb_allores", "nb_closures", "nb_caluster", "nb_splients", "nbolyexpllicts", "nb_groupsosures", "nb5chicas", "nb_exploses", "nb_aclodes", "nb5chions", "nb_clients", "nb_caloses", "nb_groupsusters", "nb_recicas", "nb_explusters", "nbolycloses", "nb_CLodes", "nb_cliques", "nb_CLibraries", "nb_expluster", "nb5clusters", "nb__cliques", "nb_spluster", "nb_Clusters", "nb_groupsuster", "nb5chocations", "nb_aclores", "nb_plodes", "nb__plodes", "nb_flocations", "nb5clions", "nb_splusters", "nb_Cluster", "nb_allibraries", "nb_clions"], "s": ["ies", "hs", "ds", "cs", " ss", "sam", "os", "bits", "sb", "p", "sp", "ses", "ins", "aws", "h", "qs", "is", "ares", "sv", "rs", "gs", "sa", "S", "ss", "ns", "sts", "vs", "ps", "sys", "http", "js", "spec", "ats", "fs", "acs", "ts", "ssl", "ls", "parts", "ims", "stats", "serv", "b", "bis", "its"], "l2_table": ["l2_TABLE", "l2phptable", "l4_result", "l2phpaddress", "l2__array", "l2prodatabase", "l2____TABLE", "l2__table", "l1_table", "l2__column", "l2iptable", "l2Ttable", "l2_header", "l2_database", "l2ipmaster", "l3_key", "l4_address", "l3_page", "l2___table", "l2__key", "l2propage", "l2_result", "l3_header", "l2ipcache", "l2_column", "l3_TABLE", "l3_cache", "l2__TABLE", "l2____tab", "l2_master", "l1_cache", "l2phptab", "l2__tab", "l2phpresult", "l2_cache", "l4_table", "l1_column", "l3_table", "l2____header", "l3_master", "l2_address", "l2ipblock", "l4_tab", "l2protable", "l2_tab", "l2___cache", "l2Tsize", "l2__cache", "l3_array", "l2procache", "l3_size", "l2_size", "l3_database", "l3_tab", "l3_block", "l2Ttab", "l2___block", "l2_block", "l2__size", "l2TTABLE", "l2_page", "l2_key", "l1_TABLE", "l2_array", "l2___master", "l2____table"], "l2_index": ["l3_Index", "l2_icon", "l2_i", "l1_Index", "l22available", "l2___prefix", "l2_prefix", "l2eicon", "l120istindex", "l1_index", "l2___index", "l2eindex", "l120_index", "l2_count", "l22status", "l2_path", "l22_available", "ltwo_index", "l2_open", "l2_available", "l2_status", "l2tindex", "ltwo_int", "l120isti", "l22_status", "l2__int", "l2__ind", "l120_seed", "l120istseed", "l2tstatus", "l2tavailable", "l2_Index", "l1_id", "l120_i", "l3_index", "l2isti", "l2_rank", "l2___seed", "l3_open", "l2___i", "l2istindex", "l22initial", "l22_index", "l120istprefix", "l3_count", "l2istprefix", "l2ecount", "ltwo_ind", "l2istseed", "l2_seed", "l2eIndex", "l22index", "l22_initial", "l2__path", "l2_ind", "l120_prefix", "ltwo_path", "l2__index", "l2_int", "l2_initial", "l3_icon", "l2_id", "l1_rank", "l2tinitial"], "ret": ["details", "dt", "report", "rt", "nz", "iter", "sys", "cat", "pat", "er", "ert", "cert", "net", "rets", " RET", "flag", "result", "ry", "ber", "RET", "reset", "re", "reply", "try", "usr", "resp", "it", "elt", "after", "err", "rm", "res", "nt", "pret", "ter", "over", "rect", "expr", "tr", "mt", "reg", "lt", "ft", " Ret", "mber", "det", "att", "def", "print", "alt", "txt", "ail", "gt", "utils", "arr", "deg", "git", "ort", "out", "cont", "rem", "rev", "cmd", "ext", "lit", "val", "et", "uf", "lag", "red", "Ret"], "i": ["ic", "index", "ij", "si", "ci", "im", "hi", "ei", "ki", "qi", " ti", "me", "li", " pi", "span", "\u0438", "ri", "is", "I", " ii", "ai", "phi", " index", " multi", "di", "cli", "io", " mi", "ip", "mi", "pi", "oi", "ind", " j", "json", "j", "xi", "id", "in", "ti", "ui", "batch", "gi", "uli", " I", "ji", "uri", "multi", "dim", "complete", "bi", "x", "info", " si", "asi", " ni", " m", "zi", " err", "ini", " bi", "sim", "by", "f", "it", "ix", "us", "series", "iu", "y", "ii", "m"], "old_offset": ["old_key", "old7offset", "old_point", "old_Offset", "old_off", "new_block", "old___pointer", "new_offset", " old_key", "old___off", "old_block", "old7rot", "old___key", "oldxOffset", "old___rot", "new_attribute", "oldTheoffset", "old_loc", "oldxoffset", "oldTheblock", "Old_offset", "oldamattribute", "oldTheattribute", "old_rot", "Old_rot", "old7off", "Old_pointer", "old___Offset", "old___offset", "old7pointer", "oldamoffset", "old_pointer", "old_attribute", "Old_off", "oldamblock", " old_point", " old_Offset", " old_loc", "oldxpoint", "old___loc"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    S390pciState *s = opaque;\n\n\n\n    return &s->pbdev[PCI_SLOT(devfn)].as;\n\n}\n", "idx": 19126, "substitutes": {"bus": ["box", "board", "bridge", "used", "back", "proc", "bur", "mount", "device", "bs", "usb", "bc", "clus", " Bus", "bit", "Bus", "BUS", "dev", "uses", " BUS", "block", "cus", " buses", "book", "chain", "us", "boot", "loop"], "opaque": ["optsolete", "oppsolete", " opse", "ipossus", "OPsolete", "ipse", " opque", "opse", " opossus", "opsolete", "OPque", "opaco", "oopaque", "OPaco", "oppaco", "ipque", "oppque", "optaque", "oppaque", "optaco", "oopse", "optque", "ipaque", "opque", "opossus", "OPaque", "oopossus", "oopque"], "devfn": ["devicefn", "ndFN", " devnon", " devicenm", "devicenm", "devicepath", " devicenon", "Devfn", "devnm", " devFN", " devicefn", " devicepath", " devpath", " devname", "devFN", "devpath", "devnon", "devname", "devicenon", " devnm", "ndname", "Devname", "DevFN", "ndfn"], "s": ["a", "ds", "l", "z", "t", "i", "p", "sb", "ess", "ses", "als", "sq", "h", "sm", "is", "e", "sv", "rs", "gs", "S", "ss", "d", "sts", "ns", "v", "ps", "c", "j", "r", "o", "n", "sol", "state", "ts", "ssl", "ls", "sac", "f", "sis", "sl", "b", "y", "m"]}}
{"project": "qemu", "commit_id": "7b899f4dd596dbb7d271f7fab36fbfffec84868e", "target": 0, "func": "static void test_info_commands(void)\n\n{\n\n    char *resp, *info, *info_buf, *endp;\n\n\n\n    info_buf = info = hmp(\"help info\");\n\n\n\n    while (*info) {\n\n        /* Extract the info command, ignore parameters and description */\n\n        g_assert(strncmp(info, \"info \", 5) == 0);\n\n        endp = strchr(&info[5], ' ');\n\n        g_assert(endp != NULL);\n\n        *endp = '\\0';\n\n        /* Now run the info command */\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", info);\n\n        }\n\n        resp = hmp(info);\n\n        g_free(resp);\n\n        /* And move forward to the next line */\n\n        info = strchr(endp + 1, '\\n');\n\n        if (!info) {\n\n            break;\n\n        }\n\n        info += 1;\n\n    }\n\n\n\n    g_free(info_buf);\n\n}\n", "idx": 19128, "substitutes": {"resp": ["next", "init", "pos", "res", "Resp", "nt", "p", "tx", "sp", "result", "ctx", "ret", "fr", "vp", "Response", "rec", "rep", "cli", "obj", "response", "ps", "esp", "conn", "rev", "req", "msg", "re", "cmd", "body", "rel", "ref", "r", "jp", "comm", "cmp", "repl", "txt", "par", "respond", "comp", "serv", "status", "err"], "info": ["iso", "loc", "error", "ok", "about", "hi", "valid", "details", "shift", "good", "rt", "interesting", "iter", "kind", " Info", "req", "inner", "diff", "cache", "check", "index", "inf", "none", "safe", "list", "where", "end", "ret", "zero", "unknown", "start", "doc", "tip", "msg", "json", "update", "skip", "try", "fi", "entry", "f", "it", "show", "status", "init", "help", "more", "total", "comment", "num", "only", "query", "Info", "information", "name", "all", "ip", "addr", "time", "fo", "recent", "def", "ignore", "str", "notice", "source", "txt", "state", "row", "by", "nr", "debug", "nice", "history", "stable", "used", "i", "p", "ready", " INFO", "count", "empty", "op", "off", "important", "success", "data", "INFO", "id", "now", "key", "par", "full", "comp", "parse", "conf", "trace", "type"], "info_buf": ["info2limit", " info2uf", "inf_box", " info_map", "info___uf", " info_limit", " info_uf", " info2limit", "inf_cb", "info2buff", " info2buff", "info2uf", "info_uf", "info_box", "info_map", "info___buff", "info_limit", "info___buf", " info2buf", "inf_uf", "info_cb", "info___limit", "inf_buf", "info2buf", " info_buff", "info_buff"], "endp": ["endv", "Endpt", "restpos", "appendpoint", "endercp", "restP", "rendp", "enderpat", "pendcp", " endpt", "endedP", "endedv", "appendp", "endpoint", "endpos", "pendp", "Endv", "enderp", "appendpt", "gatep", "Endcp", "gatev", "endpt", "endedpt", "pendpat", " endpoint", "pendP", "enderP", "endedpos", "endpat", "endP", " endpos", "rendP", "EndP", " endP", "restp", "endedp", "rendpt", "gatept", "Endpat", "endcp", "gateP", "rendpoint", "Endp", "restpt", "appendP"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n", "idx": 19129, "substitutes": {"s": ["sc", "hs", "ds", "cs", "os", "t", "sg", "w", "i", "sb", "p", "as", "ses", "ins", "sq", "h", "sm", "set", "ctx", "qs", "is", "bs", "g", "south", "sv", "rs", "gs", "S", "ss", "d", "sw", "ns", "sts", "ties", "se", "self", "sports", "sys", "sn", "js", "ps", "c", "in", "es", "comm", "fs", "less", "ts", "x", "ims", "ls", "an", "stats", "us", "ex", "sl", "b", "its"], "type": ["p", " typ", "test", "e", "ype", "ct", "name", "kind", "typ", " ty", "re", "target", "cmd", "id", "TYPE", "ref", "tag", "et", "o", "y", "state", "Type", " Type", "pe", "ty", "event", "class"], "ret": ["mem", "res", "nt", "arr", "t", "flag", "result", "ry", "rt", "op", "tmp", "prop", "mt", "out", "reg", "Return", "obj", "RET", "rev", "re", "cmd", "target", "reply", "lit", "ref", "r", "val", "def", "rets", "usr", "alt", "aux", "repl", "null", "resp", "rc", "f", "buffer", "fun", "gt", "err", "Ret"], "arg": ["mem", "res", "arr", "or", "ag", "args", "t", "flag", "ax", "p", "agg", "ar", "gc", "ob", "g", "op", "name", "m", "pg", "mb", "v", "reg", "out", " args", "obj", "param", "cmd", "target", "in", "ext", "argument", "ref", "r", "tag", "val", "new", "def", "key", "orig", "ack", "pl", "Arg", "gt", "it", "b", "err", "ig"], "old_code_ptr": ["old_codeprops", "old_code_Ptr", "old_cache_ptr", "old_codeproptr", "old_code_addr", "old_Code_pointer", "old_Code_ptr", "old_cache_Ptr", "old_code_pointer", "old_code_ps", "old_code_pt", "old_cache_store", "old_codeprostore", "old_codes_pt", "old_Code_tip", "old_Code_addr", "old_cache_ps", "old_codeproPtr", "old_code_store", "old_codes_pointer", "old_codes_ptr", "old_code_tip", "old_codes_addr"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 19133, "substitutes": {"s": ["bits", "details", "g", "rs", "conv", "vs", "self", "obj", "sys", "c", "es", "comm", "fs", "er", "spec", "sl", "os", "ops", "t", "sp", "set", "qs", "S", "ss", "sts", "v", "ps", "https", "n", "ts", "ls", "parts", "ads", "stats", "bes", "bis", "status", "err", "a", "ies", "ds", "cs", "sam", "l", "sb", "as", "ses", "changes", "als", "sv", "sw", "http", "js", "gets", "ssl", "tests", "b", "y", "hs", "i", "ins", "aws", "h", "is", "bs", "gs", "out", "ports", "ns", "sports", "ats", "less", "ims", "ms", "full", "conf", "its"], "p": ["lp", "np", "dp", "t", "wp", "phy", "i", "w", "ping", "pp", "sp", "q", "h", "bp", "pc", "g", "op", "vp", "press", "tp", "d", "rep", "v", "pro", "pb", "ip", "ps", "tip", "mp", "data", "c", "pkg", "up", "j", "r", "jp", "post", "o", "gp", "x", "pre", "pa", "cp", "php", "f", "it", "fp", "P", "b", "ap", "m"], "request": ["QUEST", "frame", "question", "input", "query", "q", "set", "change", "point", "requ", "prefix", "command", "reason", "seek", "address", "method", "position", "reference", "push", "get", "read", "response", "call", "reset", "req", "cmd", "access", "re", "order", "r", "message", "quest", "hello", "claim", "Request", "buffer", "version", "event", "task"], "value": ["see", "ue", "VALUE", "result", "ceive", "set", "change", "action", "volume", "output", "property", "command", "length", "save", "values", "content", "Value", "address", "position", "unit", "v", "variable", "get", "ve", "response", "example", "description", "data", "json", "operator", "val", "message", "hello", "number", "key", "vector", "attribute", "function", "buffer", "version", "multiple", "sample"], "index": ["offset", "pos", "size", "i", "num", "timeout", "input", "query", "end", "find", "ion", "point", "prefix", "link", "Index", "length", "address", "position", "seek", "axis", "image", "reference", "iter", "success", "document", "order", "data", "update", "ind", "id", "ref", "condition", "val", "context", "number", "connect", "key", "x", "open", "row", "len", "code", "status"]}}
{"project": "qemu", "commit_id": "a193b0f0a8d7735f4eb2ff863fd0902a5fa5eec6", "target": 0, "func": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,\n\n                                      int64_t offset, uint64_t bytes,\n\n                                      bool *error_is_read,\n\n                                      bool is_write_notifier)\n\n{\n\n    BlockBackend *blk = job->common.blk;\n\n    CowRequest cow_request;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    void *bounce_buffer = NULL;\n\n    int ret = 0;\n\n    int64_t start, end; /* bytes */\n\n    int n; /* bytes */\n\n\n\n    qemu_co_rwlock_rdlock(&job->flush_rwlock);\n\n\n\n    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);\n\n    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);\n\n\n\n    trace_backup_do_cow_enter(job, start, offset, bytes);\n\n\n\n    wait_for_overlapping_requests(job, start, end);\n\n    cow_request_begin(&cow_request, job, start, end);\n\n\n\n    for (; start < end; start += job->cluster_size) {\n\n        if (test_bit(start / job->cluster_size, job->done_bitmap)) {\n\n            trace_backup_do_cow_skip(job, start);\n\n            continue; /* already copied */\n\n        }\n\n\n\n        trace_backup_do_cow_process(job, start);\n\n\n\n        n = MIN(job->cluster_size, job->common.len - start);\n\n\n\n        if (!bounce_buffer) {\n\n            bounce_buffer = blk_blockalign(blk, job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,\n\n                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = blk_co_pwrite_zeroes(job->target, start,\n\n                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = blk_co_pwritev(job->target, start,\n\n                                 bounce_qiov.size, &bounce_qiov,\n\n                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        set_bit(start / job->cluster_size, job->done_bitmap);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->bytes_read += n;\n\n        job->common.offset += n;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, offset, bytes, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n", "idx": 19160, "substitutes": {"job": ["error", "report", "journal", "problem", "mb", "pro", "manager", "common", "jp", "sync", "line", "Job", "project", "module", "day", "jump", "com", "jar", "build", "exec", " Job", "connection", "server", "item", "emb", "app", "program", "command", "tab", "up", "obs", "low", "entry", "mor", "org", "status", "event", "task", "jj", "comment", "sb", "sub", "user", "node", "match", "band", "bug", "cor", "order", "j", "rb", "state", "info", "block", "row", "cp", "scan", "process", "pixel", "work", "this", "pause", "cell", "store", "ob", "config", "jobs", "image", "db", "web", "vm", "param", "cmd", "record", "tag", "batch", "member", "jam", "pair", "package", "cb", "sim", "conf"], "offset": ["init", "pos", "index", "Offset", "error", "location", "size", "slot", "timeout", "shift", "base", "output", "count", "delay", "op", "padding", "length", "alloc", "position", "address", "off", "seek", "stop", "image", "mask", "addr", "bit", "order", "data", "reset", "id", "rot", " offsets", "ref", "origin", "root", "et", "oot", "align", "bound", "info", "block", "unk", "row", "len", "buffer", "transfer", "byte", "hop"], "bytes": ["ies", "xff", "ops", "blocks", "memory", "units", "size", "offs", "os", "bits", "classes", "total", "les", "Bytes", "lines", "bps", "bs", "users", "points", "gs", "length", "files", "odes", "pages", "eks", "ips", "values", "jobs", "done", "address", "limit", "keys", "tes", "loads", "es", " offsets", "steps", "options", "rows", "maps", "errors", "reads", "abytes", "parts", "len", "heads", "items", "byte", "seconds"], "error_is_read": ["error_is_error", "error_type_reader", "error_is_write", "error_type_readable", "error_Is_readable", "error_is_readable", "error_type_write", "error_Is_read", "error_is__readable", "error_type_read", "error_Is_write", "error_is_reader", "error_is__read", "error_is__write"], "is_write_notifier": ["is_write_notified", "is_write_vertifer", "is_write_noicator", "is_write_noteicator", "is_write_noiger", "is_write_noteify", "is_write_noifer", "is_write_noified", "is_write_noteiger", "is_write_noteifier", "is_write_vertified", "is_write_notifer", "is_write_notiger", "is_write_critifier", "is_write_critifer", "is_write_critify", "is_write_noifier", "is_write_verticator", "is_write_vertifier", "is_write_noticator", "is_write_critiger", "is_write_noteifer", "is_write_noify", "is_write_notify", "is_write_noteified"], "blk": ["BLk", "blck", "bltk", "brk", "clck", "lbg", "clak", "blke", "brotk", "brok", "lbck", "lbk", "bleck", "brck", "plak", "glk", "brock", "glck", " bltk", "bleg", "clk", "blek", " blg", "BLke", "clke", "bleak", " blak", "lbak", "blg", "broak", "blak", "BLck", "BLtk", "brak", "glak", "BLak", "glke", "plk", "plg", " blck", "plck", "brg"], "cow_request": ["Cow_param", "Cow_command", "cowthequery", "Cow_request", "cowtherequest", "cowpycommand", "cow_query", "cow_req", "cowpyreq", "cowthereq", "Cow_query", "Cow_req", "cowpyrequest", "cowtheparam", "cow_param", "cow_command"], "iov": ["cv", "ieu", "ij", "hero", "yon", "intelligence", " mor", " supporters", " multimedia", "iev", " fav", "iw", "imp", " unim", " trou", "iop", "uj", "voice", "vec", " terr", "vp", "ovi", "virt", "iour", "river", "meyer", "establishment", "rov", "ilo", "conv", "iq", " morale", "ivic", "iv", "tv", " vib", "chrom", " rav", "ichael", "inv", "veh", "iological", " vibe", " mus", "nov", "voc", "isco", " volley", "rio", "Iv", "icon", "vector", "hovah", "vo", " bio", "liv", "vr", "serv", "iol", "minecraft", "iva", "drm", " civ", "dq"], "bounce_qiov": ["bounce_qiour", "bounce_qqiour", "bounce_quibr", "bounce2qqiour", "bounce_sqiev", "bounce_piour", "bounce_veiour", "bounce_dqiour", "bounce2qqiol", "bounce_quiop", "bounce_sqiov", "bounce2qiour", "bounce_qqiev", "bounce2qqiop", "bounce_piov", "bounce_qiop", "bounce_qqiol", "bounce2qiov", "bounce2qiol", "bounce2qiop", "bounce2qqiov", "bounce_sqiop", "bounce_piop", "bounce_qiev", "bounce_dqiev", "bounce_veiop", "bounce_qqiv", "bounce_pvoice", "bounce_quiour", "bounce_sqiv", "bounce_dqiv", "bounce_qqiop", "bounce_qvoice", "bounce_qiv", "bounce_dqiov", "bounce_veiov", "bounce_qqvoice", "bounce_quiov", "bounce_dqiol", "bounce_veibr", "bounce_qqiov", "bounce_dqiop", "bounce_qiol", "bounce_dqvoice", "bounce_qibr", "bounce_qqibr"], "bounce_buffer": ["bouncematmap", "bounce_base", "bounce2buff", "bounce2base", "bouncing_address", "bouncing_map", "bounce___map", "bouncing_buf", "bounce___buff", "bouncebleavailable", "bouncing_buff", "bounce2buffer", "bounce___address", "bounceblebuff", "bouncing_buffer", "bouncematbuff", "bouncebleBuffer", "bounce___buffer", "bounced_document", "bounced_available", "bouncematbuffer", "bounced_buff", "bounce2document", "bounce_document", "bounceblebuffer", "bounced_buffer", "bounce_buf", "bounce_Buffer", "bounce_address", "bouncing_Buffer", "bounce_buff", "bounce_map", "bounce2Buffer", "bounce2buf", "bounced_Buffer", "bouncemataddress", "bounced_base", "bounce_available"], "start": ["prep", "size", "pad", "st", "shift", "base", "e", "step", "stop", "iter", "get", "kind", "first", "c", "origin", "art", "rank", "space", "pre", "wind", "boot", "check", "index", "use", "t", "ish", "sp", "set", "starting", "seek", "add", "reset", "skip", "try", "root", "x", " Start", "from", "entry", "rest", "it", "part", "begin", "init", "a", "Start", "match", "address", "head", "addr", "time", "j", "row", "ix", "next", "pos", "pause", "p", "before", "store", "we", "at", "power", "position", "started", "in", "id", "new", "current", "now", "top", "key", "create"], "end": ["export", "until", "index", "ue", "eng", "ord", "size", "and", "max", "close", "endif", "en", "edge", "set", "e", "append", " End", "send", "off", "stop", "fin", "wrap", "all", "ew", "limit", "get", "add", "ending", "order", "up", "entity", "ext", "id", "ell", "est", "eff", "enable", "End", "bound", "ent", "END", "ended", "nd", "except", "begin", "after", "ff", "ek"], "n": ["na", " N", "nt", "np", "l", "size", "t", "w", "z", "i", "p", "num", "en", "cn", "ne", "count", "g", "ni", "mn", "out", "d", "v", "ns", "nn", "sn", "nb", "c", "nu", "nl", "j", "r", "o", "N", "nan", "nm", "nc", "len", "nd", "it", "b", "y", "min", "m"]}}
{"project": "qemu", "commit_id": "d157ed5f7235f3d2d5596a514ad7507b18e24b88", "target": 0, "func": "static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n", "idx": 19184, "substitutes": {"bs": ["bm", "hs", "ds", "cs", "lbs", "os", "outs", "bits", "sb", "BS", "bb", "ubs", "bp", "qs", "rs", "gs", "ss", "bc", "aus", "ubis", "sts", "ns", "vs", "bl", "bos", "obs", "fs", "acs", "bi", "ts", "aos", "ls", "b", "bis", "its", "bn"], "rule": ["priority", "require", "error", "style", "rol", "item", "word", "comment", "definition", "p", "test", "decl", "feature", "tle", "Rule", "e", "fr", "ace", "ULE", "rules", "law", "command", "run", "match", "node", "rr", "group", "statement", "rec", "link", "se", "trigger", "that", "http", "call", "service", "order", "range", "role", "re", "document", "operator", "record", "event", "scope", "r", "tag", "line", "fire", "key", "module", "state", "request", "sche", "block", "token", "row", "ro", "function", "ule", "filter", "policy", "pe", "spec", "parse", "task", "rl"], "s": ["hs", "ds", "cs", "os", "t", "i", "p", "sb", "sp", "ses", "sq", "h", "sm", "sv", "rs", "gs", "sa", "S", "ss", "v", "sts", "ns", "ps", "js", "c", "j", "fs", "state", "ts", "ims", "ls", "sis", "b"]}}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        /* Set the device in I/O access mode */\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        /* read mode */\n\n        switch (cmd) {\n\n        case 0x00: /* ??? */\n\n            goto reset_flash;\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: /* Block erase */\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; /* Block erase error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0x50: /* Clear status bits */\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: /* Block (un)lock */\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: /* Status Register */\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: /* Read Device ID */\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: /* CFI query */\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: /* Write to buffer */\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0xf0: /* Probe for AMD flash */\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: /* Read array mode */\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: /* Block erase */\n\n        case 0x28:\n\n            if (cmd == 0xd0) { /* confirm */\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { /* read array mode */\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    /* Flush the entire write buffer onto backing storage.  */\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; /* Programming error */\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: /* Confirm mode */\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen */\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n", "idx": 19198, "substitutes": {"pfl": [" pcl", " pflight", "npfl", "Pfin", "paiflush", " pjet", "lpfr", "patkl", "pkgfol", "pkgFl", "paifl", "lpFl", "phpflat", "pfil", "jpflight", "pflat", " pfi", "pflight", " ppl", "ipfl", "cpfd", " pkl", "pingfl", "phpbm", "lpilot", " pgl", "cpflo", "apfl", "pbfl", " pFl", "jpfl", "cpflow", "patchfl", "privatefin", "lpflo", "dpFl", "lpplane", "Pfr", "perfl", "pwl", "dpfil", "privatefl", "formflo", "pject", "lpsw", "privateflo", "percl", "pingfol", "pingfr", "pcl", "Psw", "phpflight", "dpplane", "phpwl", " pcompl", "pajet", "lpject", " pfc", "Pfl", " pflat", " pfin", "phpilot", "pbm", "paflush", "pingpol", " pfd", "lpfl", "pbpl", " pfol", "pfc", "pingFl", " pfil", "powerwl", " pform", "pafil", "privatefr", "Pgl", "pafl", "phpkl", "pfin", "pvl", "npvl", "cpwl", "pbfr", " plf", "pFl", "jpflat", "jpfc", "patchflight", "pfr", "paiform", "paifil", " poft", "npsw", "jpfi", "apfr", "npprot", "pbfil", "phpfl", " psw", "pjet", "lpflight", "paform", "perfr", "cpcompl", "dpfl", "phpplane", "pflow", "pcompl", "phpsw", "patchfr", "phpject", "pkgfl", "patfl", "ppl", " pfp", "ppol", "pingflow", "formfl", "pkgcompl", " pvl", "patbm", "patchoft", " pfr", "pawl", "pform", " pwl", "cpfil", "ipfr", "lplf", "phpcompl", "lpcl", "cpfol", "phpfc", "pkl", "pprot", " ppol", "apoft", "cpfr", "Pflo", "phpvl", "lpgl", "jppol", "psw", "powerfd", "pilot", "dpflo", "pfol", "phpform", "lpfp", "ippl", "formfp", "pflo", "dplf", "phpjet", "pfp", " pprot", "cpFl", " pplane", "pflush", "pfd", "apflight", "pfi", "formflight", "lpcompl", "phpprot", "powerflo", " pflow", "pplane", "pgl", "poft", "powerfl", "pingfi", " pilot", "jpFl", "patplane", " pflo", " pbm", " pflush", "plf", "cpfl", "perflight", " pject", "ipfil"], "offset": ["pos", "xff", "Offset", "index", "loc", "error", "location", "z", "offs", "size", "w", "slice", "pad", "i", "slot", "sp", "ow", "h", "at", "set", "end", "shift", "point", "op", "padding", "command", "length", "mt", "position", "off", "address", "seek", "scroll", "start", "pointer", "ptr", "mask", "ip", "addr", "pt", "rot", "ref", "height", "origin", "et", "oid", "o", "align", "path", "af", "attribute", "row", "from", "buffer", "f", "fp", "b", "ff", "hop"], "value": ["mem", "index", "ue", "b", "memory", "size", "t", "w", "VALUE", "weight", "format", "input", "text", "set", "shift", "buf", "op", "vp", "length", "values", "Value", "address", "name", "position", "wrap", "v", "start", "hw", "data", "update", "field", "val", "current", "raw", "vector", "attribute", "block", "function", "buffer", "create", "byte", "type"], "be": ["ength", "Offset", " align", " error", " bytes", " start", " count", " mode", "end", "op", " begin", " address", "off", " index", "bit", " enable", " capacity", "ize", " height", "enabled", " stride", " off", "ode", " hop", "block", " depth", " b", "byte"], "p": ["pos", "lp", "l", "t", "w", "wp", "i", "pp", "sp", "h", "q", "bp", "pc", "g", "point", "op", "vp", "tp", "pro", "v", "pb", "ps", "c", "pt", "j", "r", "jp", "ph", "o", "n", "x", "pa", "s", "cp", "f", "fp", "P", "b", "ap", "m"], "cmd": ["ctx", "crit", "vp", "kw", "MD", "cd", "obj", "kind", "bit", "req", "comm", "dc", "mem", "index", "np", "flag", "desc", " command", "hold", "command", "handle", "ct", "force", "cli", "mask", "msg", "pkg", "resp", "bind", "fun", "urg", "code", "ctr", "status", "mode", "err", "help", "init", "nt", "opt", "term", "buf", "xp", "cut", "prop", "ip", "addr", "target", "cmp", "cfg", "def", "act", "state", "txt", "nd", "cp", "quit", "text", "canon", "md", "xy", "count", "config", "op", "reason", "control", "Cmd", "conn", "ind", "func", "id", "batch", "cod", "key", "cb"], "wcycle": ["hwsync", "wcc", "hwcycle", "Wcycles", "hwcycles", "wcount", "wdcle", "Wcycle", "swcle", "swcycle", "hwcc", "Wcode", "wdcycles", "wcle", "hcycles", "wdcycle", "Wcle", "hcle", " wcount", "hcycle", "wsync", "Wsync", "wcode", " wcc", " wsync", "hwcle", "swcode", "Wcc", "wcycles", "hwcount", "swcycles", "hcode", "Wcount", "wdcode", "hwcode"]}}
{"project": "qemu", "commit_id": "4c055ab54fae39b6329c57bcb5334d59b920463e", "target": 0, "func": "int kvm_init_vcpu(CPUState *cpu)\n\n{\n\n    KVMState *s = kvm_state;\n\n    long mmap_size;\n\n    int ret;\n\n\n\n    DPRINTF(\"kvm_init_vcpu\\n\");\n\n\n\n    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));\n\n    if (ret < 0) {\n\n        DPRINTF(\"kvm_create_vcpu failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_fd = ret;\n\n    cpu->kvm_state = s;\n\n    cpu->kvm_vcpu_dirty = true;\n\n\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (mmap_size < 0) {\n\n        ret = mmap_size;\n\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\n                        cpu->kvm_fd, 0);\n\n    if (cpu->kvm_run == MAP_FAILED) {\n\n        ret = -errno;\n\n        DPRINTF(\"mmap'ing vcpu state failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {\n\n        s->coalesced_mmio_ring =\n\n            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;\n\n    }\n\n\n\n    ret = kvm_arch_init_vcpu(cpu);\n\nerr:\n\n    return ret;\n\n}\n", "idx": 19204, "substitutes": {"cpu": ["mac", "ck", "uu", "lib", "ctx", "setup", "ace", "copy", "tp", "nz", "sys", "c", "bench", "jp", "aux", "cache", "net", "boot", "mem", "cv", "np", "uart", "program", "device", "ruby", "pu", "cli", "hw", "reset", "pkg", "cu", "cum", "cs", "nic", "linux", "total", "proc", "node", "ka", "clock", "processor", "docker", "runner", "gpu", "upt", "kernel", "cp", "php", "process", "utils", "component", "phy", "i", "p", "remote", "pid", "pc", "core", "gc", "util", "u", "library", "socket", "vm", "conn", "foo", "pool", "prof", "aq", "du", "anc", "CPU", "us", "parse", "this", "phys"], "s": ["a", "sc", "services", "hs", "ds", "cs", "states", "os", "si", "t", "w", "args", "i", "p", "sb", "sp", "ses", "changes", "proc", "sq", "store", "aws", "h", "q", "sm", "qs", "is", "bs", "g", "south", "sv", "rs", "gs", "sa", "S", "ss", "so", "conv", "sw", "ports", "sts", "v", "ns", "se", "ps", "sys", "sets", "iss", "js", "spec", "c", "ex", "ssh", "es", "comm", "n", "fs", "less", "space", "acs", "state", "ts", "ssl", "ls", "ims", "sis", "sl", "b", "y"], "mmap_size": ["mmap2size", "mmap67area", "mmmap_count", "mmat_area", "mmap1error", "mmmap_error", "mmap67size", "mmap2SIZE", "mmap67number", "mmapper_len", "mmap2storage", "mmap1set", "mmmap_set", "mmmap_size", "mmap_storage", "mmap_set", "mmap_error", "mmat_number", "mmat67size", "mmap1SIZE", "mmmap_storage", "mmapper_size", "mmap2error", "mmap_SIZE", "mmat67number", "mmmap_Size", "mmmap_sum", "mmmap_SIZE", "mmap_count", "mmap_Size", "mmap_value", "mmap_sum", "mmapper_SIZE", "mmap1storage", "mmap1size", "mmap_len", "mmap_area", "mmat_size", "mmap1count", "mmat_value", "mmap_number", "mmat67value", "mmapper_Size", "mmat67area", "mmap67value"], "ret": ["back", " ar", "dt", "rt", "arg", "g", "nz", "inter", "get", "jp", "cert", "net", "fp", "rets", "mem", " RET", "t", "flag", "result", "ry", "set", "tmp", "RET", "reset", "re", "try", "usr", "fi", "len", "resp", "f", "fun", "it", "elt", "err", "rm", "fd", "res", "nt", "ter", "Ret", "tr", "mt", "ptr", "lt", "ft", " Ret", "addr", "det", "nl", "j", "att", "def", "print", "alt", "gt", " res", " alt", "deg", "git", "ll", "gc", " fut", "out", "Return", "dr", "cont", "rem", "rev", "ext", "ref", "val", "uf", "red"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void arm_cpu_do_interrupt(CPUState *cs)\n{\n    ARMCPU *cpu = ARM_CPU(cs);\n    CPUARMState *env = &cpu->env;\n    unsigned int new_el = env->exception.target_el;\n    assert(!arm_feature(env, ARM_FEATURE_M));\n    arm_log_exception(cs->exception_index);\n    qemu_log_mask(CPU_LOG_INT, \"...from EL%d to EL%d\\n\", arm_current_el(env),\n                  new_el);\n    if (qemu_loglevel_mask(CPU_LOG_INT)\n        && !excp_is_internal(cs->exception_index)) {\n        qemu_log_mask(CPU_LOG_INT, \"...with ESR %x/0x%\" PRIx32 \"\\n\",\n                      env->exception.syndrome >> ARM_EL_EC_SHIFT,\n                      env->exception.syndrome);\n    }\n    if (arm_is_psci_call(cpu, cs->exception_index)) {\n        arm_handle_psci_call(cpu);\n        qemu_log_mask(CPU_LOG_INT, \"...handled as PSCI call\\n\");\n        return;\n    }\n    /* Semihosting semantics depend on the register width of the\n     * code that caused the exception, not the target exception level,\n     * so must be handled here.\n    if (check_for_semihosting(cs)) {\n        return;\n    }\n    assert(!excp_is_internal(cs->exception_index));\n    if (arm_el_is_aa64(env, new_el)) {\n        arm_cpu_do_interrupt_aarch64(cs);\n    } else {\n        arm_cpu_do_interrupt_aarch32(cs);\n    }\n    arm_call_el_change_hook(cpu);\n    if (!kvm_enabled()) {\n        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n    }\n}", "idx": 19216, "substitutes": {"cs": ["hs", "ds", "acts", "tc", "ys", "ck", "ses", "ins", "cell", "ec", "ics", "cases", "otes", "ks", "ctx", "cn", "qs", "cons", "pc", "bs", "gc", "ares", "cas", "caps", "rs", "gs", "cc", "ces", "sts", "ns", "vs", "ps", "ices", "js", "c", "cmd", "css", "ats", "Cs", "cm", "cks", "fs", "acs", "ce", "ts", "ims", "ls", "cus", "s", "cp", "icks", "CS", "cms", "wcs", "ix", "sc"], "cpu": ["mem", "utils", "frame", "cv", "np", "tc", "mac", "os", "server", "linux", "nic", "ck", "sp", "cell", "proc", "ork", "cn", "ctx", "pc", "rom", "core", "gc", "device", "cam", "pu", "onet", "ka", "cc", "stat", "tp", "cli", "thread", "hw", "clock", "vm", "sys", "conn", "c", "mx", "pt", "bench", "cmd", "pool", "jp", "sync", "processor", "gpu", "cu", "exe", "kernel", "nc", "net", "cp", "CPU", "sc", "process"], "env": ["dt", "ctx", "e", "eur", "eas", "vp", "vs", "obj", "era", "sys", "ens", "esp", "inv", "origin", "context", "er", "shell", "net", "ah", "eg", "serv", "environment", "cv", "here", "el", "server", "desc", "en", "eni", "end", "nv", "em", "v", "ew", "doc", "hw", "estate", "dev", "entry", "sc", "worker", " ens", "ds", "console", "ei", "proc", "enc", "esm", "buf", "sv", "ptr", "attr", "addr", " environment", "ev", "viron", "eve", "kernel", "der", "process", "next", "eng", "window", "ec", "config", "esc", "vm", "ve", "conn", "data", "cmd", "ext", "et", "eps", "extra", "cb", "nc", "conf", "eh"], "depend": [" rely", "require", "work", "dependent", "dep", "depending", " depends", "deb", "wait", "osit", "epend", " depending", "based", "independent", "Based", "fail", "ependent", " dependence", "req", "ind", "und", "specific", "project", "reflect", "disable", " based", " dependent", "improve"], "the": ["eth", "expected", "t", "and", "max", "he", "were", "th", "then", "where", "test", "they", "het", "largest", "ing", "we", "there", "te", "on", "what", " The", "_", "general", "application", "length", "match", "unknown", "minimum", "athe", "your", "them", "tf", "get", "each", "that", "you", "any", "document", "my", "to", "new", "some", "current", "non", "ethe", "number", "their", "by", "an", "from", "The", "this", "trace", "type"], "of": ["OF", "Of", "or", "and", "component", "en", "on", "with", "e", "des", "name", "your", "that", "in", "to", "oft", "new", "current", "number", "by", "from", "an", "s"], "caused": ["Caus", "occused", "provused", "occumed", "caurred", "caumed", "provurred", "provus", "Caumed", "Caused", "Caurred", "occurred", "occus", "provumed", "caus"], "exception": ["reption", "xceptor", "Exption", "transception", "xpection", "EXceptions", "transcept", "eyception", "exceptpection", "exceptceptor", "excption", "execpection", "interException", "transpection", "expection", "interaction", "excceptions", "eception", "EXpection", "EXException", "epection", "interceptions", "execcept", "interception", "Exceptions", "exceptions", "eceptor", "exaction", "eaction", "exceptceptions", "eyption", "Expection", "recept", "exeption", "excpection", "eceptions", "excception", "exceptor", "EXption", "exeception", "xception", "eyactly", "execption", "EXception", "exeactly", "xceptions", "EXaction", "exption", "exException", "reception", "transption", "eException", "eactly", "eption", "exceptception", "exepection", "except", "repection", "exactly", "execception", "eypection", "Exception"], "not": ["ont", "or", "t", "probably", "before", "only", "at", "always", "is", "currently", "ot", "all", "than", "unless", "nor", "also", "note", "non", "let", "now", "n", "should", "no", "un", "never"], "target": ["next", "Target", "expected", "specified", "max", "original", "matched", "arget", "match", "minimum", "major", "execute", "inter", "latest", "physical", "master", "generated", "specific", "new", "root", "current", "table", "recorded", "actual", "real", "necessary", "supported", "proxy"], "level": ["priority", "offset", "location", "depth", "scale", "count", "group", "length", "name", "label", "limit", "lvl", "variable", "value", "class", "scope", "local", "line", "file", "print", "path", "sequence", "module", "levels", "Level", "stack", "type"], "so": ["him", "probably", "being", "were", "they", "th", "always", "sf", "xxx", "is", "resource", "still", "se", "also", "could", "might", "any", "Should", "thus", "condition", "since", "such", "because", "ie", "s", "sc", "need", "this"], "be": ["a", "fore", "are", "or", "being", "equal", "obe", "were", "en", "always", "le", "ge", "te", "stay", "se", "also", "ve", "you", "re", "note", "ignore", "BE", "Be", "by", "never", "bes", "been"]}}
{"project": "qemu", "commit_id": "e3f30488e5f802547b3a60e40cebaef3b4ec16a3", "target": 1, "func": "static void virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))\n\n        return;\n\n\n\n    if (n->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(n->tx_vq, 0);\n\n        return;\n\n    }\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        ssize_t ret, len = 0;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        unsigned hdr_len;\n\n\n\n        /* hdr_len refers to the header received from the guest */\n\n        hdr_len = n->mergeable_rx_bufs ?\n\n            sizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\n            sizeof(struct virtio_net_hdr);\n\n\n\n        if (out_num < 1 || out_sg->iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* ignore the header if GSO is not supported */\n\n        if (!n->has_vnet_hdr) {\n\n            out_num--;\n\n            out_sg++;\n\n            len += hdr_len;\n\n        } else if (n->mergeable_rx_bufs) {\n\n            /* tapfd expects a struct virtio_net_hdr */\n\n            hdr_len -= sizeof(struct virtio_net_hdr);\n\n            out_sg->iov_len -= hdr_len;\n\n            len += hdr_len;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,\n\n                                      virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(n->tx_vq, 0);\n\n            n->async_tx.elem = elem;\n\n            n->async_tx.len  = len;\n\n            return;\n\n        }\n\n\n\n        len += ret;\n\n\n\n        virtqueue_push(vq, &elem, len);\n\n        virtio_notify(&n->vdev, vq);\n\n    }\n\n}\n", "idx": 19223, "substitutes": {"n": ["na", "ren", "np", "yn", "nt", "fn", "form", "w", "p", "en", "num", "cn", "h", "remote", "ne", "on", "nv", "g", "ng", "node", "tn", "mn", "ann", "name", "out", "m", "d", "nw", "ns", "v", "ln", "nn", "nor", "sn", "conn", "cdn", "nb", "nu", "c", "nl", "j", "note", "comm", "local", "new", "non", "o", "N", "number", "hn", "y", "ny", "network", "nm", "gn", "nc", "rn", "nd", "an", "nr", "net", "names", "b", "conf", "dn"], "vq": ["veq", "sviq", "svqq", "sch", " vue", "lq", "vdq", "svz", "vque", "veqq", "xdq", "sq", "sz", " vdq", "vck", "vz", "svch", " vch", "svque", " vck", "svq", "hue", "viq", "xck", "veiq", "hqq", "xq", "xqs", "ldq", " vque", "svck", "xque", "sue", " vz", "vqq", "vue", "lque", "svqs", "hq", " vqs", "svue", "veue", "vqs", "hiq", "vch"], "elem": ["eulev", "eledem", "adelems", "pept", "veelement", " edem", "edlem", "telems", "eulem", "adelda", " ele", "eulete", "uelda", "eelem", "lelev", "edlev", "elelems", "lelement", "neagle", "belem", "euagle", "elelda", "ell", "eleelement", "eld", "elelem", "veem", "euld", " ell", "nelement", "eelete", "elete", "nelems", "pele", "enll", "edlement", "neelement", "elda", " elems", "eagle", "lelems", "velem", "edlems", "pelem", "bele", "enlem", "beem", "uelem", "elelev", "lelete", "eell", " element", " elev", "vept", "nelem", "eelement", "vele", " ego", "engo", "enle", "eele", "ept", " eagle", "uelement", "nelev", "bept", "element", "ele", "eulement", "eego", "velems", "eeld", "eem", "telem", "velev", "telement", "adelement", "elelement", "lelem", "leld", "adelem", "peem", "ego", "elems", "edem", "tedem", "uelems", "elev"], "ret": ["mem", "lv", "nt", "res", "arr", "el", "t", "deg", "flag", "back", "l", "num", "en", "result", "ll", "Ret", "hash", "rt", "sum", "count", "ben", "arg", "il", "tr", "mt", "out", "fin", "after", "ptr", "read", "cont", "lt", "ft", "RET", "rev", "re", "reset", "nl", "ext", "lit", "r", "val", "def", "str", "leg", "alt", "del", "lan", "ld", "len", "resp", "f", "gt", "url", "fun", "elt", "status", "red", "rets"], "out_num": ["outjmsg", "outLEno", " out_ref", "outznum", "out_man", "outznu", " out_mon", "in_no", "outLEmon", "out_n", "out_net", "outvalsnap", "out_ref", "out_Num", "outvalnu", "in_num", "outzum", "out_mon", "out_nu", "in_man", "outvalnum", "outputzum", "outjno", "output_nu", "outputznu", "outputznum", "out_non", "in_mon", "in_mun", "out_pos", "output_snap", "outjnum", "out_no", "outjpos", "in_msg", "in_pos", "out_um", " out_name", "out_name", "output_um", "outLEman", " out_non", "outputzsnap", "out_msg", "output_num", "in_Num", " out_net", " out_n", "outvalum", "outLEnum", "outzsnap", "out_mun", "out_snap"], "out_sg": ["in_sk", "in_sb", "outstreamng", " out_si", "out_sb", " out_sb", "outstreamsb", "out_sk", "out_sc", "ch_si", " out_ng", "out__si", "in_num", "in_bg", "out_gs", "out2sk", " out_sol", "in_rg", "out2sb", "in_sg", "in_sd", "out__sg", "out2sg", "out__gs", "out_bg", "ch_gs", "out_sd", "outstreamsg", "out__rg", "out_ng", "outstreamsc", "out_sol", "ch_sg", "ch_rg", "out_si", "out_rg", "out2rg", " out_sc"], "hdr_len": ["hdr2mem", "hdr_ln", "hDR_la", "hdr_el", "hdr_mem", "hdr2len", "hvr_len", "hdr_long", "hDR_mem", "hdr_buf", "hDR_den", "hdr_en", "hvr_gen", "hDR_len", "hdr_gen", "hdr_length", "hvr_Len", "hdr_la", "hDR_en", "hDR_gen", "hdr2Len", "hDR_buf", "hDR_fun", "hdr7len", "hDR_length", "hDR_syn", "hdr_fun", "hdr7buf", "hDR_Len", "hpar_ln", "hdr7la", "hpar_len", "hdr7Len", "hdr_den", "hdr_Len", "hvr_el", "hDR_long", "hdr_syn", "hpar_Len", "hdr2den"]}}
{"project": "qemu", "commit_id": "a1c5975270f2335e1d7129c084a6e562d7b99bdd", "target": 1, "func": "static void flush_queued_data(VirtIOSerialPort *port, bool discard)\n\n{\n\n    assert(port || discard);\n\n\n\n    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);\n\n}\n", "idx": 19237, "substitutes": {"port": ["priority", "export", "connection", "channel", "Port", "bridge", "server", "pipe", "window", "termin", "phy", "boat", "ping", "p", "comment", "component", "ort", "valid", "only", "mit", "required", "report", "pid", "pport", "test", "store", "journal", "pc", "task", "public", "wait", "count", "point", "cast", "queue", "PORT", "pod", "ports", "eport", "porter", "bid", "select", "plugin", "peer", "page", "pt", "pool", "post", "table", "interface", "let", "connect", "project", "bound", "client", "tty", "trace", "row", "entry", "cp", "meter", "policy", "bind", "import", "rule", "proxy", "gate", "type"], "discard": ["iscarded", "resard", "discarding", "Discard", "discards", "resarded", "Discarded", " Discard", " discards", "resause", "discarded", " Discards", " Discarding", "discARD", " discarding", "iscard", "resARD", "Discause", "Disccast", " disccast", "dcards", "Discards", "dcard", " discarded", "dcarded", " Discause", " DiscARD", "iscards", "dccast", "iscarding", "disccast", "DiscARD", "discause", " Discarded"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static int hdev_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n\n\n\n\n\n\n    const char *filename = qdict_get_str(options, \"filename\");\n\n    char bsd_path[MAXPATHLEN] = \"\";\n\n    bool error_occurred = false;\n\n\n\n    /* If using a real cdrom */\n\n    if (strcmp(filename, \"/dev/cdrom\") == 0) {\n\n        char *mediaType = NULL;\n\n        kern_return_t ret_val;\n\n        io_iterator_t mediaIterator = 0;\n\n\n\n        mediaType = FindEjectableOpticalMedia(&mediaIterator);\n\n        if (mediaType == NULL) {\n\n            error_setg(errp, \"Please make sure your CD/DVD is in the optical\"\n\n                       \" drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        ret_val = GetBSDPath(mediaIterator, bsd_path, sizeof(bsd_path), flags);\n\n        if (ret_val != KERN_SUCCESS) {\n\n            error_setg(errp, \"Could not get BSD path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If a real optical drive was not found */\n\n        if (bsd_path[0] == '\\0') {\n\n            error_setg(errp, \"Failed to obtain bsd path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If using a cdrom disc and finding a partition on the disc failed */\n\n        if (strncmp(mediaType, kIOCDMediaClass, 9) == 0 &&\n\n            setup_cdrom(bsd_path, errp) == false) {\n\n            print_unmounting_directions(bsd_path);\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        qdict_put(options, \"filename\", qstring_from_str(bsd_path));\n\n\n\nhdev_open_Mac_error:\n\n        g_free(mediaType);\n\n        if (mediaIterator) {\n\n            IOObjectRelease(mediaIterator);\n\n        }\n\n        if (error_occurred) {\n\n            return -ENOENT;\n\n        }\n\n    }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n\n    s->type = FTYPE_FILE;\n\n\n\n    ret = raw_open_common(bs, options, flags, 0, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n        if (*bsd_path) {\n\n            filename = bsd_path;\n\n        }\n\n        /* if a physical device experienced an error while being opened */\n\n        if (strncmp(filename, \"/dev/\", 5) == 0) {\n\n            print_unmounting_directions(filename);\n\n        }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n        return ret;\n\n    }\n\n\n\n    /* Since this does ioctl the device must be already opened */\n\n    bs->sg = hdev_is_sg(bs);\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        ret = check_hdev_writable(s);\n\n        if (ret < 0) {\n\n            raw_close(bs);\n\n            error_setg_errno(errp, -ret, \"The device is not writable\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 19238, "substitutes": {"bs": ["bm", "ds", "cs", "lbs", "os", "bits", "sb", "BS", "bb", "ubs", "bh", "bp", "qs", "bps", "rs", "gs", "ss", "bg", "bc", "ubis", "ns", "sts", "vs", "pb", "bl", "bos", "ps", "bes", "js", "obs", "fs", "ts", "ls", "ms", "b", "bis", "its"], "options": ["ptions", "atts", "IONS", "times", "uploads", "ops", "os", "args", "linux", "settings", "games", "bits", "details", "finals", "false", "roots", "comes", "results", "tops", "option", "checks", "opens", "config", "pins", "caps", "files", "values", "Options", "properties", "plates", "ption", "bos", "ps", "aps", "data", "json", "styles", "lets", "es", "eps", "dict", "errors", "fs", "weights", "ts", "metadata", "features", "ims", "null", "meta", "params", "stats", "ms", "fp", "spec", "objects"], "flags": ["atts", "fields", "cs", "acts", "times", "fps", "ops", "fd", "args", "flag", "settings", "bits", "details", "members", "lines", "frames", "ensions", "vals", "length", "files", "windows", "tags", "properties", "mask", "kind", "ants", "types", "cmd", "nl", "ags", "ints", "weights", "ts", "faces", "features", "FLAG", "locks", "params", "stats", "ms", " Flags", "lag", "status", "Flags", "comments"], "errp": ["rrpost", "errps", "erping", "rerping", "errm", "errorm", "errorp", "rrpa", "errorP", "rerp", " errping", "lerping", "errorpar", "errpa", "erp", "ererps", "lerr", "erm", "errr", "rrr", "ererping", "rrpid", "errpar", "rrping", "rrp", " errpost", " errps", "lerpa", "errping", "ererp", "errpost", "erpid", "errpid", " errm", "errorr", " errpar", "rerpost", "errorpid", "errP", "lerp", "errorps", "erpa", "ererpar", "erP", " errP", "errorping", "err"], "s": ["ds", "cs", "states", "os", "t", "ys", "args", "settings", "sb", "as", "ses", "sq", "sm", "sv", "rs", "sa", "gs", "S", "ss", "ns", "sts", "obj", "ps", "sys", "sn", "js", "c", "fs", "state", "ts", "ssl", "ls", "stats", "f", "sl", "b", "status"], "local_err": ["local__err", "local__sys", "local____kr", "local___ptr", "local_er", "local___er", "local____er", " local_kr", "local___r", "local_ptr", "local____sys", "Local_ptr", " local_sys", "local___err", "local____ptr", "Local_er", "Local_err", "local__kr", "local____r", "Local_r", "local_kr", "local_r", "local____err", "local_sys"], "ret": ["mem", " RET", "res", "nt", "t", "opt", "ter", "result", "ll", "Ret", "rt", "arg", "il", "tr", "mt", "out", "Return", "get", "ft", " Ret", "rem", "RET", "re", "nl", "att", "j", "r", "val", "et", "alt", "len", "resp", "gt", "elt", "rets"], "filename": ["SourceFile", "fn", "ame", "username", "amer", "Filename", "fil", "journal", "family", "bas", "fle", "ames", "til", "ename", "prefix", "length", "files", "name", "jpg", "which", "json", "binary", "wine", "fs", "path", "directory", "nil", "source", "txt", "buffer", "url", "fp", "browser", "title", "src", "names", "river", "file"], "bsd_path": ["bsd___value", "bsd_route", "bsd7p", "bssd_stream", "bssd_port", "bsd_name", "bsd___ring", "bssd_path", "bsdxroot", "bssd_data", "bsd_data", "bsd_ring", "bsd7path", "bsd___Path", "bssd_component", "bsd2path", "bsd___component", "bsdxstream", "bsd2Path", "bsd2stream", "bssd_root", "bsd_component", "bssd_ring", "bsd___route", "bsd_stream", "bsd2root", "bssd_name", "bssd_route", "bsd2data", "bsd__ath", "bsd___path", "bsd_value", "bsd7name", "bssd_ath", "bsd_port", "bsd__path", "bssd_Path", "bsd_p", "bsd__Path", "bsd_ath", "bsdxpath", "bsd_Path", "bsd7Path", "bssd_p", "bsdxPath", "bssd_value", "bsd_root", "bsd__data"], "mediaType": ["commandTYPE", " mediaSource", "commandTypes", "memoryAdapter", "commandType", "commandTyp", " mediaTYPE", "mediTYPE", "resourceIterator", "documentType", "mediaTypes", "areaType", "mediaAdapter", "resourceType", "documentIterator", " mediaTyp", "imageTypes", "documentTYPE", "mediAdapter", "areaTYPE", "imageType", "memoryTypes", "mediName", "dataAdapter", " mediaName", "imageTYPE", "proxyName", "memorySource", "mediType", "mediaIterator", "resourceTYPE", "mediaTyp", "proxyAdapter", "memoryTYPE", "mediaSource", "memoryName", "dataTYPE", "mediaName", "mediaHandler", "proxyTYPE", " mediaHandler", " mediaAdapter", "dataName", "resourceHandler", "memoryType", "areaTypes", " mediaTypes", "proxyType", " mediaIterator", "areaTyp", "mediaTYPE", "imageSource", "dataType", "documentHandler"], "ret_val": ["ret_value", "return_vals", "ret32val", "retTvalue", "ret32value", "ret32el", "return_val", "ret_VAL", "Ret_val", " ret_vals", "return_Val", " ret_VAL", "ret32VAL", "ret2vals", "ret_type", "retTel", "ret2VAL", "ret_Val", "Ret_VAL", "ret_el", "Ret_el", "retTVAL", "retTval", "ret3vals", "ret2val", "ret3VAL", "return_value", "ret3val", " ret_type", "ret2type", "ret_vals", "ret3type", "Ret_value"]}}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n", "idx": 19243, "substitutes": {"bus": ["os", "bridge", "board", "box", "ck", "bb", "controller", "bh", "bur", "kt", "mount", "handler", "stick", "bs", "buf", "lock", "usb", "vc", "onet", "bc", "bug", "route", "sys", "http", "conn", "driver", "cat", "bolt", "Bus", "hand", "BUS", "bu", "ass", "dev", "sync", "piece", " BUS", "BO", "ack", "block", " brick", "cus", " buses", "phys", "book", "vol", "us", "boot", "volt", "full", "b", "chain", "loop"], "loc": ["pos", "lp", "pub", "location", "l", "res", "box", "LOC", "p", "oc", "tx", "lib", "Loc", "ctx", "util", "buf", "cl", "zip", "alloc", "ch", "co", "reg", "label", " location", "doc", "iter", "lr", "data", "dir", "lit", "rel", "ref", "local", "path", "fc", "info", "lim", "pl", "lang", "ack", "ro", "rc", "home", "ac", "ol", "col"], "dinfo": ["dsinf", " dfo", " dinf", "tinf", "dsfo", "dnInfo", " dInfo", "finit", "DINFO", "dINFO", "DInfo", "dninf", "ddfo", "finf", "fti", "lfo", " dti", "dti", "fINFO", "Dinfo", "fInfo", "dInfo", "dsinfo", "dinformation", "tfo", "ffo", "Dfo", "ddinit", "linfo", "finfo", "ddinfo", "dinf", "tinformation", "ddinf", "dninfo", " dinit", "linformation", "dfo", " dinformation", "tinfo", "dinit", "dnINFO", "Dinf", "dsInfo", "linf", "Dti"], "unit": [" Unit", "nit", "currency", "weight", "span", "point", "label", "cat", "bit", "dir", "relation", "cond", "number", "chain", "under", "title", "index", "port", "uint", "family", "device", "sum", "zero", "command", "unknown", "mun", "force", "scope", "ju", "uni", "n", "it", "slave", "ut", "task", "category", "init", "onent", "term", "num", "user", "kt", "normal", "group", "target", "um", "uri", "alt", "block", "un", "Unit", "pos", "stable", "units", "component", "future", "volume", "u", "Unity", "reason", "axis", "value", "quant", "nu", "unt", "ou", "du", "dim", "key", "vol", "file", "type"]}}
{"project": "FFmpeg", "commit_id": "fbd97184f8b68b2074b79a1698e4d9404292f7ca", "target": 1, "func": "static int link_filter_inouts(AVFilterContext *filt_ctx,\n\n                              AVFilterInOut **curr_inputs,\n\n                              AVFilterInOut **open_inputs, AVClass *log_ctx)\n\n{\n\n    int pad = filt_ctx->input_count, ret;\n\n\n\n    while (pad--) {\n\n        AVFilterInOut *p = *curr_inputs;\n\n        if (!p) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Not enough inputs specified for the \\\"%s\\\" filter.\\n\",\n\n                   filt_ctx->filter->name);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        *curr_inputs = (*curr_inputs)->next;\n\n\n\n        if (p->filter) {\n\n            if ((ret = link_filter(p->filter, p->pad_idx, filt_ctx, pad, log_ctx)) < 0)\n\n                return ret;\n\n            av_free(p->name);\n\n            av_free(p);\n\n        } else {\n\n            p->filter = filt_ctx;\n\n            p->pad_idx = pad;\n\n            insert_inout(open_inputs, p);\n\n        }\n\n    }\n\n\n\n    if (*curr_inputs) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Too many inputs specified for the \\\"%s\\\" filter.\\n\",\n\n               filt_ctx->filter->name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    pad = filt_ctx->output_count;\n\n    while (pad--) {\n\n        AVFilterInOut *currlinkn = av_mallocz(sizeof(AVFilterInOut));\n\n\n\n        currlinkn->filter  = filt_ctx;\n\n        currlinkn->pad_idx = pad;\n\n        insert_inout(curr_inputs, currlinkn);\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 19245, "substitutes": {"filt_ctx": ["fil_rc", "filturectx", "fil_std", "filt___tx", "filt_rx", "filturetx", "filt_std", "fil_context", "filtationctx", "filt___context", "fift_cfg", "filt_rc", "fld_tx", "fift_ctx", "filtration_pool", "filt67tx", "filtationtx", "fift_rx", "filtration_ctx", "filtationcpp", "filturecpp", "filt_cpp", "fld_cfg", "filt_cfg", "filt_func", "fil_tx", "filtration_func", "fld_ctx", "fil_cpp", "filt___tc", "filt_pkg", "filt___ctx", "filt67std", "filt_pool", "fift_tx", "filt_context", "filtration_pkg", "fld_context", "fil_cf", "filt_cf", "fil_ctx", "filturestd", "filtration_std", "fil_tc", "filtationstd", "filtration_tx", "filt67context", "filt_tc", "filt_tx", "filt67ctx", "filtration_context"], "curr_inputs": ["curr_currentes", "curr_contexters", "curr_execos", "curr_outputers", "curr_currentets", "curr__outputos", "curr_inputS", "curr_rawS", "curr__inputos", "curr_buts", "curr_contextets", "curr_inputets", "curr_context_", "curr_butes", "curr_buters", "curr_exec_", "curr_outputS", "curr_outputs", "curr_inputts", "curr__inputs", "curr_except_", "curr_input_", "curr_inputes", "curr_excepts", "curr_execs", "curr_inputers", "curr_contextes", "curr_errorss", "curr_raws", "curr_outputts", "curr_exceptes", "curr__input_", "curr_InputS", "curr_Inputes", "curr_contextts", "curr_errorses", "curr_contextos", "curr__output_", "curr_errors_", "curr_Input_", "curr_currents", "curr_inputos", "curr_Inputs", "curr_contextS", "curr__inputS", "curr_exceptS", "curr__outputs", "curr_currentts", "curr_output_", "curr_outputes", "curr_errorsS", "curr_outputets", "curr_outputos", "curr_rawes", "curr_but_", "curr_contexts", "curr_raw_", "curr_execS", "curr__outputS"], "open_inputs": ["open_outputes", "open_connectes", "open__outputts", "open_contexteds", "open_outputcs", "open_connects", "open_interestes", "open__outputs", "open_interestcs", "open_inputes", "open_outputs", "open_contextes", "open_connectcs", "open_outputts", "open_outputles", "open_Inputts", "open__outputes", "open_outputeds", "open__outputeds", "open__inputts", "open_contextts", "open__inputeds", "open_Inputs", "open_inputeds", "open_Inputes", "open_Inputeds", "open_contexts", "open_inputts", "open__inputs", "open_inputcs", "open_interests", "open__inputes", "open_connectles", "open_interestles", "open_inputles"], "log_ctx": [" log_obj", "loggerconst", "log2ctx", "web_cas", "log__ctx", "log__context", "log2obj", "loggingctx", "log2context", " log_tx", "log__obj", "blog_ctx", "log_desc", "log_obj", " log2context", " log_context", " log2ctx", "log_rec", "log_conn", "logptrec", "logptcas", "webptctx", "webpttx", "loggingconn", "blog_const", "web_tx", "loggingtx", "log_const", "log_jac", "blog_desc", "log_cas", " log_kb", "log__kb", " log2kb", "web_ctx", "loggingdesc", "loggerdesc", "log2kb", "log_kb", " log_conn", "web_rec", "webptcas", "logpttx", "log_context", " log_desc", "loggerjac", "blog_jac", "logptctx", " log2obj", "webptrec", "log_tx", "loggerctx"], "ret": ["mel", "res", "nt", "pret", "t", "back", "flag", "result", "ll", "port", "err", "rt", "tr", "mt", "nz", "out", "fin", "pro", "ft", " Ret", "rem", "success", "reset", "RET", "re", "reply", "nl", "det", "try", "att", "j", "rel", "ref", "r", "val", "def", "print", "pas", "alt", "aux", "txt", "resp", "no", "not", "gt", "it", "fun", "elt", "status", "red", "rets", "Ret"], "pad": ["prep", "ping", "blank", "ctx", "shift", "scale", "length", "ad", "pat", "rank", "pre", "pa", "Pad", "buffer", "grow", "offset", "np", "max", "crop", "port", "end", "device", "append", "seek", "d", "start", "tip", "add", "quad", "pkg", "dev", "pack", "n", " padd", "ack", "x", " padding", "len", "bind", "patch", "depth", "wait", "ady", "delay", "prefix", "address", "ptr", "adder", "addr", "embed", "pend", "cp", "ix", "gate", "pos", "pause", "pay", "store", "pc", "paste", "count", "map", "padding", "off", "pod", "push", "cmd", "ind", "id", "pick", "batch", "pair", "added", "pen"], "p": ["patch", "lp", "np", "l", "dp", "perm", "t", "wp", "i", "pp", "ping", "sp", "proc", "app", "q", "at", "bp", "h", "port", "pc", "power", "span", "g", "point", "per", "op", "vp", "tp", "primary", "d", "rep", "pod", "pro", "pb", "k", "ip", "ps", "peer", "pm", "tip", "param", "c", "pkg", "pt", "pi", "j", "att", "pers", "jp", "comm", "local", "post", "n", "pat", "pair", "pre", "pl", "par", "pa", "resp", "cp", "f", "policy", "fp", "comp", "P", "parse", "y", "ap", "m"], "currlinkn": ["currlinkmn", "currnodem", "currnetna", "currnetworkcn", "currlocknm", "currrstreamn", "currlockn", "currlockne", "currrlinkmn", "currlinkna", "currplugns", "currplugnel", "currstreamcn", "currLinkna", "currerlinkn", "currplugn", "currlockconn", "currnodena", "currrlinkcn", "currstreammn", "currerlinkm", "currstreamn", "currplayns", "currrlinkconn", "currboltconn", "currlinkne", "currrlinkn", "currboltnm", "currnetworkn", "currboltne", "currerlinknel", "currrstreamconn", "currplaynel", "currlinkcn", "currnetm", "currerlinkout", "currplugout", "currnoden", "currerlinkne", "currerlinkns", "currboltn", "currnetworkconn", "currnetworkmn", "currerLinkn", "currerLinkm", "currLinkn", "currlinkns", "currlinkconn", "currstreamconn", "currlinkout", "currrstreammn", "currplayout", "currlinkm", "currplayn", "currerLinkna", "currrstreamcn", "currnetn", "currlinknm", "currerlinkna", "currLinkm", "currerlinkconn", "currerlinknm", "currlinknel"]}}
{"project": "qemu", "commit_id": "46232aaacb66733d3e16dcbd0d26c32ec388801d", "target": 0, "func": "static void x86_cpu_common_class_init(ObjectClass *oc, void *data)\n\n{\n\n    X86CPUClass *xcc = X86_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    xcc->parent_realize = dc->realize;\n\n    dc->realize = x86_cpu_realizefn;\n\n    dc->bus_type = TYPE_ICC_BUS;\n\n    dc->props = x86_cpu_properties;\n\n\n\n    xcc->parent_reset = cc->reset;\n\n    cc->reset = x86_cpu_reset;\n\n    cc->reset_dump_flags = CPU_DUMP_FPU | CPU_DUMP_CCOP;\n\n\n\n    cc->class_by_name = x86_cpu_class_by_name;\n\n    cc->parse_features = x86_cpu_parse_featurestr;\n\n    cc->has_work = x86_cpu_has_work;\n\n    cc->do_interrupt = x86_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;\n\n    cc->dump_state = x86_cpu_dump_state;\n\n    cc->set_pc = x86_cpu_set_pc;\n\n    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = x86_cpu_gdb_read_register;\n\n    cc->gdb_write_register = x86_cpu_gdb_write_register;\n\n    cc->get_arch_id = x86_cpu_get_arch_id;\n\n    cc->get_paging_enabled = x86_cpu_get_paging_enabled;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = x86_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_memory_mapping = x86_cpu_get_memory_mapping;\n\n    cc->get_phys_page_debug = x86_cpu_get_phys_page_debug;\n\n    cc->write_elf64_note = x86_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = x86_cpu_write_elf64_qemunote;\n\n    cc->write_elf32_note = x86_cpu_write_elf32_note;\n\n    cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;\n\n    cc->vmsd = &vmstate_x86_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->debug_excp_handler = breakpoint_handler;\n\n#endif\n\n    cc->cpu_exec_enter = x86_cpu_exec_enter;\n\n    cc->cpu_exec_exit = x86_cpu_exec_exit;\n\n}\n", "idx": 19253, "substitutes": {"oc": ["ic", "loc", "ok", "mc", "ec", "og", "erc", "unc", "pc", "ob", "toc", "vc", "aco", "ot", "bc", "alloc", "co", "ocon", "soc", "orp", "uc", "ocr", "oci", "oco", "oid", "voc", "oad", "osc", "o", "nc", "roc", "OC", "ocation", "cp", "rc", "ac", "arc", "org", "od", "oca"], "data": ["ds", " d", "res", "ctx", " sd", "output", "config", "dat", "ata", "name", "rec", "d", "DATA", "di", "Data", "doc", "cmd", "func", "dev", "def", "cache", "info", "dll", "bin", "dd"], "xcc": ["xfcc", "xacc", "xxacc", " xCC", "xfc", "oxck", "nac", "xfcell", "ixck", "nck", " xac", "xck", "xaac", "oxcc", "ixcc", " xcell", "xack", "oxcar", "xCC", "xpcc", "xxcc", "xpacc", "oxCC", "xac", "ixCC", "ncell", "xxcell", "xcell", "ncc", "xffc", "ixcar", " xck", "xfacc", "xpcell", "xcar", "xxfc", "xpfc", " xcar", "xacell"], "cc": ["td", "ctl", "con", "cv", "cs", "tc", "ca", "cong", "ci", "ck", "disc", "pp", "lib", "cell", "isc", "mc", "lf", "ec", "ll", "ctx", "unc", "pc", "gc", "bec", "cl", "cf", "craft", "vc", "cca", "bc", "cci", "ct", "co", "control", "cd", "cont", "BC", "conn", "uc", "c", "cmd", "func", "ctrl", "CC", "cmp", "cm", "xx", "coll", "lc", "fc", "acc", "cod", "ce", "cu", "cache", "nc", "ld", "ucc", "xc", "go", "rc", "cp", "ac", "icc", "comp", "code", "sc", "inc", "cy"], "dc": ["ctl", "ds", "cs", "dp", "tc", "ca", "disc", "de", "ck", "dt", "mc", "ec", "ctx", "unc", "pc", "gc", "cf", "vc", "cca", "bc", "bd", "cci", "d", "co", "rec", "di", "cd", "da", "db", "cat", "c", "cmp", "lc", "cm", "df", "fc", "nc", "iac", "DC", "rc", "cp", "ac", "dd"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    audsettings_t obt_as = *as;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_RECORD,\n\n        conf.source,\n\n        \"pcm.capture\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        NULL,                   /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for capture failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 19256, "substitutes": {"hw": ["him", "hs", "rew", "hh", "wp", "w", "phy", "sh", "kh", "wm", "ich", "ow", "hz", "aws", "h", "rw", "ha", "ctx", "whe", "iw", "aw", "hop", "hd", "ht", "xp", "vp", "how", "ews", "nw", "htt", "sw", "kw", "ew", "wa", "wx", "igh", "wd", "ay", "sys", "hub", "hm", "pkg", "mx", "hp", "war", "mph", "wan", "haw", "wy", "ww", "wi", "mg", "ether", "wn", "zh", "cu", "shake", "rh", "fw", "phys", "wcs", "rpm", "rack", "wk", "wo", "hog"], "as": ["a", "au", "am", "las", "sh", "ras", "asm", "jas", "aws", "asia", "ctx", "ar", "kas", "aw", "ars", "is", "bs", "eas", "sa", "ase", "rs", "asp", "aus", "sw", "ias", "ns", "ams", "ay", "ast", "mas", "ass", "asms", "ats", "ais", "AS", "As", "asha", "ts", "asa", "aos", "asi", "an", "s", "nas", "ac", "ms", "conf"], "error": ["offset", "frame", "channel", "stable", "server", " Error", "comment", "close", "p", "result", "Error", "query", "ar", "e", "ERROR", "exc", "ace", "empty", "owner", "command", "name", "address", "detail", "start", "se", "instance", "success", "time", "order", "data", "description", "warning", "ror", "event", "r", "std", "message", " ERROR", "pair", "rank", "er", "alias", "state", "info", "row", " err", "no", "rc", "status", "err", "type"], "ss": ["\u00df", "ds", "cs", " sys", "si", " rs", " ts", " os", "hess", "ys", "ests", "settings", "tx", "ess", "sq", "pps", " ssh", "aws", "oss", "ks", " sd", "ress", "ness", "bs", " us", "sv", "rs", " sc", " s", "sa", "SS", "sw", "ns", " ls", "news", "ps", "sys", "ams", "iss", "js", "sd", "spec", "css", " iss", " fs", "ass", "es", "rss", " ps", "pas", " sa", "pse", "ts", "ssl", "ls", "aos", "s", "stats", "ms", "serv", "ssh"], "pa": ["ea", "au", "aka", "ara", "ca", "pause", "ga", "sea", "ta", "pr", "p", "pp", "ping", "asia", "ha", "ctx", "ja", "whe", "pc", "ppa", "paste", "ava", "pol", "sa", "pan", "py", "pu", "ka", "rep", "pro", "ma", "pb", "wa", "ps", "pm", "ada", "mp", "pi", "Pa", "pt", "pha", "pkg", "wan", "jp", "val", "ph", "PA", "fa", "apa", "pas", "pee", "pse", "ppo", "la", "qua", "oa", "opa", "no", "ota", "ia", "pe", "po", "pai", "ap", "oe"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)\n\n{\n\n    CPU_DoubleU farg;\n\n    int isneg;\n\n    int ret;\n\n    farg.ll = arg;\n\n    isneg = float64_is_neg(farg.d);\n\n    if (unlikely(float64_is_nan(farg.d))) {\n\n        if (float64_is_signaling_nan(farg.d)) {\n\n            /* Signaling NaN: flags are undefined */\n\n            ret = 0x00;\n\n        } else {\n\n            /* Quiet NaN */\n\n            ret = 0x11;\n\n        }\n\n    } else if (unlikely(float64_is_infinity(farg.d))) {\n\n        /* +/- infinity */\n\n        if (isneg)\n\n            ret = 0x09;\n\n        else\n\n            ret = 0x05;\n\n    } else {\n\n        if (float64_is_zero(farg.d)) {\n\n            /* +/- zero */\n\n            if (isneg)\n\n                ret = 0x12;\n\n            else\n\n                ret = 0x02;\n\n        } else {\n\n            if (isden(farg.d)) {\n\n                /* Denormalized numbers */\n\n                ret = 0x10;\n\n            } else {\n\n                /* Normalized numbers */\n\n                ret = 0x00;\n\n            }\n\n            if (isneg) {\n\n                ret |= 0x08;\n\n            } else {\n\n                ret |= 0x04;\n\n            }\n\n        }\n\n    }\n\n    if (set_fprf) {\n\n        /* We update FPSCR_FPRF */\n\n        env->fpscr &= ~(0x1F << FPSCR_FPRF);\n\n        env->fpscr |= ret << FPSCR_FPRF;\n\n    }\n\n    /* We just need fpcc to update Rc1 */\n\n    return ret & 0xF;\n\n}\n", "idx": 19274, "substitutes": {"arg": ["rap", "au", "ok", "arr", "ag", "args", "flag", "ax", "p", "oc", "var", "ar", "deb", "g", "fac", "ad", "reg", "inter", "doc", "obj", "add", "param", "bit", "re", "target", "in", "argument", "ref", "field", "local", "val", "cal", " larg", "def", "aux", "Arg", "arp", "f", "inc", "conf", "ang", "ig"], "set_fprf": ["set_fPRF", "set_nprfx", "set_vprx", "set_fbrb", "set_fsprx", "set_vPRF", "set_fbrf", "set_nporb", "set_vprF", "set_vprb", "set_nporfx", "set_fprc", "set_vprf", "set_fsprfx", "set_fcrF", "set_fprx", "set_fporfx", "set_nprf", "set_fprfx", "set_fcrx", "set_nprc", "set_fbrfx", "set_fPRx", "set_fprF", "set_fcrf", "set_fPRf", "set_fprb", "set_fporf", "set_fsprf", "set_fsprb", "set_fporb", "set_fsprF", "set_vPRf", "set_fsprc", "set_nporc", "set_nprb", "set_vPRx", "set_fPRb", "set_nporf", "set_fcrb", "set_fbrc", "set_fporc", "set_vPRb"], "farg": ["darg", " faut", " fpack", "fref", "flitem", "fedreg", "flapp", "fcarp", "fbadmin", "fullric", "dpack", "frav", "flreg", " fvar", "fitem", "fbtag", "fcpack", "farp", "fmaut", "faut", "fullagg", "fric", "flarg", "floatargument", "fcargument", "fabarc", "fapp", " freg", "fbarg", "fullref", "floatarc", "floatitem", "lfarg", "fullreg", "fedarg", " fargument", "lfrav", " farp", "ftag", "fedagg", "floatop", "floatarg", "fullfield", "fabarg", " dfaut", " dfarg", " fagg", "fmargs", "fwarg", "floatapp", "fargs", "fwref", "fwric", "flrav", "fmarg", "lfitem", "farc", " fop", "ffield", "fwarp", "fargument", "floatrav", "fullarg", "floattag", "fpack", "fbapp", "flargument", "floatfield", " fargs", "floatadmin", "fltag", "fvar", "lfargument", "fabfield", "floatarp", "fop", "fabref", "darp", "fmvar", "fladmin", "flop", " fric", "fadmin", "floatric", " dfvar", "fullarc", " dfargs", "floatreg", "fedric", "fagg", "dargument", "fcarg", "floatref", "freg", " fref"], "isneg": ["risneg", "aispos", " isrel", "lispriv", "isnegative", "irel", "aismobile", "risdec", "osneg", "ISne", "aisdec", "lisorigin", "esne", "esnegative", "Isne", " isnegative", "osmobile", "ispos", "iorigin", "ISnegative", "isui", "ismobile", "isserver", "aisneg", "isaui", "imobile", "osdec", "esneg", "ISneg", "isne", "osserver", "isdec", " ispos", "ispriv", "aisserver", "isorigin", "Ispos", "ISpos", "isapriv", "isrel", " isne", "rismobile", "lisui", " ismobile", "ineg", "ipos", "risserver", "aisrel", "espos", "isaneg", "isaorigin", "lisneg", "Isnegative", "ipriv", "Isneg", "iui"], "ret": ["pub", "back", "dt", "test", "hash", "rt", "nz", "mb", "iter", "obj", "sys", "cat", "bit", "req", "art", "nil", "pert", "ert", "cert", "net", "url", "rets", "mem", "eth", " RET", "t", "flag", "desc", "result", "set", "replace", "virtual", "alf", "RET", "reply", "re", "reset", "quad", "try", "usr", "aj", "len", "resp", "tech", "rest", "fun", "elt", "status", "rm", "res", "pret", "terror", "nt", "opt", "ter", "expr", "tr", "match", "mt", "reg", "ptr", "ft", "addr", "det", "att", "def", "str", "print", "alt", "txt", "tt", "gt", "der", "utils", "final", "ort", "last", "out", "Return", "dr", "cont", "value", "rem", "rev", "cmd", "ext", "rot", "rel", "ref", "tag", "val", "Ret"]}}
{"project": "qemu", "commit_id": "df8002103c3e262dc40d7b5e0eb2171ba28b1d63", "target": 0, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if (s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) {\n\n            if (s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n                /* can always write bit 4 of CR7 */\n\n                if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                    s->cr[VGA_CRTC_OVERFLOW] =\n\n                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);\n\n                }\n\n                return;\n\n            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&\n\n                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n                /* extra CGA compatibility hacks (not in standard VGA) */\n\n                if (s->cr_index == VGA_CRTC_MAX_SCAN &&\n\n                    val == 7 &&\n\n                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    return;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&\n\n                           val == 6 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xd;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&\n\n                           val == 7 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xe;\n\n                }\n\n            }\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 19290, "substitutes": {"opaque": ["opent", " opque", "oposter", "poster", "iopque", "opaques", "opsacity", " opaques", "opsent", "popaque", "opsaque", "opsaques", "pque", "popent", "popacity", " oposter", "iopaque", " opent", " opacity", "opacity", "opque", "ioposter", "popaques", "paque", "paques", "iopaques"], "addr": ["offset", "init", "grad", "loc", "mac", "arr", "ord", "location", "pad", "tx", "var", "store", "at", "hash", "ctx", "ret", "adr", "ace", "prefix", "link", "rr", "tr", "mt", "alloc", "handle", "ad", "address", "db", "v", "inter", "attr", "ptr", "dr", "add", "iter", "order", "cmd", "ind", "id", "func", "ref", "r", "host", "str", "align", "act", "alias", "coord", "ack", "x", "url", "src", "ix"], "val": ["ival", "pr", "valid", "tx", "lib", "test", "ctx", "vals", "arg", "Value", "obj", "bl", "eval", "bit", "sol", "cho", "bin", "buffer", "serv", "mem", "check", "Val", "gold", "el", "item", "sel", "var", "list", "ret", " value", "fail", "v", "doc", "msg", "pt", " aval", "try", "dev", "x", "len", "al", "it", "elt", "err", "res", "num", "als", "buf", "pol", "prop", "stat", "reg", " arg", "cal", "def", "str", "alt", "txt", "fx", "bool", "byte", "pos", "rol", "arr", "p", "vt", "xy", "VAL", "fb", "aval", "values", "unit", "value", "data", "ind", "func", "rot", "rel", "ref", "new", "key", " v", "vol", "conf"], "s": ["bits", "details", "ess", "e", "g", "rs", "vs", "se", "obj", "self", "sys", "c", "es", "fs", "er", "params", "spec", "sis", "sl", "os", "sort", "t", "settings", "events", "sp", "sm", "set", "qs", "S", "ss", "sts", "v", "ps", "sn", "service", "xs", "ids", "n", "ts", "ls", "parts", "ains", "aunts", "stats", "bis", "comments", "services", "ies", "a", "ds", "cs", "sam", "w", "terms", "sb", "as", "ses", "changes", "als", "esm", "sv", "des", "sw", "js", "j", "state", "ssl", "tests", "an", "states", "b", "y", "m", "utils", "hs", "p", "store", "sq", "aws", "h", "is", "bs", "gs", "ns", "sd", "tes", "ats", "r", "less", "ims", "ms", "conf", "its"], "index": ["loc", "error", "size", "valid", "test", "ctx", "scale", "point", "Index", "length", "iter", "insert", " sidx", "commit", "local", "cond", "number", "module", "ex", "dd", "offset", "server", "list", "timeout", "set", "zero", "level", "find", "shape", "link", "seek", "scroll", "route", "update", "condition", "x", "version", "status", "init", "location", "seed", "slice", "total", "num", "ticket", "query", "column", "cycle", "node", "match", "send", "address", " address", "all", "capacity", "ptr", " ind", "height", "draw", "vector", "state", "request", "block", "exclusive", "row", "scan", "ix", "gate", "loop", "pos", "si", "i", "change", "count", "config", "position", "axis", "thread", "select", "value", "success", "ind", "id", "new", "connect", " offset", "key", "search", "active"]}}
{"project": "qemu", "commit_id": "913440249ea2e697177e9d43167ac325a8dfe907", "target": 0, "func": "static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 19291, "substitutes": {"nc": ["cs", "np", "nt", "tc", "yn", "nic", "oc", "isc", "NC", "cn", "ics", "ne", "unc", "pc", "gc", "nec", "usc", "bc", "cc", "ct", "nw", "nz", "ns", "nn", "c", "nih", "nl", "Ns", "n", "nm", "anc", "rn", "nr", "cus", "sc"], "s": ["a", "hs", "ds", "cs", "states", "sam", "l", "z", "t", "sb", "p", "ess", "ses", "changes", "als", "sq", "aws", "h", "sm", "has", "qs", "is", "bs", "sv", "rs", "gs", "S", "ss", "ns", "sts", "sports", "sys", "ps", "js", "sd", "xs", "j", "es", "ats", "n", "fs", "less", "ts", "ls", "stats", "us", "sis", "sl", "b", "bis", "y"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void dhcp_decode(const uint8_t *buf, int size,\n\n                        int *pmsg_type)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n\n\n    p = buf;\n\n    p_end = buf + size;\n\n    if (size < 5)\n\n        return;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n}\n", "idx": 19301, "substitutes": {"buf": ["mem", "pos", "xff", "cv", "cap", "loc", "w", "window", "img", "pad", "max", "paren", "h", "q", "bp", "port", "ctx", "paste", "cur", "map", "tmp", "queue", "alloc", "out", "pg", "v", "limit", "pb", "read", "ptr", "bl", "data", "c", "msg", "page", "cmd", "ref", "r", "batch", "raw", "rb", "cb", "block", "bin", "uf", "cp", "buffer", "Buffer", "fp", "buff", "b", "ff"], "size": ["offset", "pos", "mem", "l", "z", "w", "sent", "sh", "max", "sp", "en", "h", "scale", "sum", "count", "g", "empty", "shape", "padding", "length", "send", "name", "m", "bytes", "start", "v", "fee", "sn", "c", "ize", "in", "body", "nl", "message", "number", "n", "space", "since", "Size", "SIZE", "s", "buffer", "small", "type"], "pmsg_type": ["pmsg___num", "pmsg___Type", "pmsg__Type", "pmsg_Type", "pmsg_size", "pmessage_num", "pmessage_type", "pmessage_Type", "pmessage_id", "pmsg__type", "pmsg_name", "pmsg___name", "pmsg_num", "pessage_type", "pmessage_size", "pessage_error", "pessage_Type", "pmsg_data", "pessage_data", "pmessage_name", "pmsg___type", "pmsg_error", "pmsg__name", "pmsg__num", "pmsg_id"], "p": ["a", "pos", "lp", "np", "l", "dp", "t", "wp", "pr", "i", "pp", "ping", "sp", "pad", "en", "proc", "pay", "q", "h", "bp", "pid", "at", "port", "pc", "span", "g", "point", "xp", "vp", "prefix", "tp", "pg", "d", "pro", "v", "rep", "pointer", "pb", "progress", "ip", "ps", "c", "up", "pt", "pi", "pkg", "j", "page", "pers", "r", "jp", "post", "pack", "n", "pat", "pre", "pl", "par", "pa", "pn", "cp", "php", "f", "buffer", "fp", "pe", "P", "b", "y", "ap", "m"], "p_end": ["p__size", "tp_END", "tp_len", " p_size", "p_stop", "p2end", "p2END", "p_size", " p_max", "p__end", "p_ending", "p_start", " p_ending", "lp_stop", "tp_start", "p2stop", "p_max", " p_END", "tp_end", "p_END", "p_len", "lp_END", "p__ending", "lp_end"], "len": ["mem", "pos", "lp", "offset", "fn", "l", "el", "nt", "t", "lon", " el", "lib", "sp", "lf", "en", "ll", "li", "count", "vec", " l", "il", "length", "mn", "ann", "mat", "fin", "conv", "ln", "v", "label", "all", "lt", "nl", "lit", "val", "L", "cmp", "line", "coll", "str", "n", "lic", "cod", "lan", "repl", "lim", "ls", "pl", "ld", "un", " clen", "fun", "Len", "sl", "elt", "seq", "err", "fl"], "tag": ["word", "ag", "format", "back", "pad", "hash", "feature", "te", "tags", "mat", "cat", "bit", "field", "local", "rat", "token", "net", "offset", "t", "flag", "var", "set", "end", "qual", "ot", "call", "role", "parent", "date", "pack", "card", "ver", "brand", "code", "task", "old", "style", "comment", "term", "tar", "html", "prefix", "prop", "match", "tr", "stat", "mt", "bug", "reg", "attr", "TAG", "note", "cmp", "row", "tg", "meta", "go", "no", "col", "debug", "pos", "at", "count", "op", "pod", "dr", "feat", "cmd", "Tag", "key", "par", "tail", "comp", "type"]}}
{"project": "qemu", "commit_id": "ddb603ab6c981c1d67cb42266fc700c33e5b2d8f", "target": 0, "func": "static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)\n\n{\n\n    XHCITRB *trb_setup, *trb_status;\n\n    uint8_t bmRequestType;\n\n\n\n    trb_setup = &xfer->trbs[0];\n\n    trb_status = &xfer->trbs[xfer->trb_count-1];\n\n\n\n    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,\n\n                              xfer->epctx->epid, xfer->streamid);\n\n\n\n    /* at most one Event Data TRB allowed after STATUS */\n\n    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {\n\n        trb_status--;\n\n    }\n\n\n\n    /* do some sanity checks */\n\n    if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n\n        DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\",\n\n                TRB_TYPE(*trb_setup));\n\n        return -1;\n\n    }\n\n    if (TRB_TYPE(*trb_status) != TR_STATUS) {\n\n        DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\",\n\n                TRB_TYPE(*trb_status));\n\n        return -1;\n\n    }\n\n    if (!(trb_setup->control & TRB_TR_IDT)) {\n\n        DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\");\n\n        return -1;\n\n    }\n\n    if ((trb_setup->status & 0x1ffff) != 8) {\n\n        DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\",\n\n                (trb_setup->status & 0x1ffff));\n\n        return -1;\n\n    }\n\n\n\n    bmRequestType = trb_setup->parameter;\n\n\n\n    xfer->in_xfer = bmRequestType & USB_DIR_IN;\n\n    xfer->iso_xfer = false;\n\n    xfer->timed_xfer = false;\n\n\n\n    if (xhci_setup_packet(xfer) < 0) {\n\n        return -1;\n\n    }\n\n    xfer->packet.parameter = trb_setup->parameter;\n\n\n\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n\n\n    xhci_try_complete_packet(xfer);\n\n    if (!xfer->running_async && !xfer->running_retry) {\n\n        xhci_kick_epctx(xfer->epctx, 0);\n\n    }\n\n    return 0;\n\n}\n", "idx": 19307, "substitutes": {"xhci": ["xhii", "xhlvc", "xhhii", " xxhlii", "xhtci", "xhpi", "xhhpi", "xhlpi", " xxhci", " xxhvc", " xxhlvc", " xxhlpi", "xhtii", "xhhci", " xxhii", "xhhvc", " xxhpi", "xhlci", "xhtpi", "xhtvc", " xxhlci", "xhvc", "xhlii"], "xfer": ["tference", "wxference", "xxference", "xlate", "xxfer", "zFER", "xpporter", "txcer", " xception", "zxferred", "xpject", "uxFER", "oxference", "ixferred", "vporter", "zxference", "ixpire", "wxpire", "ixterm", "ixffer", "axfer", "ixve", "xpire", "xpfer", "xject", "xxport", "xception", "xxtransfer", "ixFER", "xfr", "txporter", "crosstransfer", "oxfer", "exterm", " xreq", "exporter", "yiter", "txcert", "retransfer", "exec", " xiter", "xport", "inxlate", "ixject", "ctxfer", "oxiter", "uxfer", "xFER", "zxreq", "xfporter", "ixference", "xxcert", "xve", "inxference", "xxcer", "_", "xfe", "axffer", "txferred", "uxffer", "xiter", "tporter", "yporter", "zference", "inxfe", "xuse", "uxfr", "crossfer", "ixtransfer", "xxpire", "txpire", "xe", " xferred", "xterm", "exfer", "workfer", "txception", "uxiter", "wxception", "xffer", "extransfer", "xcert", "txport", "yfer", "ctxlate", "txiter", "zfer", " xporter", "ixreq", "wxfer", "reiter", "zxfer", "crosspire", " xject", "ixfe", "workference", "axiter", "ixfer", "oxception", "xxiter", " xuse", "oxcer", "ixiter", "xxffer", "wxject", "vffer", "crossve", "wxfr", "xcer", " xpire", "oxport", "ixlate", "xxFER", " xve", "xtransfer", "workporter", "wxFER", "oxFER", " xfr", "xsend", "xxporter", "oxsend", "ytransfer", "txference", "xxfr", "refer", "txfer", "vference", "uxterm", "xffr", "workpire", "xreq", "txffer", "xferred", "tfer", "ixuse", "ixporter", "xference", " xFER", "reference", "uxference", "oxcert", "xfject", "inxfer", "ctxfe", "cmd", "axporter", "axsend", "oxpire", "func", "xpfr", "tception", "vfer", " xsend", "uxporter", "exffer", "xporter", "ctxference", "ixfr", " xtransfer", "uxferred", "wxporter", "zuse", " xference", "exiter", "txFER", "axference"], "trb_setup": ["trb_new", "trB_new", "trfb_update", "trfb_get", "trb_check", "trbbdefinit", "trbdefcheck", "trb_____new", "trB_status", "trbairset", "trB_sync", "trbb_update", "trb11update", "trfb11init", "trb_config", "trbThesetup", "trb___init", "trb11setup", "trB_rise", "trb_result", "trbb_setup", "trB_call", "trba_setup", "trba_Setup", "trb_sequence", "trB_help", "trb_get", "trb___control", "trbbdefsetup", "trB_settings", "trB_Setup", "trbThehelp", "trb_____setup", "trbairsetup", "trbb_check", "trb_reset", "trB_control", "trB_connect", "trb11init", "trb_init", "trfb_setup", "trb_settings", "trfb11setup", "trbbdefupdate", "trb_call", "trfb11get", "trb_____call", "trB_init", "trb_info", "trb_help", "trba_reset", "trb_control", "trb_sync", "trbairnew", "trbaircall", "trb_update", "trfb_init", "trbTheset", "trbb_init", "trbdefsetup", "trb___setup", "trB_config", "trB_set", "trB_info", "trb11get", "trbbdefcheck", "trB_sequence", "trba_result", "trfb11update", "trb_Setup", "trb_connect", "trb_rise", "trb___status", "trbTheconnect", "trbdefupdate", "trb_____set", "trbdefinit", "trb_set", "trB_setup"], "trb_status": ["trb_description", "trb0check", "trb__stat", "trb_check", "trb_reason", "trb__check", "trB_description", "trb___reason", "trp_stat", "trB_status", "trB_reason", "trB_version", "trb_type", "trb__status", "trB_res", "trb_result", "trb_spec", "trB_type", "trp_result", "trp_spec", "trB_settings", "trb_settings", "trB_free", "trB_check", "trp_status", "trb___stat", "trb___handle", "trb_Status", "trb_res", "trB_Status", "trb_version", "trB_stat", "trb__type", "trb0status", "trb__description", "trb_free", "trb___status", "trb0stat", "trb_stat", "trb_handle", "trb0type", "trB_handle"], "bmRequestType": ["bmRequStyle", "bmrequestType", "bnrequestType", "bmCommandName", "bmRequestTypes", "BMResponseTypes", "bdRequTYPE", "bdRequType", "bnRequestTyp", "bmReturnStyle", "BMRequestStyle", "BMRequestName", "bmReturnType", "bmRequTyp", "bmrequestTypes", "bmRequestStyle", "bmRequInfo", "BMRequestType", "bdRequestType", "bmResponseTypes", "bmRequestTyp", "BMRequestTypes", "bmRequestTYPE", "bmrequestInfo", "bmEventStyle", "bmRequTypes", "bnRequestInfo", "bnrequestTyp", "bmRequType", "bnRequestType", "bmResponseName", "bmCommandTypes", "bmrequestTyp", "bmEventTypes", "bmRequestName", "bmEventName", "bmRequestInfo", "bmReturnTYPE", "bmResponseStyle", "bdRequestTYPE", "bdRequestStyle", "bdRequStyle", "BMResponseName", "bmCommandStyle", "bnrequestInfo", "bmResponseInfo", "bmRequTYPE", "bmCommandType", "BMResponseStyle", "bnRequestTypes", "bmEventType", "bmResponseType", "BMResponseType", "bnrequestTypes", "bmResponseTyp"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "void qemu_free_timer(QEMUTimer *ts)\n\n{\n\n    g_free(ts);\n\n}\n", "idx": 19322, "substitutes": {"ts": ["hs", "ds", "TS", "cs", "t", "tz", "als", "ics", "tis", "ks", "kt", "qs", "pc", "uts", "bs", "rs", "gs", "tn", "ss", "mt", "tp", "Ts", "ns", "sts", "estamp", "ps", "tes", "pt", "ats", "fs", "ims", "ls", "tt", "ms", "ents", "its"]}}
{"project": "FFmpeg", "commit_id": "816577716bc6170bccfea3b9e865618b69a4b426", "target": 1, "func": "static av_cold int dvdsub_close(AVCodecContext *avctx)\n\n{\n\n    DVDSubContext *ctx = avctx->priv_data;\n\n    av_freep(&ctx->buf);\n\n    ctx->buf_size = 0;\n\n    return 0;\n\n}\n", "idx": 19353, "substitutes": {"avctx": ["savctrl", " avcontext", "awctrl", "awcontext", " avcv", "avcv", "avcontext", "aftx", "afctx", " avtx", "awctx", "afcv", "savtx", "avctrl", "awtx", "savcv", "avtx", "savcontext", "savctx", "afcontext", " avctrl"], "ctx": ["cv", "loc", " cx", "tc", "nt", "np", "tz", "px", "ck", "tx", "lib", "desc", "mc", "kt", "unc", "gc", "cl", "buf", " context", "crit", "cf", "cam", "config", "ct", "cc", "bc", "kw", "ns", "auth", "hw", "ptr", "obj", "cor", "req", "c", "pkg", "cmd", "ind", "inst", "ref", "context", "ctrl", "cmp", "cfg", "act", "txt", "cb", "nc", "anc", "xc", "cp", "ac", "wcs", "ctr"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return toclen;\n\n}\n", "idx": 19373, "substitutes": {"req": ["mem", "history", "res", "tx", "desc", "md", "sq", "query", "q", "rx", "ctx", "required", "gz", "compl", "buf", "uj", "fr", "crit", "requ", "prefix", "rr", "queue", "reg", "attr", "wx", "each", "http", "conn", "cmd", "msg", "inv", "ocr", "ind", "j", "pkg", "ref", "r", "comm", "Requ", "jp", "gr", "cmp", "quest", "usr", "rb", "request", "aux", "qt", "org", "resp", "urg", "rpm", "spec", "qq", "err", "dq"], "outbuf": ["OUTbytes", "Outbuf", " outbuff", "invbuf", "outbuffer", "outqueue", "outvec", "Outbu", "invbuffer", "callbuf", "Outbytes", "outbu", "inbuff", "outbytes", "inqueue", "callbound", "outputbuff", " outbu", " outbytes", "outputbytes", "checkbytes", "checkbuff", "outputqueue", "checkbuf", " outvec", "OUTvec", "callbu", "OUTbuff", "Outbuff", "outputbu", "Outvec", " outbound", "OUTbuf", "Outqueue", "Outbuffer", "inbuf", "invvec", "outbuff", " outqueue", "invbu", "callbuff", "outputbound", " outbag", "outbag", "Outbag", "outputbuf", "checkbag", "outputbuffer", "inbuffer", " outbuffer", "outbound"], "s": ["hs", "ds", "sam", "t", "i", "sb", "p", "ess", "sp", "ses", "sq", "h", "is", "syn", "rs", "gs", "sa", "S", "ss", "sw", "ns", "sts", "v", "se", "ps", "sys", "http", "iss", "js", "c", "es", "r", "comm", "n", "fs", "sol", "less", "ts", "ls", "sis", "sl", "b", "y", "m"], "start_track": ["startPosttrace", "start_rack", "start_Track", "startTimeroute", "start_ack", " start_Track", "start_trace", "startPosttrack", " start_seek", "startPostack", "start_seek", "startTimerack", "end_track", "start_tr", "start_tracking", " start_rack", "end_ack", " start_tr", "start_route", "startTimetrack", "end_trace", " start_route", " start_tracks", "start_tracks", " start_tracking"], "format": ["frame", "form", "style", "sort", "fn", "t", "size", "feature", "set", "scale", "cf", "prefix", "command", "mt", "name", "mat", "force", "method", "unit", "atter", "feat", "ft", "pretty", "time", "ff", "ats", "tag", "iat", "transform", "file", "act", "fc", "Format", "fm", "dim", "MAT", "len", "function", "api", "pattern", "filter", "f", "fp", "spec", "version", "status", "fit", "mode", "type"], "msf": ["armsfr", "msfe", " msfs", "armsfe", "entsfr", "msfg", "omsfi", "msF", "emsfs", "csm", "msz", "armsz", "entsfe", "armsfg", " mscf", "msfer", "omsf", " msfr", "omsv", "msm", "lsv", "csf", " msm", "armsf", " msF", "lsF", "omsp", " msfer", "tesf", "entscf", " msfg", "lsp", "lsfi", "mscf", "csfi", "lsf", "lsm", "msfs", "ampsF", " msz", "csF", "emsF", "ampsf", "armscf", "ampsfs", "entsf", "msp", "emsf", "ampsfer", " msfi", " msfe", "msv", "tesz", "tsv", "armsfs", "emsfer", "msfr", "tsp", "tesfs", "tesfg", "tsfi", "msfi", "tsf"], "toclen": ["allocLen", "tclan", "topiclength", "alloclength", "htmlLen", "socstr", "topicLen", "socLen", "doclen", "tocstr", "htmllength", "tocfin", "allocstr", "tocrel", "tclength", "htmlfin", "alloclen", " tclength", "ocstr", " tcLen", "oclength", "tcrel", " tclen", "toclength", "tocLen", "soclength", "socdir", "ocdir", "tnlim", "topicfin", "htmllen", "toclan", "soclan", " tcdir", "tnlen", "ocLen", "docLen", "soclim", "tclim", "toclim", "tcLen", "tnrel", "socrel", "tclen", "doclength", "socfin", "soclen", "tnLen", "tocdir", "oclen", "doclan", "topiclen"], "nb_sectors": ["nb_seors", "nb_begments", "nb_sesonents", "nb_pellers", "nb_pecs", "nb_belements", "nb_velements", "nb_becs", "nb_pegments", "nb_sesors", "nb_beors", "nb_segments", "nb_sesctors", "nb_usellers", "nb_useors", "nb_perseicides", "nb_sesicides", "nb_vellers", "nb_vecs", "nb_seicides", "nb_seonents", "nb_vegments", "nb_peors", "nb_pectors", "nb_vectors", "nb_useonents", "nb_neors", "nb_perseors", "nb_perseonents", "nb_selements", "nb_veonents", "nb_nellers", "nb_peonents", "nb_veicides", "nb_persectors", "nb_veors", "nb_nectors", "nb_sellers", "nb_negments", "nb_usectors", "nb_secs", "nb_nelements", "nb_bectors"]}}
{"project": "qemu", "commit_id": "0d1c5c91607d1c55a8f5db39c57c6e5c76e21131", "target": 0, "func": "void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n    } else if (bs->file) {\n\n        bdrv_invalidate_cache(bs->file->bs, &local_err);\n\n    }\n\n    if (local_err) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n", "idx": 19380, "substitutes": {"bs": ["els", "bits", "ubs", "banks", "base", "uts", "vals", "rs", "aus", "vs", "news", "bl", "fs", "acs", "aos", "names", "bm", "boxes", "BS", "bb", "bn", "blog", "bh", "abilities", "otes", "qs", "bas", "bps", "bec", "ubis", "sts", "pb", "ps", "lets", "obs", "bf", "bi", "ts", "ls", "bes", "bis", "ds", "cs", "sb", "ses", "als", "hz", "lines", "bp", "bc", "stones", "js", "vers", "css", "cks", "bing", "ba", "eb", "b", "lbs", "fps", "bed", "outs", "bles", "aws", "gs", "ns", "bytes", "bos", "aps", "ats", "ears", "ims", "ms", "its", "lb"], "errp": [" errpad", "errps", "ererpad", "diep", " errpa", "arrpe", "errpad", "diepa", "aerp", "arrp", " errpkg", "arrper", "errpa", "diepe", "ererps", "dieps", "dieP", "ererper", "errpkg", "arrpa", "arrps", " errps", "errpe", "arrpad", "ererp", "aerpkg", "errper", "errP", " errpe", "aerpa", " errP", "aerP", "diepkg", " errper"], "local_err": ["local_msg", "partialererr", "partial_err", "local_errors", "local_rr", "localererr", " local_msg", "local_rel", "localerrel", "locallyer", "local_r", " local_arr", "partialererrors", "local_eas", "internal_err", "partialerrel", "partial_rel", "locallyreq", "partial_eas", " local_eas", "local_error", " local_er", "internal_r", "locallyerr", "partial_errors", "localererrors", " local_rr", "internal_er", " local_req", "local_arr", "local_er", "localereas", "locallyeas", "partialereas", " local_error", "internal_eas", "local_req"], "ret": ["mem", "rm", "res", "nt", "arr", "t", "back", "deg", "ter", "desc", "result", "ll", "Ret", "hash", "rt", "arg", "kb", "tr", "mt", "nz", "out", "sec", "inter", "ptr", "lt", "ft", "rem", "RET", "mber", "re", "det", "reply", "cmd", "reset", "ext", "rev", "ref", "val", "def", "print", "usr", "alt", "del", "cert", "len", "resp", "status", "gt", "fun", "ctr", " res", "elt", " alt", "rets"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);\n\n\n\n    /* USB misc control 1/2 */\n\n    pci_set_long(pci_conf + 0x40,0x00001000);\n\n    /* PM capability */\n\n    pci_set_long(pci_conf + 0x80,0x00020001);\n\n    /* USB legacy support  */\n\n    pci_set_long(pci_conf + 0xc0,0x00002000);\n\n\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 19389, "substitutes": {"dev": ["mem", "debug", "adv", "nt", "w", "de", "desc", "Dev", "proc", "test", "h", "device", "DEV", "buf", "av", "cam", "des", "ad", "ch", "d", "db", "v", "pro", "off", "hw", "doc", "ve", "obj", "serial", "sd", "conn", "data", "cmd", "priv", "att", "out", "ev", "def", "raw", "develop", "env", "info", "block", "vo", "Device", "go", "ver", "devices", "home", "dem", "spec", "conf", "dd", "serv"], "s": ["a", "ds", "cs", "t", "w", "i", "p", "sb", "ses", "sq", "aws", "h", "is", "bs", "syn", "south", "sv", "rs", "gs", "sa", "S", "ss", "v", "ns", "sts", "ps", "sys", "js", "spec", "c", "es", "n", "fs", "sol", "state", "ts", "ls", "su", "sis", "sl", "b", "conf", "m"], "pci_conf": ["pci_conv", "pdi_com", "pci_priv", "pci00fac", "pci_cand", "pci_cons", "pci_prop", "pco_cons", "pdat_nav", "pdi_def", "pdat_conf", "pdi_conn", "pci_config", "pdi_conf", "pci_def", "pci_nav", "pci_com", "pci00conf", "pcu_conn", "pcu_prop", "pci_con", "pco_conf", "pco_con", "pcu_config", "pcixconv", "puci_fac", "pci00config", "pcixconf", "pcixnav", "pco_config", "puci_cand", "pcu_conf", "puci_config", "pdi_priv", "pdat_con", "pdi_config", "pci_fac", "pci_conn", "pcixcon", "pdat_conv", "pci00cand", "puci_conf"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n", "idx": 19403, "substitutes": {"insn": [" insz", "psdn", "linsn", "pinssn", "linsne", "inssn", "linsz", "valsn", "linsnm", " inssn", "intssn", "pinsn", "insz", "pssn", "valssn", "valsne", "pinsnm", " insdn", "ressn", "intsnz", "insdn", "insne", "resn", "psz", "intsn", "valsnm", "insnan", "linsnz", "resnz", "linsdn", "insnm", "linssn", "insnz", "resnan", "intsnan", "pinsne", "psn", "linsnan"], "mask": ["patch", "check", "loc", "perm", "ask", "flag", "weight", "window", "flags", "crop", "list", "Mask", "shift", "set", "sum", "lock", "config", "map", "shape", "match", "address", "kw", "sign", "white", "black", "addr", "target", "master", "tag", "mk", "cmp", "pack", "key", "filter", "bool", "conf", "mode"], "dest": ["temp", "mem", "nom", "loc", "dist", "window", "opt", "img", "proc", "st", "result", "test", "end", "sum", "buf", "cur", "global", "tr", "out", "v", "ptr", "cont", "obj", "sys", "addr", "msg", "target", "master", "origin", "table", "transform", "usr", "orig", "source", "Dest", "txt", "rest", "src", "trans"], "tmp": ["temp", "loc", "img", "test", "ctx", "rt", "copy", "tp", "mb", "obj", "mp", "jp", "local", "orig", "cache", "emp", "td", "trap", "cv", "np", "perm", "t", "dist", "sp", "result", "ret", "output", "cur", "global", "dat", "v", "etc", "start", "tab", "msg", "resp", "mut", "buff", "trans", "old", "snap", "nt", "utm", "box", "mm", "proc", "tar", "buf", "node", " src", "uv", "ptr", "attr", "target", "cmp", "txt", "tg", "cp", "tt", "mint", "qq", "window", "p", "vt", "tn", "out", "db", "ind", "pool", "new", "mk", "table", "repl", "src", "tv"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIONvidia3d0Quirk *data;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vdev->bars[1].region.size) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->data = data = g_malloc0(sizeof(*data));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);\n\n    quirk->nr_mem = 2;\n\n    data->vdev = vdev;\n\n\n\n    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,\n\n                          data, \"vfio-nvidia-3d4-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);\n\n\n\n    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,\n\n                          data, \"vfio-nvidia-3d0-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,\n\n                      quirk, next);\n\n\n\n    trace_vfio_quirk_nvidia_3d0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 19408, "substitutes": {"vdev": ["evapp", "vtech", "avDevice", "evstore", "avscan", "svenv", "svend", " vapp", "vstore", "venv", " vDEV", " vve", "ltech", "vcenv", "gcam", "gve", "vrpro", "vDEV", "pdev", " vev", "avdevice", "tdev", "gev", "svDEV", "evDevice", "svev", "vrDev", " vDevice", "vev", "vver", "evver", " vpro", "pstable", "svstore", "ndevice", "evenv", " vstore", "vDevice", "hdevice", "gpro", "vdevice", "svdev", "vpro", "evdev", "pdevice", "hcam", "gDev", "ldev", "vstable", "hDev", "avcam", "svver", "envdev", "gdevice", "avenv", "gend", " vscan", "avdef", "avve", "svsys", "envga", " vstable", "envDev", "pev", "vve", "nsys", "vrcam", " vsys", "vctech", " vver", "ncam", " vDev", " venv", "hdev", "vdef", "evDEV", " vtech", "avdev", " vcam", "tend", "hga", "envdevice", "lev", "vcev", "vcam", "tev", "vscan", "lenv", "gdev", "vrdev", "avsys", "vDev", "avDEV", "hsys", " vdevice", "vga", "tdevice", "vend", "evdef", "vapp", " vdef", "avDev", "vcdev", "vsys", "avga", "svapp", "ndev", "gstable", "svdevice", "evscan"], "quirk": ["virk", "quarantine", "chirk", "acquitton", "aquirk", "aquiat", "invlict", " inquitton", "quinnie", "chinn", "requitton", "qasi", "glirk", "aquiry", "QUirus", "querirk", "guasi", "requlict", "requirus", "requarantine", "QUirrel", "qulict", "equarantine", "inqulict", "aquirus", "qirrel", " inquirk", " quirrel", "squirk", "vlict", "aquirrel", " quinnie", "vasi", "blirk", "inquirrel", "glirrel", "invirk", "gliat", "inquasi", "chlict", "queriry", "acquiat", "quirus", "glirus", "invasi", " qulict", "blault", "invirrel", "requirt", "quirrel", "squlict", "qirus", "quault", "quiry", "acquirk", "invirus", "gallinn", "blasi", "blirt", "quinn", " inquiat", "guirk", "requiry", "quitton", "quirt", "acquasi", "querirrel", "chiat", " quirus", "inquirk", "acquirus", "virus", "QUinnie", "requiat", "invirt", "gallirk", "equirus", "requinnie", "galllict", " inqulict", "invault", "squirt", "requirk", "guirt", "requirrel", "squiat", "chirt", "aquasi", "equirk", "quasi", "guault", "qirk", "qarantine", "qlict", "acqulict", "QUirk", "equirrel", " quinn", "acquirrel", "quiat", "queriat", "aqulict", "gallirus", "chirus"], "data": ["rew", "error", "format", "size", "results", "dq", "DATA", "di", "news", "obj", "relation", "cache", "bin", "buffer", "mem", "memory", "list", "result", "cheat", "zero", "device", "output", "dat", "ata", "content", "d", "mu", "video", "fee", "json", "dev", "n", "bus", "snap", "res", "query", "buf", "group", "name", "all", "reg", "to", "def", "info", "block", " DATA", "missing", "debug", "next", "window", "p", "action", "config", "empty", "map", "done", "image", "rec", "db", "out", "bytes", "Data", "feat", "value", "rel", "ref", "r", "new", "message", "batch", "table", "extra", "key", "advert", "type"]}}
{"project": "FFmpeg", "commit_id": "919d13d2383bd7318b80ed0c5b723323a79a8996", "target": 0, "func": "static int cookie_string(AVDictionary *dict, char **cookies)\n\n{\n\n    AVDictionaryEntry *e = NULL;\n\n    int len = 1;\n\n\n\n    // determine how much memory is needed for the cookies string\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n\n\n    // reallocate the cookies\n\n    e = NULL;\n\n    if (*cookies) av_free(*cookies);\n\n    *cookies = av_malloc(len);\n\n    if (!cookies) return AVERROR(ENOMEM);\n\n    *cookies[0] = '\\0';\n\n\n\n    // write out the cookies\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n\n\n    return 0;\n\n}\n", "idx": 19411, "substitutes": {"dict": ["ds", "adv", "inf", "arr", "md", "list", "h", "hash", "rect", "compl", "base", "hd", "fr", "map", "dat", "upper", "ad", "d", "session", "db", "da", "doc", "dr", "obj", "get", "wd", "data", "cmd", "pkg", "update", "dir", "ict", "und", "def", "cond", "str", "del", "state", "ld", "red", "nd", "vol", "conf", "dd"], "cookies": ["goodsters", "Cookbooks", "coinsied", "replys", "Cookied", "copy", "bufiers", "innys", "readsters", "cookied", "cookys", "readys", "cellies", "copIES", "Cookries", "copies", "bufys", "cookries", "cookIES", "coinsys", "warnys", "CookIES", "coinssters", " cooks", "curys", "Cookials", "replIES", "replies", "Cookys", "innbooks", "cellys", "Cookiers", "innies", "curied", "coinsies", "cooky", "curies", "cookbooks", "warnied", "cmdys", "capys", "capies", "replied", "warnIES", "goodies", "cellries", "cookials", "warnies", "cmdies", "capIES", "copbooks", "Cooky", "cookiers", "bufries", "cmdells", "capy", "readies", "copials", "curs", "copys", "cooks", "cookells", "innials", "bufies", " cookells", "cooksters", "goodys", "payys", "goodied", "payied", "payies", " cookys", "Cooks", "celliers", "Cookies", "readied", "cmds", "Cookells", "pays"], "e": ["ea", "see", "ue", "ek", "el", "or", "de", "i", "ei", "en", "EEE", "ec", "me", "he", "eeee", "we", "end", "ne", "le", "ge", "ae", "eur", "te", "je", "g", "d", "one", "fe", "ffe", "se", "self", "peer", "ef", "ee", "re", "c", "entity", "es", "note", "ere", "ev", "et", "element", "eps", "o", "n", "ine", "eu", "ele", "ze", "er", "ce", "ent", "ger", "xe", "be", "ep", "E", "ie", "eg", "ed", "eb", "pe", "elt", "event", "eh", "err", "oe"]}}
{"project": "qemu", "commit_id": "9fbf4a58c90183b30bb2c8ad971ccce7e6716a16", "target": 1, "func": "static int get_physical_address (CPUMIPSState *env, hwaddr *physical,\n\n                                int *prot, target_ulong real_address,\n\n                                int rw, int access_type)\n\n{\n\n    /* User mode can only access useg/xuseg */\n\n    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;\n\n    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;\n\n    int kernel_mode = !user_mode && !supervisor_mode;\n\n#if defined(TARGET_MIPS64)\n\n    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n#endif\n\n    int ret = TLBRET_MATCH;\n\n    /* effective address (modified for KVM T&E kernel segments) */\n\n    target_ulong address = real_address;\n\n\n\n#define USEG_LIMIT      0x7FFFFFFFUL\n\n#define KSEG0_BASE      0x80000000UL\n\n#define KSEG1_BASE      0xA0000000UL\n\n#define KSEG2_BASE      0xC0000000UL\n\n#define KSEG3_BASE      0xE0000000UL\n\n\n\n#define KVM_KSEG0_BASE  0x40000000UL\n\n#define KVM_KSEG2_BASE  0x60000000UL\n\n\n\n    if (kvm_enabled()) {\n\n        /* KVM T&E adds guest kernel segments in useg */\n\n        if (real_address >= KVM_KSEG0_BASE) {\n\n            if (real_address < KVM_KSEG2_BASE) {\n\n                /* kseg0 */\n\n                address += KSEG0_BASE - KVM_KSEG0_BASE;\n\n            } else if (real_address <= USEG_LIMIT) {\n\n                /* kseg2/3 */\n\n                address += KSEG2_BASE - KVM_KSEG2_BASE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (address <= USEG_LIMIT) {\n\n        /* useg */\n\n        if (env->CP0_Status & (1 << CP0St_ERL)) {\n\n            *physical = address & 0xFFFFFFFF;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        }\n\n#if defined(TARGET_MIPS64)\n\n    } else if (address < 0x4000000000000000ULL) {\n\n        /* xuseg */\n\n        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0x8000000000000000ULL) {\n\n        /* xsseg */\n\n        if ((supervisor_mode || kernel_mode) &&\n\n            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xC000000000000000ULL) {\n\n        /* xkphys */\n\n        if (kernel_mode && KX &&\n\n            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {\n\n            *physical = address & env->PAMask;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xFFFFFFFF80000000ULL) {\n\n        /* xkseg */\n\n        if (kernel_mode && KX &&\n\n            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n#endif\n\n    } else if (address < (int32_t)KSEG1_BASE) {\n\n        /* kseg0 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG0_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG2_BASE) {\n\n        /* kseg1 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG1_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG3_BASE) {\n\n        /* sseg (kseg2) */\n\n        if (supervisor_mode || kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else {\n\n        /* kseg3 */\n\n        /* XXX: debug segment is not emulated */\n\n        if (kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 19431, "substitutes": {"env": ["enter", "ctx", "te", "e", "setup", "vp", "vs", "obj", "gear", "era", "manager", "req", "inv", "context", "er", "shell", "net", "ah", "environment", "Environment", "cv", "here", "t", "desc", "en", "end", "nv", "v", "ew", "response", "msg", "estate", "dev", "forge", "entry", "code", "org", "worker", "err", "init", "esm", "buf", "sv", "disk", "sw", "uv", "attr", "ptr", "ef", " environment", "ev", "erd", "rb", "state", "network", "nav", "eng", "window", "vt", "ec", "h", "equ", "config", "engine", "esc", "vm", "param", "outer", "conn", "cmd", "ext", "et", "conf", "eh"], "physical": ["pixel", "location", "memory", "basic", "hard", "protected", "base", "absolute", "resource", "virtual", "native", "vp", "prefix", "checked", "primary", "operation", "address", "image", "variable", "pointer", "reference", "route", "ip", "target", "external", "local", "binary", "Physical", "maximum", "network", "attribute", "exclusive", "localhost", "phys", "relative"], "prot": ["eth", "pos", "chron", "format", "lag", "opt", "flags", "ping", "at", "port", "ret", "protected", "pc", "what", "virtual", "prefix", "tif", "prop", "stat", "pro", "tf", "ptr", "addr", "typ", "reset", "rot", "def", "pat", "platform", "Prot", "net", "ocol", "policy", "protect", "version", "status", "phys", "type"], "real_address": ["realitymemory", "realtextelement", "absolute_route", "regular_address", "realtextmemory", "realetport", "real_attribute", "real_route", "signed_relative", "physical_Address", "real__addr", "realmlport", "realmmelement", "real_element", "realtextaddress", "realetrelative", "regular_pointer", "realpreroute", "signed_port", "realetaddress", "real_addr", "real_Address", "real_port", "absolutetextaddress", " real_location", "signedmmelement", "signedmmport", "realprememory", "realetelement", "absolutetextroute", "realmmaddress", "realationmemory", "realmmport", "realmmrelative", "realmlelement", "absolute_memory", "real__Address", "real_memory", "physical_address", "real_length", "regular1memory", "regular_memory", "absolute_element", "absolutetextelement", "real_location", "realityelement", "realmladdress", "realpreelement", "absolute_address", "regular1address", "realationaddress", "realmlrelative", "regular_length", "realityaddress", "real1address", "regular1pointer", "regular1length", "realationlength", "real__address", "real1pointer", "signed_address", "real1memory", "signedmmrelative", "physical_addr", "realationpointer", "real_pointer", "signedmmaddress", " real_attribute", "realtextroute", "signed_element", "realpreaddress", "absolutetextmemory", "realityroute", "real1length", "real_relative"], "rw": ["eth", "rew", "channel", "word", "res", "w", "weight", "wm", "term", "asm", "aw", "rt", "writer", "password", "wr", "pointer", "ptr", "rar", "route", "req", "ref", "r", "dc", "pack", "exclusive", "net", "write", "rf", "rib"], "access_type": [" access_types", " access_key", "accessoryinfo", "accessorytype", "accessorykey", "access_key", "accessorytypes", " access_info", "access_info", "access_types"]}}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n", "idx": 19434, "substitutes": {"spapr": ["spcapr", "spaptw", "spampR", "shopappr", "spppar", " spapar", "spapfr", "spiprus", "capapr", "espapm", "sprapar", "spaprer", "spcapcr", "sparpr", "sprapu", "spaper", "sprapz", "shampl", "spapcr", "spapres", "capappr", "sptapcr", "spraprr", "spapppr", "ispappbr", "espapcr", " spipr", "shampr", "spppr", "spaptrt", "sphappr", "espampr", "shophapu", "spapter", "spappw", "spumprt", "ispapper", "shapR", "spampcr", "spapu", "spapz", "sparpl", "spaptpr", "spumppr", "ispappr", "sppprus", "spampm", "spamfr", "spipbr", "sphapu", "sparmrer", "espapr", " spiprus", "sphapz", "spaml", "espampm", "shapr", "spapper", "spraprus", "espampres", "spapR", "capaprt", "sptapres", "shampR", "shopapu", "spaprus", " spaprus", "spapar", "spumprer", "capaprer", "spapbr", "spamR", "shapfr", "spipar", "spapw", "spapm", "sprapr", "shophapr", " spaprr", " spiprr", "sparmrt", "capaptpr", "sphapr", "spiprr", "spipw", "ispapr", "spiper", "espampcr", "sparmr", "capaptrer", "spampres", " spipar", "shophapz", "shophappr", "spampr", "spappr", "shampfr", "spipr", "shopapr", "ispapbr", "spapl", "shopapz", "capaptrt", "capaptr", "spamr", "spumpr", "espapres", "spampfr", "spaptr", "sprappr", "ispappw", "sparmpr", "sparpfr", "ispapw", "shapl", "spcapm", "spappu", "sptapm", "spaptrer", "spcapres", "spaptbr", "spampl", "spaprt", "spappz", "sptapr", "spappbr", "ispaper", "sppprr", "sparpR", "spaprr"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n", "idx": 19441, "substitutes": {"v": ["vi", "cv", "l", "qv", "w", "vim", "i", "p", "vt", "q", "h", "e", "av", "g", "sv", "vp", "u", "vc", "conv", "gov", "uv", "vs", "vm", "k", "verb", "c", "j", "vy", "r", "ev", "vu", "V", "vr", "f", "b", "m"], "name": ["a", "missing", "cap", "word", "error", "ame", "item", "san", "t", "w", "filename", "none", "p", "valid", "false", "term", "err", "prefix", "lat", "Name", "unknown", "named", "ma", "start", "data", "c", "id", "common", "r", "local", "def", "str", "n", "format", "path", "nan", "key", "alias", "title", "nm", "null", "no", "names", "NAME", "search", "code", "text", "create", "nam", "type"], "list": ["word", "format", "ist", "st", "li", "copy", "tree", "LIST", "local", "cache", "chain", "not", "index", "use", "form", "t", "none", "result", "set", "level", "lock", "limit", "drop", "collection", "parent", "List", "null", "layout", "view", "show", "status", "old", "ul", "l", "comment", "array", "only", "load", "match", "queue", "all", "any", "str", "print", "dict", "source", "info", "block", "bool", "isl", "count", "listed", "empty", "map", "lists", "out", "cont", "id", "record", "batch", "member", "table", "sequence", "seq", "file", "type"], "size": [" length", "izes", "index", "use", "z", "si", "args", "ci", "equal", "max", "sp", "num", "set", "zero", "scale", "sum", "count", "g", "empty", "shape", "length", "iz", "m", "capacity", "add", "sn", "data", "ize", "id", "ui", "n", "number", "space", "Size", "SIZE", "len", " sizes", "small", "code", "dimension", "type"], "errp": [" errr", " errpa", "errm", "errorm", "errorp", "rrpa", "errorP", " errping", "cerp", "rrpre", "ferp", "errpa", "erp", "erm", "errpre", "errr", "rrping", "rrp", "errping", "ferping", " errm", "errorr", "ferP", "cerpre", "errP", "cerP", " errpre", "rrP", "erP", "ferpa", " errP", "err"], "qiv": ["qqij", "qive", "qiver", "acquive", "quiv", "quiver", " qiev", "quivable", "acquiver", "quiev", "quiov", "qiev", " qive", "qivable", "quive", "qqiver", "requiver", "qiov", "requiov", " qiver", " qij", " qivable", "requiv", " qiov", "acquivable", "acquiv", "qqiev", "requivable", "qij", "quij", "qqiv"], "qobj": ["qujs", " qob", "queryjs", " qObj", "dqobject", "qjs", "qurect", "quso", "qso", "iqso", "qobject", "qrect", "quob", "dqobj", "iqobj", " qjs", "queryObj", " qobject", "qob", "queryobj", "quobject", "qObj", "quObj", " qrect", "queryob", "quobj", "dqjs", "dqso", "dqObj", "iqObj", "dqrect"], "entry": ["check", "needed", "expected", "index", "see", "form", "nt", "server", "or", "channel", "existent", "found", "ist", "comment", "equal", "sp", "cell", "result", "q", "ry", "set", "e", "created", "ace", "link", "match", "obj", "se", "add", "instance", "insert", "Entry", "data", "try", "record", "r", "line", "element", "member", "print", "key", "ent", "RY", "info", "exclusive", "row", "ary", "it", "search", "import", "way"]}}
{"project": "qemu", "commit_id": "0a982b1bf3953dc8640c4d6e619fb1132ebbebc3", "target": 0, "func": "static void test_qga_file_write_read(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    const unsigned char helloworld[] = \"Hello World!\\n\";\n\n    const char *b64;\n\n    gchar *cmd, *enc;\n\n    QDict *ret, *val;\n\n    int64_t id, eof;\n\n    gsize count;\n\n\n\n    /* open */\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-file-open',\"\n\n                 \" 'arguments': { 'path': 'foo', 'mode': 'w+' } }\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    id = qdict_get_int(ret, \"return\");\n\n    QDECREF(ret);\n\n\n\n    enc = g_base64_encode(helloworld, sizeof(helloworld));\n\n    /* write */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-write',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \",\"\n\n                          \" 'buf-b64': '%s' } }\", id, enc);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert_cmpint(eof, ==, 0);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read (check implicit flush) */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, \"\");\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* seek to 0 */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-seek',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \", \"\n\n                          \" 'offset': %d, 'whence': %d } }\",\n\n                          id, 0, SEEK_SET);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    qmp_assert_no_error(ret);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"position\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(!eof);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, enc);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n    g_free(enc);\n\n\n\n    /* close */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-close',\"\n\n                          \" 'arguments': {'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n}\n", "idx": 19469, "substitutes": {"fix": ["patch", "init", "check", "fd", "bridge", "format", "fab", "valid", "cell", " Fix", " prefix", "fixes", "test", "feature", "prefix", " patch", "fail", "force", "feat", "call", "FIX", "to", "field", "def", "Fix", "diff", "fc", "cod", "pre", "ifix", "edit", "fx", "mix", "f", "ix", "conf", "file"], "fixture": ["fluent", "gitness", "giction", "dixtures", "confactory", "fiber", "cactory", "flixtures", "testival", "futation", " fixtures", "dixture", " fluent", "flict", "confestival", "formitness", "diber", "fitness", "conflict", "formutation", "festival", "mitness", "tactory", "cestival", "fixtures", "fliber", "cixture", "fliction", "miction", "fllict", "clict", "tixture", "flutation", "flixture", " fitness", "confixture", "flitness", "formixture", "gixture", "factory", " futation", "mlict", "glict", "tlict", "dluent", "flluent", " fiber", "mixture", "fiction"], "helloworld": ["gallowworld", "helloweesome", "hellOWild", "hellowww", "helloyire", "hellonewily", "hellonewww", "helladowild", "galleworld", "hellewily", "hellowswell", "helloweworld", "helloyild", " hellowshell", "illoworld", " hellowwell", "hellewire", "hellowesome", "illowild", "hellowwell", "hellowsild", " hellowsild", "hellowsworld", "illewild", "illowire", "helloyorld", "helladowhell", "gallowily", "galloneworld", "helloyily", "gallewworld", "hellowire", "hellowworld", "galloworld", "hellowsily", "hellOWhell", " hellowsorld", "hellOWorld", "gallewesome", "helleworld", "helloweww", "hellowhell", "gallonewworld", "hellowily", "gallonewesome", "gallowesome", "gallewww", "helloneworld", " hellowswell", "illewily", " hellowhell", "hellowsesome", "hellewworld", "gallowww", "hellOWwell", "hellowsorld", "hellowshell", "hellowild", "hellewesome", "hellewild", "helladowwell", "hellonewesome", "helloweily", "helladoworld", "gallonewily", "illowily", "illewire", "illeworld", "hellowsire", "hellewww", " hellowild", "helloweorld", "hellonewworld"], "b64": [" b8", "rb32", "b32", "b8", "bg32", "gb128", "rb8", " b128", "base64", "base32", "rb64", "b1024", "base8", "gb8", "gb64", " bpl", "b63", "base128", "base1024", "bpl", "bgpl", "basepl", "bg1024", " b63", " b1024", "bg64", "rb63", "base63", " b32", "b128"], "cmd": ["ctx", "rt", "crit", "MD", "cd", "kind", "sys", "cat", "req", "dir", "cond", "dc", "path", "kick", "jump", "exec", "om", "grow", "fn", "pipe", "norm", "command", "handle", "ct", "force", "tab", "call", "msg", "pkg", "pt", "resp", "bind", "fun", "urg", "code", "ctr", "err", "help", "init", "nt", "opt", "term", "kt", "buf", "prop", "mt", "send", "method", "addr", "std", "cfg", "def", "act", "rc", "cp", "quit", "col", "args", "phy", "md", "op", "out", "Cmd", "wd", "conn", "data", "ind", "ext", "ref", "mk", "batch", "job", "cod", "cb"], "enc": ["con", "ic", "el", "eng", "nt", "format", "bn", "en", "ec", "buf", "Enc", "vc", "cc", "ct", "ch", "conv", "kw", "ot", "auth", "ew", "attr", "obj", "iv", "sys", "conn", "msg", "c", "eq", "ext", "str", "dc", "act", "fc", "cod", "ent", "ENC", "nc", "lang", "encrypted", "len", "bin", "rc", "ac", "code", "buff", "inc", "col", "err"], "ret": ["back", "dt", "ctx", "rt", "iter", "sys", "cat", "eval", "req", "jp", "del", "aux", "gd", "ert", "cert", "net", "rets", "mem", "el", "t", "result", "ry", "vet", "gz", "dat", "d", "detail", "RET", "reset", "re", "pt", "ts", "resp", "it", "elt", "rm", "res", "nt", "pret", "rect", "kt", "buf", "il", "tr", "mt", "reg", "backed", "ft", "lt", "addr", "det", "att", "std", "def", "dict", "alt", "got", "gt", "grad", "deg", "git", "final", "vt", "ll", "out", "db", "dr", "rem", "rev", "lit", "rel", "ref", "et", "repl", "uf", "prot", "Ret"], "val": ["loc", "pr", "valid", "tx", "lib", "test", "base", "rt", "vals", "arg", "obj", "eval", "cond", "cho", "pl", "serv", "mem", "gold", "Val", "el", "item", "sel", "sil", "t", "var", "dat", "bil", "v", "pt", "dev", "x", "resp", "al", "it", "elt", "old", "res", "pret", "als", "expr", "buf", "pol", "vec", "il", "stat", "reg", "pal", "cal", "def", "str", "act", "ele", "alt", "vo", "b", "col", "bal", "pos", "grad", "rol", "arr", "p", "fol", "vt", "VAL", "aval", "ve", "value", "rem", "data", "gb", "rel", "ref", "vol"], "id": ["index", "fd", "res", "uid", "md", "en", "h", "hash", "pid", "ctx", "base", "end", "sid", "wid", "name", "ad", " rid", "d", "iq", "kid", "start", " tid", "bid", "hid", "iter", "kind", "addr", "Id", "ind", "aid", "ref", "rid", "ids", "oid", "et", " pid", "str", " offset", "key", "ent", "len", "mid", "f", "vid", " fid", "code", "ID", "it", "ident", "err", "type"], "eof": ["eeown", "leown", "leot", " eoh", "zeow", " eown", "Eow", "teov", "eot", " eok", "Eok", "teow", "eroe", "ueof", " eOf", "eeop", "eeow", "ueoh", "eov", "eoe", "eow", " eow", " eos", " eov", "eown", "erof", "estop", "eoh", "leof", "eos", "eeot", "estof", "Eoh", " eoe", "EOf", "erov", "estown", "eeos", "teoe", "zeof", "leow", "zeot", "ueok", " eop", "eop", "zeown", "Eof", "ueOf", "erow", "eOf", "estos", "eeof", "teof", "eok", "eeOf"], "count": ["index", "loc", "nt", "z", "size", "t", "found", "flag", "flags", "total", "depth", "num", "list", "test", "ctx", "err", "ount", "find", "sum", "child", "length", "cast", "amount", "stat", "ct", "name", " name", "cd", "cont", " counts", "add", "iter", "call", " code", "nb", "data", "c", "pt", "ind", "first", "batch", "coll", "cond", "n", "Count", "act", "key", "cache", "len", " err", "no", "full", "code", "ctr", "part", "conf", "counter", "col", " c", "type"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);\n\n}\n", "idx": 19473, "substitutes": {"data": ["next", "mem", "size", "window", "array", "input", "list", "zero", "device", "output", "ata", "map", "dat", "done", "values", "out", "image", "d", "DATA", "session", "accept", "mu", "Data", "di", "iter", "reader", "da", "read", "bytes", "batch", "table", "state", "block", "bin", "buffer", "text"], "unused": ["nus", " unusing", "nonusing", "uuse", "unausable", "uusable", " unspecified", "nuse", "unaused", "unusing", "nonuse", "unaspecified", "nonused", "uused", " unusable", "unause", "unus", " unuse", "unusable", "unspecified", "nused", "nonus", "nusing", " unus", "uspecified", "unuse"]}}
{"project": "qemu", "commit_id": "01cd90b641e1aed40cf13a577e6a737af94d55e7", "target": 0, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n", "idx": 19490, "substitutes": {"xendev": ["xentame", " xndee", "xendDEV", "xendeg", "xendDev", "xtentown", "xendeee", " xendeower", "xtenddev", "lexendec", "xentown", "xENDec", "xtenteg", " xendeiv", " xenddev", "xendown", "xbeginev", "lexendedoc", "xenderower", "xendriver", "xenderec", "xenterv", "yendeddev", "xendower", " xendower", "xengev", "xengower", "xndev", "xendedeg", "xendeev", "xENDdev", "xenderoc", " xendee", "xENDriver", "xtendriver", "xendsec", "xentata", "yendedeg", "xendedDEV", "wxendDEV", "xenderee", "xtendata", " xndev", "xndame", "xenteg", "xendedoc", "exendedov", "xendsoc", "xendec", "xbegindev", "xentoc", "yenddev", "wxendev", "wxendedDev", " xendeev", "xentdev", " xndame", "xenderiv", "xendiv", "xenderev", "xendeower", "xendedee", "xestev", "wxendedev", "xendeec", "xendedfo", "xendeown", "xendedov", "xENDDEV", "xtendeg", "xendame", "wxendedfo", "xestfo", " xendiv", "xendingev", " xendame", "xtentata", "xendata", "xENData", "xendingriver", "xndee", "xentev", "wxendedDEV", "xtendoc", "lexendedev", "lexendoc", "xestDEV", "xENDoc", "xendsev", "xendingata", "xenderv", "xendeov", "xENDDev", "xendeddev", "xendfo", "xENDfo", "yendev", "lexendedec", "xendeiv", "xnddev", "xbegineg", "xtentdev", "yenderv", "xendedown", "exendedown", "xentriver", " xendeee", "xendedev", "xtendown", "exendown", "xENDerv", "exendov", "xestDev", "xendee", "xendedDev", "xENDeg", "exendedev", "xendederv", "xendoc", "wxendfo", "xendingoc", "xengiv", "yendedev", "exendedec", "exendec", "xENDev", "exendev", "xendov", "xENDov", "xenddev", "wxendDev", "xENDown", "yendeg", "xbeginown", "xengee", "xtentoc", "xentee", "xendedec", "lexendev", "xtendev", "yendederv", " xnddev", "xtentriver", "xtentev", "xendedame"], "i": ["hi", "li", "ri", "I", " l", "ai", "conv", "di", "mi", "c", "ji", "asi", "series", "multi", "ii", "index", "ij", "t", "ci", " n", "list", "\u0438", "phi", " multi", "v", "cli", "io", "pi", "gi", "n", "fi", "bi", "x", "zi", "ini", "f", "it", "iu", "err", "init", "ic", "l", "ei", "qi", " ti", "me", " ii", " mi", " k", "ip", " li", "to", " j", "iri", "j", "ti", " I", "ami", "uri", "info", " si", "go", " bi", "ix", "y", "m", "si", "im", "p", "h", " pi", "is", "oi", "ind", "in", "id", "xi", "r", "batch", "ui", "ims", " ni", " m", " v", "sim"], "xen_9pdev": ["xen_9erdev", "xen_9wpcast", "xen_09tpdef", "xen_9powerserv", "xen_9predev", "xen_9pDev", "xen_9tdevice", "xen_ninepgo", "xen_9lpDev", "xen_1tev", "xen_9pcast", "xen_970wdes", "xen_9pdeal", "xen_9psdev", "xen_9wver", "xen_9ddes", "xen_9pde", "xen_9dconn", "xen_8pdevice", "xen_9rver", "xen_9ipserv", "xen_9fev", "xen_9phpdev", "xen_9ppfam", "xen_21pdev", "xen_ninetdevice", "xen_ninetgu", "xen_9ipve", "xen_9cev", "xen_13pdconn", "xen_9tev", "xen_9psver", "xen_9pgu", "xen_1psd", "xen_12pds", "xen_9pbdem", "xen_9wpgo", "xen_9tpro", "xen_9wpde", "xen_9gver", "xen_93pdev", "xen_9powerds", "xen_9piddevelop", "xen_9ppdef", "xen_9powerden", "xen_996pver", "xen_9ndef", "xen_9ppdev", "xen_9picache", "xen_9pschool", "xen_8tdd", "xen_9pcdevice", "xen_96pver", "xen_9piddd", "xen_9lpdev", "xen_tenerDEV", "xen_13pdDev", "xen_9ddevelop", "xen_970pdes", "xen_9Pdevice", "xen_93pth", "xen_93pival", "xen_9lpDEV", "xen_9psfam", "xen_9phpserver", "xen_8pserver", "xen_9pergo", "xen_21phpdev", "xen_9pcache", "xen_ninepgu", "xen_9pscast", "xen_9pidev", "xen_99pDEV", "xen_tenpdev", "xen_ninengo", "xen_ninepdef", "xen_9lpadv", "xen_09pschool", "xen_tenerdev", "xen_9ppcast", "xen_9pcserv", "xen_9fver", "xen_12pdev", "xen_9pith", "xen_970pdev", "xen_996pdev", "xen_9edd", "xen_9tpdef", "xen_9pth", "xen_9pdef", "xen_9tdd", "xen_9lpconn", "xen_9phpdd", "xen_9Pdev", "xen_1pdev", "xen_9perver", "xen_8pdem", "xen_970ipserv", "xen_8pdevelop", "xen_9cdev", "xen_21phpdevice", "xen_ninepdevice", "xen_8pcdevelop", "xen_9rdev", "xen_9pcdev", "xen_9ipdes", "xen_12pserv", "xen_21phppro", "xen_99ipDEV", "xen_9ipev", "xen_970pver", "xen_09tpschool", "xen_9nserv", "xen_9tsd", "xen_9pdebug", "xen_9pcden", "xen_99pdevelop", "xen_9pdDev", "xen_9pev", "xen_8pcev", "xen_9wpdev", "xen_9tdem", "xen_9Ppro", "xen_9pconn", "xen_9ppdevice", "xen_9pve", "xen_8pcdev", "xen_9tver", "xen_09pdef", "xen_99ipdev", "xen_tenpdebug", "xen_9cdevices", "xen_970ipdev", "xen_9wdev", "xen_13pconn", "xen_9pddev", "xen_09pver", "xen_9pdd", "xen_12pden", "xen_9erver", "xen_ninepdev", "xen_9pcDEV", "xen_9pival", "xen_9erdebug", "xen_96psver", "xen_09tpdev", "xen_9tpcache", "xen_8pve", "xen_8tserver", "xen_ninepreq", "xen_12predev", "xen_9tpval", "xen_9psd", "xen_9ppschool", "xen_21ppro", "xen_9Pserv", "xen_ninenver", "xen_9piddevice", "xen_970ipfam", "xen_9pbserver", "xen_1tver", "xen_99pdev", "xen_9lpdebug", "xen_970pDev", "xen_9pdconn", "xen_996apver", "xen_9pval", "xen_9pbdd", "xen_8pver", "xen_9ngo", "xen_tenpver", "xen_9rde", "xen_9pbev", "xen_ninepver", "xen_ninepserv", "xen_9pserv", "xen_9wpDev", "xen_13pDev", "xen_996pdevices", "xen_9pcds", "xen_9tpver", "xen_9ppreq", "xen_9edeal", "xen_9pserver", "xen_1pev", "xen_9pbve", "xen_tenpDEV", "xen_9pdadv", "xen_9pdem", "xen_9gdebug", "xen_9pcver", "xen_tenerdebug", "xen_1tsd", "xen_8pdd", "xen_9phpev", "xen_9perdef", "xen_9persdev", "xen_996apdev", "xen_9phppro", "xen_8tve", "xen_96psfam", "xen_9ipfam", "xen_1tdev", "xen_9perscache", "xen_12preden", "xen_970wdev", "xen_96psdev", "xen_96pdev", "xen_96pscast", "xen_12preserv", "xen_9preserv", "xen_9dev", "xen_09pdev", "xen_9padv", "xen_21pdevice", "xen_9tve", "xen_970wDev", "xen_9nver", "xen_12preds", "xen_tenerver", "xen_9erdevice", "xen_8pDev", "xen_9lpserv", "xen_21pev", "xen_9powerdev", "xen_9ipDEV", "xen_9ppver", "xen_9pcdevelop", "xen_9apdev", "xen_9wpserv", "xen_9ppgu", "xen_93pcache", "xen_8tdev", "xen_9pdevice", "xen_9piddeal", "xen_13pdadv", "xen_9phpdevice", "xen_9Pev", "xen_93pidev", "xen_99pserv", "xen_9ergu", "xen_970pfam", "xen_ninenserv", "xen_9dadv", "xen_999pdd", "xen_9edev", "xen_1pver", "xen_9pdevices", "xen_9wpfam", "xen_9pDEV", "xen_9wdes", "xen_9ppdevices", "xen_ninetdev", "xen_8tev", "xen_970wver", "xen_9apver", "xen_9apdevices", "xen_9perdev", "xen_9preds", "xen_ninendev", "xen_9wpver", "xen_9persval", "xen_13pddev", "xen_999pdev", "xen_9ddevice", "xen_9ppro", "xen_9ppsd", "xen_99ipdevelop", "xen_9nev", "xen_9ipdem", "xen_9tpdev", "xen_9ndev", "xen_9pfam", "xen_9pdevelop", "xen_8pdev", "xen_9ipdevelop", "xen_9wpdef", "xen_9erDEV", "xen_ninepev", "xen_999piddev", "xen_9lpdeal", "xen_999piddeal", "xen_8pcdevice", "xen_9ppev", "xen_13pdev", "xen_9treq", "xen_13padv", "xen_ninenev", "xen_9tpschool", "xen_9ddev", "xen_9erreq", "xen_99ipserv", "xen_93pith", "xen_93pval", "xen_9Pfam", "xen_9lpdd", "xen_999piddd", "xen_9pds", "xen_9dDev", "xen_9tgu", "xen_09tpver", "xen_9preq", "xen_96pfam", "xen_9tserver", "xen_21phpev", "xen_9tdev", "xen_9gdev", "xen_9ipdev", "xen_970pserv", "xen_9pver", "xen_999pdeal", "xen_9ipDev", "xen_9pden", "xen_9pgo", "xen_9pdes", "xen_8pev", "xen_9dver", "xen_9lpdevelop", "xen_ninetreq", "xen_996apdevices", "xen_8tdem", "xen_9nschool", "xen_9lpver", "xen_9pbdev", "xen_93picache", "xen_9fsd", "xen_9persth", "xen_9rDev", "xen_9wDev", "xen_9cserv", "xen_8pde", "xen_96pcast", "xen_9pcev", "xen_9piddev", "xen_9ipver", "xen_9tpth", "xen_9preden", "xen_9gDEV", "xen_9fdev", "xen_9cver", "xen_ninendef"], "s": ["ds", "t", "w", "p", "sb", "h", "e", "g", "sv", "rs", "gs", "S", "ss", "d", "v", "ps", "c", "j", "r", "o", "n", "fs", "stats", "b", "m"], "fsdev": ["FSDEV", "FSdev", "fsDev", "csdevice", "fsdevice", "FSDev", " fsDEV", "csDEV", "FSdevice", " fsDev", "csDev", "csdev", "fsDEV", " fsdevice"], "str": ["pr", "st", "STR", "fr", "g", "shr", "rs", "iter", "c", "inner", "er", "buffer", "chain", "exec", "sl", "t", "sp", "cur", "Str", "v", "sts", "doc", "msg", "cr", "ocr", "usr", "x", "f", "it", "ctr", "sc", "err", "init", "cs", "res", "w", "enc", "expr", "buf", "prefix", "tr", "name", "sw", "j", "def", "raw", "print", "txt", "b", "arr", "p", "out", "dr", "cont", "data", "inst", "r", "new", "key", "vol", "comp", "seq", "br"], "ring_order": ["ray_record", "ring_record", "ring_ord", "ray_index", "ray_ord", "ray_order", "ring_index"]}}
{"project": "qemu", "commit_id": "299f80130401153af1a6ddb3cc011781bcd47600", "target": 0, "func": "static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n", "idx": 19492, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "ops", "t", "w", "i", "p", "sb", "ses", "sq", "h", "q", "ctx", "set", "is", "conf", "g", "rs", "gs", "S", "ss", "d", "v", "ns", "sts", "self", "obj", "ps", "sys", "js", "c", "es", "r", "context", "n", "o", "source", "ts", "x", "state", "stats", "spec", "sc", "b", "y", "its", "m"], "op": ["loc", "pop", "ok", "or", "ops", "wp", "opt", "ist", "oc", "p", "pp", "sp", "og", "oss", "set", "expr", "ob", "arg", "cop", "copy", "opp", "ot", "operation", "ox", "co", "OP", "attr", "obj", "ip", "ps", "mp", "bit", "up", "cmd", "update", "operator", "ext", "jp", "oper", "cmp", "o", "ack", "pl", "omp", "cp", "Op", "ac", "it", "comp", "oop", "ost", "hop", "oe"], "args": ["atts", "ds", " arguments", "cs", "ops", "arr", "arms", "terms", "flags", "p", "members", "as", "ins", "ics", "posts", "aws", "results", "Args", "qs", "items", "ars", "bs", "vals", "arg", "pres", "rs", "gs", "values", "aus", "ns", "vs", "aps", "ams", "ps", "js", "mus", "related", "ids", "options", "eps", "fs", "ags", "aux", "uns", "ts", "actions", "ims", "parts", "params", "ads", "ms", "us", "ents", "orders", "issues"], "dst": ["dsts", "sdst", "didst", "dsend", "dsmt", "pdest", "kpr", "dST", "dsest", " dlt", "jend", "Dst", "snd", "Dv", "dast", "sct", " ddest", "deldest", "dsnd", "sdST", "sest", "adst", " dpt", "Dct", "sdest", "DST", " dz", "dusts", "ddest", "dudest", "dpr", "dust", "diddest", "delmt", " dpr", "dlt", "dot", " dennd", "hst", "fdest", "jst", "fmt", "dsct", "dssts", "pnd", "kbr", "dno", "dadest", "jbr", "dpt", "dsST", "fport", "dmt", "Dest", "jz", "dct", " dv", "fst", "sst", "pst", "dbr", "dsv", " dot", "disST", " dest", " dST", "dalt", "adST", "adr", "dspt", "disest", "Dr", "daend", " dend", " denst", "adot", "dsbr", "dz", "pno", "delport", "sdmt", " dbr", "kst", "Ddest", "dsdest", "Dmt", "dnd", " denST", " dport", " dnd", "hdest", "dv", "delst", "disend", "disst", "dsst", " dsts", "dr", "Dot", " dno", "dport", "duend", "dend", "Dnd", "Dend", "jmt", " dr", "didno", "jlt", "hpt", "jdest", "jpt", "hbr", " dendest", "didnd", "jpr", "dest", " dmt", "kz"], "src": ["loc", "st", "ctx", "rt", "rs", "conv", "self", "iv", "sys", "RC", "sync", "origin", "nil", "sr", "spec", "hl", "desc", "sp", "set", "syn", "cur", "tmp", "vc", "sec", "sn", "via", "obs", "usr", "null", "from", "vr", "stats", "ctr", "sc", "init", "snap", "rob", "sb", "sub", "proc", "th", "sv", "other", "bc", "cc", "ptr", "attr", "sing", "addr", "target", "std", "str", "rb", "source", "txt", "rc", "scan", "ins", "isc", "sq", "bs", "supp", "cmd", "inst", "r", "comp", "dest", "ser", "phys", "rl"], "mask": ["temp", "z", "mac", "weight", "bits", "hash", "shift", "mount", " masked", "scale", " mu", "clear", " flags", "mb", " scale", "mas", "bit", "cm", "cache", "offset", "index", "perm", "flag", "miss", "flags", " stamp", "result", "set", "zero", "hold", "lock", "shape", "ma", " masks", "mark", "pack", "qa", "code", "status", "cover", "box", "ask", "comment", " mark", "mod", "match", "mt", "target", "cmp", " Mask", "block", "write", "scan", "Mask", "m", "hide", " error", "window", "sk", " flag", "gc", "count", "config", "map", "sign", "allow", "fix", "id", "tag", "batch", " offset", "key", "share", "filter", "ms", "type"]}}
{"project": "FFmpeg", "commit_id": "3594554a064d76e3514fab9781c0e63ea9e08ea9", "target": 0, "func": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx)\n\n{\n\n  /* VIS-specific optimizations */\n\n  int accel = vis_level ();\n\n  const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n  if (accel & ACCEL_SPARC_VIS) {\n\n      if (avctx->bits_per_raw_sample <= 8 &&\n\n          avctx->idct_algo == FF_IDCT_SIMPLEVIS) {\n\n          c->idct_put = ff_simple_idct_put_vis;\n\n          c->idct_add = ff_simple_idct_add_vis;\n\n          c->idct     = ff_simple_idct_vis;\n\n          c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n      }\n\n\n\n      if (!high_bit_depth) {\n\n      c->put_pixels_tab[0][0] = MC_put_o_16_vis;\n\n      c->put_pixels_tab[0][1] = MC_put_x_16_vis;\n\n      c->put_pixels_tab[0][2] = MC_put_y_16_vis;\n\n      c->put_pixels_tab[0][3] = MC_put_xy_16_vis;\n\n\n\n      c->put_pixels_tab[1][0] = MC_put_o_8_vis;\n\n      c->put_pixels_tab[1][1] = MC_put_x_8_vis;\n\n      c->put_pixels_tab[1][2] = MC_put_y_8_vis;\n\n      c->put_pixels_tab[1][3] = MC_put_xy_8_vis;\n\n\n\n      c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;\n\n      c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;\n\n      c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;\n\n      c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;\n\n\n\n      c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;\n\n      c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;\n\n      c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;\n\n      c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;\n\n\n\n      c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;\n\n      c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;\n\n      c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;\n\n      c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;\n\n      }\n\n  }\n\n}\n", "idx": 19494, "substitutes": {"c": ["check", "con", "cv", "cs", "ic", "l", "tc", "ca", "can", "t", "z", "ci", "p", "mc", "ec", "enc", "ctx", "set", "err", "unc", "pc", "gc", "e", "g", "cam", "config", "cf", "vc", "cc", "ct", "bc", "content", "co", "all", "v", "etc", "cont", "call", "pi", "cr", "lc", "cm", "dc", "C", "coll", "n", "fc", "ce", "cu", "cache", "nc", "anc", "xc", "com", "cp", "rc", "ac", "abc", "chain", "arc", "spec", "sc", "scan", "conf", "m"], "avctx": ["avecontext", "AVctx", "averparams", "navcontext", "aupkg", "avtc", "aveconn", " avtc", " avcontext", "varparams", "avercmp", "wavkb", "navtmp", "wavcf", "aukb", "navkb", "varctx", "wavpkg", "auctx", "navcf", "wavctx", "avconn", "navjp", "avcontext", "avcmp", "varcas", "aucf", "avkb", " avconn", "AVcas", "avetmp", " avjp", "AVcmp", "varcmp", "avcas", "avetc", "avcf", "averctx", "AVparams", "avpkg", "savtc", "avparams", "avectx", "navpkg", "avtmp", " avtmp", "avjp", "navctx", "savcontext", "savconn", "avejp", "savctx", "avercas"]}}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc(VP8Context *s, int luma,\n\n            uint8_t *dst, uint8_t *src, const VP56mv *mv,\n\n            int x_off, int y_off, int block_w, int block_h,\n\n            int width, int height, int linesize,\n\n            vp8_mc_func mc_func[3][3])\n\n{\n\n    if (AV_RN32A(mv)) {\n\n        static const uint8_t idx[3][8] = {\n\n            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,\n\n                                        // also function pointer index\n\n            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required\n\n            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels\n\n        };\n\n        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];\n\n        int my = (mv->y << luma)&7, my_idx = idx[0][my];\n\n\n\n        x_off += mv->x >> (3 - luma);\n\n        y_off += mv->y >> (3 - luma);\n\n\n\n        // edge emulation\n\n        src += y_off * linesize + x_off;\n\n        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - idx[2][my]) {\n\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n\n                                block_w + idx[1][mx], block_h + idx[1][my],\n\n                                x_off - mx_idx, y_off - my_idx, width, height);\n\n            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n        }\n\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n\n    } else\n\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n}\n", "idx": 19538, "substitutes": {"s": ["a", "ds", "cs", "t", "w", "sg", "settings", "i", "csv", "p", "sb", "sp", "ses", "st", "ins", "sq", "aws", "h", "set", "qs", "is", "e", "g", "south", "sv", "rs", "gs", "S", "ss", "d", "sw", "ns", "v", "sts", "ps", "sys", "sports", "js", "service", "ex", "c", "ats", "r", "https", "n", "fs", "less", "ts", "ls", "stats", "spec", "b", "m"], "luma": ["linora", " lanca", "luten", "Loco", "lum", "leoco", "oloco", "Luma", "nlanca", "luc", "Lfu", "oluna", "leanca", "muna", "mum", "Lanca", "olanca", "Luna", "muma", " luc", "nlasma", "leuten", "leuna", "linuma", " luna", "lora", "lasma", "linasma", "Luc", "leuc", "lfu", " lfu", "Luten", "luna", "leuma", "leasma", "nluma", "linanca", "Lum", "nlora", " lum", "oluma", " luten", "lanca", "mfu", "loco", "leora"], "dst": ["ddest", "sdst", "adrc", "rost", "adpt", "bot", " dest", "sdot", " dost", "dot", "iddest", "Dost", "brc", "rdest", "adot", "Dst", "idsrc", "idst", "rst", " ddest", "dpt", "bst", "dsrc", "sdrc", "bpt", "Dest", "adst", "Dsrc", "Ddest", "drc", "dost", "rest", " dsrc", "sdpt", "idest", "dest"], "src": ["init", "offset", "ul", "loc", "fn", "sort", "ur", "dist", "filename", "sh", "sb", "sup", "sub", "ins", "st", "input", "sq", "th", "stream", "rx", "proc", "rt", "ri", "fr", "rs", "copy", "tmp", "sec", "start", "ptr", "iter", "iv", "addr", "sn", "sys", "insert", "via", "target", "inner", "inst", "r", "sync", "str", "usr", "source", "cb", "sr", "lib", "rc", "scan", "sur", "url", "sc", "b", "dest", "ser", "lr", "rl"], "mv": ["vtv", "lv", "manvi", "mvm", "vvt", "lvc", " mceive", "px", "mvp", "mtv", "gmv", " mtv", "dmvm", " mva", "amvP", "gmvin", " mvP", "lx", "mvP", "mV", "vmv", "manvin", "mvi", "vmtv", "vj", "amvm", "dmv", "vva", "dv", "vmj", "mcV", "vmvm", "mceive", "vmvin", "dmvc", " mvc", "mj", "lvp", "mva", "vmV", "mvc", "gmvm", "amV", "manv", "mcceive", "mcv", "mvin", " mvm", "mx", "amvc", "dmvP", " mvp", "vV", "pv", "pvt", "dvc", "gmvi", "amv", "dvp", " mvt", " mx", "manvm", "pva", "amceive", "vv", "mvt", "dx", "vx", " mj", "vmvi", "mcvP", " mV"], "x_off": ["yx_free", "x__offset", "xactoff", " x_err", "ex_off", "ex_along", "x__off", " x_offer", "x_free", "yxactoff", "x_err", "xacthand", "xactfree", "ex_on", "yx_off", "xxout", "xxhand", " x_OFF", "x_hand", "xxoffer", "x_offset", "yx_hand", "x___off", "yxactfree", "xxOFF", "xactout", "x___on", "x67out", "yx_out", "xxoffset", "xxfree", "x_OFF", "yxactout", "yxacthand", "x67free", "xxoff", "x_on", "x_offer", "ex_offset", "x_out", " x_on", "x__on", "x67off", " x_offset", "xxon", "x67hand", "x_along", "x___err"], "y_off": ["y_on", "y_before", "y___zero", "y_offer", "y_zero", "ry_end", "yo___zero", "vy_before", "y__OFF", "yo___off", "y_att", " y_OFF", "ry_off", "ry_on", "y_raw", "yo_off", "yo___OFF", "cy_off", "vy_offs", "y_offs", "y___OFF", "x_OFF", "cy_offer", "cy_att", "y___off", "y___raw", "y__off", "y_end", "y_OFF", "x_on", "yo_zero", "yo_OFF", "vy_off", " y_offs", "yo_raw", "yo___raw"], "block_w": ["window__W", "window__m", "block_m", "Block_wid", "block_wid", "block2W", "window__w", "block_W", "block_wx", "window_W", "blockJW", "Block_w", "blocklogm", "Block_h", "block__wh", "blocklogwh", "block2h", "blocklogW", "blockJwx", "window_w", "Block_W", "window__wh", "block_wh", "block2wx", "window_m", "block__W", "Block_wx", "block2w", "block__w", "window_wh", "blockJh", "blocklogw", "block__m", "blockJw"], "block_h": [" block_hi", "blockgrhi", "blockPh", "block2hh", "block_v", "block_hh", "blockgrw", "blockPw", "Block_w", "block2v", "Block_h", "Block_hh", "blockgrh", " block_hh", "block_hi", "block2h", "blockPhh", " block_hw", "block2w", "block_hw", " block_v", "blockPv"], "height": ["grow", "history", "sky", "size", "density", "gravity", "depth", "total", "w", "window", "t", "acity", "hang", "h", "hash", "radius", "html", "volume", "count", "shape", "resolution", "padding", "length", "ch", "capacity", "bottom", " Height", " heights", "rows", "rank", "block", "row", "alpha", "build", "angle", "ows", "ty", "Height", "y"], "linesize": ["odesizer", "inesize", "lesization", "lesized", "linesized", "lines8", "ines8", "linessize", "linesizing", "linksized", "elinespace", "lineIZE", "linesizer", "pointsizer", "lesize", "inesization", "blocksization", "pagesize", "blocksize", "lineize", "lineizer", "linespace", "stylesizer", "pinsization", "elinesIZE", "linsizing", "codesIZE", "inspace", "insizer", "elinesizer", "linksizer", "inesIZE", "elinesize", "odesized", "insize", "linsIZE", "pinssize", "insIZE", "codesize", "codesization", "stylespace", "lesizer", "pinsIZE", "stylesIZE", "pointsized", "linesIZE", "inessize", "linksize", "linssize", "blocksizer", "linsization", "lins8", "inespace", "blocksized", "odesize", "odesizing", "linksization", "pagesizer", "linsize", " lines8", "lineization", "linksIZE", " linespace", "linksizing", " linesIZE", "linepace", "stylesize", "linesization", "pinsize", "codesizer", "linsizer", "pointsization", "pointsize", "pagesization", "inesizer", "pagesIZE", " linesizer", "linsized"], "mc_func": ["mc2unc", "MC2fc", "MC2unc", "MC_fc", "MC2func", "mc2fc", "MC_func", "mc_function", " mc_kw", " mc_function", "mc_fun", "MC_unc", "mc_fc", "mc2kw", " mc_unc", " mc_fc", "mc2func", " mc_fun", "mc_unc", "mc_kw"], "idx": ["idsp", "ridox", "idsox", "Idx", " idX", "infoc", "idv", "IDx", "idc", "Idst", "idsex", "Idxs", "Idp", "idst", "andx", "andct", "Idxb", "midci", "IDX", "infoxb", "idsy", "pidxs", " idp", "ridx", " idst", "idsx", " idy", "infox", "midxs", "Idc", " idex", "IDxs", "idci", "identw", "Idy", "indv", "andv", "andw", "adox", "midx", "pidy", "pidst", "idX", "ady", "idy", "indw", "midix", "Idw", "ridv", "ridy", "IDc", " idci", "idix", "idxb", "IDxb", "ridci", "idex", "pidx", "ridxs", "IDw", "idsxs", "adv", "indx", "idox", "idct", "adx", "idsv", "identct", "ridix", "identx", "indct", "Idex", "idw", "idxs", "idp", "infow", "identv", " idxs", "IDex", " idix", "IdX"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 19554, "substitutes": {"dev": ["mem", " device", "os", "nt", "or", "w", "de", "ach", "pad", "dep", "Dev", "proc", "md", "ow", "dis", "device", "DEV", "av", "cam", "ad", "d", "pro", "v", "hw", "wd", "conn", "data", "priv", "att", "ev", "act", "Device", "ver", "ac", "serv", "od"], "prop": ["pos", "prev", "or", "pr", "p", " Prop", "term", "proc", "test", "property", "op", " props", "sec", "pro", "sty", "bug", "attr", "doc", "pri", "feat", "ps", "spec", "priv", "pkg", "cmd", "pt", "rop", "cfg", "def", "pred", "fx", "cp", "comp", "Prop", "conf", "col"], "str": ["b", "arr", "res", "w", "p", "desc", "sp", "st", "list", "enc", "STR", "ar", "buf", "fr", "Str", "tr", "name", "out", "ctr", "doc", "cont", "msg", "c", "data", "r", "raw", "txt", "vol", "s", "f", "chain", "spec", "text", "seq", "br", "err"], "ptr": ["eth", "pos", "index", "np", "arr", "deg", "dist", "t", "Ptr", "pr", "pad", "sh", "p", "sp", "dep", "proc", "th", "ctx", "buf", "tr", "tp", "handle", "rep", "pointer", "resh", "dr", "inter", "iv", "addr", "ps", "tip", "obj", "pt", "ind", "rel", "ref", "jp", "inst", "pert", "ts", "prime", "src", "ctr"], "fmt": ["tfct", " fformat", "fcMT", " fmid", "hformat", "tfmt", " fMT", "fcmid", "fformat", "htm", "fcformat", "vstr", " ftm", "vformat", "Ftm", "fMT", "FMT", "vct", "fct", "fmid", "tfformat", "hMT", "Fmt", "fcmt", "Fmid", "hmt", "fstr", " fstr", "ftm", "tfstr", "Fformat", "vmt", " fct"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "DECLARE_LOOP_FILTER(mmxext)\n\nDECLARE_LOOP_FILTER(sse2)\n\nDECLARE_LOOP_FILTER(ssse3)\n\nDECLARE_LOOP_FILTER(sse4)\n\n\n\n#endif /* HAVE_YASM */\n\n\n\n#define VP8_LUMA_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][2] = ff_put_vp8_epel ## SIZE ## _h6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][0] = ff_put_vp8_epel ## SIZE ## _v6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][2] = ff_put_vp8_epel ## SIZE ## _h6v6_ ## OPT\n\n\n\n#define VP8_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][1] = ff_put_vp8_epel ## SIZE ## _h4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][0] = ff_put_vp8_epel ## SIZE ## _v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][1] = ff_put_vp8_epel ## SIZE ## _h4v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][2] = ff_put_vp8_epel ## SIZE ## _h6v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \\\n\n    VP8_LUMA_MC_FUNC(IDX, SIZE, OPT)\n\n\n\n#define VP8_BILINEAR_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][1] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][2] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT\n\n\n\n\n\nav_cold void ff_vp8dsp_init_x86(VP8DSPContext* c)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        c->vp8_idct_dc_add    = ff_vp8_idct_dc_add_mmx;\n\n        c->vp8_idct_dc_add4uv = ff_vp8_idct_dc_add4uv_mmx;\n\n#if ARCH_X86_32\n\n        c->vp8_idct_dc_add4y  = ff_vp8_idct_dc_add4y_mmx;\n\n        c->vp8_idct_add       = ff_vp8_idct_add_mmx;\n\n        c->vp8_luma_dc_wht    = ff_vp8_luma_dc_wht_mmx;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_mmx;\n\n#endif\n\n        c->put_vp8_epel_pixels_tab[1][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[1][0][0] = ff_put_vp8_pixels8_mmx;\n\n\n\n#if ARCH_X86_32\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmx;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmx;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmx;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmx;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmx;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmx;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmx;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmx;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmx;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmx;\n\n#endif\n\n    }\n\n\n\n    /* note that 4-tap width=16 functions are missing because w=16\n\n     * is only used for luma, and luma is always a copy or sixtap. */\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        VP8_MC_FUNC(2, 4, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, mmxext);\n\n#if ARCH_X86_32\n\n        VP8_LUMA_MC_FUNC(0, 16, mmxext);\n\n        VP8_MC_FUNC(1, 8, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(1,  8, mmxext);\n\n\n\n        c->vp8_v_loop_filter_simple   = ff_vp8_v_loop_filter_simple_mmxext;\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmxext;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmxext;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmxext;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmxext;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmxext;\n\n#endif\n\n    }\n\n\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        c->vp8_idct_add                         = ff_vp8_idct_add_sse;\n\n        c->vp8_luma_dc_wht                      = ff_vp8_luma_dc_wht_sse;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_sse;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags) && (cpu_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, sse2);\n\n        VP8_MC_FUNC(1, 8, sse2);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, sse2);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, sse2);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_sse2;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_sse2;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_sse2;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        c->vp8_idct_dc_add4y          = ff_vp8_idct_dc_add4y_sse2;\n\n\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_sse2;\n\n\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_sse2;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse2;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, ssse3);\n\n        VP8_MC_FUNC(1, 8, ssse3);\n\n        VP8_MC_FUNC(2, 4, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, ssse3);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_ssse3;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_ssse3;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_ssse3;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_ssse3;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_ssse3;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_ssse3;\n\n    }\n\n\n\n    if (EXTERNAL_SSE4(cpu_flags)) {\n\n        c->vp8_idct_dc_add                  = ff_vp8_idct_dc_add_sse4;\n\n\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_sse4;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse4;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse4;\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n", "idx": 19557, "substitutes": {}}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int get_bat (CPUState *env, mmu_ctx_t *ctx,\n\n                    target_ulong virtual, int rw, int type)\n\n{\n\n    target_ulong *BATlt, *BATut, *BATu, *BATl;\n\n    target_ulong base, BEPIl, BEPIu, bl;\n\n    int i;\n\n    int ret = -1;\n\n\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    switch (type) {\n\n    case ACCESS_CODE:\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n        break;\n\n    default:\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n        break;\n\n    }\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s...: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    base = virtual & 0xFFFC0000;\n\n    for (i = 0; i < 4; i++) {\n\n        BATu = &BATut[i];\n\n        BATl = &BATlt[i];\n\n        BEPIu = *BATu & 0xF0000000;\n\n        BEPIl = *BATu & 0x0FFE0000;\n\n        bl = (*BATu & 0x00001FFC) << 15;\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                    \" BATl 0x\" ADDRX \"\\n\",\n\n                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                    *BATu, *BATl);\n\n        }\n\n#endif\n\n        if ((virtual & 0xF0000000) == BEPIu &&\n\n            ((virtual & 0x0FFE0000) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||\n\n                (msr_pr == 1 && (*BATu & 0x00000001))) {\n\n                /* Get physical address */\n\n                ctx->raddr = (*BATl & 0xF0000000) |\n\n                    ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |\n\n                    (virtual & 0x0001F000);\n\n                if (*BATl & 0x00000001)\n\n                    ctx->prot = PAGE_READ;\n\n                if (*BATl & 0x00000002)\n\n                    ctx->prot = PAGE_WRITE | PAGE_READ;\n\n#if defined (DEBUG_BATS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"BAT %d match: r 0x\" PADDRX\n\n                            \" prot=%c%c\\n\",\n\n                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                            ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n#endif\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & 0xF0000000;\n\n                BEPIl = *BATu & 0x0FFE0000;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                        \" BATl 0x\" ADDRX \" \\n\\t\"\n\n                        \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\",\n\n                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                        *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 19567, "substitutes": {"env": ["init", "cap", "here", "server", "eng", "t", "window", "desc", "sp", "proc", "en", "vt", "ec", "end", "err", "nv", "e", "te", "config", "disk", "worker", "sw", "v", "db", "esc", "ptr", "vs", "obj", "era", "ve", "attr", "instance", "param", "conn", "manager", "req", "cmd", "inv", "operator", "ext", "dev", "inst", "ev", "et", "context", "def", "extra", "er", "rb", "state", "org", "net", "ah", "pe", "code", "conf", "gate", "environment"], "ctx": ["con", "cv", "loc", "np", "tc", "nt", "ci", "tx", "p", "mc", "cas", "cf", "jac", "ct", "cc", "bc", "conv", "co", "hw", "obj", "conn", "req", "c", "cmd", "pkg", "context", "cmp", "ctrl", "act", "aux", "cu", "x", "cb", "Context", "anc", "xc", "cp", "rc", "exec", "sc"], "virtual": ["bal", "hidden", "binding", "index", "intel", "console", "server", "t", "total", "valid", "angular", "final", "vt", "interface", "required", "Virtual", "text", "domain", "protected", "ret", "normal", "absolute", "resource", "vert", "initial", "native", "vp", "virt", "name", "web", "v", "variable", "vm", "ptr", "ip", "bit", "target", "physical", "inv", "ref", "specific", "external", "local", "rendered", "context", "ui", "current", "binary", "unique", "vector", "bi", " v", "reverse", "sim", "actual", "view", "al", "net", "vr", "real", "full", "buffer", "initialized", "bitcoin", "version", "m"], "rw": ["rew", "res", "w", " wr", "wire", "weight", "ei", "ran", "rt", "ruby", "resource", "xp", "rin", " r", " w", "wr", "ptr", "self", "ip", "iv", "req", "inv", "physical", "ref", "bound", "ib", "net", "write", "lr"], "type": ["index", "word", "style", "error", "size", "t", "format", "weight", "ping", " typ", "where", "test", "port", "feature", "set", "family", "change", "action", "count", "ype", "what", "tp", "name", "all", "unit", "start", "ptr", "kind", "value", "class", "typ", "time", "types", "role", "range", "TYPE", "try", "scope", "id", "relation", "pack", "o", "state", "Type", "ver", "view", "function", "no", "pe", "ty", "rule", "file"], "BATlt": [" BATelt", "PORTLT", "BATelt", "SPEClt", " BATLT", "Batterylt", "GBTlt", "BATtl", "SPECelt", "Batteryelt", "GBTlin", "GBTl", "BATlin", " BATlet", "BATlet", "Batlet", "Batut", "BTLT", "Batlt", "ATlin", "Batlin", "Batteryut", "BTelt", "SPECl", "BTtl", "BTlt", "Batl", "Batelt", "GBTelt", "BATLT", "SPEClet", "PORTtl", "PORTelt", "ATl", " BATtl", "ATelt", "Batteryl", "PORTlt", "ATlt"], "BATut": ["Batutil", "GBTut", "BTUT", "GBTlt", "BTut", "BTul", "BATus", "LETlt", "GBTus", "BatUT", "BTu", "Batuts", "BTuts", "Batut", "BATuti", "Batlt", "BenUT", "BATul", "Batu", " BATus", "GBTu", "Batus", "BTuti", "LETutil", "BTlt", "BTutil", " BATul", "Benut", "LETut", "BATutil", "LETu", "BATUT", "Batuti", "Benuts", "Batul", " BATutil", "BATuts", "Benuti", "LETul"], "BATu": ["Bencu", "BatU", "GBTut", "GBTui", "BTcu", "NETou", "TAGui", "BTou", "NETu", "BTl", "CHATtu", "SPECou", " BATiu", "Batu", "SPECl", "Benut", "BTnu", "VISou", "VISu", "Batul", "GBTU", "VISut", "TAGou", "BTut", "GBTl", "BATus", "GBTus", "SPECu", "BTu", "BTuu", "Batnu", " BATul", "Batcu", "GBTou", "Batiu", "SPECut", "BATou", "BATiu", "SAMcu", "Battu", "BTul", "GBTuu", "Batut", "BATul", "BATnu", "BATtu", " BATU", "BTU", "BATcu", "SAMu", "Benl", "TAGus", "Batou", "GBTnu", "Benu", "NETus", " BATcu", "LOGu", "LOGou", "CHATl", "CHATu", "GBTu", "Batl", "VISl", "BATui", "SAMiu", " BATnu", "CHATut", "GBTcu", "SAMl", "TAGu", "BATuu", "LOGU", "BTtu", "NETui", "BATU", "LOGuu"], "BATl": ["BTli", "Batlp", "PINl", "SPEClp", "ATli", "Batn", "PINn", "uint", "GBTl", " BATln", "Batteryle", "BATlin", "BATli", " BATt", "BTl", "GBTln", "_", "BATt", "Batlt", "ATlin", "Batteryln", "GBTt", "Batlin", "Batli", "Batteryt", "SPECl", "bit", "BTlt", "Batl", "func", "ATlp", "BTn", "SPEClin", "BATlp", " BATle", "BATn", "PINlt", "new", "def", "V", "BL", "BATln", "PINli", "SET", "ATl", "BATle", "Batteryl", "GBTle", "SPECli"], "base": ["bal", "index", "binding", "server", "res", "used", "basic", "back", "p", "interface", "bp", "set", "bas", "e", "prefix", "name", "out", "m", "db", "v", "pointer", "bid", "ip", "bit", "re", "physical", "id", "ref", "r", "external", "binary", "et", "bound", "bi", "block", "net", "buffer", "real", "ex", "b", "file", "Base"], "BEPIl": ["BENDIl", "BDPEl", " BEPUs", "BDPIns", "PEEPFail", " BENDLu", "PEEPEl", "TEMIns", "TEMil", " BENDIl", "BDPLu", "BEPIns", "BEEPil", "BEEPLu", "PEEPNL", "BENDLu", " BEPIns", "BEEPFail", "TEPil", "BETEl", "PEEPIl", "BENDUs", "BEPNL", "BETNL", "TEMIl", "BEEPUs", "BEPEl", "BEMIl", "TEPIns", "BEMil", "BDPil", "BEEPIl", "BEEPIns", "BEPFail", "BDPIl", "BDPUs", "TEPEl", "TEMEl", " BENDUs", "PEPIl", "PEPFail", "TEPIl", "BEPLu", "BEMEl", "BEEPEl", "BETFail", " BENDIns", "PEPNL", "BEMIns", "BDPFail", "BEPil", "BEPUs", " BEPLu", "BETIl", "BENDIns", "PEPEl", "BEEPNL", "BDPNL"], "BEPIu": ["BEMPIntelus", "BEPIcu", "BEPiui", "BEPicu", "BEPEu", "BEPUIu", "BEPEui", "BEPIAuf", "BepIou", "BEPIntelu", "BEPib", "BEPIPcu", "BEPEb", "BELIcu", "BEPIAu", "BEPUIcu", "BEMPIus", "BEPIEu", "BELIui", "BEPIEui", "BEPIEcu", "BEPIntelus", "BEPIEuid", "BepIIu", "BepIcu", "BEPIIou", "BELIb", "BEMPIuid", "BepIIou", "BEPIAus", "BEPIEb", "BepIIcu", "BEPIPus", "BELEu", "BELEb", "BEMPInteluf", "BepIu", "BELIu", "BepIIus", "BEPIuid", "BEPInteluf", "BEPIPu", "BEPIou", "BEPiu", "BELEui", "BELEcu", "BEPIIus", "BEPInteluid", "BEPUIus", "BEPUIou", "BEPIPou", "BEMPIntelu", "BEPIEuf", "BEPIIcu", "BEPIEus", "BEPIb", "BEPIui", "BEPIIu", "BEMPIuf", "BEMPInteluid", "BEPIAuid", "BEPEcu", "BepIus", "BEMPIu", "BEPIus", "BEPIuf"], "bl": ["bm", "Bl", "lp", "loc", "l", "bridge", "obl", "lig", "sb", "bn", "ll", "ml", "bp", "li", "abl", "lu", "bs", "cl", "fr", " BL", "il", "mn", "bg", "bd", "bc", "ln", "ptr", "jl", "ibl", "nl", "BR", "ble", "kl", "bf", "BL", "bi", "pl", "ba", "len", "sl", "b", "br", "lb"], "i": ["tim", "ic", "index", "ij", "z", "si", "l", "t", "ci", "im", "hi", "p", "ei", "ki", "qi", "me", "ir", "li", "is", "\u0438", "ri", "e", "point", "I", " ii", "u", "ai", "v", "di", "ip", "mi", "pi", "c", "ind", " j", "in", "j", "xi", "id", "r", "ti", "ui", "batch", "gi", "n", "ji", "multi", "fi", "bi", "iu", "x", "zi", "ini", "sim", " bi", "gu", "f", "status", "it", "ix", "b", "y", "ii", "m"]}}
{"project": "qemu", "commit_id": "2ff30257974e19ebe2a97baad32ac29c06da5fb9", "target": 0, "func": "static void *migration_thread(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    /* Used by the bandwidth calcs, updated later */\n\n    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    int64_t initial_bytes = 0;\n\n    int64_t max_size = 0;\n\n    int64_t start_time = initial_time;\n\n    int64_t end_time;\n\n    bool old_vm_running = false;\n\n    bool entered_postcopy = false;\n\n    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */\n\n    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;\n\n\n\n    rcu_register_thread();\n\n\n\n    qemu_savevm_state_header(s->to_dst_file);\n\n\n\n    if (migrate_postcopy_ram()) {\n\n        /* Now tell the dest that it should open its end so it can reply */\n\n        qemu_savevm_send_open_return_path(s->to_dst_file);\n\n\n\n        /* And do a ping that will make stuff easier to debug */\n\n        qemu_savevm_send_ping(s->to_dst_file, 1);\n\n\n\n        /*\n\n         * Tell the destination that we *might* want to do postcopy later;\n\n         * if the other end can't do postcopy it should fail now, nice and\n\n         * early.\n\n         */\n\n        qemu_savevm_send_postcopy_advise(s->to_dst_file);\n\n    }\n\n\n\n    qemu_savevm_state_begin(s->to_dst_file, &s->params);\n\n\n\n    s->setup_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) - setup_start;\n\n    current_active_state = MIGRATION_STATUS_ACTIVE;\n\n    migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n\n\n    trace_migration_thread_setup_complete();\n\n\n\n    while (s->state == MIGRATION_STATUS_ACTIVE ||\n\n           s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {\n\n        int64_t current_time;\n\n        uint64_t pending_size;\n\n\n\n        if (!qemu_file_rate_limit(s->to_dst_file)) {\n\n            uint64_t pend_post, pend_nonpost;\n\n\n\n            qemu_savevm_state_pending(s->to_dst_file, max_size, &pend_nonpost,\n\n                                      &pend_post);\n\n            pending_size = pend_nonpost + pend_post;\n\n            trace_migrate_pending(pending_size, max_size,\n\n                                  pend_post, pend_nonpost);\n\n            if (pending_size && pending_size >= max_size) {\n\n                /* Still a significant amount to transfer */\n\n\n\n                if (migrate_postcopy_ram() &&\n\n                    s->state != MIGRATION_STATUS_POSTCOPY_ACTIVE &&\n\n                    pend_nonpost <= max_size &&\n\n                    atomic_read(&s->start_postcopy)) {\n\n\n\n                    if (!postcopy_start(s, &old_vm_running)) {\n\n                        current_active_state = MIGRATION_STATUS_POSTCOPY_ACTIVE;\n\n                        entered_postcopy = true;\n\n                    }\n\n\n\n                    continue;\n\n                }\n\n                /* Just another iteration step */\n\n                qemu_savevm_state_iterate(s->to_dst_file, entered_postcopy);\n\n            } else {\n\n                trace_migration_thread_low_pending(pending_size);\n\n                migration_completion(s, current_active_state,\n\n                                     &old_vm_running, &start_time);\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (qemu_file_get_error(s->to_dst_file)) {\n\n            migrate_set_state(&s->state, current_active_state,\n\n                              MIGRATION_STATUS_FAILED);\n\n            trace_migration_thread_file_err();\n\n            break;\n\n        }\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n        if (current_time >= initial_time + BUFFER_DELAY) {\n\n            uint64_t transferred_bytes = qemu_ftell(s->to_dst_file) -\n\n                                         initial_bytes;\n\n            uint64_t time_spent = current_time - initial_time;\n\n            double bandwidth = (double)transferred_bytes / time_spent;\n\n            max_size = bandwidth * migrate_max_downtime() / 1000000;\n\n\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                    ((double) time_spent / 1000.0)) / 1000.0 / 1000.0;\n\n\n\n            trace_migrate_transferred(transferred_bytes, time_spent,\n\n                                      bandwidth, max_size);\n\n            /* if we haven't sent anything, we don't want to recalculate\n\n               10000 is a small enough number for our purposes */\n\n            if (s->dirty_bytes_rate && transferred_bytes > 10000) {\n\n                s->expected_downtime = s->dirty_bytes_rate / bandwidth;\n\n            }\n\n\n\n            qemu_file_reset_rate_limit(s->to_dst_file);\n\n            initial_time = current_time;\n\n            initial_bytes = qemu_ftell(s->to_dst_file);\n\n        }\n\n        if (qemu_file_rate_limit(s->to_dst_file)) {\n\n            /* usleep expects microseconds */\n\n            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);\n\n        }\n\n    }\n\n\n\n    trace_migration_thread_after_loop();\n\n    /* If we enabled cpu throttling for auto-converge, turn it off. */\n\n    cpu_throttle_stop();\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_cleanup();\n\n    if (s->state == MIGRATION_STATUS_COMPLETED) {\n\n        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);\n\n        s->total_time = end_time - s->total_time;\n\n        if (!entered_postcopy) {\n\n            s->downtime = end_time - start_time;\n\n        }\n\n        if (s->total_time) {\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                       ((double) s->total_time)) / 1000;\n\n        }\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    } else {\n\n        if (old_vm_running && !entered_postcopy) {\n\n            vm_start();\n\n        } else {\n\n            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {\n\n                runstate_set(RUN_STATE_POSTMIGRATE);\n\n            }\n\n        }\n\n    }\n\n    qemu_bh_schedule(s->cleanup_bh);\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 19574, "substitutes": {"opaque": ["Opiera", "Oposit", "Opaque", "iopacity", "oque", " opque", "opiera", "catacity", "OPque", "cataque", "oaque", "oposit", "catosit", "OPesc", " opiera", "Opacity", "opesc", "oesc", "iopiera", "iopaque", "catiera", " opesc", "opacity", "opque", "oiera", "OPaque", "OPiera", "ioposit"], "s": ["details", "ess", "rs", "vs", "sys", "es", "comm", "fs", "spec", "sis", "sl", "serv", "os", "t", "csv", "sm", "set", "qs", "S", "ss", "d", "sts", "v", "ps", "service", "ts", "ls", "stats", "ies", "ds", "sam", "times", "l", "w", "sb", "as", "ses", "changes", "als", "south", "sv", "sw", "still", "js", "j", "gets", "ssl", "an", "b", "has", "y", "m", "hs", "args", "i", "p", "ins", "store", "sq", "aws", "h", "is", "bs", "gs", "ports", "ns", "ties", "sports", "cmd", "ats", "less", "ims", "sql", "conf", "its"], "end_time": ["endmodstart", "stop_start", "endmodruntime", "endablestart", "endmodtimeout", "stop_time", "stop_timeout", "stop_runtime", "end_start", "end_runtime", "endableruntime", "endabletime", "end_timeout", "endmodtime", "endabletimeout"], "current_time": ["current_size", "initial_size", "currentTimetime", "currentTimesize", "currentutionprice", "current_price", "initial_table", "currentutionsize", "currentTimeprice", "initial_price", "currentutiontable", "currentTimetable", "initial_time", "current_table", "currentutiontime"], "pending_size": ["pended_size", "pending_SIZE", "pending_Size", "pended_Size", "pended_SIZE"], "pend_post": ["append_pre", "pend2new", "pend2pre", "pend2posts", "pend2post", "pend___post", "append_new", "pend_new", "pend___pre", "append_post", "append_posts", "pend___posts", "pend_pre", "pend_posts", "pend___new"], "pend_nonpost": ["pend_notPOST", "pend_nopost", "pend_nonpre", "pend_nopre", "pend_noPOST", "pend_npost", "pend_nposts", "pend_nonPOST", "pend_notpost", "pend_npre", "pend_nPOST", "pend_nonposts", "pend_notposts", "pend_noposts", "pend_notpre"]}}
{"project": "qemu", "commit_id": "b6954712abea03afd686b724060f9873e2c61f2b", "target": 0, "func": "void replay_input_event(QemuConsole *src, InputEvent *evt)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        /* Nothing */\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_add_input_event(qapi_clone_InputEvent(evt));\n\n    } else {\n\n        qemu_input_event_send_impl(src, evt);\n\n    }\n\n}\n", "idx": 19576, "substitutes": {"src": ["loc", "rol", "sel", "sh", "sb", "st", "sq", "th", "bh", "ctx", "rt", "bs", "cur", "rs", "tn", "sec", "hw", "obj", "pri", "iv", "sys", "sn", "via", "rel", "wn", "usr", "source", "pl", "sr", "screen", "gin", "rc", "vr", "sur", "ctr", "sc", "dest", "ser", "hl"], "evt": [" evle", "EVn", "ivert", " evl", " event", "iverr", " evv", "ekr", "Evl", "ekt", " evr", "ekent", "egv", "iverle", "ekn", "ivern", "egl", "Evn", "EVr", "Evr", "EVent", "evn", "evle", "EVt", "Evle", "evl", "egt", " evn", "evv", "egn", "Evv", "evr", "event", "Evt"]}}
{"project": "FFmpeg", "commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "target": 1, "func": "static inline unsigned int get_uint(ShortenContext *s, int k)\n\n{\n\n    if (s->version != 0)\n\n        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);\n\n    return get_ur_golomb_shorten(&s->gb, k);\n\n}\n", "idx": 19593, "substitutes": {"s": ["hs", "ds", "cs", "sam", "os", "ops", "sg", "sb", "p", "ess", "ses", "sq", "aws", "q", "sf", "qs", "bs", "sv", "rs", "gs", "sa", "S", "ss", "ns", "sts", "se", "ps", "sys", "sn", "js", "ast", "c", "ats", "comm", "fs", "less", "ts", "ims", "ls", "sac", "ms", "serv", "conf"], "k": ["km", "work", "ok", "z", "t", "sk", "ck", "kh", "uk", "max", "dk", "kj", "q", "ks", "ik", "kr", "ke", "g", "u", "ijk", "ku", "ka", "kan", "m", "kw", "kid", "ak", "kind", "kk", "c", "j", "ikk", "mk", "kl", "tk", "isk", "key", "unk", "K", "it", "ek"]}}
{"project": "FFmpeg", "commit_id": "136ce8baa4fc16cf38690cb457f7356c00e00a28", "target": 1, "func": "static void scale_coefs (\n\n    int32_t *dst,\n\n    const int32_t *src,\n\n    int dynrng,\n\n    int len)\n\n{\n\n    int i, shift, round;\n\n    int16_t mul;\n\n    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;\n\n\n\n    mul = (dynrng & 0x1f) + 0x20;\n\n    shift = 4 - ((dynrng << 23) >> 28);\n\n    if (shift > 0 ) {\n\n      round = 1 << (shift-1);\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp = temp + round;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          temp1 = temp1 + round;\n\n          dst[i] = temp >> shift;\n\n          temp3 = src[i+3] * mul;\n\n          temp2 = temp2 + round;\n\n\n\n          dst[i+1] = temp1 >> shift;\n\n          temp4 = src[i + 4] * mul;\n\n          temp3 = temp3 + round;\n\n          dst[i+2] = temp2 >> shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          temp4 = temp4 + round;\n\n          dst[i+3] = temp3 >> shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 >> shift;\n\n          temp5 = temp5 + round;\n\n          temp7 = src[i+7] * mul;\n\n          temp6 = temp6 + round;\n\n\n\n          dst[i+5] = temp5 >> shift;\n\n          temp7 = temp7 + round;\n\n          dst[i+6] = temp6 >> shift;\n\n          dst[i+7] = temp7 >> shift;\n\n\n\n      }\n\n    } else {\n\n      shift = -shift;\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          dst[i] = temp << shift;\n\n          temp3 = src[i+3] * mul;\n\n\n\n          dst[i+1] = temp1 << shift;\n\n          temp4 = src[i + 4] * mul;\n\n          dst[i+2] = temp2 << shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          dst[i+3] = temp3 << shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 << shift;\n\n          temp7 = src[i+7] * mul;\n\n\n\n          dst[i+5] = temp5 << shift;\n\n          dst[i+6] = temp6 << shift;\n\n          dst[i+7] = temp7 << shift;\n\n\n\n      }\n\n    }\n\n}\n", "idx": 19595, "substitutes": {"dst": ["mdcheck", "dscr", "dsts", "drstop", "sdst", "ddbr", "ldstore", "darwp", "edst", "dsl", "dellt", "dlsl", "ddsn", "mdwp", "darcheck", "Dst", "dsset", "dast", "drend", "dset", "bdst", "ldld", "dsn", " ddest", "deldest", "drbr", "sdest", "edsl", "ddsl", "ddnd", "ddest", "mdsn", "lddest", "dtst", "dsstore", "dlt", "darest", "ssts", "bdput", "ddst", "dlst", "dstop", "bdcr", "sdset", "sddest", "sput", "ldrest", "delstore", "dtld", "dadest", "Dest", "mdst", "dost", "sst", "sdstore", " dcheck", "dbr", "ddend", "bdstore", "dastop", " dest", "Dbsp", "dalt", " dset", "drost", "bdset", "dlnd", " dstore", "ldst", "bdlt", "dbsp", "mdend", "sdcr", "bddest", "edbsp", "dwp", "drbsp", " dbr", "dtrest", "dnd", "delstop", "sdstop", "ddstop", "ldest", "ednd", "dput", "dstore", "dld", "dtstore", "dtest", "Dset", "dlbsp", " dbsp", " dwp", "dcr", " drest", "mdest", "ddbsp", "drset", "mdstop", " dost", " dld", " dput", "bdstop", "delst", "dcheck", "ddost", "dsst", " dsts", "drsn", "drst", "dend", "drest", "darst", "dtdest", "bdsts", "dest"], "src": ["loc", "ser", "img", "lib", "st", "rt", "resource", "rs", "conv", "ipl", "iv", "sys", "req", "sync", "ji", "aux", "sr", "s", "spec", "sl", "serv", "hl", "np", "sort", "sel", "desc", "sp", "input", "bh", "syn", "cur", "sec", "stab", "sn", "via", "pkg", "usr", "ctr", "sc", "inc", "rob", "sb", "sub", "proc", "ipp", "impl", "bc", "cc", "sw", "str", "rg", "rb", "source", "txt", "info", "ssl", "rc", "scan", "irc", "b", "ins", "secure", "sq", "bs", "rec", "supp", "in", "func", "rel", "inst", "r", "sur", "stock", "comp", "rpm", "dest", "seq", "rl"], "dynrng": ["dynrrng", "dynnrNG", "dyncRmb", "dyncrNG", "dynrnd", "dynprmb", "dyncramp", "dynclmd", "dynprnd", "dynpramp", "dyncrgn", "dynprng", "dynprgn", "dynlmd", "dynRgn", "dyncsprgn", "dynsprng", "dynRng", "dyncrmb", "dynlanger", "dyncsprnd", "dynsprnd", "dynrNG", "dyncrmd", "dyncranger", "dynrmd", "dynRmb", "dynnrng", "dyncRnd", "dynclng", "dynrrNG", "dynrrmd", "dynnranger", "dynspramp", "dynRamp", "dynsprmb", "dyncRng", "dynnrmd", "dynclanger", "dynclNG", "dynRnd", "dyncrnd", "dyncsprng", "dyncRamp", "dynrranger", "dynsprgn", "dyncrng", "dynrgn", "dynramp", "dynlNG", "dynrmb", "dynlng", "dynranger"], "len": [" length", "mem", "pos", "fl", "ul", "fn", "l", "el", "size", "t", "lon", "vl", "isl", "lib", "num", "en", "lf", "ll", "list", "h", "li", "le", "cl", "lock", "dl", " l", "il", "length", "fin", "ln", "Length", "nl", "lit", "L", "kl", "lc", "n", "lan", "del", "lim", "f", "lis", "Len", "b", "elt", "m"], "i": ["hi", "ir", "li", "base", "ri", "e", "g", "I", "ai", "ori", "di", "mi", "ji", " iter", "s", "chain", "multi", "ii", "index", "ij", "item", "or", "ci", "ish", "list", "q", "on", "ret", "\u0438", "phi", "v", "cli", "io", "pi", "try", "gi", "o", "n", "fi", "bi", "x", "zi", "ini", "rest", "f", "it", "ia", "iu", "status", "err", "init", "ic", "l", "res", "depth", "ei", "qi", " ti", "me", "ik", " ii", " index", "name", "iq", " mi", "ip", " li", "iii", "to", " j", "iri", "j", "ti", " is", " ki", " I", "ami", "uri", "info", " si", " di", " bi", "ix", "y", "m", "si", "im", "at", " pi", "is", "oi", "ind", "id", "in", "xi", "r", "batch", "ui", "key", "iy", "sim"], "shift": ["error", "size", "weight", "pad", "sup", "hash", "move", "scale", "shr", "length", "step", "track", "resh", "ssh", "diff", "hift", "shake", "mix", "offset", "frame", "index", "sort", "dist", "sh", "shock", "q", "set", "hold", "distance", "shape", "command", "handle", "start", "mask", "tip", "reset", "skip", "trade", "pack", "align", "hello", "reverse", "it", "transfer", "show", "version", "mode", "init", "snap", "ul", "style", "seed", "depth", "sub", "tick", "delay", "tr", "send", "address", "iq", "clock", "ptr", "time", "order", "j", "raw", "transform", "Shift", "focus", "pull", "ix", "sample", "hide", "m", "effect", "power", "change", "split", "off", "sign", "sleep", "push", "ind", "message", "share", "filter", "seq", "dq"], "round": ["format", " Round", "sound", "scale", "deep", "inter", "mi", "field", "cond", "diff", "pre", "shell", "build", "quick", "offset", "form", "sort", "server", "gro", "hard", "play", "set", "level", "hold", "lock", "town", "force", "call", "reset", "re", "drop", "trade", "align", "rounded", "null", "turn", "open", "reverse", "bind", "ound", "sc", "min", "snap", "box", "close", "rect", "mod", "group", "bc", "method", "reg", "clean", "j", "print", "block", "row", "col", "m", "apply", "secure", "ort", "cell", "bot", "around", "sign", "Round", "roll", "rot", "ref", "r", "connect", "reflect", "adjust", "full", "rule", "ff"], "mul": ["modol", "manul", "mutula", "mulator", "rul", "manull", "immolar", "minull", "dil", "mmular", "mulse", "pil", "mular", "emual", "moduleur", "Muler", "copy", "molar", "get", "tUL", "modul", "mmul", "mUL", "c", "remula", "mule", "duler", "mual", "emular", "mtual", "mmolar", "Mul", "emulse", "permular", "immula", "mol", "smil", "immul", "pula", " cmuli", "remulative", "muler", "moduleul", "pul", " mule", "mtuli", "magur", "mmula", "set", "emull", "mur", "mutulse", "_", "ril", "dular", "smular", "dul", "tular", "magoul", "rula", "call", "Muli", " mula", "immil", "tuler", "mutular", " mull", "mip", "smol", "magul", "smuler", "remul", "mutuler", " mular", "rulator", "mmol", "mtUL", "mutip", " cmUL", "permules", "minulative", "moduleoul", "minular", "MUL", "smulative", "smul", "Mule", "mull", " mulative", "mulative", "roul", "mtil", "load", "mutual", "emula", "emul", " cmule", " moul", "Moul", "mtolar", " muli", "permip", "mula", "modil", "remull", "emules", "mutur", "muli", "moul", "ruler", "Mular", "emip", "tul", "mtul", "mil", "mules", " cmul", "manulative", "mutulator", "mutil", "poul", "mutules", "rUL", "mtular", "moduleolar", "cont", " mUL", "permul", "mtulator", "smull", "mtulse", "mtoul", "new", "mmil", "modular", "mutoul", "emulative", "manular", "mtula", "rular", "minul", "mutolar", "magolar", "mutul"], "temp": ["Temperature", "format", "texture", "test", "base", "point", "copy", "variable", "iter", "mp", "mi", "perature", "cache", "pre", "buffer", "emp", "mem", "strength", "tim", "memory", "t", "ta", "input", "timeout", "result", " Temp", "port", "set", "level", "output", "dat", "tmp", "fac", "v", "pi", "json", "pt", "adjusted", "cu", "null", "status", "min", "tc", "total", "mm", "mod", "prefix", "tr", "all", "method", "capacity", "ptr", "ip", "time", "master", " temperature", "alt", "able", "txt", "fake", "mint", "ate", "deg", "p", "at", "abl", "power", "util", "tem", "timer", "empty", "Temp", "position", "unit", "pressure", "typ", "current", "unt", "sequence", "ac", "full"], "temp1": ["Temp5", "stem0", "stem3", "tmp1", "emp1", "tim11", "temA", "temp01", "timOne", "temB", "tem0", "tempOne", "tem9", " temp9", "tmpA", "tmp3", "stem1", "tmp01", "Temp1", "timA", "tempB", "temOne", "tem3", "tem11", "emp11", "Temp01", "tim0", "tim5", "tim4", "termOne", "temp11", "emp01", "stem4", "tempone", "stem01", "tempA", "tem4", "template01", "tmpB", "term5", "templateTo", "tim1", "temp0", "temp9", "stem9", "template11", " tempB", "term1", "tmp4", "template1", " temp01", "timone", "tmpTo", "tim01", "tmpOne", "tim3", " tempone", "empTo", "stemone", "tmp11", "tem1", "term01", "TempOne", "tempTo"], "temp2": ["stem3", "template3", "temGe", "bufferTwo", "bufferL", "base4", "buffer4", "tem3", "buffer5", "buffer2", "buffer3", "tempTwo", "stemL", "tem5", "tem2", "tempDouble", "tempL", "stem4", "tem4", "base5", "temTwo", "templateL", "level2", "level3", "temDouble", "base3", "tempGe", "levelDouble", " tempGe", "tmp4", "tmp5", "stemTwo", "stem2", " tempDouble", "level4", "base2", "tmpGe", "tmp2", "template2"], "temp3": ["template6", "stem3", "template3", "stem43", "stem5", "tmp21", "temThree", "emp003", "mod3", "temDecl", "stemthree", "tmp3", "stem003", "tem3", "cache03", "mod5", "tmp003", "temp03", "stemDecl", "tmpDecl", "tempthree", "cachethree", "stemThree", "tempDecl", "currentThree", "tem5", "stem4", "tem43", "status6", "tem4", "current6", "status3", "tmpthree", "mod43", "mod6", "emp3", "statusThree", "tem03", "tmp03", "cacheThree", "temp43", "tmp4", "tempThree", "tem6", "temp003", "stem03", "stem21", "current3", "current5", "temp21", "emp21", "stem6", "cache3", "cache4", "emp03", "status5", "templateThree", "template5", "tmpThree"], "temp4": ["stem3", "permFour", "emp6", "stem44", "tempBy", "stem5", "temFour", "satBy", "stem04", "temp04", "tmp44", "tem44", "stemFour", "emp422", "emp45", "sequence4", "temp422", "tem3", "permfour", "sequenceLine", "tmp45", "sequence6", "temp42", "cache04", "temp44", "tem5", "tempFour", "tem2", "stem4", "emp4", "tmp42", "sequence2", "tmpBy", "temfour", "tem4", "sequenceBy", "tmpFour", " temp422", "sat4", " temp44", "empFour", "stem42", "tempfour", "empfour", "satLine", "perm4", "tmp422", "temp45", "sat6", "cache44", " temp45", "tmp4", "tem04", "tem6", "tempLine", "tmp6", "sequence3", "cacheFour", "emp44", "sequence5", "stem6", "stem2", "perm6", "cache4", "emp42", "tmpLine"], "temp5": ["template6", "template3", "tmp50", "emp6", "temp50", "tim6", "emp2", "time6", "tem3", "tim512", "tim5", "tem5", "tem50", "tem2", "emp4", "status6", "tem4", "emp50", "status3", "emp512", "temLet", "emp3", "empLet", "level5", "tmp512", "levelLet", "emp5", "tempLet", "tem6", "status2", "tmp6", "temp512", "tmp5", "time5", "time3", "time4", "level6", "level4", "tmp2", "status5", "template2", "template5"], "temp6": ["tmp7", "template6", "cacheSix", "tem7", "emp6", "Temp4", "stem5", "tim6", "tem06", "temp68", "stem68", "stem7", "tem9", "test7", "tempSix", " temp06", "tim8", "tim4", "tem5", "tmpSix", "stem4", "emp4", "timSix", "test6", "tem4", "TempSix", "temSix", "test68", "result68", "Temp6", "emp68", "temp8", "level5", "cache6", "temp9", "stem9", " tempSix", "Temp8", "result6", "tem6", "tmp6", "level9", "stemSix", "template4", "templateSix", "template8", "empSix", "stem6", "temp06", "result7", "tmp68", "level6", "cache4", "level7", "cache06", "testSix", "resultSix", " temp68"], "temp7": ["tmp7", "test87", "tem7", "timSeven", "tmpseven", "prime4", "tmp07", "tim6", "tempSeven", "ptr87", "stem07", "stem7", "ptr4", "status7", "test7", "tim07", "stem1", "ptr7", "cacheseven", "cacheSeven", "stem4", "tim87", "status6", "tem4", "cacheJul", "cache7", "status07", "timJul", "tim7", "temp87", "tim1", "prime7", "ptrseven", "prime87", "testJul", "tem87", "stemseven", "temp07", "tmp4", "statusseven", "tem6", "tmp6", "cache07", "cache87", "primeseven", "stem6", "status87", "tmp87", "tempJul", "tempseven", "tem07", "tem1", "temseven", "status4", "testSeven"]}}
{"project": "qemu", "commit_id": "db3b3c7281ca82e2647e072a1f97db111313dd73", "target": 1, "func": "static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)\n{\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n    const char *path = qemu_opt_get(opts, \"path\");\n    if (sec_model) {\n        error_report(\"Invalid argument security_model specified with handle fsdriver\");\n        return -1;\n    }\n    if (!path) {\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n    fse->path = g_strdup(path);\n    return 0;\n}", "idx": 19612, "substitutes": {"opts": ["promt", "iopms", "optjs", "opjs", "ops", "iopps", "OPts", " opps", "OPps", "pros", " opmt", "OPms", "OPls", "optts", "opls", "prots", " opls", "opms", "optls", " opjs", "opps", "props", "OPmt", "optms", "OPs", " ops", "opmt", "iopts", "iops", "optps", "OPjs"], "fse": ["vte", "Fsem", "fae", "fser", " fser", "fcsem", " fte", "fcae", "vge", "fte", " fsem", "fsem", "fcser", "Fge", "Fae", " fae", "vse", "Fse", "Fte", "vae", "Fser", "fge", "fcse", " fge"], "errp": [" errpp", "Erp", "errr", "errpp", "errP", "erP", " errr", "erpp", "erp", "Err", "Erpp", " errP", "ErP", "err"], "sec_model": ["sec_mode", "sec_models", " sec_models", " sec_Model", " sec_mode", "sec_Model"], "path": ["near", "form", "location", "format", "filename", "component", "p", "desc", "where", "th", "PATH", "test", "port", "stream", "user", "with", "output", "point", "prefix", "prop", "length", "stat", "name", "out", "method", "partial", "serial", "route", "value", "data", "pkg", "target", "pt", "dir", "id", "ath", "ref", "template", "host", "root", "context", "raw", "transform", "str", "key", "alias", "source", "pred", "anc", "entry", "pattern", "chain", "url", "full", "arc", "spec", "text", "status", "file", "Path", "type"]}}
{"project": "qemu", "commit_id": "302d9d6fd8cb34e393cc9bb101a1748bd53899d3", "target": 1, "func": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n", "idx": 19633, "substitutes": {"vs": ["bits", "details", "ks", "words", "vals", "caps", "rs", "vp", "pages", "inv", "rys", "fs", "s", "params", "names", "heads", "ows", "ii", "ops", "otes", "ups", "qs", "vc", "ss", "uds", "sts", "v", "xs", "obs", "ts", "Vs", "ls", "parts", "ads", "vr", "wcs", "ues", "services", "ds", "cs", "ov", "times", "terms", "ils", "changes", "lines", "bp", "sv", "blogs", "docs", "ables", "js", "vers", "VS", "links", "vd", "hs", "atts", "history", "lbs", "ists", "outs", "args", "ins", "vt", "bs", "gs", "values", "lists", "ports", "ns", "eps", "views", "ires", "ims", "vv", "ms", "its"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int integratorcm_init(SysBusDevice *dev)\n\n{\n\n    IntegratorCMState *s = INTEGRATOR_CM(dev);\n\n\n\n    s->cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (s->memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (s->memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (s->memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (s->memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,\n\n                                   1000);\n\n    memory_region_init_ram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->flash);\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,\n\n                          \"integratorcm\", 0x00800000);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    integratorcm_do_remap(s);\n\n    /* ??? Save/restore.  */\n\n    return 0;\n\n}\n", "idx": 19643, "substitutes": {"dev": ["ds", "adv", "os", "nt", "w", "de", "phy", "pad", "p", "Dev", "dis", "ctx", "device", "DEV", "buf", "cam", "usb", "disk", "des", "ad", "ch", "d", "db", "v", "serial", "hw", "ve", "sys", "conn", "sd", "spec", "pi", "DE", "dm", "ev", "def", "o", "Device", "ver", "devices", "scan", "dem", "serv", "dd", "gate"], "s": ["bits", "details", "e", "g", "rs", "tags", "vs", "se", "self", "sys", "c", "es", "comm", "sync", "fs", "er", "params", "spec", "sl", "serv", "os", "t", "settings", "sm", "set", "qs", "S", "ss", "d", "sts", "v", "ps", "erences", "ids", "n", "o", "ts", "ls", "parts", "stats", "f", "bis", "services", "ies", "a", "ds", "cs", "sam", "l", "w", "terms", "sb", "as", "ses", "changes", "als", "sv", "des", "sw", "js", "j", "gets", "tests", "states", "b", "y", "m", "hs", "uploads", "args", "i", "p", "ins", "ers", "sq", "aws", "h", "is", "bs", "gs", "ports", "ns", "sports", "sd", "cmd", "tes", "ats", "r", "eps", "less", "ears", "ims", "ms", "conf", "its"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 19650, "substitutes": {"obj": ["ij", "np", "nt", "arr", "opt", "ck", "pr", "oc", "bb", "bh", "og", "xy", "rect", "bo", "ob", "impl", "tmp", "onet", "ot", "bj", "object", "js", "cmd", "nu", "pkg", "j", "oj", "inst", "ev", "obo", "Obj", "kl", "tk", "obs", "o", "act", "cod", "txt", "ack", "resp", "buff", "po", "elt"]}}
{"project": "FFmpeg", "commit_id": "8f4020d8a4b2e6264f54accbcb881577316c3ca6", "target": 0, "func": "static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)\n\n{\n\n    int frame_size_code;\n\n\n\n    skip_bits(bitbuf, 8); /* temporal_reference */\n\n\n\n    /* frame type */\n\n    s->pict_type = get_bits(bitbuf, 2) + 1;\n\n    if (s->pict_type == 4)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        /* unknown fields */\n\n        if (s->f_code == 0x50 || s->f_code == 0x60) {\n\n            int csum = get_bits(bitbuf, 16);\n\n\n\n            csum = ff_svq1_packet_checksum(bitbuf->buffer,\n\n                                           bitbuf->size_in_bits >> 3,\n\n                                           csum);\n\n\n\n            av_dlog(s->avctx, \"%s checksum (%02x) for packet data\\n\",\n\n                    (csum == 0) ? \"correct\" : \"incorrect\", csum);\n\n        }\n\n\n\n        if ((s->f_code ^ 0x10) >= 0x50) {\n\n            uint8_t msg[256];\n\n\n\n            svq1_parse_string(bitbuf, msg);\n\n\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"embedded message: \\\"%s\\\"\\n\", (char *)msg);\n\n        }\n\n\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits1(bitbuf);\n\n\n\n        /* load frame size */\n\n        frame_size_code = get_bits(bitbuf, 3);\n\n\n\n        if (frame_size_code == 7) {\n\n            /* load width, height (12 bits each) */\n\n            s->width  = get_bits(bitbuf, 12);\n\n            s->height = get_bits(bitbuf, 12);\n\n\n\n            if (!s->width || !s->height)\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            /* get width, height from table */\n\n            s->width  = ff_svq1_frame_size_table[frame_size_code].width;\n\n            s->height = ff_svq1_frame_size_table[frame_size_code].height;\n\n        }\n\n    }\n\n\n\n    /* unknown fields */\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);    /* use packet checksum if (1) */\n\n        skip_bits1(bitbuf);    /* component checksums after image data if (1) */\n\n\n\n        if (get_bits(bitbuf, 2) != 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 4);\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 2);\n\n\n\n        while (get_bits1(bitbuf) == 1)\n\n            skip_bits(bitbuf, 8);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19654, "substitutes": {"bitbuf": ["jobbuf", "batchdb", "bitbuffer", "bytebag", "gitnext", "bootdb", "bytequeue", "basebuff", "bandbuff", "lockfac", "basebuf", "bitbatch", "bitsbuffer", "bytecap", "bootbr", "bitbr", "taskcmd", "lockbuff", "bootbatch", " bitbatch", "bitsbag", "formbr", "BITdesc", "bitdesc", " bitbox", " bitbn", "lockbuffer", "lockbuf", "baseuf", "catbag", "lockbag", "backcmd", "BITbuffer", "jobuf", " bitbuff", "bandbuffer", " bitcmd", "bitvec", "backuf", "bytebr", "shotbuf", " bitcap", "bytebuff", "bitbox", "lockuf", "itbuf", "bugcmd", "bitsbox", "worduf", "byteuf", "jobbuff", "gitbuff", "backbuf", "taskbag", "bitdb", "bootbuffer", "bituf", "BITbuf", "Bitbuff", "bitsbuff", " bituf", " bitvec", "batchbuff", "bitfac", "bandbuf", "taskcat", "boardbuff", "bytebatch", "batchuf", "bitscap", "Bitbuffer", "bitcap", "formbuf", "bitsfac", "bitbag", "BITobj", " bitobj", "bootuf", " bitqueue", "bugbuff", "bitsbuf", "basevec", "bytedesc", "bootbuf", "blockbuf", "wordbag", "bytebuffer", "backbuffer", "itbuff", "bandbn", "byteobj", "bitsqueue", "bitbuff", " bitbuffer", "blockbag", "itbuffer", "jobbag", "batchbuf", "bitbn", "bitobj", "bugbuf", "catcat", "gitbuf", "boardbn", "blockbuffer", "bitscat", "boardbuffer", "bitcat", "bitscmd", "itqueue", "bitnext", "wordbuf", "bootbuff", "bugbox", " bitdesc", "catcmd", "bugdb", "bitqueue", "shotbatch", "formbatch", "Bitbuf", "blockuf", "locknext", "bitsvec", "formbuffer", "wordbuff", "bitsuf", "catbuf", "bitsnext", "shotbox", "bytebox", "buguf", "bugbuffer", "boardbuf", "bytecmd", "gitfac", "bytebuf", "bitcmd", "taskbuf"], "s": ["sg", "details", "st", "results", "rs", "conv", "vs", "se", "sys", "ants", "c", "es", "comm", "fs", "er", "ex", "spec", "os", "ops", "set", "qs", "S", "ss", "d", "sts", "ps", "service", "n", "ts", "ls", "ains", "aunts", "stats", "bis", "ies", "ds", "cs", "l", "w", "sb", "as", "ses", "changes", "als", "sv", "des", "sw", "js", "j", "b", "has", "y", "rates", "m", "hs", "uploads", "p", "ins", "store", "aws", "h", "is", "bs", "gs", "ports", "ns", "sports", "pers", "ats", "eps", "less", "ims", "ms", "conf", "its"], "frame_size_code": ["frame_size_type", "frame_size_result", "frame_size_create", "frame_size32rate", "frame_size_table", "frame_size5result", "frame_name_type", "frame_size_count", "frame_width_create", "frame_size5table", "frame_width_table", "frame_sizeityCode", "frame_size12code", "frame_size32create", "frame_size32table", "frame_sizeityresult", "frame_width32code", "frame_width32table", "frame_size_rate", "frame_size_Code", "frame_size32code", "frame_width_code", "frame_name_code", "frame_size12coe", "frame_name_Code", "frame_width32rate", "frame_size_cycle", "frame_size_coe", "frame_size12cycle", "frame_sizeitycode", "frame_size5Code", "frame_width32create", "frame_size_key", "frame_width_rate", "frame_name_count", "frame_size5code", "frame_sizeitytable", "frame_size12Code"], "msg": ["mem", "error", "res", "arr", "args", "sg", "sent", "desc", "var", "goo", "result", "mail", "og", "gz", "buf", "g", "arg", "empty", "gs", "Message", "tmp", "tree", "reason", "mt", "out", "mat", "mo", "bug", "news", "obj", "doc", "Msg", "data", "cmd", "pkg", "ext", "body", "new", "message", "str", "mess", "txt", "vol", "gm", "ms", "title", "text", "event", "err", "m"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void prepare_grab(void)\n\n{\n\n    fprintf(stderr, \"Must supply at least one input file\\n\");\n\n    exit(1);\n\n}\n", "idx": 19665, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_codec_desc(const void *a, const void *b)\n\n{\n\n    const AVCodecDescriptor * const *da = a;\n\n    const AVCodecDescriptor * const *db = b;\n\n\n\n    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n\n           strcmp((*da)->name, (*db)->name);\n\n}\n", "idx": 19667, "substitutes": {"a": ["ea", "au", "am", "or", "ga", "ach", "as", "at", "ae", "both", "e", "eas", "ata", "sa", "aa", "ad", "d", "area", "ade", "aaa", "ast", "ab", "ada", "c", "admin", "att", "ant", "act", "apa", "aj", "aux", "A", "oa", "ba", "an", "from", "ac", "ed"], "b": ["another", "bridge", "t", "bb", "abb", "bp", "facebook", "fb", "bs", "e", "g", "other", "bc", "d", "v", "B", "ab", "hub", "nb", "c", "to", "r", "n", "bound", "blue", "rb", "ib", "bi", "cb", "be", "by", "ba", "ed", "eb", "bis", "y", "br"], "da": ["ea", "ds", "ara", "lambda", "ga", "ta", "ra", "md", "dal", "ar", "va", "deb", "hd", "DA", "sa", "dl", "ata", "dat", "bd", "aa", "d", "ma", "di", "wa", "dr", "lda", "Da", "pd", "ena", "dar", "sha", "fa", "du", "anda", "oa", "la", "ld", "pa", "ba", "oda", "dra", "ao"], "db": ["ds", "dp", "bridge", "Db", "back", "lib", "sb", "bb", "dk", "og", "bur", "ub", "deb", "fb", "bs", "ob", "dl", "dat", "kb", "py", "bd", "bc", "ad", "d", "di", "pb", "ade", "bl", "sd", "nb", "gb", "dir", "try", "dev", "rel", "ud", "dc", "bf", "df", "rb", "bi", "ib", "gd", "cb", "eb", "sql", "DB", "vd", "dd"]}}
{"project": "qemu", "commit_id": "c3fecea50dc0f27198b8658a0c9c4fbfdd0f95db", "target": 1, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, int create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, NULL, s);\n\n    set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = do_write(s->fd, &hdr, sizeof(hdr));\n\n    if (ret) {\n\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -EIO;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = do_writev(s->fd, iov, wlen, aio_req->iov_offset);\n\n        if (ret) {\n\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -EIO;\n\n        }\n\n    }\n\n\n\n    set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, NULL, s);\n\n\n\n\n    return 0;\n\n}", "idx": 19684, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "l", "t", "w", "i", "p", "sb", "sp", "ses", "st", "store", "sq", "sub", "as", "h", "qs", "is", "bs", "e", "conf", "g", "sv", "rs", "gs", "S", "ss", "so", "sw", "ns", "v", "sts", "socket", "se", "self", "ps", "sys", "http", "js", "sd", "ex", "c", "j", "es", "r", "comm", "sync", "n", "fs", "less", "source", "ts", "ims", "ls", "ssl", "status", "stats", "f", "an", "spec", "sl", "b", "y", "serv", "m"], "aio_req": ["aio_request", "aioptcmd", "aioptreq", "aio___require", "aie_require", "aie_inv", "aie_md", "aio___req", "aoy_requ", "aio_desc", "aio_seq", "aie_requ", "aio_cmd", "aio2request", "aie_err", "aie_req", "aIO_query", "aive_requ", "aio_obj", "aio2req", "aio_query", "aIO_req", "aio___quest", "aio___err", "aio___requ", "aio___seq", "aio_md", "aio_expr", "aio_quest", "aio___request", "aive_cmd", "aio___res", "aio_res", "aio2requ", "aio_err", "aioptexpr", "aoy_seq", "aIO_requ", "aio_require", "aio2md", "aive_req", "aio_requ", "aie_request", "aIO_request", "aioptrequ", "aoy_req", "aoy_res", "aio___inv", "aio_inv", "aive_expr"], "iov": ["IO", "cv", "ival", "uart", "oo", "OV", "actor", "vec", "ovi", "conv", "iq", "ilo", "uv", "io", "ih", "iv", "ef", "rio", "isco", "ou", "nc", "ucc", "uf", "vr", "ux", "version", "river", "wo"], "niov": ["tiocr", "niuv", "nuuv", "diuv", "diOV", "tiOV", "nuocr", "nuov", "niocr", "diocr", "niOV", "tiuv", "nuOV", "diov", "tiov"], "create": ["check", "activate", "creator", "see", "use", "delete", "equal", "close", "make", "only", "set", "ure", "find", "creation", "created", "Create", "count", "clear", "load", "copy", "send", "raise", "force", "actory", "execute", "add", "insert", "drop", "ize", "update", "creat", "new", "draw", "enable", "destroy", "ce", "ulate", "open", "cre", "write", "build", "code", "define"], "aiocb_type": ["aiocB_name", "aiocbetycolor", "aiocb___types", "aiocb_name", "aiocb___time", "aiocbetytype", "aiocb_types", "aiocb_color", "aiocb___name", "aiocB_color", "aiocB_types", "aiocbetyType", "aiocb_Type", "aiocbetytypes", "aiocb_time", "aiocB_Type", "aiocb___type", "aiocB_type", "aiocB_time"], "hdr": ["hmtr", "Hgt", "ohr", "ghDR", " hDR", " hrr", "Hadr", "shdr", "hrnz", "phrr", "phdr", "thedr", " htr", "ohadr", "shDR", "hedr", "hhder", "ohint", "hmcmd", "Hr", " hder", "ohld", "heder", "hrDR", "ohDR", "hmsg", "hdro", "thegt", "hrr", "Hstr", "Hheader", "heDR", "hhDR", "Hint", "hadr", "hint", " hr", "hmusr", "ghgt", "ohnz", "hrstr", " hmsg", "hhmsg", "thfr", "hheader", "thstr", "husr", "htr", "ahder", "hfr", "theDR", " hstr", " hld", "ahtr", "ahDR", "hder", "Hder", "hhstr", "Hdr", "ohdr", "Htr", "heheader", "hr", " husr", "thedro", "thbr", "ahser", "hld", "thecmd", "thld", "ahadr", "hcmd", "ghdro", "HDR", "hgt", "thDR", "theusr", "Hbr", "hhnz", "hhdr", "Hmsg", "ghdr", "ohrr", "ohbr", "shser", "ohder", "ahdr", "hmdr", "hDR", "ohstr", "hstr", "ohfr", " hbr", "hser", "hrdr", "shder", "thheader", "Hser", "thdr", " hheader", " hfr", "thetr", " hcmd", "Hrr", "phbr", "ahheader", "hbr", "phDR", "Hdro", " hint", "hnz", "ohheader"], "wlen": ["worddl", "swlan", "swiller", " wlan", " wlength", "hen", "wordbl", "wln", "winlan", "wen", "winlen", "wlan", "hbl", "worden", "wxLen", "hlen", "rlength", "wxlen", "wbl", "willer", "rval", " wen", "wxval", "hdl", "whlan", " wbl", "wlength", "rLen", " welt", "winiller", " wln", "wordlen", " willer", " wval", "wval", "welt", "rlen", "wLen", "wdl", "whelt", " wdl", "wxlength", "whlen", "swln", "helt", "hlan", "whdl", " wLen", "winln", "swlen"], "ret": ["rm", "nt", "res", "t", "back", "flag", "result", "ll", "Ret", "rt", "count", "il", "tr", "mt", "out", "Return", "cont", "ft", " Ret", "success", "rem", "RET", "rev", "re", "any", "att", "rel", "r", "val", "et", "rets", "alt", "x", "len", "gt", "elt", "err"]}}
{"project": "qemu", "commit_id": "2b3de6ada5d180130ba083d5b45ed51ce8e4def2", "target": 1, "func": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);", "idx": 19685, "substitutes": {"p": ["lp", "np", "t", "wp", "w", "i", "pr", "ping", "pp", "h", "at", "pc", "e", "g", "op", "vp", "press", "tp", "d", "pro", "v", "pb", "k", "ip", "ps", "c", "pkg", "att", "r", "jp", "post", "n", "pat", "pre", "pa", "cp", "part", "P", "y", "ap", "m"], "q": ["quote", "ue", "z", "l", "t", "window", "w", "ck", "i", "qu", "pp", "qi", "sq", "query", "h", "ry", "qs", "conf", "g", "cl", "lock", "requ", "mt", "queue", "ct", "ch", "iq", "pg", "d", "v", "m", "k", "req", "pkg", "quant", "pt", "cmd", "j", "Q", "flow", "r", "comm", "aq", "gr", "y", "cache", "pl", "qa", "qt", "que", "f", "quit", "gm", "it", "qq", "dq"], "state": [" length", "init", "cs", " error", "style", " t", "l", "size", "t", "ta", "ist", "close", "State", "st", "list", "ose", "where", "test", "h", "port", "result", "STATE", "set", "power", "is", "change", "ne", " states", "lock", " l", " s", "length", "oto", " score", "stat", "ot", "name", "ch", "m", "out", " State", "start", "value", "come", "to", "id", "tag", "local", "print", "powered", "info", "no", "al", "s", "un", "it", "code", "spec", "states", "status", "trace", "type"]}}
{"project": "qemu", "commit_id": "36c6711bbe79642b0102416a9dd4243505e874a6", "target": 1, "func": "static void gen_ldst_pair (DisasContext *ctx, uint32_t opc, int rd,\n\n                           int base, int16_t offset)\n\n{\n\n    const char *opn = \"ldst_pair\";\n\n    TCGv t0, t1;\n\n\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK || rd == 31 || rd == base) {\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    t1 = tcg_temp_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n\n\n    switch (opc) {\n\n    case LWP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"lwp\";\n\n        break;\n\n    case SWP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sw(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sw(t1, t0, ctx);\n\n        opn = \"swp\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case LDP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"ldp\";\n\n        break;\n\n    case SDP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sd(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sd(t1, t0, ctx);\n\n        opn = \"sdp\";\n\n        break;\n\n#endif\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s, %s, %d(%s)\", opn, regnames[rd], offset, regnames[base]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 19709, "substitutes": {"ctx": ["loc", "ck", "tx", "rt", "setup", "kw", "conv", "cd", "obj", "sys", "req", "c", "jp", "context", "cm", "dc", "gp", "xc", "com", "cv", "np", "sp", "mc", "timeout", "bh", "gz", "tmp", "handle", "ct", "etc", "hw", "via", "xs", "pkg", "json", "scope", "parent", "kl", "fc", "cu", "qt", "resp", "wcs", "ctr", "sc", "ctl", "tc", "nt", "ca", "cn", "kt", "unc", "cl", "cf", "kb", "jac", "cc", "bc", "co", "cfg", "cmp", "act", "txt", "Context", "fx", "cp", "history", "grad", " cx", "pause", "tz", "xy", "bo", "gc", "cas", "config", "pg", "wx", "conn", "cmd", "func", "ref", "pool", "batch", "lc", "cb", "nc", "conf", "iat"], "opc": ["ioppc", "opct", "iopn", "copcs", "copc", " opcs", "OPn", " opcin", "roppc", "iopcs", "opcs", "copct", "iopct", "oppc", "ropc", "ropnc", " opct", "iopcin", "OPpc", "iopnc", "opnc", "iopc", "OPc", "copcin", "OPnc", "ropn", "opcin"], "rd": ["round", "index", "ds", "fd", "ord", "back", "ra", "ring", "aug", "rw", "th", "ry", "rx", "end", "ru", "hr", "rt", "ri", "RD", "fr", "rax", "rs", "rin", "rr", "rend", "mb", "d", "db", "ptr", "dr", "attr", "range", "ind", "r", "rid", "std", "rss", "rank", "ird", "du", "usr", "rb", "rg", "orth", "rown", "sr", "ld", "rn", "red", "nd", "rh", "rate", "rc", "rest", "rod", "dra", "src", "rf", "dd", "lr", "dq"], "base": ["bal", "work", "index", "server", "size", "back", "max", "p", "st", "store", "h", "bp", "set", "end", "bas", "rt", "balance", "zero", "handler", "fr", "ase", "based", "length", "mb", "db", "start", "se", "reset", "range", "bit", "id", "ref", "r", "origin", "et", "root", "bound", "bf", "orig", "bi", "x", "null", "type", "len", "no", "buffer", "f", "b", "file", "old", "Base"], "offset": ["pos", "index", "Offset", "error", "location", "pad", "slot", "shift", "set", "end", "fr", "length", "mt", "off", "address", "start", "pointer", "attr", "ptr", "addr", "time", "reset", "bit", "range", "id", "rot", "ref", "r", "et", "extra", "bound", "bf", "alt", "coord", "attribute", "block", "unk", "row", "rc", "type"], "opn": ["optc", "optnu", "optnt", "optcn", " opnp", " opns", " opcn", "Opcn", "optnp", "cmdn", "opns", "OPns", "cmdc", "OPcn", "Opn", " opnu", "optv", "cmdv", "hopn", "hopnp", " opnt", "opv", "opcn", "cmdnu", "Opr", "optn", " opv", "hopnt", "opr", "opnt", "OpN", "opnu", "OPc", "Opns", "opnp", " opr", "opN", "Opc", " opN", "hopcn", "OPN", "OPr", "OPn"], "t0": ["dt6", "m0", "att047", " t8", "tie", " t000", "ot1", " T0", "T0", "T6", "t180", "Tor", "T83", "tmp0", "t8", "tt0", "ot50", "dt0", " tMac", "tnOK", "tree0", "m8", "T000", "ot0", "rt0", "tMac", "t047", "T1", "dt83", "T4", "nt0", "test1", "tmp1", "TMac", " t6", "T9", "T50", "it1", " t7", " t047", "it4", " t4", "tree9", "test0", "it6", "det047", "T180", "nt7", "at4", "rt4", "it0", " t50", "ut0", "m1", "ut1", "at0", "det8", "gt1", " t83", "gt83", "tn0", "at83", " T8", " t9", " tie", "t00", "ttor", "tZero", "T7", "Tie", "at1", "gt180", " T1", "test83", "tt1", " t00", "dt1", "det0", "TZero", "rt000", "t7", "utMac", "tn7", "treeie", "att0", "gt0", "t9", "ntOK", "atNo", "tt9", " t180", " tOK", " T00", "t4", "ttZero", "m00", "att8", "T047", " tNo", "tt7", "t6", "at000", "ot047", "tNo", "t000", "attZero", "tmp000", " tor", " tZero", "ut6", "tree1", "itNo", "detZero", "t50", "tOK", "tor", "rt1", "it83", "t83"], "t1": ["te1", "t5", "v1", "taone", "ot2", "tree01", "ta120", "t2", "otone", " t8", "ptN", "ot001", "time512", "tsone", "pt512", "to6", "ot1", " t120", "T0", "nt1", "itOne", "nt110", " t512", "templateons", " t110", "e1", "ptone", "T12", "at6", "otons", "t8", "t01", "tree0", "time119", "terOne", "wt119", "atN", "otONE", "ot0", "ter41", "atOne", "ta1", "te0", "ot12", "atone", "Tons", "T1", "tt384", "tree001", "e01", "T2", "p1", "test1", "to0", " t6", "pt14", "v6", "T41", "t120", "it1", "T14", "pt01", "toone", "ter61", "tone", " t41", "to41", "tAP", " tOne", "to1", "tree31", "ot61", "T91", "e2", "timeAP", "t001", "pt110", "it0", "p2", "v0", "t512", "ntOne", "to384", "eONE", "template0", "test8", "ter5", "tOne", "t31", "te2", "otOne", "it61", "t12", "terone", "te01", " t256", "pt384", "pt41", " t9", " t5", "p01", "dt61", "atons", "at1", "v31", "ter1", "treeons", "tN", "tt1", "dt1", "testOne", "it9", "pt1", "tons", "v384", "tt01", "it91", "T120", "t384", "test256", "t9", " t61", "T5", "wt512", "t119", " t31", "nt512", "it256", "t41", "t110", "pt0", "tt41", " tN", "tree512", "ptOne", " tAP", "tree120", "t14", "template91", "t61", "e12", "wtAP", "to14", "at512", " t119", " t01", "tsOne", "t6", "itons", "Tone", "pt6", "time1", "ot512", "ot120", "dt9", "T01", "ter0", "t91", "wt1", "tONE", "treeOne", " t2", "t256", "to61", "tree1", "eone", "T001", " tONE", "template1", "e0", "p0", "itone", "it8", "ts120", "ts1", "T61", " tone", "dtone", "v01", "to01", "taOne"]}}
{"project": "qemu", "commit_id": "84ebd3e8c7d4fe955b359b9aac84395907b0412e", "target": 1, "func": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}", "idx": 19716, "substitutes": {"klass": [" klf", " klasses", "klasses", "tklasses", "iklass", "Klf", "Klasses", "Kls", "ikls", "iklasses", "klf", "tklf", "kclass", "tkls", "ikclass", " kls", " kclass", "Kclass", "kls", "Klass", "tklass"], "data": ["rew", "res", "w", "result", "ret", "dat", "ata", " Data", "name", "d", "DATA", "di", "mu", "Data", "attr", "kind", "value", "json", "def", "module", "cache", "dll", " DATA", "bin", "rc", "buffer"], "dc": ["design", "cs", "dp", "tc", "mac", "currency", "ga", "ca", "disc", "oc", "desc", "dt", "proc", "mc", "ec", " DC", "erc", "unc", "pc", "gc", "cam", "vc", "disk", "cca", "bc", "cc", "ct", "d", "di", "cd", "da", "doc", "dr", "cat", "uc", "c", "cr", "dm", "root", "draw", "lc", "cm", "fc", "df", "cu", "cache", "nc", "iac", "DC", "cp", "ac", "rc", "comp", "sc", "dd"], "diag288": ["diagger288", " diig288", "diog288", "diagg280", "diag248", "diagger263", " diig248", " diag263", " diog263", "diig280", "diog280", "diagg28", "diag28", "diagg256", "diig256", "diag256", "diagg248", " diag256", " diig256", "diog263", " diog288", "diagger280", "diagg263", "diig288", "diang248", " diog280", " diag248", "diang256", "diag280", "diang280", " diig280", "diang288", "diog28", "diagger28", " diag28", "diig248", "diag263", " diag280", " diog28", "diagg288"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "int ff_estimate_motion_b(MpegEncContext * s,\n\n                       int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code)\n\n{\n\n    int mx, my, range, dmin;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    const int mot_stride = s->mb_width + 2;\n\n    const int mot_xy = (mb_y + 1)*mot_stride + mb_x + 1;\n\n    \n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = mv_table[mot_xy    ][0];\n\n            P[0][1] = mv_table[mot_xy    ][1];\n\n            P[1][0] = mv_table[mot_xy - 1][0];\n\n            P[1][1] = mv_table[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = mv_table[mot_xy - mot_stride             ][0];\n\n                P[2][1] = mv_table[mot_xy - mot_stride             ][1];\n\n                P[3][0] = mv_table[mot_xy - mot_stride + 1         ][0];\n\n                P[3][1] = mv_table[mot_xy - mot_stride + 1         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            pred_x= P[1][0];\n\n            pred_y= P[1][1];\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    /* intra / predictive decision */\n\n//    xx = mb_x * 16;\n\n//    yy = mb_y * 16;\n\n\n\n//    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n//    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    dmin= halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n\n\n//    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    mv_table[mot_xy][0]= mx;\n\n    mv_table[mot_xy][1]= my;\n\n    return dmin;\n\n}\n", "idx": 19721, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "ops", "z", "scl", "t", "w", "sg", "args", "i", "p", "sb", "as", "ses", "ins", "sq", "aws", "h", "q", "sm", "set", "ctx", "qs", "is", "bs", "e", "g", "sv", "rs", "gs", "S", "ss", "d", "sw", "v", "ns", "sts", "vs", "ties", "se", "ps", "sys", "js", "ex", "c", "es", "ats", "r", "comm", "n", "fs", "ts", "ims", "ls", "an", "stats", "ms", "us", "spec", "sc", "b", "y", "its", "m"], "mb_x": ["kb_x", "mb1y", "mp_z", "mb__x", "mb__y", "emb_ex", "kb_y", "mb08ix", "kb_ix", "emb_dx", "mb_content", " MB_ix", "mp_x", "emb_y", " MB_x", "mp1width", "mb08content", " MB_X", "mp1ex", "mp1x", "kb_ex", "mb_dx", "mb_width", "mb_ix", "mb__z", "mb__dx", "mb08X", "mb1dx", "mb08x", " MB_content", "mb1z", "mp_width", "mb1ex", "mp_ex", "mb__ex", "mb_z", "mp1z", "emb_x", "mb_X", "mb__width", "mb1width", "mb_ex", "mb1x"], "mb_y": ["mb_xy", "mor_yl", "rav_xy", "ghost_y", "mb_ym", "mor08yl", "mor_yy", "mb67yl", "mb_yo", "ghost_gy", "mor08ny", "mb08yl", "mb___yt", "mb08yy", "mb67ny", "mb_yt", "mb___y", "mor08yy", "mb_ye", "rav_yo", "mb_ny", "mb08ny", "mb_yl", "mb______gy", "mb67y", "mb67yy", "mb___yl", "rav_x", "mb___yo", "ghost_ym", "mb_yy", "rav_y", "ref_yt", "ref_yl", "mb___yy", "mb___x", "ref_yy", "mb______y", "ghost_ye", "mb___xy", "mor08y", "mb______ye", "mor_ny", "mor_y", "mb______ym", "mb_gy", "ref_y", "mb08y"], "mv_table": ["mvi_map", "mv_array", "mvi2info", "mvi_info", "mv1tab", "mV_source", "mV_database", "mv_map", "mv5source", "mV_list", "mv_tab", "mv5tab", "mV_tab", "mov_list", "mv_info", "mvi2map", "mv_list", "mv2info", "mv2table", "mov_tab", "mov_table", "mvi2tab", "mov_array", "mV_table", "mv1map", "mv5list", "mv1table", "mvi_table", "mv_database", "mv2tab", "mv_source", "mvi2table", "mv2map", "mvi_tab", "mv5table", "mv1info", "mv5database"], "ref_picture": [" ref_friendly", "reference2image", "ref2picture", "ref__picture", "ref__proof", "ref2profile", "reference2profile", "reference2picture", "ref_person", "ref_communication", " ref_profile", "reference_picture", " ref_communication", "refogproof", "refgcode", "refogperson", "ref_friendly", "refogpicture", "ref_code", "refgpicture", " ref_proof", "ref2image", "ref__person", "refgproof", "ref_proof", "reference2pict", "reference_pict", "ref_profile", "reference_profile", "ref2pict", "ref__friendly", " ref_code", "refogfriendly", " ref_person", "ref_image", "ref_pict", "reference_image"], "f_code": ["flicpicture", "ref_language", "f___description", "f_picture", "f_description", "ref_codes", "f___name", "ref_code", "fjpicture", "fliccodes", "fdefdescription", "f___codes", "f___code", "f_name", "fjcode", "f_language", "fliclanguage", "fdefname", "fdefcodes", "fliccode", "fjcodes", "ref_name", "f_codes", "fjlanguage", "ref_description", "fdefcode"], "mx": ["mem", "rm", "mac", "mie", "px", "ax", "max", "tx", "mm", "wm", "md", "mc", "ml", "rx", "xy", "ctx", "mort", "mr", "mn", "mt", "MX", "nz", "mb", "ox", "mouse", "vm", "wx", "pm", "mp", "mi", "xs", "mic", "mind", "dm", "mk", "yx", "xx", "mop", "x", "yz", "xml", "xes", "cp", "fax", "ms", "ix", "y", "m"], "my": ["iam", "mem", "sam", "memory", "mie", "ys", "mm", "My", "colm", "les", "md", "mc", "me", "xy", " My", "maybe", "ym", "mn", "mos", "py", "his", "m", "your", "vm", "self", "sys", "pm", "mp", "mi", "yy", "try", " MY", "mph", "ti", "mk", "wi", "mon", "mg", "ny", "their", "gray", "MY", "mis", "by", "thing", "dds", "ms", "ty", "y", "multi", "mys"], "range": ["offset", "frame", "history", "loc", "use", "res", "rage", "channel", "size", "args", "window", "slice", "format", "max", "term", "usage", "store", "list", "q", "radius", "remote", "domain", "feature", "move", "base", "change", "rang", "scale", "ge", "fr", "resource", "shape", "command", "handle", "ch", "m", "force", "axis", "area", "spread", "call", "release", "race", "scope", "ref", "r", "batch", "ange", "diff", "bound", "path", "space", "ram", "ANGE", "exclusive", "row", "share", "view", "rest", "chain", "gap", "angle", "Range", "conf", "sample"], "dmin": ["ldmon", "dlMin", "dMIN", " dmins", "drmin", "dtmon", " damin", " dlower", "ldrain", "ldmin", "dsMin", " donly", "drrain", "rmins", "donestat", " dstat", "dlt", "draminus", "dpart", " dMin", " dMIN", "dramin", "dtstat", "nmins", "dmon", "drapart", "damin", "idpart", " dlt", "idamin", "dtmin", "donemon", "dlmin", "d0", "dllt", "donemin", "dtlower", "dstat", "nonly", "drMIN", "dminus", "nmin", "n0", "dsmin", "dMin", "dslt", "dlower", "drmon", "draamin", "dlminus", "ldMIN", " dmon", " drain", "r0", "donelower", "dmins", "dsminus", "drain", "idminus", "rmin", "ronly", "idmin", " d0", " dminus", " dpart", "donly"], "xmin": [" xmins", "wmax", "xpmax", "xxMin", " xinit", "fxinit", "ymins", "xpmin", "lexinit", "Xmin", "wstart", "wxmin", "fxmin", "xmlinit", " xbegin", "xminimum", "xmins", " xMin", "yinit", "exstart", "xbegin", "wmins", "xxmin", "xMin", "yMin", "ixmins", "xpstart", "Xminimum", "xinit", "xmlmin", "exmins", "fxmax", "xstart", "exbegin", "xxmax", "exmax", " xminimum", "Xmins", "xxmins", "lexmin", "xmlmins", "wmin", "exmin", "xpmins", "wxminimum", "ixmax", "wxmins", "ybegin", "lexmax", "Xmax", "wxmax", "ixmin", "fxbegin", "lexbegin", "ixbegin"], "ymin": ["ymedi", "Ymid", "ypart", "ymind", "yserv", "ilyserv", "axymedi", "veryserv", "ryserv", "ymins", "iymins", "lyminimum", " ystore", "cymins", "erymins", "fymin", "yminimum", "yMIN", "cymin", " ymind", "iyserv", "erymind", "xminimum", "xmins", "yymind", "ilymin", "ilymain", "cypart", "lymin", "iymid", "xMIN", "axyserv", "ymid", "yymin", "verymer", "verymins", "erymin", "ymer", "xpart", "Yserv", " ymins", "rymax", "verypart", " ymer", "rymid", "yymins", "ymain", "lyMIN", "cymax", "ystore", "yystore", "erystore", "ilymedi", "fypart", "cyminimum", "verymedi", "Ymax", "iypart", "Ymin", "axymain", "verymin", "verymain", "axymin", " ypart", "iymin", "lymax", "iymax", "cyMIN", "fymins", "rymin", "fymer"], "xmax": [" xax", "Xax", "xax", "mxax", "yend", "mxend", "xend", "ixax", "xtmax", "rxmin", "txmin", "xMAX", "ylast", "expr", "xtmod", "xhr", "ixhr", "xmllast", "exhr", "mxmax", "xmlmin", "xmod", "xmlmax", "ymod", "Xend", "ypr", "yMAX", "txMAX", "exmax", "xlast", "exMAX", "exax", "yax", "txmax", "exmin", "xpr", "xtax", "xtmin", "ixmax", "rxlast", " xmod", "rxMAX", "Xmax", "rxmax", "ixmin", "xmlMAX", " xhr", "ixpr"], "ymax": ["ammax", "ymAX", "ymake", "ammazon", "iemake", "ynagic", "yazon", "ynax", "ymazon", "iemap", "yask", "ammake", "ypass", "iemaxy", "ypake", "ynake", "ymagic", "symagic", "ammask", "ynac", "symass", "ermav", "symax", "symap", "iemAX", "iemax", "ymmax", "ymmap", "yake", "ymgr", "ymmaxy", "ymmaz", "iemaz", "ymmake", "ynass", "symav", "ymap", "symgr", "ymask", "ypazon", "pmake", "ymac", "ymav", "ermax", "pmap", "pmax", "yax", "ymaz", "ymmat", "ermap", "ypask", "symac", "ermaz", "ermAX", "yngr", "iemav", "ymass", "symake", "ypgr", "ymat", "ymaxy", "iemat", "ypac", "ypax", "symAX", "ypagic", "ermat", "ynav", "ypav", "pmaxy"], "rel_xmin": ["rel_dxstat", "rel_reman", "rel_dxmin", "rel_exmax", "rel_expath", "rel_dxmins", "rel_exstat", "rel_xman", "rel_yman", "rel_remin", "rel_xstat", "rel_ystat", "rel_ymins", "rel_xmins", "rel_exmins", "rel_remax", "rel_xpath", "rel_exman", "rel_repath", "rel_exmin", "rel_ypath", "rel_dxmax"], "rel_ymin": ["rel_ysminimum", "rel_Ymax", "rel_ysonly", "rel_mmin", "rel_Yminimum", "rel_Ymin", "rel_yonly", "rel_Yonly", "rel_mmins", "rel_ysmax", "rel_ysmin", "rel_monly", "rel_ymins", "rel_xmins", "rel_xminimum", "rel_mmax", "rel_Ymins", "rel_yminimum", "rel_xonly"], "rel_xmax": ["rel_exax", "rel_oxshow", "rel_latmax", "rel_yres", "rel_latstart", "rel_xmlres", "rel_exmax", "rel_xmlmin", "rel_oxmax", "rel_xax", "rel_yax", "rel_yshow", "rel_xshow", "rel_oxstart", "rel_exres", "rel_oxmin", "rel_xmlmax", "rel_ystart", "rel_exmin", "rel_xmlax", "rel_latmin", "rel_xstart", "rel_xres", "rel_latshow"], "rel_ymax": ["rel_iemaj", "rel_ymmaz", "rel_ymmask", "rel_yaj", "rel_yyax", "rel_yymax", "rel_yaz", "rel_ymaj", "rel_ymAX", "rel_yyaj", "rel_iemaz", "rel_yax", "rel_iemax", "rel_wyaj", "rel_yAX", "rel_wyax", "rel_iemask", "rel_ymmax", "rel_wymax", "rel_ymmaj", "rel_ymask", "rel_ymaz", "rel_yyAX", "rel_yask", "rel_wyAX"], "P": ["PP", "Progress", "Port", "Ps", "p", "PO", "PS", "PR", "PIN", "I", "J", "S", "G", "Array", "DP", "IP", "U", "H", "X", "B", "PUT", "PT", "M", "Q", "SCP", "PRE", "L", "V", "D", "C", "W", "N", "R", "PU", "A", "PF", "Z", "TP", "E", "Y", "K", "CP", "F", "O", "T", "PI"]}}
{"project": "FFmpeg", "commit_id": "ecb14b8af73b92e5a1be47c119d2f528ff402ebd", "target": 0, "func": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){\n\n    MpegEncContext * const s = &h->s;\n\n    AVCodecContext * const avctx= s->avctx;\n\n    H264Context *hx; ///< thread context\n\n    int buf_index;\n\n    int context_count;\n\n    int next_avc;\n\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n\n    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts\n\n    int nal_index;\n\n\n\n    h->nal_unit_type= 0;\n\n\n\n    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;\n\n    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){\n\n        h->current_slice = 0;\n\n        if (!s->first_field)\n\n            s->current_picture_ptr= NULL;\n\n        ff_h264_reset_sei(h);\n\n    }\n\n\n\n    for(;pass <= 1;pass++){\n\n        buf_index = 0;\n\n        context_count = 0;\n\n        next_avc = h->is_avc ? 0 : buf_size;\n\n        nal_index = 0;\n\n    for(;;){\n\n        int consumed;\n\n        int dst_length;\n\n        int bit_length;\n\n        uint8_t *ptr;\n\n        int i, nalsize = 0;\n\n        int err;\n\n\n\n        if(buf_index >= next_avc) {\n\n            if (buf_index >= buf_size - h->nal_length_size) break;\n\n            nalsize = 0;\n\n            for(i = 0; i < h->nal_length_size; i++)\n\n                nalsize = (nalsize << 8) | buf[buf_index++];\n\n            if(nalsize <= 0 || nalsize > buf_size - buf_index){\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);\n\n                break;\n\n            }\n\n            next_avc= buf_index + nalsize;\n\n        } else {\n\n            // start code prefix search\n\n            for(; buf_index + 3 < next_avc; buf_index++){\n\n                // This should always succeed in the first iteration.\n\n                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)\n\n                    break;\n\n            }\n\n\n\n            if(buf_index+3 >= buf_size) break;\n\n\n\n            buf_index+=3;\n\n            if(buf_index >= next_avc) continue;\n\n        }\n\n\n\n        hx = h->thread_context[context_count];\n\n\n\n        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);\n\n        if (ptr==NULL || dst_length < 0){\n\n            return -1;\n\n        }\n\n        i= buf_index + consumed;\n\n        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&\n\n           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)\n\n            s->workaround_bugs |= FF_BUG_TRUNCATED;\n\n\n\n        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){\n\n        while(dst_length > 0 && ptr[dst_length - 1] == 0)\n\n            dst_length--;\n\n        }\n\n        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n\n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);\n\n        }\n\n\n\n        if (h->is_avc && (nalsize != consumed) && nalsize){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);\n\n        }\n\n\n\n        buf_index += consumed;\n\n        nal_index++;\n\n\n\n        if(pass == 0) {\n\n            // packets can sometimes contain multiple PPS/SPS\n\n            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely\n\n            // if so, when frame threading we can't start the next thread until we've read all of them\n\n            switch (hx->nal_unit_type) {\n\n                case NAL_SPS:\n\n                case NAL_PPS:\n\n                    nals_needed = nal_index;\n\n                    break;\n\n                case NAL_IDR_SLICE:\n\n                case NAL_SLICE:\n\n                    init_get_bits(&hx->s.gb, ptr, bit_length);\n\n                    if (!get_ue_golomb(&hx->s.gb))\n\n                        nals_needed = nal_index;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        //FIXME do not discard SEI id\n\n        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)\n\n            continue;\n\n\n\n      again:\n\n        err = 0;\n\n        switch(hx->nal_unit_type){\n\n        case NAL_IDR_SLICE:\n\n            if (h->nal_unit_type != NAL_IDR_SLICE) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");\n\n                return -1;\n\n            }\n\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n\n        case NAL_SLICE:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= &hx->s.gb;\n\n            hx->s.data_partitioning = 0;\n\n\n\n            if((err = decode_slice_header(hx, h)))\n\n               break;\n\n\n\n            if (   h->sei_recovery_frame_cnt >= 0\n\n                && ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt) {\n\n                h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %\n\n                                    (1 << h->sps.log2_max_frame_num);\n\n            }\n\n\n\n            s->current_picture_ptr->f.key_frame |=\n\n                    (hx->nal_unit_type == NAL_IDR_SLICE);\n\n\n\n            if (h->recovery_frame == h->frame_num) {\n\n                h->sync |= 1;\n\n                h->recovery_frame = -1;\n\n            }\n\n\n\n            h->sync |= !!s->current_picture_ptr->f.key_frame;\n\n            h->sync |= 3*!!(s->flags2 & CODEC_FLAG2_SHOW_ALL);\n\n            s->current_picture_ptr->sync = h->sync;\n\n\n\n            if (h->current_slice == 1) {\n\n                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {\n\n                    decode_postinit(h, nal_index >= nals_needed);\n\n                }\n\n\n\n                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)\n\n                    return -1;\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    ff_vdpau_h264_picture_start(s);\n\n            }\n\n\n\n            if(hx->redundant_pic_count==0\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL){\n\n                if(avctx->hwaccel) {\n\n                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)\n\n                        return -1;\n\n                }else\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n\n                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};\n\n                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));\n\n                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );\n\n                }else\n\n                    context_count++;\n\n            }\n\n            break;\n\n        case NAL_DPA:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= NULL;\n\n\n\n            if ((err = decode_slice_header(hx, h)) < 0)\n\n                break;\n\n\n\n            hx->s.data_partitioning = 1;\n\n\n\n            break;\n\n        case NAL_DPB:\n\n            init_get_bits(&hx->intra_gb, ptr, bit_length);\n\n            hx->intra_gb_ptr= &hx->intra_gb;\n\n            break;\n\n        case NAL_DPC:\n\n            init_get_bits(&hx->inter_gb, ptr, bit_length);\n\n            hx->inter_gb_ptr= &hx->inter_gb;\n\n\n\n            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning\n\n               && s->context_initialized\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL)\n\n                context_count++;\n\n            break;\n\n        case NAL_SEI:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            ff_h264_decode_sei(h);\n\n            break;\n\n        case NAL_SPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            if(ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? (nalsize != consumed) && nalsize : 1)){\n\n                av_log(h->s.avctx, AV_LOG_DEBUG, \"SPS decoding failure, trying alternative mode\\n\");\n\n                if(h->is_avc) av_assert0(next_avc - buf_index + consumed == nalsize);\n\n                init_get_bits(&s->gb, &buf[buf_index + 1 - consumed], 8*(next_avc - buf_index + consumed));\n\n                ff_h264_decode_seq_parameter_set(h);\n\n            }\n\n\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n\n                s->low_delay=1;\n\n\n\n            if(avctx->has_b_frames < 2)\n\n                avctx->has_b_frames= !s->low_delay;\n\n            break;\n\n        case NAL_PPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n\n\n            break;\n\n        case NAL_AUD:\n\n        case NAL_END_SEQUENCE:\n\n        case NAL_END_STREAM:\n\n        case NAL_FILLER_DATA:\n\n        case NAL_SPS_EXT:\n\n        case NAL_AUXILIARY_SLICE:\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n\n        }\n\n\n\n        if(context_count == h->max_contexts) {\n\n            execute_decode_slices(h, context_count);\n\n            context_count = 0;\n\n        }\n\n\n\n        if (err < 0)\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n\n        else if(err == 1) {\n\n            /* Slice could not be decoded in parallel mode, copy down\n\n             * NAL unit stuff to context 0 and restart. Note that\n\n             * rbsp_buffer is not transferred, but since we no longer\n\n             * run in parallel mode this should not be an issue. */\n\n            h->nal_unit_type = hx->nal_unit_type;\n\n            h->nal_ref_idc   = hx->nal_ref_idc;\n\n            hx = h;\n\n            goto again;\n\n        }\n\n    }\n\n    }\n\n    if(context_count)\n\n        execute_decode_slices(h, context_count);\n\n    return buf_index;\n\n}\n", "idx": 19724, "substitutes": {"h": ["hs", "history", "hh", "oh", "w", "sh", "kh", "p", "he", "hz", "th", "bh", "hash", "ctx", "q", "hr", "html", "hd", "g", "ht", "header", "handle", "m", "ch", "v", "hw", "k", "H", "ih", "head", "http", "hm", "c", "hp", "j", "dev", "r", "comm", "host", "ph", "o", "dh", "cache", "x", "rh", "ah", "f", "hal", "b", "eh", "hl"], "buf": ["mem", "cap", "cv", "Buff", "np", "arr", "mates", "window", "img", "proc", "rw", "bh", "bp", "ctx", "fb", "bag", "vec", "cur", "map", "tmp", "cast", "queue", "bc", "conv", "db", "v", "pb", "wb", "doc", "cmd", "pkg", "func", "bu", "batch", "str", "bf", "rb", "cb", "block", "ba", "uf", "bin", "buffer", "Buffer", "buff", "b", "seq", "br", "bn"], "buf_size": ["buf_SIZE", "bufPSize", "uf_content", "buf__amount", "bufowsize", " buf_amount", "uf_cache", "buf2SIZE", "buf_Size", "bufPcache", "buff_SIZE", "buf__size", " buf2size", "buf_content", " buf_start", " buf2amount", "bufixsize", "buf__SIZE", "buff_space", "buf_amount", "buf_start", "buf2start", "bufowstart", "bufixcache", "buf__start", "buf2size", "bufowSIZE", "buf_cache", "uf_SIZE", "bufixcontent", "buf2amount", "bufPsize", " buf2start", " buf_SIZE", "buff_size", "bufixSize", "uf_Size", " buf2SIZE", "bufowamount", "bufPcontent", "buf_space", "uf_index", "uf_size"], "s": ["sc", "a", "services", "hs", "ds", "cs", "utils", "os", "t", "settings", "sh", "bits", "as", "p", "ess", "ses", "sb", "ins", "sq", "sp", "th", "aws", "ctx", "set", "is", "syn", "g", "sv", "rs", "gs", "S", "ss", "his", "conv", "d", "session", "v", "ns", "sts", "vs", "socket", "sports", "sys", "ps", "js", "http", "c", "j", "es", "ats", "n", "fs", "ts", "ims", "ls", "stats", "ms", "wcs", "spec", "sl", "b", "has", "its", "m"], "avctx": ["avecontext", "avctl", " avsys", "vcontext", "apcp", "vtx", "avtc", " avtc", " avcontext", "avcc", "avercc", "avecfg", "avercu", "wavcv", "avcu", "avcv", "avecv", "wavctx", " avcp", "wavconn", "averjac", "avsys", "avconn", "avertx", "wavcmp", "avercv", " avcc", "avjac", "avercp", "avcontext", "avcfg", "avectl", "averctl", "avcmp", "apkt", "wavcfg", " avtx", " avconn", " avkt", "wavctl", "avesys", "avetc", "apcc", "averctx", "avecp", "aversys", "wavtx", "wavcontext", "avectx", "avertc", "apctx", "wavcu", "wavjac", "avcp", "avejac", " avcu", "avtx", "averconn", "avercontext", "avercfg", "vcmp", " avcmp", "vctx", " avjac", "avetx", "averkt", "avkt"], "hx": ["thx", "thtx", "htx", "thxx", "ihxx", "hxx", " htx", "ihx", "ihtx", " hxx"], "buf_index": ["buf_point", "broad_index", "buff2size", " buf_iter", "buf_level", " buf_lock", "broad_search", "buff2iter", "uf_start", "buf_ind", "uf_number", "buf2ind", "buf_iter", "broad_address", " buf_status", "buf_status", "buf_slice", "cachegiterator", "buf_count", "uf_open", "cachegindex", "bufxnumber", "cache_iterator", "uf_ind", "buf_no", "uf_iter", "buff_iter", "bufgiterator", "uf_strength", "uf_len", " buf_location", "cache_index", "cachegind", "buf_start", "buf_len", "buf_address", " buf_ind", "bufgnum", "cache_num", "cachegnum", "buf2size", "bufxstart", "buff_index", " buf_level", "uf_no", "buf_num", "bufxindex", "bufgind", "cache_ind", "buf_Index", "buf_open", "buf___strength", "buf2iter", "buff_size", "buf___open", "buf___index", "buf_number", " buf_Index", " buf_point", "bufgindex", "buf_strength", "buf_location", "buf_iterator", "buff2index", "uf_index", "buf2index", "broad_slice", "uf_count", "uf_size", "buf___size", "buf2count", "buf_search", "buf_lock"], "context_count": ["context8table", " context64table", "contextingmax", "contextingcount", "component_length", "context_length", " context64child", "context8comment", "context_Count", "context64child", " context_comment", "component_Count", "contextinglength", " context64comment", "context64table", "context_max", " context_table", "contextingCount", "context64comment", "context_comment", " context_child", "context8count", "component_max", "context64count", " context64count", "context_child", "context8child", "context_table", "component_count"], "next_avc": ["next_afac", "next___avcs", "next_cvcs", "next_awc", "next_avcache", "next_avac", "next_avef", "next_cvc", "next_avalbc", "next___avc", "next_avalpc", "next_wavcu", "next_wavcs", "next_ovc", "next_avecache", "next_averca", "next_ovcs", "next_avebc", "next_svf", "next_wavci", "next_afca", "next_avect", "next_aveci", "next_svcu", "next_avercc", "next_avalcs", "next_averc", "next_ovcc", "next___afcs", "next_cvbc", "next_aveca", "next_ovf", "next_avf", "next_avcc", "next_awci", "next___afca", "next___avca", "next_svc", "next_wavc", "next_cvpc", "next_avecc", "next_avcs", "next_avercs", "next_averf", "next_awct", "next_awcache", "next_avecs", "next___avac", "next_ovca", "next_avpc", "next_avbc", "next_wavct", "next_avercu", "next_avci", "next___afc", "next_ovac", "next_avca", "next_wavf", "next_afc", "next_avct", "next_avalc", "next_wavcache", "next_avepc", "next_svcs", "next___afac", "next_afcs", "next_avec", "next_wavca", "next_wavac", "next_avcu"], "nal_index": ["nale_label", "nale_link", "nal_key", "nal__label", "nale_index", "nal_count", "nals_key", "nals_position", "nals_count", "nal_ind", "nal_position", "nal__count", "nal__link", "nalacindex", "nalacind", "nalaclink", "nal__position", "nale_ind", "nalaclabel", "nal__key", "nal__index", "nal__ind", "nals_index", "nal_link", "nal_label"], "pass": ["check", "pos", "fl", "strip", "can", "ask", "p", "pp", "proc", "stage", "ret", "level", "conf", "arg", "fail", "run", "prop", "PASS", "password", "step", "handle", "pillar", "session", "gain", "auth", "mask", "push", "read", "fall", "call", "allow", "skip", "commit", "mode", "j", "ass", "access", "func", "through", "def", "act", "pas", "Pass", "acc", "card", "par", "row", "pa", "scan", "phase", "status", "col", "loop", "process"], "consumed": ["Consumed", "Consumption", "consaved", "Consume", " unconsaved", "Consaved", "presume", "presumption", "consumption", " unconsume", " unconsumption", "consume", " unconsumed", "presumed", "presaved"], "dst_length": ["dst_len", "dst__count", "dst2len", "dst_count", "dest_len", "dest_length", "dst2count", "dst__length", "dest_count", "dst2length", "dst__len"], "bit_length": ["bits_length", "bit64size", "bit2count", "bit_count", "bit2length", "bit2len", "bit2size", "bit64length", "bit64count", "bits_len", "bit_size", "bits_size", "bit_len", "bit64len", "bits_count"], "ptr": ["offset", "arr", "Ptr", "pr", "pad", "desc", "enc", "ctx", "cur", "vec", "tr", "length", "address", "pointer", "attr", "dr", "addr", "rev", "ind", "ref", "str", "rc", "buffer", "src", "heads", "ctr", "br"], "i": ["ic", "index", "l", "si", "ci", "hi", "ei", "ki", "qi", "me", "li", "\u0438", "e", "I", "ai", "phi", "v", "io", "di", "cli", "ip", "MI", "mi", "pi", "c", "ind", "id", "in", "j", "xi", "ti", "ui", "wi", "gi", "multi", "bi", "iu", "x", "zi", "ini", "sim", "gu", "f", "it", "ix", "b", "y", "ii", "m"], "err": ["error", "res", "arr", "or", "valid", "score", "ei", "proc", "result", "Error", "level", "e", "count", "rr", "call", "race", "cr", "func", "r", "str", "diff", "extra", "raw", "errors", "complete", "er", "coord", "rn"]}}
{"project": "FFmpeg", "commit_id": "611b35627488a8d0763e75c25ee0875c5b7987dd", "target": 1, "func": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n\n                                const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext *pc = &dctx->pc;\n\n    uint64_t state = pc->state64;\n\n    int pic_found = pc->frame_start_found;\n\n    int i = 0;\n\n\n\n    if (!pic_found) {\n\n        for (i = 0; i < buf_size; i++) {\n\n            state = (state << 8) | buf[i];\n\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n\n                i++;\n\n                pic_found = 1;\n\n                dctx->cur_byte = 0;\n\n                dctx->remaining = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (pic_found && !dctx->remaining) {\n\n        if (!buf_size) /* EOF considered as end of frame */\n\n            return 0;\n\n        for (; i < buf_size; i++) {\n\n            dctx->cur_byte++;\n\n            state = (state << 8) | buf[i];\n\n\n\n            if (dctx->cur_byte == 24) {\n\n                dctx->h = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 26) {\n\n                dctx->w = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 42) {\n\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n\n\n                if (cid <= 0)\n\n                    continue;\n\n\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n\n                if (dctx->remaining <= 0) {\n\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n\n                    if (dctx->remaining <= 0)\n\n                        return dctx->remaining;\n\n                }\n\n                if (buf_size - i + 47 >= dctx->remaining) {\n\n                    int remaining = dctx->remaining;\n\n\n\n                    pc->frame_start_found = 0;\n\n                    pc->state64 = -1;\n\n                    dctx->cur_byte = 0;\n\n                    dctx->remaining = 0;\n\n                    return remaining;\n\n                } else {\n\n                    dctx->remaining -= buf_size;\n\n                }\n\n            }\n\n        }\n\n    } else if (pic_found) {\n\n        if (dctx->remaining > buf_size) {\n\n            dctx->remaining -= buf_size;\n\n        } else {\n\n            int remaining = dctx->remaining;\n\n\n\n            pc->frame_start_found = 0;\n\n            pc->state64 = -1;\n\n            dctx->cur_byte = 0;\n\n            dctx->remaining = 0;\n\n            return remaining;\n\n        }\n\n    }\n\n    pc->frame_start_found = pic_found;\n\n    pc->state64 = state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 19728, "substitutes": {"dctx": ["ddctx", "docpu", "daresp", " dork", "Dmom", "dmom", "djcp", "Dcp", "docm", "dagc", "daca", "ddtx", "dacv", "ddalloc", "dcas", "dgc", "Dobj", "calbatch", "didcas", "sdwp", "Dpkg", "dactr", " dbatch", "dcv", "didcontext", "dlwp", "Dcas", "djcss", "dactl", "pdpkg", "doalloc", "dserv", "datx", " dgc", "dcmp", "donectx", "docp", "donecfg", "odctx", "Dctx", "djcas", "delserv", "dcrit", "didwp", " dcmd", "odcrit", "pdctx", "ddork", "ddcmd", "dctr", "modcm", "dloc", "dbctx", "dacmd", "dcfg", "Dcontext", "dacontext", " dtx", " dfunc", " dcrit", " dobj", " dca", "_", " dcpu", "modcss", "doobj", "dacp", "ddreq", "dfunc", "dcomp", "call", "dalloc", "dbjac", "ddcontext", "dcp", " dcss", "djctx", "dctl", "djca", "dbatch", "pdobj", "sdpkg", "dcmd", "doreq", "dcpu", "donecas", "dtx", " dpkg", " dalloc", "didcmp", "dcss", "sdctx", "djcontext", "docontext", "dowp", "xff", "delctx", " dcm", "dobj", "ffff", "datimeout", " dctl", " dreq", "calpkg", "dlcontext", "dawp", "dork", "delcm", "doctr", "daproc", " dinst", "dcm", " dloc", " dcas", "ddctr", "calcrit", "dcontext", "ddpkg", "doneproc", "daloc", "Djac", "didmom", "dca", "odbatch", "dbtx", "dbobj", "donetimeout", "docmp", "dlcomp", "doinst", "ddresp", " dcv", "modpkg", "dinst", "def", "dpkg", "dlctx", "dwp", "didpkg", "pdfunc", "dreq", " dmom", " dresp", "daobj", "dlcm", "dofunc", " dcontext", "djac", " dcfg", "didcfg", "donewp", "didtx", " dcp", " dwp", "didcomp", "dproc", "delcontext", "donecp", " dcmp", "docv", "dacss", "didctx", "odpkg", "didinst", " djac", "dlloc", "dactx", "dbwp", "dbproc", " dserv", "dresp", "dlserv", "dlgc", "func", "dbtimeout", "didobj", "dotx", "new", "dlobj", "docss", "didcp", "modctx", "Dtx", " dctr", " dcomp", "dtimeout", "dopkg", "dlctl", "calctx", "daork", "sdcontext", "doctx"], "buf": ["late", "mem", "cap", "cv", "Buff", "aka", "arr", "img", "bits", "p", "bb", "bar", "proc", "bp", "ctx", "fb", "bag", "ob", "bs", "vec", "cast", "queue", "bc", "v", "bytes", "brace", "pb", "doc", "bl", "msg", "cmd", "batch", "obs", "pack", "bf", "rb", "cb", "block", "bin", "uf", "que", "buffer", "Buffer", "buff", "b", "br"], "buf_size": ["box_fee", "buf_SIZE", "uf_empty", "buf_name", "buf_ize", "cb_name", "box_size", "buf0size", "bnvalsize", "cb_ize", "buf2range", "buf_source", "bn_source", "buf2len", "buf_Size", "buf0length", "bn_gz", "bufvalgz", " buf_Size", "uf_too", "buf_loc", "bnvalgz", "bn_loc", "cb_size", "bufvalsource", "buf67Size", "bufswsource", " buf_length", "buf0ize", "bnvalsource", "buf0Size", "bufswgz", "buf_len", "buf_style", "bufswloc", "buf_empty", "buf2size", "bnvalloc", "buf_too", "bn_size", "bufvalloc", "bufvalsize", "buf67size", "buf_range", "box_style", "box_Size", "cb_Size", "buf_length", "buf2Size", "buf_fee", "uf_found", "cb_range", "bufswsize", "buf67fee", "cb_len", "cb_SIZE", "buf67style", "buf_found", "buf_gz", "uf_size", " buf_ize"], "pc": ["lp", "cs", "psc", "tc", "px", "wp", "pr", "p", "ping", "amp", "lib", "proc", "mc", "acl", "PC", "ec", "ctx", "pic", "gc", "cam", "vc", "pan", "amps", "bc", "cc", "alloc", "tp", "pointer", "pb", "sys", "pm", "conn", "mp", "c", "pi", "pt", "func", "pkg", "pd", "cmp", "tk", "lc", "cm", "dc", "fc", "cu", "nc", "anc", "pa", "pn", "iac", "cp", "rc", "ac", "icc", "arc", "pac"], "i": ["li", "span", "ri", "e", "g", "point", "I", "copy", "ai", "di", "iter", "mi", "c", "ji", "ex", "multi", "ii", "yi", "index", "ij", "t", "ci", "list", "\u0438", "phi", "v", "io", "cli", "pi", "my", "try", "gi", "o", "fi", "bi", "x", "zi", "ini", "f", "it", "ia", "iu", "status", "init", "ic", " pos", "l", "slice", "ei", "qi", " ti", "me", "load", " ii", "ip", "any", "to", " j", "j", "ti", "print", " I", "ami", "uri", "go", " bi", "ix", "b", "y", "m", "si", "im", "p", "client", "ki", "is", "u", "oi", "ind", "in", "record", "xi", "ui", "batch", "ims", "sim"], "cur_byte": ["cur_element", "curjbyte", "cur5Byte", "Cur_byte", "cur5element", "cur___bytes", "cur___bit", "cur_bytes", "Cur_second", "now_note", "Cur_Byte", "cur5bytes", "curJline", "cur_note", "cur___page", "cur___Byte", "Cur_bytes", "cur5byte", "cur_page", "cur_Byte", "curjbytes", "now_page", "curjpage", " cur_line", "now_byte", "curJbyte", "cur_bit", "Cur_page", "cur___byte", "Cur_note", "curjByte", " cur_element", "cur_line", "curJbytes", "curjnote", " cur_bytes", "cur_second", " cur_Byte", "Cur_bit", "cur___second"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext      *ctx = avctx->priv_data;\n\n    VAAPIEncodeH264Context *priv = ctx->priv_data;\n\n    int hrd_buffer_size;\n\n    int hrd_initial_buffer_fullness;\n\n\n\n    if (avctx->bit_rate > INT32_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Target bitrate of 2^31 bps or \"\n\n               \"higher is not supported.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size)\n\n        hrd_buffer_size = avctx->rc_buffer_size;\n\n    else\n\n        hrd_buffer_size = avctx->bit_rate;\n\n    if (avctx->rc_initial_buffer_occupancy)\n\n        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;\n\n    else\n\n        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;\n\n\n\n    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;\n\n    priv->rc_params.rc = (VAEncMiscParameterRateControl) {\n\n        .bits_per_second   = avctx->bit_rate,\n\n        .target_percentage = 66,\n\n        .window_size       = 1000,\n\n        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),\n\n        .min_qp            = (avctx->qmin >= 0 ? avctx->qmin : 18),\n\n        .basic_unit_size   = 0,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->rc_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->rc_params);\n\n\n\n    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;\n\n    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {\n\n        .initial_buffer_fullness = hrd_initial_buffer_fullness,\n\n        .buffer_size             = hrd_buffer_size,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->hrd_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->hrd_params);\n\n\n\n    // These still need to be  set for pic_init_qp/slice_qp_delta.\n\n    priv->fixed_qp_idr = 26;\n\n    priv->fixed_qp_p   = 26;\n\n    priv->fixed_qp_b   = 26;\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\"PRId64\" bps.\\n\",\n\n           avctx->bit_rate);\n\n    return 0;\n\n}\n", "idx": 19759, "substitutes": {"avctx": ["navtx", "AVctx", " avcontext", "aveconn", "AVjp", "aveconf", "avobj", "wavctx", "avconn", "evcontext", "wavcmp", "avjac", " avconfig", "tvjac", "vrtx", " avcall", "avtxt", "avpkg", "wavcontext", "avetxt", "ajcmp", "savjac", "wavct", "avertmp", "avercomp", "averfc", "avercfg", "avekl", " avjac", "wavca", "avetx", "vobj", "avecontext", "navcp", "navcontext", "savset", "avefc", "avcpu", "savcomp", "avfc", "navkl", "avecmp", "navcf", "wavconn", "aveca", "AVcfg", "avconfig", " avcf", "vrreq", "navfc", "aveobj", "evctx", "averjp", " avtx", "navcfg", "averkl", "avkw", "avcf", "avecp", " avreq", "vtmp", "vrtmp", "navtxt", "tvset", "avcp", "vcfg", "avtmp", "navkw", "averconn", "avercall", "wavcpu", "vrcontext", "savctx", "tvpkg", "vctx", "avca", "savpkg", "vcontext", "avertxt", "aucpu", "evreq", " avcomp", "tvctx", "auctx", " avcfg", "wavkl", "wavpid", "ajct", "averca", "savcf", "avkl", "wavconf", "navjp", "avcontext", "avcfg", "avcomp", "aucmp", "avcall", "navcomp", "abcfg", "vpid", "ajcpu", "avectx", "wavjp", "avekw", "avpid", "avejp", " avcmp", " avkw", "averpid", "averconf", "avreq", "wavconfig", "avecfg", "navcmp", "wavobj", "abcmp", " avcp", " avobj", "avepid", "avcmp", "navcall", "ajctx", "wavcfg", " avset", "evtx", "auct", "vrpid", "avconf", " avpkg", "averctx", "vrcfg", "avset", "abcontext", "vconfig", "navpkg", "AVtx", "vrctx", "avjp", "navctx", "avtx", "abctx", "avct", "avercmp", "averobj"], "ctx": ["loc", "ck", "tx", "dt", "rt", "kw", "obj", "sys", "context", "dc", "xc", "exec", "mem", "td", "cv", "np", "fn", "desc", "mc", "tmp", "ct", "etc", "hw", "doc", "pri", "call", "xs", "pkg", "pt", "kl", "voc", "ctrl", "fc", "cu", "resp", "org", "init", "ctl", "tc", "nt", "wp", "acl", "rect", "kt", "unc", "expr", "cf", "xp", "jac", "alloc", "cc", "bc", "co", "ptr", "addr", "cmp", "def", "act", "txt", "iac", "fx", "cp", "mint", "tz", "public", "gc", "config", "ns", "wx", "wd", "conn", "cmd", "ind", "func", "pool", "mk", "cb", "nc", "ac", "conf", "iat"], "priv": ["mem", "rib", "riv", "pub", "nt", "perm", "Priv", "pr", "tx", "lib", "proc", "rw", "good", "expr", "prov", "public", "prop", "py", "alloc", "sec", "pro", "etc", "auth", "ptr", "pb", "pri", "soc", "attr", "sys", "doc", "conn", "pi", "access", "rev", "pkg", "ocr", "admin", "dev", "rel", "private", "cfg", "cmp", "cer", "def", "env", "exec", "Pri", "rc", "cp", "rest", "policy", "serv", "conf"], "hrd_buffer_size": ["hrd_buffer_len", "hrd_block_size", "hrd_window_size", "hrd_window_SIZE", "hrd_Buffer_SIZE", "hrd_enum_Size", "hrd_enum_size", "hrd_enumlensource", "hrd_block_len", "hrd_block_Size", "hrd_buffer_strength", "hrd_buffer_SIZE", "hrd_Buffer_strength", "hrd_window_Size", "hrd_buffer_Size", "hrd_enum_source", "hrd_bufferlensize", "hrd_window_name", "hrd_buffer_max", "hrd_buffer_body", "hrd_Buffer_data", "hrd_buffer_data", "hrd_window_max", "hrd_bufferlenSize", "hrd_bufferlensource", "hrd_block_name", "hrd_enum_body", "hrd_window_length", "hrd_enumlenSize", "hrd_buffer_name", "hrd_enumlenbody", "hrd_buffer_source", "hrd_Buffer_size", "hrd_bufferlenbody", "hrd_enumlensize", "hrd_buffer_length"], "hrd_initial_buffer_fullness": ["hrd_initial_buffer_broadness", "hrd_initial_buffer_fullity", "hrd_initial_buffer_fullivity", "hrd_initial_buffer_fullyly", "hrd_initial_buffer_cleanity", "hrd_initial_buffer_fulity", "hrd_initial_buffer_fullylength", "hrd_initial_buffer_fully", "hrd_initial_buffer_fullyiveness", "hrd_initial_buffer_fullyness", "hrd_initial_buffer_fuliveness", "hrd_initial_buffer_offity", "hrd_initial_buffer_fulllength", "hrd_initial_buffer_fullyity", "hrd_initial_buffer_fulliness", "hrd_initial_buffer_offlength", "hrd_initial_buffer_broadly", "hrd_initial_buffer_broadivity", "hrd_initial_buffer_fulliveness", "hrd_initial_buffer_fullliness", "hrd_initial_buffer_broadity", "hrd_initial_buffer_fullyivity", "hrd_initial_buffer_fullyfulness", "hrd_initial_buffer_fulness", "hrd_initial_buffer_broadfulness", "hrd_initial_buffer_fullength", "hrd_initial_buffer_cleanness", "hrd_initial_buffer_cleanfulness", "hrd_initial_buffer_offiveness", "hrd_initial_buffer_cleanliness", "hrd_initial_buffer_fulivity", "hrd_initial_buffer_fullly", "hrd_initial_buffer_fulfulness", "hrd_initial_buffer_fullyliness", "hrd_initial_buffer_fullfulness", "hrd_initial_buffer_offness"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)\n\n{\n\n\tlong x,y;\n\n\n\n\tdst[0]= src[0];\n\n\n\n\t// first line\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n\n\n        dst+= dstStride;\n\n\n\n\tfor(y=1; y<srcHeight; y++){\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\t\tconst long mmxSize= srcWidth&~15;\n\n\t\tasm volatile(\n\n\t\t\t\"mov %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_a\"), %%mm1\t\\n\\t\"\n\n\t\t\t\"movq 1(%0, %%\"REG_a\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"movq 1(%1, %%\"REG_a\"), %%mm3\t\\n\\t\"\n\n\t\t\t\"movq -1(%0, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movq -1(%1, %%\"REG_a\"), %%mm5\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm5, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm4, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm3, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm2, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm2, %%mm6\t\t\\n\\t\"\n\n#if 1\n\n\t\t\tMOVNTQ\" %%mm5, (%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm4, (%3, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#else\n\n\t\t\t\"movq %%mm5, (%2, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\t\"movq %%mm4, (%3, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#endif\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\t:: \"r\" (src + mmxSize  ), \"r\" (src + srcStride + mmxSize  ),\n\n\t\t\t   \"r\" (dst + mmxSize*2), \"r\" (dst + dstStride + mmxSize*2),\n\n\t\t\t   \"g\" (-mmxSize)\n\n\t\t\t: \"%\"REG_a\n\n\n\n\t\t);\n\n#else\n\n\t\tconst long mmxSize=1;\n\n#endif\n\n\t\tdst[0        ]= (3*src[0] +   src[srcStride])>>2;\n\n\t\tdst[dstStride]= (  src[0] + 3*src[srcStride])>>2;\n\n\n\n\t\tfor(x=mmxSize-1; x<srcWidth-1; x++){\n\n\t\t\tdst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;\n\n\t\t\tdst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;\n\n\t\t}\n\n\t\tdst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;\n\n\t\tdst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;\n\n\n\n\t\tdst+=dstStride*2;\n\n\t\tsrc+=srcStride;\n\n\t}\n\n\n\n\t// last line\n\n#if 1\n\n\tdst[0]= src[0];\n\n\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n#else\n\n\tfor(x=0; x<srcWidth; x++){\n\n\t\tdst[2*x+0]=\n\n\t\tdst[2*x+1]= src[x];\n\n\t}\n\n#endif\n\n\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 19782, "substitutes": {"src": ["loc", "size", "img", "sup", "st", "ctx", "imp", "rt", "scale", "rs", "length", "ipl", "iv", "RC", "sys", "rl", "sync", "aux", "sr", "s", "sl", "hl", "np", "sel", "dist", "sh", "desc", "input", "syn", "cur", "tmp", "sec", "sn", "via", "ctrl", "obs", "usr", "ctr", "sc", "inc", "sb", "proc", "rx", "usc", "cc", "sw", "ptr", "http", "std", "str", "rb", "source", "txt", "ssl", "rc", "ins", "secure", "sq", "bs", "seq", "supp", "cont", "in", "inst", "sur", "comp", "dest", "ser", "lb"], "dst": ["dscr", "dsts", "sdst", "ddx", "deput", " dx", "donwp", "dsrest", "dsc", "Dsp", "dST", "dsest", "idv", "Dst", "idwp", "idst", " ddest", "ddreat", " dcr", "sdST", " dsp", "sdest", "donv", "donsts", "ddest", " dreat", "ddst", "ddsc", " dbl", "dreat", "dssts", "nsp", "dsST", "Dest", " dv", "sbl", "sst", " dsc", " dest", "Dx", " dST", "dbl", "sreat", "dsp", "dddest", "Dsc", "dwp", "sdsts", "Drest", "dput", " dport", "Dsts", " dwp", "nst", "dcr", " drest", "deport", "deest", "donst", "Dport", "dv", " dput", "dsst", "Dcr", " dsts", "dsput", "dport", "sdput", "idsts", "Dput", "drest", "ddbl", "nsts", "nest", "dx", "dest"], "srcWidth": ["rcHeight", "stWidth", "srHeight", " srcSize", "srcAmount", "sourceLeft", "rcLeft", "rcNetwork", "hlAmount", "srcLeft", "srcGraph", "auxH", " srcNetwork", "srcSize", "srcPath", "srGraph", "rcPath", "sourceWidth", "srcH", "auxWidth", " srcLeft", "rcAmount", "rcSize", " srcPath", "rsWidth", "sourceSize", "rsSize", "hlHeight", "rcLength", "hlWidth", "srWidth", "stPath", "srAmount", "rcH", "auxHeight", "rcGraph", "srcNetwork", "srcLength", " srcH", "hlGraph", " srcLength", "stLength", "rsNetwork", "sourceHeight", "auxSize", "rcWidth", "stHeight", "rsHeight"], "srcHeight": ["rcHeight", "srcheight", " srcSize", "secureWidth", "srcTheme", " srcheight", "srcSize", "rcheight", "srcCount", "sourceWidth", "secureTheme", "rcSize", "rcCount", "sourceSize", "secureheight", "sourceCount", "rcTheme", " srcCount", "secureHeight", " srcTheme", "sourceHeight", "rcWidth"], "srcStride": ["srcRestrat", "rcStrrict", "srcSlrict", "rcStride", "rcStrip", "srcRestide", "srcSlide", "srcStrrat", "srcSlride", "srcStrrip", "rcStrict", "srcSpide", "srcDestrat", "srcDestrict", "srcSpride", "rcStide", "srcDestide", "srcStrrict", "srcSprat", "srcRestrip", "rcStrrat", "srcSprip", "srcRestride", "srcDestride", "srcStide", "srcStrride", "srcStrip", "rcStrat", "srcSlrat", "rcStrrip", "srcStrict", "rcStrride", "srcStrat"], "dstStride": ["dstRestide", "dststr", "dstStrid", "dstSlide", "dststride", "dststd", "dstStd", "dstFlride", "dndStride", "dndStrride", "dstStrride", "dstRestd", "dstRestride", "dsrcStide", "dststide", "dstSlrid", "dndStrr", "dstSlride", "dndStide", "dstStr", "dstFlrid", "dsrcStrrid", "dstStide", "dstStrr", "dstFlide", "dsrcStrride", "dsrcStride", "dndStrd", "dsrcStrid", "dstStrrid", "dndStd", "dndStr", "dstRestr", "dstStrd"], "x": ["z", "px", "lex", "tx", "inx", "e", "g", "lat", "step", "ox", "xf", "get", "page", "path", "xc", "ux", "chain", "ex", "cy", "index", "el", "item", "t", "ry", "on", "ct", "content", "d", "scroll", "X", "mx", "xd", "n", "xe", "l", "w", "xt", "rx", "column", "xp", "name", "j", "att", "xx", "draw", "print", "edit", "fx", "ix", "ax", "i", "p", "at", "xy", "axis", "dr", "wx", "ind", "ext", "xi", "batch", "yx", "key", "dx", "full"], "y": ["ies", "yi", "ly", "sky", "yn", "t", "i", "yr", "very", "h", "xy", "axy", "kit", "sy", "ey", "ym", "py", "lat", "ot", "ch", "out", "ay", "sys", "ya", "ye", "my", "yy", "yer", "try", "j", "vy", "pt", "gy", "wy", "uy", "dy", "ery", "yo", "o", "ny", "yt", "iy", "by", "Y", "oy", "yl", "ty", "b", "cy", "m"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        TCGv msr = tcg_temp_new();\n\n\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);\n\n#else\n\n        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n        gen_helper_store_msr(cpu_env, msr);\n\n        tcg_temp_free(msr);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 19808, "substitutes": {"ctx": ["loc", "ck", "tx", "handler", "rt", "crit", "kw", "conv", "obj", "sys", "req", "jp", "context", "cm", "xc", "abc", "cv", "np", "desc", "gz", "cur", "tmp", "ct", "etc", "hw", "xs", "pkg", "kl", "fc", "cu", "x", "qt", "resp", "wcs", "ctr", "sc", "ctl", "tc", "nt", "ca", "proc", "kt", "cl", "cf", "xp", "prefix", "kb", "jac", "ann", "cc", "bc", "ka", "co", "warn", "std", "cfg", "cmp", "def", "act", "txt", "cp", "gt", "history", "work", "p", "gc", "cas", "cpu", "push", "wx", "wd", "conn", "cmd", "ind", "mk", "today", "cb", "nc", "anc", "iat"]}}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809, "substitutes": {"view": ["check", "see", "eye", "index", "form", "iew", "widget", "window", "client", "cell", "controller", "query", "html", "task", "model", "virtual", "link", "View", "show", "image", "web", "v", "get", "tv", "service", "manager", "document", "watch", "field", "version", "views", "print", "package", "block", "layout", "row", "blade", "display", "VIEW", "file"]}}
{"project": "FFmpeg", "commit_id": "2162b862eba5aadb59c0cf7cc304c67f4a5fb946", "target": 1, "func": "static int huff_build10(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[1024];\n\n    uint32_t codes[1024];\n\n    uint8_t bits[1024];\n\n    uint16_t syms[1024];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        he[i].sym = 1023 - i;\n\n        he[i].len = len[i];\n\n\n\n    }\n\n    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);\n\n\n\n    code = 1;\n\n    for (i = 1023; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}", "idx": 19827, "substitutes": {"vlc": ["wlc", "VLsc", "vrcs", "vrp", "vlp", "tlp", "volca", "vlca", "tlc", "vlsc", "vllc", "vpc", "volcs", "vrc", "vrlc", "vrl", "VLc", "volc", "wlp", "tllc", "tll", "volsc", "vll", "wlcs", "vlcs", "VLcs", "wllc", "vpl", "tlcs", "wlca", "VLca", "vpp", "wlsc", "vplc"], "len": ["mem", "pos", "lp", "fn", "l", "el", "nt", "size", "lon", "els", "hi", "num", "en", "list", "ll", "ml", "enc", "li", "le", "sym", "syn", "vec", "wid", "dl", "il", "link", "length", "wl", "fin", "ln", "lvl", "nn", "bl", "priv", "nl", "id", "ind", "lit", "den", "rel", "ref", "von", "val", "kl", "cmp", "ell", "cod", "lan", "del", "lo", "low", "lim", "ls", "pl", "ld", "resp", "lis", "Len", "spec", "sl", "tl", "elt", "seq", "pen", "hl"], "he": [" ge", "mem", "hs", "yi", "na", "see", "ue", "hu", "hen", "hi", " we", "He", "HE", "wen", "en", "me", "we", "h", "aste", "ha", "phe", " fe", "het", "le", "ke", "ae", "fle", "e", "ape", "te", "ja", "hy", "ense", "ale", "her", "co", "ma", "wa", "se", "ve", "ile", "vre", " pe", " h", "ye", "hene", "ithe", "cal", "she", "hem", "ce", "che", "hes", "cu", "sche", "xe", "cache", "pse", "spe", "rh", "pe", "hal", " ha", " ke", "gre"], "codes": ["cs", "blocks", "outs", "scripts", "ones", "flags", "classes", "terms", "coded", "cards", "cases", "pieces", "lines", "frames", "boards", "cons", "checks", "bs", "chains", "odes", "files", "values", "coins", "cells", "bytes", "cd", "keys", "ices", "xs", "types", "rices", "phones", "maps", "headers", "obs", "rooms", "errors", "cod", "ints", "cache", "images", "zi", "tests", "icons", "ms", "names", "cats", "items", "modules", "fits", "its", "rates"], "bits": ["utils", "cs", "ops", "blocks", "bool", "outs", "units", "size", "flags", "bles", "classes", "bars", "ins", "ubs", "cases", "pieces", "lines", "frames", "is", "checks", "bs", "bps", "uts", "vals", "pins", "gs", "rs", "jobs", "rots", "values", "ports", "ns", "bytes", "vs", "keys", "ps", "bit", "xs", "bis", "issues", "ats", "phones", "rows", "maps", "obs", "cod", "ints", "bi", "locks", "parts", "s", "ads", "orts", "ms", "ris", "heads", "b", "items", "cats", "fits", "its"], "syms": ["symns", "sysma", "synmn", " symes", "sysmes", "Syms", "synps", " syvs", "sysms", "tyfs", "thefs", "symcs", "tymes", "synmb", "syvs", "syma", "tyvs", "thems", " syfs", "asymes", "schens", "Syls", "asyma", "asyms", "schems", "tymb", "symn", "tyls", "sysps", "synmes", " syps", "syfs", "chemb", "Symes", "thens", "synma", "symms", "schecs", "asyps", "symb", "syns", "Syfs", "tymn", "chevs", "synms", "typs", "schefs", "synvs", "symes", "Syps", "symfs", "sycs", "Syvs", "syps", "syls", "tyms", " syls", "chems", "thecs", "chemn"], "code": ["next", "check", "offset", "rice", "index", "ue", "error", "b", "use", "size", "ci", "comment", "component", "close", "result", "test", "err", "xxx", "zero", "pc", "change", "ice", "count", "action", "le", "e", "lock", "cycle", "u", "command", "length", "reason", "name", "ch", "force", "co", "out", "coe", "value", "bit", "data", "c", "Code", "try", "message", "ode", "cod", "key", "ce", "cache", "ack", "x", "be", "xc", "entry", "rc", "go", "buffer", "ie", "create", "byte", "mode", "type"], "i": ["iso", "z", "hi", "ir", "li", "ri", "g", "point", "I", "ai", "ori", "di", "esi", "mi", "ji", "asi", "chain", "ex", "multi", "ii", "index", "ij", "t", "ci", "list", "\u0438", "phi", "ity", "v", "io", "cli", "you", "pi", "parent", "gi", "o", "fi", "bi", "x", "zi", "ini", "it", "iu", "status", "PI", "init", "ic", "ei", "qi", " ti", "me", " Xi", " ii", "iq", "all", "ip", "to", " j", "j", "ti", "print", " I", "ami", "uri", "info", " bi", "ix", "y", "m", "si", "im", "p", "client", "isi", "is", "oi", "ind", "in", "id", "xi", "ui", "iy", "ims", " m", "sim", "us"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n", "idx": 19834, "substitutes": {"task": ["next", "asks", "work", "form", "nt", "t", "ask", "game", "total", "tx", "proc", "result", "test", "ran", "util", "course", "setup", "associated", "map", "run", "command", "node", "link", "session", "thread", "object", "that", "data", "cmd", "target", "bolt", "func", "msg", "master", "dev", "trans", "new", "table", "job", "unt", "def", "piece", "ack", "tg", "net", "rake", "it", "think", "Task", "worker", "process"], "obj": ["pos", "Object", "os", "Ob", "arr", "nt", "ok", "t", "oc", "proc", "bh", "xy", "ctx", "og", "oss", "rt", "ob", "op", "tmp", "rs", "onet", "ot", "ct", "out", "bj", "db", "attr", "self", "object", "sys", "js", "addr", "ex", "data", "cmd", "typ", "ind", "ext", "id", "j", "inst", "ref", "obb", "Obj", "oid", "tk", "obs", "str", "o", "act", "cod", "rb", "orig", "txt", "it", "org", "od", "err"], "src": ["sc", "ds", "loc", "fn", "rol", "sb", "sup", "st", "sq", "th", "err", "ctx", "rt", "bs", "syn", "rs", "gs", "tmp", "bc", "sec", "bj", "SOURCE", "ptr", "iv", "addr", "sn", "sys", "via", "data", "target", "rel", "inst", "ref", "sync", "str", "usr", "source", "txt", "sr", "s", "rc", "vr", "scan", "sur", "url", "sl", "dest", "ser", "rl"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    ByteIOContext *bc = &s->pb;\n\n    int64_t pos;\n\n    int inited_stream_count;\n\n\n\n    nut->avf= s;\n\n    \n\n    av_set_pts_info(s, 60, 1, AV_TIME_BASE);\n\n\n\n    /* main header */\n\n    pos=0;\n\n    for(;;){\n\n        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"no main startcode found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_main_header(nut) >= 0)\n\n            break;\n\n    }\n\n    \n\n    \n\n    s->bit_rate = 0;\n\n\n\n    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);\n\n\n\n    /* stream headers */\n\n    pos=0;\n\n    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){\n\n        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"not all stream headers found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_stream_header(nut) >= 0)\n\n            inited_stream_count++;\n\n    }\n\n\n\n    /* info headers */\n\n    pos=0;\n\n    for(;;){\n\n        uint64_t startcode= find_any_startcode(bc, pos);\n\n        pos= url_ftell(bc);\n\n\n\n        if(startcode==0){\n\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n\n            return -1;\n\n        }else if(startcode == KEYFRAME_STARTCODE){\n\n            url_fseek(bc, -8, SEEK_CUR); //FIXME\n\n            break;\n\n        }else if(startcode != INFO_STARTCODE){\n\n            continue;\n\n        }\n\n\n\n        decode_info_header(nut);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19886, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "san", "t", "i", "csv", "p", "sb", "sp", "ses", "ins", "als", "sq", "aws", "h", "sm", "ar", "set", "qs", "is", "bs", "g", "south", "sv", "rs", "gs", "sa", "S", "ss", "aus", "sw", "ns", "sts", "v", "vs", "tools", "ps", "sys", "sn", "js", "sports", "c", "ants", "j", "es", "ats", "r", "comm", "n", "o", "fs", "acs", "uns", "state", "ts", "ims", "ls", "an", "stats", "ms", "sc", "b", "y", "its"], "ap": [" map", "cap", " ip", " op", "pp", "amp", "sp", " mp", "tap", "bp", "op", "tp", " par", "Ap", " pars", " p", "aps", "ip", "ps", "mp", "att", " cp", " sap", " af", " pp", " sp", "ep", "AP"], "nut": ["na", "orb", "cot", "ano", "uts", "ox", "obj", "nor", "iv", "ens", "maker", "art", "Nut", "aos", "net", "critical", "np", "fn", "or", "gob", "kat", "six", "pot", "nv", "tmp", "utt", "torn", "rots", "ot", "nw", "sts", "stab", "nova", "ocr", "hawk", "n", "nas", "ut", "snap", "sam", "nt", "tub", "grain", "capt", "num", "mom", "nuts", "native", "node", "cut", "ore", "orn", "sat", "nm", "nr", "demon", "aunt", "san", "core", "util", "ng", "knife", "ns", "apy", "nat", "feat", "conn", "cmd", "umb", "cens", "rot", "cooked", "piece", "our", "nir", "hog"], "bc": ["snap", "con", "ic", "cs", "tc", "console", "sb", "oc", "bb", "proc", "mc", "ec", "ml", "ctx", "bp", "bo", "unc", "pc", "gc", "bs", "ob", "cl", "exc", "bec", "vc", "bg", "jac", "cc", "clus", "conv", "db", "sec", "pb", "soc", "BC", "sys", "asc", "uc", "c", "comm", "um", "gru", "arb", "cmp", "lc", "cm", "dc", "cond", "kl", "bf", "lic", "fc", "ib", "cb", "nc", "ba", "rc", "broad", "arc", "sc", "b", "bus", "bitcoin"], "pos": ["offset", "Pos", "ds", "index", "snap", "os", "loc", "l", "size", "nos", "pr", "p", "slot", "sp", "client", "proc", "at", "oss", "port", "pid", "on", "base", "pc", "bs", "pres", "point", "op", "tmp", "prop", "length", "position", "off", "pro", "limit", "pointer", "doc", "push", "add", "ps", "POS", "apo", "pi", "pt", "to", "rot", "j", "ref", "body", "origin", "neg", "def", "cond", "pat", "top", "Position", "x", "pl", "pose", "len", "go", "resp", "no", "comp", "spec", "po", "conf", "prot"], "inited_stream_count": ["inited_streaminglength", "inited_stream_counter", "inited_field_count", "inited_form_Count", "inited_window_count", "inited_form_counter", "inited_streamingct", "inited_form_cache", "inited_field_Count", "inited_stream_length", "inited_window_ct", "inited_stack_call", "inited_window_Count", "inited_stream_call", "inited_streamingCount", "inited_stream_ct", "inited_field_length", "inited_form_count", "inited_stream_Count", "inited_stack_count", "inited_window_length", "inited_stream_cache", "inited_stack_Count", "inited_streamingcount"]}}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)\n\n{\n\n    int ret;\n\n\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"reinit context\\n\");\n\n\n\n    /* 1. streamoff */\n\n    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);\n\n    if (ret)\n\n        av_log(s->avctx, AV_LOG_ERROR, \"capture VIDIOC_STREAMOFF\\n\");\n\n\n\n    /* 2. unmap the capture buffers (v4l2 and ffmpeg):\n\n     *    we must wait for all references to be released before being allowed\n\n     *    to queue new buffers.\n\n     */\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"waiting for user to release AVBufferRefs\\n\");\n\n    if (atomic_load(&s->refcount))\n\n        while(sem_wait(&s->refsync) == -1 && errno == EINTR);\n\n\n\n    ff_v4l2_context_release(&s->capture);\n\n\n\n    /* 3. get the new capture format */\n\n    ret = ff_v4l2_context_get_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"query the new capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 4. set the capture format */\n\n    ret = ff_v4l2_context_set_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"setting capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 5. complete reinit */\n\n    sem_destroy(&s->refsync);\n\n    sem_init(&s->refsync, 0, 0);\n\n    s->draining = 0;\n\n    s->reinit = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 19889, "substitutes": {"s": ["services", "ies", "utils", "hs", "ds", "cs", "os", "ops", "args", "i", "sb", "events", "details", "ses", "ins", "als", "sq", "changes", "aws", "ers", "store", "h", "qs", "is", "bs", "g", "south", "sv", "rs", "gs", "S", "ss", "aus", "sw", "ns", "sts", "v", "vs", "ties", "self", "obj", "ps", "sys", "js", "spec", "ants", "tes", "j", "es", "ats", "comm", "n", "fs", "ags", "acs", "ts", "ims", "ls", "ains", "params", "stats", "ms", "serv", "states", "b", "has", "conf", "its", "m"], "ret": ["back", "details", "dt", "hash", "rt", "iter", "get", "cat", "jp", "del", "ert", "cert", "net", "not", "rets", "t", "flag", "result", "ry", "vet", "ber", "v", "RET", "reset", "re", "complete", "usr", "len", "resp", "f", "it", "fun", "elt", "rm", "res", "nt", "pret", "grain", "ter", "Ret", "ben", "il", "tr", "mt", "reg", "lt", "backed", "ft", " Ret", "det", "att", "sat", "j", "def", "str", "print", "alt", "got", "txt", "gt", " alt", "deg", "ll", "out", "fin", "cont", "value", "rem", "rev", "cmd", "ext", "val", "red"]}}
{"project": "FFmpeg", "commit_id": "e3123856c79c36507772ada1bcda6cfe36a1e297", "target": 1, "func": "static int wsvqa_read_header(AVFormatContext *s,\n\n                             AVFormatParameters *ap)\n\n{\n\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char *header;\n\n    unsigned char scratch[VQA_PREAMBLE_SIZE];\n\n    unsigned int chunk_tag;\n\n    unsigned int chunk_size;\n\n\n\n    /* initialize the video decoder stream */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n    wsvqa->video_stream_index = st->index;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_WS_VQA;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n\n\n    /* skip to the start of the VQA header */\n\n    avio_seek(pb, 20, SEEK_SET);\n\n\n\n    /* the VQA header needs to go to the decoder */\n\n    st->codec->extradata_size = VQA_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    header = (unsigned char *)st->codec->extradata;\n\n    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=\n\n        VQA_HEADER_SIZE) {\n\n        av_free(st->codec->extradata);\n\n        return AVERROR(EIO);\n\n    }\n\n    st->codec->width = AV_RL16(&header[6]);\n\n    st->codec->height = AV_RL16(&header[8]);\n\n\n\n    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */\n\n    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        if (AV_RL16(&header[0]) == 1)\n\n            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;\n\n        else\n\n            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->sample_rate = AV_RL16(&header[24]);\n\n        if (!st->codec->sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n", "idx": 19892, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "scl", "sl", "t", "sg", "w", "p", "sb", "sp", "as", "ins", "sq", "ses", "ctx", "is", "pc", "bs", "e", "g", "rs", "gs", "S", "ss", "aus", "ns", "sts", "v", "ps", "sys", "sn", "js", "c", "es", "ats", "r", "n", "fs", "ts", "ls", "src", "spec", "sc", "b", "its", "m"], "ap": [" map", "cap", "am", "pp", " mp", "sp", "tap", "bp", "ar", "op", "tp", " par", "pro", "aps", "ps", "mp", "att", " cp", " sap", " af", "pl", " sp", "ep", "pa", " pr", "al", "ac", "AP"], "wsvqa": ["wsvpqua", "wsvgiza", "vssviza", "hwvqua", "vsvaja", "wsvgqa", "wsgovaja", "wsgovqua", "wsvtaja", "wsviza", "wsgovqa", "wsvtqa", "wsvala", "vssvqa", "vssvaja", "wsvvala", "wsvpqa", "vsvqa", "wsvvqa", "hwvvaja", "wsvpaja", "wsvtqua", "wssvaja", "wsvgaja", "vsvqua", "hwvvala", "hwvqa", "hwvvqa", "wsvgqua", "wssviza", "wsvvaja", "wsvtala", "hwvaja", "vsviza", "hwvala", "wsgovala", "wssvqa", "wsvvqua", "vssvqua", "wsvpiza", "wssvqua", "hwvvqua", "wsvaja", "wsvqua"], "pb": ["td", "snap", "lp", "cv", "np", "tc", "dp", "wp", "sb", "p", "pp", "sp", "proc", "bh", "bp", "ctx", "ub", "pid", "pc", "fb", "bs", "ob", "buf", "vp", "pan", "tp", "pg", "mb", "pro", "pm", "typ", "mp", "PB", "pkg", "pt", "erb", "jp", "tk", "iov", "gp", "ib", "rb", "cb", "pl", "pa", "uf", "cp", "fp", "eb", "sc", "b", "lb", "iat"], "st": ["td", "stable", "nt", "form", "sl", "t", "stra", "ist", "sp", "store", "stage", "must", "th", "set", "bo", "end", "chest", "rt", "sum", "cl", "wt", "ste", "mt", "ct", "stat", "step", "sw", "stop", "sts", "St", "start", "so", "sty", "cont", "add", "ft", "ast", "sn", "stack", "sth", "rd", "mont", "pt", "storage", "inst", "put", "std", "et", "ust", "ST", "est", "sta", "art", "str", "usr", "stri", "ent", "ts", "bt", "stru", "irst", "nd", "status", "resp", "rest", "tt", "stan", "src", "sc", "ut", "ost"], "header": ["init", "offset", "check", "frame", "history", "cover", "channel", "server", "window", "flag", "comment", "term", "sample", "rule", "query", "h", "hash", "text", "tar", "layer", "feature", "column", "sum", "padding", "tree", "tr", "writer", "command", "byte", "content", "dr", "head", "iter", "peer", "magic", "spec", "data", "cmd", "body", "master", "field", "tag", "Header", "headers", "table", "key", "er", "source", "cache", "metadata", "HEAD", "border", "tail", "block", "meta", "len", "heading", "ver", "buffer", "filter", "player", "part", "title", "version", "event", "file", "drm", "type"], "scratch": [" Scratch", "SCratch", "screenshot", "SCreenshot", " Screenshot", "Scratch", "Scatter", "SCattered", " Scatter", "Screenshot", "scattered", " Scattered", "SCatter", "scatter", "Scattered"], "chunk_tag": ["chunkstag", "chunks_count", "chunk_number", "chunkssize", "chunks_tag", "chunksnumber", "chunks_size", "chunk_count", "chunks_number", "chunkscount"], "chunk_size": ["chunk2length", "chunk2size", "chunk_length", "chunk_name", "chump_name", "chump_size", "chump_length", "chunk2name"]}}
{"project": "FFmpeg", "commit_id": "984add64a41c3296a8a82051cc90bff2eb449609", "target": 1, "func": "int ff_wma_init(AVCodecContext *avctx, int flags2)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i;\n\n    float bps1, high_freq;\n\n    volatile float bps;\n\n    int sample_rate1;\n\n    int coef_vlc_table;\n\n\n\n    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000\n\n        || avctx->channels    <= 0 || avctx->channels    > 2\n\n        || avctx->bit_rate    <= 0)\n\n        return -1;\n\n\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n\n        s->version = 1;\n\n    } else {\n\n        s->version = 2;\n\n\n\n\n    /* compute MDCT block size */\n\n    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,\n\n                                                  s->version, 0);\n\n    s->next_block_len_bits = s->frame_len_bits;\n\n    s->prev_block_len_bits = s->frame_len_bits;\n\n    s->block_len_bits      = s->frame_len_bits;\n\n\n\n    s->frame_len = 1 << s->frame_len_bits;\n\n    if (s->use_variable_block_len) {\n\n        int nb_max, nb;\n\n        nb = ((flags2 >> 3) & 3) + 1;\n\n        if ((avctx->bit_rate / avctx->channels) >= 32000)\n\n            nb += 2;\n\n        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;\n\n        if (nb > nb_max)\n\n            nb = nb_max;\n\n        s->nb_block_sizes = nb + 1;\n\n    } else {\n\n        s->nb_block_sizes = 1;\n\n\n\n\n    /* init rate dependent parameters */\n\n    s->use_noise_coding = 1;\n\n    high_freq = avctx->sample_rate * 0.5;\n\n\n\n    /* if version 2, then the rates are normalized */\n\n    sample_rate1 = avctx->sample_rate;\n\n    if (s->version == 2) {\n\n        if (sample_rate1 >= 44100) {\n\n            sample_rate1 = 44100;\n\n        } else if (sample_rate1 >= 22050) {\n\n            sample_rate1 = 22050;\n\n        } else if (sample_rate1 >= 16000) {\n\n            sample_rate1 = 16000;\n\n        } else if (sample_rate1 >= 11025) {\n\n            sample_rate1 = 11025;\n\n        } else if (sample_rate1 >= 8000) {\n\n            sample_rate1 = 8000;\n\n\n\n\n\n    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);\n\n    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;\n\n\n\n\n\n\n\n    /* compute high frequency value and choose if noise coding should\n\n       be activated */\n\n    bps1 = bps;\n\n    if (avctx->channels == 2)\n\n        bps1 = bps * 1.6;\n\n    if (sample_rate1 == 44100) {\n\n        if (bps1 >= 0.61) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.4;\n\n\n    } else if (sample_rate1 == 22050) {\n\n        if (bps1 >= 1.16) {\n\n            s->use_noise_coding = 0;\n\n        } else if (bps1 >= 0.72) {\n\n            high_freq = high_freq * 0.7;\n\n        } else {\n\n            high_freq = high_freq * 0.6;\n\n\n    } else if (sample_rate1 == 16000) {\n\n        if (bps > 0.5) {\n\n            high_freq = high_freq * 0.5;\n\n        } else {\n\n            high_freq = high_freq * 0.3;\n\n\n    } else if (sample_rate1 == 11025) {\n\n        high_freq = high_freq * 0.7;\n\n    } else if (sample_rate1 == 8000) {\n\n        if (bps <= 0.625) {\n\n            high_freq = high_freq * 0.5;\n\n        } else if (bps > 0.75) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.65;\n\n\n    } else {\n\n        if (bps >= 0.8) {\n\n            high_freq = high_freq * 0.75;\n\n        } else if (bps >= 0.6) {\n\n            high_freq = high_freq * 0.6;\n\n        } else {\n\n            high_freq = high_freq * 0.5;\n\n\n\n    av_dlog(s->avctx, \"flags2=0x%x\\n\", flags2);\n\n    av_dlog(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",\n\n            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,\n\n            avctx->block_align);\n\n    av_dlog(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",\n\n            bps, bps1, high_freq, s->byte_offset_bits);\n\n    av_dlog(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",\n\n            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);\n\n\n\n    /* compute the scale factor band sizes for each MDCT block size */\n\n    {\n\n        int a, b, pos, lpos, k, block_len, i, j, n;\n\n        const uint8_t *table;\n\n\n\n        if (s->version == 1) {\n\n            s->coefs_start = 3;\n\n        } else {\n\n            s->coefs_start = 0;\n\n\n        for (k = 0; k < s->nb_block_sizes; k++) {\n\n            block_len = s->frame_len >> k;\n\n\n\n            if (s->version == 1) {\n\n                lpos = 0;\n\n                for (i = 0; i < 25; i++) {\n\n                    a = ff_wma_critical_freqs[i];\n\n                    b = avctx->sample_rate;\n\n                    pos = ((block_len * 2 * a) + (b >> 1)) / b;\n\n                    if (pos > block_len)\n\n                        pos = block_len;\n\n                    s->exponent_bands[0][i] = pos - lpos;\n\n                    if (pos >= block_len) {\n\n                        i++;\n\n                        break;\n\n\n                    lpos = pos;\n\n\n                s->exponent_sizes[0] = i;\n\n            } else {\n\n                /* hardcoded tables */\n\n                table = NULL;\n\n                a = s->frame_len_bits - BLOCK_MIN_BITS - k;\n\n                if (a < 3) {\n\n                    if (avctx->sample_rate >= 44100) {\n\n                        table = exponent_band_44100[a];\n\n                    } else if (avctx->sample_rate >= 32000) {\n\n                        table = exponent_band_32000[a];\n\n                    } else if (avctx->sample_rate >= 22050) {\n\n                        table = exponent_band_22050[a];\n\n\n\n                if (table) {\n\n                    n = *table++;\n\n                    for (i = 0; i < n; i++)\n\n                        s->exponent_bands[k][i] = table[i];\n\n                    s->exponent_sizes[k] = n;\n\n                } else {\n\n                    j = 0;\n\n                    lpos = 0;\n\n                    for (i = 0; i < 25; i++) {\n\n                        a = ff_wma_critical_freqs[i];\n\n                        b = avctx->sample_rate;\n\n                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);\n\n                        pos <<= 2;\n\n                        if (pos > block_len)\n\n                            pos = block_len;\n\n                        if (pos > lpos)\n\n                            s->exponent_bands[k][j++] = pos - lpos;\n\n                        if (pos >= block_len)\n\n                            break;\n\n                        lpos = pos;\n\n\n                    s->exponent_sizes[k] = j;\n\n\n\n\n\n            /* max number of coefs */\n\n            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;\n\n            /* high freq computation */\n\n            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /\n\n                                          avctx->sample_rate + 0.5);\n\n            n = s->exponent_sizes[k];\n\n            j = 0;\n\n            pos = 0;\n\n            for (i = 0; i < n; i++) {\n\n                int start, end;\n\n                start = pos;\n\n                pos += s->exponent_bands[k][i];\n\n                end = pos;\n\n                if (start < s->high_band_start[k])\n\n                    start = s->high_band_start[k];\n\n                if (end > s->coefs_end[k])\n\n                    end = s->coefs_end[k];\n\n                if (end > start)\n\n                    s->exponent_high_bands[k][j++] = end - start;\n\n\n            s->exponent_high_sizes[k] = j;\n\n#if 0\n\n            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",\n\n                    s->frame_len >> k,\n\n                    s->coefs_end[k],\n\n                    s->high_band_start[k],\n\n                    s->exponent_high_sizes[k]);\n\n            for (j = 0; j < s->exponent_high_sizes[k]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n#endif\n\n\n\n\n\n#ifdef TRACE\n\n    {\n\n        int i, j;\n\n        for (i = 0; i < s->nb_block_sizes; i++) {\n\n            tprintf(s->avctx, \"%5d: n=%2d:\",\n\n                    s->frame_len >> i,\n\n                    s->exponent_sizes[i]);\n\n            for (j = 0; j < s->exponent_sizes[i]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n\n\n#endif\n\n\n\n    /* init MDCT windows : simple sinus window */\n\n    for (i = 0; i < s->nb_block_sizes; i++) {\n\n        ff_init_ff_sine_windows(s->frame_len_bits - i);\n\n        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];\n\n\n\n\n    s->reset_block_lengths = 1;\n\n\n\n    if (s->use_noise_coding) {\n\n\n\n        /* init the noise generator */\n\n        if (s->use_exp_vlc) {\n\n            s->noise_mult = 0.02;\n\n        } else {\n\n            s->noise_mult = 0.04;\n\n\n\n\n#ifdef TRACE\n\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n\n            s->noise_table[i] = 1.0 * s->noise_mult;\n\n#else\n\n        {\n\n            unsigned int seed;\n\n            float norm;\n\n            seed = 1;\n\n            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n\n                seed = seed * 314159 + 1;\n\n                s->noise_table[i] = (float)((int)seed) * norm;\n\n\n\n#endif\n\n\n\n\n    /* choose the VLC tables for the coefficients */\n\n    coef_vlc_table = 2;\n\n    if (avctx->sample_rate >= 32000) {\n\n        if (bps1 < 0.72) {\n\n            coef_vlc_table = 0;\n\n        } else if (bps1 < 1.16) {\n\n            coef_vlc_table = 1;\n\n\n\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n\n                  s->coef_vlcs[0]);\n\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n\n                  s->coef_vlcs[1]);\n\n\n\n    return 0;\n", "idx": 19908, "substitutes": {"avctx": ["avereq", "avctl", "avgc", " avcontext", "aveconn", "avobj", "wavctx", " avcmd", "avconn", "averconfig", " avcb", " avctl", "afkt", "navconn", "avjac", "avercp", " avconfig", "afctx", "vrtx", "afcv", "avpkg", "wavcontext", "ajcmp", "vercontext", "averaddr", "avercfg", "avekl", "avcmd", " avjac", "avetx", "ajconn", "avecontext", "ajcmd", "avcu", "avercmd", "wavconn", "wavaddr", "avertx", "navjac", "avercv", "avconfig", "avepkg", "aveobj", " avtx", " avhandle", " avkt", "averkl", "avecp", " avreq", "wavcp", "avecb", "avcp", "avcb", "avekt", "avehandle", "averconn", "averhandle", "avercontext", "vrcontext", "aftx", "navgc", "ajconfig", "verctx", "wavgc", "avergc", " avcv", "avcv", " avcfg", "wavkl", " avgc", "vrcb", "avegc", "avkl", "wavconf", "avcontext", "avectl", "avcfg", "aveaddr", "averreq", "ajcontext", "vertx", "aveconfig", "avectx", "avejac", "vercfg", "ajcu", " avcmp", "avecu", "afcontext", "ajgc", "avkt", "abctl", "averconf", "avreq", " avconf", "avecfg", "avercu", "wavpkg", " avobj", "abtx", "afcmp", "avcmp", "wavcfg", "ajctx", "avhandle", " avconn", "avconf", " avpkg", "averctx", "wavtx", "abcontext", "vrctx", " avcu", "navctx", "avtx", "abctx", "avercmp", "avaddr", "averobj"], "flags2": ["flag02", "flags4", "Flags0", "flags1", "Flags02", "flags3", "flag2", "ags3", "ags1", " flags1", "ags0", "options1", " flags0", "Flags4", "Flags2", "options02", "flag4", "flag1", "ags2", " flags3", "options2", "flags02", "options4", "Flags3", "Flags1", "flags0"], "s": ["z", "scripts", "details", "results", "g", "rs", "vs", "self", "se", "sys", "es", "comm", "sync", "fs", "ex", "spec", "os", "ops", "sm", "set", "qs", "S", "ss", "so", "sts", "ps", "sn", "https", "ts", "ls", "stats", "bis", "comments", "services", "ds", "cs", "l", "terms", "sb", "ses", "changes", "als", "ar", "sv", "sw", "js", "ssl", "states", "y", "m", "utils", "hs", "ins", "sq", "aws", "h", "is", "bs", "gs", "ports", "ns", "sports", "sd", "pers", "ats", "eps", "less", "ags", "ims", "ms", "its"], "i": ["si", "l", "t", "ci", "p", "ki", "li", "ati", "e", "I", "phi", "m", "v", "io", "ip", "mi", "pi", "c", "ti", "fi", "multi", "bi", " bi", "iu", "ii", "iat"], "bps1": ["bits1", " rates1", "bps2", "bps0", "rates0", " rates2", " rates0", "bits2", "rates1", "bits0", "rates2"], "high_freq": ["high_FreQ", "high_freeqs", "high_frereq", "high_Freqs", "high_preqs", "high_preq", "high_Freck", "high_freck", "high_freQ", "high_preck", "high_Frereq", "high_freeq", "high_Freq", "high_freereq", "high_freqs", "high_preQ"], "bps": ["fps", "ops", "bits", "p", "pps", "bp", "bs", "vals", "points", "ips", "amps", "ns", "bytes", "pb", "aps", "ps", "gb", "steps", "maps", "eps", "ls", "abytes", "params", "stats", "bis", "rates"], "sample_rate1": ["sample_delayU", "sample_delay2", "sample_rates101", "sample_delay0", "sample_rate101", "sample_iterator100", "sample_rangeU", "sample_time2", "sample_ratesU", "sample_rates2", "sample_range2", "sample_rat100", "sample67rat101", "sample_delay1", "sample_rate100", "sample_iterator2", "sample_index1", "sample67rat1", "sample_rates3", "sample_rates0", "sample_rate2", "sample_time1", "sample_rat101", "sample_index100", "sample_rate01", "sample_rates1", "sample_time01", "sample67rat2", "sample_rate0", "sample67rate1", "sample_range100", "sample67rate2", "sample_rat1", "sample_time3", "sample_range0", "sample67rate101", "sample_index0", "sample_iterator101", "sample67rate100", "sample_rat2", "sample67rat100", "sample_index2", "sample_rates100", "sample_rates01", "sample_iterator1", "sample_range1", "sample_rateU", "sample_rate3"], "coef_vlc_table": ["coef_vlc_size", "coef_vlac_db", "coef_vlc_db", "coef_vlac_size", "coef_vlc_data", "coef_vlc2size", "coef_vlc2db", "coef_vlac_data", "coef_vlc2data", "coef_vlc2table", "coef_vlac_table"], "nb_max": ["nblmax", "nb67min", "cb_med", "ni_box", "NB2top", "binarymyexp", "nb_min", "nb67top", "ni_range", "NB_min", "binary_final", "nblbox", "NB2major", "binarymymod", "nb7max", "nb67major", "ni_max", "nb_major", "binary_exp", "nb_range", "nbmyfinal", "nb_top", "binarymymax", "nbPfinal", "nb_exp", "nb2top", "nbmyexp", "nblmaximum", "nb2max", "nb2major", "cb_max", "cb_MAX", "nbmymod", "nb_MAX", "cb_min", "nb_final", "nblrange", "nbPmod", "binarymyfinal", "NB_major", "nbPmax", "nb2min", "NB2max", "NB_top", "binary_mod", "binary_max", "nbPexp", "nb_med", "nb67max", "NB_max", "NB2min", "ni_maximum", "nb_mod", "nb7MAX", "nbmymax", "nb7min", "nb7med", "nb_box", "nb_maximum"], "nb": [" nu", "nom", "np", "nt", "nob", "bits", "oat", "sb", "bb", "num", "aff", "cn", "ne", "zb", "nv", "bs", "ob", "count", "uj", "ni", "NB", "kb", "usb", "tn", "nz", "iq", "db", "bj", "ns", "cli", "gov", "pb", "wb", "nn", "obj", "conn", "gb", "nu", "cmd", "try", "body", "note", "NR", "batch", "mk", "obb", "number", "rb", "ib", "bi", " numb", "nm", "cb", "nc", " neb", "fine", "nd", "nr", "eb", "buff", "qq", "phys", "bn"]}}
{"project": "FFmpeg", "commit_id": "12dea8a5a15343e9c404376c40ca8a1cc9d1479e", "target": 1, "func": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n{\n    IVI45DecContext *ctx = avctx->priv_data;\n    ivi_free_buffers(&ctx->planes[0]);\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n    av_frame_free(&ctx->p_frame);\n    return 0;\n}", "idx": 19912, "substitutes": {"avctx": ["Avtx", "AVctx", "vcontext", "vtx", " avcontext", "awcontext", "Avcmd", " avcmd", "Avcontext", "AVcontext", "vcmd", "avcontext", "avcmp", " avtx", "Avctx", "awcmp", "AVcmp", "awctx", "AVtx", "awtx", "avtx", " avcmp", "avcmd", "vctx"], "ctx": ["td", "ctl", "check", "cv", "index", "history", "loc", "np", "tc", "nt", "ca", "tz", "window", "ck", "tx", "desc", "ork", "kt", "gc", "cl", "crit", "cf", "xp", "kb", "prefix", "jac", "ka", "ct", "cc", "ann", "kw", "hw", "obj", "conn", "req", "cmd", "pkg", "jp", "context", "ctrl", "cmp", "cfg", "cm", "def", "lc", "act", "aux", "txt", "cb", "nc", "qt", "xc", "resp", "cp", "ia", "wcs", "ctr", "conf", "iat"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n", "idx": 19916, "substitutes": {"nd": ["td", "ds", "np", "nt", "fd", "ord", "odd", "ck", "bb", "dk", "md", "lf", "decl", "ne", "ND", "nv", "ined", "pard", "hd", "ng", "rend", "bd", "d", "ns", "ln", "cd", "news", "nn", "sd", "nb", "rd", "cmd", "det", "ind", "und", "inst", "xd", "pd", "std", "isd", "n", "wn", "hn", "ent", "gd", "nc", "ld", "rn", "nda", "wind", "rest", "buff", "od", "vd", "dd", "dn"], "models": ["ies", "mem", "fits", "mes", "projects", "boxes", "mys", "groups", "bots", "els", "classes", "limits", "mins", "settings", "members", "ages", "fixes", "lines", "versions", "apps", "qs", "chains", "users", "ians", "eas", "model", "los", "pins", "gs", "files", "pages", "values", "lists", "jobs", "relations", "fit", "guards", "flows", "mas", "xs", "types", " Models", "videos", "es", "gets", "ids", "codes", "maps", "headers", "views", "hips", "mails", "obs", "lim", "ls", "ims", "images", "mods", "links", "params", "devices", "forms", "ms", "names", "sql", "states", "suits", "items", "modules", "seconds", "reports"], "default_model": ["Default_data", "default_models", "Default_Model", "default___models", "default_name", "default___name", "default___model", "Default_model", "default_label", "default___data", "Default_label", "Default_name", "default_data", "default___label", "default___Model", "default_Model", "Default_models"], "i": ["iso", "hi", "ski", "li", "ri", "g", "point", "I", "ai", "di", "iter", "mi", "c", "jp", "ji", "gu", "chain", "multi", "ii", "index", "ij", "ci", "list", "\u0438", "phi", "cli", "io", "pi", "my", "uni", "gi", "n", "fi", "bi", "x", "zi", "ini", "f", "it", "iu", "status", " c", "ic", "cgi", "ei", "qi", " ti", "me", " ii", "iq", " mi", "ip", "to", " j", "j", "ti", " ki", "ami", "uri", " si", "go", " bi", "ix", "y", "m", "si", "im", "p", "client", "ki", "remote", " pi", "is", " wi", "oi", "ind", "in", "id", "xi", "ui", "key", "ims", " ni", " m", "sim", "ms"]}}
{"project": "qemu", "commit_id": "8103b4d161d7c00ea3ff89ffe66bb2bc2c67de5d", "target": 0, "func": "static void virtio_s390_notify(void *opaque, uint16_t vector)\n\n{\n\n    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;\n\n    uint64_t token = s390_virtio_device_vq_token(dev, vector);\n\n\n\n    /* XXX kvm dependency! */\n\n    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);\n\n}\n", "idx": 19927, "substitutes": {"opaque": ["opposter", "oppca", "oplay", " oplay", "oposter", " opacle", "opaques", " opaques", "oplca", "pacle", "ropacle", "oploster", "oplaque", "ropula", "opula", " opca", "ropaques", "oppaque", " oposter", " opula", "opacle", "opllay", "paque", "opca", "paques", "ropaque", "pula", "opplay"], "vector": [" sensor", "seed", "inventory", "translation", "ctors", "Vector", "term", " matrix", " vectors", "zero", "normal", "vec", "padding", "command", "password", "v", " vec", "serial", "clock", "value", "response", " Vector", "description", "document", " keyword", "random", "product", "template", "message", "NV", "transform", "hello", "number", "sequence", "token", " v", "gradient", "phrase", "buffer", "series", "spec", "version", "ser", "counter", "material"], "dev": ["mem", " device", "nt", "w", "de", "pad", "Dev", "var", "proc", " vo", "van", "md", "app", "end", "cand", "device", "av", "DEV", "cam", "tr", "des", "ad", "d", " devs", "v", "ptr", "sys", "conn", "spec", "cmd", "det", "ind", "ev", "val", "local", "def", "develop", "vo", "ver", "dem", "serv"]}}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "func": "static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)\n\n{\n\n    if (throttle_conflicting(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (!throttle_is_valid(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (throttle_max_is_missing_limit(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 19962, "substitutes": {"cfg": ["init", "nom", "cgi", "deg", "desc", "adj", "og", "gz", "cand", "compl", "eas", "config", "cf", "oga", "gs", "bg", "ctr", "alg", "gov", "fg", "cli", "etc", "ns", "gran", "gb", "cmd", "priv", "ext", "gg", "comm", "forge", "fig", "def", "mg", "gp", "orig", "cb", "qt", "qa", "org", "eg", "urg", "gt", "exec", "nav", "conf"], "errp": [" errr", "erpress", " erp", "errpress", "errpb", " errpp", " erpkg", "ferpb", " errpkg", "ferp", "erpb", "erp", "verpp", "errr", "rrp", "errpkg", "errpp", "erpp", "rrpress", "verp", "verr", "rrpb", "ferP", " erP", "errP", "erpkg", "rrP", " err", "verP", "ferpress", "erP", " errP", "err"]}}
{"project": "FFmpeg", "commit_id": "101ef19ef4dc9f5c3d536aee8fcc10fff2af4d9e", "target": 1, "func": "static void decode_block(BinkAudioContext *s, short *out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = s->coeffs_ptr[ch];\n\n        if (s->version_b) {\n\n            coeffs[0] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n        } else {\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            /* constant is result of 0.066399999/log10(M_E) */\n\n            int value = get_bits(gb, 8);\n\n            quant[i] = expf(FFMIN(value, 95) * 0.15289164787221953823f) * s->root;\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else if (get_bits1(gb)) {\n\n                j = i + rle_length_tab[get_bits(gb, 4)] * 8;\n\n            } else {\n\n                j = i + 8;\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            width = get_bits(gb, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    coeff = get_bits(gb, width);\n\n                    if (coeff) {\n\n                        if (get_bits1(gb))\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n            s->dsp.vector_fmul_scalar(coeffs, coeffs, s->frame_len / 2, s->frame_len);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    s->fmt_conv.float_to_int16_interleave(out, (const float **)s->coeffs_ptr,\n\n                                          s->frame_len, s->channels);\n\n\n\n    if (!s->first) {\n\n        int count = s->overlap_len * s->channels;\n\n        int shift = av_log2(count);\n\n        for (i = 0; i < count; i++) {\n\n            out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift;\n\n        }\n\n    }\n\n\n\n    memcpy(s->previous, out + s->block_size,\n\n           s->overlap_len * s->channels * sizeof(*out));\n\n\n\n    s->first = 0;\n\n}\n", "idx": 19965, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "ops", "t", "sg", "settings", "sb", "p", "details", "ses", "ins", "als", "sq", "as", "aws", "h", "results", "qs", "is", "span", "bs", "e", "g", "sv", "rs", "gs", "S", "ss", "sw", "sts", "ns", "vs", "se", "ps", "sports", "sys", "js", "spec", "c", "ants", "es", "ats", "r", "comm", "n", "o", "fs", "less", "space", "er", "ts", "ims", "ls", "parts", "ains", "sim", "stats", "f", "ms", "series", "ex", "b", "conf", "its", "m"], "out": ["os", "res", "arr", "outs", "t", "w", "img", "p", "result", "output", "buf", "Out", "tmp", "ot", "conv", "v", "io", "c", "in", "to", "new", "ou", "n", "o", "buffer", "y", "m"], "use_dct": ["use_fct", "use_Duct", "use_dot", "use_sduct", "use_fpt", "use2duct", "use_DCT", "use_dCT", "use_Dot", "use2dpt", "use2Dpt", "use_dpt", "use2dCT", "use_Dct", "use_sdot", "use_duct", "use_fot", "use_sdCT", "use2Dct", "use_Dpt", "use2DCT", "use_fCT", "use2dct", "use2Duct", "use_sdct", "use_fuct"], "ch": ["br", "chart", "cs", "channel", "l", "sch", "z", "ca", "chron", "hl", "sk", "ach", "kh", "sh", "qu", "p", "ich", "th", "h", "Ch", "count", "chip", "ht", "ot", "cht", "CH", "v", "cd", "ih", "chan", "c", "ind", "att", "ble", "height", "batch", "mk", "zh", "cho", "och", "x", "cb", "tch", " Ch", "ech", "cp", "chn", "cha", "code", "sc", "b", "y", "col", "chrom", "ek"], "i": ["z", "hi", "li", "ri", "e", "g", "I", "ai", "length", "di", "mi", "c", "ji", "multi", "ii", "index", "ij", "ci", "\u0438", "phi", "v", "io", "pi", "my", "try", "gi", "n", "o", "bi", "x", "zi", "ini", "f", "it", "ia", "iu", "status", "ic", "l", "w", "ei", "qi", "ik", "ip", "iii", "height", "ti", "um", "ami", "uri", "info", "ie", "ix", "b", "y", "m", "si", "im", "p", "ki", "h", "is", "u", "in", "ind", "id", "xi", "ui", "api"], "j": ["index", "jj", "ij", "z", "l", "si", "w", "p", "dj", "adj", "kj", "h", "ja", "uj", "g", "fr", "J", "jac", "jit", "v", "obj", "jl", "js", "json", "height", "r", "jp", "ji", "n", "o", "aj", "bi", "row", "jump", "f", "it", "jc", "b", "y", "br", "m"], "k": ["km", "index", "z", "ok", "w", "ask", "sk", "ck", "kh", "p", "uk", "ki", "kj", "ks", "ik", "kr", "ke", "kit", "g", "u", "ijk", "ka", "ku", "m", "kw", "v", "kid", "ak", "kind", "kk", "c", "ind", "id", "ark", "ikk", "mk", "kl", "ko", "tk", "isk", "n", "o", "kick", "key", "unk", "K", "b", "y", "ek"], "q": [" query", "ue", "z", "qv", " z", "t", "w", " crit", " sq", "weight", "qu", "p", "pp", "qi", "sq", "ll", "query", "h", " qu", "qs", "qual", "g", "requ", "u", "quality", "m", "iq", "v", "charge", " req", "req", "c", "Q", " qual", "aq", "y", "x", "qa", "qt", "f", "it", "qq", "dq"], "quant": ["patch", "temp", "nice", "debug", "nt", "Quant", "complex", "total", "valid", "qu", "details", "var", "final", "shock", "secure", "finals", "tight", "neutral", "uint", "good", "util", "qual", "count", " Quant", "requ", "press", "pdf", "integer", "windows", "deep", "important", "frac", "mot", "quad", "mont", "percent", "pick", "quart", "specific", "local", "private", "liquid", "quiet", "recent", "mult", "different", "ent", "vol", "stats", "stock", "buff", "quick", "qq", "critical", "material"], "coeff": ["coefficient", "foeff", " coefficient", "loef", "foff", " coef", " coff", "Coef", "loeff", "COefficient", "Coff", " coact", "foef", "COact", "Coeffic", "COff", "Coefficient", "coef", "COeff", "loefficient", "COef", "coff", "foact", "Coeff", "coact", "loeffic", "coeffic", " coeffic"], "gb": ["bm", "td", "cv", "sg", "deg", "phy", "csv", "img", "sb", "bb", "goo", "og", "gif", "rect", "xy", "gz", "html", "fb", "gc", "bs", "ruby", "g", "Gb", "gnu", "gs", "kb", "py", "bg", "GB", "mb", "db", "fg", "pg", "jpg", "io", "pb", "wb", "attr", "sys", "vg", "nb", "hub", "storage", "yg", "gg", "erb", "binary", "cfg", "bf", "rg", "rb", "ib", "gd", "cb", "bt", "tg", "uf", "gh", "gm", "eg", "gt", "eb", "large", "b", "hog"], "coeffs": ["coactts", "coefficrates", "coaffis", " coeffis", "coefficjs", "coffis", "coffjs", "coeffcs", "coefes", "coefids", " coefficients", " coeffjs", "coefts", "coaffcs", " coeffts", "conefficientes", "coneffes", "coefficss", "coffcs", "coefficientts", "coefrates", "coaffsys", "coneffss", "coefficientids", "coefficientsss", " coeffsys", " coff_", "coaffjs", "coff_", " coffs", " coffcs", "coneffs", "coef_", "coeff_", "coeffjs", " coeffrates", "coefficids", " coefficientrates", "coffts", "coeffls", "conefficientss", " coeff_", " coefficientls", "conefficients", "coefficientss", "coefficientrates", "coeffices", " coffjs", "coefjs", "conefficientids", " coefficientis", "coeffids", "coffs", "coacts", "coefs", " coffts", "coffsys", "coneffids", "coefficientjs", "coeffsys", " coefficientjs", "coefficientls", "coaffts", " coeffls", "coactcs", "coefficientsjs", "coefficientes", "coefficients", "coefficients_", "coefficls", "coeffrates", "coneffjs", "conefficientjs", " coeffcs", "coeffss", "coaffs", "coefls", "coeffis", "coactsys", " coffsys", "coeffes", "coeffics", "coffls", "coefficientis", "coefficientses", "coeffts"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_main_loop_start(void)\n\n{\n\n}\n", "idx": 19966, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n\n                                 const uint8_t *buf, int size, int64_t pts)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    AVStream *st = ctx->streams[stream_index];\n\n    StreamInfo *stream = st->priv_data;\n\n    int64_t dts;\n\n    int len;\n\n\n\n    /* XXX: system clock should be computed precisely, especially for\n\n       CBR case. The current mode gives at least something coherent */\n\n    if (stream_index == s->scr_stream_index)\n\n        s->last_scr = pts;\n\n    \n\n#if 0\n\n    printf(\"%d: pts=%0.3f scr=%0.3f\\n\", \n\n           stream_index, pts / 90000.0, s->last_scr / 90000.0);\n\n#endif\n\n    \n\n    /* XXX: currently no way to pass dts, will change soon */\n\n    dts = AV_NOPTS_VALUE;\n\n\n\n    /* we assume here that pts != AV_NOPTS_VALUE */\n\n    if (stream->start_pts == AV_NOPTS_VALUE) {\n\n        stream->start_pts = pts;\n\n        stream->start_dts = dts;\n\n    }\n\n    while (size > 0) {\n\n        len = s->packet_data_max_size - stream->buffer_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n\n        stream->buffer_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        while (stream->buffer_ptr >= s->packet_data_max_size) {\n\n            /* output the packet */\n\n            flush_packet(ctx, stream_index,\n\n                         stream->start_pts, stream->start_dts, s->last_scr);\n\n            /* Make sure only the FIRST pes packet for this frame has\n\n               a timestamp */\n\n            stream->start_pts = AV_NOPTS_VALUE;\n\n            stream->start_dts = AV_NOPTS_VALUE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 19976, "substitutes": {"ctx": ["ctl", "hs", "cv", " cx", "tc", "np", "ca", "ck", "kh", "tx", "p", "mc", "cn", "bh", "kt", "gc", "setup", "cam", "cf", "tmp", "ct", "cc", "bc", "kw", "aus", "conv", "etc", "ns", "hw", "cont", "wx", "addr", "js", "conn", "req", "c", "pkg", "ind", "cmd", "xs", "jp", "comm", "mk", "context", "cfg", "cmp", "cm", "dc", "act", "cu", "x", "cb", "nc", "anc", "Context", "xc", "params", "cp", "sc", "iat"], "stream_index": ["server_ind", "stream_handle", "stream_Index", "stream_location", "stream_num", " stream_Index", " stream_number", "stream_slice", "stream_ticket", "server_handle", "stream_ind", " stream_location", " stream_slice", " stream_no", "server_index", "server_number", "stream_number", " stream_ind", "stream_no", " stream_num", "stream_alias", " stream_ticket", " stream_alias"], "buf": ["mem", "cap", "xff", "cv", "Buff", "offset", "pos", "arr", "img", "bar", "result", "text", "fb", "ob", "vec", "cur", "tmp", "length", " buffer", "queue", "bc", "v", "bytes", "pb", "wb", "ptr", "addr", "data", "msg", "cmd", "ref", "batch", "str", "rb", "orig", "cb", "block", "uf", "buffer", "Buffer", "src", "buff", "code", "b", "seq", "ff", "br", "ered"], "size": ["izes", "offset", "needed", "pos", "zone", "l", "args", "settings", "total", "max", "equal", "sp", "sent", "sample", "num", "ose", "gz", "zero", "scale", "sum", "count", "g", "south", "empty", "shape", "padding", "length", "send", "name", "bytes", "capacity", "fee", "time", "any", "range", "msg", "ize", "storage", "body", "height", "too", "message", "number", "n", "now", "dim", "space", "Size", "since", "SIZE", "cache", "type", "year", "buffer", "small", "full", "ms", "m"], "pts": ["ctss", "reqts", "ptS", "Ptrl", "colss", "txts", "tells", "txsets", "Ptrs", "portts", "ptxs", "ptsd", "ptss", "ptts", "ptsets", "colts", "pkgt", "reqs", " ptsd", "cmdts", "ptis", "txtes", "portsets", "tellS", "ptl", "ctxs", "pttes", "ports", "cmdsets", "Ptrsd", "PtrS", "PTs", "colis", "PTis", "reqt", "telll", " ptl", "ptt", "reqxs", "PTss", "pkgs", "ctis", "cmdtes", "tellsd", "cts", "ctts", "cols", "porttes", "PTts", "cmds", "ctt", "pkgxs", "pkgts", " ptS", "txs"], "s": ["sc", "hs", "ds", "cs", "sam", "scl", "t", "scripts", "sh", "tx", "sb", "p", "sp", "ess", "sq", "ses", "set", "sm", "qs", "is", "bs", "sid", "sv", "rs", "gs", "sa", "S", "ss", "so", "sw", "ns", "sts", "vs", "se", "ps", "sys", "sn", "js", "sd", "service", "c", "xs", "ats", "comm", "str", "fs", "less", "ts", "ssl", "ls", "ims", "stats", "ms", "src", "spec", "sl"], "st": ["sc", "z", "t", "ist", "sk", "sh", "sp", "ess", "th", "sm", "sv", "tr", "ss", "ste", "so", "mt", "sw", "sts", "St", "start", "se", "stack", "sn", "inst", "std", "ust", "ST", "str", "est", "sta", "ts", "irst", "nd", "tt", "src", "sl", "ut", "ost"], "stream": ["test", "mount", "header", "length", "ste", "track", "peer", "iv", "driver", "wrapper", "inner", "sync", "host", "context", "present", "cache", "metadata", "unk", "download", "buffer", "chain", "spec", "sl", "ost", "dd", "check", "channel", "form", "server", "pipe", "list", "then", "port", "v", "upload", "video", "response", "dev", "post", "o", "ack", "view", "ver", "stats", "status", "poll", "stack", "event", "sam", "console", "style", "REAM", "th", "query", "enc", "ream", "tr", "send", "sw", "http", "time", "draw", "str", "transform", "source", "info", "ssl", "iterator", "row", "loop", "window", "component", "hook", "stage", "store", "public", "writer", "engine", "image", "pod", "thread", "reader", "data", "rel", "Stream", "pool", "message", "table", "our", "filter"], "dts": ["dTS", "fduts", "pdts", "dtt", "gdts", "ddps", "dt", " duts", "dcs", " dtt", "dduts", "ddTS", "dps", "fdps", "Dps", "fdTS", "gduts", " dt", " dps", "ddts", "Dts", "fdtt", "pdps", "duts", "pdtt", "ddt", "Duts", "gdTS", "gdps", " dcs", "fdcs", "Dt", "pdcs", "fdts"], "len": ["mem", "pos", "lp", "fl", "loc", "l", "el", "t", "els", "lon", "p", "lib", "sp", "lf", "en", "num", "ll", "h", "gz", "li", "ret", "le", "compl", "vec", "wid", "dl", " l", "il", "length", "fin", "v", "ln", "limit", "ptr", "iter", "lt", "rev", "nl", "half", "lit", "den", "rel", "val", "L", "kl", "cmp", "line", "coll", "n", "lic", "cod", "lan", "alt", "repl", "del", "lim", "ls", "pl", "ld", "bin", "vol", "un", "fun", "Len", "gen", "sl", "elt", "seq", "err", "hl"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n", "idx": 19987, "substitutes": {"cpu_model": ["cpu_models", "cpu_Model", "cpu_type", "gpu_label", " cpu_models", " cpu_type", "gpu_model", "cpu_label", "gpu_Model", " cpu_Model"], "id": ["index", "res", "i", "p", "uid", "sp", "num", "md", "h", "pid", "is", "count", "sid", " ID", "wid", "name", "m", "d", "kid", "start", " tid", "k", "hid", "bid", "ide", "ip", "addr", "head", "data", "Id", "ref", "r", "rid", "tag", "ids", "oid", " pid", "def", "rank", "key", "vid", "mid", "it", "ID", " fid", "part", "f", "ident", "type"], "prom_addr": ["prom8ptr", "Prom_address", " prom_address", "promocarr", "promocdata", "prom_address", "promockptr", "promockdata", "romptdata", "prom8address", "rom_arr", "prom_arr", " prom_ptr", "promptptr", "prom2addr", " prom_src", "promptaddr", "promptdata", "prom_data", "rom_data", "romptaddr", "prom_ptr", "promptarr", "rom_addr", "prom8src", "promockaddr", "promocaddr", "prom8addr", "prom_src", "romptarr", "rom_ptr", "prom2address", "romptptr", "Prom_addr", "promockarr", "Prom_ptr", "promocptr", "prom2ptr"], "cpu_irqs": ["cpu_rinq", "cpu_iorqs", "cpu_riniffs", "cpu_mirgs", "cpu_rinqs", "cpu_irques", "cpu_pirques", "cpu_irq", "cpu_prqu", "cpu_miriffs", "cpu_irqu", "cpu_irgs", "cpu_inqu", "cpu_inq", "cpu_pirqu", "cpu_iorgs", "cpu_prques", "cpu_iriffs", "cpu_pirqs", "cpu_prqs", "cpu_ioriffs", "cpu_prq", "cpu_inqs", "cpu_mirqs", "cpu_iorq", "cpu_rings", "cpu_mirq", "cpu_pirq", "cpu_inques"], "cs": ["cv", "ds", "tc", "ck", "proc", "ec", "cn", "ctx", "cons", "qs", "cas", "cf", "rs", "gs", "caps", "cc", "sts", "ns", "vs", "ps", "sys", "js", "c", "css", "comm", "Cs", "cks", "fs", "act", "acs", "ts", "nc", "ls", "cus", "s", "cp", "stats", "CS", "ac", "wcs", "sc"], "cpu": ["mac", "ck", "uu", "score", "ctx", "cam", "copy", "tp", "sys", "c", "uda", "bench", "jp", "eu", "ce", "aux", "cache", "boot", "mem", "cv", "np", "memory", "pu", "cli", "hw", "reset", "pkg", "cu", "null", "cum", "sc", "bean", "init", "nic", "linux", "proc", "hz", "cn", "cf", "node", "disk", "aco", "stat", "alloc", "ka", "clus", "clock", "processor", "cal", "gpu", "cp", "process", "phy", "p", "client", "pc", "core", "gc", "util", "socket", "thread", "vm", "conn", "cmd", "nu", "pool", "prof", "aq", "nc", "CPU", "us", "comp", "phys"], "env": ["next", "mem", "export", "cv", "np", "server", "el", "console", "window", "sb", "desc", "proc", "en", "vt", "ec", "enter", "app", "enc", "ctx", "end", "nv", "esm", "e", "buf", "ape", "sv", "config", "vp", "mn", "engine", "db", "v", "vs", "ew", "obj", "esc", "ve", "ptr", "ef", "hw", "js", "conn", "priv", "cmd", "target", "ext", "dev", "common", "scope", "ev", "forge", "context", "et", "cfg", "eu", "ce", "er", "ent", "eve", "viron", "cb", "screen", "shell", "entry", "eg", "pe", "conf", "environment", "oe"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "av_cold void avcodec_register(AVCodec *codec)\n\n{\n\n    AVCodec **p;\n\n    avcodec_init();\n\n    p = &first_avcodec;\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n    *p          = codec;\n\n    codec->next = NULL;\n\n\n\n    if (codec->init_static_data)\n\n        codec->init_static_data(codec);\n\n}\n", "idx": 19998, "substitutes": {"codec": ["cdEC", "codedisc", "codeeca", "codeoc", "codeisc", "cdiac", "Codoc", "predbec", "codedEC", "predec", "codbec", "codedec", "podeco", " codEC", "Codiac", "codiac", "odentity", "codentity", "cdeca", "codesc", "czec", "codoc", "odisc", " coddec", "cmdeco", "odoc", "cmderer", "Codeca", "czbec", "cdec", "codeco", "codEC", "podec", "poderer", "Codentity", " codoc", "Codec", "Coderer", "Codesc", " codisc", "coddec", "codeiac", " coderer", "odbec", "czdec", "codedentity", "podesc", "Codeco", "cmdesc", "codeec", "czerer", "Coddec", "oderer", "codeca", "Codisc", "odEC", "prederer", "preddec", "cmdec", "odec", "CodEC", "oddec", "codeEC", "coderer", "codisc"], "p": ["a", "lp", "np", "wp", "t", "i", "pr", "pp", "ping", "sp", "proc", "pad", "q", "h", "bp", "pid", "pc", "g", "point", "per", "vp", "prop", "tp", "m", "pro", "rep", "v", "pod", "pb", "peer", "ps", "mp", "up", "pkg", "pi", "c", "j", "pers", "jp", "post", "pair", "n", "gp", "par", "pl", "pa", "ep", "cp", "php", "f", "fp", "part", "P", "pe", "b", "ap", "process"]}}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n\n{\n\n    int i;\n\n\n\n    if ((p[1] & 0xF) == 3) {\n\n        /* NAA designator type */\n\n        if (p[3] != 8) {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = ldq_be_p(p + 4);\n\n        return 0;\n\n    }\n\n\n\n    if ((p[1] & 0xF) == 8) {\n\n        /* SCSI name string designator type */\n\n        if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) {\n\n            return -EINVAL;\n\n        }\n\n        if (p[3] > 20 && p[24] != ',') {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = 0;\n\n        for (i = 8; i < 24; i++) {\n\n            char c = toupper(p[i]);\n\n            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);\n\n            *p_wwn = (*p_wwn << 4) | c;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 19999, "substitutes": {"p": ["a", "lp", "np", "dp", "l", "t", "wp", "w", "pad", "pp", "ping", "sp", "ist", "app", "q", "at", "bp", "h", "ar", "pc", "g", "op", "xp", "vp", "tp", "out", "pg", "d", "rep", "v", "pb", "progress", "ip", "ps", "pm", "mp", "pkg", "up", "c", "pt", "pi", "j", "r", "jp", "post", "n", "o", "cache", "x", "pre", "info", "pa", "resp", "cp", "f", "fp", "pe", "P", "b", "ap", "m"], "p_wwn": ["p_whegn", "p_wdn", "p___wrd", "p_nwreen", "p___wwn", "p_wll", "p_wreen", "p_wrizen", "p_wareen", "p___wisen", "p_waldn", "p_rwm", "p_wawn", "p_waden", "p_ward", "p_walwn", "p_Wdn", "p_nwizen", "p_rwwr", "p_nkn", "p_rwll", "p_nwisen", "p_watden", "p_rwisen", "p_rwreen", "p_dgn", "p_watkn", "p_nwwr", "p_wnn", "p_rwn", "p_wkn", "p_dwm", "p_watwn", "p_wwr", "p_nden", "p_wrd", "p_wrwn", "p___rwwn", "p_wwm", "p___rwisen", "p_walll", "p_rwrd", "p_wrisen", "p_nwn", "p___rwrd", "p_wgn", "p_rgn", "p_dnn", "p___rwizen", "p_wakn", "p_whenn", "p_Wkn", "p_nwwn", "p_wisen", "p_nrown", "p_rwdn", "p_rnn", "p_watrown", "p_whewn", "p_wrown", "p_warown", "p_nwrd", "p_wawr", "p_wizen", "p_walkn", "p_wrrd", "p_dwn", "p_rwizen", "p___wizen", "p_rwwn", "p_whewm", "p_Wwn", "p_rwkn", "p_wden", "p_Wll"], "i": ["z", "hi", "li", "ri", "e", "I", "ai", "di", "iter", "mi", "asi", " iter", "ex", "multi", "ii", "index", "ij", "ci", "\u0438", "phi", " multi", "v", "cli", "pi", "gi", "o", "n", "bi", "x", " x", " hi", "zi", " err", "ini", "it", "status", "init", "ic", " pos", " count", "ei", " ti", "me", " ii", " index", " mi", "k", " li", " j", "j", "ti", " I", "uri", " di", " si", "go", " bi", "ix", "y", "m", "si", "ki", "at", "h", " pi", "is", "u", "ind", "xi", "ui", "batch", "key", "ims", " ni", " m", " v"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_i_picture_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex, status = 0;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n#if HAS_ADVANCED_PROFILE\n\n    if (v->profile <= PROFILE_MAIN)\n\n#endif\n\n    {\n\n        if (v->extended_mv) v->mvrange = get_prefix(gb, 0, 3);\n\n        if (v->multires) v->respic = get_bits(gb, 2);\n\n    }\n\n#if HAS_ADVANCED_PROFILE\n\n    else\n\n    {\n\n        v->s.ac_pred = get_bits(gb, 1);\n\n        if (v->postprocflag) v->postproc = get_bits(gb, 1);\n\n        /* 7.1.1.34 + 8.5.2 */\n\n        if (v->overlap && v->pq<9)\n\n        {\n\n            v->condover = get_bits(gb, 1);\n\n            if (v->condover)\n\n            {\n\n                v->condover = 2+get_bits(gb, 1);\n\n                if (v->condover == 3)\n\n                {\n\n                    status = bitplane_decoding(&v->over_flags_plane, v);\n\n                    if (status < 0) return -1;\n\n#if TRACE\n\n                    av_log(v->s.avctx, AV_LOG_DEBUG, \"Overflags plane encoding: \"\n\n                           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n                }\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return status;\n\n}\n", "idx": 20000, "substitutes": {"v": ["vi", "cv", "lv", "ov", "b", "l", "qv", "z", "t", "w", "window", "wire", "i", "vim", "p", "qu", "vt", "query", "q", "h", "nv", "av", "g", "sv", "vp", "u", "vc", "em", "ch", "conv", "sw", "all", "uv", "detail", "vs", "vm", "video", "ve", "k", "iv", "value", "response", "rev", "c", "inv", "j", "dev", "ev", "val", "message", "V", "current", "er", "env", "cache", "x", "vv", "view", "s", "vr", "ver", "f", "tv", "version", "vd", "y", "m"], "gb": ["bm", "cv", " GB", "deg", "csv", "sb", "bb", "goo", "gif", "ctx", "xy", "html", "pc", "fb", "gc", "bs", "ruby", "g", "Gb", "gnu", "gs", "kb", "bg", "py", "GB", "mb", "db", "pg", "bytes", "hw", "pb", "wb", "vm", "attr", "sys", "vg", "nb", "hub", "storage", "gg", "gy", "gam", "cfg", "gpu", "bf", "rg", "rb", "ib", "gd", "cb", "bt", "tg", "gh", "gm", "eg", "gt", "eb", "large", "b"], "pqindex": ["pqIndex", "cqindex", "pqqaxis", "pqno", "pdqdata", "pQnum", "pqvalue", "paquindex", "proqlaxis", "paqseed", "pquantind", "pcapaxis", "pquseed", " pqqind", "piqindex", "pqqaddress", "pqdata", "cqqindex", "paqdata", "pcapno", "pqqno", "paqqIndex", "pqqind", "paqIndex", "pqind", "pquantvalue", "pquantnum", "paqind", "pqseed", "pcapindex", "proqno", "paquseed", "pqaxis", "pqnum", "piqvalue", "pquind", "pqlindex", "pQindex", "pQind", "paqqnum", "pqqnum", "proqlindex", "cqqnum", "paqnum", "pquantindex", "piqind", "pqlno", " pqqindex", " pqvalue", "pquantIndex", " pqqvalue", "cqqind", "proqindex", " pqind", "pdqind", "pqqvalue", "proqaxis", "cqind", "proqladdress", "pqlaxis", "pqqindex", "paqudata", "paqindex", "proqlno", "pdqseed", "pquindex", "pqaddress", "paqqindex", "pcapaddress", "pqladdress", "paqqind", "pqqIndex", "cqnum", "pdqindex", "proqaddress", "paquind", "pqudata"]}}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    AVCodec *dec;\n\n    char val_str[128];\n\n    AVDictionaryEntry *tag = NULL;\n\n    AVRational display_aspect_ratio;\n\n\n\n    printf(\"[STREAM]\\n\");\n\n\n\n    printf(\"index=%d\\n\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        if ((dec = dec_ctx->codec)) {\n\n            printf(\"codec_name=%s\\n\", dec->name);\n\n            printf(\"codec_long_name=%s\\n\", dec->long_name);\n\n        } else {\n\n            printf(\"codec_name=unknown\\n\");\n\n        }\n\n\n\n        printf(\"codec_type=%s\\n\", media_type_string(dec_ctx->codec_type));\n\n        printf(\"codec_time_base=%d/%d\\n\",\n\n               dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        printf(\"codec_tag_string=%s\\n\", val_str);\n\n        printf(\"codec_tag=0x%04x\\n\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            printf(\"width=%d\\n\", dec_ctx->width);\n\n            printf(\"height=%d\\n\", dec_ctx->height);\n\n            printf(\"has_b_frames=%d\\n\", dec_ctx->has_b_frames);\n\n            if (dec_ctx->sample_aspect_ratio.num) {\n\n                printf(\"sample_aspect_ratio=%d:%d\\n\",\n\n                       dec_ctx->sample_aspect_ratio.num,\n\n                       dec_ctx->sample_aspect_ratio.den);\n\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n\n                          1024*1024);\n\n                printf(\"display_aspect_ratio=%d:%d\\n\",\n\n                       display_aspect_ratio.num, display_aspect_ratio.den);\n\n            }\n\n            printf(\"pix_fmt=%s\\n\",\n\n                   dec_ctx->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[dec_ctx->pix_fmt].name\n\n                                                    : \"unknown\");\n\n            printf(\"level=%d\\n\", dec_ctx->level);\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            printf(\"sample_rate=%s\\n\", value_string(val_str, sizeof(val_str),\n\n                                                    dec_ctx->sample_rate,\n\n                                                    unit_hertz_str));\n\n            printf(\"channels=%d\\n\", dec_ctx->channels);\n\n            printf(\"bits_per_sample=%d\\n\",\n\n                   av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n        }\n\n    } else {\n\n        printf(\"codec_type=unknown\\n\");\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n\n        printf(\"id=0x%x\\n\", stream->id);\n\n    printf(\"r_frame_rate=%d/%d\\n\",\n\n           stream->r_frame_rate.num, stream->r_frame_rate.den);\n\n    printf(\"avg_frame_rate=%d/%d\\n\",\n\n           stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n\n    printf(\"time_base=%d/%d\\n\",\n\n           stream->time_base.num, stream->time_base.den);\n\n    printf(\"start_time=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->start_time, &stream->time_base));\n\n    printf(\"duration=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->duration, &stream->time_base));\n\n    if (stream->nb_frames)\n\n        printf(\"nb_frames=%\"PRId64\"\\n\", stream->nb_frames);\n\n\n\n    while ((tag = av_dict_get(stream->metadata, \"\", tag,\n\n                              AV_DICT_IGNORE_SUFFIX)))\n\n        printf(\"TAG:%s=%s\\n\", tag->key, tag->value);\n\n\n\n    printf(\"[/STREAM]\\n\");\n\n}\n", "idx": 20005, "substitutes": {"fmt_ctx": ["ftx_ctx", "fmt2context", "ftx_tx", "ftx_req", "flt_txt", "fmt2txt", "fmtCcontext", "fmt_context", "fmtCtx", "fmtCctx", "fmt_req", "fmt2ctx", "flt_context", "flt_ctx", "fmt2tx", "ftx_context", "fmtCtxt", "flt_tx", "fmt_tx", "fmt_txt"], "stream_idx": ["stream_midxd", "stream_ridz", "stream_idz", "stream_Idxd", "stream_ridy", "stream_inxs", "stream_Idxs", "stream_inx", "stream_didy", "stream_midxs", "stream_idxs", "stream_ridxs", "stream_Idy", "stream_didxs", "stream_ridx", "stream_inz", "stream_Idx", "stream_didx", "stream_iny", "stream_idxd", "stream_didxd", "stream_idy", "stream_midy", "stream_midx"], "stream": ["channel", "form", "console", "pipe", "window", "desc", "secure", "hook", "REAM", "ec", "port", "feed", "ream", "util", "shape", "tr", "length", " upstream", "seek", "pro", "sw", "pod", "upload", "video", "cont", "reader", "read", "each", "spect", "time", "data", "ocr", "dev", "Stream", "context", "draw", "present", "transform", "path", "metadata", "ack", "iterator", "row", "open", "view", "steam", "src", "sl", "version", "trans"], "dec_ctx": ["dec_ctl", "dec67ctx", "dec_cv", "dec__tx", "Dec_tx", "decptcmd", "dec00pkg", "decockcontext", "dec_pool", "dec___ctx", "decogcontext", "decptpkg", "dec_cmp", "dec___tx", "evalogcontext", "decoggc", "dec_ck", "dec67cmd", "ec_crit", "eval_cu", "dec8tx", "DEC_cmd", "decogcv", "dec__obj", " dec_ci", "dec_ci", "decetctx", "decetpkg", " dec_pkg", "dec2context", "dec_cmd", "dec__ctx", "Dec_pkg", "DECptcheck", "DEC_check", "ec_gc", "decogcrit", "ec_context", "ec_pkg", "decockcu", "ec_ctl", "Dec_pool", "dec2obj", "Dec_ctl", " dec_tz", "dec_gc", "Dec_cmp", "DECptctx", "dec2ctx", "decptcontext", "dectxgc", "eval_cv", "dec_context", "decogctx", "Dec_ck", "dec_conn", "dec_obj", "dec2tx", "dec_check", "ec_cfg", "decockcv", "dectxctx", "dectxpkg", "ec_tx", "ec_obj", "decockctx", "evalogctx", "ec_sys", "dec67check", "dec_lvl", "dec_tz", "decptsys", "dec8pkg", "DECptcmd", "decogpkg", "dec_cu", "dec00obj", "evalogcu", "dec__ctl", "dec67obj", "decptobj", "decptctx", "dec_ca", "Dec_conn", "dec_cp", "dec_sys", "dec00tz", "evalogcv", " dec_tx", "dec_grad", "dec_cfg", "Dec_grad", "Dec_cas", "dec_tx", "decettx", "dec_crit", "ec_ctx", "eval_context", "Dec_obj", "dec_cas", "dec8ctx", "DEC_ctx", "eval_ctx", "ec_ca", "ec_cmp", "dec8pool", "dec___pkg", "dec00ctx", "dec___ck", "ec_cp", "DECptobj", "decetcas", " dec_obj", "Dec_ctx", "ec_lvl", "decptcheck", "dectxcrit", "DEC_obj", "decogcu", "dec_pkg"], "val_str": [" val_arr", "val_Str", "val_br", "val_buf", "Val_str", " val_string", "value_arr", "val2fr", "Val_Str", "val_r", "val2str", "val_string", " val_br", "value_fr", "Val_buf", "Val_arr", " val_r", "val2br", "val_fr", "val_arr", " val_Str", "val2arr", "value_str", "val2string"], "tag": ["debug", "pos", "error", "style", "word", "ag", "comment", "desc", "count", "match", "stat", "name", "reg", "label", "attr", "peg", "cat", "TAG", "id", "field", "Tag", "key", "token", "meta", "event", "type"], "display_aspect_ratio": ["display_aspect_Ratior", "display_aspect_Rati", "display_aspect_ratirection", "display_aspect_dirirection", "display_aspect_tao", "display_aspect_Ratio", "display_aspect_ratIO", "display_aspect_rtios", "display_aspect_rotio", "display_aspect_rios", "display_aspect_requios", "display_aspect_ratior", "display_aspectistdigirection", "display_aspect_ratror", "display_aspect_dirios", "display_aspect_Ratirection", "display_aspect_statio", "display_aspect_digirection", "display_aspect_rIO", "display_aspectistratience", "display_aspect_ratirement", "display_aspectistratios", "display_aspect_statistor", "display_aspect_tistor", "display_aspect_ratience", "display_aspect_rtio", "display_aspect_ratial", "display_aspect_RatIO", "display_aspect_ratao", "display_aspect_digience", "display_aspect_rio", "display_aspect_rtirement", "display_aspect_requio", "display_aspect_statior", "display_aspect_ratistor", "display_aspect_Ratios", "display_aspect_arror", "display_aspect_Ratirement", "display_aspect_tio", "display_aspect_rtial", "display_aspect_tios", "display_aspect_requial", "display_aspect_ratios", "display_aspect_Ratistor", "display_aspect_ari", "display_aspect_roti", "display_aspect_rotror", "display_aspectistdigience", "display_aspect_rao", "display_aspect_ario", "display_aspect_rotios", "display_aspect_arios", "display_aspect_Ratial", "display_aspect_tior", "display_aspect_requirement", "display_aspect_statios", "display_aspectistratio", "display_aspect_Ratience", "display_aspect_digios", "display_aspectistdigio", "display_aspect_dirience", "display_aspectistdigios", "display_aspect_digio", "display_aspect_tIO", "display_aspectistratirection", "display_aspect_Ratror", "display_aspect_dirio", "display_aspect_rati", "display_aspect_Ratao"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "static void encode_block(MpegEncContext *s, int16_t *block, int n)\n\n{\n\n    int i, j, table_id;\n\n    int component, dc, last_index, val, run;\n\n    MJpegContext *m = s->mjpeg_ctx;\n\n\n\n    /* DC coef */\n\n    component = (n <= 3 ? 0 : (n&1) + 1);\n\n    table_id = (n <= 3 ? 0 : 1);\n\n    dc = block[0]; /* overflow is impossible */\n\n    val = dc - s->last_dc[component];\n\n\n\n    ff_mjpeg_encode_coef(m, table_id, val, 0);\n\n\n\n    s->last_dc[component] = dc;\n\n\n\n    /* AC coefs */\n\n\n\n    run = 0;\n\n    last_index = s->block_last_index[n];\n\n    table_id |= 2;\n\n\n\n    for(i=1;i<=last_index;i++) {\n\n        j = s->intra_scantable.permutated[i];\n\n        val = block[j];\n\n\n\n        if (val == 0) {\n\n            run++;\n\n        } else {\n\n            while (run >= 16) {\n\n                ff_mjpeg_encode_code(m, table_id, 0xf0);\n\n                run -= 16;\n\n            }\n\n            ff_mjpeg_encode_coef(m, table_id, val, run);\n\n            run = 0;\n\n        }\n\n    }\n\n\n\n    /* output EOB only if not already 64 values */\n\n    if (last_index < 63 || run != 0)\n\n        ff_mjpeg_encode_code(m, table_id, 0);\n\n}\n", "idx": 20019, "substitutes": {"s": ["a", "services", "hs", "ds", "cs", "sam", "times", "os", "l", "sg", "t", "settings", "sb", "p", "ses", "sq", "ctx", "sm", "set", "qs", "is", "esm", "bs", "sv", "rs", "gs", "S", "ss", "sw", "ns", "sts", "v", "se", "self", "ps", "sys", "js", "service", "c", "es", "ats", "r", "o", "fs", "less", "ts", "ims", "ls", "gm", "stats", "ms", "series", "spec", "b", "y", "eds"], "block": ["mem", "snap", "frame", "check", "word", "blocks", "board", "box", "Block", "p", "proc", "list", "q", "set", "buf", "lock", "point", "load", "map", "group", "ch", "out", "image", "v", "bl", "object", "bit", "range", "in", "record", "field", "line", "new", "def", "raw", "pack", "bf", "x", "row", "bin", "view", "buffer", "chain", "f", "b", "byte", "type"], "n": ["na", " N", "nt", "l", "np", "z", "t", "fn", "size", "p", "num", "cn", "q", "h", "ne", "span", "g", "ng", "d", "ns", "v", "k", "nn", "nor", "sn", "nb", "c", "nu", "note", "r", "number", "o", "N", "nan", "network", "x", "nm", "nc", "len", "no", "nr", "b", "y"], "i": ["ic", "index", "ij", "jj", "l", "si", "ci", "im", "p", "ei", "hi", "ki", "qi", "me", "li", "is", "\u0438", "ri", "ni", "I", "ai", "iq", "v", "di", "io", "ip", "mi", "pi", "c", "ind", "id", "in", "xi", "ti", "ui", "gi", "print", "ji", "multi", "o", "bi", "x", "zi", "ini", "sim", "ie", "it", "ix", "ia", "iu", "y", "ii"], "j": ["index", "jj", "ij", "z", "l", "si", "t", "pr", "p", "dj", "kj", "q", "h", "ja", "g", "uj", "fr", "u", "J", "jac", "jit", "d", "v", "k", "jl", "js", "c", "r", "jp", "job", "ji", "o", "aj", "bi", "x", "jump", "f", "it", "jc", "b", "y"], "table_id": ["tab_ids", "tableOnum", " table_ide", "tableNameindex", " table_ids", "table_info", " table2index", "chain_info", "tabOnum", "tableNameid", "table_len", " table_ref", "tableOid", "chain_id", "tablelwith", " table2len", "tablelpid", "entity_def", " table2type", "table2id", "table_ids", "table_pid", "tablelid", "entity_id", "table_tag", " table_len", "tabOlen", "table_with", "tableOlen", "tab_len", "tableptip", "entity_oid", " table_link", " table2id", " table_log", "table_def", "tableNametype", "tableNamelen", "tabOid", "table2len", "tableptids", "tab_num", " table_type", "table_ide", "entity_info", "table_log", "chain_with", "table_num", "table_link", "table_index", "table_oid", " table_tag", "tableOids", "table_ip", "tableptid", "chain_pid", "table2index", " table_ip", "table2type", "tabOids", "tableptlog", " table_index", "tablelinfo", "table_type", "tab_id", "table_ref"], "component": ["division", "frame", "character", "index", "zone", "channel", "form", "stable", "format", "comment", "slot", "controller", "port", "family", "pc", "ness", "scale", "column", "device", "quarter", "application", "node", "command", "reason", "position", "ity", "method", "unit", "impact", "kind", "instance", "service", "c", "entity", "common", "scope", "field", "uni", "context", "relation", "draw", "member", "number", "project", "fc", "ce", "sequence", "module", "state", "Component", "attribute", "nc", "omp", "function", "com", "brand", "chain", "comp", "part", "code", "direction", "dimension", "col", "type"], "dc": ["td", "ds", "cs", "loc", "dp", "tc", "ca", "mac", "disc", "cloud", "dt", "mc", "ec", "ctx", "pc", "dat", "bc", "cc", "d", "db", "co", "di", "cd", "da", "dr", "c", "dir", "cmp", "lc", "coll", "fc", "dim", "nc", "DC", "rc", "cp", "ac", "comp", "sc"], "last_index": ["last_key", "first_date", "Last_block", "lastWlength", " last_member", "lastOverposition", "lastxlength", "lastxindex", "lastOverindex", "lastOversize", " last_key", " last_Index", "last_position", "last_block", "lastOvermember", " last_position", "lastWIndex", "Last_Index", "last_length", "first_length", "first_Index", "last_size", "lastWdate", "last_ind", "lastxIndex", "lastxdate", "last_date", "last_member", "Last_index", " last_ind", " last_size", "lastWindex", "last_Index", "first_index"], "val": ["bal", "pos", "mem", "index", "Val", "loc", "el", "l", "sel", "rol", "res", "pr", "valid", "tx", "p", "lib", "var", "vt", "test", "VAL", "li", "ret", "vals", "buf", "vec", "pol", "sv", "prop", "length", "aval", "values", "des", "Value", "v", "fe", "se", "ve", "value", "eval", "data", "eq", "dev", "ref", "r", "rel", "cmp", "cal", "def", "sol", "fc", "cho", "x", "pl", "len", "vol", "al", "ver", "buffer", "comp", "b", "elt", "seq", "col"], "run": ["round", "Run", "length", "step", "rd", "pass", "commit", "sync", "rid", "rank", "be", "mix", "spec", "exec", "check", "index", "form", "result", "play", "end", "ran", "add", "call", "range", "update", "try", "coll", "ack", "len", "ro", "cum", "fun", "code", "rm", "num", "load", "cycle", "running", "name", "all", "co", "reg", "head", "order", "draw", "runner", "row", "go", "un", "no", "scan", "rc", "render", "loop", "process", "con", "work", "runs", "une", "ru", "roll", "cmd", "record", "ref", "r", "rate", "seq"], "m": ["bm", "rm", "man", "am", "l", "mac", "t", "p", "mm", "wm", "md", "h", "esm", "mod", "g", "mr", "em", "mt", "mb", "mo", "d", "v", "vm", "pm", "mp", "mi", "c", "hm", "M", "dm", "r", "arm", "mk", "um", "cm", "o", "fm", "y", "module", "tm", "nm", "x", "gm", "ms", "f", "b", "om"]}}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dstParam[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint16_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint16_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\tint srcStride[3];\n\n\tuint8_t *src[3];\n\n\tuint8_t *dst[3];\n\n\t\n\n\tif((c->srcFormat == IMGFMT_IYUV) || (c->srcFormat == IMGFMT_I420)){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[2];\n\n\t\tsrc[2]= srcParam[1];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[2];\n\n\t\tsrcStride[2]= srcStrideParam[1];\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_YV12){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[1];\n\n\t\tsrc[2]= srcParam[2];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[1];\n\n\t\tsrcStride[2]= srcStrideParam[2];\n\n\t}\n\n\telse if(isPacked(c->srcFormat)){\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= srcParam[0];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStrideParam[0]<<1;\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_Y8){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= NULL;\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= 0;\n\n\t}\n\n\n\n\tif((c->dstFormat == IMGFMT_IYUV) || (c->dstFormat == IMGFMT_I420)){\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[2];\n\n\t\tdst[2]= dstParam[1];\n\n\t\t\n\n\t}else{\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[1];\n\n\t\tdst[2]= dstParam[2];\n\n\t}\n\n\t\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tfprintf(stderr, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);\n\n\t\tconst int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);\n\n*/\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we cant output a dstY line so lets try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\t\t\tRENAME(yuv2yuvX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2rgbX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstFormat,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we cant use MMX here without overwriting this arrays tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2rgbXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstFormat);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n}\n", "idx": 20022, "substitutes": {"c": ["con", "cv", "cs", "ic", "tc", "l", "ca", "t", "ci", "p", "mc", "ec", "cn", "enc", "ctx", "err", "cation", "unc", "pc", "gc", "e", "cl", "cam", "config", "vc", "cc", "ct", "bc", "conv", "co", "ch", "v", "etc", "rec", "cont", "cr", "comm", "cmp", "lc", "coll", "dc", "C", "cm", "n", "fc", "ce", "cu", "cache", "cb", "nc", "xc", "com", "cp", "rc", "abc", "ac", "comp", "chain", "f", "sc", "b", "wcs", "conf", "col"], "srcParam": ["sourceParam", "rcPar", "rcDim", "rcParam", "sourcePar", "sourceNum", "srcNum", " srcPar", "srcPar", " srcDim", "srcDim", "rcNum", " srcNum", "sourceDim"], "srcStrideParam": ["srcSlripParam", "srcSlripMem", "srcStripPar", "srcStrMem", "srcStrMat", "srcSlrideParam", "srcSlripPar", "srcStripParam", "srcStratePar", "srcStripMem", "srcStrateParam", "srcStrideMem", "srcStridePar", "srcStrPar", "srcStripMat", "srcStrideMat", "srcStrateMat", "srcStrParam", "srcSlrideMem", "srcSlrideMat", "srcStrateMem", "srcSlridePar", "srcSlripMat"], "srcSliceY": ["srcSlideXY", "srcLiceY", "srcSlizeXY", "srcSlideW", "srcSlideX", "srcLsliceXY", "srcSlsliceW", "srcLsliceY", "srcSlsliceX", "srcLsliceX", "srcSlsliceXY", "srcLiceXY", "srcSlizeY", "srcSliceX", "srcSlizeX", "srcSlizeW", "srcSlsliceY", "srcSliceXY", "srcLsliceW", "srcSlideY", "srcLiceW", "srcLiceX", "srcSliceW"], "srcSliceH": ["srcSlatchX", "srcSlideX", "srcSlieX", "srcSlideH", "srcPliceY", "srcSliceHT", "srcPlatchY", "srcSlatchH", "srcSlieHT", "srcSlatchY", "srcSlatchHT", "srcSliceX", "srcPliceH", "srcPlatchX", "srcSlideHT", "srcPlatchH", "srcPlatchHT", "srcSlieY", "srcPliceHT", "srcSlieH", "srcSlideY", "srcPliceX"], "dstParam": [" ddestMem", " dstMem", "destAM", " dstAM", "ddestPar", "dstAM", "ddestMem", "ddestParam", "destParam", "destPar", "dstrParam", "dstrPar", "dstPar", " ddestParam", " ddestPar", "dstrMem", " ddestAM", " dstPar", "ddestAM", "dstrAM", "destMem", "dstMem"], "dstStride": ["dstDestride", "ddestRestrain", "dstAttr", "dstRestrain", "dstRestride", "dstRestrat", "dstDestr", "ddestRestrat", "dstStrain", "dstStr", "dstAttride", "dstDestrat", "dstAttrat", "ddestStrain", "dstAttrain", "ddestRestr", "ddestStride", "dstDestrain", "ddestRestride", "dstStrat", "ddestStr", "ddestStrat", "dstRestr"], "vLumFilterPos": ["vLumFilPos", "vLumFilterOff", "vLangFilterTrans", "vLangFilterOff", "vLumBufferDef", "vLumFilPort", "vLumFilterDef", "vLumBufferPort", "vLumBufferTrans", "vLumbFilterCond", "vLumListenerPos", "vLumbFilterPos", "vLumRulePos", "vLumBufferCond", "vLumRuleCond", "vLangListenerPort", "vLumListenerPort", "vLangFilterPort", "vLumRuleDef", "vLumListenerOff", "vLumFilterPort", "vLumbFilterDef", "vLangListenerTrans", "vLangListenerPos", "vLangFilterPos", "vLumFilterCond", "vLumFilTrans", "vLumFilterTrans", "vLangListenerOff", "vLumBufferPos", "vLumBufferOff", "vLumListenerTrans", "vLumFilOff"], "vChrFilterPos": ["vChrtCounterPos", "vChrFilPosition", "vChrCounterPos", "vChrtFilterPos", "vChrFilPart", "vChdrFilterLoc", "vChdrHandlerPoints", "vChdrFilterPoints", "vChrFFPart", "vChrFilterRes", "vChrHandlerPoints", "vChrFilCol", "vChrtCounterPosition", "vChrFFCol", "vChrFilterPosition", "vChrTransformPoints", "vChrFilterPoints", "vChrTransformRes", "vChdrHandlerRes", "vChrFilterLoc", "vChrCounterPosition", "vChrFFPos", "vChrTransformLoc", "vChrCounterCol", "vChrManagerPoints", "vChrtCounterPart", "vChrHandlerPos", "vChrManagerRes", "vChrHandlerRes", "vChrtCounterCol", "vChdrHandlerLoc", "vChrCounterPart", "vChrtFilterPosition", "vChrFilPos", "vChrManagerPos", "vChdrFilterRes", "vChrHandlerLoc", "vChrFilterPart", "vChrFFPosition", "vChdrHandlerPos", "vChrManagerLoc", "vChrFilterCol", "vChdrFilterPos", "vChrtFilterCol", "vChrtFilterPart", "vChrTransformPos"], "hLumFilterPos": ["hLumFilCond", "hLumFilterDir", "hLumFilterRes", "hLumBlockObj", "hLoomFilCond", "hLoomFilterComp", "hLumFilComp", "hLumTERDir", "hLumTERCond", "hLumFormatPos", "hLumTERPos", "hLumSortDir", "hLoomFilterCond", "hLoomFilterPos", "hLumSortComp", "hLumFilterObj", "hLumBlockRes", "hLoomFilDir", "hLumControlPos", "hLoomFilterDir", "hLumFilPos", "hLumTERComp", "hLumaFilterObj", "hLumControlObj", "hLumaControlRes", "hLumSortCond", "hLoomFilComp", "hLumaFilterRes", "hLumSortPos", "hLumaControlObj", "hLumaControlPos", "hLumBlockPos", "hLumaFilterPos", "hLumFormatRes", "hLumControlRes", "hLumFilDir", "hLumFilterComp", "hLumFilterCond", "hLumFormatObj", "hLoomFilPos"], "hChrFilterPos": ["hChrfilterLen", "hChrFormatRes", "hChrfilterDir", "hChrfilterRot", "hChrTestLen", "hChdrfilterLen", "hChdrFilterRes", "hChrFilterPosition", "hChrfilterRes", "hChdrFilterLen", "hChdrfilterPos", "hChrTestPos", "hChrFilterRes", "hChrFormatPos", "hChrFileRes", "hChrFilePos", "hChroFilterPos", "hChdrFilterPos", "hChrFilterRot", "hChdrFilterRot", "hChrTestRes", "hChroFileRes", "hChroFilterPosition", "hChroFilterDir", "hChrChannelPos", "hChrFilePosition", "hChrTestRot", "hChroFilePos", "hChrChannelRes", "hChrChannelDir", "hChrFilterDir", "hChrFileDir", "hChrFilterLen", "hChroFilterRes", "hChroFilePosition", "hChrfilterPosition", "hChdrfilterRes", "hChrFormatLen", "hChrChannelPosition", "hChroFileDir", "hChrfilterPos", "hChdrfilterRot", "hChrFormatRot"], "vLumFilter": ["vBlumiHandler", "vLumbRule", "vLumFil", "vElulLimit", "vLumiFilter", "vElumFilter", "vLumbFilter", "vLumbHandler", "vBlumiChannel", "vBlumFilter", "vLumiLimit", "vLnumChannel", "vElumLimit", "vLomHandler", "vBlumiFil", "vLulHandler", "vLomFil", "vBlumHandler", "vLnumFil", "vLnumFilter", "vBlumFil", "vLumRule", "vElulFilter", "vLulLimit", "vLumiRule", "vLumbLimit", "vElulRule", "vBlumiFilter", "vLumiHandler", "vLulRule", "vElulHandler", "vLumChannel", "vLumHandler", "vLulFilter", "vElumRule", "vElumHandler", "vBlumChannel", "vLumLimit", "vLomChannel", "vLumiFil", "vLnumHandler", "vLomFilter", "vLumiChannel"], "vChrFilter": ["vChmFil", "vChrHandler", "vClmFormat", "vChdrfilter", "vChruChannel", "vColrbfilter", "vChbFormat", "vClrFilter", "vClmFil", "vColrfilter", "vChnfilter", "vChbFil", "vChrbHandler", "vChnHandler", "vClrFormat", "vClrFil", "vClmChannel", "vColrbFilter", "vChdrHandler", "vChmFormat", "vClrChannel", "vChruFormat", "vChmFilter", "vChrbfilter", "vClmFilter", "vChmChannel", "vChrFormat", "vChbFilter", "vChrbFilter", "vColrFilter", "vColrbHandler", "vChrfilter", "vChrFil", "vChruFil", "vChruFilter", "vChnFilter", "vChdrFilter", "vColrHandler", "vChrChannel", "vChbChannel"], "hLumFilter": ["hMumFF", "hLoxFilter", "hLumSpec", "hLamFF", "hLumpFF", "hLuminRule", "hLuminFilter", "hLamFilter", "hMumpFilter", "hLumaFil", "hMumpFil", "hLumiFilter", "hLeumSpec", "hLoxFF", "hLeoxFilter", "hLumFil", "hLumFF", "hLumiRule", "hLumaFilter", "hLeumFF", "hLuminSpec", "hLeumFilter", "hLumiFF", "hLeoxSpec", "hLumpFilter", "hLeumRule", "hLeoxFF", "hLoxSpec", "hLeoxRule", "hLuminFF", "hLoxRule", "hLamFil", "hMumFilter", "hMumFil", "hLumRule", "hMumpFF", "hLumpFil", "hLumiSpec", "hLumaFF"], "hChrFilter": ["hChrFil", "hChriVersion", "hColuTransform", "hChuFil", "hChriFilter", "hChrTransform", "hChuFilter", "hColuFilter", "hColrFilter", "hShrcVersion", "hChrbTarget", "hChrTarget", "hChrgTransform", "hChrbFilter", "hChrbTransform", "hShrcFilter", "hChrgTarget", "hShrcChain", "hChrcChain", "hShrcFil", "hShrFil", "hChrgFilter", "hChrbFil", "hChrcFilter", "hChrgFil", "hChrChain", "hChrVersion", "hShrChain", "hChrbVersion", "hChuTarget", "hColuTarget", "hChrbChain", "hChriFil", "hChriChain", "hChuTransform", "hShrFilter", "hColrTransform", "hChrcFil", "hChrcVersion", "hColuFil", "hColrFil", "hColrTarget", "hShrVersion"], "lumMmxFilter": ["lumRmxProfile", "lumMmxFormat", "lumBmxSort", "lumRmmFilter", "lumMmxSort", "lumMmnFilter", "lumRmmProfile", "lumBmxFormat", "lumMmmFilter", "lumMpxFilter", "lumMmmProfile", "lumRmmInfo", "lumMmProfile", "lumMmOnly", "lumMmInfo", "lumMmmInfo", "lumMixHandler", "lumMmmSort", "lumMmnInfo", "lumMmxOnly", "lumMpxHandler", "lumMpxFormat", "lumRmxFilter", "lumRmmOnly", "lumRmxInfo", "lumBpxFilter", "lumRmxOnly", "lumMixSort", "lumMmxProfile", "lumMixFormat", "lumMixFilter", "lumMmmFormat", "lumMmmHandler", "lumMpxSort", "lumBpxSort", "lumMmnProfile", "lumBmxFilter", "lumMmFilter", "lumMmxHandler", "lumMmmOnly", "lumMmxInfo", "lumBpxHandler", "lumBpxFormat", "lumBmxHandler", "lumMmnOnly"], "chrMmxFilter": ["chrLmxfilter", "chrMixBlock", "chrLmxFilter", "chrLmnfilter", "chrMnaFilter", "chrMmxfilter", "chrLmxBlock", "chrMxFile", "chrMxRule", "chrMmxBlock", "chrMixFilter", "chrMixfilter", "chrMmnFile", "chrLmnBlock", "chrMpxFilter", "chrMnaRule", "chrLmnFilter", "chrMtmFile", "chrMxFilter", "chrMpxfilter", "chrMmnBlock", "chrMixFile", "chrMmnFilter", "chrMtmRule", "chrLmnFile", "chrMtmFilter", "chrMnaFile", "chrMmnfilter", "chrMpxBlock", "chrMmxRule", "chrLmxFile", "chrMpxFile", "chrMmxFile"], "lumPixBuf": ["lumPfxBbuf", "lumPixPuf", "lumPfxRuf", "lumPixRuf", "lumPixPatch", "lumPfxRatch", "lumPfxRuff", "lumPxPrc", "lumPxPuf", "lumPxBuffer", "lumPixRbuf", "lumPixBrc", "lumPfxBuff", "lumPfxBuf", "lumPixBuffrc", "lumPxBbuf", "lumPixBuffuf", "lumPixRuff", "lumPixPuffer", "lumPxPbuf", "lumPxBuf", "lumPxPuffer", "lumPixPbuf", "lumPixBatch", "lumPixBuffbuf", "lumPfxRbuf", "lumPfxBatch", "lumPixPuff", "lumPxBrc", "lumPixBuffer", "lumPixBuffuffer", "lumPixBuff", "lumPixBbuf", "lumPixRatch", "lumPixPrc"], "chrPixBuf": ["chrPxPbuf", "chrPixCuf", "chrPixRus", "chrPixTbuf", "chrPixBuff", "chrPixCbuf", "chrPfxBbuf", "chrPixPuf", "chrPixRuff", "chrPxBff", "chrPixTff", "chrPixGbuf", "chrPixPuff", "chrPixBus", "chrPixRuf", "chrPxBuc", "chrPfxPus", "chrPxPuf", "chrPixGuff", "chrPixTuc", "chrPfxBuff", "chrPixRbuf", "chrPxBbuf", "chrPfxPuf", "chrPixCuc", "chrPixPbuf", "chrPixBbuf", "chrPfxBus", "chrPixPuc", "chrPixPus", "chrPixTuf", "chrPixBff", "chrPfxBuf", "chrPixCff", "chrPxPff", "chrPixGus", "chrPixGuf", "chrPixPff", "chrPfxPbuf", "chrPixBuc", "chrPxBuf", "chrPxPuc", "chrPfxPuff"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union srp_iu *srp = &req->iu.srp;\n\n    SCSIDevice *sdev;\n\n    int n, id, lun;\n\n\n\n    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);\n\n\n\n    /* Qemu vs. linux issue with LUNs to be sorted out ... */\n\n    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;\n\n    if (!sdev) {\n\n        dprintf(\"VSCSI: Command for id %d with no drive\\n\", id);\n\n        if (srp->cmd.cdb[0] == INQUIRY) {\n\n            vscsi_inquiry_no_target(s, req);\n\n        } else {\n\n            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        } return 1;\n\n    }\n\n\n\n    req->sdev = sdev;\n\n    req->lun = lun;\n\n    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);\n\n\n\n    dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\",\n\n            req->qtag, srp->cmd.cdb[0], id, lun, n);\n\n\n\n    if (n) {\n\n        /* Transfer direction must be set before preprocessing the\n\n         * descriptors\n\n         */\n\n        req->writing = (n < 1);\n\n\n\n        /* Preprocess RDMA descriptors */\n\n        vscsi_preprocess_desc(req);\n\n    }\n\n\n\n    /* Get transfer direction and initiate transfer */\n\n    if (n > 0) {\n\n        req->data_len = n;\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    } else if (n < 0) {\n\n        req->data_len = -n;\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    }\n\n    /* Don't touch req here, it may have been recycled already */\n\n\n\n    return 0;\n\n}\n", "idx": 20026, "substitutes": {"s": ["hs", "ds", "cs", "os", "z", "ops", "l", "t", "i", "p", "sb", "sp", "ses", "sq", "h", "is", "bs", "g", "sv", "rs", "gs", "S", "ss", "d", "session", "ns", "sts", "v", "sw", "vs", "ps", "http", "sys", "js", "es", "j", "ats", "r", "fs", "less", "ts", "ssl", "ls", "ims", "stats", "ms", "serv", "sc", "b"], "req": ["tx", "test", "ctx", "good", "rt", "fr", "crit", "requ", "rr", "tek", "pro", "rd", "inv", "comm", "jp", "aux", "quick", "exec", "spec", "need", "ij", "dist", "desc", "adj", "rw", "q", "required", "gz", "compl", "tab", "msg", "pkg", "range", "dev", "rss", "usr", "Request", "qt", "resp", "urg", "ctr", "worker", "err", "res", "term", "rx", "query", "expr", "xp", "iq", "reg", "attr", "progress", "js", "j", "Requ", "gr", "cmp", "quest", "request", "qq", "needed", "require", "rez", "p", "dep", "md", "sq", "decl", "uj", "rec", "seq", "rep", "supp", "wx", "rem", "cmd", "eq", "ext", "ind", "rel", "ref", "r", "rh", "comp", "rpm", "conf", "dq"], "srp": ["selpp", "lrf", "servpro", "servp", "srP", " srpt", "serpc", "vrp", "irpt", "sprP", "srvp", " srf", "surp", " srpar", "srpy", "sprpy", "ctrpt", "survp", "irp", "sprcp", "ibrpc", "vrcp", "serps", "srpar", "surpc", "srps", "srf", "srpa", "lrp", "servpa", "irpc", " srP", "srpro", "selp", "servpp", "ctrP", "ircp", " srpid", "ctrp", "svpro", "svf", "srpid", "lrpid", "selpro", "selpa", "ibrpar", "vrpt", " srvp", "lrpa", "svp", "srcp", "vrpar", "svpa", "ibrp", "sprpt", "serpar", "vrpc", " srpc", "ibrvp", "srpc", "svpid", "srpp", "sprpc", "ctrpy", "sprp", " srpa", "svpp", " srpy", "surpar", "srpt", "vrps", " srps", "serp"], "sdev": ["snode", "Sender", "tsdevelop", "svenv", "srdev", "sfat", "isDev", "svar", "tesDEV", "SDEV", "isdev", " sDEV", "sdfat", "sconn", "jsev", " sgo", " snode", "sldevice", "esdev", "msdev", "sdiv", "svdev", "sldev", "sgo", "ssgu", "msdevice", "sDev", "tsconn", "jsDev", " scam", "msvar", "Sev", "sgu", "tesdiv", "tsDev", "tsdevice", "sddevice", "sdevice", " sev", "sysDev", "srfat", "srdevice", "sdevelop", " sdevice", "tsdev", "tsev", "esev", "jscam", "isdevice", "statsdevice", "ssdev", "sev", "sysdevice", "esconn", " sfat", "statscam", "jsdev", "srnode", "jsdevice", "sender", "Sdev", "slev", "Sdevice", "sDEV", "isdiv", "tsenv", "slDEV", "svvar", " sdiv", "statsdev", "tesdev", "senv", "ssdevice", "scam", "jsDEV", " sdevelop", " sDev", "tsvar", " sender", "sddev", "sysender", " sgu", "jsconn", "ssgo", "tesdevice", "msenv", "esdevice", "SDev", "ssdevelop", "svdevice", "sysdev", "sdnode", "jsdiv"], "n": ["a", "na", " N", "nt", "z", "yn", " len", "t", "w", "np", "l", "i", "b", "p", "num", "en", "cn", "ll", "h", "dn", "norm", "ne", "e", "g", "ni", "ng", " l", "name", "out", "d", "ns", "ln", "v", "nn", "nor", "sn", " ns", "nb", "nu", "c", "ize", "nl", "fn", "j", "note", " fn", "r", "number", "N", "nan", "o", "gn", "nm", "nc", "x", "len", "pn", " ng", "no", "f", "an", "net", " nm", "y", "m"], "id": ["init", "offset", "debug", "fd", "l", "res", "size", "and", "t", "i", "pad", "p", "tx", "uid", "sp", "num", "md", "q", "h", "pid", "end", "hash", "is", "sid", "wid", "name", "ad", "d", "kid", "start", " tid", "bid", "ide", "ip", "addr", "data", "cmd", "ind", "Id", "in", "aid", "dev", "ref", "rid", "tag", "oid", "ids", "request", "info", "len", "no", "status", "mid", "vid", "it", "ID", "ident", "type"], "lun": ["Lun", "mlun", "mlunn", " lunt", "lut", "plund", "Lour", "llUN", "lum", "lon", "Lunt", "plun", "llunt", "leund", "leUN", "lund", " lut", "lunn", "slmun", "lUN", "leum", " lund", "leour", "mlUN", "lrun", "lrUN", "slunt", "leun", " lmun", "slUN", "llen", "Lunn", "plUn", "lUn", "llon", "Lang", "slen", "lmun", " lunn", "lour", "slun", "LUN", "LUn", "leunt", "Lut", "llmun", "leUn", "llut", "lunt", "mlUn", "lrang", "lrour", " lUn", "Lon", "slut", "lang", "Lum", "len", "llun", " lum", " lUN", "Len", "plunt", "slon", "leang"]}}
{"project": "qemu", "commit_id": "3e80bf9351f8fec9085c46df6da075efd5e71003", "target": 1, "func": "static int do_sendv_recvv(int sockfd, struct iovec *iov, int len, int offset,\n\n                          int do_sendv)\n\n{\n\n    int ret, diff, iovlen;\n\n    struct iovec *last_iov;\n\n\n\n    /* last_iov is inclusive, so count from one.  */\n\n    iovlen = 1;\n\n    last_iov = iov;\n\n    len += offset;\n\n\n\n    while (last_iov->iov_len < len) {\n\n        len -= last_iov->iov_len;\n\n\n\n        last_iov++;\n\n        iovlen++;\n\n    }\n\n\n\n    diff = last_iov->iov_len - len;\n\n    last_iov->iov_len -= diff;\n\n\n\n    while (iov->iov_len <= offset) {\n\n        offset -= iov->iov_len;\n\n\n\n        iov++;\n\n        iovlen--;\n\n    }\n\n\n\n    iov->iov_base = (char *) iov->iov_base + offset;\n\n    iov->iov_len -= offset;\n\n\n\n    {\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n        struct msghdr msg;\n\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_iov = iov;\n\n        msg.msg_iovlen = iovlen;\n\n\n\n        do {\n\n            if (do_sendv) {\n\n                ret = sendmsg(sockfd, &msg, 0);\n\n            } else {\n\n                ret = recvmsg(sockfd, &msg, 0);\n\n            }\n\n        } while (ret == -1 && errno == EINTR);\n\n#else\n\n        struct iovec *p = iov;\n\n        ret = 0;\n\n        while (iovlen > 0) {\n\n            int rc;\n\n            if (do_sendv) {\n\n                rc = send(sockfd, p->iov_base, p->iov_len, 0);\n\n            } else {\n\n                rc = qemu_recv(sockfd, p->iov_base, p->iov_len, 0);\n\n            }\n\n            if (rc == -1) {\n\n                if (errno == EINTR) {\n\n                    continue;\n\n                }\n\n                if (ret == 0) {\n\n                    ret = -1;\n\n                }\n\n                break;\n\n            }\n\n            if (rc == 0) {\n\n                break;\n\n            }\n\n            ret += rc;\n\n            iovlen--, p++;\n\n        }\n\n#endif\n\n    }\n\n\n\n    /* Undo the changes above */\n\n    iov->iov_base = (char *) iov->iov_base - offset;\n\n    iov->iov_len += offset;\n\n    last_iov->iov_len += diff;\n\n    return ret;\n\n}\n", "idx": 20032, "substitutes": {"sockfd": ["ssackd", "sigfile", "sigfd", "sOCKfd", "sackd", "sockeddir", "sockedFD", " sockeddir", "soydir", "sockedfile", "ssockstream", "ssockfd", "sOCKfs", "sockFD", "ssockd", " sockdir", " sipfd", "ssockFD", "sigdir", "soyFD", "sckstream", "sckdir", " sockFD", " sockedfs", "sackdir", "sinkfile", "socksptr", "sckFD", "socksfile", "sinkptr", " sockptr", "socksdir", "socksfd", "soyfs", "ssackstream", "sinkd", "ssockfile", "sigfc", "sockedfs", "sockstream", "sinkFD", " sockedfile", "sockfc", " sockfc", " sipptr", "sockedfd", "sackfd", "sackFD", "sipFD", "sackfile", " sockedfd", "sinkfd", "sipfile", "sckfd", "sockfs", "sinkdir", "ssackfile", "sackstream", "ssackfd", "ssackFD", "sockptr", "sckfile", " sipFD", "socksfc", "sockedfc", " sockedFD", " sockedfc", "sockdir", " sockfs", "socksFD", " sockfile", " sipfile", "ssackdir", "sinkstream", "sipfd", "sipptr", "sockfile", "sOCKdir", "soyfd", "sockd", "ssockdir", "sOCKFD", "sckd"], "iov": ["yon", "img", "username", "ir", "imp", "av", "vp", "lov", "iour", "established", "conv", "obj", "iv", "vg", "inv", "veh", "riot", "jp", "comm", "nil", "iper", "ux", "fp", "browser", "serv", "ij", "np", "server", "uart", "norm", "iev", "prov", "iop", "dl", "ovi", "v", "mu", "gra", "soc", "igroup", "pkg", "voc", "brother", "vr", "iol", "version", "iu", "kov", "minecraft", "drm", "iph", "ei", "mom", "buf", "voice", "vec", "iq", "ilo", "sov", "uv", "mus", "wikipedia", "dyl", "vision", "nov", "icon", "vector", "vo", "ech", "river", "phy", "ever", "uj", "mpeg", "rov", "cmd", "von", "isco", "liv", "src", "tv", "seq", "iva", "chrom", "iat"], "len": ["pos", "lp", "loc", "l", "el", "nt", "size", "lon", "lf", "en", "list", "ll", "num", "end", "le", "compl", "syn", "vec", "dl", "il", "length", "split", "off", "fin", "unit", "ln", "limit", "iter", "lt", "nl", "half", "rot", "local", "val", "L", "cmp", "neg", "ell", "n", "align", "mult", "lan", "alt", "del", "lim", "ls", "lang", "ld", "pl", "net", "Len", "elt", "seq", "hl"], "offset": ["Offset", "loc", "error", "size", "lon", "pad", "slot", "shift", "base", "point", "length", "inter", "half", "origin", "attribute", "buffer", "fp", "index", "t", "equal", "aff", "timeout", "set", "end", "tmp", "onet", "start", "pointer", "limit", "reset", "range", "update", "adjusted", "o", "align", "elt", "l", "seed", "location", "ow", "delay", "prefix", "address", "attr", "addr", "cmp", "alt", "eta", "alpha", "lower", "pos", "op", "padding", "position", "off", "unit", "area", "ext", "rot", "ref", "et", "extra", "OFF", "ff", "iat"], "do_sendv": ["doPsendup", "do_sev", "do_createvc", "doPsendvr", "doedexportvt", "do_exportv", "do_sendo", "do_sendev", "doedexportv", "do_poseo", "doPfailup", "do_parseo", "do_poseev", "do_sendvr", "do_senduv", "do_transferv", "do_switchv", "do_sendvv", "do_useconv", "do_parsev", "doPfailv", "do_createvv", "do_seup", "do_useev", "doedsendv", "do_failup", "do_failuv", "do_transferup", "do_sendvt", "doPfailuv", "doedexportvc", "do_sendup", "do_parseconv", "do_switchvv", "doPsenduv", "doedsendvc", "do_transfervr", "do_usev", "doPfailvr", "do_exportvc", "do_switchvt", "do_posev", "do_exportvt", "do_sendvc", "do_useo", "doPsendv", "do_failv", "do_createvt", "do_parseev", "do_createv", "do_transferuv", "do_seuv", "doedexportvv", "do_sevr", "do_switchvc", "doedsendvt", "do_sendconv", "do_exportvv", "do_failvr", "doedsendvv", "do_poseconv"], "ret": ["round", "dt", "rt", "arg", "rs", "nz", "get", "cat", "jp", "nil", "not", "url", "rets", "mem", "el", "t", "flag", "desc", "en", "result", "reset", "RET", "re", "try", "x", "resp", "fun", "elt", "err", "rm", "res", "nt", "pret", "num", "xt", "Ret", "ar", "tr", "mt", "reg", "progress", "ptr", "lt", "ft", "det", "j", "att", "def", "print", "alt", "got", "gt", "arr", "ll", "at", "gc", "count", "out", "fin", "off", "cont", "rem", "success", "rev", "cmd", "ext", "rot", "rel", "ref", "r", "val", "repl", "uf"], "diff": ["loc", "dist", "deg", "pad", "desc", "dt", "dep", "shift", "deb", "change", "iff", "delay", "mod", "dl", "length", "step", "split", "d", "Diff", "label", "attr", "progress", " difference", "range", "ind", "ext", "changed", "dir", "note", "rel", "cmp", "def", "cond", "extra", "eff", "df", "alt", "del", "different", "dim", "mix", "fun", "comp", "part", "elt", "trans"], "iovlen": ["voicelib", "iovlib", "ivlength", "novlif", "iovli", "kovlib", "convnum", "livelt", "chromellen", "iovlif", "iovellen", "livlen", "kovlan", "livdepth", "iovcompl", "iovdepth", "novlen", "ievln", "ieven", "iumLen", "iovLen", "chromlan", "novLen", "livlan", "liven", "convlan", "ievld", "iumlen", "voicelen", "chromcompl", "iovld", "kovlen", "livLen", "livld", "ivlen", "novlength", "novsl", "ievdepth", "novli", "kovellen", "ievelt", "ivlan", "iovlan", "voicelan", "ivlif", "iumlength", "livcompl", "ivLen", "ivcompl", "iovnum", "chromli", "convlen", "chromLen", "ibrlen", "chromlong", "noven", "livlong", "ievsl", "ievlen", "chromen", "ibrln", "kovnum", "novln", "voiceld", "livellen", "ibrsl", "iovlength", "ivli", "iovelt", "iumlif", "ioven", "voicenum", "convlib", "iovln", "ibren", "iovlong", "iovsl", "iven", "kovlong", "chromlen", "voicedepth", "voiceelt", "novlan"], "last_iov": [" last_iv", "last___conv", "last_iv", "last_liv", "last_conv", "last_____iev", "last___iov", "last___vr", "last___iour", "last_ij", "last_iour", "lastremiov", " last_ovi", " last_ibr", "last_____ij", "last_ovi", "last_vg", "used____iev", "last___voice", "lastOnemus", "lastMovi", "lastMiv", "last____iov", "used_iev", "last_____iov", "used____iov", "lastremnov", "last_nov", " last__conv", " last_nov", " last_vg", "last___vg", "last_voice", " last__mus", "lastOneiov", "last_____iour", " last_mus", " last_conv", "lastMij", "used_vr", "lastremliv", "lastOneconv", "last_vr", "last___liv", "last____iev", "lastobjnov", "lastobjiov", "lastMiov", "last__mus", "last___mus", "last___ij", "lastobjliv", " last_liv", "used_iour", "used____iour", " last_iev", "last____vr", " last__iov", " last_voice", "last_mus", " last_iour", "last__conv", "last__vg", "last_iev", "last___iev", "used____vr", "lastremibr", "lastobjibr", "lastOnevg", "last_ibr", "last__iov", " last__vg", " last_ij", "used_iov", " last_vr", "last____iour"], "msg": ["error", "ag", "sg", "tx", "g", "arg", "header", "mn", "mat", "news", "obj", "get", "req", "comm", "cm", "module", "gen", "mem", "game", "desc", "list", "gent", "gz", "sum", "v", "doc", "call", "pkg", "summary", "resp", "status", "l", "res", "og", "buf", "mt", "stat", "send", "all", "addr", "say", "Msg", "j", "body", "gr", "cfg", "str", "mess", "txt", "nm", "man", "m", "arr", "args", "md", "mail", "config", "op", "gs", "out", "dr", "data", "cmd", "tag", "message", "mg", "vol", "gm", "ms", "seq"], "p": ["pos", "lp", "prev", "np", "dp", "l", "perm", "t", "wp", "i", "pp", "proc", "q", "h", "bp", "ctx", "port", "pc", "pard", "e", "per", "op", "xp", "vp", "u", "tp", "conv", "rep", "d", "v", "pro", "pb", "ip", "ps", "param", "pm", "mp", "c", "pkg", "pt", "up", "j", "r", "jp", "iat", "n", "pat", "o", "pre", "par", "pa", "ep", "cp", "f", "fp", "part", "P", "pai", "ap", "m"], "rc": ["con", "round", "cs", "rob", "cv", "res", "tc", "ck", "desc", "proc", "result", "ec", "rx", "enc", "ry", "pc", "rt", "gc", "cur", "rs", "rr", "cc", "bc", "rec", "clus", "cd", "RC", "rl", "uc", "cmd", "rev", "cr", "r", "cmp", "dc", "fc", "ce", "ack", "cb", "nc", "row", "sr", "roc", "ro", "resp", "nr", "src", "arc", "ctr", "sc", "red", "err"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int vp9_decode_frame(AVCodecContext *ctx, void *frame,\n\n                            int *got_frame, AVPacket *pkt)\n\n{\n\n    const uint8_t *data = pkt->data;\n\n    int size = pkt->size;\n\n    VP9Context *s = ctx->priv_data;\n\n    int res, tile_row, tile_col, i, ref, row, col;\n\n    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&\n\n                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);\n\n    ptrdiff_t yoff, uvoff, ls_y, ls_uv;\n\n    AVFrame *f;\n\n    int bytesperpixel;\n\n\n\n    if ((res = decode_frame_header(ctx, data, size, &ref)) < 0) {\n\n        return res;\n\n    } else if (res == 0) {\n\n        if (!s->s.refs[ref].f->buf[0]) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Requested reference %d not available\\n\", ref);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if ((res = av_frame_ref(frame, s->s.refs[ref].f)) < 0)\n\n            return res;\n\n        ((AVFrame *)frame)->pts = pkt->pts;\n\n#if FF_API_PKT_PTS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        ((AVFrame *)frame)->pkt_pts = pkt->pts;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n        ((AVFrame *)frame)->pkt_dts = pkt->dts;\n\n        for (i = 0; i < 8; i++) {\n\n            if (s->next_refs[i].f->buf[0])\n\n                ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n            if (s->s.refs[i].f->buf[0] &&\n\n                (res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)\n\n                return res;\n\n        }\n\n        *got_frame = 1;\n\n        return pkt->size;\n\n    }\n\n    data += res;\n\n    size -= res;\n\n\n\n    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly) {\n\n        if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0])\n\n            vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n        if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n            (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP], &s->s.frames[CUR_FRAME])) < 0)\n\n            return res;\n\n    }\n\n    if (s->s.frames[REF_FRAME_MVPAIR].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR]);\n\n    if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n        (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR], &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    if (s->s.frames[CUR_FRAME].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[CUR_FRAME]);\n\n    if ((res = vp9_alloc_frame(ctx, &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    f = s->s.frames[CUR_FRAME].tf.f;\n\n    f->key_frame = s->s.h.keyframe;\n\n    f->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    ls_y = f->linesize[0];\n\n    ls_uv =f->linesize[1];\n\n\n\n    if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0] &&\n\n        (s->s.frames[REF_FRAME_MVPAIR].tf.f->width  != s->s.frames[CUR_FRAME].tf.f->width ||\n\n         s->s.frames[REF_FRAME_MVPAIR].tf.f->height != s->s.frames[CUR_FRAME].tf.f->height)) {\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n    }\n\n\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->next_refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n        if (s->s.h.refreshrefmask & (1 << i)) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);\n\n        } else if (s->s.refs[i].f->buf[0]) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i]);\n\n        }\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (ctx->hwaccel) {\n\n        res = ctx->hwaccel->start_frame(ctx, NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->decode_slice(ctx, pkt->data, pkt->size);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->end_frame(ctx);\n\n        if (res < 0)\n\n            return res;\n\n        goto finish;\n\n    }\n\n\n\n    // main tile decode loop\n\n    bytesperpixel = s->bytesperpixel;\n\n    memset(s->above_partition_ctx, 0, s->cols);\n\n    memset(s->above_skip_ctx, 0, s->cols);\n\n    if (s->s.h.keyframe || s->s.h.intraonly) {\n\n        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n\n    } else {\n\n        memset(s->above_mode_ctx, NEARESTMV, s->cols);\n\n    }\n\n    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n\n    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_segpred_ctx, 0, s->cols);\n\n    s->pass = s->s.frames[CUR_FRAME].uses_2pass =\n\n        ctx->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;\n\n    if ((res = update_block_buffers(ctx)) < 0) {\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Failed to allocate block buffers\\n\");\n\n        return res;\n\n    }\n\n    if (s->s.h.refreshctx && s->s.h.parallelmode) {\n\n        int j, k, l, m;\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            for (j = 0; j < 2; j++)\n\n                for (k = 0; k < 2; k++)\n\n                    for (l = 0; l < 6; l++)\n\n                        for (m = 0; m < 6; m++)\n\n                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n\n                                   s->prob.coef[i][j][k][l][m], 3);\n\n            if (s->s.h.txfmmode == i)\n\n                break;\n\n        }\n\n        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;\n\n        ff_thread_finish_setup(ctx);\n\n    } else if (!s->s.h.refreshctx) {\n\n        ff_thread_finish_setup(ctx);\n\n    }\n\n\n\n    do {\n\n        yoff = uvoff = 0;\n\n        s->b = s->b_base;\n\n        s->block = s->block_base;\n\n        s->uvblock[0] = s->uvblock_base[0];\n\n        s->uvblock[1] = s->uvblock_base[1];\n\n        s->eob = s->eob_base;\n\n        s->uveob[0] = s->uveob_base[0];\n\n        s->uveob[1] = s->uveob_base[1];\n\n\n\n        for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {\n\n            set_tile_offset(&s->tile_row_start, &s->tile_row_end,\n\n                            tile_row, s->s.h.tiling.log2_tile_rows, s->sb_rows);\n\n            if (s->pass != 2) {\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    int64_t tile_size;\n\n\n\n                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&\n\n                        tile_row == s->s.h.tiling.tile_rows - 1) {\n\n                        tile_size = size;\n\n                    } else {\n\n                        tile_size = AV_RB32(data);\n\n                        data += 4;\n\n                        size -= 4;\n\n                    }\n\n                    if (tile_size > size) {\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);\n\n                    if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    data += tile_size;\n\n                    size -= tile_size;\n\n                }\n\n            }\n\n\n\n            for (row = s->tile_row_start; row < s->tile_row_end;\n\n                 row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {\n\n                struct VP9Filter *lflvl_ptr = s->lflvl;\n\n                ptrdiff_t yoff2 = yoff, uvoff2 = uvoff;\n\n\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    set_tile_offset(&s->tile_col_start, &s->tile_col_end,\n\n                                    tile_col, s->s.h.tiling.log2_tile_cols, s->sb_cols);\n\n\n\n                    if (s->pass != 2) {\n\n                        memset(s->left_partition_ctx, 0, 8);\n\n                        memset(s->left_skip_ctx, 0, 8);\n\n                        if (s->s.h.keyframe || s->s.h.intraonly) {\n\n                            memset(s->left_mode_ctx, DC_PRED, 16);\n\n                        } else {\n\n                            memset(s->left_mode_ctx, NEARESTMV, 8);\n\n                        }\n\n                        memset(s->left_y_nnz_ctx, 0, 16);\n\n                        memset(s->left_uv_nnz_ctx, 0, 32);\n\n                        memset(s->left_segpred_ctx, 0, 8);\n\n\n\n                        memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));\n\n                    }\n\n\n\n                    for (col = s->tile_col_start;\n\n                         col < s->tile_col_end;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        // FIXME integrate with lf code (i.e. zero after each\n\n                        // use, similar to invtxfm coefficients, or similar)\n\n                        if (s->pass != 1) {\n\n                            memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));\n\n                        }\n\n\n\n                        if (s->pass == 2) {\n\n                            decode_sb_mem(ctx, row, col, lflvl_ptr,\n\n                                          yoff2, uvoff2, BL_64X64);\n\n                        } else {\n\n                            decode_sb(ctx, row, col, lflvl_ptr,\n\n                                      yoff2, uvoff2, BL_64X64);\n\n                        }\n\n                    }\n\n                    if (s->pass != 2) {\n\n                        memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));\n\n                    }\n\n                }\n\n\n\n                if (s->pass == 1) {\n\n                    continue;\n\n                }\n\n\n\n                // backup pre-loopfilter reconstruction data for intra\n\n                // prediction of next row of sb64s\n\n                if (row + 8 < s->rows) {\n\n                    memcpy(s->intra_pred_data[0],\n\n                           f->data[0] + yoff + 63 * ls_y,\n\n                           8 * s->cols * bytesperpixel);\n\n                    memcpy(s->intra_pred_data[1],\n\n                           f->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                    memcpy(s->intra_pred_data[2],\n\n                           f->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                }\n\n\n\n                // loopfilter one row\n\n                if (s->s.h.filter.level) {\n\n                    yoff2 = yoff;\n\n                    uvoff2 = uvoff;\n\n                    lflvl_ptr = s->lflvl;\n\n                    for (col = 0; col < s->cols;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);\n\n                    }\n\n                }\n\n\n\n                // FIXME maybe we can make this more finegrained by running the\n\n                // loopfilter per-block instead of after each sbrow\n\n                // In fact that would also make intra pred left preparation easier?\n\n                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);\n\n            }\n\n        }\n\n\n\n        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {\n\n            adapt_probs(s);\n\n            ff_thread_finish_setup(ctx);\n\n        }\n\n    } while (s->pass++ == 1);\n\n    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n\n\nfinish:\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->s.refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->s.refs[i]);\n\n        if (s->next_refs[i].f->buf[0] &&\n\n            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)\n\n            return res;\n\n    }\n\n\n\n    if (!s->s.h.invisible) {\n\n        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)\n\n            return res;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    return pkt->size;\n\n}\n", "idx": 20035, "substitutes": {"ctx": ["ctl", "cv", "history", " cx", "tc", "np", "ca", "tz", "ck", "tx", "p", "mc", "cn", "kt", "rt", "gc", "setup", "cas", "config", "cf", "tmp", "kb", "jac", "ct", "cc", "bc", "kw", "conv", "cpu", "hw", "obj", "self", "wx", "sys", "js", "conn", "req", "c", "cmd", "pkg", "jp", "context", "cmp", "cfg", "cm", "act", "cu", "cb", "nc", "anc", "qt", "xc", "cp", "rc", "ac", "ctr", "sc", "conf", "iat"], "frame": ["next", "offset", "index", "channel", "error", "face", "form", "process", "fram", "none", "movie", "window", "component", "p", "frames", "feature", "zero", "base", "fb", "e", "fr", "setup", "point", "cf", "header", "Frame", "profile", "cast", "rame", "name", "image", "zo", "session", "pointer", "video", "instance", "response", "object", "feat", "iframe", "reset", "id", "event", "flow", "embed", "draw", "def", "fc", "ce", "sequence", "request", "info", "block", "ence", "chain", "show", "scene", "type"], "got_frame": [" got_", "got_", "got_response", " got_response", " got_state", "received_", " got_frames", "got_frames", "get_", "got_state"], "pkt": ["spnt", "proct", "mmsg", "mwk", "Packet", "ppux", "cacket", "spkt", "pct", " pqt", "cpck", "mnt", "pmsg", "pront", "spwk", " pwk", "mck", "pqt", "cnt", "pux", "ppacket", "spux", "spacket", "cck", "packet", "mqt", "mct", "mkt", "proacket", "Pnt", "cpkt", "pck", "spqt", "cpacket", " pmsg", "ckt", "Pct", "ppwk", " packet", " pck", "macket", "pnt", "Pmsg", " pux", "pwk", "Pkt", " pct", "cpwk", "prokt", "ppkt", " pnt"], "data": ["next", "mem", "error", "box", "size", "t", "window", "pad", "p", "input", "buf", "dat", "ata", "map", "done", "length", "step", "content", "name", "image", "out", "d", "DATA", "bytes", "mu", "Data", "video", "area", "read", "value", "json", "batch", "message", "table", "raw", "str", "now", "info", " DATA", "len", "buffer", "text", "trans", "sample"], "s": ["z", "tx", "details", "ess", "st", "g", "rs", "vs", "self", "sys", "c", "es", "comm", "fs", "space", "spec", "ex", "sl", "os", "t", "settings", "sh", "sp", "sm", "set", "qs", "sers", "S", "ss", "v", "sts", "ps", "xs", "n", "o", "ts", "ls", "parts", "stats", "a", "ds", "cs", "sam", "times", "w", "sb", "ses", "changes", "sf", "th", "sv", "stat", "sw", "js", "gets", "state", "ssl", "go", "tests", "b", "has", "y", "utils", "hs", "args", "p", "ins", "sq", "aws", "h", "is", "bs", "gs", "u", "ports", "ns", "ties", "sports", "ats", "r", "less", "ims", "ms", "conf", "its"], "res": ["pos", "rez", "os", "bits", "details", "proc", "result", "results", "hash", "ress", "ret", "zero", "expr", "ber", "vals", "pres", "resource", "rs", "resolution", "ries", "values", "off", "out", "rep", "conv", "reg", "Res", "resh", "progress", "ps", "response", "rem", "js", "success", "reset", "rev", "re", "req", "css", "rel", "pers", "r", "plain", "val", "gr", "def", "rss", "RES", "pas", "fs", "sol", "len", "resp", "status", "rest", "chain", "ms", "conf", "red", "err"], "tile_row": ["window_row", "window_rc", "tile_rect", "tile_rc", "tile_cell", "window_rect", "window_cell"], "tile_col": ["tilexcolumn", "col_ct", "tilexcol", "tile_ct", "tilexct", "col_row", "col_column", "tilexrow", "col_col", "tile_column"], "i": ["init", "ic", "index", "history", "ij", "si", "t", "ci", "slice", "hi", "p", "ei", "ki", "qi", "list", "me", "ski", "ir", "remote", "q", "li", "is", "\u0438", "ri", "g", "I", "ai", "di", "start", "cli", "ip", "mi", "pi", "c", "ind", "id", "oi", "xi", "r", "ti", "batch", "ui", "gi", "n", "ji", "ami", "multi", "uri", "bi", "x", "ims", "info", "zi", "ini", "sim", "gu", "status", "chain", "it", "ix", "iu", "y", "ii"], "ref": ["offset", "pos", "round", "index", "mem", "deg", "img", "cell", "num", "remote", "bad", "ret", "ob", "buf", "fr", "arg", "resource", "Ref", "map", "REF", "link", "prefix", "prop", "rec", "grab", "rep", "pro", "bug", "reference", "inter", "obj", "ef", "rem", "tab", "addr", "reset", "range", "re", "rev", "req", "id", "ror", "ext", "rel", "tag", "val", "def", "raw", "diff", "key", "orig", "alias", "cb", "block", "ro", "resp", "url", "rf", "buff", "type"], "row": ["pos", "index", "w", "cell", "num", "ow", "th", "rect", "rs", "group", "tr", "ox", "co", "ptr", "roll", "range", "ror", "r", "rid", "height", "rows", "key", "ro", "rc", "vr", "tile"], "col": ["pos", "con", "loc", "fn", "cell", "num", "win", "column", "pc", "color", "il", "ct", "ch", "co", "cat", "c", "COL", "pt", "rot", "val", "line", "cal", "coll", "fc", "coord", "cp", "tile"], "yoff": [" yOff", "syov", "syOFF", "yOff", "syoff", "zOFF", "syOff", " yov", "zoff", "zov", "zOff", "yov", "yOFF", " yOFF"], "uvoff": ["uioffset", "uuoff", "uiOFF", "ueoff", "uuoffset", "ueOFF", "uvOFF", "uiOff", "uioff", "ueoffset", "ueOff", "uuOFF", "uvOff", "uvoffset", "uuOff"], "ls_y": ["ls_xy", "vs_y", "ls2y", "ls_my", "vs_yy", "vs_xy", "vs_my", "ls2yy", "ls_yy", "ls2my", "ls2xy"], "ls_uv": ["tl_x", "ls_u", "tl_u", "tl_cv", "ls2x", "ls2u", "tl_uv", "ls2cv", "ls_cv", "ls2uv", "ls_x"], "f": ["fu", "form", "of", "t", "fab", "p", "lf", "sf", "h", "q", "fb", "e", "fr", "g", "cf", "fac", "xf", "fg", "v", "alf", "fe", "d", "ft", "ef", "c", "ff", "elf", "fo", "o", "bf", "fi", "fc", "fs", "fm", "info", "fx", "fw", "uf", "full", "fp", "F", "b", "file", "fl"], "bytesperpixel": ["bytesPercell", "bytesPerpixel", "bytesPERframe", "byteslastframe", "bitsPERframe", "bitsPERpixel", "bytesPERcell", "bitsperpixel", "bytesperframe", "bytespercell", "bitspercell", "bytesPerframe", "bitsPERcell", "bitsperframe", "bytesPERpixel", "byteslastpixel", "byteslastcell"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t gt64120_readl (void *opaque,\n\n                               target_phys_addr_t addr, unsigned size)\n\n{\n\n    GT64120State *s = opaque;\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    uint32_t val;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfff) >> 2;\n\n    switch (saddr) {\n\n\n\n    /* CPU Configuration */\n\n    case GT_MULTI:\n\n        /* Only one GT64xxx is present on the CPU bus, return\n\n           the initial value */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Error Report */\n\n    case GT_CPUERR_ADDRLO:\n\n    case GT_CPUERR_ADDRHI:\n\n    case GT_CPUERR_DATALO:\n\n    case GT_CPUERR_DATAHI:\n\n    case GT_CPUERR_PARITY:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Sync Barrier */\n\n    case GT_PCI0SYNC:\n\n    case GT_PCI1SYNC:\n\n        /* Reading those register should empty all FIFO on the PCI\n\n           bus, which are not emulated. The return value should be\n\n           a random value that should be ignored. */\n\n        val = 0xc000ffee;\n\n        break;\n\n\n\n    /* ECC */\n\n    case GT_ECC_ERRDATALO:\n\n    case GT_ECC_ERRDATAHI:\n\n    case GT_ECC_MEM:\n\n    case GT_ECC_CALC:\n\n    case GT_ECC_ERRADDR:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    case GT_CPU:\n\n    case GT_SCS10LD:\n\n    case GT_SCS10HD:\n\n    case GT_SCS32LD:\n\n    case GT_SCS32HD:\n\n    case GT_CS20LD:\n\n    case GT_CS20HD:\n\n    case GT_CS3BOOTLD:\n\n    case GT_CS3BOOTHD:\n\n    case GT_SCS10AR:\n\n    case GT_SCS32AR:\n\n    case GT_CS20R:\n\n    case GT_CS3BOOTR:\n\n    case GT_PCI0IOLD:\n\n    case GT_PCI0M0LD:\n\n    case GT_PCI0M1LD:\n\n    case GT_PCI1IOLD:\n\n    case GT_PCI1M0LD:\n\n    case GT_PCI1M1LD:\n\n    case GT_PCI0IOHD:\n\n    case GT_PCI0M0HD:\n\n    case GT_PCI0M1HD:\n\n    case GT_PCI1IOHD:\n\n    case GT_PCI1M0HD:\n\n    case GT_PCI1M1HD:\n\n    case GT_PCI0IOREMAP:\n\n    case GT_PCI0M0REMAP:\n\n    case GT_PCI0M1REMAP:\n\n    case GT_PCI1IOREMAP:\n\n    case GT_PCI1M0REMAP:\n\n    case GT_PCI1M1REMAP:\n\n    case GT_ISD:\n\n        val = s->regs[saddr];\n\n        break;\n\n    case GT_PCI0_IACK:\n\n        /* Read the IRQ number */\n\n        val = pic_read_irq(isa_pic);\n\n        break;\n\n\n\n    /* SDRAM and Device Address Decode */\n\n    case GT_SCS0LD:\n\n    case GT_SCS0HD:\n\n    case GT_SCS1LD:\n\n    case GT_SCS1HD:\n\n    case GT_SCS2LD:\n\n    case GT_SCS2HD:\n\n    case GT_SCS3LD:\n\n    case GT_SCS3HD:\n\n    case GT_CS0LD:\n\n    case GT_CS0HD:\n\n    case GT_CS1LD:\n\n    case GT_CS1HD:\n\n    case GT_CS2LD:\n\n    case GT_CS2HD:\n\n    case GT_CS3LD:\n\n    case GT_CS3HD:\n\n    case GT_BOOTLD:\n\n    case GT_BOOTHD:\n\n    case GT_ADERR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Configuration */\n\n    case GT_SDRAM_CFG:\n\n    case GT_SDRAM_OPMODE:\n\n    case GT_SDRAM_BM:\n\n    case GT_SDRAM_ADDRDECODE:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Parameters */\n\n    case GT_SDRAM_B0:\n\n    case GT_SDRAM_B1:\n\n    case GT_SDRAM_B2:\n\n    case GT_SDRAM_B3:\n\n        /* We don't simulate electrical parameters of the SDRAM.\n\n           Just return the last written value. */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Device Parameters */\n\n    case GT_DEV_B0:\n\n    case GT_DEV_B1:\n\n    case GT_DEV_B2:\n\n    case GT_DEV_B3:\n\n    case GT_DEV_BOOT:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Record */\n\n    case GT_DMA0_CNT:\n\n    case GT_DMA1_CNT:\n\n    case GT_DMA2_CNT:\n\n    case GT_DMA3_CNT:\n\n    case GT_DMA0_SA:\n\n    case GT_DMA1_SA:\n\n    case GT_DMA2_SA:\n\n    case GT_DMA3_SA:\n\n    case GT_DMA0_DA:\n\n    case GT_DMA1_DA:\n\n    case GT_DMA2_DA:\n\n    case GT_DMA3_DA:\n\n    case GT_DMA0_NEXT:\n\n    case GT_DMA1_NEXT:\n\n    case GT_DMA2_NEXT:\n\n    case GT_DMA3_NEXT:\n\n    case GT_DMA0_CUR:\n\n    case GT_DMA1_CUR:\n\n    case GT_DMA2_CUR:\n\n    case GT_DMA3_CUR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Channel Control */\n\n    case GT_DMA0_CTRL:\n\n    case GT_DMA1_CTRL:\n\n    case GT_DMA2_CTRL:\n\n    case GT_DMA3_CTRL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Arbiter */\n\n    case GT_DMA_ARB:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Timer/Counter */\n\n    case GT_TC0:\n\n    case GT_TC1:\n\n    case GT_TC2:\n\n    case GT_TC3:\n\n    case GT_TC_CONTROL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* PCI Internal */\n\n    case GT_PCI0_CFGADDR:\n\n        val = phb->config_reg;\n\n        break;\n\n    case GT_PCI0_CFGDATA:\n\n        if (!(phb->config_reg & (1 << 31))) {\n\n            val = 0xffffffff;\n\n        } else {\n\n            val = pci_data_read(phb->bus, phb->config_reg, 4);\n\n        }\n\n        if (!(s->regs[GT_PCI0_CMD] & 1) && (phb->config_reg & 0x00fff800)) {\n\n            val = bswap32(val);\n\n        }\n\n        break;\n\n\n\n    case GT_PCI0_CMD:\n\n    case GT_PCI0_TOR:\n\n    case GT_PCI0_BS_SCS10:\n\n    case GT_PCI0_BS_SCS32:\n\n    case GT_PCI0_BS_CS20:\n\n    case GT_PCI0_BS_CS3BT:\n\n    case GT_PCI1_IACK:\n\n    case GT_PCI0_BARE:\n\n    case GT_PCI0_PREFMBR:\n\n    case GT_PCI0_SCS10_BAR:\n\n    case GT_PCI0_SCS32_BAR:\n\n    case GT_PCI0_CS20_BAR:\n\n    case GT_PCI0_CS3BT_BAR:\n\n    case GT_PCI0_SSCS10_BAR:\n\n    case GT_PCI0_SSCS32_BAR:\n\n    case GT_PCI0_SCS3BT_BAR:\n\n    case GT_PCI1_CMD:\n\n    case GT_PCI1_TOR:\n\n    case GT_PCI1_BS_SCS10:\n\n    case GT_PCI1_BS_SCS32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    default:\n\n        val = s->regs[saddr];\n\n        DPRINTF (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    if (!(s->regs[GT_CPU] & 0x00001000))\n\n        val = bswap32(val);\n\n\n\n    return val;\n\n}\n", "idx": 20054, "substitutes": {"opaque": ["Opatile", "Oposit", "Opaque", " opque", " opatile", "opaques", "opatile", " opaques", "oplatile", "Opque", "oposit", "poposit", "popaque", "Opaques", "ipaques", "oplaque", "ipque", "ipatile", "oplosit", "ipaque", "opque", "popaques", "popatile", "oplaques"], "addr": ["offset", "pos", "mem", "work", "loc", "res", "arr", "ord", "pad", "sh", "tx", "max", "var", "hash", "port", "kt", "adr", "map", "prefix", "node", "mt", "alloc", "ad", "address", "ptr", "add", "cmd", "id", "ref", "tag", "host", "align", "aro", "coord", "state", "arch", "block", "Address", "len", "rc", "src", "ix"], "size": ["offset", "mem", "cap", "z", "args", "w", "sh", "sp", "num", "h", "hash", "set", "count", "length", "name", "address", "m", "d", "start", "sn", "ize", "id", "n", "Size", "SIZE", "len", "ser", "type"], "s": ["hs", "ds", "os", "z", "t", "csv", "sb", "p", "ins", "store", "sq", "asm", "aws", "h", "is", "bs", "e", "g", "sv", "rs", "gs", "S", "ss", "ns", "sts", "socket", "single", "vs", "ps", "sports", "sn", "sys", "http", "js", "c", "tes", "es", "ats", "r", "comm", "n", "fs", "space", "y", "ts", "ssl", "ls", "ims", "an", "stats", "ms", "ex", "states", "b", "conf"], "phb": ["ahr", " phd", "grbg", "ahbg", "grr", "grb", "phr", "phbg", "phd", "ahb", "grd", "ahd", " phr", " phbg"], "val": ["bal", "pos", "au", "Val", "loc", "res", "arr", "sel", "rol", "ival", "valid", "tx", "var", "slot", "vt", "ctx", "VAL", "ret", "base", "compl", "find", "util", "vals", "arg", "buf", "pol", "vec", "crit", "fail", "prop", "aval", "stat", "v", "label", "bl", "value", "eval", "data", "msg", "lit", "rel", "ref", "dev", "cal", "def", "sol", "alt", "len", "vol", "al", "resp", "urg", "serv", "elt", "err"], "saddr": ["tsalign", "ssvar", "wsusr", "Shash", "ssstate", "sadmin", " ssrc", "ssrc", "dsaddr", "ssptr", "sbound", "saddress", "Saddr", "wsvar", "wsaddress", "sptr", "waddr", "daddress", "shost", " svar", "svar", " sstate", "ssadmin", " saddress", "tsaddr", " sadmin", " shash", "shash", "gaddr", "surg", "stsaddr", "walign", "ssurg", "gbound", "ssaddr", "gaddress", "ssaddress", "galign", "sstate", "daddr", "stsalign", " surg", "tsaddress", "susr", "tsbound", "dsusr", "dptr", " sptr", "Saddress", "stsurg", "wbound", "dsrc", "dsaddress", "Sptr", "ssalign", "Susr", "wsaddr", "dshost", "wshost", "sshash", "stsadmin", "wsstate", "waddress", " salign", "Shost", "salign"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    opt = qemu_opt_find(opts, name);\n\n    if (!opt) {\n\n        QemuOptDesc *desc = opts->list->desc;\n\n        int i;\n\n\n\n        for (i = 0; desc[i].name != NULL; i++) {\n\n            if (strcmp(desc[i].name, name) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (desc[i].name == NULL) {\n\n            if (i == 0) {\n\n                /* empty list -> allow any */;\n\n            } else {\n\n                fprintf(stderr, \"option \\\"%s\\\" is not valid for %s\\n\",\n\n                        name, opts->list->name);\n\n                return -1;\n\n            }\n\n        }\n\n        opt = qemu_mallocz(sizeof(*opt));\n\n        opt->name = qemu_strdup(name);\n\n        opt->opts = opts;\n\n        TAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n        if (desc[i].name != NULL) {\n\n            opt->desc = desc+i;\n\n        }\n\n    }\n\n    qemu_free((/* !const */ char*)opt->str);\n\n    opt->str = NULL;\n\n    if (value) {\n\n        opt->str = qemu_strdup(value);\n\n    }\n\n    if (qemu_opt_parse(opt) < 0) {\n\n        fprintf(stderr, \"Failed to parse \\\"%s\\\" for \\\"%s.%s\\\"\\n\", opt->str,\n\n                opts->list->name, opt->name);\n\n        qemu_opt_del(opt);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 20070, "substitutes": {"opts": ["ioptions", "OPts", " opcs", "iopths", "optypes", "opcs", "opttypes", " opms", "prots", "options", "opbs", "otps", "OPTS", "OPs", "optt", "optters", " opfs", "ops", "otTS", " cops", "operts", "optfs", "iopbs", "iopcs", "proTS", " coptypes", "optbs", "optts", "oprs", " copcs", "optTS", " opTS", "OPfs", "optrs", "operns", "optms", " ops", " optypes", "opertions", "iopps", " opns", "opters", "protions", "opns", "otts", "ottions", "operps", " oprs", "upt", "iopt", "opps", " options", "opfs", " opths", "optns", " opters", "iopts", "optps", "iopms", "opttions", "optcs", " opps", "upcs", "upbs", "optths", "opths", "operrs", "operms", "opms", "operters", " copts", "opTS", "upts", "props"], "name": ["na", "word", "error", "size", "format", "base", "option", "tree", "length", " NAME", "Name", "label", "dir", "admin", "common", "local", "number", "path", "module", "names", "NAME", "spec", "title", "mem", "cap", "ame", "none", "filename", "var", "list", "family", "syn", "ma", "doc", "description", "dev", "parent", "root", "n", "len", "ver", "code", "version", "class", "init", "comment", "term", "num", "normal", "prefix", "node", "group", "named", "all", "attr", "order", "note", "def", "str", "info", "nm", "no", "missing", "store", "out", "ns", "data", "in", "id", "ref", "tag", "new", "val", "member", "table", "key", "alias", "search", "nam", "type"], "value": ["word", "server", "format", "widget", "VALUE", "comment", "ter", "term", "result", "test", "option", "change", "expression", "property", "initial", "vp", "password", "values", "content", "Value", "other", "unit", "v", "label", "variable", "serial", "get", "instance", "description", "data", "json", "range", "update", "field", "version", "val", "message", "template", "summary", "raw", "str", "hello", "key", "vector", "state", "attribute", "function", "tv", "text", "event", "type"], "opt": ["temp", "nom", "error", "ok", "img", "pr", "slot", "test", "option", "rt", "arg", "crit", "copy", "OP", "alg", "obj", "iter", "cat", "eval", "req", "jp", "options", "art", "aux", "optim", "cho", "ost", "mem", "t", "plot", "max", "var", "adj", "timeout", "port", "ret", "zero", "tmp", "tip", "json", "update", "pt", "parent", "n", "usr", "ts", "x", "null", "open", "al", "ver", "it", "org", "err", "init", "anon", "nt", "term", "num", "proc", "expr", "buf", "prop", "tr", "stat", "alloc", "all", "adapt", "attr", "lt", "ip", "addr", "j", "def", "alt", "txt", "info", "go", "cp", "Opt", "p", "xy", "oss", "op", "out", "off", "select", "opted", "feat", "typ", "cmd", "ind", "ext", "lit", "id", "inst", "ref", "tag", "val", "coord", "dest"], "desc": ["next", "mem", "ds", "loc", "sort", "sel", "dist", "deg", "disc", "comment", "details", "dep", "sub", "md", "ec", "decl", "ctx", "Desc", "pres", "buf", "config", "des", "sec", "rec", "reg", "etc", "cd", "esc", "doc", "ptr", "pri", "obj", "asc", "description", "order", "req", "cmd", "msg", "eq", "dir", "ext", "ind", "dev", "rel", "cmp", "recent", "def", "str", "diff", "dict", "path", "dim", "info", "txt", "meta", "described", "der", "sc", "dest", "seq"], "i": ["iso", "size", "hi", "li", "ri", "g", "I", "ai", "di", "inter", "iter", "mi", "ji", "eu", "multi", "ii", "index", "ij", "t", "ci", "list", "phi", "v", "io", "cli", "pi", "try", "gi", "n", "fi", "bi", "x", "zi", "ini", "f", "it", "iu", "status", "err", "init", "ic", "l", "ei", "qi", "me", "wait", "k", "ip", "j", "ti", "uri", "info", "ie", "ix", "y", "m", "next", "si", "im", "p", "ki", "is", "u", "oi", "ind", "id", "in", "xi", "batch", "ui", "ims", "sim"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    Error *err = NULL;\n\n\n\n    if (!s->qdev.conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_report(\"unwanted /dev/sg*\");\n\n        return -1;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);\n\n    return 0;\n\n}\n", "idx": 20086, "substitutes": {"dev": ["mem", "ds", "adv", "os", "nt", "w", "de", "window", "Dev", "var", "md", "test", "dis", "remote", "query", "app", "device", "DEV", "av", "cam", "des", "ch", "d", "sw", "v", "serial", "hw", "ve", "obj", "sd", "conn", "spec", "cmd", "data", "driver", "att", "ev", "val", " Dev", "def", "raw", "env", "info", "gu", "Device", "ver", "tech", "devices", "scan", "vr", "dem", "serv", "conf", "dd"], "s": ["details", "g", "rs", "vs", "self", "se", "obj", "sys", "es", "comm", "fs", "params", "serv", "spec", "sl", "ex", "t", "settings", "sh", "sp", "set", "qs", "S", "ss", "v", "sts", "ps", "steps", "n", "ts", "ls", "stats", "bes", "services", "ies", "a", "ds", "sam", "cs", "l", "w", "sb", "as", "ses", "changes", "als", "ar", "south", "sv", "sw", "js", "j", "source", "mods", "tests", "states", "b", "y", "utils", "hs", "args", "ys", "i", "p", "store", "sq", "aws", "h", "is", "bs", "gs", "ports", "ns", "sports", "sd", "ats", "r", "eps", "less", "ims", "ms", "this", "its"], "err": ["here", "error", "res", "arr", "or", "die", "ez", "result", "Error", "test", "tar", "h", "gz", "kr", "ar", "ctx", "e", "buf", "eas", "exc", "fr", "mr", "rs", "rr", "ch", "out", "warn", "Er", "cli", "attr", "iter", "obj", "aaa", "ptr", "sys", "fee", "conn", "esp", "msg", "req", "cmd", "inv", "cr", "c", "erb", "r", "ev", "gr", "cfg", "eps", "cer", "str", "errors", "usr", "erd", "er", "notice", "txt", "eor", "later", "rn", "resp", "it", "der", "ex", "elt", "conf", "br"]}}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_update_frindex(EHCIState *ehci, int frames)\n\n{\n\n    int i;\n\n\n\n    if (!ehci_enabled(ehci)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < frames; i++) {\n\n        ehci->frindex += 8;\n\n\n\n        if (ehci->frindex == 0x00002000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n        }\n\n\n\n        if (ehci->frindex == 0x00004000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n            ehci->frindex = 0;\n\n            if (ehci->usbsts_frindex >= 0x00004000) {\n\n                ehci->usbsts_frindex -= 0x00004000;\n\n            } else {\n\n                ehci->usbsts_frindex = 0;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20095, "substitutes": {"ehci": ["ekcci", "ahcin", "hesscit", "ekdc", "althcgi", "ehcu", "ethcit", "ehini", "dercgi", "hesswife", "archcci", "khc", "Ohcu", "ethercgi", "iahcit", "hzcit", "Ehcos", "ehc", "graphcci", "ehwife", "althcci", "Ohc", "Ehcgi", "hcci", " ehwife", "ehdc", "althci", "vehcci", " ehcit", "ehdi", "hesscci", "hzcu", "hessci", "ehcell", "echci", "echcit", "Ohci", "ethercci", " ehcgi", " ehdi", "khcin", "khcit", "ehcgi", "echcci", "Ehcci", " ehcin", "iahdi", "khdc", "archci", "ehcit", "graphcit", "ekci", "hdi", "htmcit", "htmci", "vehcu", "vehci", "althcos", "khcell", "ehcci", "graphcu", "hzini", "khcos", "rahci", "ethercin", "ahc", "htmc", "echcgi", "Ehci", " ehco", "Ohcell", "ehco", "dercu", "archcit", "dercci", "hci", "graphci", "echdc", "ethercu", "rahcit", "hzci", "iahcci", "ahci", "ethcci", "khcgi", "htmcell", "Ohcci", "derci", "khci", "ekcit", " ehcu", "echcin", "ethci", "etherini", "vehdi", "ehcos", "echcu", "rahcu", "ahco", "archdi", "ethwife", "rahini", "hcit", "iahci", "ethercit", "khcci", " ehc", "khco", " ehcci", "ehcin", "khcu", "Ohcit", "etherci", "khdi"], "frames": ["frame", "times", "fps", "blocks", "fram", " processes", "bits", "Frames", "flags", "events", " fps", "ins", "requisites", "lines", "planes", "months", "inches", "ences", " frame", "plays", "files", "pages", "values", "hops", "bytes", "cells", "ations", "ours", "flows", "videos", "views", "fs", "ints", "reports", "weights", "dates", "faces", "features", "parts", "levels", "images", "links", " Frames", "states", "seconds"], "i": ["init", "ic", "index", "si", "ci", "im", " my", "ki", "qi", " ti", "li", " pi", "span", "\u0438", "is", "g", "I", " ii", "ai", "phi", " multi", " index", " wi", "di", " mi", "ip", " li", "mi", "pi", "ii", "ind", " j", "in", "j", "xi", "ti", "ui", " me", " f", " parts", " I", "multi", "gi", "fi", "ims", "bi", "print", "x", " x", " si", " di", " ni", " m", " iter", "ini", "sim", " bi", "zi", "gu", "it", "ix", "iu", " info", "y", " missing", " c", "m"]}}
{"project": "FFmpeg", "commit_id": "c9c55a56996836e7783fb27018834f230c553c98", "target": 0, "func": "static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)\n\n{\n\n    while (uls->id != CODEC_ID_NONE) {\n\n        if(mxf_match_uid(uls->uid, *uid, 16))\n\n            break;\n\n        uls++;\n\n    }\n\n    return uls;\n\n}\n", "idx": 20102, "substitutes": {"uls": [" MLS", "inces", "kj", "results", "aults", "imp", " us", "LCS", "fts", "rs", "aus", "ols", " sidx", "ults", " los", "ud", "uns", "eus", "lus", "uckles", "spec", "regon", " puls", "Us", "flags", "ult", " pulses", "ups", "tops", "qs", "ames", "missions", "uds", "ps", "GS", "uci", "ilot", " Ips", " sus", " sentiments", "urus", "cu", "ls", "lass", "ucc", "cus", "ishers", "ul", "cs", "acts", "umers", "sels", "amps", "des", "clus", " UCS", "phones", "uli", "cks", "ails", "ossus", "umes", "orts", "imil", "ix", "ulse", " populations", "US", "las", "ists", " vill", "args", "ull", "ins", "icas", "u", "rus", "ces", "ports", "ucl", "pes", "helps", " currents", "irms", "ulates", "UL", "ims", "us", "illus"], "uid": ["ul", "UID", "uh", "comment", "uu", "uk", "username", "user", "pid", "kt", "uint", "aw", "gc", "util", "sid", "who", "u", "pu", "cpu", "iq", "gain", "uv", "upload", "mu", "kid", "bid", "unit", "mask", "addr", "pet", "cat", "nu", "id", "tag", "rid", "uni", "oid", "std", "ud", "gpu", "unique", "du", "uri", "hn", "usr", "cu", "ua", "eus", "upid", "cum", "gin", "did", "vid", "us", "tu", "dd"]}}
{"project": "qemu", "commit_id": "85a67692d04e15a6b7d5a0e2b9d573d8bffbe108", "target": 0, "func": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            g_source_remove(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        s->polling = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (!s->connected)\n\n            qemu_chr_be_generic_open(chr);\n\n        s->connected = 1;\n\n    }\n\n}\n", "idx": 20105, "substitutes": {"chr": ["CHor", "charrb", " chor", " chrb", "cyr", "CHrt", "chnr", "Char", "charar", "ichrt", "cyrs", "chor", "chres", "cyre", "chrs", "chri", "ichres", "ichri", "charr", "chnrc", " chrt", "chrt", "charrs", "Chrs", "CHr", "chrb", "ichr", "ichor", "Chre", " chrs", "cyar", "Chrb", "CHres", "Chr", " chre", "Chrc", "Chri", "chrc", "chnrb", "chnri", "chre", "ichrc", " chres", "ichrb"], "connected": ["developed", "valid", " disconnected", "online", "fitted", "established", "called", "modified", "built", "joined", "updated", "present", "cond", "bound", "opened", "encrypted", "mounted", "connection", "loaded", "productive", "accessible", "reported", "shown", "pressed", "checked", "rolled", " attached", "licensed", "available", "enabled", "charged", "open", "successful", "ed", "registered", "status", "documented", "hidden", "provided", "responsive", "running", "closed", "authorized", "induced", "generated", "locked", "tested", "selected", "colored", "supported", "equipped", "ached", "fed", "functional", "disabled", "ready", "client", "linked", "owned", "controlled", "played", "created", "started", "socket", "success", "conn", "wired", "current", "connect", "powered", "visible", "nc", "ended", "initialized", "active"], "s": ["details", "g", "rs", "conv", "vs", "self", "se", "sys", "es", "comm", "sync", "fs", "acs", "spec", "serv", " ss", "server", "set", "qs", "S", "ss", "so", "sts", "ps", "ts", "ls", "stats", "services", "ies", "a", "ds", "cs", "sam", "l", "as", "sb", " cs", "ses", "als", "sv", "js", "j", "ssl", "b", "y", "m", "utils", "hs", "ys", "p", "client", "ins", "store", "sq", "asm", "aws", "h", "is", "bs", "gs", "ports", "ns", "sports", "pers", "ats", "eps", " self", " ps", "less", "ears", "ims", "ms", "search", "ssh"]}}
{"project": "FFmpeg", "commit_id": "544286b3d39365b30298ae07e66a755200b0895c", "target": 1, "func": "int h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format, width, height;\n\n\n\n    /* picture header */\n\n    if (get_bits(&s->gb, 22) != 0x20)\n\n        return -1;\n\n    skip_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1)\n\n        return -1;\t/* marker */\n\n    if (get_bits1(&s->gb) != 0)\n\n        return -1;\t/* h263 id */\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n\n\n    if (format != 7) {\n\n        s->h263_plus = 0;\n\n        /* H.263v1 */\n\n        width = h263_format[format][0];\n\n        height = h263_format[format][1];\n\n        if (!width)\n\n            return -1;\n\n\n\n        s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n\n\n        s->unrestricted_mv = get_bits1(&s->gb); \n\n        s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* SAC: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* advanced prediction mode: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* not PB frame */\n\n\n\n        s->qscale = get_bits(&s->gb, 5);\n\n        skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n    } else {\n\n        s->h263_plus = 1;\n\n        /* H.263v2 */\n\n        /* OPPTYPE */\n\n     \n\n        if (get_bits(&s->gb, 3) != 1) /* Update Full Extended PTYPE */\n\n            return -1;\n\n        format = get_bits(&s->gb, 3);\n\n                \n\n        skip_bits(&s->gb,1); /* Custom PCF */\n\n        umvplus_dec = get_bits(&s->gb, 1); /* Unrestricted Motion Vector */\n\n        skip_bits(&s->gb, 10);\n\n        skip_bits(&s->gb, 3); /* Reserved */\n\n        \n\n        /* MPPTYPE */\n\n        s->pict_type = get_bits(&s->gb, 3) + 1;\n\n        if (s->pict_type != I_TYPE &&\n\n            s->pict_type != P_TYPE)\n\n            return -1;\n\n        skip_bits(&s->gb, 7);\n\n        \n\n        /* Get the picture dimensions */\n\n        if (format == 6) {\n\n            /* Custom Picture Format (CPFMT) */\n\n            skip_bits(&s->gb, 4); /* aspect ratio */\n\n            width = (get_bits(&s->gb, 9) + 1) * 4;\n\n            skip_bits1(&s->gb);\n\n            height = get_bits(&s->gb, 9) * 4;\n\n#ifdef DEBUG \n\n            fprintf(stderr,\"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n\n#endif            \n\n        }\n\n        else {\n\n            width = h263_format[format][0];\n\n            height = h263_format[format][1];\n\n        }\n\n        \n\n        if ((width == 0) || (height == 0))\n\n            return -1;\n\n            \n\n        if (umvplus_dec) {\n\n            skip_bits1(&s->gb); /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n\n        }\n\n            \n\n        s->qscale = get_bits(&s->gb, 5);\n\n    }\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n    s->width = width;\n\n    s->height = height;\n\n    return 0;\n\n}\n", "idx": 20109, "substitutes": {"s": ["sg", "details", "results", "rs", "copy", "vs", "sys", "sets", "ants", "c", "es", "comm", "fs", "acs", "er", "params", "spec", "os", "ops", "set", "qs", "S", "ss", "sts", "ps", "n", "ts", "ls", "parts", "ains", "stats", "bis", "status", "err", "eds", "services", "ies", "comments", "ds", "cs", "sb", "as", "ses", "changes", "als", "ar", "sv", "des", "session", "js", "css", "tests", "states", "b", "y", "rates", "hs", "p", "ins", "ers", "sq", "aws", "is", "bs", "gs", "ports", "ns", "tes", "pers", "ats", "eps", "less", "ears", "ims", "ms", "search", "us", "conf", "its"], "format": ["missing", "init", "frame", "index", "use", "form", "style", "AT", "size", "t", "none", "settings", "list", "at", "port", "feature", "set", "color", "html", "scale", "option", "action", "sort", "prefix", "padding", "length", "lat", "stat", "position", "mat", "method", "unit", "label", "feat", "cat", "range", "commit", "fn", "ats", "tag", "date", "transform", "print", "act", "digit", "file", "Format", "dim", "flat", "title", "edit", "layout", "MAT", "function", "api", " Format", "filter", "f", "fp", "it", "pattern", "version", "status", "fit", "mode", "type"], "height": ["grow", "frame", "history", "density", "size", "gravity", "depth", "window", "total", "crop", "hang", "h", "hash", "radius", "html", "scale", "volume", "count", "shape", "padding", "resolution", "length", "quality", "capacity", "bottom", "pi", "above", "rows", "huge", "dim", "loss", "alpha", "build", "chain", "Height", "y"]}}
{"project": "qemu", "commit_id": "f3d8b1eb105199a1d6bf063a8a574e782689909a", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           DisplayState *ds, stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    qemu_irq *gpio_in[5];\n\n    qemu_irq *gpio_out[5];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    i2c_bus *i2c;\n\n    int i;\n\n\n\n    flash_size = ((board->dc0 & 0xffff) + 1) << 1;\n\n    sram_size = (board->dc0 >> 18) + 1;\n\n    pic = armv7m_init(flash_size, sram_size, kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        adc = stellaris_adc_init(0x40038000, pic[14]);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            stellaris_gptm_init(0x40030000 + i * 0x1000,\n\n                                pic[timer_irq[i]], adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_in[i] = pl061_init(gpio_addr[i], pic[gpio_irq[i]],\n\n                                    &gpio_out[i]);\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        i2c = i2c_init_bus();\n\n        stellaris_i2c_init(0x40020000, pic[8], i2c);\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            ssd0303_init(ds, i2c, 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            pl011_init(0x4000c000 + i * 0x1000, pic[uart_irq[i]],\n\n                       serial_hds[i], PL011_LUMINARY);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void * oled;\n\n            void * sd;\n\n            void *ssi_bus;\n\n            int index;\n\n\n\n            oled = ssd0323_init(ds, &gpio_out[GPIO_C][7]);\n\n            index = drive_get_index(IF_SD, 0, 0);\n\n            sd = ssi_sd_init(drives_table[index].bdrv);\n\n\n\n            ssi_bus = stellaris_ssi_bus_init(&gpio_out[GPIO_D][0],\n\n                                             ssi_sd_xfer, sd,\n\n                                             ssd0323_xfer_ssi, oled);\n\n\n\n            pl022_init(0x40008000, pic[7], stellaris_ssi_bus_xfer, ssi_bus);\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        } else {\n\n            pl022_init(0x40008000, pic[7], NULL, NULL);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        /* FIXME: Obey network model.  */\n\n        stellaris_enet_init(&nd_table[0], 0x40048000, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n}\n", "idx": 20110, "substitutes": {"kernel_filename": [" kernel_file", "kernelleFilename", "ernel_filename", "kernellefile", "kernelleprofile", "kernellefilename", "kernel_name", "ernel_family", "kernelingfamily", " kernel_Filename", "kernelingname", "ernel_file", " kernel_profile", "kernelingfile", "kernel_file", "kernelingfilename", "kernel_profile", "ernel_name", "kernel_family", "kernel_Filename"], "cpu_model": ["cpu_models", "CPU_flag", "cpuvallocation", "pu_Model", "cpuetymodels", "puetymodel", "cpu_Model", "puetymodels", "cpuvalModel", "CPU_Model", "cpuetymodel", "CPU_location", "cpu_type", "cpu_location", "cpuetytype", "pu_type", "puetytype", "cpuvalflag", "pu_model", "puetyModel", "cpuvalmodel", "pu_models", "cpu_flag", "cpuetyModel", "CPU_model"], "ds": ["cs", "os", "de", "dt", "ses", "ks", "Ds", "bs", "rs", "dl", "ss", "bd", "des", "db", "da", "ps", "dm", "pd", "ros", "dos", "def", "du", "df", "dh", "DS", "dds", "vd", "dd"], "board": ["design", "check", "ctl", "frame", "oard", "bang", "form", "word", "box", "mac", "back", "ck", "controller", "bar", "list", "bot", "boards", "kt", "bo", "boarding", "bro", "base", "ob", "core", "lock", "setup", "ward", "builder", "config", "bd", "bc", "Board", "cpu", "d", "bug", "control", "video", "reader", "bit", "hub", "body", "record", "rot", "sync", "member", "ud", "def", "runner", "du", "fc", "bank", "card", "lo", "ack", "block", "row", "layout", "ro", "deck", "view", "player", "buffer", "boot", "sc", "way", "dd", "bus", "loop"], "uart_irq": ["uart_iraql", "uart__pirve", "uart__pirql", "uart_vrqs", "uart_vrq", "uart_irve", "uart_irql", "uart_iraqs", "uart_iraq", "uart__pirqs", "uart_irqs", "uart_pirq", "uart__irql", "uart__irqs", "uart__irq", "uart_pirve", "uart_vrve", "uart_vrql", "uart_irave", "uart__irve", "uart__pirq", "uart_pirqs", "uart_pirql"], "timer_irq": ["timer_irequ", "timer_pirreq", "timer_rinqs", "timer_pirch", "timer_rinq", "timer_irich", "timer_iriqs", "timer_ireq", "timer_pirqu", "timer_irireq", "timer_irech", "timer_rinreq", "timer_rinqu", "timer__pirqs", "timer__irch", "timer__irqs", "timer__irq", "timer_pirq", "timer_rinch", "timer__pirqu", "timer__irqu", "timer_ireqs", "timer_irqu", "timer__pirch", "timer_irch", "timer_iriq", "timer__pirq", "timer_pirqs", "timer_irqs", "timer_irreq"], "gpio_addr": ["gpio__add", "gpio2addr", "gpio_inter", "gpios_address", "gpios_in", "gpio____in", "gpios_inter", "gpio____add", "gpios_align", "gpio__addr", "gpios_add", "gpio_align", "gpio____addr", "gpio_address", "gpio2address", "gpio2add", "gpios_addr", "gpio_add", "gpio____inter", "gpio__in", "gpio__inter", "gpio2align"], "gpio_irq": ["gpio_errz", "gpio_pirq", "gpio_pirz", "gpio_ireqs", "gpio_erriq", "gpio_mirue", "gpio_riniq", "gpio_irqs", "gpio_irz", "gpio_mirqs", "gpio_rinz", "gpio_rinq", "gpio_iriq", "gpio_mirq", "gpio_pirqs", "gpio_ireq", "gpio_irue", "gpio_piriq", "gpio_pirue", "gpio_ireue", "gpio_rinqs", "gpio_errq", "gpio_errqs"], "pic": ["wic", "trap", "lp", "ic", "png", "arr", "photo", "nic", "pipe", "px", "pr", "p", "pp", "sp", "proc", "capt", "mc", "ics", "lib", "Pic", "script", "pc", "gc", "pol", "arg", "cam", "pins", "shot", "jac", "py", "doc", "pb", "pict", "ip", "ps", "magic", "pi", "jp", "picture", "fc", "lic", "Picture", "txt", "pl", "par", "eric", "pa", "iac", "sac", "pin", "icc", "ac", "arc", "photos", "pac", "ig"], "gpio_in": ["gpio___rin", "gpio_ins", "gpios_ic", "gpios_in", "gpios_rin", "gpios_ins", "gpios_out", "gpio___in", "gpio_ind", "gpio___out", "gpio___ind", "gpio_rin", "gpios_ind", "gpio_ic"], "gpio_out": ["gpio2outs", "gpio_output", "gpio2in", "gpio2out", "gpios_in", "gpio_gen", "gpio_outs", "gpio2gen", "gpios_gen", "gpios_out", "gpio1gen", "gpio1out", "gpio1in", "gpios_outs", "gpio1outs", "gpios_output"], "adc": [" adl", "accon", "dp", "aycon", "Adf", "agpc", " adt", "adpc", "adl", "dt", " adpc", "acgc", "Adb", "aycc", "edc", " adf", "agc", "adf", "edt", "ayc", "Adt", "edl", "db", "adcc", "Adl", "odgc", " adcc", "Adc", "edf", "odcc", " adgc", "aypc", "agcon", "odc", "Adp", " adp", "adp", "acpc", "dc", "acc", " adb", "odpc", "adcon", "adb", "accc", "adgc", "adt", "agcc"], "sram_size": ["sram2length", "sdam_Size", "srum_count", "sdam_size", "sram_Size", "srum1size", "sram1name", "sram2name", "sram2count", "sram2size", "sram_length", "sream_name", "srum_name", "sdam2size", "sram2SIZE", "sram_count", "sram1size", "srum_SIZE", "sream_size", "sram_name", "sdam_length", "srum1name", "srum1SIZE", "sdam2SIZE", "sream_count", "sram1count", "sdam_SIZE", "sdam2length", "sdam2Size", "srum_size", "srum1count", "sream_Size", "sram1SIZE", "sram2Size", "sram_SIZE"], "flash_size": ["usb_width", " flash_Size", "flashvalspeed", "flashlexsize", "flashLogspeed", "flashLogstart", "usb_speed", "usbvalSIZE", "usbvalspeed", "cell_size", "usb_SIZE", "flashLogSize", "usbvalsize", "flash_SIZE", "flash_Size", "flashLogsize", "flashvalSIZE", "flash_speed", "cell_start", "usbvalwidth", "flash_width", "cell_Size", "flashvalwidth", "flashlexwidth", "flashlexspeed", "flashlexSIZE", " flash_SIZE", "usb_size", "flash_start", "cell_speed", " flash_loc", "flashvalsize", "flash_loc"], "i2c": ["i2n", "i7c", "i3c", "i1c", "i3n", " i2e", " i1c", " i1f", "i1n", "i1e", " i2f", " i1n", " i2n", " i1e", "i7f", "i3e", "i3f", "i1f", "i2e", "i7e", "i2f", "i7n"], "i": ["hi", "li", "span", "ri", "e", "g", "I", "ai", "di", "mi", "c", "ji", "eu", "gu", "s", "chain", "ex", "multi", "ii", "ij", "t", "ci", "sp", "q", "\u0438", "phi", "v", "cli", "io", "pi", "wi", "gi", "n", "o", "bi", "x", "zi", "ini", "it", "iu", "status", "init", "ic", "l", "ei", "qi", " ti", "me", " ii", "k", "ip", "iii", " j", "j", "ti", "ami", "ix", "y", "m", "si", "im", "p", "ki", "h", "is", "u", "dr", "oi", "ind", "in", "id", "xi", "r", "ui", "sim", "this"]}}
{"project": "FFmpeg", "commit_id": "47219e1c0c2f8a159e70b58e6293c169c7dd62cc", "target": 1, "func": "static void do_video_out(AVFormatContext *s,\n\n                         OutputStream *ost,\n\n                         InputStream *ist,\n\n                         AVFrame *in_picture,\n\n                         int *frame_size, float quality)\n\n{\n\n    int nb_frames, i, ret, av_unused resample_changed;\n\n    AVFrame *final_picture, *formatted_picture;\n\n    AVCodecContext *enc, *dec;\n\n    double sync_ipts;\n\n\n\n    enc = ost->st->codec;\n\n    dec = ist->st->codec;\n\n\n\n    sync_ipts = get_sync_ipts(ost) / av_q2d(enc->time_base);\n\n\n\n    /* by default, we output a single frame */\n\n    nb_frames = 1;\n\n\n\n    *frame_size = 0;\n\n\n\n    if(video_sync_method){\n\n        double vdelta = sync_ipts - ost->sync_opts;\n\n        //FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c\n\n        if (vdelta < -1.1)\n\n            nb_frames = 0;\n\n        else if (video_sync_method == 2 || (video_sync_method<0 && (s->oformat->flags & AVFMT_VARIABLE_FPS))){\n\n            if(vdelta<=-0.6){\n\n                nb_frames=0;\n\n            }else if(vdelta>0.6)\n\n                ost->sync_opts= lrintf(sync_ipts);\n\n        }else if (vdelta > 1.1)\n\n            nb_frames = lrintf(vdelta);\n\n//fprintf(stderr, \"vdelta:%f, ost->sync_opts:%\"PRId64\", ost->sync_ipts:%f nb_frames:%d\\n\", vdelta, ost->sync_opts, get_sync_ipts(ost), nb_frames);\n\n        if (nb_frames == 0){\n\n            ++nb_frames_drop;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** drop!\\n\");\n\n        }else if (nb_frames > 1) {\n\n            nb_frames_dup += nb_frames - 1;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** %d dup!\\n\", nb_frames-1);\n\n        }\n\n    }else\n\n        ost->sync_opts= lrintf(sync_ipts);\n\n\n\n    nb_frames= FFMIN(nb_frames, max_frames[AVMEDIA_TYPE_VIDEO] - ost->frame_number);\n\n    if (nb_frames <= 0)\n\n        return;\n\n\n\n    formatted_picture = in_picture;\n\n    final_picture = formatted_picture;\n\n\n\n#if !CONFIG_AVFILTER\n\n    resample_changed = ost->resample_width   != dec->width  ||\n\n                       ost->resample_height  != dec->height ||\n\n                       ost->resample_pix_fmt != dec->pix_fmt;\n\n\n\n    if (resample_changed) {\n\n        av_log(NULL, AV_LOG_INFO,\n\n               \"Input stream #%d.%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               ist->file_index, ist->st->index,\n\n               ost->resample_width, ost->resample_height, av_get_pix_fmt_name(ost->resample_pix_fmt),\n\n               dec->width         , dec->height         , av_get_pix_fmt_name(dec->pix_fmt));\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    ost->video_resample = dec->width   != enc->width  ||\n\n                          dec->height  != enc->height ||\n\n                          dec->pix_fmt != enc->pix_fmt;\n\n\n\n    if (ost->video_resample) {\n\n        final_picture = &ost->resample_frame;\n\n        if (!ost->img_resample_ctx || resample_changed) {\n\n            /* initialize the destination picture */\n\n            if (!ost->resample_frame.data[0]) {\n\n                avcodec_get_frame_defaults(&ost->resample_frame);\n\n                if (avpicture_alloc((AVPicture *)&ost->resample_frame, enc->pix_fmt,\n\n                                    enc->width, enc->height)) {\n\n                    fprintf(stderr, \"Cannot allocate temp picture, check pix fmt\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n            /* initialize a new scaler context */\n\n            sws_freeContext(ost->img_resample_ctx);\n\n            ost->img_resample_ctx = sws_getContext(dec->width, dec->height, dec->pix_fmt,\n\n                                                   enc->width, enc->height, enc->pix_fmt,\n\n                                                   ost->sws_flags, NULL, NULL, NULL);\n\n            if (ost->img_resample_ctx == NULL) {\n\n                fprintf(stderr, \"Cannot get resampling context\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n        sws_scale(ost->img_resample_ctx, formatted_picture->data, formatted_picture->linesize,\n\n              0, ost->resample_height, final_picture->data, final_picture->linesize);\n\n    }\n\n#else\n\n    if (resample_changed) {\n\n        avfilter_graph_free(&ost->graph);\n\n        if (configure_video_filters(ist, ost)) {\n\n            fprintf(stderr, \"Error reinitialising filters!\\n\");\n\n            exit_program(1);\n\n        }\n\n    }\n\n#endif\n\n    if (resample_changed) {\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    /* duplicates frame if needed */\n\n    for(i=0;i<nb_frames;i++) {\n\n        AVPacket pkt;\n\n        av_init_packet(&pkt);\n\n        pkt.stream_index= ost->index;\n\n\n\n        if (s->oformat->flags & AVFMT_RAWPICTURE) {\n\n            /* raw pictures are written as AVPicture structure to\n\n               avoid any copies. We support temorarily the older\n\n               method. */\n\n            AVFrame* old_frame = enc->coded_frame;\n\n            enc->coded_frame = dec->coded_frame; //FIXME/XXX remove this hack\n\n            pkt.data= (uint8_t *)final_picture;\n\n            pkt.size=  sizeof(AVPicture);\n\n            pkt.pts= av_rescale_q(ost->sync_opts, enc->time_base, ost->st->time_base);\n\n            pkt.flags |= AV_PKT_FLAG_KEY;\n\n\n\n            write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n            enc->coded_frame = old_frame;\n\n        } else {\n\n            AVFrame big_picture;\n\n\n\n            big_picture= *final_picture;\n\n            /* better than nothing: use input picture interlaced\n\n               settings */\n\n            big_picture.interlaced_frame = in_picture->interlaced_frame;\n\n            if (ost->st->codec->flags & (CODEC_FLAG_INTERLACED_DCT|CODEC_FLAG_INTERLACED_ME)) {\n\n                if(top_field_first == -1)\n\n                    big_picture.top_field_first = in_picture->top_field_first;\n\n                else\n\n                    big_picture.top_field_first = top_field_first;\n\n            }\n\n\n\n            /* handles sameq here. This is not correct because it may\n\n               not be a global option */\n\n            big_picture.quality = quality;\n\n            if(!me_threshold)\n\n                big_picture.pict_type = 0;\n\n//            big_picture.pts = AV_NOPTS_VALUE;\n\n            big_picture.pts= ost->sync_opts;\n\n//            big_picture.pts= av_rescale(ost->sync_opts, AV_TIME_BASE*(int64_t)enc->time_base.num, enc->time_base.den);\n\n//av_log(NULL, AV_LOG_DEBUG, \"%\"PRId64\" -> encoder\\n\", ost->sync_opts);\n\n            if (ost->forced_kf_index < ost->forced_kf_count &&\n\n                big_picture.pts >= ost->forced_kf_pts[ost->forced_kf_index]) {\n\n                big_picture.pict_type = AV_PICTURE_TYPE_I;\n\n                ost->forced_kf_index++;\n\n            }\n\n            ret = avcodec_encode_video(enc,\n\n                                       bit_buffer, bit_buffer_size,\n\n                                       &big_picture);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Video encoding failed\\n\");\n\n                exit_program(1);\n\n            }\n\n\n\n            if(ret>0){\n\n                pkt.data= bit_buffer;\n\n                pkt.size= ret;\n\n                if(enc->coded_frame->pts != AV_NOPTS_VALUE)\n\n                    pkt.pts= av_rescale_q(enc->coded_frame->pts, enc->time_base, ost->st->time_base);\n\n/*av_log(NULL, AV_LOG_DEBUG, \"encoder -> %\"PRId64\"/%\"PRId64\"\\n\",\n\n   pkt.pts != AV_NOPTS_VALUE ? av_rescale(pkt.pts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1,\n\n   pkt.dts != AV_NOPTS_VALUE ? av_rescale(pkt.dts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1);*/\n\n\n\n                if(enc->coded_frame->key_frame)\n\n                    pkt.flags |= AV_PKT_FLAG_KEY;\n\n                write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n                *frame_size = ret;\n\n                video_size += ret;\n\n                //fprintf(stderr,\"\\nFrame: %3d size: %5d type: %d\",\n\n                //        enc->frame_number-1, ret, enc->pict_type);\n\n                /* if two pass, output log */\n\n                if (ost->logfile && enc->stats_out) {\n\n                    fprintf(ost->logfile, \"%s\", enc->stats_out);\n\n                }\n\n            }\n\n        }\n\n        ost->sync_opts++;\n\n        ost->frame_number++;\n\n    }\n\n}\n", "idx": 20129, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "ops", "t", "its", "p", "as", "st", "sq", "h", "is", "bs", "rs", "gs", "S", "ss", "sts", "ns", "ps", "sys", "js", "sd", "c", "ats", "o", "fs", "ts", "ls", "stats", "src", "spec", "serv"], "ost": ["hess", "st", "otype", "rt", "lost", "lov", "oth", "ox", "ora", "news", "obj", "sys", " nost", "host", "oman", "oad", "art", "iot", "ether", "ott", "irst", "om", "tto", "os", "ops", "oh", "or", "oc", "zero", "iop", "utt", "onet", "so", "ot", "sts", "etc", "ast", "ocr", "post", "rss", "obs", "o", "yt", "ocol", "rest", "org", "old", "istor", "rob", "nt", "console", "ord", "rost", "ream", "sw", "ogg", "embed", "oster", "tt", "olog", "irc", "od", "hop", "rol", "ys", "ort", "store", "must", "oss", "oo", "omm", "ob", "op", "osta", "ond", "oid", "et", "ust", "est", "sta", "rog", "OST", "arent"], "ist": ["istor", "ont", "ic", "ism", "ists", "ush", "wp", "its", "ista", "ins", "st", "xt", "isc", "ess", "ik", "is", "iop", "ith", "il", "vp", "aci", "dit", "oth", "ilst", "sts", "ih", "ip", "ast", "IST", "iste", "ict", "et", "ust", "oad", "ird", "irst", "icol", "fp", "isting", "irc", "pect", "alist"], "in_picture": [" in_pict", "in_pict", "inLprofile", "inLpict", "inzpicture", "in___photo", "in_comment", "inockpicture", "inLcomment", "in_photo", " in_photo", "inockdocument", " in_profile", "in___picture", "inLpicture", " in_document", " in_comment", "in_profile", "in___profile", "in_document", "inzcomment", "inockphoto", "inzprofile", "in___document", "inzpict", "inockprofile"], "frame_size": ["window_SIZE", "frame_loss", "window_len", "window_bytes", "frame_Size", "window_loss", "frame_bytes", "window_size", "window_scale", "window_Size", "frame_len", "frame_SIZE", "frame_scale"], "quality": [" confidence", " level", " gamma", " performance", "q", "scale", "qual", " significance", " zoom", " clip", " fidelity", "Quality", " compression", " equality", " qual", " qualifier", " frequency", " divergence", " aspect", " rating", " accuracy", " qualities", " resolution", " Quality", "frequency", " priority", " quiet"], "nb_frames": ["nb_videos", "nb___videos", "ni_images", "nb_phones", "NB_values", "nr_items", "nbJfaces", "batch_flows", "nb_bits", "nb8fps", "nb___lines", "nz_faces", "nb____shots", "nb\u0648frames", "nb_features", "nz_jobs", "sb_faces", "nbWvalues", "nb5thumbnails", "NB_frames", "obb_events", "nr_bits", "nb_jobs", "nb___phones", "nb\u0648faces", "nb67rows", "cdn_cells", "nb___items", "cdnJphones", "ni_versions", "nbWframes", "nb_lines", "nb___ims", "n_frames", "nb_cells", "nr_frames", "sb_frames", "obb_frames", "batch_frames", "nb____links", "nb____jobs", "obb_fps", "nz\u0648faces", "nb67frames", "nz_features", "nb8lines", "ni_planes", "nb_objects", "nz\u0648frames", "NB_planes", "nb_shots", "cdn_phones", "cdn5frames", "nbYimages", "nbptversions", "nz_frames", "nb67bits", "nb_items", "nb_seconds", "sbJframes", "nb__frames", "nb_faces", "nb_users", "nb__videos", "NB_links", "cdn_ims", "cdn_images", "nb_modules", "nb5images", "nb_values", "obb_users", "n_videos", "nb_links", "nbJlines", "cdn_thumbnails", "nz\u0648jobs", "nb67faces", "nbYframes", "nb8ims", "nb_flows", "cdn5images", "sbJseconds", "cdnJlines", "nbYobjects", "nb\u0648jobs", "nb\u0648features", "nb_versions", "cdnJframes", "nb67items", "NB_shots", "nbWimages", "nb___planes", "cdn5cells", "cdnJims", "nb___frames", "nb8frames", "nr_images", "nbptplanes", "nb5frames", "nb__planes", "batch_modules", "nbJframes", "nb_images", "n_faces", "cdn5thumbnails", "nb_rows", "NB_images", "nb67seconds", "n_objects", "nbptframes", "nb8phones", "nbJims", "cdn_frames", "nz\u0648features", "nb____faces", "nb67images", "sb_seconds", "nb___images", "NB_objects", "NB_videos", "ni_frames", "nb____frames", "sbJrows", "nb____planes", "nb8events", "nbptimages", "nbYvalues", "nb_thumbnails", "nbWobjects", "nb____features", "nbJrows", "nb5cells", "nbJseconds", "nb___bits", "nb_events", "nb_ims", "sbJfaces", "cdn_lines", "nb_fps", "nb_planes", "nb__images", "nbJphones", "nb8users", "sb_rows"], "i": ["index", "ij", "b", "si", "t", "ci", "p", "ir", "is", "g", "I", "ai", "ip", "mi", "pi", "c", "j", "r", "ti", "iat", "n", "fi", "bi", "f", "it", "iu", "ii", "m"], "ret": ["mem", "fu", "rm", "res", "flag", "img", "result", "ll", "rt", "out", "ft", "rem", "reset", "RET", "re", "rel", "ref", "jp", "val", "new", "fi", "alt", "aux", "len", "bool", "elt", "status"], "resample_changed": ["resample_diff", "resamp_loaded", "resample2change", "ressample_change", "ressample_created", "resample2created", "resample_created", "resample_failed", "resample2failed", "resample2changed", "resamp_changed", "resample_change", "ressample_failed", "resamp_change", "resamp_diff", "resample_loaded", "ressample_changed"], "final_picture": [" final_summary", "final___img", "finalisedimg", "final___summary", "Final___profile", "Final___pic", "final___pic", "finalisedvideo", "final___picture", "final_proof", "final_pic", "final_img", " final_video", "final_profile", "Final_picture", "final_summary", "final___proof", "finalisedpicture", "Final___picture", " final___picture", " final___summary", "final___profile", "finalisedsummary", " final___video", " final___img", "final_video", "Final_profile", "Final___proof", " final_img", "Final_proof", "final___video", "Final_pic"], "formatted_picture": ["formatted_audio", "formated___pic", "formatted_status", "formatted_memory", "formattedlyaudio", "formated_picture", "formated_audio", "formatted_profile", "formattedlypicture", "formattedlyprofile", "formatted_pic", "formatted___picture", "formated_memory", "formated_pic", "formated___profile", "formattedlystatus", "formatted___image", "formated_conference", "formated___status", "formatted___photo", "formated___photo", "formatted___profile", "formatted___pic", "formatted___status", "formatted_conference", "formatted___audio", "formated___image", "formated_profile", "formatted_image", "formated_image", "formated_photo", "formated___picture", "formated_status", "formated___audio", "formatted_photo"], "enc": ["cv", "cs", "ic", "eng", "oc", "desc", "Dec", "en", "ec", "ctx", "unc", "pc", "cur", "Enc", "cc", "rec", "conv", "ew", "iv", "conn", "ens", "c", "oder", "et", "lc", "act", "cod", "fc", "acc", "ent", "ack", "eric", "nc", "anc", "ENC", "env", "lang", "xc", "rc", "ac", "code", "inc"], "sync_ipts": ["sync_ips", "sync_oints", "sync_iprs", "sync_rectps", "sync_iptps", "sync_opps", "sync___iptrs", "sync_ocolrs", "sync_ptb", "sync_ipps", "sync_cmdps", "sync_rectz", "sync_cmdts", "sync___ipps", "sync_ops", "sync_ocolts", "sync_oprs", "sync___iptts", "sync_ptps", "sync___ips", "sync_ptts", "sync_seqs", "sync_iptes", "sync_ptes", "sync_iptts", "sync_rects", "sync_rolz", "sync_ointb", "sync_rolrs", "sync_rectts", "sync_opb", "sync_iptz", "sync_seqls", "sync_ptls", "sync_seqts", "sync_ptz", "sync_opes", "sync_rols", "sync_ointts", "sync_iptb", "sync_ptrs", "sync___iprs", "sync_rolps", "sync_cmds", "sync_cmdls", "sync_seqps", "sync___iptps", "sync_ocols", "sync_ocolps", "sync___ipts", "sync_iptls", "sync_pts", "sync_ointes", "sync_iptrs", "sync_rolts"], "nb_frames_drop": ["nb_frames_dl", "nb_links_drops", "nb_links_drop", "nb_frames_drops", "nb_links_dl", "nb_links_single", "nb_frames_single"], "sync_opts": ["sync_optts", "sync_optters", "sync_opcs", "sync_OPt", "sync_ips", "sync_optcs", "sync_ops", "sync_opss", "sync_atters", "sync_OPps", "sync_opters", "sync_OPcs", "sync_oppts", "sync_opsts", "sync_OPts", "sync_OPct", "sync_oppct", "sync_atts", "sync_opps", "sync_ipt", "sync_OPls", "sync_ipcs", "sync_oppls", "sync_optps", "sync_atps", "sync_OPs", "sync_OPters", "sync_opsct", "sync_opt", "sync_opsls", "sync_ats", "sync_optt", "sync_opls", "sync_opct"], "frame_number": ["image_number", "frame_Number", "frame_no", "image_Number", "frameNamenumber", "frameNameno", "image_span", "frameNameNumber", "image_no", "frame_span", "frameNamespan"]}}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n", "idx": 20131, "substitutes": {"opaque": ["Oposit", "Opaque", "obatile", "OPacity", "obossibly", " Opacity", "obacity", "obaque", "opaques", "opatile", "oplatile", "oposit", "Opossibly", " Opossibly", "oplaque", "obaques", "Opacity", "opossibly", " Oposit", "obosit", "oplacity", " Opaque", "opacity", "OPaques", "OPatile", "OPaque", "oplaques"], "dbs": ["ldBS", "dsbes", " dmes", "dbBS", "dBS", "dbes", " dbas", "ldbas", " dBS", "dsbs", "dmes", "dscs", "sbs", "ldbs", "dcs", "sdvals", "dans", "dabes", "dvals", "davals", "dsbas", "dabs", "dsos", "smes", "dns", "sdbes", "dbbas", "dbas", "dbbs", " dos", "dbos", "sdns", "sbas", "dos", " dbes", "dbbes", " dns", "sos", " dcs", "dsmes", "sdbs", "ldos", " dvals", "dbcs"]}}
{"project": "qemu", "commit_id": "3a21532626bb5c3ecb0f916843f75ccce6501a9d", "target": 0, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n\n\n\n    /* Only aligned reads are allowed on OHCI */\n\n    if (addr & 3) {\n\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n        return;\n\n    }\n\n\n\n    if (addr < OPREGBASE) {\n\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n\n\n    /* Do any register specific pre-write processing here.  */\n\n    switch(addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (!ehci_enabled(s)) {\n\n                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            ehci_update_halt(s);\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_set_interrupt(s, 0);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n}\n", "idx": 20148, "substitutes": {"ptr": ["z", "arr", "t", "Ptr", "pr", "pad", "p", "sp", "proc", "store", "th", "h", "ry", "rect", "ctx", "ret", "rt", "tmp", "tr", "handle", "alloc", "address", "v", "pointers", "pointer", "dr", "inter", "add", "ps", "obj", "js", "cont", "rev", "req", "pt", "ind", "ref", "r", "str", "dh", "ts", "ctr", "err"], "addr": ["loc", "mac", "size", "pad", "ck", "tx", "slot", "hash", "ctx", "rt", "arg", "ace", "rs", "rr", "lat", "tp", "ad", "inter", "obj", "iter", "sys", "host", "dd", "hl", "mem", "eth", "offset", "index", "np", "t", "var", "sp", "ha", "set", "gz", "on", "ret", "cur", "handle", "v", "hw", "add", "msg", "pkg", "pt", "x", "ack", "oa", "Address", "len", "ctr", "elt", "trans", "old", "err", "init", "res", "ord", "w", "kt", "ar", "adr", "mt", "name", "address", "attr", "ip", "ash", "cmp", "str", "act", "alt", "state", "ld", "row", "arp", "rc", "gt", "ix", "gate", "pos", "work", "grad", "arr", "md", "asm", "at", "map", "dr", "rev", "cmd", "ind", "id", "rel", "ref", "r", "alias", "dh", "coord", "ac", "src", "dest", "ser", "phys"], "val": ["loc", "ival", "valid", "tx", "test", "hash", "ctx", "vals", "arg", "eval", "sol", "cho", "mem", "index", "Val", "el", "sel", "max", "var", "set", "ret", " value", "fail", "v", "msg", "pt", "dev", "x", " eval", "len", "resp", "al", " old", "elt", "status", "err", "old", "res", "l", "num", "hz", "buf", "pol", "prop", "stat", " Val", "reg", " arg", "cal", "cmp", "def", "alt", "bal", "pos", " update", "grad", "rol", "p", "vt", "xy", "VAL", "aval", "value", "data", "cmd", "rel", "ref", " ret", " v", "vol"], "s": ["hs", "ds", "cs", "sam", "times", "os", "t", "w", "p", "sb", "sp", "ses", "changes", "store", "sq", "aws", "h", "sm", "qs", "is", "bs", "e", "sv", "rs", "gs", "S", "ss", "d", "sw", "sts", "ns", "v", "vs", "self", "se", "ps", "sys", "js", "sd", "c", "j", "es", "r", "comm", "n", "fs", "state", "ts", "ims", "ls", "an", "stats", "ms", "serv", "sl", "b", "its", "m"], "mmio": ["wmico", "memios", "mmmi", "mpia", "mxios", " mmIO", "mmie", " mmios", "mpios", "memiol", " mmia", "wmios", "nightios", "mpIO", "mpnet", "mmi", "mmIO", "mtio", "mpiol", "mmmios", "mxio", "nighti", " mmie", "nightio", "mbico", "mmios", "mbio", "mtIO", "mtios", "mpio", "wmie", "mpi", "memio", "mxiol", "nightiol", "wmio", "mbios", "memnet", "mmia", "mmmio", "mmnet", "mmico", " mmico", "mxnet", "mmmiol", "mtia", "mbie", "mmiol"], "i": [" ip", "l", "or", " len", "t", " start", "p", " out", " dist", "set", " rel", " l", " set", " var", "v", " stored", "r", " offset", " tmp", "x", " init", " sp", " ref", " err", " res"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n", "idx": 20151, "substitutes": {"index": ["offset", "frame", "IND", "error", "si", "size", "i", "num", "zero", "level", "count", "ion", "lock", "config", "Index", "length", "address", "position", "data", "ind", "id", "j", "height", "number", "connect", "n", "key", "request", "state", "info", "x", "open", "row", "no", "ix", "type"], "obj": ["pos", "con", "nt", "arr", "res", "t", "opt", "pr", "ck", "oc", "p", "adj", "ready", "og", "ctx", "rect", "bo", "stick", "ob", "impl", "tmp", "node", "onet", "checked", "handle", "ot", "alloc", "out", "v", "ptr", "cont", "attr", "object", "addr", "instance", "js", "conn", "typ", "ind", "joined", "j", "oj", "ref", "inst", "jp", "val", "Obj", "cmp", "obs", "str", "o", "act", "n", "cod", "ent", "txt", "x", "vo", "go", "ie", "resp", "entry", "buff", "org", "po", "elt"], "name": ["mem", "word", "ame", "item", "size", "filename", "w", "list", "only", "base", " Name", "normal", "tmp", "prefix", "tree", " NAME", "Name", "named", "address", "v", "label", "attr", "order", "data", "c", "id", "dir", "common", "ref", "parent", "local", "def", "str", "n", "o", "path", "key", "package", "nm", "null", "title", "info", "len", "names", "NAME", "part", "search", "text", "file", "nam", "type"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) + farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 20158, "substitutes": {"arg1": ["arg01", " argone", "agg3", " arged", "Arg2", "Arg1", "agg01", "agg1", "agged", "tagone", " arg0", "agg0", " arg01", "agg2", "arg0", "arged", "tag0", "Arg3", "aggone", "argone", "tag01", "tag1", "Arged"], "arg2": ["ig02", "ig2", "agTwo", "propTwo", "argumentTwo", "ag2", "ag02", "prop3", "prop2", "ag1", "argument2", "argTwo", "igTwo", " arg02", "argument3", "arg02", "ig1", " argTwo"], "arg3": ["arg23", "targetThree", "paramthree", "param5", " argthree", "arg5", "agThree", "ag2", " argThree", "groupthree", "argthree", "ag23", "ag3", "target23", "group3", " arg23", "group5", "target2", "target3", "param3", "argThree", " arg5", "group2", "param2"], "farg1": [" fargOne", "fargument3", "fgroupons", "floc15", "fvar15", "farge101", "floatarg15", "fargs101", "fagg001", " fargsOne", "flvalidn", "fassons", " fagg15", " fargs2", "fargsOne", "falleOne", "forarg37", " farg9", "farp1", "falle1", "farge15", "farp81", "farpons", "fblock1", "fagg4", "fargs1", "fcall3", "forargasso", "forumentasso", "floatarg1", " fagg1", "fargument41", "fument001", "farg37", "fargumentOnce", "fargument01", "fuser1", "fconfig3", "fagg101", "fcall001", "fvarons", "flvalid1", "flarg81", " fagg101", "forument1", " fok1", "fagg8", "flblock3", "floatvar001", " fcall1", "farg8", "floatargons", "fconfig101", "fcall1", "floatarg3", "flvalid8", "fass81", "fargy", "fconfig1", "fagg37", " farg001", "fumentasso", "fvalidn", "fvary", " fargs001", "fconfig15", "floc3", "fumenty", " farg15", "flagOne", "farp3", "flag1", "fargumentOne", "fargn", "fargOnce", "floatargy", "fok1", "fvalid8", "fumentons", " farg01", "flarg1", "flvalid3", "falleOnce", "farg101", "fuserasso", " fagg9", "farge9", " fcall01", " fokOne", " fargOnce", "forument37", "floatconfig3", "forarg4", "fargs2", "fuser37", " fok41", "flag001", " fokOnce", "fagg9", "farg9", "farg15", "fargons", " fcall3", " fcall001", "fcall01", "fass1", "fagg01", "fargs001", "fgroup001", "fvar001", "fargs15", "fblock3", "fument37", "fument1", "floatconfig101", "faggn", "fgroup1", "fvar1", "fvalid1", "fvar101", "fargasso", "fargument1", "flblockons", "fargs3", "floatarg001", "floc1", "floatarg101", "forarg1", "floatconfig15", "flblock1", "flblock81", "floatconfig1", "fagg1", "fass3", "faggasso", "farg01", "flargons", "fagg15", "floatvary", "farpn", "flarg8", "fargument001", "flag2", "fvar9", "farp8", "flargn", "fok41", "fokOne", "floatvarons", " farg41", "fvalid3", "fument4", "farg001", "farg41", " fargs1", "fokOnce", "fargOne", "fblock81", "fagg3", "flarg3", "fgroupy", "farg81", "forument4", "floc101", "fuser4", "fblockons", "farg4", "farge1", " farg101", "falle41", "floatvar1"], "farg2": ["fparg2", "flinkTwo", "cfarg2", "fvalid22", "fargSecond", "fargument3", "farg102", "flarg22", "fpar102", "flargSecond", "fframe002", "farg21", "ftagTwo", "fllinkTwo", "fabframe002", "formargument2", "fument2", "fig21", "fabframe2", "fumenttwo", "fvalidTwo", "fpar2", "fparp2", "fargtwo", "ftag22", "flinkSecond", "formarg3", " fark2", "fark3", "fark4", "ftag2", "fabframe3", "formarg8", "fagg8", "fabarg2", "fpargtwo", "fabarg3", "farg8", " fark3", "formargument3", "fargTwo", "fok002", "fpar21", "farg48", "fcalltwo", "cfig21", "fparp4", "figtwo", "farptwo", "fparg4", "fabarg002", "fig102", "farp2", "cfargtwo", "cfarg21", "fagg2", "faj3", "faj2", "farg22", "farpTwo", "flarg2", "fargument8", "fframe21", "fark2", "ftagSecond", "fparam2", " farg4", "faj21", "fok3", "fllink2", "fllinkSecond", "farglet", "cfig2", "fargument2", "cfig102", "cfigtwo", "fagg48", "formarg48", "flink2", "fparpTwo", " farglet", "fument102", "fcall2", "fvalid2", "fparam4", "formarg2", "fparptwo", "fArg3", "fvalidSecond", "fargument48", "fparamtwo", "formargument8", "flink22", "farg002", "fframe2", "fabarg21", "farp4", "fcallTwo", "fArg48", "fllink22", "fcall4", "fabframe21", "fok21", "fvalid4", "fpartwo", "cfarg102", "flargTwo", " farklet", "fpargTwo", "fvalidlet", "fframe3", "fvalid3", "faj002", "formargument48", "fagg3", "fArg2", " fark4", "fok2", "fig2", "farklet", "farg4", "fument21", "fparamTwo", "fArg8"], "farg3": ["fcargThree", "fdate4", "foarg5", "fargument3", "faggThree", "farg13", "fagant", "vagg3", "fument41", "farg5", "fdatethree", " fargment", "dfargthree", "varg5", "fig03", "fargment", "fdateant", "farg6", "dfdatethree", "dfdateThree", "fagThree", "fcall3", "fument34", "fcarg03", "fdate3", "fparam41", "fcarg3", "fcagg6", "fvar3", "foarg34", "ftag03", "wtarget03", "fcall33", "fasc3", "fitem343", "varg2", "fitem03", "fagg5", "fagthree", "fig6", "farg33", "wtarget33", "foarg3", "wtarget343", "farg03", "dfargant", "fargThree", "ftag3", "fargant", "foarg41", " fcall4", "ftarget33", "fargs03", "dfdate3", "fitem33", "fagg2", "fang34", "warg33", "fascThree", "fcagg3", "fparam3", "varg3", "fargs5", "fang5", "fparam5", "fargs2", "fvar03", "fagg03", "fdatement", "fparam34", "fargument4", "fument3", "ftag6", "fang3", " farg4", " fcall3", "fcall343", "foument5", " fcall13", "dfarg3", " fcallment", "fument5", "vagg03", "ftarget3", "fcagg03", "fang41", "fcall13", "warg3", "figThree", "foument3", "fargs3", "fascthree", "fagg6", "foument41", "fdate13", "warg343", "vagg5", "farg343", "fag3", "dfargThree", "fcall4", "warg03", "fargument13", "ftagThree", " farg13", "foument34", "fascant", "fcall03", "ftarget343", "fvar5", "farg41", "fargumentment", "fcallment", "fitem3", "farg34", "fagg3", "wtarget3", "fcarg6", "varg03", "dfdateant", "fdateThree", "fvar2", "ftarget03", "fargthree", "farg4", "fig3", "vagg2", "fcaggThree"], "ft0_128": ["ft1_dq", "ft0Mdq", "ft0_simple", "ft06432", "ft0_63", "ft0_1024", "ft0_\t", "ft000_48", "ft1_\t", "ft1_65", "ft0P512", "ft0M128", "ft0P256", "ft2_63", "ft000_128", "ft0_65", "ft0_48", "ft0_16", "ft0M512", "ft0_dq", "ft0M256", "ft0_ul", "ft2_128", "ft06465", "ft1_180", "ft0_512", "ft100_3", "ft0_32", "ft0_180", "ft0Pdq", "ft06463", "ft100_simple", "ft1_256", "ft06416", "ft1_512", "ft2_32", "ft100_128", "ft0_256", "ft100_1024", "ft0P128", "ft000_ul", "ft2_256", "ft1_16", "ft064128", "ft064256", "ft0_3"], "ft1_128": ["ft7_257", "ft11128", "ft11257", "ftone_32", "ft1_97", "ftone_128", "ft7_16", "ft51_211", "ft1_257", "ft7_128", "ft7_32", "ft1_384", "ft0_32", "ft1_256", "ftone_256", "ft1_211", "ft0_256", "ft51_384", "ft0_384", "ft51_128", "ftone_97", "ft1_16", "ft1116", "ft1_32", "ft1132", "ft51_256"]}}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    const struct cow_header_v2 *cow_header = (const void *)buf;\n\n\n\n    if (buf_size >= sizeof(struct cow_header_v2) &&\n\n        be32_to_cpu(cow_header->magic) == COW_MAGIC &&\n\n        be32_to_cpu(cow_header->version) == COW_VERSION)\n\n        return 100;\n\n    else\n\n        return 0;\n\n}\n", "idx": 20189, "substitutes": {"buf": ["mem", "Buff", "window", "w", "img", "p", "proc", "rw", "bh", "h", "fb", "ob", "vec", "header", "queue", "alloc", "v", "bytes", "uv", "pb", "uffer", "data", "cmd", "msg", "ref", "batch", "raw", "pack", "bf", "rb", "cb", "block", "uf", "que", "buffer", "Buffer", "buff", "b", "br"], "buf_size": ["buf2size", "buf_ize", " buf_len", " buf_start", "buf2ize", "uf_len", "buf2len", "buf_Size", "buf_start", "buf2start", "buf_len", "uf_size", " buf_ize", "uf_Size"], "filename": ["png", "fn", "ame", "fil", "family", "tmp", "prefix", "files", "seek", "name", "kw", "image", "attr", " fn", "path", "fi", "nm", "txt", "write", "f", "fp", "wcs", "src", "file", " wo"], "cow_header": ["craft___tree", "cowmyadder", "cow___size", "cow___adder", "cowptmember", "cowptheader", "cow_____header", "craft___size", "craft___adder", "cow_manager", "gow_header", "cow_status", "cow___header", "gow_config", "cowptdefinition", "craft_header", "cowmytree", "cow___tree", "gow_status", "cow_____config", "gae_head", "cow_head", "cow_adder", "craft___header", "craft_tree", "gae_definition", "gae_header", "gae_member", "cowmyheader", "craft_adder", "gow_manager", "cow_member", "cow_tree", "cow_config", "craft_size", "cow_____status", "cow_____manager", "cow_size", "cowpthead", "cow_definition", "cowmysize"]}}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "uint64_t ram_bytes_remaining(void)\n\n{\n\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n\n}\n", "idx": 20197, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "aac0eda40754c010ab5156dcd5d0d1554937e9a7", "target": 0, "func": "static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {\n\n    Pulse pulse;\n\n    TemporalNoiseShaping * tns = &sce->tns;\n\n    IndividualChannelStream * ics = &sce->ics;\n\n    float * out = sce->coeffs;\n\n    int global_gain, pulse_present = 0;\n\n\n\n    /* This assignment is to silence a GCC warning about the variable being used\n\n     * uninitialized when in fact it always is.\n\n     */\n\n    pulse.num_pulse = 0;\n\n\n\n    global_gain = get_bits(gb, 8);\n\n\n\n    if (!common_window && !scale_flag) {\n\n        if (decode_ics_info(ac, ics, gb, 0) < 0)\n\n            return -1;\n\n    }\n\n\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n\n        return -1;\n\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n\n        return -1;\n\n\n\n    pulse_present = 0;\n\n    if (!scale_flag) {\n\n        if ((pulse_present = get_bits1(gb))) {\n\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n                av_log(ac->avccontext, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n\n                return -1;\n\n            }\n\n            decode_pulses(&pulse, gb, ics->swb_offset);\n\n        }\n\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n\n            return -1;\n\n        if (get_bits1(gb)) {\n\n            av_log_missing_feature(ac->avccontext, \"SSR\", 1);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 20199, "substitutes": {"ac": ["ic", "cs", "ica", "am", "tc", "mac", "ag", "acer", "ach", "mc", "acl", "ec", "ican", "enc", "at", "ctx", "unc", "pc", "rac", "ace", "cam", "auc", "aci", "jac", "fac", "vc", "aco", "ct", "cc", "bc", "ad", "ak", "ab", "uc", "c", "att", "ain", "aq", "Ac", "act", "fc", "acs", "acc", "cu", "ack", "AC", "anc", "iac", "sac", "abc", "ap", "pac"], "sce": ["Sce", "imscle", "sesces", "alsce", "jsse", "Ske", "gsce", "sCE", "jsce", "islee", "sesce", "Scle", "csCE", "gesces", "ske", "csce", "sces", "scle", "SCE", "isCE", "sescle", "sced", "alscle", " ske", "gsces", "rsce", "gscle", "stsced", "scel", "msced", "jsCE", "opensces", "jsced", " sse", "openscle", "insce", " slee", "gesce", "msces", " scer", "isce", "gesCE", "insCE", "seslee", "inske", "sse", "iscer", "msce", " sced", "rske", "imsces", "scer", " scle", " scel", "csced", "mscle", "imsce", "insces", " sCE", "opensce", "iscle", " sces", "rscle", "csse", "stsce", "gescel", "isces", "slee", "Sces", "openske", "alsces", "gescle", "gsced", "stscle", "rsces", "rsse", "alsced", "stsces", "imsse"], "gb": [" GB", "bridge", "box", "px", "args", "img", "gio", "bits", "sb", "bb", "goo", "gif", "xy", "gz", "pc", "fb", "gc", "bs", "buf", "g", "ruby", "Gb", "gs", "kb", "py", "bg", "bc", "handle", "GB", "mb", "db", "pg", "bytes", "io", "pb", "wb", "vg", "nb", "hub", "storage", "yg", "msg", "gg", "ogg", "gy", "um", "cfg", "gpu", "bf", "rg", "rb", "ib", "gp", "gd", "cb", "row", "tg", "by", "uf", "gh", "gin", "buffer", "gm", "gt", "eb", "eg", "ows", "b", "its", "bn", "ig"], "common_window": ["common_client", "common_windows", "commonishwindow", "Common_stream", "common_device", "common_stream", "commonlyclient", "Common_client", "commontenancestream", "commonishwindows", "commontenancewindow", "commonlystream", "commontenancewin", "Common_window", "commontenanceclient", "commonlywindow", "commonishwin", "Common_win", "commonishdevice", "commonlywin", "common_win", "Common_windows", "Common_device"], "scale_flag": ["scalefulonly", " scale_status", "scalefulflags", "scaleetricleaf", "scaleetricflag", "scale_status", "scaleerevent", "scale_lag", "scaleetricflags", "scale2flag", " scale_flags", " scale_leaf", "scale_leaf", "scalealflag", "scalealflags", "scale2flags", " scale_event", "scale2only", "scalealevent", "scaleetricstatus", "scalealmode", "scalefulflag", "scale_only", "scalefullag", "scale_mode", "scale_event", " scale_lag", "scaleerflags", "scaleermode", " scale_mode", "scale_flags", "scale2lag", "scaleerflag", " scale_only"], "pulse": ["impitch", "dolar", "rulse", "duls", "cpulsion", "paulsion", "psuls", "psulsion", "expolar", "spuls", "cpuls", "psitch", "impolar", "spulse", "cpitch", "ppulse", "expuls", "psulse", "cpulse", "ppulsion", "Pulse", "pitch", "cpolar", "ditch", "ppuls", "spulsion", "Pulsion", "dulse", "pritch", "ruls", "paulse", "pulsion", "spitch", "impuls", "Puls", "puls", "pruls", "ppolar", "ritch", "prulsion", "paolar", "Pitch", "expitch", "polar", "pauls", "impulse", "rulsion", "prulse", "expulse"], "tns": ["vcs", "dtnis", "ternis", "ynis", "ynos", "terks", " tnos", "Tns", "rmn", "ttcs", "rnes", "tn", "dtns", "vrs", "ttns", "pcs", " trs", "rns", "tnes", "Tcs", "terls", "ymn", "terns", "tls", "ynes", " tks", "ycs", "Tmn", "tnis", " tnis", "dtls", "tks", "dtks", " tn", "ttnis", "prs", "Tnes", " tcs", "ttnos", "vn", "vns", "pn", "tnos", " tls", "tcs", "trs", "pns", "yns", "tmn", "rcs"], "ics": ["wic", "onics", "ic", "cs", "icking", "ico", "nic", "bits", "ICS", "ils", "ins", "isc", "aws", "oms", "tis", "ks", "qs", "pic", "is", "rics", "bs", "ik", "iris", "rs", "caps", "ips", "amps", "icing", "irs", "aic", "ns", "vs", "aps", "ices", "ps", "sys", "mic", "xs", "css", "IC", "es", "ats", "ires", "fs", "fc", "acs", "ints", "ts", "ims", "eric", "ls", "icks", "xes", "cus", "stats", "icons", "icc", "ris", "icates", "irc", "iers", "wcs", "fits", "its"], "out": ["OUT", "os", "res", "outs", "t", "px", "result", "at", "ctx", "unc", "gc", "output", "g", "Out", "ot", "off", "all", "conv", "v", "io", "gain", "band", "mask", "obj", "co", "sys", "in", "ch", "to", "ref", "raw", "o", "aux", "aos", "cb", "bin", "net", "loss", "scan", "gt", "ix", "ex", "sc", "conf", "its"], "global_gain": ["global_wm", "total_gain", "total_wm", " global_gen", " global_wave", "global_speed", " global_grain", "total_speed", "global_wave", " global_speed", "global_gen", "global_grain"]}}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static ssize_t buffered_flush(QEMUFileBuffered *s)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t ret = 0;\n\n\n\n    DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffer_size);\n\n\n\n    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {\n\n        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);\n\n        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,\n\n                                    to_send);\n\n        if (ret <= 0) {\n\n            DPRINTF(\"error flushing data, %zd\\n\", ret);\n\n            break;\n\n        } else {\n\n            DPRINTF(\"flushed %zd byte(s)\\n\", ret);\n\n            offset += ret;\n\n            s->bytes_xfer += ret;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffer_size);\n\n    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);\n\n    s->buffer_size -= offset;\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return offset;\n\n}\n", "idx": 20200, "substitutes": {"s": ["ies", "hs", "ds", " ss", "cs", "sam", "os", "bits", "i", "as", "details", "events", "ses", "ins", "ers", "sq", "changes", "aws", "als", "h", "qs", "is", "bs", "south", "sv", "rs", "gs", "S", "ss", "sb", "sw", "ports", "ns", "sts", "v", "tains", "vs", "se", "ps", "http", "sys", "js", "xs", "es", "ats", "gets", "comm", "sync", "https", "fs", "less", "ags", "ts", "ows", "ims", "ls", "parts", "stats", "ms", "sql", "serv", "b", "bis", "y", "its", "comments"]}}
{"project": "qemu", "commit_id": "10c4c98ab7dc18169b37b76f6ea5e60ebe65222b", "target": 0, "func": "void pci_qdev_register(PCIDeviceInfo *info)\n\n{\n\n    info->qdev.init = pci_qdev_init;\n\n    info->qdev.bus_type = BUS_TYPE_PCI;\n\n    qdev_register(&info->qdev);\n\n}\n", "idx": 20213, "substitutes": {"info": ["iso", "check", "next", "debug", "init", "index", "history", "loc", "error", "inf", "about", "ok", "comment", "i", "ready", "details", "desc", "report", "where", "query", "always", "good", "Info", "count", "config", "information", "py", "address", "auth", "start", "doc", "iter", "kind", "http", "success", "fee", "description", "time", "INFO", "update", "id", "try", "fo", "Inf", "now", "fi", "fire", "request", "notice", "cache", "txt", "metadata", "entry", "f", "policy", "it", "conf", "trace"]}}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "func": "static void vhost_net_stop_one(struct vhost_net *net,\n\n                               VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { .fd = -1 };\n\n\n\n    if (!net->dev.started) {\n\n        return;\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\n}\n", "idx": 20233, "substitutes": {"net": ["grid", "nets", "test", "rt", "Net", "mat", "vs", "obj", "sys", "physical", "page", "plain", "comm", "art", "iot", "ether", "chain", "not", "boot", "serv", "sky", "np", "server", "en", "nis", "port", "pot", "virtual", "dat", "NET", "virt", "onet", "sec", "io", "n", "ent", "ver", "volt", "org", "ut", "task", "nt", "nic", "kt", "ne", "vert", "ann", "nut", "fat", "ip", "mot", "def", "act", "network", "nm", "no", "fax", "nav", "gate", "man", "eng", "client", "ng", "config", "out", "web", "unit", "vm", "nat", "conn", "nu", "et", "nc", "inet", "phys"], "dev": ["mem", "debug", "eth", "adv", "pub", "nt", "server", "w", "de", "disc", "desc", "Dev", "var", "md", "van", "dis", "enc", "device", "DEV", "av", "buf", "cam", "dat", "cast", "des", "nw", "ad", "d", "v", "hw", "ptr", "ve", "obj", "doc", "iv", "conn", "priv", "data", "det", "cmd", "att", "den", "watch", "ev", "host", "val", " Dev", "def", "raw", "develop", "aux", "env", "cho", "info", "block", "nc", "gu", "ver", "tech", "devices", "go", "dem", "serv", "dd", "dn"], "file": [" chain", "handler", "base", "e", " filename", "run", "tree", "iter", "page", "dir", "field", "local", "line", "path", "ib", "attribute", "issue", "buffer", "fp", "spec", "connection", "use", "form", "channel", "t", "port", " fe", "le", " db", " world", "link", "files", "handle", "File", " io", "io", "ile", "range", "open", " pool", "al", "f", "task", "proc", "array", "user", " msg", "il", "disk", "name", " files", "fe", "progress", "time", "info", " path", "block", "row", "byte", " error", "p", "lf", " fo", "h", "util", "image", "out", "db", "reader", "data", "entity", "in", "ref", "et", "table", " fin", " f", "key", " data", "lo", " fid", " File", "rule"], "index": ["offset", "pos", "loc", "slice", "depth", "i", "weight", "num", "list", "test", "span", "find", "level", "count", "lock", "point", "prefix", "Index", "node", "length", "position", "d", "seek", "address", "start", "iter", "head", "range", "ind", "id", "ref", "val", "str", "n", "rank", "number", "connect", "key", "sequence", "dim", "connected", "x", "no", "brand", "chain", "ix", "ex", "seq"], "vhost_ops": ["vHost_tops", "vHost_op", "vost_caps", "vhost__ops", "vost_ops", "vhost__Ops", "vhost2tops", "vhost_caps", "vhost_tops", "vhost2op", "vHost_Ops", "vhost__tops", "vhost2ops", "vhost2Ops", "vost_Ops", "vhost_op", "vhost_Ops", "vhost_oops", "vHost_oops", "vhost__oops", "vHost_ops"]}}
{"project": "FFmpeg", "commit_id": "b7b8fc340632d15cb3b26a57915ebea84f37d03e", "target": 0, "func": "static int rtsp_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char host[1024], path[1024], tcpname[1024], cmd[2048];\n\n    URLContext *rtsp_hd;\n\n    int port, i, ret, err;\n\n    RTSPHeader reply1, *reply = &reply1;\n\n    unsigned char *content = NULL;\n\n    AVStream *st;\n\n    RTSPStream *rtsp_st;\n\n    int protocol_mask;\n\n\n\n    rtsp_abort_req = 0;\n\n    \n\n    /* extract hostname and port */\n\n    url_split(NULL, 0,\n\n              host, sizeof(host), &port, path, sizeof(path), s->filename);\n\n    if (port < 0)\n\n        port = RTSP_DEFAULT_PORT;\n\n\n\n    /* open the tcp connexion */\n\n    snprintf(tcpname, sizeof(tcpname), \"tcp://%s:%d\", host, port);\n\n    if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)\n\n        return AVERROR_IO;\n\n    rt->rtsp_hd = rtsp_hd;\n\n    rt->seq = 0;\n\n    \n\n    /* describe the stream */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"DESCRIBE %s RTSP/1.0\\r\\n\"\n\n             \"Accept: application/sdp\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, &content);\n\n    if (!content) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n        \n\n    /* now we got the SDP description, we parse it */\n\n    ret = sdp_parse(s, (const char *)content);\n\n    av_freep(&content);\n\n    if (ret < 0) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    \n\n    protocol_mask = rtsp_default_protocols;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n       RTSP stream */\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        char transport[2048];\n\n        AVInputFormat *fmt;\n\n\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n\n\n        /* compute available transports */\n\n        transport[0] = '\\0';\n\n\n\n        /* RTP/UDP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP)) {\n\n            char buf[256];\n\n            int j;\n\n\n\n            /* first try in specified port range */\n\n            if (rtsp_rtp_port_min != 0) {\n\n                for(j=rtsp_rtp_port_min;j<=rtsp_rtp_port_max;j++) {\n\n                    snprintf(buf, sizeof(buf), \"rtp://?localport=%d\", j);\n\n                    if (!av_open_input_file(&rtsp_st->ic, buf, \n\n                                            &rtp_demux, 0, NULL))\n\n                        goto rtp_opened;\n\n                }\n\n            }\n\n\n\n            /* then try on any port */\n\n            if (av_open_input_file(&rtsp_st->ic, \"rtp://\", \n\n                                       &rtp_demux, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n            }\n\n\n\n        rtp_opened:\n\n            port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb));\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;unicast;client_port=%d-%d\",\n\n                     port, port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/TCP\");\n\n        }\n\n\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), \n\n                     sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;multicast\");\n\n        }\n\n        snprintf(cmd, sizeof(cmd), \n\n                 \"SETUP %s RTSP/1.0\\r\\n\"\n\n                 \"Transport: %s\\r\\n\",\n\n                 rtsp_st->control_url, transport);\n\n        rtsp_send_cmd(s, cmd, reply, NULL);\n\n        if (reply->status_code != RTSP_STATUS_OK ||\n\n            reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].protocol != rt->protocol) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->protocol = reply->transports[0].protocol;\n\n        }\n\n\n\n        /* close RTP connection if not choosen */\n\n        if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP &&\n\n            (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP))) {\n\n            av_close_input_file(rtsp_st->ic);\n\n            rtsp_st->ic = NULL;\n\n        }\n\n\n\n        switch(reply->transports[0].protocol) {\n\n        case RTSP_PROTOCOL_RTP_TCP:\n\n            fmt = &rtp_demux;\n\n            if (av_open_input_file(&rtsp_st->ic, \"null\", fmt, 0, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n            \n\n        case RTSP_PROTOCOL_RTP_UDP:\n\n            {\n\n                char url[1024];\n\n                \n\n                /* XXX: also use address if specified */\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d\", \n\n                         host, reply->transports[0].server_port_min);\n\n                if (rtp_set_remote_url(url_fileno(&rtsp_st->ic->pb), url) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        case RTSP_PROTOCOL_RTP_UDP_MULTICAST:\n\n            {\n\n                char url[1024];\n\n                int ttl;\n\n\n\n                fmt = &rtp_demux;\n\n                ttl = reply->transports[0].ttl;\n\n                if (!ttl)\n\n                    ttl = 16;\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", \n\n                         host, \n\n                         reply->transports[0].server_port_min,\n\n                         ttl);\n\n                if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* use callback if available to extend setup */\n\n    if (ff_rtsp_callback) {\n\n        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, \n\n                             NULL, 0, rt->last_reply) < 0) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n                         \n\n    /* start playing */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"PLAY %s RTSP/1.0\\r\\n\"\n\n             \"Range: npt=0-\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, NULL);\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n#if 0\n\n    /* open TCP with bufferized input */\n\n    if (rt->protocol == RTSP_PROTOCOL_RTP_TCP) {\n\n        if (url_fdopen(&rt->rtsp_gb, rt->rtsp_hd) < 0) {\n\n            err = AVERROR_NOMEM;\n\n            goto fail;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n fail:\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n        if (rtsp_st) {\n\n            if (rtsp_st->ic)\n\n                av_close_input_file(rtsp_st->ic);\n\n        }\n\n        av_free(rtsp_st);\n\n    }\n\n    av_freep(&content);\n\n    url_close(rt->rtsp_hd);\n\n    return err;\n\n}\n", "idx": 20237, "substitutes": {"s": ["a", "hs", "ds", "cs", "os", "z", "as", "server", "t", "w", "its", "p", "sb", "sp", "ses", "ins", "sq", "store", "aws", "h", "set", "qs", "is", "bs", "g", "rs", "gs", "S", "ss", "so", "sw", "sts", "ns", "self", "ps", "sys", "js", "service", "c", "xs", "in", "es", "ats", "r", "n", "fs", "source", "ts", "ssl", "ls", "stats", "ms", "src", "spec", "b", "conf", "serv", "m"], "ap": [" map", "cap", " ip", " op", "pp", " mp", "sp", "tap", "bp", "ar", "ape", "op", "map", "tp", " p", "aps", "ps", "mp", "att", " cp", " sap", " pac", "apt", " sp", "pa", "ep", "al", "ac"], "rt": ["rm", "res", "nt", "t", "tx", "dt", "vt", "rw", "rx", "ctx", "rs", "tmp", "rr", "tr", "mt", "ot", "rec", "ptr", "dr", "sys", "addr", "rd", "rev", "req", "pt", "r", "art", "usr", "rb", "RT", "txt", "bt", "sr", "rn", "ro", "resp", "vr", "tt", "rc", "gt", "it", "rf", "rl"], "host": ["connection", "loc", "server", "mac", "client", "hook", "h", "user", "domain", "owner", "prefix", "node", "subject", "handle", "address", "name", "author", "ip", "http", "addr", "conn", "driver", " Host", "target", "pkg", "dir", "container", "local", "context", "root", "Host", "https", "str", "uri", "cert", "pattern", "home", "localhost", "src", "serv", "ost", "bind", "hop"], "path": ["con", "history", "format", "p", "query", "PATH", "th", "pid", "prefix", "prop", "length", "stat", "name", "method", "pod", "route", "ip", "conn", "msg", "data", "pt", "dir", "id", "ext", "pkg", "ath", "col", "template", "root", "local", "context", "transform", "key", "cert", "cp", "pattern", "chain", "part", "text", "file", "Path"], "tcpname": ["tmpno", "tchaddress", "tchno", "tppName", "tctxNAME", " tcptype", "TmpName", " tmpadmin", "tpnname", " tmpaddress", "tcpaddress", "tmplen", " tcpaddress", "tspname", " tcpadmin", "tpname", "tchname", "Tmpname", "tpkgnames", " tmptype", "Tcpnames", "tmpNAME", "tmpname", "Tcpno", "tppname", "TcpNAME", "tspName", " tcpno", "tpnaddress", "tmpnames", "tpnno", "tmptype", "tcplen", "tpkgname", "Tcpname", "tchadmin", "Tmplen", "Tmpno", "tpnadmin", " tmpno", "Tcplen", "TmpNAME", "tptype", "tcpNAME", "tmpaddress", "tctxnames", "tpkgNAME", " tmpName", " tmpname", "tspno", "tcpno", "tcpName", "tsplen", "tmpadmin", "Tmpnames", "tctxName", "tmpName", "TcpName", "tpName", " tcpName", "tctxname", "tplen", "tpkgName", "tpno", "tcpadmin", "tcptype", "tpptype", "tcpnames"], "cmd": ["patch", "rm", "nt", "comment", "tx", "desc", "md", "ctx", "config", "command", "prop", "send", "ct", "method", "cli", "control", "cd", "MD", "Cmd", "cont", "auth", "tab", "magic", "msg", "req", "data", "id", "dir", "pkg", "ext", "c", "comm", "mk", "cmp", "cfg", "def", "act", "pat", "cod", "txt", "cb", "cp", "rc", "fun", "code", "ctr", "text"], "rtsp_hd": ["rtsport_rh", "rtspt_hard", "rtsport_ctx", "rtsp_ht", "rtsport_hd", "rtsp___dt", "rtsp_ctx", "rtsv_tx", "rtsp_md", "rtsp_conn", "rtsv_hd", "rtspt_ht", "rtsp____rh", "rtsl_dt", "rtsport_conn", "rtsp_tx", "rtsp2ht", "rtsl_hd", "rtsp___rh", "rtspt_hd", "rtsp_ds", "rtsv_md", "rtsp___hd", "rtspt_ds", "rtsp_dt", "rtsp2ds", "rtsp____md", "rtsp_hard", "rtsv_rh", "rtsp2hard", "rtsp___ld", "rtsp____tx", "rtsp____hd", "rtsp_ld", "rtsl_rh", "rtsp_rh", "rtsl_ld", "rtsp2hd"], "port": ["priority", "export", "pos", "connection", "index", "Port", "server", "format", "t", "size", "window", "p", "client", "slot", "ort", "ORT", "timeout", "interface", "pport", "pid", "pc", "count", "age", "length", " sport", "PORT", "position", "ports", "address", "eport", "limit", "ptr", "media", "pro", "ip", "peer", "proxy", " Port", "pi", "pkg", "pt", "page", "to", "line", "ported", "print", "number", "project", "n", "state", "row", "len", "cp", "import", "policy", "it", "P", "localhost", "version", "file", "prot", "type"], "i": ["index", "ij", "si", "t", "ci", "im", "hi", "p", "ei", "ki", "qi", "me", "ir", "li", "is", "e", "I", "u", "ai", "phi", "v", "di", "iter", "ip", "mi", "pi", "c", "ind", "id", "in", "xi", "ti", "batch", "ui", "gi", "n", "o", "multi", "key", "er", "bi", "iu", "x", "info", "sim", "zi", "ini", "gu", "f", "chain", "it", "ix", "b", "y", "ii", "m"], "ret": ["res", "nt", "arr", "deg", "back", "flag", "t", "sent", "dt", "num", "result", "ll", "fr", "tmp", "rr", "tr", "mt", "nz", "fin", "progress", "dr", "ptr", "ft", " Ret", "rem", "success", "sys", "RET", "rev", "re", "reset", "nl", "try", "lit", "r", "val", "fi", "usr", "repl", "del", "alt", "txt", "len", "net", "resp", "gt", "ctr", "elt", "rets", "Ret"], "err": ["br", "rer", "error", "res", "arr", "die", "pr", "Error", "ir", "gz", "kr", "ner", "expr", "fr", "rr", "ch", "fg", "Er", "attr", "ptr", "dr", "doc", "obj", "fee", "aaa", "addr", "iter", "order", "rev", "msg", "req", "ind", "cr", "try", "r", "cfg", "usr", "er", "notice", "txt", "cb", "rn", "status", "rc", "der", "elt", "conf", "lr"], "reply1": ["response1", "answer2", "part2", "ReplyOne", "response2", "Reply1", "reply2", "answer1", "response3", "Reply2", "part1", "answer3", "reply3", "replyOne", "partOne", "responseOne", "Reply3"], "reply": ["frame", "rm", "spr", "error", "nt", "res", "server", "comment", "echo", "p", "sp", "Reply", "report", "result", "fr", "command", "rr", "out", "rep", "se", "response", "esp", "reset", "req", "msg", "nl", "ror", "body", "r", "sync", "ply", "repl", "notice", "txt", "info", "ro", "resp", "write", "transfer", "status", "proxy", "answer"], "content": ["tc", "res", "format", "lex", "comment", "sent", "Content", "CONT", "result", "readable", "output", "config", "header", "load", "empty", "command", "match", "cc", "ct", "address", "out", "accept", "name", "magic", "mask", "cont", "value", "response", "ontent", "cor", "description", "conn", "data", "c", "clean", "ext", "body", "css", "version", "context", "message", "cm", "raw", "quest", "act", "str", "txt", "xml", "resp", "cp", "buffer", "fp", "code", "title", "transfer", "text", "status"], "st": ["sc", "stable", "nt", "z", "t", "ist", "sh", "p", "sp", "stage", "th", "stream", "at", "sv", "tmp", "tr", "mt", "ste", "ct", "sw", "St", "start", "se", "sn", "pt", "inst", "r", "std", "ST", "str", "art", "est", "ts", "irst", "nd", "tt", "rest", "it", "src", "serv", "ost", "status", "ut"], "rtsp_st": ["rtsd_data", "rtsp_ist", "rtsps_ist", "rtsp_se", "rtsps_st", "rtsd_st", "rtsps_tt", "rtsp_ct", "rtsd_nd", "rtsp_tt", "rtsp_nd", "rtsd_ct", "rtsps_se", "rtsp_data"], "protocol_mask": ["protocolnetflag", "protocol__mask", "protocol_bit", "protocol_ask", "protocolityflag", "protocol_flag", "protocolnetask", "protocolnetflags", "protport_mask", "protport_flag", "protocolityfilter", "protport_bit", "protocol__flags", "protocol_map", "protocol_filter", "protocol__ask", "protport_map", "protocolityflags", "protocol_flags", "protocol__flag", "protocolnetmask", "protocolitymask"], "transport": ["transporter", "transports", "ransports", "transferporter", "Transport", "Transporter", "ransname", "ransport", " transports", "ransporter", "transname", "Transband", "ransband", " transname", "Transname", " transband", "Transports", "transband", "transferports", "transferport"], "fmt": ["cftx", " fformat", " flt", "cfformat", "cfmt", "Ftx", " ftx", "ftx", "Flt", "Fmt", "flt", "Fformat", "fformat", "cflt"], "buf": ["cap", "box", "pad", "var", "stream", "count", "map", "length", "conv", "conn", "data", "ref", "pool", "table", "raw", "pack", "str", "block", "len", "buffer", "Buffer", "buff", "code", "seq", "br"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                                int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong phys;\n\n    int prot;\n\n\n\n    /* XXX: implement mmu */\n\n\n\n    phys = address;\n\n    prot = PAGE_READ | PAGE_WRITE;\n\n\n\n    return tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                        phys & TARGET_PAGE_MASK, prot,\n\n                        mmu_idx, is_softmmu);\n\n}\n", "idx": 20238, "substitutes": {"env": ["ten", "cv", "server", "window", "sb", "desc", "proc", "en", "store", "ctx", "end", "nv", "te", "e", "equ", "sv", "config", "vp", "web", "v", "uv", "esc", "ptr", "vs", "ve", "param", "ef", "scope", "dev", "ev", "context", "ce", "viron", "cb", "ah", "code", "conf", "environment"], "address": ["offset", "eth", "index", "location", "memory", "server", "array", "interface", "port", "device", "resource", "ase", "shape", "command", "handle", "position", "name", "pointer", "ptr", "reference", "route", "add", "addr", "order", "range", "page", "r", "host", "message", "number", "path", "uri", "alias", "network", "attribute", "Address", "type", "buffer", "url", "direction", "process"], "rw": ["work", "wp", "w", "wire", "writ", "aw", "nw", "wr", "hw", "wa", "wb", "rar", "route", "req", "dir", "wh", "RW", "rb", "ram", "network", "nc", "row", "rh", "wind", "net", "write", "rf", "rib"], "mmu_idx": ["mmu_midxs", "mmu_midxc", "mmu_midx", "mmu_idxs", "mmu_idz", "mmu__Idx", "mmu_Idy", "mmu_idxc", "mmu_Idxf", "mmu__Idy", "mmu__Idxs", "mmu_pidz", "mmu_Idz", "mmu_idxf", "mmu_idy", "mmu__Idxc", "mmu__idy", "mmu_Idxc", "mmu_pidg", "mmu__idx", "mmu_idg", "mmu_Idxs", "mmu__idxc", "mmu__idxs", "mmu_pidxf", "mmu_Idg", "mmu_midy", "mmu_pidx", "mmu_Idx"], "is_softmmu": ["is_softmmux", "is_SoftmemU", "is_softmemU", "is_Softmmcu", "is_Softmemus", "is_softmemcu", "is_softmmmue", "is_softmemue", "is_softmmmu", "is_softMMu", "is_softMMue", "is_Softmemcu", "is_softmemus", "is_softMMcu", "is_Softmmu", "is_Softmmue", "is_softMMus", "is_softmmmus", "is_softmmus", "is_softmemu", "is_SoftmmU", "is_softmmue", "is_softMMux", "is_Softmemue", "is_softmmcu", "is_Softmemu", "is_Softmemux", "is_softmmU", "is_softMMU", "is_softmmmux", "is_Softmmux", "is_Softmmus", "is_softmemux"], "phys": ["mem", "eth", "snap", "np", "mac", "memory", "phy", "pr", "p", "proc", "port", "pc", "ther", "prop", "phi", "password", "stat", "handle", "cpu", "tp", "pro", "socket", "hw", "ptr", "ip", "ps", "addr", "sys", "mp", "priv", "pi", "physical", "page", "Phys", "rel", "ref", "host", "gpu", "ph", "pas", "path", "arch", "home", "ris", "type"], "prot": ["eth", "pos", "fl", "channel", "fd", "format", "phy", "bits", "p", "at", "port", "tif", " PROT", "tr", "prop", "tp", "stat", "method", "pro", "fat", "tf", "ptr", "addr", "tel", "typ", "cmd", "physical", "rot", "ref", "conduct", "def", "ph", "mult", "pat", "path", "platform", "Prot", "sche", "net", "ocol", "pattern", " proto", "policy", "version", "col", "type"]}}
