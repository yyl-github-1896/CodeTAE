{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         void **refcount_table,\n\n                         int64_t *refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k, refcount;\n\n    int ret;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= *refcount_table_size) {\n\n            ret = realloc_refcount_array(s, refcount_table,\n\n                                         refcount_table_size, k + 1);\n\n            if (ret < 0) {\n\n                res->check_errors++;\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        refcount = s->get_refcount(*refcount_table, k);\n\n        if (refcount == s->refcount_max) {\n\n            fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n            fprintf(stderr, \"Use qemu-img amend to increase the refcount entry \"\n\n                    \"width or qemu-img convert to create a clean copy if the \"\n\n                    \"image cannot be opened for writing\\n\");\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n        s->set_refcount(*refcount_table, k, refcount + 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20248, "substitutes": {"bs": ["js", "gs", "ls", "bb", "rs", "bits", "bc", "bes", "sb", "vs", "bis", "ps", "fs", "ds", "b", "ms", "cs", "bm", "iss", "ts", "ss", "ubis", "aos", "bh", "ubs", "BS", "ns", "cks", "its", "hs", "obs", "bos", "lbs", "als", "bas"], "res": ["reset", "response", "rest", "inv", "rs", "pr", "details", "req", "def", "des", "ps", "resolution", "red", "rem", "rss", "result", "expr", "RES", "ms", "gr", "r", "results", "reg", "cond", "rez", "rev", "re", "resp", "cons", "Res", "wcs", "ress", "resh", "crit", "rec", "os", "pres", "err", "vals", "pas", "rel", "rek", "ack", "pers", "rc"], "refcount_table": ["refchildistdb", "refchild_table", "refname_table", "refcount2list", "refcountistsource", "refcountedtable", "refcountedlist", "refval_list", "refval_table", "refval_database", "refcountisttable", "refcount2TABLE", "refountstable", "refvaledtable", "refchild_source", "refchildisttable", "refountstab", "refcountsTABLE", "refount_TABLE", "refchildistset", "refcount_database", "refcount_Table", "refvaleddatabase", "refount_tab", "refcount_list", "refval_TABLE", "refcount_tab", "refcount_set", "refcountistdb", "refname_tab", "refcountsTable", "refcount_TABLE", "refcount_source", "refchild_set", "refcounteddatabase", "refcount2database", "refcountstab", "refount_table", "refchildistsource", "refcountstable", "refcount_array", "refname_array", "refvaledTABLE", "refountsTABLE", "refcount_db", "refcountistset", "refcountedTABLE", "refcount2table", "refvaledlist", "refchild_db", "refountsTable", "refname_Table", "refount_Table", "refcountsarray"], "refcount_table_size": ["refcount_TABLE_size", "refcount_table_length", "refcount_TABLE_length", "refcount_list_length", "refcount_table_SIZE", "refcount_table2ize", "refcount_table_Size", "refcount_table2size", "refcount_TABLE_ize", "refcount_table2SIZE", "refcount_TABLE_SIZE", "refcount_table2length", "refcount_list_size", "refcount_table_ize", "refcount_list_SIZE"], "offset": ["reset", "end", "alias", "tile", "id", "slot", "seed", "length", "padding", "scroll", "block", "shift", "Offset", "style", "prefix", "address", "top", "empty", "location", "origin", "point", "pointer", "timeout", "pos", "set", "error", "first", "initial", "key", "position", "ref", "et", "slice", "count", "align", "off", "row", "sector", "base", "index", "attribute", "oid", "addr", "begin", "fp", "peer", "seek", "trace"], "size": ["height", "sn", "full", "body", "name", "type", "SIZE", "si", "length", "small", "padding", "range", "scale", "Size", "resolution", "bytes", "amount", "shift", "capacity", "style", "max", "gravity", "large", "send", "address", "storage", "scope", "empty", "no", "timeout", "sum", "shape", "area", "message", "position", "total", "count", "number", "len", "zero", "sized", "ize", "fee", "space"], "s": ["js", "gs", "south", "sn", "sl", "ls", "ssl", "p", "sq", "sp", "rs", "sb", "ps", "bis", "eps", "y", "fs", "ims", "ds", "l", "sm", "b", "ms", "c", "cs", "ess", "sw", "ts", "ses", "serv", "ss", "abilities", "stats", "t", "aws", "less", "g", "ubs", "ns", "series", "its", "ins", "hs", "sam", "sts", "sv", "http", "qs", "h", "sys", "ats", "S", "als", "is", "locks", "pers", "comm"], "start": ["rest", "get", "end", " starting", "sp", "p", "started", "id", "ist", "starting", "range", "it", "shift", "init", "Start", "root", "wind", "top", "arts", "iter", "origin", "step", "pointer", "t", "set", "first", "from", "open", "store", "next", " Start", "row", "before", "base", "pre", "index", "part", " tid", "begin", "art", "space", "st", "seek", "ish", "use"], "last": ["latest", "any", "ast", "rest", "close", "most", "old", "end", "full", "las", "bottom", "stable", "based", "good", "max", "tail", "show", "scope", "reverse", "first", "nd", "est", "total", "next", "largest", "best", "after", "base", "Last", "st", "worst", "since", "final"], "cluster_offset": ["clusterptoffset", "clusterptitem", "cluster_index", "clust_pos", "cluster_Offset", "cluster____key", "clocation_offset", "cluster_url", "clusters_index", "clocation_length", "clocation_url", "cluster_length", "clusters_Offset", "clocation___id", "cluster____item", "clocation___length", "clusterptkey", "cluster___length", "clust_offset", "clusters_point", "cluster____offset", "cluster_item", "cluster_point", "clust_id", "cluster_pos", "cluster_id", "cluster_key", "clust_Offset", "clust_point", "cluster___id", "clust_item", "cluster___offset", "clust_key", "cluster___url", "clocation___offset", "clusters_offset", "clust_position", "clocation_id", "clocation___url", "cluster_position"], "k": ["ac", "ke", "kh", "m", "kan", "kr", "ko", "q", "alpha", "z", "mk", "ijk", "kt", "unk", "K", "ak", "ka", "uk", "km", "n", "kick", "c", "kind", "kw", "kl", "j", "kid", "i", "g", "kb", "ek", "u", "key", "ck", "ks", "ku", "kk", "kn", "sk", "kj", "ask", "wk", "ik", "ack", "ki"], "refcount": [" refcounter", "respcache", " refcall", "refcell", "refcomment", "alfcounter", "efcounter", " refcache", "reount", " refc", "replcomment", " refcell", "refcall", "Refcount", "refcounter", "calcloud", "refcache", "Refount", "reconst", "referenceount", "replcount", "respcount", "Refcall", "alfcell", " refcomment", "Refc", "referencec", "refcloud", "refc", "recomment", "referencecount", "recount", " refconst", " refcloud", "refconst", "refount", "respcounter", "replount", "calcell", "replconst", "calcounter", "efcount", "calcount", "alfcount", "referencecall", " refount", "efcache", "alfcloud"], "ret": ["reset", "try", "num", "alt", " alt", "ter", "tr", "Ret", "jp", "value", "dt", "ext", "rem", "it", "status", "att", "result", " Ret", "true", "rt", "ry", "r", "final", "no", "j", "nt", "deg", "flag", "print", "t", "ft", "net", "reg", "cat", "ref", "rev", "re", "count", "resp", "back", "out", "len", "ll", "rets", "after", "gt", "nz", "sr", "jump", "err", "elt", "RET", "mt", "val"], "check_errors": ["read_errors", "checkdresults", "check_checks", "checkdchecks", "check_results", "checkderrors", "read_rows", "checkdrows", "check_rows", "read_checks", "read_results"], "corruptions": ["corstructions", "chritations", "corrotured", "corritions", "corrupture", "chriture", "corruptations", "chruptured", "corrotions", "chruptions", "corriture", "chruptations", "corritured", "chritions", "corrotations", "corstructations", "corstructure", "chrupture", "corritations", "chritured", "corstructured", "corruptured", "corroture"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    gic_cpu_write(s, id, addr, value);\n\n}\n", "idx": 20257, "substitutes": {"opaque": ["oply", "Opaque", "oppane", "oplaque", "OPaque", "OPly", "opllay", "oplay", "Oposter", "opca", " oposter", "oplane", " opca", "Opent", "OPoster", "opent", " oplay", " oply", "oplca", " opane", "OPent", "Oply", " opent", "oppaque", "oppca", "oposter", "opplay", "opane"], "addr": ["arp", "add", "Address", "adr", "alias", "rs", "state", "at", "pad", "loc", "ptr", "ace", "src", " address", "offset", "inter", "attr", "dh", "rt", "address", "r", "tx", "ord", "wd", "cmd", "host", "dr", "pos", "ip", "ref", "store", "work", "off", "now", "eth", "handle", "obj", "x", "hw", "err", "alloc", "ad", "fx"], "value": ["volume", " amount", "Value", "vector", "property", "data", " pair", "state", "memory", "name", "type", "length", "ay", "content", "ue", " values", "values", " quantity", "address", " v", "function", "func", "set", "message", " cost", "buffer", "val", "VALUE", " weight", " parameter", "number", "code", " sequence", "byte", "mem", " val", "index", "fee", "block", "v", " sum"], "size": ["ity", "num", "data", " length", "z", "bits", "name", "type", "SIZE", "length", "Size", "n", "bytes", "offset", "l", "info", "address", "args", "count", "buf", "len", "mem", "ize", "weight", "v", "val"], "backref": ["backpointer", "BACKreference", "sideRef", "frontRef", "Backreference", "Backptr", "sideptr", "BACKRef", " backreference", "sideref", "backRef", "Backpointer", "frontpointer", "sidereference", " backpointer", "BackRef", " backptr", "backptr", "Backref", "frontref", "backreference", "frontreference", "BACKref", " backRef"], "s": ["js", "gs", "m", "sl", "ls", "p", "sq", "o", "rs", "bs", "state", "z", "d", "sb", "n", "ps", "sis", "l", "ds", "b", "c", "cs", "r", "ts", "ss", "i", "stats", "t", "less", "set", "g", "ns", "ins", "hs", "a", "e", "source", "sts", "sv", "h", "se", "os", "S", "als", "sd", "f", "is", "v"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n", "idx": 20282, "substitutes": {"addr": ["ctx", "pkg", "ix", "oc", "add", "arp", "adr", "alt", "at", "id", "pad", "help", "ag", "d", "ptr", "ay", "src", "offset", "inter", "att", "attr", "dh", "address", "r", "tx", "cmd", "dr", "act", "gate", "ref", "et", "align", "store", "off", "coord", "eth", "hl", "arr", "hw", "err", "alloc", "ad", "ack", "v"], "val": ["ac", "ctx", "num", "sl", "vt", "aval", "q", "data", "ival", "p", "z", "vc", "pr", "sel", "loc", "port", "util", "sol", "value", "it", "pl", "test", "bit", "ret", "vol", "lib", "VAL", "tx", "serv", " value", "pt", "eval", "res", "reg", "Val", "buffer", "pol", "ref", "var", "al", "bal", "buf", "len", "arg", "all", "mem", "arr", "index", "x", "cal", "vals", "fee", "err", "valid", "f", "v"]}}
{"project": "qemu", "commit_id": "9f2130f58d5dd4e1fcb435cca08bf77e7c32e6c6", "target": 0, "func": "static int fb_initialise(struct XenDevice *xendev)\n\n{\n\n    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);\n\n    struct xenfb_page *fb_page;\n\n    int videoram;\n\n    int rc;\n\n\n\n    if (xenstore_read_fe_int(xendev, \"videoram\", &videoram) == -1)\n\n\tvideoram = 0;\n\n\n\n    rc = common_bind(&fb->c);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    fb_page = fb->c.page;\n\n    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,\n\n\t\t\t    fb_page->width, fb_page->height, fb_page->depth,\n\n\t\t\t    fb_page->mem_length, 0, fb_page->line_length);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    rc = xenfb_map_fb(fb);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n#if 0  /* handled in xen_init_display() for now */\n\n    if (!fb->have_console) {\n\n        fb->c.ds = graphic_console_init(xenfb_update,\n\n                                        xenfb_invalidate,\n\n                                        NULL,\n\n                                        NULL,\n\n                                        fb);\n\n        fb->have_console = 1;\n\n    }\n\n#endif\n\n\n\n    if (xenstore_read_fe_int(xendev, \"feature-update\", &fb->feature_update) == -1)\n\n\tfb->feature_update = 0;\n\n    if (fb->feature_update)\n\n\txenstore_write_be_int(xendev, \"request-update\", 1);\n\n\n\n    xen_pv_printf(xendev, 1, \"feature-update=%d, videoram=%d\\n\",\n\n\t\t  fb->feature_update, videoram);\n\n    return 0;\n\n}\n", "idx": 20283, "substitutes": {"xendev": [" xindDev", "xndect", "xiendedee", "xadddev", "zendeddev", "vendew", " xendsep", "xendsele", " xindapter", " xendsev", "xsendew", "xendew", "xndew", "xnddevice", "wxenddevice", "xendsDev", "xndec", "xsenddev", "xideapter", "zendedev", "xideep", "xendedep", "xendele", "xendv", "xendserv", " xinderv", "xendsev", "xiendedele", "xndv", "xendapter", " xendapter", "xiendedev", "zendev", "wxendev", "xenec", "zenddev", "xenddev", "wxendeddevice", "xenele", "xndev", "xengev", "xenev", " xendep", "xidedev", " xindev", "xendedew", "xengdevice", " xenddev", "vendev", "xendsep", "vndDev", " xendsapter", "xidDev", "xsendev", "zendep", " xendsdev", "wxenddev", " xenderv", "xendeddevice", "xnddev", "ixendect", "ixendedec", "xendedev", "xendedDev", "xendedele", "xendedec", "ixendev", "wxendeddev", "xenee", " xendDev", "vndew", "xidev", "zendedv", "xindDev", "xendedv", "xendedee", "xengdev", "xiendew", "vnddev", "xengec", "xendsapter", "xideev", "xendsew", "vndev", "vendDev", "xendDev", "xendsdev", "xindapter", "venddev", "xenect", "ixendedev", "xidapter", "xaddv", "xendec", "xaddep", "wxendedev", "xendep", "xiendee", "xndapter", "zendv", "xendedect", "ixendedect", "xiderv", "xiendev", "xsendDev", "xenddevice", "wxendec", "xindev", "xendect", "xiendele", "ixendec", "xaddev", "xndDev", "xendeddev", "wxendedec", "xndep", "xenew", "xendsee", "ixendeddev", "xendee", "xiendedew", "zendedep", "ixenddev", "xinderv", "xenderv"], "fb": ["bridge", "bb", "pp", "bs", "fw", "icc", "fd", "fs", "rh", "hab", "grab", "rb", "rf", "pb", "buf", "bf", "tf", "fen", "f", "cb", "ctx", "uf", "vt", "nb", "be", "deb", "fl", "ctrl", "xff", "wb", "gb", "bp", "vy", "hd", "b", "bm", "buff", "fab", "abb", "fam", "fax", "fm", "beck", "fx", "face", "ff", "eb", "blog", "fr", "gold", "abl", "wp", "facebook", "zy", "eval", "gif", "fi", "xf", "abc", "FB", "fee", "fp", "btn", "ffff", "sb", "fe", "ab", "fa", "ob", "raf", "fc", "bt", "fuel", "db", "buffer", "ref", "lb", "fg"], "fb_page": ["fbgetrecord", "ffff_message", "bufgetclient", "fbgetclient", "fb_pool", "fbmlmessage", "fbmyrecord", "eb_point", "ebmyline", "fb_disk", "fbpromemory", "fb_memory", "fb_line", "buf_page", "fw_page", "fbmyclient", "ffff_space", "facebook_load", "fb_point", "fb1record", "ebmypage", "fbprophrase", "fb_message", "fw_port", "facebook_pool", "eb_page", "facebook_pointer", "fb_client", "fw_c", "abb_phrase", "fbgetpage", "fb_map", "fbmypage", "ebmypoint", "fbmlspace", "fbmlclient", "fb_record", "fb_space", "ffff_page", "buf_chain", "eb_line", "fb_load", "fb_pages", "fb_c", "eb_record", "buf_client", "abb_disk", "bufgetchain", "fbmatpages", "facebook_map", "bufgetpage", "ffff_client", "fbprodisk", "facebook_page", "bufgetrecord", "ebmyrecord", "fbmatpointer", "fb1chain", "fbmatload", "abb_memory", "fbmyline", "fbmypoint", "fb_port", "fb_chain", "facebook_p", "fw_point", "fb1client", "fb_phrase", "fb_p", "facebook_pages", "fbpropage", "fb1page", "fbmatpage", "fb_pointer", "buf_record", "fbmlpage", "fbgetchain", "abb_page", "fbmychain"], "videoram": ["videoam", "videoredim", "videoriot", "videratorom", "videORim", "videorationom", "vieoramm", "videoredacion", "videORamm", "vendoAM", "videoAM", "videorationiam", "videORacion", "videoredamm", "videorAM", "vidoramin", "videoramm", "viderorom", "vendoriam", "videorsams", "videoriam", "videorsay", "videatorot", "viderorot", "videORiam", "vendoray", "videoray", "vieoredacion", "vieorim", "vendoam", "videorationAm", "vieoracion", "videoriamin", "videatorom", "vendORom", "videorsiam", "vendORam", "vieoredamm", "videoriom", "videorom", "videraramm", "videoay", "videratoramer", "videorsom", "videORAm", "videorsAm", "vidoriam", "viderarim", "vendorAM", "videratorot", "videorot", "videoams", "videorsamin", "videorim", "videoracion", "videraram", "videoriay", "videatoramer", "vidorams", "videraracion", "videonam", "videorsAM", "videorableam", "videatoram", "vieoredam", "vidoram", "videoredam", "videoriiam", "videoramin", "videorsam", "vendORiam", "vidoriiam", "videorams", "videratoram", "vendorams", "videonamer", "videORom", "videoriAM", "vidoriamin", "videoramer", "videorableamin", "vendoay", "vendoams", "vendORAm", "vieoredim", "videorableiam", "videroramer", "videoriamer", "videoriams", "vendorom", "videORam", "vieoram", "videonot", "vendoram", "videorableams", "vendorAm", "videroram", "videorationam", "vidoriams", "videonom", "videorAm"], "rc": ["rx", "cor", "roc", "rs", " RC", "tc", "sc", "rys", "rh", "cs", "ok", "uc", "dr", "auc", "pc", "dc", "cur", "con", "ro", " proc", "arc", "cod", "ac", "rin", "gc", "yes", "xff", "cc", " cr", "rac", "co", "rt", "core", "RC", "ec", "desc", "ctr", "usr", "priv", "ack", "cont", "ras", "cr", "success", "ko", "nc", "r", "lc", "raw", "clus", "res", "ck", "re", "userc", "row", "comp", "rl", "sys", "isc", "bc", "src", "irc", "c", "ry", "sync", "func", "ce", "cd", "code", "rec", " ro", "rr", "cmp"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static void gen_exts(int ot, TCGv reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        tcg_gen_ext8s_tl(reg, reg);\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_ext16s_tl(reg, reg);\n\n        break;\n\n    case OT_LONG:\n\n        tcg_gen_ext32s_tl(reg, reg);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 20299, "substitutes": {"ot": ["rot", "ott", "Mot", "ox", "oc", "isc", "at", "hot", "tt", "or", " mot", "iat", " tot", "typ", "y", "it", "ant", "quote", "mot", "ort", "rt", " dot", "ote", "pot", "yt", "nt", "pt", "iot", "t", "OT", "ota", " pt", "et", "oting", "cot", "ent", "lot", "oid", "os", "oot", "oted", "ots", "ct"], "reg": ["gc", "gro", "rect", "eg", "dat", "p", "or", "req", "rom", "gov", "tag", "eng", "gb", "domain", "cache", "disc", "br", "Reg", " region", " registry", "rem", "ring", "region", "ret", "gr", "r", "grid", "serv", "gen", "cmd", "org", "go", "act", "rar", "net", "res", "db", "g", "REG", "msg", "asm", "re", "ru", "leg", " rg", "mem", "rec", "rule", "rg", "form", "sys", "addr", "lang", "urg", "rm", "err", "greg", "istry", "pool", "val"]}}
{"project": "qemu", "commit_id": "c0462f6d75fa481f7660c15a5ca3a60205aa4eca", "target": 0, "func": "bool is_valid_option_list(const char *param)\n\n{\n\n    size_t buflen = strlen(param) + 1;\n\n    char *buf = g_malloc(buflen);\n\n    const char *p = param;\n\n    bool result = true;\n\n\n\n    while (*p) {\n\n        p = get_opt_value(buf, buflen, p);\n\n        if (*p && !*++p) {\n\n            result = false;\n\n            goto out;\n\n        }\n\n\n\n        if (!*buf || *buf == ',') {\n\n            result = false;\n\n            goto out;\n\n        }\n\n    }\n\n\n\nout:\n\n    free(buf);\n\n    return result;\n\n}\n", "idx": 20301, "substitutes": {"param": ["min", "cp", "perm", "m", "command", "me", "num", "program", "mm", "par", "params", "type", "jp", "pm", "vim", "padding", "tag", "cm", "prop", "rem", "prefix", "attr", "address", "config", "mark", "im", "dm", "argument", "aram", "buffer", "dem", "target", "ref", "member", "comment", "Param", "prom", "Parameter", "ram", "arg", "form", "package", "index", "attribute", "part", "cal", "v"], "buf": ["ctx", "cp", "pkg", "uf", "np", "bar", "v", "data", "seq", "pad", "cast", "bag", "bc", "pend", "bin", "port", "tmp", "wb", "bp", "br", "Buffer", "ah", "que", "result", "b", "proc", "buff", "iter", "cmd", "img", "func", "brace", "bh", "paren", "bl", "rb", "buffer", "cat", "msg", "txt", "ref", "vec", "bu", "Buff", "window", "cam", "cur", "pb", "emb", "mem", "conv", "arr", "h", "queue", "str", "batch", "pg", "err", "cap", "block", "pool", "cb", "cv"], "p": ["ctx", "cp", "pkg", "perm", "m", "pid", "tp", "q", "np", "pp", "sp", "par", "pr", "jp", "pe", "d", "ptr", "bp", "ps", "n", "prop", "l", "P", "result", "b", "rep", "wp", "c", "r", "pot", "j", "i", "point", "pt", "pointer", "pos", "t", "g", "pro", "buffer", "pc", "pa", "pb", "ping", "pre", "h", "x", "lp", "part", "fp", "f", "pers", "v"]}}
{"project": "FFmpeg", "commit_id": "099d6813c27faf95257a529aa2c65dfde816a487", "target": 1, "func": "int ff_h264_alloc_tables(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int big_mb_num= s->mb_stride * (s->mb_height+1);\n\n    const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;\n\n    int x,y;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)\n\n\n\n    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n\n    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);\n\n    for(y=0; y<s->mb_height; y++){\n\n        for(x=0; x<s->mb_width; x++){\n\n            const int mb_xy= x + y*s->mb_stride;\n\n            const int b_xy = 4*x + 4*y*h->b_stride;\n\n\n\n            h->mb2b_xy [mb_xy]= b_xy;\n\n            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));\n\n        }\n\n    }\n\n\n\n    s->obmc_scratchpad = NULL;\n\n\n\n    if(!h->dequant4_coeff[0])\n\n        init_dequant_tables(h);\n\n\n\n    return 0;\n\nfail:\n\n    free_tables(h, 1);\n\n    return -1;\n\n}\n", "idx": 20305, "substitutes": {"h": ["pp", "hhh", "oh", "hm", "rh", "info", "eh", "dr", "her", "ch", "op", "hw", "f", "ctx", "q", "zh", "o", "hz", "ih", "cache", "each", "ht", "hd", "b", "bh", "jpg", "hash", "hh", "v", "hi", "m", "here", "br", "ph", "fr", "history", "H", "hp", "ssh", "hs", "hl", "http", "exec", "th", "comm", "ha", "kh", "p", "_", "w", "ho", "def", "ah", "has", "dh", "c", "sh", "he", "gh", "host", "func", "hal"], "s": ["sp", "bs", "rs", "conf", "ants", "gets", "fs", "ims", "cs", "stats", "ins", "its", "wcs", "a", "os", "ctx", "ls", "es", "o", "vs", "ties", "ps", "ds", "b", "ts", "serv", "his", "conv", "se", "is", "v", "js", "gs", "m", "tes", "sl", "tools", "ges", "parts", "css", "ms", "history", "ses", "ss", "aws", "g", "session", "ers", "hs", "sts", "sys", "ats", "sports", "comm", "spec", "p", "sq", "w", "sb", "n", "has", "les", "c", "sh", "sw", "j", "ys", "i", "t", "ns", "e", "sv", "qs", "S", "als", "ops"], "x": ["m", "ox", "rx", "ix", "p", "o", "z", "dx", "w", "n", "l", "tx", "i", "t", " i", " xx", "X", "e", "xy", "xs", "index", " X", "px", "ex", "f", "v"], "y": ["iy", "m", "yl", "p", "my", "o", "ym", "n", "py", "vy", "ly", "b", "ny", "ry", "Y", "j", "i", "t", "yy", "key", "ey", "dy", "e", "ch", "xy", "cy", "sy", "v"]}}
{"project": "FFmpeg", "commit_id": "3583eb93410a73cac8ddf291baa405005ff4c405", "target": 0, "func": "static inline CopyRet copy_frame(AVCodecContext *avctx,\n\n                                 BC_DTS_PROC_OUT *output,\n\n                                 void *data, int *data_size,\n\n                                 uint8_t second_field)\n\n{\n\n    BC_STATUS ret;\n\n    BC_DTS_STATUS decoder_status;\n\n    uint8_t is_paff;\n\n    uint8_t next_frame_same;\n\n    uint8_t interlaced;\n\n\n\n    CHDContext *priv = avctx->priv_data;\n\n\n\n    uint8_t bottom_field = (output->PicInfo.flags & VDEC_FLAG_BOTTOMFIELD) ==\n\n                           VDEC_FLAG_BOTTOMFIELD;\n\n    uint8_t bottom_first = !!(output->PicInfo.flags & VDEC_FLAG_BOTTOM_FIRST);\n\n\n\n    int width    = output->PicInfo.width;\n\n    int height   = output->PicInfo.height;\n\n    int bwidth;\n\n    uint8_t *src = output->Ybuff;\n\n    int sStride;\n\n    uint8_t *dst;\n\n    int dStride;\n\n\n\n    ret = DtsGetDriverStatus(priv->dev, &decoder_status);\n\n    if (ret != BC_STS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"CrystalHD: GetDriverStatus failed: %u\\n\", ret);\n\n       return RET_ERROR;\n\n    }\n\n\n\n    is_paff           = ASSUME_PAFF_OVER_MBAFF ||\n\n                        !(output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC);\n\n    next_frame_same   = output->PicInfo.picture_number ==\n\n                        (decoder_status.picNumFlags & ~0x40000000);\n\n    interlaced        = ((output->PicInfo.flags &\n\n                          VDEC_FLAG_INTERLACED_SRC) && is_paff) ||\n\n                         next_frame_same || bottom_field || second_field;\n\n\n\n    av_log(avctx, AV_LOG_VERBOSE, \"CrystalHD: next_frame_same: %u | %u | %u\\n\",\n\n           next_frame_same, output->PicInfo.picture_number,\n\n           decoder_status.picNumFlags & ~0x40000000);\n\n\n\n    if (priv->pic.data[0] && !priv->need_second_field)\n\n        avctx->release_buffer(avctx, &priv->pic);\n\n\n\n    priv->need_second_field = interlaced && !priv->need_second_field;\n\n\n\n    priv->pic.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE |\n\n                             FF_BUFFER_HINTS_REUSABLE;\n\n    if (!priv->pic.data[0]) {\n\n        if (avctx->get_buffer(avctx, &priv->pic) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return RET_ERROR;\n\n        }\n\n    }\n\n\n\n    bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n\n    if (priv->is_70012) {\n\n        int pStride;\n\n\n\n        if (width <= 720)\n\n            pStride = 720;\n\n        else if (width <= 1280)\n\n            pStride = 1280;\n\n        else if (width <= 1080)\n\n            pStride = 1080;\n\n        sStride = av_image_get_linesize(avctx->pix_fmt, pStride, 0);\n\n    } else {\n\n        sStride = bwidth;\n\n    }\n\n\n\n    dStride = priv->pic.linesize[0];\n\n    dst     = priv->pic.data[0];\n\n\n\n    av_log(priv->avctx, AV_LOG_VERBOSE, \"CrystalHD: Copying out frame\\n\");\n\n\n\n    if (interlaced) {\n\n        int dY = 0;\n\n        int sY = 0;\n\n\n\n        height /= 2;\n\n        if (bottom_field) {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: bottom field\\n\");\n\n            dY = 1;\n\n        } else {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: top field\\n\");\n\n            dY = 0;\n\n        }\n\n\n\n        for (sY = 0; sY < height; dY++, sY++) {\n\n            memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);\n\n            if (interlaced)\n\n                dY++;\n\n        }\n\n    } else {\n\n        av_image_copy_plane(dst, dStride, src, sStride, bwidth, height);\n\n    }\n\n\n\n    priv->pic.interlaced_frame = interlaced;\n\n    if (interlaced)\n\n        priv->pic.top_field_first = !bottom_first;\n\n\n\n    if (output->PicInfo.timeStamp != 0) {\n\n        priv->pic.pkt_pts = opaque_list_pop(priv, output->PicInfo.timeStamp);\n\n        av_log(avctx, AV_LOG_VERBOSE, \"output \\\"pts\\\": %\"PRIu64\"\\n\",\n\n               priv->pic.pkt_pts);\n\n    }\n\n\n\n    if (!priv->need_second_field) {\n\n        *data_size       = sizeof(AVFrame);\n\n        *(AVFrame *)data = priv->pic;\n\n    }\n\n\n\n    if (ASSUME_TWO_INPUTS_ONE_OUTPUT &&\n\n        output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) {\n\n        av_log(priv->avctx, AV_LOG_VERBOSE, \"Fieldpair from two packets.\\n\");\n\n        return RET_SKIP_NEXT_COPY;\n\n    }\n\n\n\n    return RET_OK;\n\n}\n", "idx": 20320, "substitutes": {"avctx": ["avecf", "avercf", " avcfg", "avesc", " avconn", "savcu", " avsc", "vrctx", "awconn", " avcontext", "savctx", "avercontext", "avefc", "averctx", "avercu", "averfc", " avtxt", "vrtxt", "avconn", "awcontext", "AVtx", " avcmd", "vrcontext", "avecontext", "savcf", "avcu", "AVcfg", "avfc", "awctx", "avertx", " avfc", "AVconn", "vrpkg", "avcfg", "avectx", "avpkg", "savjac", "awcmd", "avcontext", "avertxt", "avjac", "avsc", "AVctx", "avejac", "vrtx", "avecu", "averjac", "AVcontext", "awpkg", "vrconn", "awtx", "avercfg", " avtx", "avcf", "avcmd", "aversc", "vrcmd", "avtx", " avpkg", "avtxt"], "output": ["ilo", "command", "product", "public", "four", "write", "success", "export", "input", "o", "file", "sort", "secure", "image", "hidden", "web", "production", "console", "generated", "common", "module", "cache", "version", "global", "protected", "print", "text", "info", "config", "no", "online", "detail", "Output", "video", "net", "network", "format", "remote", "put", "prev", "document", "buffer", "update", "open", "error", "position", "PUT", "outer", "see", "answer", "out", "entity", "operation", "option", "policy", "display", "op", "connection", "filter", "new", "progress", "block", "response", "final"], "data": ["dat", "p", "input", "start", "received", "bits", "id", "pad", "name", "image", "bin", "w", "d", "mu", "bytes", "offset", "text", "doc", "tx", "empty", "no", "da", "pointer", "pos", "t", "extra", "map", "message", "sample", "pipe", "buffer", "window", "buf", "next", "out", "actions", "DATA", "ata", "batch", "ops", "block", "Data", "table"], "data_size": ["data_len", "image_length", "image_len", "data_length", "data_type", "image_size", "image_type"], "second_field": ["secondFilebuffer", "second_margin", "secondFieldfields", "secondFilefields", "Second_field", "Second___buffer", "third_margin", "third_field", "second_fields", "Second___field", "Second_buffer", "secondFilefield", "third_fields", "secondFieldbuffer", "Second_fields", "third_buffer", "Second___fields", "second___buffer", "second___fields", "second_buffer", "secondFieldmargin", "secondFilemargin", "second___field", "secondFieldfield"], "ret": ["reset", "report", "terror", "alt", "state", "imp", "Return", "ter", "tr", " returned", "Ret", "jp", "def", "reply", "status", " Ret", "result", "fun", " resp", "rt", "final", "r", "lit", "nt", "deg", "detail", "t", "ft", "res", " res", " RET", "cat", "txt", "rev", "ref", "re", "summary", "resp", "hash", "std", "out", "code", "obj", "len", "desc", "rets", "gt", "err", "elt", "RET", "prot", "sat", "stat", "mt", "cont", "val"], "decoder_status": ["decoderCstatus", "decoderpystatus", "decoderationstatus", "decode_report", "decoderpystats", "decoder_state", "decoder_stat", "decoder__report", "decoder__status", "decode_Status", "decoder2stat", "decoding_msg", "decode_stat", "decode_stats", "decoder_stats", "decoder_score", "decoder_msg", "decoderationscore", "decoderCStatus", "decoderCstat", "decoder__score", "decoder__stats", "decoded_stat", "decode_state", "decoderCstate", "decoder_Status", "decoder_report", "decoderpyreport", "decoded_status", "decoderationmsg", "decoder2status", "decoded_Status", "decoding_status", "decoder__msg", "decoder2Status", "decoderpyStatus", "decoding_score", "decoder__Status", "decoder2state", "decode_status"], "is_paff": ["is_spiffe", "is_muff", "is_maffe", "is_mff", "is_cpaffe", "is_Paffe", "is_vaffe", "is2puff", "is_bpaf", "is_mcap", "is_cpaff", "is_caff", "is2paf", "is_spuff", "is_spaff", "is2maf", "is_pff", "is2paffe", "is_maf", "is_ciffe", "is_vff", "is_cuff", "is_paffe", "is_cpuff", "is_Paff", "is_spaf", "is_paf", "is_bpaff", "is2muff", "is_puff", "is_pcap", "is_Pcap", "is_bpiffe", "is_cpaf", "is_Pff", "is_bpuff", "is2maff", "is_piffe", "is_Puff", "is_maff", "is2maffe", "is_caf", "is2paff", "is_Paf", "is_vcap", "is_vaff"], "next_frame_same": ["next_Frame_safe", "next_frame_equal", "next_Frame_equal", "next_framelynum", "next_framelysame", "next_frame_match", "next_frames_good", "next_frame_num", "next_frame_present", "next_frames_match", "next_frame_ident", "next_frame_good", "next_frames_equal", "next_framelyident", "next_framelyequal", "next_Frame_good", "next_frame_safe", "next_Frame_same", "next_frames_present", "next_frames_same"], "interlaced": ["interplaed", "interlitaded", "interplisted", " interlacer", "INTERlocated", "interlitacer", " interlisted", "interlocated", "intervlocated", "intercomplocated", "interplaced", "intervlaed", "interraced", " interlocated", "interflocated", "INTERplaced", "interrocated", "INTERlaced", "intercomplaed", "interlayaded", " interlayaded", "interlayocated", "interlayacer", "INTERplocated", "interristed", "interraded", "interlcacer", "interflaced", "interladed", "interpladed", "interlitaced", "interlace", "interlcaced", "interlaed", " interlayaced", "interplocated", "intercomplace", "intervlaced", "interlacer", "interlcaded", " interplisted", " interplocated", "intervlace", "interplace", "interlisted", " interpladed", "INTERlace", "interlcocated", " interlayacer", "INTERlaed", " interladed", "INTERplace", "interlitocated", " interplaced", "interlayaced", "interfladed", "intercomplaced", "INTERplaed", " interlayocated", "interflisted"], "priv": ["ctx", "cfg", "dev", "cp", "perm", "pkg", "pub", "sp", "soc", "ev", "pr", "tr", "conf", "req", "deb", "Pri", "loc", "gov", "ptr", "notice", "conn", "prop", "rw", "ocr", "sky", "expr", "good", "attr", "rep", "proc", "access", "Priv", "lib", "serv", "org", "stats", "auth", "encrypted", "pro", "env", "not", "riv", "pol", "ssh", "pri", "rib", "sec", "trust", "ch", "mem", "usr", "policy", "pic", "sys", "pre", "pi", "private", "por", "urg", "alloc", "pas", "cmp", "rc", "prov"], "bwidth": ["Bsize", "dstr", "dsize", " bstr", "bsize", " bsize", "dWidth", "bWidth", " bWidth", "dwidth", "bstr", "Bwidth", "Bstr", "BWidth"], "src": ["dir", "inst", "sn", "input", "rs", "loc", "tmp", "ptr", "sb", "sc", "iv", "dest", "ser", "attr", "img", "origin", "bh", "bg", "sub", "txt", "buf", "source", "comp", "usr", "sys", "rl", "rel", "rc"], "sStride": ["sstrat", "sStrat", "tsRestride", "tsStride", "tsRestide", "sSpr", "sSpride", "tsStrat", "tsRestrat", "sStr", "tsStr", "sstide", "sRestide", "tsStide", "sSprat", "sSpide", "tsRestr", "sstride", "sRestrat", "sRestride", "sstr", "sStide", "sRestr"], "dst": ["idbl", "mst", "mth", "dsc", "msc", "jth", "idst", "jsc", "mbl", "jbl", "dbl", "idth", "jst", "idsc", "dth"], "dStride": ["dSTrd", "dstide", "dstrd", "bStrip", "dSlrip", "bStride", "bSlrd", "bStide", "dSTide", "dSlrd", "dSTrip", "dstrip", "dStrip", "bSlride", "dStrd", "dstride", "bStrd", "dSlride", "bSlide", "dStide", "bSlrip", "dSlide", "dSTride"]}}
{"project": "qemu", "commit_id": "d4754a953196516b16beef707dcdfdb35c2eec6e", "target": 1, "func": "static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n", "idx": 20327, "substitutes": {"nc": ["ctx", "gc", "nw", "sn", "np", "nb", "cn", "bc", "mn", "nm", "nec", "nn", "tc", "anc", "n", "conn", "cc", "rn", "mc", "sc", "NT", "c", "cs", "nl", "fc", "nic", "nt", "net", "NC", "pc", "tn", "ns", "dc", "unc", "nd", "ck", "nv", "nz", "nr", "ne", "cb", "cv", "ct"], "s": ["js", "gs", "spec", "sn", "sl", "ls", "ssl", "sq", "sp", "es", "rs", "bs", "conf", "w", "sb", "sol", "n", "ps", "y", "fs", "sis", "ds", "sm", "sa", "b", "an", "cs", "sync", "as", "iss", "sw", "ses", "ts", "j", "ss", "stats", "t", "aws", "ns", "its", "changes", "ins", "hs", "a", "sam", "obj", "sts", "sv", "qs", "sys", "ats", "se", "os", "h", "S", "new", "ops", "stat", "is", "sports", "comm"]}}
{"project": "qemu", "commit_id": "79d5ca5617cfc9be13a4f314ed800fca1267d903", "target": 1, "func": "static AioHandler *find_aio_handler(int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    LIST_FOREACH(node, &aio_handlers, node) {\n\n        if (node->fd == fd)\n\n            return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 20328, "substitutes": {"fd": ["lf", "pid", "ff", "fff", "dir", "id", "td", " fid", "flags", "ln", "d", "ld", "pd", "dt", "fs", "fa", "ds", "hd", "fin", "fn", "fc", "du", "ord", "dn", "cond", "db", "fi", "dl", "nd", "ed", "cd", "dc", "dd", "ud", "FD", "sd", "len", "eth", "ind", "bf", "bd", "fp", "fm", "fed", "io", "f", "cb", "df"], "node": ["post", "m", "nw", "list", "this", "inner", "np", "data", "parent", "id", "entry", "handler", "manager", "seed", "name", "path", "d", "tmp", "nil", "field", "tree", "nn", "n", "component", "content", "self", "hd", "holder", "good", "result", "attr", "c", "root", "fn", "slave", "item", "edge", "nt", "server", "leaf", "t", "document", "normal", "k", "db", "nd", "cd", "child", "msg", "key", "adj", "link", "desc", "note", "len", "event", "instance", "obj", "e", "row", "source", "local", "index", "new", "Node", "f", "wife"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,\n\n                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    int i;\n\n#if COMPILE_TEMPLATE_MMX\n\n    if(!(c->flags & SWS_BITEXACT)) {\n\n        long p= 4;\n\n        const int16_t *src[4]= {alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW};\n\n        uint8_t *dst[4]= {aDest, dest, uDest, vDest};\n\n        x86_reg counter[4]= {dstW, dstW, chrDstW, chrDstW};\n\n\n\n        if (c->flags & SWS_ACCURATE_RND) {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121_ACCURATE\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        } else {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        }\n\n        return;\n\n    }\n\n#endif\n\n    for (i=0; i<dstW; i++) {\n\n        int val= (lumSrc[i]+64)>>7;\n\n\n\n        if (val&256) {\n\n            if (val<0) val=0;\n\n            else       val=255;\n\n        }\n\n\n\n        dest[i]= val;\n\n    }\n\n\n\n    if (uDest)\n\n        for (i=0; i<chrDstW; i++) {\n\n            int u=(chrSrc[i       ]+64)>>7;\n\n            int v=(chrSrc[i + VOFW]+64)>>7;\n\n\n\n            if ((u|v)&256) {\n\n                if (u<0)        u=0;\n\n                else if (u>255) u=255;\n\n                if (v<0)        v=0;\n\n                else if (v>255) v=255;\n\n            }\n\n\n\n            uDest[i]= u;\n\n            vDest[i]= v;\n\n        }\n\n\n\n    if (CONFIG_SWSCALE_ALPHA && aDest)\n\n        for (i=0; i<dstW; i++) {\n\n            int val= (alpSrc[i]+64)>>7;\n\n            aDest[i]= av_clip_uint8(val);\n\n        }\n\n}\n", "idx": 20338, "substitutes": {"c": ["ctx", "cp", "ac", "m", "ci", "ca", "cn", "conf", "bc", "w", "d", "tc", "n", "cm", "mc", "cc", "C", "l", "co", "com", "b", "s", "cs", "fc", "lc", "kw", "config", "enc", "ec", "t", "ce", "g", "dc", "cv", "con", "e", "cu", "h", "cf", "rc", "cmp", "f", "cont", "v", "ct"], "lumSrc": ["lumRsrs", "luvSnc", "lumSnc", "lumInsrc", "lumAssrc", "lumAsRC", "luvIduf", "lumbAsRC", "lumInssrc", "luvIdrc", "lumIdrc", "luvSuf", "lumSr", "lumbSr", "lumbAsrc", "lumInsRC", "lumCvc", "lamSRC", "lumSvc", "lumbAssrc", "lumIdrs", "lamSrt", "lumSrt", "lumCrt", "lumPRC", "lumSrs", "lumSsrc", "lumSourcers", "lumPrc", "lumbSsrc", "lumbSRC", "lumIdnc", "lumSourceuf", "lumRsrc", "lumSourcerc", "lumbSrc", "lumPrt", "lumIduf", "lumCRC", "lumSuf", "luvSrc", "lumCrc", "lamSrc", "lumInsr", "luvSrs", "lumRsnc", "lumAsr", "lumSRC", "lumRsuf", "lumAsrc", "lamSvc", "lumPvc", "lumSourcenc", "luvIdnc", "luvIdrs", "lumbAsr"], "chrSrc": ["chrRic", "chrRRC", "chrSRC", "chrSlsrc", "chrSvc", "chrSourcers", "chrSourcesrc", "chrInsrc", "chrcInsrc", "chrRrc", "chrSecRC", "chrgSuf", "chdrSourcerc", "chrSecic", "chdrSsrc", "chrSourcerc", "charRsrc", "chrSrl", "chrSluf", "chrInsla", "chdrSourceRC", "charSrc", "chrgSrt", "chrInsuf", "chrDic", "chrSourceRC", "chrSlrt", "chrPrc", "charSRC", "chdrSrs", "chrSource", "chrSla", "chrDRC", "chrInsrl", "chrcSsrc", "chrAsrc", "chrRsRC", "chrAsRC", "chrcInsrl", "chrSecrc", "chrSecsrc", "chrAsource", "chrSrs", "charSic", "charSource", "chrInssrc", "chrsrl", "chdrSourcers", "chrInsrt", "charSvc", "chrsrc", "chrSsrc", "charRic", "chrgInssrc", "chrsrs", "chrSrt", "charRRC", "chdrSrc", "chrSuf", "charSsrc", "chrgInsuf", "chrgInsrc", "chrcSla", "chrPsrc", "chrDrc", "chrgSrc", "charRrc", "chrgSsrc", "chrSic", "chdrSourcesrc", "chrcSrc", "chrPla", "chrgInsrt", "chrRsrc", "chrcInssrc", "chrRsvc", "chrDsrc", "chdrSRC", "chrsRC", "chrAsvc", "chrSlrc", "chrcSrl", "chrsla", "chrPrl", "chrRsource", "chrcInsla", "chrssrc"], "alpSrc": ["alpAsix", "alpSust", "alpSack", "alpiSRC", "aluAsrs", "aluAsix", "alpAsrs", "alpiSurc", "aluSg", "alpSix", "alpSuack", "alpSg", "alpiSack", "alpiSust", "alpAsg", "alpiSst", "alpInsix", "alpSRC", "alpSyrc", "alpCrc", "alpSrs", "aluAsrc", "alpSst", "alpInsrs", "alpSuRC", "alpiSuRC", "alpSurc", "alpCrs", "alpInsg", "aluAsg", "alpCix", "alpiSrc", "alpSyst", "alpSyRC", "alpAsrc", "alpSyack", "aluSrc", "alpiSuack", "alpCg", "alpInsrc", "aluSix", "aluSrs"], "dest": ["temp", "rest", "list", "spec", "data", "sp", "sort", "tr", "loc", "Dest", "port", "tmp", "ptr", "master", "trans", "foreign", "orig", "sc", "dist", "win", "result", "chain", "decl", "iter", "origin", "neg", "pipe", "buffer", "est", "gate", "target", "dc", "desc", "out", "source", "mem", "comb", "usr", "stop", "priv", "st", "table", "v"], "uDest": ["vdest", "vTarget", " uDecl", "uTarget", "uDesc", "ouDecl", "hDest", "vDecl", " uDesc", " udest", "oDesc", "ouDesc", "unDesc", "cuDest", "uDecl", "ouQueue", "unDecl", "udest", "hDesc", "cuTarget", "adest", "vEast", "oQueue", "cuEast", "vDesc", "aDesc", "uEast", "aDecl", "uQueue", "cuDesc", "unQueue", "unDest", "hEast", "oDecl", "ouDest", "hTarget", "oDest"], "vDest": ["vdest", "vcDest", "vTarget", "bDest", "vcEnd", "vcdest", "bEnd", "vPriv", "wPriv", "wBuff", " vTarget", " vEnd", " vEast", " vdest", "vEnd", "wDest", "bEast", "uvTarget", "vBuff", "bdest", "uvBuff", " vBuff", "vcEast", "uvDest", "vEast", "wTarget", " vPriv", "uvPriv"], "aDest": [" aDesc", "aPriv", "ADecl", "bDest", "saPriv", "bDesc", "auPriv", "auDesc", "oDesc", "auDest", "saPos", "bdest", "saDest", "ADest", "adest", "ADesc", "aDesc", "aDecl", "aPos", "odest", " aPriv", " aPos", "saDesc", "oDecl", "auPos", "Adest", "oDest", "bDecl"], "dstW": ["dsnL", "dstWe", "dstartR", "dsnWriter", "dSTR", "ddestW", "dstM", "DstM", "drestS", "dsrcS", "DestM", "DSTL", "dsrcW", "drestW", "dstWriter", "dstS", "DestW", "destU", "DSTWriter", "DSTR", "ddestN", "dSTM", "DstWH", "dstWH", "dirstW", "dstH", "DstWriter", "dSTWe", "dstreamR", "dsrcWH", "drestR", "DestU", "dntW", "dSTW", "DestN", "DstR", "dstL", "drestM", "destH", "dstreamM", "dostL", "dsnW", "dstartM", "ddestM", "dsnH", "DstW", "destWH", "DSTWe", "DestH", "dirstM", "destR", "dSTU", "dsrcM", "dstR", "dntM", "DestWH", "dirstN", "destN", "DSTW", "dSTL", "dSTS", "destM", "dntU", "DstWe", "dstartW", "dstU", "dostWriter", "DestR", "dSTWriter", "DstS", "dntH", "DstL", "DstU", "dirstWH", "dstreamW", "destW", "drestWe", "dstreamWH", "dsrcR", "dostH", "DSTS", "dstartWe", "dstN", "DSTH", "DstH", "DSTM", "dostW", "DstN", "dSTH", "ddestWH"], "chrDstW": ["chrPrcM", "chrSstW", "chrRstH", "chrDrW", "chrdrcW", "chrDestN", "chrdstT", "chrDvV", "chrDsetW", "chrRstW", "chrDStV", "chrDStZ", "chrdrcT", "chrDvL", "chrDstT", "chrDintV", "chrDrcV", "chrSndV", "chrDrH", "chrDstR", "chrDrcT", "chrDistV", "chrdstV", "chrDstZ", "chrDrcL", "chrSndU", "chrDblM", "chrSblW", "chrPrcV", "chrRSTL", "chrDsetR", "chrDintW", "chrSstN", "chrDistM", "chrDndN", "chrDSTW", "chrDndW", "chrDintH", "chrDSTH", "chrPstN", "chrDSTL", "chrDvW", "chrDvT", "chrDintL", "chrRstL", "chrDistZ", "chrSblM", "chrRSTH", "chrSstM", "chrPstM", "chrSndN", "chrDndV", "chrDistN", "chrDSTN", "chrRSTN", "chrDestV", "chrDntV", "chrDrcM", "chrDrcU", "chrSblR", "chrDstL", "chrDntW", "chrSstV", "chrRstZ", "chrRstV", "chrDrcW", "chrPrcW", "chrDStH", "chrdstL", "chrRSTZ", "chrRSTV", "chrDstH", "chrPstW", "chrDstU", "chrDistW", "chrDestW", "chrDstN", "chrDSTV", "chrRstN", "chrDntL", "chrDstV", "chrDstM", "chrdrcV", "chrDntT", "chrDSTZ", "chrDestU", "chrSstR", "chrDistH", "chrDndU", "chrSstU", "chrDblR", "chrdrcL", "chrDblW", "chrPstV", "chrdstW", "chrDintM", "chrDsetM", "chrDStW", "chrDrN", "chrDintN", "chrRSTW", "chrDrcR", "chrDrcN", "chrPrcN", "chrSndW", "chrDrL"], "i": ["at", " li", "multi", "ei", "mi", "info", "ski", " pos", "\u0438", "uri", "phi", "pa", "ip", "ri", "ini", "ind", "ii", "x", "pi", "f", "ki", " pi", "q", "o", " bi", "zi", "it", "l", "qi", "iu", "di", "in", "print", " I", " j", "slice", "v", "hi", "m", "me", "this", "si", "xi", "status", "init", "point", "ai", "g", "ma", "ui", "fi", "li", "err", " ti", "ci", "ix", " iter", "parent", " index", "id", "y", "ij", "ti", "j", "go", " ii", "gi", "key", "cli", "sim", "php", "ji", "bi", "e", "oi", "index", "I", "ia", "ami"], "src": ["inst", "sl", "sn", "sort", "loc", "tmp", "sb", "ptr", "trans", "dist", "ser", "iter", "img", "sub", "cur", "desc", "sec", "source", "ctr", "comp", "usr", "sys", "sur", "rel", "st", "rc"], "dst": ["psts", "Dsts", "delST", "lest", "pst", "dend", "Dest", "Ddest", "lend", "dport", "lst", "DST", "pest", "lsts", "lST", "dast", "ldest", "hport", "delst", "pdest", "delport", "daST", "pdST", "hdest", "ddest", "deldest", "Dst", "dadest", "pdend", "dST", "pdst", "hST", "hst", "Dport", "daend", "pddest", "dsts"], "counter": ["list", "num", "pack", "state", "entry", "tr", "syn", "cache", "loader", "no", "ounter", "pointer", "cycle", "buffer", "names", "count", "desc", "code", "obj", "ctr", "record", "time", "codes", "class", "table"], "p": ["pkg", "pid", "perm", "m", "post", "cp", "tp", "q", "np", "pp", "o", "sp", "imp", "at", " P", "port", "pe", "jp", "d", "bp", "n", "ps", "pl", "l", "P", "b", "wp", "pat", "j", "point", "pt", "pos", "t", "g", "pc", "pa", "dp", "ip", "ap", "ping", "php", "h", "op", "lp", "pi", "fp", "peer", "f", "pers"]}}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint32_t tmp;\n\n\n\n    if (n < CPU_NB_REGS) {\n\n        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n            env->regs[gpr_map[n]] = ldtul_p(mem_buf);\n\n            return sizeof(target_ulong);\n\n        } else if (n < CPU_NB_REGS32) {\n\n            n = gpr_map32[n];\n\n            env->regs[n] &= ~0xffffffffUL;\n\n            env->regs[n] |= (uint32_t)ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {\n\n#ifdef USE_X86LDOUBLE\n\n        /* FIXME: byteswap float values - after fixing fpregs layout. */\n\n        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);\n\n#endif\n\n        return 10;\n\n    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {\n\n        n -= IDX_XMM_REGS;\n\n        if (n < CPU_NB_REGS32 ||\n\n            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {\n\n            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);\n\n            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);\n\n            return 16;\n\n        }\n\n    } else {\n\n        switch (n) {\n\n        case IDX_IP_REG:\n\n            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n                env->eip = ldq_p(mem_buf);\n\n                return 8;\n\n            } else {\n\n                env->eip &= ~0xffffffffUL;\n\n                env->eip |= (uint32_t)ldl_p(mem_buf);\n\n                return 4;\n\n            }\n\n        case IDX_FLAGS_REG:\n\n            env->eflags = ldl_p(mem_buf);\n\n            return 4;\n\n\n\n        case IDX_SEG_REGS:\n\n            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);\n\n        case IDX_SEG_REGS + 1:\n\n            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);\n\n        case IDX_SEG_REGS + 2:\n\n            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);\n\n        case IDX_SEG_REGS + 3:\n\n            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);\n\n        case IDX_SEG_REGS + 4:\n\n            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);\n\n        case IDX_SEG_REGS + 5:\n\n            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */\n\n            return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */\n\n            return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */\n\n            return 4;\n\n        case IDX_FP_REGS + 15: /* fop */\n\n            return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n", "idx": 20345, "substitutes": {"cs": ["ctx", "cp", "CS", "js", "ls", "rs", "bs", "vs", "tc", "ps", "sc", "cc", "css", "fs", "acs", "ds", "s", "c", "ts", "Cs", "cus", "ec", "ss", "ys", "ns", "cks", "ck", "ks", "ins", "wcs", "hs", "sts", "aps", "caps", "is", "rc"], "mem_buf": ["memedfb", "mem_gen", " mem_cb", "mem_buff", "mem_bed", "memmatfb", " mem_bu", "mem2buf", "Mem_buffer", "Mem_buf", "memfbuff", "memedbox", " mem_box", "memfbu", "mem_bar", "memedbuffer", "mem2buffer", " mem_buffer", "memorybed", "memorygen", "memMemdb", "mem2cb", "mem_uf", " mem_uf", "mem_cb", "mem2uf", " mem_gen", "mem_fb", "memorybuf", "memmatbuf", "Mem_vec", "mem_box", "memMembar", "mem2buff", "mem2vec", "mem_buffer", "mem_bu", "mem_vec", "mem2bu", "memmatbuffer", "memedbuf", " mem_bed", "memmatbox", " mem_bar", " mem_db", "memorybuffer", "memMembuf", "mem_db", "memfbuf", " mem_buff", " mem_fb", "memfbuffer"], "n": ["m", "nw", "num", "sn", "p", "np", "nb", "o", "v", "z", "cn", "name", "mn", "port", "ln", "nm", "d", "w", "nil", "nn", "nc", "N", "on", "rn", "conn", "y", "l", "nor", "an", "c", "fn", "nl", "root", "s", "no", "j", "nt", "nu", "i", "ren", "ni", "gn", "t", "na", "dn", "net", "size", "g", "en", "tn", "ns", "ng", "names", "note", "number", "len", "next", "none", "all", "after", "local", "nan", "index", "x", "norm", "new", "nr", "ne", "un"], "cpu": ["ctx", "cp", "pkg", "gc", "ca", "cn", "ex", "kt", "CPU", "util", "ka", "arch", "tc", "conn", "ork", "proc", "c", "core", "aux", "aco", "bean", "processor", "nic", "ec", "node", "bench", "pt", "net", "pc", "ck", "setup", "process", "mem", "comp", "CP", "cf", "hw", "clock", "pu", "stat", "ack", "boot", "cv", "ct"], "env": ["equ", "end", "viron", "ve", "eng", "conn", "ei", "ext", "environment", "attr", "worker", "eh", "enc", "org", "eco", "server", "extra", " environment", "her", "et", "client", "buf", "hw", "eve", "gear", "ctx", "der", "exc", "eni", "manager", "esi", "eq", "vs", "den", "enter", "era", "doc", "neck", "scope", "config", "ec", "uv", "en", "ew", "desc", "ent", "email", "v", "dev", "te", "eb", "ev", "here", "engine", "console", "chart", "nc", "oe", "er", "outer", "window", "next", "el", "estate", "obj", "policy", "err", "cfg", "entry", "esc", "ah", "hess", "door", "cmd", "ef", "ner", "vert", "event", "e", "context", "runner", "eu", "operator", "Environment"], "tmp": [" ref", " input", " dst", " remainder", " ind", " leftover", " misc", " missing", " stored", " resp", " done", " matched", " ptr", " junk", " delta", " net", " remaining", " ov", " allocated", " lost", " np", " err", " noise", " sp", " ignored", " tcp", " quot", " addr"]}}
{"project": "FFmpeg", "commit_id": "70b1dcef2d859ae6b3e21d61de928c3dd0cf1aa4", "target": 0, "func": "int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n\n                                     H264ParamSets *ps)\n\n{\n\n    AVBufferRef *sps_buf;\n\n    int profile_idc, level_idc, constraint_set_flags = 0;\n\n    unsigned int sps_id;\n\n    int i, log2_max_frame_num_minus4;\n\n    SPS *sps;\n\n\n\n    profile_idc           = get_bits(gb, 8);\n\n    constraint_set_flags |= get_bits1(gb) << 0;   // constraint_set0_flag\n\n    constraint_set_flags |= get_bits1(gb) << 1;   // constraint_set1_flag\n\n    constraint_set_flags |= get_bits1(gb) << 2;   // constraint_set2_flag\n\n    constraint_set_flags |= get_bits1(gb) << 3;   // constraint_set3_flag\n\n    constraint_set_flags |= get_bits1(gb) << 4;   // constraint_set4_flag\n\n    constraint_set_flags |= get_bits1(gb) << 5;   // constraint_set5_flag\n\n    skip_bits(gb, 2);                             // reserved_zero_2bits\n\n    level_idc = get_bits(gb, 8);\n\n    sps_id    = get_ue_golomb_31(gb);\n\n\n\n    if (sps_id >= MAX_SPS_COUNT) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sps_buf = av_buffer_allocz(sizeof(*sps));\n\n    if (!sps_buf)\n\n        return AVERROR(ENOMEM);\n\n    sps = (SPS*)sps_buf->data;\n\n\n\n    sps->sps_id               = sps_id;\n\n    sps->time_offset_length   = 24;\n\n    sps->profile_idc          = profile_idc;\n\n    sps->constraint_set_flags = constraint_set_flags;\n\n    sps->level_idc            = level_idc;\n\n\n\n    memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n\n    memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n\n    sps->scaling_matrix_present = 0;\n\n\n\n    if (sps->profile_idc == 100 ||  // High profile\n\n        sps->profile_idc == 110 ||  // High10 profile\n\n        sps->profile_idc == 122 ||  // High422 profile\n\n        sps->profile_idc == 244 ||  // High444 Predictive profile\n\n        sps->profile_idc ==  44 ||  // Cavlc444 profile\n\n        sps->profile_idc ==  83 ||  // Scalable Constrained High profile (SVC)\n\n        sps->profile_idc ==  86 ||  // Scalable High Intra profile (SVC)\n\n        sps->profile_idc == 118 ||  // Stereo High profile (MVC)\n\n        sps->profile_idc == 128 ||  // Multiview High profile (MVC)\n\n        sps->profile_idc == 138 ||  // Multiview Depth High profile (MVCD)\n\n        sps->profile_idc == 144) {  // old High444 profile\n\n        sps->chroma_format_idc = get_ue_golomb_31(gb);\n\n        if (sps->chroma_format_idc > 3) {\n\n            avpriv_request_sample(avctx, \"chroma_format_idc %u\",\n\n                                  sps->chroma_format_idc);\n\n            goto fail;\n\n        } else if (sps->chroma_format_idc == 3) {\n\n            sps->residual_color_transform_flag = get_bits1(gb);\n\n        }\n\n        sps->bit_depth_luma   = get_ue_golomb(gb) + 8;\n\n        sps->bit_depth_chroma = get_ue_golomb(gb) + 8;\n\n        if (sps->bit_depth_chroma != sps->bit_depth_luma) {\n\n            avpriv_request_sample(avctx,\n\n                                  \"Different chroma and luma bit depth\");\n\n            goto fail;\n\n        }\n\n        sps->transform_bypass = get_bits1(gb);\n\n        decode_scaling_matrices(gb, sps, NULL, 1,\n\n                                sps->scaling_matrix4, sps->scaling_matrix8);\n\n    } else {\n\n        sps->chroma_format_idc = 1;\n\n        sps->bit_depth_luma    = 8;\n\n        sps->bit_depth_chroma  = 8;\n\n    }\n\n\n\n    log2_max_frame_num_minus4 = get_ue_golomb(gb);\n\n    if (log2_max_frame_num_minus4 < MIN_LOG2_MAX_FRAME_NUM - 4 ||\n\n        log2_max_frame_num_minus4 > MAX_LOG2_MAX_FRAME_NUM - 4) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"log2_max_frame_num_minus4 out of range (0-12): %d\\n\",\n\n               log2_max_frame_num_minus4);\n\n        goto fail;\n\n    }\n\n    sps->log2_max_frame_num = log2_max_frame_num_minus4 + 4;\n\n\n\n    sps->poc_type = get_ue_golomb_31(gb);\n\n\n\n    if (sps->poc_type == 0) { // FIXME #define\n\n        sps->log2_max_poc_lsb = get_ue_golomb(gb) + 4;\n\n    } else if (sps->poc_type == 1) { // FIXME #define\n\n        sps->delta_pic_order_always_zero_flag = get_bits1(gb);\n\n        sps->offset_for_non_ref_pic           = get_se_golomb(gb);\n\n        sps->offset_for_top_to_bottom_field   = get_se_golomb(gb);\n\n        sps->poc_cycle_length                 = get_ue_golomb(gb);\n\n\n\n        if ((unsigned)sps->poc_cycle_length >=\n\n            FF_ARRAY_ELEMS(sps->offset_for_ref_frame)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"poc_cycle_length overflow %d\\n\", sps->poc_cycle_length);\n\n            goto fail;\n\n        }\n\n\n\n        for (i = 0; i < sps->poc_cycle_length; i++)\n\n            sps->offset_for_ref_frame[i] = get_se_golomb(gb);\n\n    } else if (sps->poc_type != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"illegal POC type %d\\n\", sps->poc_type);\n\n        goto fail;\n\n    }\n\n\n\n    sps->ref_frame_count = get_ue_golomb_31(gb);\n\n    if (sps->ref_frame_count > H264_MAX_PICTURE_COUNT - 2 ||\n\n        sps->ref_frame_count >= 32U) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"too many reference frames %d\\n\", sps->ref_frame_count);\n\n        goto fail;\n\n    }\n\n    sps->gaps_in_frame_num_allowed_flag = get_bits1(gb);\n\n    sps->mb_width                       = get_ue_golomb(gb) + 1;\n\n    sps->mb_height                      = get_ue_golomb(gb) + 1;\n\n    if ((unsigned)sps->mb_width  >= INT_MAX / 16 ||\n\n        (unsigned)sps->mb_height >= INT_MAX / 16 ||\n\n        av_image_check_size(16 * sps->mb_width,\n\n                            16 * sps->mb_height, 0, avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"mb_width/height overflow\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    sps->frame_mbs_only_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag)\n\n        sps->mb_aff = get_bits1(gb);\n\n    else\n\n        sps->mb_aff = 0;\n\n\n\n    sps->direct_8x8_inference_flag = get_bits1(gb);\n\n    if (!sps->frame_mbs_only_flag && !sps->direct_8x8_inference_flag) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");\n\n        goto fail;\n\n    }\n\n\n\n#ifndef ALLOW_INTERLACE\n\n    if (sps->mb_aff)\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MBAFF support not included; enable it at compile-time.\\n\");\n\n#endif\n\n    sps->crop = get_bits1(gb);\n\n    if (sps->crop) {\n\n        unsigned int crop_left   = get_ue_golomb(gb);\n\n        unsigned int crop_right  = get_ue_golomb(gb);\n\n        unsigned int crop_top    = get_ue_golomb(gb);\n\n        unsigned int crop_bottom = get_ue_golomb(gb);\n\n\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_IGNORE_CROP) {\n\n            av_log(avctx, AV_LOG_DEBUG, \"discarding sps cropping, original \"\n\n                                           \"values are l:%d r:%d t:%d b:%d\\n\",\n\n                   crop_left, crop_right, crop_top, crop_bottom);\n\n\n\n            sps->crop_left   =\n\n            sps->crop_right  =\n\n            sps->crop_top    =\n\n            sps->crop_bottom = 0;\n\n        } else {\n\n            int vsub   = (sps->chroma_format_idc == 1) ? 1 : 0;\n\n            int hsub   = (sps->chroma_format_idc == 1 ||\n\n                          sps->chroma_format_idc == 2) ? 1 : 0;\n\n            int step_x = 1 << hsub;\n\n            int step_y = (2 - sps->frame_mbs_only_flag) << vsub;\n\n\n\n            if (crop_left & (0x1F >> (sps->bit_depth_luma > 8)) &&\n\n                !(avctx->flags & AV_CODEC_FLAG_UNALIGNED)) {\n\n                crop_left &= ~(0x1F >> (sps->bit_depth_luma > 8));\n\n                av_log(avctx, AV_LOG_WARNING,\n\n                       \"Reducing left cropping to %d \"\n\n                       \"chroma samples to preserve alignment.\\n\",\n\n                       crop_left);\n\n            }\n\n\n\n            if (INT_MAX / step_x             <= crop_left               ||\n\n                INT_MAX / step_x - crop_left <= crop_right              ||\n\n                16 * sps->mb_width <= step_x * (crop_left + crop_right) ||\n\n                INT_MAX / step_y             <= crop_top                ||\n\n                INT_MAX / step_y - crop_top  <= crop_bottom             ||\n\n                16 * sps->mb_height <= step_y * (crop_top + crop_bottom)) {\n\n                av_log(avctx, AV_LOG_WARNING, \"Invalid crop parameters\\n\");\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    goto fail;\n\n                crop_left = crop_right = crop_top = crop_bottom = 0;\n\n            }\n\n\n\n            sps->crop_left   = crop_left   * step_x;\n\n            sps->crop_right  = crop_right  * step_x;\n\n            sps->crop_top    = crop_top    * step_y;\n\n            sps->crop_bottom = crop_bottom * step_y;\n\n        }\n\n    } else {\n\n        sps->crop_left   =\n\n        sps->crop_right  =\n\n        sps->crop_top    =\n\n        sps->crop_bottom =\n\n        sps->crop        = 0;\n\n    }\n\n\n\n    sps->vui_parameters_present_flag = get_bits1(gb);\n\n    if (sps->vui_parameters_present_flag) {\n\n        int ret = decode_vui_parameters(gb, avctx, sps);\n\n        if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE)\n\n            goto fail;\n\n    }\n\n\n\n    /* if the maximum delay is not stored in the SPS, derive it based on the\n\n     * level */\n\n    if (!sps->bitstream_restriction_flag &&\n\n        (sps->ref_frame_count || avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT)) {\n\n        sps->num_reorder_frames = MAX_DELAYED_PIC_COUNT - 1;\n\n        for (i = 0; i < FF_ARRAY_ELEMS(level_max_dpb_mbs); i++) {\n\n            if (level_max_dpb_mbs[i][0] == sps->level_idc) {\n\n                sps->num_reorder_frames = FFMIN(level_max_dpb_mbs[i][1] / (sps->mb_width * sps->mb_height),\n\n                                                sps->num_reorder_frames);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!sps->sar.den)\n\n        sps->sar.den = 1;\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n\n        static const char csp[4][5] = { \"Gray\", \"420\", \"422\", \"444\" };\n\n        av_log(avctx, AV_LOG_DEBUG,\n\n               \"sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %\"PRId32\"/%\"PRId32\"\\n\",\n\n               sps_id, sps->profile_idc, sps->level_idc,\n\n               sps->poc_type,\n\n               sps->ref_frame_count,\n\n               sps->mb_width, sps->mb_height,\n\n               sps->frame_mbs_only_flag ? \"FRM\" : (sps->mb_aff ? \"MB-AFF\" : \"PIC-AFF\"),\n\n               sps->direct_8x8_inference_flag ? \"8B8\" : \"\",\n\n               sps->crop_left, sps->crop_right,\n\n               sps->crop_top, sps->crop_bottom,\n\n               sps->vui_parameters_present_flag ? \"VUI\" : \"\",\n\n               csp[sps->chroma_format_idc],\n\n               sps->timing_info_present_flag ? sps->num_units_in_tick : 0,\n\n               sps->timing_info_present_flag ? sps->time_scale : 0);\n\n    }\n\n\n\n    /* check if this is a repeat of an already parsed SPS, then keep the\n\n     * original one.\n\n     * otherwise drop all PPSes that depend on it */\n\n    if (ps->sps_list[sps_id] &&\n\n        !memcmp(ps->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n\n        av_buffer_unref(&sps_buf);\n\n    } else {\n\n        remove_sps(ps, sps_id);\n\n        ps->sps_list[sps_id] = sps_buf;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&sps_buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 20352, "substitutes": {"gb": ["ctx", "cfg", "gc", "gs", "gam", "uf", "bridge", "eg", "aaa", "nb", "bs", "bits", "gg", "gm", "sb", "um", "tg", "gd", "wb", "vm", "Gb", "bytes", "mg", "py", "phy", "GB", "storage", "buff", "gnu", "bt", "gh", "deg", "img", "args", "gif", "gz", "kb", "db", "rb", "g", "bg", "vg", "cd", "asm", "pb", "csv", "mb", "buf", "bf", "gt", "xy", "rg", "fb", "bsp", "cb", "hub", "pg", "bn"], "avctx": [" avcfg", " avconn", "vrctx", " avcontext", "verctx", "cloudconn", "cloudcontext", "avconn", "vercontext", "vrcontext", "airtx", "avcfg", "avcv", "avcontext", "vrcv", "aircv", " avcv", "vrtx", "cloudcfg", "vercfg", "avtx", "verconn", " avtx", "cloudctx", "aircontext", "airctx"], "ps": ["gs", "ips", "p", "pp", "bs", "rs", "amps", "params", "ams", "ets", "pes", "ups", "pps", "eps", "Ps", "fs", "ds", "mp", "ms", "pse", "cs", "PS", "ts", "aps", "ats", "pres", "ops", "pers"], "sps_buf": ["spsckcb", "smp_buf", "sps2data", "sps__buff", "sps_uf", "sps__buf", "sPS_buf", "sps2uf", "sPS_alloc", "sPS_buff", "smp_data", "sps_cb", "sps__data", "sps_data", "sPS_uf", "spsckbuf", "sps_alloc", "sps2buf", "smp_buff", "smp_cb", "spsckuf", "sPS_cb", "spsckalloc", "smp_uf", "sps2buff", "sps_buff", "sps__uf"], "profile_idc": ["profile_indc", "profile_actc", "profile_iconc", "profile_idsf", "profile_idct", "profile_indf", "profileOidcor", "profileOactc", "profile_indx", "profile_iconl", "profile_idsc", "profile_idepc", "profile_Idc", "profile_idsl", "profile_tryct", "profile_idC", "profile_itpc", "profile_iconcor", "profile_idcor", "profile_Idca", "profile_itc", "profile_iconcut", "profile_IDx", "profileOidcut", "profile_Idl", "profile_trypc", "profile_Idcor", "profile_IDca", "profile_idpc", "profile_Idcut", "profileOidc", "profile_Idx", "profile_idcut", "profile_idl", "profileOactcor", "profile_idsx", "profile_actl", "profile_indl", "profile_idx", "profile_ideC", "profile_idca", "profile_actcut", "profile_itC", "profile_tryC", "profile_IDc", "profileOactcut", "profile_idec", "profileOidl", "profile_itct", "profile_tryc", "profile_actcor", "profile_idf", "profileOactl", "profile_idect"], "level_idc": ["level_iconc", "level_idsC", "level__idce", "level_idsxc", "level_mitce", "level__idc", "level_idenc", "level_idC", "level_idsf", "level_Idco", "level_Idc", "level_vidce", "level_idsl", "level_mitci", "level_Idl", "level_ridl", "level_iconlc", "level_idenxc", "level_iconl", "level_idsc", "level__oidci", "level_oidc", "level_ridi", "level_idf", "level_Idf", "level_Idi", "level_oidce", "level_vidco", "level__oidce", "level__idci", "level_idi", "level_idlc", "level_oidco", "level_idco", "level_oidci", "level__idco", "level_uidC", "level_ridlc", "level_vidc", "level_mitco", "level_idxc", "level_ridf", "level_idsco", "level__oidco", "level_iconi", "level_mitc", "level_idci", "level_idenco", "level_uidc", "level_uidxc", "level_Idlc", "level_idce", "level_idenC", "level_vidci", "level_uidco", "level_idl", "level_ridc", "level_ridco", "level__oidc"], "sps_id": ["samples_id", "spsootid", "sps_len", "samplesootlen", "samplesootid", "sps__id", "sps_ident", "smp_id", "spse_it", "sps_num", "samplesootident", "sps_vid", "spsootname", "sps_info", "sPS_no", "samplesootname", "sPS_num", "sps_it", "sps__ids", "sPS_name", "samples_ident", "sPS_info", "spsootident", "spse_id", "sps2len", "sps_ref", "sps_rid", "sPS_ids", "samples_len", "sps2no", "sps_name", "sps_ids", "sPS_vid", "sPS_len", "sps2id", "sps__it", "sPS_rid", "samples_name", "spse_ids", "smp_ids", "sPS_id", "sps_ID", "sps2info", "sPS_ID", "sps_no", "smp_ref", "spsootlen"], "i": ["m", " l", " ti", "ci", "p", "si", " bi", "n", "it", "l", "ti", "mi", "b", " v", "j", "t", " ii", "phi", "li", " j", "ip", "bi", " m", "ii", "x", "pi", "I", "v"], "log2_max_frame_num_minus4": ["log2_max_frame_num_minus2", "log2_max_frame_num_mod4", "log2_max_frame_num_mod8", "log2_max_frame_num_times4", "log2_max_frame_num_version2", "log2_max_frame_num_mod32", "log2_max_frame_num_minus8", "log2_max_frame_num_version32", "log2_max_frame_num_times8", "log2_max_frame_num_version4", "log2_max_frame_num_times2", "log2_max_frame_num_times32", "log2_max_frame_num_version8", "log2_max_frame_num_mod2", "log2_max_frame_num_minus32"], "sps": ["sept", "jspers", "lspt", "gspers", "isits", "sPS", "ascs", "espps", "lseps", " sops", "Spt", "spers", "despers", "desps", "nspt", " spl", "seps", " spers", "seaps", "descs", "sits", "sepers", "jsaps", "rsPS", "spp", "dessts", "ispl", "esPS", "sbs", "rseps", " sports", "espt", "aspps", "spt", "sops", "desrs", " sts", "imsps", "rsaps", "isaps", " spt", " spp", "gsps", "rspers", "imsbs", "Sps", "iscs", "saves", "nsplays", "dests", " saps", "Sports", "esports", " sbs", " spps", "lsPS", " splaces", "expers", "isrs", " sPS", "spoints", "isplaces", "saps", "isps", " spoints", "spps", "isPS", "nspp", "asps", "exps", "lspers", "rspps", "despl", "issts", "iseps", "seeps", "Spers", "imspt", " splays", "ssts", "aspoints", "SPS", "spl", "esps", "sts", "gsts", "desPS", "splays", "ists", "exeps", "sports", "desits", "nsps", "seops", "scs", "lspl", "rscs", "sls", "Spps", "lsps", " scs", "rsps", "lsls", "sebs", "asPS", "Sts", "desplaces", " saves", "splaces", "srs", "exls", "ispers", "imsops", "gsPS", "espl", "jsts", "asaves", "jsps"]}}
{"project": "qemu", "commit_id": "424ad8388f89f4202a7836d003273f23ebe04b09", "target": 0, "func": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t val, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t oldval, newval;\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* CSC: Cchip System Configuration Register.  */\n\n        /* All sorts of data here; nothing relevant RW.  */\n\n        break;\n\n\n\n    case 0x0040:\n\n        /* MTR: Memory Timing Register.  */\n\n        /* All sorts of stuff related to real DRAM.  */\n\n        break;\n\n\n\n    case 0x0080:\n\n        /* MISC: Miscellaneous Register.  */\n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     /* W1C fields */\n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */\n\n        } else {\n\n            newval |= val & 0x00f00000;    /* ABT field is W1S */\n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */\n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */\n\n\n\n        newval &= ~0xf0000000000ull;       /* WO and RW fields */\n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        /* Pass on changes to IPI and ITI state.  */\n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    /* IPI can be either cleared or set by the write.  */\n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    /* ITI can only be cleared by the write.  */\n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        /* MPD: Memory Presence Detect Register.  */\n\n        break;\n\n\n\n    case 0x0100: /* AAR0 */\n\n    case 0x0140: /* AAR1 */\n\n    case 0x0180: /* AAR2 */\n\n    case 0x01c0: /* AAR3 */\n\n        /* AAR: Array Address Register.  */\n\n        /* All sorts of information about DRAM.  */\n\n        break;\n\n\n\n    case 0x0200: /* DIM0 */\n\n        /* DIM: Device Interrupt Mask Register, CPU0.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: /* DIM1 */\n\n        /* DIM: Device Interrupt Mask Register, CPU1.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: /* DIR0 (RO) */\n\n    case 0x02c0: /* DIR1 (RO) */\n\n    case 0x0300: /* DRIR (RO) */\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PRBEN: Probe Enable Register.  */\n\n        break;\n\n\n\n    case 0x0380: /* IIC0 */\n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: /* IIC1 */\n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: /* MPR0 */\n\n    case 0x0440: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 20365, "substitutes": {"opaque": ["iopaque", "opaques", "Opaque", "opacity", "iopaques", "OPaque", "OPaques", "opque", "popatile", "iopque", " opacity", "OPque", "Opque", "OPacity", "Opacity", "OPatile", "popaques", " opque", "Opaques", "popaque", "popque", "iopatile", "opatile", " opaques"], "addr": ["ctx", "ix", "arp", "add", "Address", "adr", "inv", "rs", "v", "at", "id", "pad", "name", "loc", "ptr", "ash", "tag", "url", "src", " address", "offset", "address", "r", "tx", "ord", "cmd", "host", "dr", "act", "order", "pos", "res", "arity", "ref", "ip", "et", "hop", "align", "rev", "hash", "rol", "work", "len", "eth", "index", "hw", "err", "ad", "cmp", "ack", "rc"], "val": ["rot", "grad", "sel", "conf", "bin", "unit", "sol", "test", "ret", "attr", "info", "lib", "pt", "buf", "arg", "arr", "x", "pal", "cal", "block", "ctx", "vt", "data", "ival", "util", "it", "l", "bit", "vol", "fail", "serv", " arg", "pos", "Val", "pol", "len", "xy", "local", " eval", "v", "dev", "num", "sl", "aval", "alt", "loc", "imm", "item", "eval", "res", "bl", "var", "al", "el", "obj", "err", "elt", "valid", "rel", "stat", "pr", "def", "value", "values", "VAL", "tx", " v", " value", "reg", "update", "key", "ref", "zero", "all", "base", "index", "vals"], "size": ["num", "sp", "z", "name", "id", "type", "SIZE", "length", "ffff", "unit", "scale", "Size", "n", "offset", "l", "c", "sum", "args", "count", "len", "mem", "ize", "dim", "cap", "v"], "s": ["js", "gs", "ssl", "sl", "ls", "ows", "p", "sq", "es", "rs", "bs", "details", "ads", "views", "sb", "ants", "vs", "parts", "n", "ps", "bis", "fs", "acs", "sis", "ds", "ims", "ains", "ms", "c", "as", "sw", "ts", "ses", "ss", "stats", "aws", "less", "set", "ns", "series", "ies", "ins", "changes", "its", "hs", "ports", "sts", "sv", "qs", "sys", "ats", "os", "S", "als", "is", "comm"], "oldval": ["oldeval", "oldervol", "newvalue", "newVal", " oldvol", "holdervol", "Oldeval", "oldvalue", " newVAL", "holderVAL", " oldVAL", "OldVal", "OldVAL", "oldervalue", " neweval", "oldVAL", "holderval", "Oldval", " oldvalue", " oldeval", "oldvol", "olderVal", "oldVal", "olderVAL", " newVal", " oldVal", "holdervalue", "olderval"], "newval": ["createvalid", "newsVal", "newvalue", "oldfail", " newel", "normalval", " neweval", "newarr", "oldVAL", "nextvalue", " newbal", " newvalue", "enval", "newsval", " newitem", "genlev", "oldbal", "mainVAL", "newVal", "nextlev", "nextVal", "oldvalue", " newVAL", "NEWvalid", "NEWVal", "newsvalue", "ewel", "genvals", "normalVal", "maineval", "newsfail", " newVal", "newspol", "ewvol", "ewitem", "nextvol", "ewfail", "newseval", "createbal", "ewarr", "createvalue", "oldeval", "NEWvalue", "nextitem", "NEWVAL", " newfail", "nextarr", "newlev", "newbal", "eneval", "newvalid", " newvol", "createVAL", "newfail", "neweval", "nextpol", "newVAL", "normaleval", "enVAL", " newcho", "genvol", "newel", "oldVal", "nexteval", "newsarr", "newcho", "ewpol", "NEWeval", "nextvals", "nextvalid", "genval", "newvol", "nextfail", "createVal", "newpol", "NEWel", "mainval", "newslev", "newsvals", " newvalid", "nextVAL", "newitem", "mainVal", "NEWlev", "NEWval", "ewvalue", "createval", "ewval", "envalue", "normalcho", "newvals", "nextval", "ewVal", "newsvol", "oldvalid", "createlev", "newscho"], "i": ["iy", "hi", "m", "me", "ci", "ix", "p", "name", "si", "zi", "multi", "ei", "n", "y", "it", "xi", "ims", "ij", "l", "ti", "mi", "qi", "gu", "c", "iu", "info", "j", "di", "in", "ai", "ie", "u", "uri", "ui", "phi", "ic", "li", "key", "gi", "cli", "sim", "ri", "ji", "a", "ini", "bi", "ind", "e", "oi", "index", "x", "ii", "pi", "asi", "I", "ami", "ia", "ex", "io", "is", "im"], "cpu": ["ctx", "cp", "current", "gc", "ilo", "mx", "us", "hz", "np", "linux", "pixel", "CPU", "proxy", "cache", "sc", "vm", "dt", "css", "chip", "cum", "uu", "proc", "c", "core", "gpu", "thread", "aco", "bean", "processor", "mac", "nic", "nu", "node", "prof", "nice", "phys", "pc", "cat", "ck", "ip", "disk", "device", "php", "process", "cam", "ram", "cu", "mem", "comp", "sys", "hard", "hw", "clock", "cmp", "pu", "stat", "bus", "boot", "physical"], "cs": ["ctx", "js", "CS", "cp", "acts", "ls", "ix", "rs", "ces", "vs", "sc", "ps", "icks", "cc", "css", "fs", "acs", "ds", "ics", "c", "ts", "cus", "ss", "ys", "stats", "cas", "pc", "ns", "cks", "ks", "ins", "cons", "wcs", "hs", "checks", "cu", "sts", "qs", "sys", "ats", "cf", "ars"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_combiner_write(void *opaque, target_phys_addr_t offset,\n\n        uint64_t val, unsigned size)\n\n{\n\n    struct Exynos4210CombinerState *s =\n\n            (struct Exynos4210CombinerState *)opaque;\n\n    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and\n\n                                   get a start of corresponding group quad */\n\n    uint32_t grp_quad_base_n;    /* Base of group quad */\n\n    uint32_t reg_n;              /* Register number inside the quad */\n\n\n\n    req_quad_base_n = offset >> 4;\n\n    grp_quad_base_n = req_quad_base_n << 2;\n\n    reg_n = (offset - (req_quad_base_n << 4)) >> 2;\n\n\n\n    if (req_quad_base_n >= IIC_NGRP) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (reg_n > 1) {\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        return;\n\n    }\n\n\n\n    if (offset >> 2 >= IIC_REGSET_SIZE) {\n\n        hw_error(\"exynos4210.combiner: overflow of reg_set by 0x\"\n\n                TARGET_FMT_plx \"offset\\n\", offset);\n\n    }\n\n    s->reg_set[offset >> 2] = val;\n\n\n\n    switch (reg_n) {\n\n    /* IIESR */\n\n    case 0:\n\n        /* FIXME: what if irq is pending, allowed by mask, and we allow it\n\n         * again. Interrupt will rise again! */\n\n\n\n        DPRINTF(\"%s enable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Enable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask |= val & 0xFF;\n\n        s->group[grp_quad_base_n + 1].src_mask |= (val & 0xFF00) >> 8;\n\n        s->group[grp_quad_base_n + 2].src_mask |= (val & 0xFF0000) >> 16;\n\n        s->group[grp_quad_base_n + 3].src_mask |= (val & 0xFF000000) >> 24;\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n        /* IIECR */\n\n    case 1:\n\n        DPRINTF(\"%s disable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Disable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask &= ~(val & 0xFF);\n\n        s->group[grp_quad_base_n + 1].src_mask &= ~((val & 0xFF00) >> 8);\n\n        s->group[grp_quad_base_n + 2].src_mask &= ~((val & 0xFF0000) >> 16);\n\n        s->group[grp_quad_base_n + 3].src_mask &= ~((val & 0xFF000000) >> 24);\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n    default:\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n}\n", "idx": 20368, "substitutes": {"opaque": ["parentca", "opaques", " opoid", "Opaque", "opacity", "compute", "opute", " opacity", "oplay", "Opute", "opca", "Opca", " opca", "compaque", "Opacity", "opoid", "Opoid", "compoid", "Oplay", "parentlay", " oplay", "parentacity", " opute", "Opaques", "parentaque", "compaques", " opaques"], "offset": ["ta", "kh", "height", "reset", "frequency", "start", "data", "o", "alias", "parent", "entry", "pad", "slot", "length", "loc", "ptr", "padding", "onto", "block", "scroll", "value", "range", "shift", "amount", "inter", "Offset", "style", "prefix", "offer", "address", "sync", "location", "origin", "point", "pointer", "timeout", "pos", "t", "set", "error", "output", "buffer", "usage", "key", "seek", "position", "ref", "slice", "align", "window", "off", "handle", "sector", "row", "base", "reference", "tz", "index", "attribute", "op", "kernel", "batch", "addr", "peer", "mt", "table", "trace"], "val": ["ctx", "dev", "rot", "Value", "vt", "p", "data", "aval", "ival", "alt", "sel", "conf", "slot", "bin", "util", "unit", "sol", "ay", "ver", "value", "it", "test", "inter", "bit", "ret", "b", "vol", "lib", "VAL", "tx", "item", "empty", " value", "pt", "func", "eval", "pos", "sum", "reg", "res", "bl", "Val", "msg", "pol", "ref", "vec", "var", "al", "ul", "buf", "rol", "hash", "zero", "all", "base", "xy", "local", "x", "cal", "vals", "fee", "elt", "valid", "err", "block", "f", "v"], "size": ["num", "start", "sp", " length", "z", "name", "type", "SIZE", "length", "Size", "n", "bytes", "shift", "l", "set", "message", "count", "len", "off", "e", "mem", "index", "h", "ize", "weight", "fee"], "s": ["js", "gs", "m", "spec", "ssl", "sl", "ls", "south", "p", "sq", "sp", "o", "rs", "bs", "bits", "es", "details", "conf", "w", "sb", "vs", "gets", "n", "ps", "y", "bis", "fs", "sis", "ds", "ims", "b", "ms", "c", "settings", "cs", "ands", "r", "ts", "ses", "ss", "i", "stats", "t", "less", "g", "ns", "ies", "its", "ins", "socket", "ers", "changes", "hs", "ports", "sts", "sv", "qs", "sys", "h", "se", "os", "ats", "S", "als", "ops", "space", "is", "comm"], "req_quad_base_n": ["req_quad_Base2n", "req_quad_bas_N", "req_quad_Base2b", "req_quad_basejp", "req_quad_Base_b", "req_quad_base_cn", "req_quad_base_b", "req_quad_basejcn", "req_quad_basejn", "req_quad_bas_n", "req_quad_bas2N", "req_quad_based_p", "req_quad_base_number", "req_quad_base2b", "req_quad_Base_N", "req_quad_based_n", "req_quad_bas2n", "req_quad_base2N", "req_quad_based_N", "req_quad_Base_v", "req_quad_base2v", "req_quad_based_cn", "req_quad_Base2v", "req_quad_base2l", "req_quad_basexn", "req_quad_base_l", "req_quad_basejN", "req_quad_Base_n", "req_quad_base32v", "req_quad_Base_ns", "req_quad_base32n", "req_quad_basexN", "req_quad_base_p", "req_quad_base_ns", "req_quad_basexnumber", "req_quad_Base_number", "req_quad_base_N", "req_quad_bas2l", "req_quad_base_v", "req_quad_base32b", "req_quad_base2n", "req_quad_bas_l", "req_quad_basexns"], "grp_quad_base_n": ["grp_quad_Base_n", "grp_quad_base_name", "grp_quad_base_c", "grp_quad_base_nt", "grp_quad_Base_r", "grp_quad_base2r", "grp_quad_basetnt", "grp_quad_base_l", "grp_quad_Base_name", "grp_quad_base1l", "grp_quad_baseptx", "grp_quad_base_x", "grp_quad_base2N", "grp_quad_base1N", "grp_quad_basetn", "grp_quad_base1n", "grp_quad_Base_N", "grp_quad_base_ns", "grp_quad_basepton", "grp_quad_base_on", "grp_quad_base_N", "grp_quad_base2name", "grp_quad_basetN", "grp_quad_base2l", "grp_quad_Base_l", "grp_quad_base2n", "grp_quad_baseptn", "grp_quad_base_r", "grp_quad_base_p", "grp_quad_base2nt", "grp_quad_baseptN", "grp_quad_Base_x", "grp_quad_Base_c"], "reg_n": ["reg_k", "eng_1", "regMl", "arg_n", "eng_c", " reg_p", "reg_name", "REG_n", "arg_nb", "regxn", "reg_nb", "regMnb", "REG_dn", "eng_N", "arg_l", "regMne", "reg_dn", "reg_c", "reg_p", " reg_name", "REG_k", "regxl", "regxnb", "reg_N", "reg_l", "eng_n", "arg_ne", "regMn", "reg_ne", "regxne", "REG_c", "reg_1"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static void bt_submit_acl(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t handle;\n\n    int datalen, flags;\n\n    struct bt_link_s *link;\n\n\n\n    if (length < HCI_ACL_HDR_SIZE) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        return;\n\n    }\n\n\n\n    handle = acl_handle((data[1] << 8) | data[0]);\n\n    flags = acl_flags((data[1] << 8) | data[0]);\n\n    datalen = (data[3] << 8) | data[2];\n\n    data += HCI_ACL_HDR_SIZE;\n\n    length -= HCI_ACL_HDR_SIZE;\n\n\n\n    if (bt_hci_handle_bad(hci, handle)) {\n\n        fprintf(stderr, \"%s: invalid ACL handle %03x\\n\",\n\n                        __FUNCTION__, handle);\n\n        /* TODO: signal an error */\n\n        return;\n\n    }\n\n    handle &= ~HCI_HANDLE_OFFSET;\n\n\n\n    if (datalen > length) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB < %iB)\\n\",\n\n                        __FUNCTION__, length, datalen);\n\n        return;\n\n    }\n\n\n\n    link = hci->lm.handle[handle].link;\n\n\n\n    if ((flags & ~3) == ACL_ACTIVE_BCAST) {\n\n        if (!hci->asb_handle)\n\n            hci->asb_handle = handle;\n\n        else if (handle != hci->asb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Active Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    if ((flags & ~3) == ACL_PICO_BCAST) {\n\n        if (!hci->psb_handle)\n\n            hci->psb_handle = handle;\n\n        else if (handle != hci->psb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Parked Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    /* TODO: increase counter and send EVT_NUM_COMP_PKTS */\n\n    bt_hci_event_num_comp_pkts(hci, handle | HCI_HANDLE_OFFSET, 1);\n\n\n\n    /* Do this last as it can trigger further events even in this HCI */\n\n    hci->lm.handle[handle].lmp_acl_data(link, data,\n\n                    (flags & 3) == ACL_START, length);\n\n}\n", "idx": 20370, "substitutes": {"info": ["INFO", "fo", "meta", "check", "basic", "json", "report", "o", "id", "type", "conf", "by", "Info", "def", "information", "force", "init", "status", "bit", "good", "history", "inf", "kind", "isu", "about", "i", "auth", "error", "frame", "fi", "from", "is", "now", "base", "http", "index", "os", "nr", "stat", "f", " inf"], "data": ["params", "name", "test", "aw", "chain", "join", "address", "extra", "format", "buf", "actions", "a", "none", "DATA", "ad", "block", "Data", "table", "command", "list", "missing", "o", "d", "padding", "cache", "content", "partial", " DATA", "map", "error", "message", "first", "device", "read", "hash", "len", "done", "image", "mu", "to", "duration", "offset", "text", "load", "raw", "empty", "timeout", "window", "next", "str", "batch", "valid", "share", "bus", "height", "dat", "p", "entry", "id", "def", "value", "bytes", "tx", "no", "size", "buffer", "ns", "out", "sha", "zero", "multiple", "ata", "new", "weight", "ops", "response"], "length": ["height", "end", "family", "p", "full", "missing", "pad", "be", "type", "ength", "path", "L", "padding", "maximum", "ptr", "duration", "n", "value", "offset", "l", "minimum", "capacity", "available", "limit", "tail", "load", "ENGTH", "idth", "address", "empty", "expected", "shape", "loop", "size", "t", "error", "message", "buffer", "H", "phi", "position", "total", "count", "len", "number", "zero", "angle", "time", "h", "valid", "sequence", "th", "ish", "Length", "present"], "hci": ["rco", "wci", "httpcirc", "ohri", "hri", "Hii", "httpdi", "hercci", "hooksee", "ehdi", " hdi", "hlic", "thco", "hcin", "rmi", "hdi", " hcos", "hii", "cci", "hCI", "hco", " hlic", "hcos", "hli", "hloci", "ohoci", "hoci", "hcci", "httplic", "loci", "hookcci", "ohdi", "thoci", " hmi", "hlcli", "ehCI", "httpci", "cco", "hecm", "thcci", " hoci", "httpco", " hcirc", "httpli", "wli", "hlcci", "cdi", "Hoci", "ihci", "ihdi", "shci", "lcci", " hco", "hmi", "ohci", "ihri", "rcci", " hcci", "heri", "ehii", "heci", " hcu", "hercos", "shCI", "hcu", "lcli", "ccin", "hookcos", "hlci", "hecci", "Hci", "hersee", "wcci", "ehcin", "hookci", "hecu", "ehci", " hii", "heco", "ihcm", "Hcu", " hli", "hcirc", "hcm", "rci", " hCI", "herci", "thci", "shcci", "ohcli", " hsee", "ehco", "hsee", "hecirc", "hcli", "lmi", "Hco", "shoci", "wlic", "ohcm", "Hcci", "ehcci", "ehoci", "lco", " hcin", "hedi", "httpcci", "lci", "ohcci"], "handle": ["wrap", "check", "bridge", "hide", "hold", "memory", "handler", "type", "filename", "tree", "chain", "address", "trigger", "server", "set", "count", "store", "forward", "angle", "queue", "help", "ctx", "command", "try", "Handle", "range", "cache", "wrapper", "scope", "handled", "flag", "loop", "bh", "shape", "map", "device", "hash", "oid", "draw", "dev", "ssl", "state", "folder", "port", "ptr", "domain", "transfer", "offset", "status", "anch", "header", "delay", "node", "metadata", "driver", "route", "note", "policy", "connection", "mask", "share", "then", "le", "ha", "close", "tool", "old", "alias", "id", "mount", "path", "value", "release", "has", "hand", "line", "lock", "cmd", "host", "size", "ignore", "match", "buffer", "key", "target", "process", "code", "context", "h", "index", "addr", "label", "bind"], "datalen": ["dallize", "dblens", "dalener", "damelis", " dallength", "datotalens", "damelener", "dalis", " dallen", " dipalen", "dalllen", "dallis", "datotalen", " dallens", "datatalens", "Dalen", "dallen", "datotalener", " datalize", "dalize", "dotalener", "datalens", "dalength", "dallens", "datatalen", "datalis", "Dalens", " dallis", "datallen", "datalength", "dipalen", " datalens", " datalis", "dblength", "damelen", "datatalener", "datalener", " dipalens", "dblen", "damelens", "dallength", "dotalength", "datatalength", "dalen", "Datalength", " dipalength", "Datallen", "dbllen", " dipalize", "Dallen", "Datalens", "damelength", "Datalen", "datalize", "datotalength", "dipalength", "dotalens", "dipalens", "dipalize", "Dalength", "dotalen", " datalength", "dalens"], "flags": ["pins", "acts", "hips", "facts", "tools", "posts", "bits", "points", "details", "times", "tags", "lag", "links", "weights", "magic", "types", "fs", "bugs", "helps", "settings", "kind", "packages", "flag", "cmd", "allows", "utils", "stats", "faces", "lines", "args", "relations", "atts", "hands", "friendly", "actions", "ags", "checks", "options", "features", " Flags", "ports", "reports", "levels", "aps", "properties", "mask", "vals", "weight", "fields", "heads", "Flags", "locks"], "link": ["relation", "pid", "check", "tool", "pack", "sp", "like", "lo", "parent", "alias", "id", "type", "handler", "loc", "path", "linked", "ln", "port", "ld", "url", "links", "offset", "l", "chain", "tail", "line", "lock", "light", "sh", "hip", "load", "lan", "slave", "nl", "address", "ble", "delay", "Link", "loop", "match", "li", "target", "store", "ping", "route", "ink", "device", "member", "head", "base", "local", "index", "lp", "connection", "addr", "way", "share", "label", "le", "bind"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_flush(&s->client);\n\n}\n", "idx": 20398, "substitutes": {"bs": ["js", "gs", "bing", "abus", "bits", "bc", "bes", "sb", "vs", "bis", "fs", "acs", "ims", "ds", "cs", "iss", "ts", "ss", "aos", "aws", "bh", "ubs", "BS", "ns", "cks", "pb", "its", "asis", "bps", "hs", "obs", "bos", "ats", "fps", "lbs", "als"], "s": ["js", "gs", "ls", "sq", "rs", "sb", " ss", "ps", "sis", "ds", "self", "ims", "b", "cs", "as", "ts", "j", "ses", "ss", "aws", "less", "ns", "its", "hs", "a", "sam", "ares", "sts", "sys", "ats", "os", "S", "als", "is", "v"]}}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 20410, "substitutes": {"qiov": ["Qdrm", "qiour", "queryconv", " qovi", "ayiov", " qiev", "querynov", "qiev", "qqiour", "qurolet", "qrolet", "ayovi", "qconv", " qdrm", "qqiov", "qqiev", "dqconv", "quiev", "quiour", "qdrm", "quiov", " qnov", "ayrolet", "Qrolet", " qconv", " qrolet", "dqiov", "qnov", "dqnov", "dqliv", "aydrm", "queryliv", "Qovi", "queryiov", "qqrolet", "qliv", "qovi", " qiour", "Qiov", " qliv"], "i": [" li", "multi", " mi", "ims", "mi", " wi", "\u0438", " my", "uri", "phi", "ip", "ri", "ini", "ind", "x", "ii", "pi", "yi", "f", "ki", "im", " pi", "q", "zi", "it", " missing", "gu", "qi", "iu", "di", "in", "print", " I", "u", " ni", "m", "me", "si", " si", "mu", "xi", "init", " key", "point", "ai", "g", "fi", "ui", " multi", "li", " err", " m", " ti", "ci", "ix", "p", " iter", " index", "id", "span", "n", "y", "ij", "ti", "s", "j", "go", "uli", "t", " ii", "key", "sim", "bi", "oi", "index", "I", "ami", " all"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20422, "substitutes": {"avctx": ["averiac", "avesc", " avconn", " avctl", "aftx", "vrctx", " avcontext", " avjp", "wavcontext", "averctx", "camctx", "avecv", "camjac", " avpkg", "wavctl", "afcontext", "afpkg", "avconn", "aviac", "camiac", "vrcontext", "avecontext", "avejp", "camsc", "wavctx", "vrpkg", "avetx", "wavconn", "avectx", "avpkg", "apctx", "afctx", " avgc", "avcontext", "avcv", "avjac", "apctl", "avsc", "avejac", "wavtx", "aveiac", "averjac", "avctl", "vrgc", "afcv", " avtx", "aversc", "aptx", "avjp", "apcontext", "aveconn", "wavjp", "avtx", "afgc", "wavcv", "avgc"], "data": ["meta", "m", "done", "dat", "p", "input", "family", "name", "pad", "type", "id", "image", "bin", "length", "d", "def", "mu", "to", "cache", "value", "bytes", "content", "feed", " DATA", "result", "text", "Data", "load", "final", "empty", "video", "extra", "t", "pos", "size", "area", "message", "frame", "error", "buffer", "ref", "read", "window", "next", "resp", "DATA", "package", "str", "ata", "batch", "block", "f", "val"], "data_size": [" data_shape", "data_len", " data_SIZE", "data_Size", "data_shape", "data_length", "data_SIZE", " data_length", " data_Size", " data_len"], "avpkt": ["avpodkt", "avppqt", "avwpkat", "avenpacket", "avpbacket", "avpct", "avepct", "avepdu", "avpdu", "avnpgt", "avPdu", "avepkt", "avPacket", "avenpkt", " avpkat", "avppkt", "avwpkt", "avpbkt", "avwpct", "avpmt", "avnpkg", " avPkat", "avPqt", "avpgt", "avnpkt", "avcpgt", "avcpkt", "avcpacket", " avPacket", "avppct", "avPct", "avpacket", "avpkat", "avcpkg", "avpkg", " avpacket", "avenpgt", "avPmt", "avpbmt", "avwpacket", "avenpkg", "avppdu", "avewpqt", "avpodacket", "avnpacket", "avepqt", " avpmt", "avwpdu", "avepacket", "avewpct", "avewpdu", " avPkt", "avpodgt", "avpqt", "avpodkg", "avPkt", "avPkat", "avwpqt", "avepkg", "avewpkt", " avPmt", "avpbkat", "avwpmt", "avepgt"], "buf": ["ctx", "pkg", "uf", "dat", "p", "np", "bs", "bc", "box", "loc", "bin", "tmp", "br", "Buffer", "orig", "bytes", "lim", "b", "buff", "raw", "iter", "cmd", "img", "map", "bh", "db", "rb", "buffer", "capt", "ref", "vec", "read", "Buff", "len", "mem", "queue", "batch", "cap", "cb", "cv"], "seq": ["ctx", "pkg", "list", "num", "ez", "q", "sq", "spec", "qa", "sel", "req", "jp", "eq", "ctrl", "sequ", "sc", "test", "cl", "feat", "mp", "chain", "pse", "proc", "ess", "sync", "tab", "tx", "serv", "iter", "gen", "ec", "cmd", "nt", "eval", "clus", "prev", "frame", "sub", "msg", "ng", "ref", "vec", "iq", "sim", "session", "next", "desc", "job", "cur", "sec", "obj", "pause", "ctr", "mem", "flow", "comp", "crit", "queue", "batch", "exec", "sequence", "prot", "cv", "val"]}}
{"project": "qemu", "commit_id": "b2b012afdd9c03ba8a1619f45301d34f358d367b", "target": 1, "func": "static ssize_t imx_fec_receive(NetClientState *nc, const uint8_t *buf,\n\n                               size_t len)\n\n{\n\n    IMXFECState *s = IMX_FEC(qemu_get_nic_opaque(nc));\n\n    IMXFECBufDesc bd;\n\n    uint32_t flags = 0;\n\n    uint32_t addr;\n\n    uint32_t crc;\n\n    uint32_t buf_addr;\n\n    uint8_t *crc_ptr;\n\n    unsigned int buf_len;\n\n    size_t size = len;\n\n\n\n    FEC_PRINTF(\"len %d\\n\", (int)size);\n\n\n\n    if (!s->regs[ENET_RDAR]) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Unexpected packet\\n\",\n\n                      TYPE_IMX_FEC, __func__);\n\n        return 0;\n\n    }\n\n\n\n    /* 4 bytes for the CRC.  */\n\n    size += 4;\n\n    crc = cpu_to_be32(crc32(~0, buf, size));\n\n    crc_ptr = (uint8_t *) &crc;\n\n\n\n    /* Huge frames are truncated.  */\n\n    if (size > ENET_MAX_FRAME_SIZE) {\n\n        size = ENET_MAX_FRAME_SIZE;\n\n        flags |= ENET_BD_TR | ENET_BD_LG;\n\n    }\n\n\n\n    /* Frames larger than the user limit just set error flags.  */\n\n    if (size > (s->regs[ENET_RCR] >> 16)) {\n\n        flags |= ENET_BD_LG;\n\n    }\n\n\n\n    addr = s->rx_descriptor;\n\n    while (size > 0) {\n\n        imx_fec_read_bd(&bd, addr);\n\n        if ((bd.flags & ENET_BD_E) == 0) {\n\n            /* No descriptors available.  Bail out.  */\n\n            /*\n\n             * FIXME: This is wrong. We should probably either\n\n             * save the remainder for when more RX buffers are\n\n             * available, or flag an error.\n\n             */\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Lost end of frame\\n\",\n\n                          TYPE_IMX_FEC, __func__);\n\n            break;\n\n        }\n\n        buf_len = (size <= s->regs[ENET_MRBR]) ? size : s->regs[ENET_MRBR];\n\n        bd.length = buf_len;\n\n        size -= buf_len;\n\n\n\n        FEC_PRINTF(\"rx_bd 0x%x length %d\\n\", addr, bd.length);\n\n\n\n        /* The last 4 bytes are the CRC.  */\n\n        if (size < 4) {\n\n            buf_len += size - 4;\n\n        }\n\n        buf_addr = bd.data;\n\n        dma_memory_write(&address_space_memory, buf_addr, buf, buf_len);\n\n        buf += buf_len;\n\n        if (size < 4) {\n\n            dma_memory_write(&address_space_memory, buf_addr + buf_len,\n\n                             crc_ptr, 4 - size);\n\n            crc_ptr += 4 - size;\n\n        }\n\n        bd.flags &= ~ENET_BD_E;\n\n        if (size == 0) {\n\n            /* Last buffer in frame.  */\n\n            bd.flags |= flags | ENET_BD_L;\n\n            FEC_PRINTF(\"rx frame flags %04x\\n\", bd.flags);\n\n            s->regs[ENET_EIR] |= ENET_INT_RXF;\n\n        } else {\n\n            s->regs[ENET_EIR] |= ENET_INT_RXB;\n\n        }\n\n        imx_fec_write_bd(&bd, addr);\n\n        /* Advance to the next descriptor.  */\n\n        if ((bd.flags & ENET_BD_W) != 0) {\n\n            addr = s->regs[ENET_RDSR];\n\n        } else {\n\n            addr += sizeof(bd);\n\n        }\n\n    }\n\n    s->rx_descriptor = addr;\n\n    imx_eth_enable_rx(s);\n\n    imx_eth_update(s);\n\n    return len;\n\n}\n", "idx": 20425, "substitutes": {"nc": ["gc", "nw", "sn", "np", "cn", "bc", "xc", "nec", "nn", "tc", "anc", "n", "conn", "cc", "rn", "mc", "sc", "ics", "c", "nl", "cs", "nic", "nt", "ec", "net", "NC", "pc", "nd", "ns", "dc", "nv", "nz", "nr", "ne", "cv", "ct"], "buf": ["uf", "p", "data", "seq", "bc", "box", "bin", "tmp", "wb", "br", "Buffer", "bytes", "BU", "b", "text", "buff", "raw", "cmd", "img", "bl", "rb", "buffer", "msg", "txt", "ref", "pb", "vec", "cv", "read", "Buff", "mem", "bf", "queue", "batch", "rc", "fb", "cap", "block", "cb", "v"], "len": ["num", "data", "start", "sp", "body", "z", "type", "SIZE", "length", "ln", "ptr", "ld", "n", "Size", "bytes", "Len", "l", "fun", "nl", "pos", "t", "size", "en", "count", "code", "all", "mem", "h", "str", "ize", "cmp"], "s": ["js", "gs", "spec", "ssl", "sn", "ls", "so", "sq", "p", "sp", "rs", "bs", "conf", "sb", "n", "ps", "fs", "sis", "ds", "sa", "c", "cs", "an", "iss", "sw", "ts", "ses", "ss", "i", "stats", "t", "aws", "less", "set", "g", "ns", "store", "hs", "sec", "sam", "sts", "sv", "qs", "sys", "ats", "sg", "se", "S", "is", "sports", "comm"], "bd": ["js", "edd", "bb", " BD", "bar", "bs", "nb", "BT", "pad", "vd", "bc", "box", "ba", "bo", "d", "sb", "ld", "gb", "pd", "br", "disc", "fd", "dt", "ds", "hd", "ob", "b", "led", " b", "buff", "dis", "ocked", "bt", "da", "ded", "bh", "bl", "db", "rb", "kb", "cd", "ed", "od", "bg", "dd", "pb", "mb", "md", "bf", "lay", " bl", "ad", "sd", "BD", "cb", "bind"], "addr": ["ctx", "dir", "ix", "arp", "add", "data", "adr", "Address", "rs", "alias", "at", "id", "name", "pad", "alt", "v", "loc", "debug", "port", "ag", "ptr", "url", "src", "n", "offset", "attr", "er", "rt", "nl", "address", "r", "tx", "ord", "cmd", "host", "dr", "i", "act", "pos", "args", "size", "msg", "ref", "ip", "align", "store", "hash", "np", "coord", "handle", "obj", "a", "mem", "arr", "x", "ad", "rc"], "crc": ["pcRC", "Crs", "acRC", "lcron", "pcrs", "cce", "cRC", " ccr", " cce", " cRC", "pcron", "crs", "gccr", "gcce", "acrs", "rcron", "Cck", "cron", "rcred", "Cred", "accr", "Cron", "rcrc", "Crc", "acrc", "cred", "ccr", "rcck", "acce", "lcred", "lcrc", "acron", "cck", "lcck", "pcrc", "gcrc", "gcRC", "CRC"], "buf_addr": ["br_addr", "bufxdir", "bufxaddr", " buf_ref", "buf_ptr", "buf__ptr", "uf_ref", "buf__len", "buf__ref", "uf_addr", "buf_offset", "br_offset", "br_dir", "uf_ptr", "bufxoffset", " buf_address", " buf_ptr", "buf_ref", "uf_len", "bufxlen", "buf__addr", "buf_dir", "br_len", "buf_address"], "crc_ptr": ["cron2ref", "cron2ptr", "cron2inter", "crc2ptr", "crc_obj", "crc2obj", "cron_ptr", "crc2inter", "cRC_rel", "cron_inter", "crc_inter", "cRC_addr", "cron2obj", "cRC_val", "cron_ref", "cRC_ptr", "crc2ref", "crc_ref", "cron_obj", "crc_rel", "crc_val", "crc_addr"], "buf_len": ["buf5en", "buffer_pos", "buf2len", "buff5en", "buffer_ptr", "ctxitylang", "ctx_len", "buf5len", "ctx_length", "buf6len", " buf2len", " buf_length", "buf_ref", "buf6ptr", "buf2addr", "buf6length", "queue_l", "bufjaddr", " buf_fin", "ctxityelt", "bufjl", " buf2ref", "buff5lan", "buf5elt", "ctxitylength", "bufityelt", "buff_len", "buf2ref", "ctx_lang", "buf2pos", "buf_el", "buf5lan", "buf_l", "queue_addr", " buf_el", "buf2fin", "buf_pos", "buffer_len", "buf_length", "buff5elt", "ctx_elt", "bufitylen", "buf2length", "buf_fin", "buff_lan", " buf2length", "buf6pos", "buf2ptr", "bufjlen", "buf_lan", " buf_ref", "queue_len", "ctxitylen", "buf_ptr", "buffer_length", "buff_en", "buf_elt", "buff_elt", "buf_en", " buf_offset", "buf_offset", "buff5len", "buf2l", " buf2fin", "bufitylang", "bufitylength", "buf_lang"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void breakpoint_handler(CPUState *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n    if (prev_debug_excp_handler)\n\n        prev_debug_excp_handler(env);\n\n}\n", "idx": 20433, "substitutes": {"env": ["end", "viron", "np", "ve", "esm", "shell", "editor", "eng", "conn", "ext", "environment", "worker", "eh", "enc", "org", "server", "cur", "buf", "queue", "gear", "peer", "erd", "cv", "ctx", "nw", "vt", "exc", "manager", "vs", "vm", "enter", "era", "self", "doc", "serv", "ec", "uv", "net", "en", "ew", "desc", "eas", "ent", "usr", "ov", "v", "dev", "export", "ev", "here", "engine", "console", "external", "timer", "init", "er", "proc", "app", "act", "network", "txt", "outer", "window", "obj", "esp", "ee", "exec", "em", "eg", "inv", "entry", "gov", "esc", "ah", "etc", "vp", "cmd", "dn", "buffer", "nv", "code", "e", "context", "sv", "Environment"], "bp": ["cp", "pkg", "tp", "bb", "p", "eb", "np", "sp", "bs", "btn", "mk", "vc", "nb", "bc", "jp", "sb", "gb", "br", "yk", "BP", "wp", "bm", "vp", "bt", "wr", "isp", "prof", "bh", "kb", "bg", "hp", " lb", "pb", "lb", "mb", "snap", "bps", "bi", "gp", "bf", "esp", "lp", "BIP", "lbs", "fb", "bd", "fp", "bsp", "ipp", "usb", "cb", "bn"]}}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 20434, "substitutes": {"widget": ["ctx", " widgets", "fw", "editor", "web", "w", "console", "screen", "wid", "layout", "component", "idget", "win", "wt", "wp", "root", "gui", "grid", "focus", "html", "board", "document", "game", "window", "Widget", "obj", "view", "wx"], "button": ["bridge", "type", "editor", "again", "BUT", "band", "feature", "Button", "video", "trigger", "normal", "element", "pb", "color", "bug", "attribute", "block", "action", "command", "box", "tag", "shift", "b", "but", "cart", "function", "flag", "document", "error", "message", "position", "comment", "pressed", "back", "menu", "click", "power", "notice", "field", "module", "timer", "application", "point", "version", "ui", "page", "driver", "butt", "section", "window", "channel", "note", "next", "option", "form", "display", "title", "utton", "atom", "connection", "submit", "ilo", "entry", "pixel", "span", "communication", "foreign", "delete", "result", "tab", "no", "mark", "match", "buffer", "key", "link", "process", "number", "job", "code", "change", "operation", "bot", "index", "label"], "opaque": ["iopaque", "OPiphany", "opacity", " Opatile", "compulent", "OPaque", "OPulent", "opiphany", "OPac", "compacity", "opac", " opacity", "oplucent", "OPacity", "compaque", "OPatile", " Opaque", "OPlucent", " Opiphany", "compac", " opac", "iopatile", " Oplucent", "opatile", "iopiphany", "ioplucent", " opulent", "opulent"], "vc": ["ctx", "gc", "tv", "vv", "sn", "vt", "oc", "soc", "ev", "vd", "bc", "ctrl", "xc", "vs", "vm", "iv", "vl", "ht", "etc", "c", "cs", "vp", "lc", "serv", "tk", "ec", "lv", "uv", "wr", "ic", "vr", "VC", "dc", "vg", "cv", "nv", "cu", "voc", "sv", "conv", "cf", "vo", "wx", "vi", "v"], "s": ["js", "gs", "spec", "sn", "sl", "ls", "p", "sq", "o", "rs", "sp", "soc", "w", "d", "sb", "vs", "gets", "ps", "n", "sc", "fs", "sis", "ds", "sm", "sa", "b", "c", "cs", "r", "sw", "ts", "ses", "serv", "ss", "i", "t", "aws", "g", "u", "ns", "session", "a", "hs", "sam", "sts", "sv", "qs", "h", "sys", "sg", "os", "ats", "S", "st", "is", "v"], "btn": ["pkg", " ko", " tet", "bb", "bs", "fw", "quit", "again", "kt", "attr", "fn", "org", "nom", "foo", "tn", "bott", "bf", "pai", "wx", " bout", "prot", "cb", " bud", "fl", "toggle", "ctrl", "bp", " slack", "b", "og", " notch", "bh", "bj", " tit", "bol", " kick", "ctr", "fb", "bd", " champ", " dock", "ko", "oulder", " tip", "mu", "aug", "lu", " quit", "utt", "msg", "txt", "butt", "ck", "window", "rl", "fp", "comm", "bn", "bo", " todd", "dat", " slog", "skin", "addon", "nm", "plot", "heading", "sb", "typ", "feat", "fc", "tk", "focus", "bt", "cmd", "bolt", "bg", "cli", "bot", "stick"]}}
{"project": "FFmpeg", "commit_id": "183216b21870f21c86c904a7530d53682d7db46d", "target": 1, "func": "static void * attribute_align_arg worker(void *v){\n\n    AVCodecContext *avctx = v;\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    AVPacket *pkt = NULL;\n\n\n\n    while(!c->exit){\n\n        int got_packet, ret;\n\n        AVFrame *frame;\n\n        Task task;\n\n\n\n        if(!pkt) pkt= av_mallocz(sizeof(*pkt));\n\n        if(!pkt) continue;\n\n        av_init_packet(pkt);\n\n\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {\n\n            if(c->exit){\n\n                pthread_mutex_unlock(&c->task_fifo_mutex);\n\n                goto end;\n\n            }\n\n            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);\n\n        }\n\n        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n        frame = task.indata;\n\n\n\n        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);\n\n        pthread_mutex_lock(&c->buffer_mutex);\n\n        av_frame_unref(frame);\n\n        pthread_mutex_unlock(&c->buffer_mutex);\n\n        av_frame_free(&frame);\n\n        if(got_packet) {\n\n            int ret2 = av_dup_packet(pkt);\n\n            if (ret >= 0 && ret2 < 0)\n\n                ret = ret2;\n\n        } else {\n\n            pkt->data = NULL;\n\n            pkt->size = 0;\n\n        }\n\n        pthread_mutex_lock(&c->finished_task_mutex);\n\n        c->finished_tasks[task.index].outdata = pkt; pkt = NULL;\n\n        c->finished_tasks[task.index].return_code = ret;\n\n        pthread_cond_signal(&c->finished_task_cond);\n\n        pthread_mutex_unlock(&c->finished_task_mutex);\n\n    }\n\nend:\n\n    av_free(pkt);\n\n    pthread_mutex_lock(&c->buffer_mutex);\n\n    avcodec_close(avctx);\n\n    pthread_mutex_unlock(&c->buffer_mutex);\n\n    av_freep(&avctx);\n\n    return NULL;\n\n}\n", "idx": 20457, "substitutes": {"v": ["V", "m", "vv", "vt", "vc", "p", "ve", "w", "vs", "av", "va", "n", "vm", "iv", "l", "b", "r", "vp", "j", "i", "t", "k", "g", "vr", "cv", "nv", "sv", "h", "vo", "vi", "f"], "avctx": [" avcfg", " avconn", "avehandle", "avhandle", "svcontext", " avcontext", " avcam", "avercontext", "avnp", "averctx", "avecv", " avnp", "avconn", "svnp", "avecam", "avecontext", "averhandle", "avenp", "avcfg", "svconn", "avercam", "avectx", "avcv", "avcontext", "svctx", "avcam", " avcv", "avecfg", "avercv", "avercfg", " avhandle", "aveconn"], "c": ["ctx", "cp", "ac", "gc", "m", "cr", "this", "ci", "p", "vc", "ca", "bc", "conf", "can", "xc", "tc", "cache", "nc", "cm", "mc", "cc", "sc", "n", "C", "l", "co", "cl", "etc", "com", "chain", "b", "cs", "fc", "r", "lc", "config", "ec", "comm", "t", "ce", "g", "pc", "cd", "unc", "dc", "ic", "cv", "count", "con", "cam", "e", "abc", "cu", "cf", "rc", "call", "cmp", "coll", "f", "cb", "ct"], "pkt": ["pkg", "xpacket", "pack", "paacket", " pmsg", "paelt", " pwk", " pelt", "payqt", " pkg", " pet", "xpett", "ipacket", "spkt", "npelt", "parsekt", " pqt", "xpkg", "pkat", " pct", "parseacket", "pakt", "pckt", "Pqt", "Pkat", " pvc", "ipet", " pett", "wpwk", "payacket", "pett", "Pkt", "parsekg", "cpwk", " pcmd", "pft", "pwk", "paycmd", "pet", " pix", "pct", "Packet", "spett", "Pet", "Pct", "parseet", "spkg", "payix", "spacket", "cpacket", "pacmd", "pbmsg", "pix", "pashot", "vpft", "pcck", "cpkt", "pcet", "wpet", "cpet", "fpkt", "packet", "nacket", "pbkt", " pkat", "ppct", "nkt", "wpkat", "payshot", "pbelt", "paix", " pft", "ppnt", " packet", "vpkt", "nct", "spck", "pmsg", "ipkt", "fpkg", "ppacket", "pcmd", "pbkg", "pqt", "packkt", "payct", "packkg", "wpkt", " pshot", "pcacket", "paykt", "ppkt", "vpacket", "vpelt", "xpkt", "pnt", " pnt", "ppet", "pshot", " pck", "Pwk", "packacket", "pckg", "nnt", "spvc", "packck", "npmsg", "npkg", "fpet", "pelt", "fpacket", "pcct", "pavc", "ipwk", "pvc", "paft", "npkt", "pck"], "got_packet": ["got___packel", "got_linkacket", "got_signET", "got_maskel", "got___pet", "got_ped", "got_packacket", "got_signet", "got_packedet", "got_signkt", "got_packkt", "got_packageo", "got_packageacket", "got_buckkt", "got_packagekt", "got_packo", "got___packet", "got_masko", "got___pel", "got_packET", "got_packedkt", "got_masked", "got_packageed", "got___packed", "got___ped", "got_po", "got_packageel", "got_masket", "got_pet", "got_pel", "got_packeder", "got_packskt", "got_linker", "got_linkkt", "got___packo", "got_packer", "got_buckET", "got_packel", "got_packsET", "got_linket", "got_packed", "got_packageet", "got_bucked", "got_packsed", "got_packageer", "got_bucket", "got___po", "got_packset", "got_signed", "got_packedacket"], "ret": ["rot", "try", "success", "ert", "alt", "tr", "Ret", "kt", "jp", "def", "url", "virt", "magic", "reply", "it", "rem", "status", "bit", "fin", "att", "fun", "got", "result", "rt", " Ret", "xt", "nt", "flag", "cmd", "dr", "deg", "ft", "res", "repl", "lt", "txt", "ref", "rev", "re", "resp", "desc", "RT", "len", "code", "arg", "rets", "mem", "gt", "after", "usr", "rm", "elt", "err", "RET", "back", "mt", "f", "cont", "val"], "frame": [" Frame", "face", "profile", "scene", "iframe", "data", "file", "qt", "framework", "word", "image", "kt", "req", "def", " framed", "fr", "orig", "force", "component", "feat", "movie", "fin", "bit", "text", "info", "Frame", "fram", "feature", "doc", "ence", "tx", "FR", "point", "video", "step", "version", "shot", "t", "remote", " timeframe", "error", "sample", "ref", "rame", "session", "window", "process", "event", "frames", "code", "zero", "row", "none", "base", "bf", "comp", "cf", "part", "fb", "sequence", "block", "f", "zone", "draw"], "task": ["action", "dev", "command", "list", "tt", "word", "image", "req", "kt", "tag", "tc", "master", "question", "service", "request", "tar", "test", "self", "feat", "bit", "role", "result", "rake", "token", "thread", "worker", "tx", "config", "item", "function", "nt", "node", "unknown", "func", "t", "remote", "net", "message", "key", "msg", "target", "total", "session", "window", "process", "work", "job", "event", "next", "piece", "time", "form", "package", "index", "Task", "part", "ask", "new", "commit", "block", "table", "course", "term"]}}
{"project": "qemu", "commit_id": "86865c5ff16bd1a2ef2b9ce217a7bb8f39e2126c", "target": 1, "func": "static void _decode_opc(DisasContext * ctx)\n\n{\n\n    /* This code tries to make movcal emulation sufficiently\n\n       accurate for Linux purposes.  This instruction writes\n\n       memory, and prior to that, always allocates a cache line.\n\n       It is used in two contexts:\n\n       - in memcpy, where data is copied in blocks, the first write\n\n       of to a block uses movca.l for performance.\n\n       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used\n\n       to flush the cache. Here, the data written by movcal.l is never\n\n       written to memory, and the data written is just bogus.\n\n\n\n       To simulate this, we simulate movcal.l, we store the value to memory,\n\n       but we also remember the previous content. If we see ocbi, we check\n\n       if movcal.l for that address was done previously. If so, the write should\n\n       not have hit the memory, so we restore the previous content.\n\n       When we see an instruction that is neither movca.l\n\n       nor ocbi, the previous content is discarded.\n\n\n\n       To optimize, we only try to flush stores when we're at the start of\n\n       TB, or if we already saw movca.l in this TB and did not flush stores\n\n       yet.  */\n\n    if (ctx->has_movcal)\n\n\t{\n\n\t  int opcode = ctx->opcode & 0xf0ff;\n\n\t  if (opcode != 0x0093 /* ocbi */\n\n\t      && opcode != 0x00c3 /* movca.l */)\n\n\t      {\n\n\t\t  gen_helper_discard_movcal_backup ();\n\n\t\t  ctx->has_movcal = 0;\n\n\t      }\n\n\t}\n\n\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_ldtlb();\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_PRIVILEGED\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_sleep(tcg_const_i32(ctx->pc + 2));\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\t\t\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(low, REG(B7_4));\n\n\t    tcg_gen_bswap16_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\tgen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\tgen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new();\n\n\t    TCGv cmp2 = tcg_temp_local_new();\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\tgen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macl(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macw(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\tgen_helper_negc(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\tgen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\tgen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,\t   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(addr, addr, 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t} else {\n\n\t    TCGv addr;\n\n\t    addr = tcg_temp_new_i32();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B11_8);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B7_4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    CHECK_FPU_ENABLED\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n                TCGv_i64 fp0, fp1;\n\n\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new_i64();\n\n\t\tfp1 = tcg_temp_new_i64();\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_DT(fp0, fp1);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_DT(fp0, fp1);\n\n                    return;\n\n                }\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n                tcg_temp_free_i64(fp0);\n\n                tcg_temp_free_i64(fp1);\n\n\t    } else {\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                }\n\n\t    }\n\n\t}\n\n\treturn;\n\n    case 0xf00e: /* fmac FR0,RM,Rn */\n\n        {\n\n            CHECK_FPU_ENABLED\n\n            if (ctx->fpscr & FPSCR_PR) {\n\n                break; /* illegal instruction */\n\n            } else {\n\n                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],\n\n                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    gen_helper_trapa(imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* ldc Rm,SR */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* ldc.l @Rm+,SR */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* stc SR,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* stc SR,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n#define LD(reg,ldnum,ldpnum,prechk)\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\n\n#define ST(reg,stnum,stpnum,prechk)\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new();\t\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_gen_mov_i32(REG(B11_8), addr);\t\t\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\\n\n\tLD(reg,ldnum,ldpnum,prechk)\t\t\t\t\\\n\n\tST(reg,stnum,stpnum,prechk)\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)\n\n\tST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)\n\n\tLD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\tgen_helper_ld_fpscr(REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    gen_helper_ld_fpscr(addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n        {\n\n            TCGv val = tcg_temp_new();\n\n            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);\n\n            gen_helper_movcal (REG(B11_8), val);            \n\n            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n        }\n\n        ctx->has_movcal = 1;\n\n\treturn;\n\n    case 0x40a9:\n\n\t/* MOVUA.L @Rm,R0 (Rm) -> R0\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40e9:\n\n\t/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0073:\n\n        /* MOVCO.L\n\n\t       LDST -> T\n\n               If (T == 1) R0 -> (Rn)\n\n               0 -> LDST\n\n        */\n\n        if (ctx->features & SH_FEATURE_SH4A) {\n\n\t    int label = gen_new_label();\n\n\t    gen_clr_t();\n\n\t    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);\n\n\t    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\t    gen_set_label(label);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0063:\n\n        /* MOVLI.L @Rm,R0\n\n               1 -> LDST\n\n               (Rm) -> R0\n\n               When interrupt/exception\n\n               occurred 0 -> LDST\n\n        */\n\n\tif (ctx->features & SH_FEATURE_SH4A) {\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 1);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    gen_helper_ocbi (REG(B11_8));\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x00d3:\t\t/* prefi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00e3:\t\t/* icbi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00ab:\t\t/* synco */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new();\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_helper_float_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_ftrc_DT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fabs_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fsqrt_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 20467, "substitutes": {"ctx": ["pkg", "xp", "np", "kt", "tmp", "tc", "iat", "conn", "acl", "nt", "dl", "unc", "dc", "resp", "wcs", "ind", "tz", "crit", "x", "hw", "wx", "ticket", "cb", "cv", "cp", "gc", "command", "reason", "yes", "jp", "ctrl", "unk", "cc", "tm", "prefix", "today", "config", "cas", "document", "ctr", "cu", "mk", "req", "loc", "xc", "anc", "cm", "history", "aux", "kw", "lc", "act", "timeout", "kb", "ck", "std", "abc", "exec", " cx", "ctl", "ct", "cfg", "ca", "bc", "mc", "etc", "c", "tx", "cmd", "ce", "event", "context", "xs", "cf", "cmp"], "CHECK_NOT_DELAY_SLOT": ["CHECK_NOT_DELAY_PLOTS", "CHECK_NOT_DELAY_Slot", "CHECK_NOT_DELAYEDSLot", "CHECK_NOT_DELAY_SLOP", "CHECK_NOT_DELAYEDSLOTS", "CHECK_NOT_DELAY_PLOT", "CHECK_NOT_DELAY_PLOST", "CHECK_NOT_DELAY_SLot", "CHECK_NOT_DELAY_SlOST", "CHECK_NOT_DELAYEDSLOP", "CHECK_NOT_DELAY_SLOTS", "CHECK_NOT_DELAY_LOT", "CHECK_NOT_DELAY_PLot", "CHECK_NOT_DELAY_LOTS", "CHECK_NOT_DELAY_LOP", "CHECK_NOT_DELAY_Lot", "CHECK_NOT_DELAY_SlOP", "CHECK_NOT_DELAY_PLOP", "CHECK_NOT_DELAY_SLOST", "CHECK_NOT_DELAY_SlOT", "CHECK_NOT_DELAYEDSLOT", "CHECK_NOT_DELAYEDSLOST"], "delayed_pc": ["delayed5mc", "delocated5sc", "delaying_PC", "delayed_PC", "delocated_mc", "delocated_PC", "delaying___pc", "delocated_pc", "delayed5PC", "delayed___sc", "delayed5pc", "delaying_sc", "delocated5pc", "delayed___pb", "delaying___PC", "delocated5PC", "delayed___PC", "delayed5sc", "delaying___sc", "delaying_pc", "delayed___pc", "delaying_pb", "delaying___pb", "delocated5mc", "delayed_mc", "delayed_pb", "delayed_sc", "delocated_sc"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n", "idx": 20471, "substitutes": {"opaque": ["oply", "opaques", "Opaque", "opacity", "ipaques", "oient", "ogque", "oplaque", "opque", "ogaque", " opatile", "oaque", "ogacity", "oplient", "Opatile", "oacity", "oplacity", " oply", "Opaques", "oplque", "ipatile", "opient", "Oply", "opatile", "ipaque", " opaques", "oque", "iply", "ogient"], "hz": ["GHz", "height", "kh", "frequency", "mostly", " height", "zh", "phil", "z", "conf", "hhhh", " MHz", "zz", "cz", "phy", "hm", "fs", "hurst", "rss", "hd", " her", "maxwell", " sch", "density", " fps", " frequency", " h", "MHz", "stones", "Hz", "hash", "wcs", "hs", "hh", " cz", " bandwidth", "elong", "tz", "h", "fps", "zon", " Hz", "clock", "weight", "vals", " hue", "zone", "val"], "s": ["js", "gs", "m", "spec", "sl", "ls", "q", "p", "sq", "rs", "bs", "sb", "sol", "service", "ps", "bis", "self", "status", "ds", "b", "ms", "c", "an", "as", "r", "ts", "j", "ss", "stats", "t", "set", "g", "ns", "ins", "its", "socket", "a", "e", "source", "sts", "sv", "h", "ats", "se", "sys", "S", "space", "f", "is", "v"]}}
{"project": "qemu", "commit_id": "ac58fe7b2c67a9be142beacd4c6ee51f3264d90f", "target": 1, "func": "static void pmac_dma_write(BlockBackend *blk,\n\n                         int64_t sector_num, int nb_sectors,\n\n                         void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    dma_addr_t dma_addr, dma_len;\n\n    void *mem;\n\n    int nsector, remainder;\n\n    int extra = 0;\n\n\n\n    qemu_iovec_destroy(&io->iov);\n\n    qemu_iovec_init(&io->iov, io->len / MACIO_PAGE_SIZE + 1);\n\n\n\n    if (io->remainder_len > 0) {\n\n        /* Return remainder of request */\n\n        int transfer = MIN(io->remainder_len, io->len);\n\n\n\n        MACIO_DPRINTF(\"--- processing write remainder %x\\n\", transfer);\n\n        cpu_physical_memory_read(io->addr,\n\n                                 &io->remainder + (0x200 - transfer),\n\n                                 transfer);\n\n\n\n        io->remainder_len -= transfer;\n\n        io->len -= transfer;\n\n        io->addr += transfer;\n\n\n\n        s->io_buffer_index += transfer;\n\n        s->io_buffer_size -= transfer;\n\n\n\n        if (io->remainder_len != 0) {\n\n            /* Still waiting for remainder */\n\n            return;\n\n        }\n\n\n\n        MACIO_DPRINTF(\"--> prepending bounce buffer with size 0x200\\n\");\n\n\n\n        /* Sector transfer complete - prepend to request */\n\n        qemu_iovec_add(&io->iov, &io->remainder, 0x200);\n\n        extra = 1;\n\n    }\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        sector_num = (int64_t)(s->lba << 2) + (s->io_buffer_index >> 9);\n\n    } else {\n\n        sector_num = ide_get_sector(s) + (s->io_buffer_index >> 9);\n\n    }\n\n\n\n    nsector = (io->len >> 9);\n\n    remainder = io->len - (nsector << 9);\n\n\n\n    MACIO_DPRINTF(\"--- DMA write transfer - addr: %\" HWADDR_PRIx \" len: %x\\n\",\n\n                  io->addr, io->len);\n\n    MACIO_DPRINTF(\"xxx remainder: %x\\n\", remainder);\n\n    MACIO_DPRINTF(\"xxx sector_num: %\"PRIx64\"   nsector: %x\\n\",\n\n                  sector_num, nsector);\n\n\n\n    dma_addr = io->addr;\n\n    dma_len = io->len;\n\n    mem = dma_memory_map(&address_space_memory, dma_addr, &dma_len,\n\n                         DMA_DIRECTION_TO_DEVICE);\n\n\n\n    if (!remainder) {\n\n        MACIO_DPRINTF(\"--- DMA write aligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, io->len);\n\n        qemu_iovec_add(&io->iov, mem, io->len);\n\n    } else {\n\n        /* Write up to last complete sector */\n\n        MACIO_DPRINTF(\"--- DMA write unaligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, (nsector << 9));\n\n        qemu_iovec_add(&io->iov, mem, (nsector << 9));\n\n\n\n        MACIO_DPRINTF(\"--- DMA write read    - bounce addr: %p \"\n\n                      \"remainder_len: %x\\n\", &io->remainder, remainder);\n\n        cpu_physical_memory_read(io->addr + (nsector << 9), &io->remainder,\n\n                                 remainder);\n\n\n\n        io->remainder_len = 0x200 - remainder;\n\n\n\n        MACIO_DPRINTF(\"xxx remainder_len: %x\\n\", io->remainder_len);\n\n    }\n\n\n\n    s->io_buffer_size -= ((nsector + extra) << 9);\n\n    s->io_buffer_index += ((nsector + extra) << 9);\n\n\n\n    io->len = 0;\n\n\n\n    MACIO_DPRINTF(\"--- Block write transfer   - sector_num: %\"PRIx64\"  \"\n\n                  \"nsector: %x\\n\", sector_num, nsector + extra);\n\n\n\n    m->aiocb = blk_aio_writev(blk, sector_num, &io->iov, nsector + extra, cb,\n\n                              io);\n\n}\n", "idx": 20480, "substitutes": {"blk": ["BLk", "slk", "blb", "BLK", "blK", "blak", "slak", " blak", "BLak", "slK", " blb", "BLb", "slb", " blK"], "sector_num": ["sector2name", "section_num", "sector_dim", "section_number", "sector_id", "sectoritynumber", "sector_no", " sector_number", "sectoritynum", "sector2num", "sector_number", " sector_no", "section_id", " sector_dim", "sectoritydim", "sector_name", "sector_Num", "section_Num", "sectorityno", "sector2number", "sector2no", " sector_name"], "nb_sectors": ["nb_pselements", "nb_segments", "nb_psectors", "nb_nectors", "nb_negments", "nb_vegments", "nb_vectors", "nb_selements", "nb_pseors", "nb_psegments", "nb_veors", "nb_nelements", "nb_seors", "nb_velements", "nb_neors"], "cb": ["ctx", "cp", "CB", "callback", "bb", "bc", "ctrl", "sb", "gb", "bp", "cm", "cc", "b", "proc", "fn", "func", "db", "rb", "bg", "cd", "dc", "buf", "obj", "bf", "cf", "err", "fp", "cmp", "cv"], "opaque": ["Opaco", " opus", "iopaque", "opaques", "oque", "Opaque", "patile", "opacity", "oaco", "iopaques", "oboid", "omposit", "opaco", "operque", "compque", "oplaco", "oplaque", "obatile", "oposit", "ompaque", "opque", "operoid", "compacity", "composit", "Opque", "obaque", " opatile", "ipacity", "oaque", "ipque", "Opacity", "compaque", "paque", "operaque", "opoid", "oacity", "opus", " opque", "oplacity", "pque", "oplque", "ompque", "operus", "iopatile", "opatile", "obaques", "ipaque", "operaques", "iposit", "operatile", "ompacity", "pus", "iopoid"], "io": ["ror", "ox", "so", "rio", "lo", "test", "ae", "org", "video", "iot", "server", "pro", " ie", "foo", "ip", "ri", "client", "ao", "ro", "ico", "ore", "op", "os", "example", "ki", "im", "command", "list", "zip", "o", "yes", "cgi", "proxy", "it", "feed", "co", "bit", "core", "serv", "ive", "tif", "net", "remote", "error", "writer", "byte", "iol", "fo", "my", "or", "image", "iterator", "IO", "ace", "transfer", "orm", "history", "hero", "timeout", "ai", "network", "page", "driver", "window", "note", "obj", "row", "http", "option", "form", "ee", "connection", "exec", "ilo", "entry", "ahi", "def", "ion", "task", "ry", "storage", "no", "i", "go", " gateway", "ie", " IO", "cho", "ory", "poll", "link", "disk", "event", "ary", "isco", "interface", "iop", "ia", "ex", "response"], "m": ["meta", "me", "em", "mm", "p", "o", "manager", "gm", "w", "d", "n", "cm", "mc", "hm", "vm", "tm", "sm", "l", "mp", "b", "ms", "mode", "c", "bm", "r", "j", "i", "t", "dm", "g", "mis", "h", "M", "mt", "f", "v"], "s": ["js", "gs", "sets", "spec", "ls", "p", "us", "sp", "o", "rs", "bs", "es", "w", "d", "sb", "vs", "n", "ps", "y", "sc", "fs", "sm", "ds", "ims", "self", "b", "ms", "er", "c", "cs", "settings", "r", "sw", "ts", "sym", "serv", "ss", "i", "stats", "t", "less", "set", "g", "ns", "ies", "sim", "ins", "its", "changes", "services", "hs", "e", "ports", "a", "sam", "sts", "sv", "qs", "sys", "h", "ats", "os", "S", "als", "is", "comm"], "dma_addr": ["dma_address", "dme_address", "dma__addr", "dma__ptr", "dme_ptr", "dme_addr", "dma_ptr", "dma2addr", "dma2ptr", "dma__address", "dma2address"], "dma_len": ["dme_size", "dma__val", "dma___val", "dma___size", "dma__size", "dma___len", "dme_len", "dme_val", "dma_val", "dma_length", "dme_length", "dma__length", "dma__len", "dma___length", "dma_size"], "mem": ["temp", "mm", "memory", "nm", "Mem", "um", "rem", "mi", "buff", "cmd", "reg", "phys", "res", "buffer", "msg", "ref", "asm", "link", "mb", "buf", "md", "ram", "jump", "ata", "addr", "alloc", "progress", "mop"], "nsector": ["cnsector", "cnser", "Nframe", "ntector", "ntsector", "anframe", "Nsection", "nsection", " nser", "nser", "ntriver", "dector", "nbrowser", "nriver", "Nector", " nsection", " nriver", "anector", "ntsection", "dsector", "Nsector", "nector", " nbrowser", "dsection", "cnbrowser", "nframe", "msection", "mser", "Nriver", "cnsection", " nector", "mbrowser", "ansector", "msector", "dframe", "ansection"], "remainder": ["remainedder", "remplaindr", "respainner", " remainsger", " remainedner", "remainter", "remraindr", "promainedder", "resprainder", "promainder", " remainsner", "promainedger", "resprainter", " remaindr", "remainedter", "REMainingDER", "remainingter", "promainner", "respainder", "REMainter", "remplainter", "remaindr", "remainsner", "remainedger", "REMainingter", "remplainger", "remrainder", "respaindr", "remainingder", "promainger", " remainedDER", "remainsder", "remrainDER", "remainingner", " remainger", "remainedner", "REMainDER", " remainDER", "remainingDER", "remrainter", "resprainner", "REMainingder", "REMainder", "remainger", "remainsger", "remainingger", "REMainger", "promainedter", "REMainingger", "promainedner", " remainsder", " remainedger", "remainedDER", "remainsDER", "remrainner", "respraindr", " remainsdr", " remainner", "respainter", "remplainner", "remainner", "promainter", "remainsdr", "remplainder", "remainster", "remrainger", "remainingdr", " remainedder", "remainDER"]}}
{"project": "qemu", "commit_id": "c5acdc9ab4e6aa9b05e6242114479333b15d496b", "target": 0, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n", "idx": 20485, "substitutes": {"bs": ["js", "gs", "ls", "bing", "hz", "es", "bits", "bc", "bes", "sb", "vs", "outs", "bp", "bis", "ps", "bytes", "fs", "acs", "ims", "ds", "ms", "ics", "cs", "iss", "ts", "cus", "ss", "stats", "ubis", "aus", "bles", "aws", "aos", "ubs", "BS", "ns", "cks", "pb", "ks", "its", "boxes", "bps", "hs", "obs", "sts", "qs", "xs", "sys", "bos", "ats", "aps", "lbs", "als", "bas"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 20495, "substitutes": {"iommu_mr": ["iommo_mr", "iommu_hr", "iommu_vr", "iommo_tr", "iommu_tr", "iommu_rs", "iommu2mr", "iommu2rr", "iommu2vr", "iommu_rr", "iommo_rr", "iommo_rs", "iommo_vr", "iommu2rs", "iommo_hr"], "n": ["nw", "m", "sn", "num", "p", "np", "nb", "o", "cn", "mn", "nm", "nn", "nc", "N", "on", "rn", "l", "nor", "b", "an", "c", "fn", "nl", "r", "j", "nt", "nu", "node", "i", "t", "na", "g", "tn", "ns", "out", "nv", "h", "x", "nr", "nah", "ne", "v"], "vtd_as": ["vdt_ars", "vdtpyws", "vsd_as", "vtd_a", "vtd___as", "vdoolyasha", "vtd_las", "vdd_asin", "vtd_am", "vtadbas", "vnt_ras", "vpd_as", "vtdpyas", "vtdolyase", "vtd2asy", "vtdolyaos", "vtd_ar", "vtd8as", "vpd_ar", "vtadbasha", "vdt_ws", "vtddba", "vsd_ase", "vdo_asha", "vtdolyas", "vtdappas", "vtd_av", "vta_asha", "vtd2as", "vtdolymas", "vtd2ase", "vtd0ar", "vtd0jas", "vdoolyas", "vdtpyas", "vtdpyars", "vtd_aos", "vtdpyrs", "vtdolyasy", "vtd_has", "vtd2jas", "vtd_ass", "vtd_asy", "vtd___asin", "vtd2aos", "vtd2asha", "vtadbras", "vtd8las", "vdt_am", "vdoolyasy", "vtd_ats", "vtdappasin", "vtddbas", "vtd_ws", "vtdpyws", "vdo_asy", "vsd_aos", "vta_as", "vtadba", "vtd_jas", "vtd2ras", "vdt_as", "vnt_as", "vtd_asin", "vdtpyars", "vta_ras", "vpd_ass", "vdo_ras", "vtd___ats", "vtd_asha", "vtd___ase", "vtddbasha", "vtd0as", "vtd2ass", "vtdolyhas", "vtdolyras", "vtddbras", "vdt_rs", "vnt_av", "vsd_ras", "vta_a", "vdd_ats", "vtd_ras", "vtd8am", "vdtpyrs", "vtdolyav", "vdo_as", "vtd2ar", "vdt_las", "vnt_has", "vtd_rs", "vpd_jas", "vtd_ase", "vtdolyasha", "vdoolyras", "vdd_as", "vdd_ase", "vtdappats", "vtdappase", "vtd_mas", "vtd_ars", "vtd0ass"], "s": ["js", "gs", "m", "sn", "ls", "p", "rs", "bs", "state", "w", "sb", "ps", "fs", "sis", "ds", "sa", "b", "c", "cs", "r", "as", "ts", "ss", "t", "g", "ns", "its", "sts", "h", "sys", "ats", "os", "S", "space", "is", "v"], "ce": ["ke", "ci", "ca", "CE", "cle", "te", "le", "ve", "entry", "cer", "cast", "cele", "ces", " ace", "je", "pe", " ice", "ace", "nc", "card", "cc", "enter", "force", "ue", "ced", "cause", " CE", "ae", "c", "du", "ence", "ense", "ie", "cue", "ine", "ck", "see", "et", "de", "ge", "cur", "ze", "lee", "e", "ent", "cand", "se", "cf", "ee", " ke", "coe", "ne", "cont", "cell", "cel", "ct"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n", "idx": 20507, "substitutes": {"sd": ["south", "sn", "so", "eds", "sand", "state", "td", "vd", "si", "d", "sb", "pd", "sm", "ds", "hd", "sky", "sh", "ess", "dis", "ss", "aws", "SD", "od", "dl", " cd", "dd", "sim", "md", "sam", "ind", "sv", "dk", "sg", "se", "sk", "st", "sy"], "addr": ["ha", "arp", "add", "Address", "at", "id", "pad", " dst", "help", "loc", "lag", "ptr", "ash", "ace", " address", "offset", "test", "attr", "dh", "address", " ptr", "tx", "ord", "cmd", "act", "map", "ar", "set", "ref", "align", "hash", "off", "work", "eth", "obj", "sha", "coord", "a", "arr", " pad", "ad", "mt", "ack"]}}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_handle_escape(QemuConsole *s)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i<s->nb_esc_params; i++) {\n\n        switch (s->esc_params[i]) {\n\n            case 0: /* reset all console attributes to default */\n\n                s->t_attrib = s->t_attrib_default;\n\n                break;\n\n            case 1:\n\n                s->t_attrib.bold = 1;\n\n                break;\n\n            case 4:\n\n                s->t_attrib.uline = 1;\n\n                break;\n\n            case 5:\n\n                s->t_attrib.blink = 1;\n\n                break;\n\n            case 7:\n\n                s->t_attrib.invers = 1;\n\n                break;\n\n            case 8:\n\n                s->t_attrib.unvisible = 1;\n\n                break;\n\n            case 22:\n\n                s->t_attrib.bold = 0;\n\n                break;\n\n            case 24:\n\n                s->t_attrib.uline = 0;\n\n                break;\n\n            case 25:\n\n                s->t_attrib.blink = 0;\n\n                break;\n\n            case 27:\n\n                s->t_attrib.invers = 0;\n\n                break;\n\n            case 28:\n\n                s->t_attrib.unvisible = 0;\n\n                break;\n\n            /* set foreground color */\n\n            case 30:\n\n                s->t_attrib.fgcol=COLOR_BLACK;\n\n                break;\n\n            case 31:\n\n                s->t_attrib.fgcol=COLOR_RED;\n\n                break;\n\n            case 32:\n\n                s->t_attrib.fgcol=COLOR_GREEN;\n\n                break;\n\n            case 33:\n\n                s->t_attrib.fgcol=COLOR_YELLOW;\n\n                break;\n\n            case 34:\n\n                s->t_attrib.fgcol=COLOR_BLUE;\n\n                break;\n\n            case 35:\n\n                s->t_attrib.fgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 36:\n\n                s->t_attrib.fgcol=COLOR_CYAN;\n\n                break;\n\n            case 37:\n\n                s->t_attrib.fgcol=COLOR_WHITE;\n\n                break;\n\n            /* set background color */\n\n            case 40:\n\n                s->t_attrib.bgcol=COLOR_BLACK;\n\n                break;\n\n            case 41:\n\n                s->t_attrib.bgcol=COLOR_RED;\n\n                break;\n\n            case 42:\n\n                s->t_attrib.bgcol=COLOR_GREEN;\n\n                break;\n\n            case 43:\n\n                s->t_attrib.bgcol=COLOR_YELLOW;\n\n                break;\n\n            case 44:\n\n                s->t_attrib.bgcol=COLOR_BLUE;\n\n                break;\n\n            case 45:\n\n                s->t_attrib.bgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 46:\n\n                s->t_attrib.bgcol=COLOR_CYAN;\n\n                break;\n\n            case 47:\n\n                s->t_attrib.bgcol=COLOR_WHITE;\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 20518, "substitutes": {"s": ["js", "gs", "sets", "spec", "tes", "sl", "ls", "sq", "us", "es", "rs", "bs", "details", "ches", "sb", "ants", "vs", "gets", "parts", "mys", "ps", "n", "states", "fs", "ims", "ds", "ms", "cs", "as", "sw", "ses", "ts", "ss", "stats", "t", "ans", "less", "aws", "ns", "ins", "its", "changes", "hs", "services", "ports", "ares", "ears", "sts", "sv", "qs", "sys", "ats", "se", "os", "S", "als", "is", "pers", "sports", "comm"], "i": ["m", "me", " ti", "ci", "ix", "us", " iter", " index", " li", "ex", " bi", "multi", "zi", "si", "by", " si", " mi", " di", "y", "it", "ims", "init", "ij", "xi", "ti", "mi", "qi", "c", "iu", "ski", "j", "di", "in", "go", "\u0438", " my", "ai", " ii", " I", "ui", "phi", "ic", "li", " multi", "gi", " j", "ip", "sim", "is", "ini", "e", " m", "ind", "bi", "oi", "index", "x", "ii", "pi", "batch", "I", " ni", "io", "ki", "im", " pi"]}}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,\n\n                              int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_64:\n\n        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "idx": 20520, "substitutes": {"s": ["js", "gs", "sq", "p", "es", "rs", "w", "d", "sb", "ps", "n", "fs", "ds", "c", "ts", "ses", "ss", "t", "ns", "socket", "e", "sv", "h", "sg", "os", "S", "v"], "tcg_src": ["tcg___syn", "tcg___desc", "tcgntsrc", "tcga_target", "tcg__src", "tcgntsyn", "tcgo___src", "tcgo___cur", "tcgo_src", "tcg___src", "tcg__dest", "tcg___cont", "tcg___impl", "tctg__source", "tctg_dest", "tcg___cur", "tcg_dest", "tcg_syn", "tcgo_cur", "tcg_cur", "tcga_src", "tctg_source", "tcgntdesc", "tctg__dest", "tcgo_cont", "tcga_rol", "tcgo_dest", "tcg_rou", "tcgo___rou", "tcgo_rou", "tcgo_impl", "tcgo___cont", "tctg__src", "tcgo_tmp", "tcg_st", "tcrg_impl", "tcrg_desc", "tcg_impl", "tcg___tmp", "tcg_tmp", "tcg___rou", "tcga_st", "tcrg_syn", "tcgo___impl", "tcgo___tmp", "tcgntimpl", "tcg_rol", "tcg___dest", "tcg_source", "tcg_desc", "tctg_src", "tcg_target", "tcg_cont", "tcrg_src", "tcg__source", "tcgo___dest"], "destidx": ["destidxf", "Destindxs", "destidxs", "Destindx", " destidxs", "Destindy", "destIdy", "destindxf", "destindxs", " destidy", "destindz", "destidy", "destIdxf", " destidxf", "Destidx", "destIdxs", "Destidz", "destindy", "destIdz", "destindx", "Destidxs", "Destidy", "destIdx", "destidz", "Destindz"], "element": ["ror", "vector", "month", "ment", "entry", "repeat", "pe", "ace", "field", "module", "value", "lement", "oe", "offset", "component", "mode", "feature", "address", "empty", "append", "ce", "buffer", "E", "Element", "lements", "variable", "section", "position", "number", "e", "interface", "attribute", "index", "echo", " ele", "lem", "elt", "ele", "object", "sequence", "nce", "le"], "memop": ["memoryop", "memops", "memoper", "memoryoper", "emOp", "memOp", "Memop", "memoryops", " memhop", "MemOp", "memok", "memoryoop", " memops", "emop", " memOp", "mOp", " memok", "emops", "Memoper", "mhop", "memoop", " memoop", "memoryok", "memhop", "emoop", "mok", "memoryhop", "Memhop", "memoryOp", " memoper", "mop"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),\n\n                                    int ra, int rb, int rc,\n\n                                    int islit, uint8_t lit)\n\n{\n\n    if (unlikely(rc == 31))\n\n        return;\n\n\n\n    if (ra != 31) {\n\n        if (islit) {\n\n            if (lit != 0)\n\n                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));\n\n            else\n\n                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);\n\n        } else {\n\n            TCGv tmp1, tmp2;\n\n            tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);\n\n            tcg_gen_shli_i64(tmp1, tmp1, 3);\n\n            tmp2 = tcg_const_i64(64);\n\n            tcg_gen_sub_i64(tmp1, tmp2, tmp1);\n\n            tcg_temp_free(tmp2);\n\n            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);\n\n            tcg_temp_free(tmp1);\n\n        }\n\n        if (tcg_gen_ext_i64)\n\n            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);\n\n    } else\n\n        tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n}\n", "idx": 20531, "substitutes": {"tcg_gen_ext_i64": ["tcg_gen_ext_pi32", "tcg_gen_ext_l16", "tcg_gen_ext_pi256", "tcg_gen_ext_i16", "tcg_gen_ext_i32", "tcg_gen_ext_i256", "tcg_gen_ext2i16", "tcg_gen_ext2i64", "tcg_gen_ext_I16", "tcg_gen_ext_l64", "tcg_gen_ext_I256", "tcg_gen_ext_I32", "tcg_gen_ext2I64", "tcg_gen_ext_I64", "tcg_gen_ext2i8", "tcg_gen_ext_pi16", "tcg_gen_ext_i8", "tcg_gen_ext_I8", "tcg_gen_ext2I16", "tcg_gen_ext_pi8", "tcg_gen_ext2I32", "tcg_gen_ext2i32", "tcg_gen_ext_pi64", "tcg_gen_ext2I8", "tcg_gen_ext_l32"], "ra": ["ha", "ror", "ta", "rog", "cr", "rx", "ur", "mr", "ca", "lo", "rs", "pr", "tra", "ara", "tri", "loc", "br", "aria", "dra", "rw", "era", "co", "ica", "sa", "rh", "rise", "rt", "raf", "r", "ran", "po", "RA", "la", "ir", "rar", "ar", "rap", "area", "ras", "ma", "rera", "ref", "ri", "ru", "re", "Ra", "cur", "ro", "a", "row", "cro", "au", "rr", "rd"], "rb": ["hr", "erb", "mr", "nb", "loc", "wb", "bp", "br", "rw", "ab", "ob", "b", "lr", "rt", "raf", "r", "bt", "rar", "db", "rf", "vr", "ruby", "ref", "lb", "re", "ri", "ru", "pb", "ro", "rob", "reb", "rl", "RB", "rg", "rr", "rd", "rid", "rm", "cb"], "rc": ["ror", "rog", "gc", "hr", "cr", "rin", "rx", "ur", "roc", "rs", "isc", "loc", "ctrl", "tc", "src", "nc", "sc", "cc", "rn", "rw", "rac", "co", "ica", "rt", "c", "RC", "fc", "cs", "r", "irc", "raf", "lc", "ec", "uc", "act", "rar", "ce", "ras", "pc", "vr", "ck", "ref", "ri", "cur", "cv", "ru", "ro", "row", "ctr", "rl", "rec", "rr", "rm", "arc", "cb", "ct"], "islit": ["kellit", "gellit", "selig", "iolig", "selite", "iolit", "slite", "selit", "kelit", "islitt", "gelit", "iollit", "sellit", "slitt", "iolitt", "sllit", "isllit", "gelitt", "islig", "slit", "gelig", "slig", "kelig", "islite", "kelite"], "lit": ["hi", "rot", "sl", "alt", "sel", "type", "las", "loc", "lam", "length", "def", "typ", "it", "pl", "lim", "init", "l", "bit", "eral", "lic", "limit", "rt", "tl", "lu", "lc", "buff", "la", "lv", "t", "mit", "fi", "li", "lt", "let", "ref", "lb", "vec", "len", "late", "lif", "hl", "lp", "lang", "stat", "lite"], "tmp1": ["mp2", "txt2", " tmp3", "temFor", "tem1", "ctx1", "tem2", "tem4", "temp2", "permone", "mp25", "td2", "tmpOne", "temp4", "txt3", "tm0", "tp1", " tmp4", "buffone", "permOne", "ctx2", "temp1", "txtOne", "buffOne", "mpOne", "tmpone", "buff1", "mp1", "tm1", "tmone", "tp25", "tmp25", " tmpFor", "perm2", "tm2", "tmp3", "tdOne", "txt1", " tmpone", "td1", "tempFor", " tmpOne", "txtone", "perm1", "tmp0", "mp3", "tp2", "mpone", "tpOne", "tmpFor", "tmp4", "buff2", "temp3", " tmp25", "ctxOne", "temp0", "ctx3", "mp0", " tmp0"], "tmp2": ["mp2", "txt2", " tmp3", "prime2", "temp2", "txt02", "primetwo", "temp4", "txt3", " tmp4", "tmp02", "temp1", "mp1", "tmp3", "txt1", "mp4", "prime02", "mptwo", "mp3", "obj1", "tmptwo", "mp02", " tmp02", "tmp4", "prime1", "temp3", "objtwo", "obj2", "obj02"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "void ff_h264_init_dequant_tables(H264Context *h)\n\n{\n\n    int i, x;\n\n    init_dequant4_coeff_table(h);\n\n    if (h->pps.transform_8x8_mode)\n\n        init_dequant8_coeff_table(h);\n\n    if (h->sps.transform_bypass) {\n\n        for (i = 0; i < 6; i++)\n\n            for (x = 0; x < 16; x++)\n\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n\n        if (h->pps.transform_8x8_mode)\n\n            for (i = 0; i < 6; i++)\n\n                for (x = 0; x < 64; x++)\n\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n\n    }\n\n}\n", "idx": 20534, "substitutes": {"h": ["gc", "m", "kh", "q", "p", "zh", "hz", "here", "oh", "ih", "w", "cache", "ah", "ph", "hm", "it", "ht", "hd", "b", "dh", "rh", "history", "c", "sh", "info", "he", "proc", "sw", "eh", "host", "dr", "t", "bh", "H", "hp", "hash", "hist", "window", "hs", "hh", "hl", "handle", "obj", "ch", "context", "mem", "http", "hw", "th", "f", "help", "v", "comm"], "i": ["iy", "hi", "m", "this", "me", "ci", "ix", "p", "us", "q", "at", "id", "name", "si", "zi", "multi", "g", "ei", "y", "it", "l", "ij", "status", "ti", "mi", "chain", "qi", "iu", "c", "info", "di", "in", "\u0438", "ai", "ki", "ie", "u", " ii", "gi", "phi", "ui", "li", "ic", "key", "uri", "ip", "sim", "ri", "cli", "slice", "ini", "bi", "ind", "oi", "index", "ii", " I", "pi", "batch", "asi", "I", "ik", "io", "is", "im"], "x": ["ctx", "xp", "ac", "any", "check", "ox", "rx", "try", "ix", "q", "p", "mx", "z", "at", "xx", "yx", "ax", "dx", "xxx", "xc", "ph", "on", "y", "inx", "pl", "xi", "expr", "xe", "xt", "c", "xa", "lex", "mix", "tx", "j", "pt", "act", "xml", "xes", "ux", "xf", "php", "lat", "draw", "el", "X", "e", "ll", "xy", "xs", "batch", "wx", "px", "ex", "cox", "v", "fx"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int g722_encode_init(AVCodecContext * avctx)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono tracks are allowed.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    c->band[0].scale_factor = 8;\n\n    c->band[1].scale_factor = 2;\n\n    c->prev_samples_pos = 22;\n\n\n\n    if (avctx->trellis) {\n\n        int frontier = 1 << avctx->trellis;\n\n        int max_paths = frontier * FREEZE_INTERVAL;\n\n        int i;\n\n        for (i = 0; i < 2; i++) {\n\n            c->paths[i] = av_mallocz(max_paths * sizeof(**c->paths));\n\n            c->node_buf[i] = av_mallocz(2 * frontier * sizeof(**c->node_buf));\n\n            c->nodep_buf[i] = av_mallocz(2 * frontier * sizeof(**c->nodep_buf));\n\n            if (!c->paths[i] || !c->node_buf[i] || !c->nodep_buf[i]) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (avctx->frame_size) {\n\n        /* validate frame size */\n\n        if (avctx->frame_size & 1 || avctx->frame_size > MAX_FRAME_SIZE) {\n\n            int new_frame_size;\n\n\n\n            if (avctx->frame_size == 1)\n\n                new_frame_size = 2;\n\n            else if (avctx->frame_size > MAX_FRAME_SIZE)\n\n                new_frame_size = MAX_FRAME_SIZE;\n\n            else\n\n                new_frame_size = avctx->frame_size - 1;\n\n\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested frame size is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_frame_size,\n\n                   avctx->frame_size);\n\n            avctx->frame_size = new_frame_size;\n\n        }\n\n    } else {\n\n        /* This is arbitrary. We use 320 because it's 20ms @ 16kHz, which is\n\n           a common packet size for VoIP applications */\n\n        avctx->frame_size = 320;\n\n    }\n\n    avctx->delay = 22;\n\n\n\n    if (avctx->trellis) {\n\n        /* validate trellis */\n\n        if (avctx->trellis < MIN_TRELLIS || avctx->trellis > MAX_TRELLIS) {\n\n            int new_trellis = av_clip(avctx->trellis, MIN_TRELLIS, MAX_TRELLIS);\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested trellis value is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_trellis,\n\n                   avctx->trellis);\n\n            avctx->trellis = new_trellis;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    g722_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 20541, "substitutes": {"avctx": ["avsys", "avekl", "ajcontext", " avconn", "avercp", "aftx", "vrctx", "wavcontext", "avcmp", "wavcmd", "afpkg", "avekt", "avetx", "avectx", "avcontext", "ajmsg", "avetxt", "wavreq", "avecmd", " avtx", "avtx", "averpkg", "aujac", "afctl", " avreq", "afsys", "averreq", "ajjac", "wavcfg", "autx", "averctl", " avcc", "wavctl", "avecp", "avercmd", "ajsys", "ajctx", "navctx", "ajkl", " avmsg", "avcp", " avcmp", "afctx", "avjac", "auctx", "avbj", "wavkl", "ajctl", "averjac", "avepkg", "avectl", " avpkg", "averkt", "navcu", "afcmd", "vrbj", "ajcfg", "avmsg", "savtx", " avcontext", "savctx", " avjac", "averctx", "vrcmp", "avkt", "afcontext", "avconn", "avemsg", "vrcu", "avertx", "savcontext", "avcfg", "averconn", "avreq", "vrtx", "aucontext", "avercfg", "avermsg", "afkt", "aveconn", "ajcp", "aucc", "navcontext", "ajkt", " avctl", "avkl", "averbj", "avercontext", " avbj", " avtxt", "ajpkg", " avcmd", "avecontext", "vrcontext", " avcu", "avcu", "afcp", "autxt", "wavctx", "savcmd", "wavsys", "wavconn", "ajtx", "avpkg", " avcp", "avecc", "ajconn", "avcc", "navcmp", "avejac", "wavtx", "wavpkg", "avecfg", "avctl", "avcmd", "avtxt"], "c": ["ctx", "cp", "ac", "gc", "m", "cr", "comments", "ci", "p", "ca", "o", "bc", "conf", "can", "d", "xc", "tc", "anc", "cache", "sc", "cm", "mc", "cc", "nc", "C", "l", "co", "cl", "etc", "com", "chain", "b", "cs", "lib", "fc", "lc", "config", "enc", "ec", "comm", "t", "ce", "g", "pc", "cd", "dc", "cv", "con", "cam", "a", "abc", "ch", "cu", "conv", "comp", "cf", "rc", "call", "cal", "cmp", "coll", "f", "cont", "cb", "v", "ct"], "ret": ["alt", "Return", "tr", "Ret", "def", "fit", "ext", "rem", "att", "fun", "result", "rt", "flag", "nt", "print", "t", "ft", "res", "mail", "mel", "et", "ref", "re", "resp", "out", "eth", "ll", "rets", "gt", "urn", "elt", "RET", "pas", "back", "mt", "val"], "i": ["m", "me", "list", "ci", "ix", "p", "q", "o", "id", "gl", "si", "multi", "zi", "span", "to", "y", "it", "xi", "ims", "l", "status", "ij", "ti", "mi", "qi", "info", "iu", "chain", "j", "di", "in", "go", "\u0438", "ai", "im", "ki", " ii", "fi", "ui", "phi", "ic", "li", "gi", "key", "uri", "ip", "sim", "cli", "ri", "slice", "ji", "ini", "bi", "ind", "oi", "index", "ii", "x", "pi", "batch", "I", "ami", "ex", "io", "f", "is", "v"], "new_frame_size": ["new_frame_name", "new_window_Size", "new_frame2size", "new_window_SIZE", "new_frame_count", "new_frame_to", "new_frame2number", "new_window_size", "new_window_count", "new_Frame_scale", "new_window_to", "new_frame_scale", "new_Frame_size", "new_window_number", "new_frame_SIZE", "new_frame_Size", "new_frame_number", "new_frame_set", "new_window_len", "new_window_name", "new_Frame_set", "new_frame2count", "new_frame_len"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n\n\n    return lsi_reg_readb(s, addr & 0xff);\n\n}\n", "idx": 20548, "substitutes": {"opaque": ["opaques", "Opaque", "paques", "patile", "oplaque", "obatile", "oposit", "opque", "Opque", "obaque", " oposit", " opatile", "oplatile", " opesc", "paque", "Opatile", " opque", "pque", "obesc", "Opaques", "oplosit", "obosit", "opesc", "opatile", "oplesc", " opaques"], "addr": ["ctx", "ix", "add", "Address", "adr", "data", "sp", "at", "id", "name", "pad", "loc", "ptr", "tag", "to", "src", " address", "offset", "bound", "dh", "address", "tx", "ord", "node", "go", "dr", "act", "pos", "map", "res", "ref", "var", "align", "store", "hash", "coord", "sha", "len", "obj", "arg", "gt", "index", "alloc", "ad"], "size": ["num", "start", "data", "sp", "state", "name", "id", "type", "SIZE", "length", "d", "Size", "n", "offset", "l", "address", "args", "shape", "count", "len", "mem", " len", "index", "h", "ize", " count"], "s": ["js", "gs", "spec", "ls", "q", "p", "sq", "es", "o", "rs", "sb", "n", "ps", "fs", "ds", "b", "c", "ess", "r", "iss", "ts", "j", "ss", "i", "t", "less", "set", "g", "ns", "a", "hs", "sts", "sv", "qs", "h", "se", "os", "S", "als", "is"]}}
{"project": "qemu", "commit_id": "465f2fedd262cbdcbfc92c181660cf85e5029515", "target": 0, "func": "static int cryptodev_builtin_create_cipher_session(\n\n                    CryptoDevBackendBuiltin *builtin,\n\n                    CryptoDevBackendSymSessionInfo *sess_info,\n\n                    Error **errp)\n\n{\n\n    int algo;\n\n    int mode;\n\n    QCryptoCipher *cipher;\n\n    int index;\n\n    CryptoDevBackendBuiltinSession *sess;\n\n\n\n    if (sess_info->op_type != VIRTIO_CRYPTO_SYM_OP_CIPHER) {\n\n        error_setg(errp, \"Unsupported optype :%u\", sess_info->op_type);\n\n        return -1;\n\n    }\n\n\n\n    index = cryptodev_builtin_get_unused_session_index(builtin);\n\n    if (index < 0) {\n\n        error_setg(errp, \"Total number of sessions created exceeds %u\",\n\n                  MAX_NUM_SESSIONS);\n\n        return -1;\n\n    }\n\n\n\n    switch (sess_info->cipher_alg) {\n\n    case VIRTIO_CRYPTO_CIPHER_AES_ECB:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CBC:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CBC;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CTR:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CTR;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_DES_ECB:\n\n        algo = QCRYPTO_CIPHER_ALG_DES_RFB;\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Unsupported cipher alg :%u\",\n\n                   sess_info->cipher_alg);\n\n        return -1;\n\n    }\n\n\n\n    cipher = qcrypto_cipher_new(algo, mode,\n\n                               sess_info->cipher_key,\n\n                               sess_info->key_len,\n\n                               errp);\n\n    if (!cipher) {\n\n        return -1;\n\n    }\n\n\n\n    sess = g_new0(CryptoDevBackendBuiltinSession, 1);\n\n    sess->cipher = cipher;\n\n    sess->direction = sess_info->direction;\n\n    sess->type = sess_info->op_type;\n\n\n\n    builtin->sessions[index] = sess;\n\n\n\n    return index;\n\n}\n", "idx": 20549, "substitutes": {"builtin": ["linkedIn", "Builtins", " builtas", " builtIN", "uiltin", "builtas", " builtins", "buildIn", "linkedIN", "Builtin", "builtIN", "uiltIn", " builtIn", "uiltIN", "buildin", "linkedin", "builtIn", "linkedas", "BuiltIn", "uiltas", "buildins", "builtins"], "sess_info": ["sessetyuser", "sess1no", "semptjhistory", "ssession2info", "sess___init", "sessetyinfo", "sess_fo", "session1no", "ssession_inf", "sempt_inf", "sessjinf", "sist_INFO", "scess___try", "scess___status", "sempt_report", "ssession2fo", "sess_user", "session1info", "sess2init", "sempt_info", "ssession_ready", "session_Info", "sess2Info", "sess_no", "ssession_fo", "sessobjnow", "sengeetyuser", "sess1Info", "sess_Info", "sess_try", "sessjreport", "sessetyhttp", "sess_history", "sessobjinfo", "semptjinf", "senge_now", "session_info", "sess___try", "sess_status", "scess_inf", "sessetyinf", "ssession2inf", "sess___inf", "sess1INFO", "sess_INFO", "sess2no", "session1Info", "sessobjinf", "sess___status", "sengeetyinf", "senge_inf", "ssession_init", "sist_info", "semptjreport", "session_INFO", "sempt_history", "semptjinfo", "scess_try", "ssession_info", "sessjsuccess", "sess2fo", "scess_info", "sessjready", "sess_now", "ssession_success", "sessobjuser", "sessjinfo", "sess_init", "sessetynow", "sess2inf", "session1INFO", "sess2INFO", "scess___inf", "scess_status", "sess___fo", "sist_inf", "sess_success", "sess_inf", "sess_report", "sengeetynow", "sessetyINFO", "sengeetyinfo", "session_no", "ssession2init", "sess_ready", "sessjhistory", "senge_info", "senge_user", "sess_http", "scess___info", "sist_http", "sess___info", "sess1info", "sess2info"], "errp": ["nerp", "derp", "ierpkg", "iterpp", "timerp", "diepo", "excpid", "errg", "timerg", "errpb", "ererps", "ierp", "errping", "confps", "errpr", "usrpb", " errps", "usrpo", "derpid", "derps", "errpid", "errpkg", "confping", "errorping", " errP", "errpo", "diepoint", "derP", "derpkg", "testpp", "ererp", "eorpb", "diep", "errorp", "testP", "ierpb", " errping", "outerP", "usrpoint", "eorpoint", "errP", "diepb", "outerpid", "usrp", "iterping", "errorpe", "eorpo", "timerpa", "excp", "ererg", "errorpid", "confP", "errpp", "excpe", "outerp", "errpe", "testp", " errpp", " errpr", "eorp", "nerpb", "testping", "iterp", " errpid", "excP", "derg", "errorps", "outerpr", "errorP", "derpb", "ererpa", "timerps", "iterP", "derpr", "errpoint", "confp", "nerpkg", "errps", " errpe", "ierps", "derpa", "errpa", "nerps"], "algo": ["ALgorithm", "balgo", "mailgo", "ralvo", "palgo", "alca", "ALgo", "qualga", "unalready", "Alno", "halGO", "mailbo", "halgem", "mailgorithm", "halango", " alno", "halvo", "stalgem", "aladdin", " already", "Almo", "adalgo", "calbo", "stalgorithm", "unalcos", "stalca", "stalGO", "alGO", "Algo", "stalgo", " algor", "unalonna", " alGO", "alga", "halgorithm", "halca", "unaladdin", "palgor", "calgo", " almo", "aliaddin", " alvo", "alango", "palGO", "adalGO", "ralgo", "qualgo", "balko", "already", "balga", "ralga", "algorithm", "ralko", "qualvo", "aligo", "alonna", "palmo", "algor", "calvo", "alicos", "talonna", "alno", "unalvo", "palno", " algorithm", "adalango", "albo", "ALgor", "stalango", "ALGO", "stalvo", "halgo", "algem", "talgo", "alvo", "palgorithm", "unalgorithm", "calready", "alcos", "mailvo", "almo", "alko", "taladdin", "balbo", "talcos", "balgorithm", "adalgem", "calgorithm", "qualko", "unalgo", "AlGO", "alionna", "balvo", "mailca"], "mode": ["stage", "me", "m", "success", "mm", "direction", "depth", "state", "MODE", "mod", "name", "type", "purpose", "distance", "pe", "module", "scale", "dirty", "oe", "offset", "component", "shift", "status", "role", "style", "feature", "kind", "show", "config", "location", "timeout", "version", "format", "method", "size", "network", "error", "message", "mit", "loop", "metadata", "driver", "position", "pose", "device", "language", "md", "mission", "mate", "zero", "display", "Mode", "model", "mid", "mask", "ode", "dim", "sequence", "operator"], "cipher": ["chiper", "coiper", "ciph", " ciph", "coipher", "chip", "chiph", "ciper", " ciper", "cip", " cip", "chipher", "coip", "coiph"], "index": ["min", "height", "connect", "num", "check", "success", "list", "close", "iso", "sort", "alias", "id", "name", "loc", "offset", "init", "capacity", "max", "info", "limit", "lock", "address", "empty", "j", "find", "node", "i", "order", "axis", "timeout", "pos", "loop", "version", "size", "search", "set", "update", "key", "open", "position", "slice", "count", "len", "Index", "instance", "level", "zero", "ind", "row", "context", "x", "fee", "dim", "block"], "sess": [" ssession", "ssession", "ssess", "wvc", " svc", "wession", "wess", "svc", "ssvc", "wsession", " session", "sssession", "session"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n", "idx": 20553, "substitutes": {"entry": ["command", "check", "list", "try", "inner", "end", "add", "ment", "insert", "password", "ace", "def", "field", "enter", "it", "Entry", "ue", "inter", "RY", "result", "escape", "ry", "r", "ence", "item", "query", "nt", "server", "ie", "set", "match", "element", "key", "page", "child", "cue", "ew", "see", "link", "member", "window", "comment", "entity", "event", "instance", "ary", "row", "ent", "e", "office", "import", "record", "obj", "index", "attribute", "se", "next", "pair", "cell"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 20562, "substitutes": {"ahci": ["hcci", "amdi", "ahce", "akhcci", "ohcor", "amci", " ahco", "ehli", "herecci", "ehpi", "ohdi", "ohcci", "ohki", "ahco", "ehdi", "ohci", "ohcia", "ahki", "haci", "hereci", " ahpi", "akhlink", "ahlink", " ahcu", "akhci", "ehco", "akhcu", "achcci", "ahcci", "achlink", "hci", "ahcia", "hadi", "hali", "ohli", "ehcci", "ahcor", "achci", "ehce", "hereki", "ehcia", "ehci", "ahli", " ahlink", "ahdi", "hacor", "akhce", "herecia", "hpi", "hco", "amcci", "ahcu", "achcu", "ehki", "ahpi", "amce", "ehcor", "akhdi", " ahcci"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static int writev_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector qiov;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return command_usage(&writev_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_writev(&qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"writev failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}", "idx": 20576, "substitutes": {"argc": ["argsC", "Argc", "catC", "argsc", "argp", "argcs", "argcount", "argumentp", " argct", "Argp", "argumentlc", "argsv", "argsct", "Argl", "argsl", "aglc", "argumentcs", " argl", "agcs", "catct", " argp", "argct", "argumentc", " argm", "argsm", "argC", "agl", " argcs", "argumentl", " argC", "argumentv", "catm", "catc", "argm", " arglc", "argl", "arglc", "Argcount", "agc", "argumentct", " argcount", "argumentcount"], "argv": ["Argc", "argsc", "argp", "argsf", "argsp", "argumentp", " argb", "tagc", "taglv", "Argp", " argvs", "argsv", " argargs", "agh", "argslv", "tagf", " argf", "argh", "Argf", "tagv", " argp", "argumentc", "agv", "argumentf", "argumentb", "argumentvs", "agb", "argumentv", " argh", " arglv", "argsvs", "argargs", "argb", "agargs", "argf", "argsh", "argumentargs", "Argv", "agc", "arglv", "agp", "argvs"], "t1": ["m2", "T3", "l3", "T01", "l01", "m0", "t01", "p0", "p1", "T2", "l1", "m1", "T1", "p3", " t01", "T0", "t3", "m3", "l2", "p2", " t3", "t0", " t0"], "t2": ["c2", "m2", "T4", "T3", "c1", "c6", " t4", "timetwo", "m0", "t6", "ttwo", " t6", "p0", "p1", "T2", " ttwo", "time1", "Ttwo", "time02", "m4", "m1", "T1", "p3", "time2", "T02", "T0", "t3", "c3", "t4", "T6", "t02", "p2", " t02", " t3", "t0", " t0"], "c": ["ac", "ctx", "cp", "gc", "m", "p", "vc", "o", "z", "bc", "tc", "cache", "n", "nc", "sc", "cc", "y", "C", "l", "co", "b", "cs", "fc", "r", "lc", "cut", "ec", "i", "t", "ce", "k", "g", "u", "unc", "dc", "count", "cur", "con", "color", "off", "code", "abc", "ch", "h", "rc", " C", " count", "cmp", "f", "v", "ct"], "cnt": ["acount", "ncnt", "acnt", "Cnc", "Ccount", "lcount", "ncount", "lcnc", "cnc", " cnc", " ccount", "cnton", "Count", " cct", "cNT", " cNT", "gnt", "CNT", "lcnt", "ncNT", "gNT", "Cnton", "count", "ccount", "gount", "ncnton", "acct", "Cct", "Cnt", "lcNT", " count", "account", "cct", " cnton"], "buf": ["pkg", "cp", "uf", "CB", "data", "font", "v", "np", "nb", "bs", "seq", "bc", "box", "tmp", "ptr", "wb", "cache", "Buffer", "br", "fd", "layout", "BU", "result", "b", "uffy", "buff", "iter", "bt", "cmd", "gz", "rb", "buffer", "txt", "ref", "vec", "pb", "Buff", "window", "out", "uffer", "row", "mem", "h", "queue", "batch", "FB", "err", "alloc", "block", "CV", "cb", "cv"], "offset": ["rot", "orbit", "end", "sp", "transform", "slot", "type", "tmp", "Offset", "info", "address", "org", "origin", "set", "et", "count", "client", "ind", "bf", "tz", "attribute", "op", "f", "command", "frequency", "data", "o", "iso", "padding", "xff", "it", "shift", "prefix", "pointer", "pos", "error", "position", "len", "xy", "oid", "seek", "ff", "reset", "pad", "loc", "length", "image", "to", " offsets", "online", "location", "point", "timeout", "total", "window", "time", "OFF", "eta", "p", "start", "alias", "id", "entry", "value", "layout", "style", "no", "size", "buffer", "ref", "off", "number", "out", "zero", "base", "index", "addr"], "nr_iov": ["nr_iour", "tn_iour", "nrxij", "nr_voice", "nr_ij", "tn_liv", "nb_liv", "nrxiov", "nrxovi", "nb_ovi", "nrMemliv", "tn_iv", "nrxliv", "sr_iov", "nrMemiour", "sr_voice", "sr_ovi", "nr_liv", "nr_iv", "tnMemliv", "nrMemiov", "tnMemiour", "tnMemiv", "tn_iov", "sr_iour", "nb_iov", "nb_ij", "nr_ovi", "nrMemiv", "tnMemiov"], "qiov": ["qiour", "requij", "qvr", " qiev", "qqvoice", "requiov", "eqiour", "qiev", " qij", "quvr", "queryiour", "sqiov", "sqiv", " qiv", "qvoice", "chiov", "eqiov", "qqiov", "eqij", "sqvoice", "qij", "qqiev", "queryvr", "qqiv", "ziu", "quiour", "quiev", "queryiev", "eqiev", "zij", "quiov", "chvr", "chiour", "zovi", "qiv", " qvoice", "requiu", "queryiov", "quovi", "quiu", "qovi", "chiev", " qiour", "requovi", "quij", "qiu", "ziov", "sqiev"], "optind": ["opindex", "verind", "optimPtr", "catIND", "optionindex", " optPtr", "catindex", "Optstart", "verbind", "verindex", "opIND", "OptIND", " optInd", "verIND", "Optind", "optInd", "opind", " optIND", "optimstart", "optIND", "catInd", " optindex", "Optbind", " optstart", "optstart", "optimbind", "optimindex", "optionPtr", "optiminder", "optionInd", "Optindex", "optionind", "optPtr", "optionIND", "optimind", "optindex", "optimIND", "optinder", "optioninder", "optbind", "opInd", " optinder", "catind"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)\n\n{\n\n    int i;\n\n    for (i = 0; i < width; i++) {\n\n        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n    }\n\n}\n", "idx": 20581, "substitutes": {"dst": ["bsts", "dnd", "Dsts", "Drc", " dST", " dbl", " dsrc", " dlt", "pdrc", "Dlt", "jest", "drc", " dust", "DST", "dbr", "bst", "dist", "dest", "dsst", "dust", " dsts", "dast", "jrc", " dnd", "dasrc", "dsust", "Dist", " dist", "daist", "jnd", "dlt", "blt", "pdbl", "dsST", "pdest", " drc", "Dsrc", "dsrc", "Dbr", "jst", "Dnd", " dbr", "pdbr", "darc", "Dst", "dssrc", " dest", "dST", "pdnd", "pdst", "daust", "dbl", "Dbl", "bsrc", "daST", "dsts"], "i": ["json", "multi", "ei", "ims", "chain", "mi", "info", "ski", "\u0438", "uri", "phi", "ip", "iq", "ri", "ini", "ind", "ii", "x", "pi", "yi", "ki", "im", " pi", " bi", "zi", "esi", "it", "qi", "iu", "di", " I", "is", "v", "hi", "m", "me", "si", "xi", "init", "status", "ms", "ai", "ui", "li", " multi", " err", "iri", "batch", "sequence", " ti", "ci", "ix", "p", "id", "span", "y", "ij", "ti", "j", "uli", "t", " ii", "gi", "ic", "cli", "sim", "ji", "e", "bi", "oi", "index", "asi", "I", "ami", "ogi", "ish"]}}
{"project": "FFmpeg", "commit_id": "6fd00e9dd94ac3aecf4fa14ca6fa23c395215ac9", "target": 1, "func": "static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,\n\n                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],\n\n                      GetBitContext *gb)\n\n{\n\n    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;\n\n    int comment_len;\n\n\n\n    skip_bits(gb, 2);  // object_type\n\n\n\n    sampling_index = get_bits(gb, 4);\n\n    if (m4ac->sampling_index != sampling_index)\n\n        av_log(avctx, AV_LOG_WARNING, \"Sample rate index in program config element does not match the sample rate index configured by the container.\\n\");\n\n\n\n    num_front       = get_bits(gb, 4);\n\n    num_side        = get_bits(gb, 4);\n\n    num_back        = get_bits(gb, 4);\n\n    num_lfe         = get_bits(gb, 2);\n\n    num_assoc_data  = get_bits(gb, 3);\n\n    num_cc          = get_bits(gb, 4);\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // mono_mixdown_tag\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // stereo_mixdown_tag\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround\n\n\n\n\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );\n\n    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );\n\n\n\n    skip_bits_long(gb, 4 * num_assoc_data);\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );\n\n\n\n    align_get_bits(gb);\n\n\n\n    /* comment field, first byte is length */\n\n    comment_len = get_bits(gb, 8) * 8;\n\n    if (get_bits_left(gb) < comment_len) {\n\n\n\n\n    skip_bits_long(gb, comment_len);\n\n    return 0;\n", "idx": 20600, "substitutes": {"avctx": ["AVcc", "aftx", " avcontext", " avjac", "avcmp", " avcc", "afcontext", "avecontext", "afjac", "servctx", "AVcmp", "servcontext", "avecmp", "avectx", "avecc", " avcmp", "afctx", "avcontext", "avjac", "avcc", "AVctx", "servtx", "servjac", " avtx", "avtx", "AVcontext"], "m4ac": ["mfourac", " m2am", "m6AC", "sm4acc", "m6am", "m5AC", "mfouraj", "smfouraj", "smfouracc", "m2ac", "m2sac", "m5ac", "m4am", "m256sac", " m4acc", "m256aj", "m4sac", "sm4aj", "m5am", "mfouracc", " m2acc", " m2AC", "m4aj", "m256ac", "m4acc", "smfoursac", "m6acc", "m2acc", "m2aj", "m4AC", "m5acc", " m4AC", "sm4sac", "smfourac", " m4am", " m2ac", "mfoursac", "m2am", "sm4ac", "m2AC", "m256acc", "m6ac"], "new_che_pos": ["new_cheldpos", "new_che2ps", "new_chelpo", "new_eifmos", "new_chetxpos", "new_chetxto", "new_che_mos", "new_che2os", "new_chemldpos", "new_cod_pr", "new_cu_mot", "new_che_ps", "new_che_to", "new_eifPOS", "new_cuxmot", "new_chelds", "new_cheldmos", "new_chelneg", "new_chelpos", "new_cu_pos", "new_cheptloc", "new_cu_addr", "new_codtxrot", "new_che_pat", "new_cheldPOS", "new_chellmos", "new_ei_neg", "new_cheptpo", "new_chexneg", "new_codtxpo", "new_che_loc", "new_che_Pos", "new_chefloc", "new_chexpo", "new_ch_pos", "new_eifpos", "new_chem_po", "new_che_addr", "new_chemldloc", "new_ch_loc", "new_chellpos", "new_che_po", "new_ch_POS", "new_che2pat", "new_che_POS", "new_chem_loc", "new_chexpr", "new_chelmot", "new_ei_POS", "new_chexrot", "new_chemmrot", "new_che_trans", "new_culdto", "new_chemmPOS", "new_chellPOS", "new_che_rot", "new_cheekpos", "new_che_pr", "new_chemmloc", "new_cheldto", "new_che2loc", "new_ch_ds", "new_culdaddr", "new_chem_trans", "new_ei_mos", "new_chetxpr", "new_culdps", "new_chellneg", "new_cod_pos", "new_cheldloc", "new_culdpos", "new_chepttrans", "new_chemldtrans", "new_cheldposition", "new_eifneg", "new_che2ds", "new_cu_position", "new_culdpo", "new_chemmpo", "new_cu_ps", "new_che2position", "new_che_mot", "new_chem_pos", "new_che_os", "new_codtxpos", "new_chefneg", "new_chexpos", "new_cheldaddr", "new_chetxpo", "new_cheekpo", "new_chetxrot", "new_culdposition", "new_chelPos", "new_cheptpos", "new_cheldneg", "new_ch_pat", "new_cuxneg", "new_cod_rot", "new_che_position", "new_chefrot", "new_che_ds", "new_chemmpos", "new_cheldpo", "new_chefPOS", "new_chexmot", "new_codtxpr", "new_ch_Pos", "new_cheldps", "new_ei_pos", "new_chefpos", "new_chetxaddr", "new_ch_rot", "new_cuxpos", "new_cuxpo", "new_che_neg", "new_che2Pos", "new_cu_po", "new_cod_po", "new_cu_to", "new_ch_os", "new_cu_neg", "new_chemmpr", "new_che2pos", "new_chemldpo", "new_cheekto", "new_chefmos", "new_cheekaddr", "new_cheldtrans"], "gb": ["ctx", "cfg", "cp", "gs", "gc", "gam", "ogg", "json", "eg", "gin", "bb", "eb", "erb", "nb", "bs", "hog", "yg", "gg", "gm", "sb", "git", "tg", "gd", "wb", "vm", "Gb", "py", "bytes", "google", "gpu", "GB", "gnu", "raw", "html", "bt", "gh", "img", "args", "gif", "gz", "kb", "db", "rb", "g", "bg", "vg", "jpg", "goo", "ruby", "pb", "csv", "mb", "bf", "gt", "xy", "gem", "rg", "sg", "sys", "fb", "pg", "bsp", "wm", "hub", "cb", "cv"], "num_front": ["num___aft", " num_left", "numllfd", "num___left", "origllface", "num_fd", "num___fr", "num_face", "orig_front", "num_fore", "number_back", "num___fd", "num88side", "number_side", "num___front", "num_left", "num88front", "num88back", "num_aft", " num_aft", "origllfr", "num___back", "orig_fd", "num___face", "orig_fr", "origllfd", "number_front", "number_fore", "numllfront", "num_fr", "origllfront", "numllface", "numllfr", "orig_face", "num88fore"], "num_side": ["num67side", "num88below", "num_below", "num_small", "nb_bottom", "num__side", "num67below", "nb_side", "dev_below", "nb_back", "num__Side", "dev_small", "dev88back", "num67back", "dev_side", "num_Side", "num88small", "num88side", "Num_Side", "num_bottom", "num88back", "num_main", "dev_back", "nb_main", "num__back", "Num_back", "dev88below", "num67small", "num__below", "Num_below", "dev88small", "Num_side", "dev88side"], "num_back": ["num42backer", "num64forward", "num__front", "NUM_front", "num0place", "num42place", "num64backer", "NUM_back", "multi64backer", " num_bottom", "num___Back", "num42forward", "multi64back", "num64back", "NUM_load", "num_backer", "NUM_Back", "num64place", "num_Back", "multi_back", "num_place", "num0forward", "num68bottom", "num___load", "num_forward", "num___front", "num_bottom", "num__BACK", "num_BACK", "num68back", "num68front", "NUM___back", " num_BACK", "NUM___front", "num___back", "num0backer", "multi_forward", "num68BACK", "num__back", "num_load", "num0back", "NUM___load", "multi_backer", "num__bottom", "NUM___Back", "multi64forward", "multi_place", "multi64place", "num42back"], "num_lfe": ["num_alfee", "num_ffee", "num_lifes", "num_olfee", "num_lifee", "num_lved", "num_life", "num_olfE", "num_lfes", "num_alfE", "num_ffes", "num_lfee", "num_lva", "num_alfe", "num_lfed", "num_lfa", "num_lifE", "num_lve", "num_olfes", "num_lfE", "num_alfes", "num_ffed", "num_cfed", "num_ffE", "num_olfe", "num_lves", "num_cfe", "num_ffa", "num_cfes", "num_cfa", "num_ffe"], "num_assoc_data": ["num_assoc_DATA", "num_assoc2count", "num_assoc_len", "num_assoc_count", "num_assOC_count", "num_associngdata", "num_associngDATA", "num_assocmata", "num_assoc2len", "num_assocmsize", "num_assign_size", "num_assign_key", "num_assoc2DATA", "num_assoc_key", "num_assign_DATA", "num_assoc2data", "num_associngkey", "num_assOC_size", "num_assocmdata", "num_assOC_len", "num_assOC_data", "num_assign_data", "num_assoc2size", "num_assoc2key", "num_assign_ata", "num_assoc_ata", "num_assoc_size"], "num_cc": [" num_fc", "num_ca", "num_cs", "num67cf", "num67cc", " num_ca", "num_cf", "num_CC", "num67cca", "num67fc", " num_cf", "num_fc", " num_CC", " num_cca", " num_cs", "num_cca"], "sampling_index": ["sampler_offset", "sampling___no", "sampling___index", "sampling2link", "samison_num", "samplingetypoint", "sampler_index", "sampling___offset", "sampling_point", "sampler_link", "samplingingoffset", "sampling_ind", "samplingingindex", "samisonetynum", "samplingingind", "samison_offset", "sampping_index", "sampling2ind", "sampling_no", "sampling2data", "sampping_id", "sampling2index", "samisonetyoffset", "samplingingno", "sampling_valid", "sampler_ind", "samisonetypoint", "samisonetyindex", "sampler_no", "samplingetyoffset", "samison_point", "sampling_data", "sampling___ind", "samplingetyindex", "sampling_offset", "sampling_link", "sampling_id", "sampling_num", "samplingetynum", "sampping_ind", "sampping_valid", "sampler_data", "samison_index"], "comment_len": ["slot_pos", "commentationseq", "commentationset", "slotationlen", "comment6len", "comment6seq", "comment6set", "slot_seq", "slot_set", "slotationpos", "comment_seq", "slot_len", "comment_set", "commentationlen", "commentationpos", "slotationset", "comment_pos", "slotationseq", "comment6pos"]}}
{"project": "FFmpeg", "commit_id": "5257743aee0c3982f0079e6553aabc6aa39401d2", "target": 1, "func": "static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,\n\n                               int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    WSSndContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n\n\n    int in_size, out_size, ret;\n\n    int sample = 128;\n\n    uint8_t *samples;\n\n    uint8_t *samples_end;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    out_size = AV_RL16(&buf[0]);\n\n    in_size  = AV_RL16(&buf[2]);\n\n    buf += 4;\n\n\n\n    if (in_size > buf_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame data is larger than input buffer\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* get output buffer */\n\n    s->frame.nb_samples = out_size;\n\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples     = s->frame.data[0];\n\n    samples_end = samples + out_size;\n\n\n\n    if (in_size == out_size) {\n\n        memcpy(samples, buf, out_size);\n\n        *got_frame_ptr   = 1;\n\n        *(AVFrame *)data = s->frame;\n\n        return buf_size;\n\n    }\n\n\n\n    while (samples < samples_end && buf - avpkt->data < buf_size) {\n\n        int code, smp, size;\n\n        uint8_t count;\n\n        code  = *buf >> 6;\n\n        count = *buf & 0x3F;\n\n        buf++;\n\n\n\n        /* make sure we don't write past the output buffer */\n\n        switch (code) {\n\n        case 0:  smp = 4;                              break;\n\n        case 1:  smp = 2;                              break;\n\n        case 2:  smp = (count & 0x20) ? 1 : count + 1; break;\n\n        default: smp = count + 1;                      break;\n\n        }\n\n        if (samples_end - samples < smp)\n\n            break;\n\n\n\n        /* make sure we don't read past the input buffer */\n\n        size = ((code == 2 && (count & 0x20)) || code == 3) ? 0 : count + 1;\n\n        if ((buf - avpkt->data) + size > buf_size)\n\n            break;\n\n\n\n        switch (code) {\n\n        case 0: /* ADPCM 2-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ( code       & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 2) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 4) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample +=  (code >> 6)        - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 1: /* ADPCM 4-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ws_adpcm_4bit[code & 0xF];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ws_adpcm_4bit[code >> 4];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 2: /* no compression */\n\n            if (count & 0x20) { /* big delta */\n\n                int8_t t;\n\n                t = count;\n\n                t <<= 3;\n\n                sample += t >> 3;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            } else { /* copy */\n\n                memcpy(samples, buf, smp);\n\n                samples += smp;\n\n                buf     += smp;\n\n                sample = buf[-1];\n\n            }\n\n            break;\n\n        default: /* run */\n\n            memset(samples, sample, smp);\n\n            samples += smp;\n\n        }\n\n    }\n\n\n\n    s->frame.nb_samples = samples - s->frame.data[0];\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = s->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20606, "substitutes": {"avctx": ["avetc", "afcmp", " avkl", "afctl", "ajcontext", " avctl", "aftx", "avkl", "abctx", " avcontext", " avjac", "wavcontext", "avcmp", "averctx", "avecv", "averctl", "abtx", "afcontext", "afpkg", "awcontext", "avecontext", "afjac", "wavctx", "abcontext", "awctx", "awcmp", "ajctx", "afkl", "avecmp", "avetx", "ajtx", "ajkl", "avectx", "avpkg", "abcmp", "afctx", " avcmp", "avcontext", "avcv", "avjac", " avcv", "avejac", "wavtx", "wavpkg", "aftc", "averjac", "avctl", "avtc", "afcv", "awtx", " avtx", "avectl", "avepkg", "avertc", "avtx", " avpkg"], "data": ["file", "name", "type", "bin", "video", "extra", "format", "output", "resp", "a", "pieces", "DATA", "package", "block", "f", "Data", "action", "o", "d", "padding", "cache", "content", "self", " DATA", "doc", "map", "area", "message", "frame", "device", "read", "v", "meta", "this", "m", "done", "bits", "pad", "image", "length", "mu", "to", "offset", "text", "history", "raw", "empty", "results", "window", "next", "options", "str", "batch", "rel", "sequence", "dat", "p", "input", "body", "id", "flags", "w", "def", "value", "bytes", "result", "values", "da", "buffer", "multiple", "ata", "response"], "got_frame_ptr": ["got_frames__loc", "got_frame_loc", "got_frames_pointer", "got_frames__pos", "got_frame__loc", "got_frames__ptr", "got_frame_obj", "got_frames__pointer", "got_window2Ptr", "got_frameingpointer", "got_frameingpos", "got_window_ptr", "got_frames_ptr", "got_frame2Ptr", "got_frame2pos", "got_frame__ptr", "got_frame_Ptr", "got_frame__pointer", "got_frame2loc", "got_frame_pos", "got_frames_loc", "got_window2ptr", "got_frameingloc", "got_window_pointer", "got_frame2ptr", "got_frame_pointer", "got_window2pointer", "got_frames_pos", "got_window2obj", "got_window_Ptr", "got_window_obj", "got_frame2pointer", "got_frameingptr", "got_frame2obj", "got_frame__pos"], "avpkt": ["avevpkg", "avrespkt", "avdmit", "avPmit", "wavppacket", "avjpkat", "avtacket", "avvpck", " avpkat", " avpmit", "avppacket", "avdkat", "avppnt", "avrespacket", " avPkat", "avopacket", "avopkt", "avcpkt", "avdkt", " avpacket", "avopck", "avppmit", "avPkt", "avPkat", "avckg", "avpmit", " avpct", "wavppnt", "avpnt", "avPacket", "avtkt", "avevpck", "avepck", "wavpnt", "avcpacket", "avcpcht", " avPacket", "avPct", "avpkat", " avPct", "avepkg", "avcacket", "avcck", "wavpkt", "avvpkg", "avtct", "avopkg", "avtmit", "avppcht", "avjpacket", "avckt", "avppct", " avPmit", "avpacket", "avevpkt", "avvpkt", "avcpnt", "avjpkt", "wavpcht", "avepacket", "avpcht", "avrespnt", "avpct", "wavppcht", "avevpacket", "avepkt", "avppkt", "avdacket", "wavppkt", "avpck", "avpkg", "avrespcht", " avPkt", "wavpacket", "avvpacket", "avjpmit"], "s": ["ctx", "js", "gs", "m", "spec", "ls", "p", "sq", "es", "full", "rs", "bs", "w", "d", "n", "ps", "fs", "ims", "ds", "l", "b", "ms", "c", "cs", "ess", "r", "ts", "j", "ss", "i", "stats", "less", "g", "ns", "ins", "its", "hs", "a", "sts", "conv", "sv", "qs", "h", "ats", "sys", "os", "S", "als", "ops", "f", "is", "v"], "buf": ["pkg", "bs", "tmp", "prop", "aw", "good", "gen", "order", "rb", "foo", "vec", "pb", "cur", "arr", "queue", "keep", "block", "cb", "cv", "ctx", "uf", "bar", "box", "xff", "wb", "bp", "cache", "shift", "BU", "b", "doc", "buff", "iter", "img", "pos", "map", "Buff", "desc", "len", "emb", "ctr", "fb", "cont", "v", "ff", "num", "seq", "port", "ptr", "mu", "br", "rw", "lim", "offset", "text", "limit", "proc", "bl", "msg", "txt", "window", "next", "batch", "err", "alloc", "cap", "progress", "font", "bc", "nm", "Buffer", "bytes", "tx", "cmd", "db", "buffer", "ref", "off", "late", "mem", "pg"], "in_size": [" out___count", "in___size", " out_device", "in5scale", "out_scale", "in_global", "in___count", "in67scale", "in67size", "out_SIZE", "in___device", "in_status", "in_Size", "out_Size", " out_count", "out_global", "in___Size", "inlayscore", "in_device", "in_count", "in_SIZE", "inlaysize", "in_score", "inlaySize", " out___Size", " out___size", "in5Size", "in67Size", "in5size", "out_score", "in_scale", "inlayglobal", " out_Size", "in5status", "in67status", "out_status", " out___device"], "out_size": ["outjwidth", " out_width", "out_SIZE", "oablelength", "outptSize", "outablelength", "out_length", "outablenum", "outablescore", " out_Size", "out_format", "o_num", "o_size", "out_num", "oablenum", "in_SIZE", "outMemstore", "outptstore", " out_length", " out_format", "out_score", "out_name", "outJsize", "outjlength", "in_Size", "outMemdepth", "in_store", "outablesize", "outjsize", "out_depth", "outJSIZE", "o_length", "oablescore", " out_name", "in_depth", "outMemsize", "out_Size", "out_store", "outJformat", "outptsize", "out_width", " out_SIZE", "oablesize", "o_score", "outptdepth", "outMemSize"], "ret": ["reset", "vt", "alt", "tr", "Ret", "tmp", "red", "it", "rem", "status", "result", "fun", "got", "rt", "tail", "empty", "j", "nt", "deg", "flag", "det", "res", "reg", "repl", "buffer", "txt", "ref", "rev", "re", "bad", "resp", "len", "out", "zero", "mem", "rets", "gt", "arr", "err", "elt", "RET", "back", "mt", "f", "cont", "val"], "samples": ["sonents", "sounds", "Sores", "jsamples", "nsonents", "slamps", " samp", "timesamps", "jsamp", "nsamps", "sources", "ssamps", "Sources", "sores", "Sonents", "ssores", "nsounds", " sores", "Samp", "Sample", "tsamples", "samps", " sample", "sides", "tsources", " samps", " sources", "Samps", "samp", "slamples", "sample", "Sounds", "timesonents", "jsamps", "timesounds", "tsample", "ssample", "jsample", " sides", "nsamples", "Sides", "slamp", "timesamples", "ssamples", "tsamps", "Samples", "slides"], "samples_end": ["samp_start", "samples_ended", "samp_last", "samps_start", "samples_to", "samples_ending", "sairs_len", "samps_end", "samples_last", "sairs_ending", "samp_ends", "samp_ended", "samps_to", "samples_len", "samp_end", "sairs_end", "samples_ends", "samples_start"], "code": ["action", "command", "close", "check", "num", "ose", "id", "name", "type", "length", "cache", "nc", "magic", "cc", "test", "cod", "component", "status", "counter", "chain", "text", "mode", "line", "c", "cmd", "ec", "go", "ce", "ie", "cycle", "cond", "frame", "error", "cd", "key", "second", "age", "note", "event", "change", "ch", "comp", "time", "index", "rc", "call", "ode", "cmp", "sequence", "coe", "ack", "cb", "Code", "ct"], "smp": ["arespsc", "swp", "fspsc", "spm", "stscp", "somp", "SMP", "aresmp", "insclip", "ccmp", " samp", " sMP", "gsamp", "gsomp", " spsc", "camp", "myscmp", "tscmp", "arescmp", "gsmp", "tspm", "myscp", "sclip", "ccp", "scmp", "inscp", "stscmp", "tsmp", "stsmp", "Samp", "Scmp", "scp", "atscmp", " scp", " scmp", " swp", "inscmp", " sclip", "mysclip", "insmp", "atsamp", "samp", "sMP", "atsmp", "fswp", "gsMP", "Smp", " somp", "Somp", "Scp", "atspm", "tscp", "fsmp", "spsc", "mysmp", " spm", "stspm", "cmp", "areswp", "Spm", "fscmp"], "size": ["south", "get", "sn", "sent", "end", "start", "ose", "body", "sp", "z", "name", "type", "SIZE", "length", "small", "port", "unit", "range", "cache", "Size", "n", "bytes", "offset", "max", "c", "send", "empty", "speed", "sum", "pos", "error", "message", "sample", "buffer", "total", "read", "window", "len", "mem", "time", "index", "ize", "fee", "dim", "space", "cmp", "use", "zone"], "count": ["current", "check", "list", "num", "try", "add", "z", "id", "type", "conf", "length", "scroll", "cache", "n", "nc", "cc", "force", "test", "amount", " cc", "counter", "result", "max", "info", "c", " counts", "Count", "found", "doc", "core", "flag", "nt", "cmd", "sum", "cond", "match", "first", "key", "second", "total", "hash", "comment", "len", "number", "now", "all", "base", "last", "ch", "time", "index", "call", "err", "cmp", "ount", "codes", "cont", "more", "rc"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                     const uint8_t *src_in[4], int srcW, int xInc,\n\n                                     const int16_t *hLumFilter,\n\n                                     const int16_t *hLumFilterPos, int hLumFilterSize,\n\n                                     uint8_t *formatConvBuffer,\n\n                                     uint32_t *pal, int isAlpha)\n\n{\n\n    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;\n\n    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;\n\n    const uint8_t *src = src_in[isAlpha ? 3 : 0];\n\n\n\n    if (toYV12) {\n\n        toYV12(formatConvBuffer, src, srcW, pal);\n\n        src= formatConvBuffer;\n\n    } else if (c->readLumPlanar && !isAlpha) {\n\n        c->readLumPlanar(formatConvBuffer, src_in, srcW);\n\n        src = formatConvBuffer;\n\n    }\n\n\n\n    if (!c->hyscale_fast) {\n\n        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);\n\n    }\n\n\n\n    if (convertRange)\n\n        convertRange(dst, dstWidth);\n\n}\n", "idx": 20613, "substitutes": {"c": ["ctx", "cp", "ac", "gc", "cr", "ci", "p", "ca", "cn", "bc", "conf", "w", "d", "can", "tc", "cache", "sc", "cm", "nc", "cc", "mc", "C", "l", "co", "etc", "com", "chain", "b", "cs", "fc", "lc", "config", "enc", "ec", "t", "ce", "k", "cd", "pc", "unc", "dc", "cur", "cv", "con", "cam", "e", "abc", "cu", "comp", "h", "cf", "cal", "call", "rc", "cmp", "coll", "f", "cont", "v", "ct"], "dst": ["dnd", "bdst", "dedsc", "daint", " dint", "drend", "tdest", "Dest", "dect", "dent", "dct", "dstd", "bdct", "dint", " dnt", "debugsts", "Dstd", "dest", "Dct", "debugst", " dsts", "dast", "darend", " dnd", "debugint", "dedst", "bdest", "deest", "dedest", "dsc", "bdnd", "Dnt", "Dnd", "Dsc", " drend", "Dst", " dest", " dct", "tdsc", "tdst", "dnt", "debugrend", "tdstd", "dasts", "dedstd", "dsts"], "dstWidth": ["destHeight", "ddestWidth", "DestHeight", " destWidth", "dstEnd", "DestWidth", " dstW", "dstrX", "dmtHeight", "dSTHeight", "dstW", "destWrite", "destEnd", " dstEnd", "dstX", "DstWrite", "dstWrite", "dvX", "ddestW", "dstrW", " dstX", " dstRender", "dstHeight", "dvW", " dmtHeight", "dblWidth", "dstRender", "DestWrite", "dostHeight", "dmtWidth", " destW", "DstW", "dvHeight", "dSTWrite", "DstHeight", "destX", "dblW", " dmtW", "ddestRender", "destW", "dvEnd", "destWidth", " destHeight", "dSTW", " dmtWidth", "DstWidth", "dmtRender", "dblEnd", "DestW", "dvRender", "dblHeight", " destEnd", "dostWrite", " destX", " dmtRender", "dostWidth", "dmtW", "ddestHeight", "dostW", "dstrHeight", "dstrWidth", "dvWidth", "dSTWidth", " dstHeight"], "src_in": ["rc_inn", " src_out", "srcPout", "src_inn", "src_int", "srcPinn", "srcPin", "rc_ins", "rc_IN", " src_ind", "rc_out", "src_IN", "srcPins", " src_int", "src_out", "src_ind", "rc_in", "src_ins"], "srcW": ["rcR", "sortW", " srcV", "stR", "rcM", "sortV", "stW", "srcWidth", "srcNW", "addrV", "rcL", "addrW", "rcWR", "srV", "rcW", " srcL", "srcL", "rcNW", "rcWidth", "srWidth", "sortWR", "srcR", " srcM", "srW", " srcWidth", "stM", " srcR", " srcw", "addrL", "srNW", "stw", "sortL", "addrWidth", "srcWR", "srcV", " srcWR", "rcw", " srcNW", "rcV", "srcM", "srcw"], "xInc": ["checkInc", "exInc", "rxIns", "xinc", "exINC", "rxIncre", "checkinc", "checkIncre", " xINC", "checkINC", "xIncre", " xIns", "exIncre", "xIns", "xINC", "exIns", "rxinc", " xinc", "rxINC", " xIncre", "rxInc"], "hLumFilter": ["hHumpStream", "hLUMStream", "hLamFilter", "hHumpFilter", "hLulApply", "hLumiFilter", "hHumSort", "hLumiApply", "hHumProfile", "hLumStream", "hLUMFilter", "hLumApply", "hLamProfile", "hLumSort", "hLulSort", "hHumpSort", "hHumpProfile", "hLumProfile", "hLumpSort", "hLumDef", "hLUMSort", "hLamSort", "hLUMProfile", "hLumiSort", "hLamApply", "hLulDef", "hHumStream", "hLamStream", "hLumpStream", "hLumiDef", "hLumpProfile", "hLamDef", "hLulFilter", "hHumFilter", "hLumpFilter"], "hLumFilterPos": ["hLamFilterSize", "hLumSourcePos", "hLamFilterPOS", "hLamHandlerOff", "hLueFormatPOS", "hLumFilterOff", "hLueFormatSize", "hLumBufferPOS", "hLumFormatSize", "hLamFilterPos", "hLueFilterPos", "hLumSortSize", "hLumFilterPOS", "hLumFormatPos", "hLumHandlerPOS", "hLumHandlerSize", "hLumFormatPOS", "hLumSourceSize", "hLamHandlerPOS", "hLumSortPos", "hLumSortPOS", "hLumSourceOff", "hLueFilterPOS", "hLumHandlerPos", "hLumSortOff", "hLamHandlerPos", "hLumBufferPos", "hLamFilterOff", "hLumSourcePOS", "hLamHandlerSize", "hLueFilterSize", "hLumBufferSize", "hLumHandlerOff", "hLueFormatPos"], "hLumFilterSize": ["hLumBufferStyle", "hLangBufferSize", "hLumFilterSIZE", "hLumMaskStyle", "hLumpFilterLen", "hLumMaskSize", "hLumMaskLen", "hLumOutputStyle", "hLumpTextureLen", "hLangBufferSpec", "hLumFilterSpec", "hLangFilterSpec", "hLumBufferSpec", "hLangFilterSize", "hLumBufferSIZE", "hLumOutputSize", "hLumpFilterSIZE", "hLumTexturePos", "hLangFilterStyle", "hLumMaskSIZE", "hLumFilterStyle", "hLumBufferLen", "hLumpTextureSIZE", "hLumTextureSize", "hLumTextureSIZE", "hLumMaskPos", "hLumFilterLen", "hLumOutputLen", "hLangFilterLen", "hLumOutputSpec", "hLumpTexturePos", "hLumBufferPos", "hLumpFilterPos", "hLumMaskSpec", "hLumBufferSize", "hLangBufferStyle", "hLumTextureLen", "hLumpTextureSize", "hLumpFilterSize", "hLangBufferLen"], "formatConvBuffer": ["formatconvBytes", "formatConvecTable", "formatConvertArray", "formatconvtBuffer", "formatEnvBuff", "formatConvtCache", "formatConnvBuilder", "formatConvBytes", "formatconVBuff", "formatconVBuffer", "formatConvecLength", "formatEnvBuilder", "formatconvtLength", "formatconvtCache", "formatCovertArray", "formatConVBytes", "formatconvLength", "formatConconvBuffer", "formatconvCache", "formatEnnvBuilder", "formatconvtBuff", "formatConvecBuffer", "formatConnvBuffer", "formatConvBuff", "formatCovBuffer", "formatconvtTable", "formatconvtBlock", "formatconvBuff", "formatConconvBlock", "formatEnvBuffer", "formatConVBuffer", "formatConvBuilder", "formatCovertTable", "formatConconvBuff", "formatCovTable", "formatconVBytes", "formatConconvCache", "formatCovBuff", "formatConvtBytes", "formatConnvBuff", "formatConvArray", "formatConvtLength", "formatEnnvBuff", "formatConvertBuff", "formatConvertTable", "formatConvBlock", "formatConconvTable", "formatConconvLength", "formatConconvBuilder", "formatCovertBuffer", "formatConconvArray", "formatCovertBuff", "formatConvtTable", "formatCovArray", "formatConvtBuilder", "formatConvecBlock", "formatConvertBuffer", "formatconvTable", "formatconvBlock", "formatConvTable", "formatConvertBytes", "formatConvCache", "formatConvtArray", "formatConvertCache", "formatconvBuffer", "formatConvtBuff", "formatEnnvBuffer", "formatConvtBuffer", "formatConvLength", "formatConvtBlock", "formatConVBuff"], "pal": ["pid", "pack", "alpha", "ass", "font", "p", "phil", "cil", "qt", "conf", " PAL", "mat", "ph", "pl", "style", "Pal", "phal", "attr", "what", "pat", "fac", "pol", "ul", "pha", "al", "bal", "olor", "pill", "color", "sav", "pac", "el", "alph", "local", "cal", "qual", "sal", "pres", "bat", "pas", "isal", "qq", "val"], "isAlpha": ["Isalpha", "isAlias", "hasHA", "ISHA", "ishMass", " isMeta", "isalMeta", "isMeta", "ISalpha", "needsAlias", " isMass", "ISAlpha", "isalpha", "needsHA", "hasMeta", "isaAlpha", " isPhase", "ishalpha", "isHA", "bisAlias", "setalpha", "hasAlpha", "bisalpha", " isalpha", "isPhase", "isaPhase", "setHA", "ishAlpha", "isMass", "isalHA", "isaalpha", "IsAlpha", "setAlpha", " isAlias", "IsPhase", "ISMass", "needsalpha", "ishHA", "IsHA", "bisHA", "bisAlpha", " isHA", "isalAlpha", "needsAlpha"], "toYV12": ["toYAVS32", "toYAVSail", "toXP24", "toYV2", "toYV8", "toIEUV12", "toXV24", "toYVS32", "toYP24", "toYPail", "toXP8", "toYv12", "toIEV8", "toIEV12", "toXV8", "toYVM8", "toYV32", "toXP12", "toIEV2", "toYAV12", "toYAV2", "toXP2", "toYVM2", "toYVM24", "toYVS12", "toYVM12", "toXV12", "toYv32", "toIEUV2", "toYP2", "toYV24", "toYv24", "toYAV32", "toYUV32", "toYAVS2", "toYP12", "toYUVail", "toYAVS12", "toYVSail", "toIEUV32", "toYv8", "toYUV8", "toYP32", "toYv2", "toXV2", "toYVS2", "toYUV12", "toIEUV8", "toYAVail", "toIEV32", "toYVail", "toYP8", "toYUV2"], "convertRange": ["covertRegion", "conlateRow", "covertRow", "coforceRow", "convertingRegion", "convertsRange", "coforceRange", "converrange", "convertsRate", "conversionrange", "conversionList", "coforceRegion", "convertedRange", "conversionRate", "conforcerange", "convertRule", "covertRange", "coversionRange", "convertingRange", "conversionRange", "convertList", "coversionList", "converRange", "convertingRule", "conlateRule", "conforceRegion", "conlateRegion", "conforceRule", "convertsrange", "convertRegion", "convertedList", "coforceRule", "conlateRange", "conforceRange", "conforceRow", "covertRate", "convertrange", "coversionrange", "coversionRate", "covertrange", "convertRow", "convertingRow", "convertRate", "conforceList", "converRate", "convertedrange", "covertRule", "covertList"], "src": ["pkg", "inst", "sn", "sl", "inner", "sq", "ssl", "input", "rs", "impl", "via", "loc", "supp", "tmp", "ptr", "sb", "syn", "sc", "iv", "dest", "ser", "attr", "lr", "s", "proc", "r", "raw", "buff", "config", "img", "spr", "buffer", "sub", "vr", "cur", "ins", "obj", "hl", "source", "ctr", "conv", "sr", "sys", "usr", "rl", "addr", "urg", "sur", "fp", "st", "rc"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */\n\n                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n", "idx": 20617, "substitutes": {"av_flatten": ["av_multen", "av_clen", "av__flatten", "av_flac", "av__flen", "av_fatten", "av_multenn", "av_multac", "av__fatten", "av__fac", "av_fac", "av_clenn", "av_fenn", "av_flenn", "av_flen", "av__fen", "av_clac", "av__fenn", "av_clatten", "av__flenn", "av__flac", "av_multatten", "av_fen"], "pix": ["Pond", "vpix", " piv", " pitch", "vpixels", "cpix", "Pfix", "ppfx", "PIX", "paiv", "cpIX", "ppix", "Pix", "ppixels", "pIX", "paitch", "pond", "Pox", "paix", "cpixels", "Px", " pfix", "padd", "pox", "Pitch", "pct", " pfx", "npct", "Pct", " pond", "vpip", "pitch", " pox", "ppx", "pfx", "pip", "pfix", "Pixels", "ipfx", "ipIX", "pixels", "npox", "cpip", "npadd", "npfix", " pct", "npix", "npixels", "piv", "vpIX", " pip", " pixels", "cpx", "paixels", " px", "ppIX", "Piv", "Padd", "px", " padd", "ppond", "ipix", " pIX"], "xstride": ["ystrride", "xstringimate", "xstriend", "xdrride", "ystid", "xslided", "xcollid", "ystrend", "xstriime", "xstrend", "ystrime", "xStride", "xSTRided", "xstringange", "ystrange", "xstrest", "xstringide", "xdrend", "ystides", "xSTRides", "xdivides", "xslide", "ystrided", "xstrride", "xdivride", "ySTRided", "ystrides", "ystide", "xslride", "xcollide", "xSTRest", "xstrime", "xSTRange", "ySTRimate", "xstrimate", "xcollride", "xstide", "xstringides", "xslides", "xdride", "xdivide", "ystrest", "xstringride", "xdrime", "xscoperide", "ySTRend", "ySTRide", "xdivest", "ySTRime", "xSTRide", "xstriide", "ystrid", "xscopeide", "ySTRange", "xstringest", "xStrides", "xslid", "ySTRest", "ystrimate", "xstid", "xstrides", "xscopeange", "xstriride", "xSTRend", "xstides", "xstrange", "xSTRimate", "xSTRride", "xstrided", "xStrride", "xscopeimate", "xcollides", "xstrid", "ySTRride", "xSTRime", "ySTRides", "xStrided"], "ystride": ["xyStrider", "ydivine", "ystrride", "xstrIDE", "yStride", "ylenider", "ybrride", "xSTRides", "ystatuside", "xstrides", "ydivride", "yglride", "ybrides", "yStrride", "ySTRider", "yStrider", "xstrride", "xSTRale", "xSTRider", "xystride", "ystrides", "ystatusride", "yglIDE", "ybride", "xyStrine", "ySTRale", "xystrider", "ylenide", "ySTRide", "xystrride", "xystrine", "xSTRIDE", "xSTRride", "ystatusIDE", "xstrider", "ySTRIDE", "yglide", "xSTRide", "ystrIDE", "ybrider", "yglale", "ylenides", "ySTRride", "ystatusale", "ystrine", "ystrider", "yStrine", "xstrale", "ylenride", "xyStrride", "ySTRine", "ydivider", "xyStride", "ySTRides", "ystrale", "ydivide"], "alpha": ["ac", "ta", "hi", "phas", "A", "ra", "ca", "inc", "alias", " gamma", "p", "HA", "si", "scale", "it", "fa", "asc", "acl", "xa", "la", "ar", "area", "ma", "phi", "pha", "al", "sha", "a", "upper", "ati", "alph", "au", "appa", "angle", "lambda", "title", "h", "pi", "ia", "rc", "Alpha"], "beta": ["ta", "gam", "dev", "frequency", "te", "ca", "alias", "p", "bc", "BA", "ba", "tc", "mu", "scale", "bis", "blue", "lie", "b", "Beta", "boost", "normal", "t", "prime", "u", "phi", "pha", "igma", "late", "bet", "bi", "a", "e", "base", "lambda", "binary", "fine", "fee", "\u03b2", "coe", "term", "v", "Alpha"], "tc0": ["qt1", " tc00", " tc6", "pcands", "tc00", "pc00", "qt6", "TCands", " tcands", "pc1", "TC6", "TC00", "tc1", "pc0", "tcands", " tc1", "qt0", "TC0", "TC1", "tc6"], "i": ["hi", "m", "me", "this", "try", "ci", "ix", "p", "us", "o", "id", "ex", "name", "si", "zi", "multi", "it", "init", "l", "xi", "status", "ij", "ti", "mi", "ms", "chain", "iu", "c", "r", "j", "di", "in", "\u0438", "ai", "t", "im", "print", "ie", "ki", "g", "ui", "gi", "li", "ip", "sim", "ri", "ini", "bi", "ind", "ico", "index", "ii", "x", "pi", "I", "io", "is", "v"], "d": ["m", "der", "dir", "done", "diff", "dat", "p", "del", "add", "mod", "dx", "debug", "pd", "n", "den", "dt", "fd", "dra", "dj", "ds", "l", "c", "r", "du", "ord", "j", "di", "da", "dr", "t", "dm", "g", "dl", "cd", "nd", "did", "dd", "dc", "de", "dy", "md", "draw", "out", "ind", "D", "bd", "days", "dim", "ad", "dig", "f", "v"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "int ff_mpeg4_decode_picture_header(MpegEncContext * s, GetBitContext *gb)\n\n{\n\n    int startcode, v;\n\n\n\n    /* search next start code */\n\n    align_get_bits(gb);\n\n    startcode = 0xff;\n\n    for(;;) {\n\n        v = get_bits(gb, 8);\n\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        \n\n        if(get_bits_count(gb) >= gb->size*8){\n\n            if(gb->size==1 && s->divx_version){\n\n                printf(\"frame skip %d\\n\", gb->size);\n\n                return FRAME_SKIPED; //divx bug\n\n            }else\n\n                return -1; //end of stream\n\n        }\n\n\n\n        if((startcode&0xFFFFFF00) != 0x100)\n\n            continue; //no startcode\n\n        \n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            printf(\"startcode: %3X \", startcode);\n\n            if     (startcode<=0x11F) printf(\"Video Object Start\");\n\n            else if(startcode<=0x12F) printf(\"Video Object Layer Start\");\n\n            else if(startcode<=0x13F) printf(\"Reserved\");\n\n            else if(startcode<=0x15F) printf(\"FGS bp start\");\n\n            else if(startcode<=0x1AF) printf(\"Reserved\");\n\n            else if(startcode==0x1B0) printf(\"Visual Object Seq Start\");\n\n            else if(startcode==0x1B1) printf(\"Visual Object Seq End\");\n\n            else if(startcode==0x1B2) printf(\"User Data\");\n\n            else if(startcode==0x1B3) printf(\"Group of VOP start\");\n\n            else if(startcode==0x1B4) printf(\"Video Session Error\");\n\n            else if(startcode==0x1B5) printf(\"Visual Object Start\");\n\n            else if(startcode==0x1B6) printf(\"Video Object Plane start\");\n\n            else if(startcode==0x1B7) printf(\"slice start\");\n\n            else if(startcode==0x1B8) printf(\"extension start\");\n\n            else if(startcode==0x1B9) printf(\"fgs start\");\n\n            else if(startcode==0x1BA) printf(\"FBA Object start\");\n\n            else if(startcode==0x1BB) printf(\"FBA Object Plane start\");\n\n            else if(startcode==0x1BC) printf(\"Mesh Object start\");\n\n            else if(startcode==0x1BD) printf(\"Mesh Object Plane start\");\n\n            else if(startcode==0x1BE) printf(\"Still Textutre Object start\");\n\n            else if(startcode==0x1BF) printf(\"Textutre Spatial Layer start\");\n\n            else if(startcode==0x1C0) printf(\"Textutre SNR Layer start\");\n\n            else if(startcode==0x1C1) printf(\"Textutre Tile start\");\n\n            else if(startcode==0x1C2) printf(\"Textutre Shape Layer start\");\n\n            else if(startcode==0x1C3) printf(\"stuffing start\");\n\n            else if(startcode<=0x1C5) printf(\"reserved\");\n\n            else if(startcode<=0x1FF) printf(\"System start\");\n\n            printf(\" at %d\\n\", get_bits_count(gb));\n\n        }\n\n\n\n        switch(startcode){\n\n        case 0x120:\n\n            decode_vol_header(s, gb);\n\n            break;\n\n        case USER_DATA_STARTCODE:\n\n            decode_user_data(s, gb);\n\n            break;\n\n        case GOP_STARTCODE:\n\n            mpeg4_decode_gop_header(s, gb);\n\n            break;\n\n        case VOP_STARTCODE:\n\n            return decode_vop_header(s, gb);\n\n        default:\n\n            break;\n\n        }\n\n\n\n        align_get_bits(gb);\n\n        startcode = 0xff;\n\n    }\n\n}\n", "idx": 20618, "substitutes": {"s": ["js", "gs", "m", "ssl", "ls", "p", "sq", "sp", "rs", "si", "sb", "ps", "sc", "fs", "sm", "ds", "sa", "ms", "b", "c", "cs", "ts", "ses", "ss", "stats", "t", "aws", "set", "g", "ns", "sim", "hs", "a", "e", "sam", "sts", "sv", "h", "ats", "sg", "sys", "se", "os", "S", "sf", "st", "f", "is"], "gb": ["cfg", "gs", "gc", "uf", "eg", "bb", "eb", "erb", "nb", "bs", "bc", "gg", "yg", "gm", "sb", "tg", "gd", "wb", "gio", "vm", "Gb", "py", "ob", "gu", "b", "large", "GB", "ib", "tif", "gif", "db", "kb", "rb", "g", "bg", "vg", "goo", "asm", "pb", "mb", "buf", "emb", "bf", "gt", "rg", "sg", "fb", "pg", "io", "hub", "cb"], "startcode": ["sticklink", " startlink", " startcount", "startc", " startc", "basecode", "headcoded", "keycod", "needco", " startco", "starttry", "padvalue", "needcore", "basetry", "launchcode", "shortcase", "pickcase", "artc", "stickcondition", "firstcode", "firstcase", "statuscore", "startcase", "birthcache", "drawcase", " starttry", "sharepost", "needcod", " startcycle", "startx", "rankcode", "launchcache", "inittime", "stickgo", "headcod", "firstno", "partentry", "initcard", "Startcount", "startingsequence", "stickcycle", "initmap", "firstcache", "startingcycle", "startmap", "lookco", "rankmap", "launchtime", "startingcod", "rankcache", "lookcache", "startcount", "artCode", "startcore", "startdate", " startno", "pickcondition", "latcase", "basecod", "stopcode", "spacec", "precode", " startCode", "precount", "stickcard", "stickcode", "initcache", "initinfo", "caseco", "rankquery", " startquery", "keysequence", "shareco", "pickcode", "launchco", "latevent", "baseline", "sharecase", "rankentry", "stopentry", "artcode", "startevent", "basecache", "padcoded", "initcycle", "sharecod", "initmodule", "headvalue", "startcache", "startcycle", "initcase", " startgo", " startline", "sharecode", "spacecod", "firstcod", "startlink", "sendcod", "startno", "checkcache", "sendcommand", " startcard", "lookpage", "startcondition", "needsequence", "stickcase", "casecod", "startgo", "latcache", "precod", "firstcoded", "birthcode", "shortmodule", "initco", "padcod", " startpage", "initcondition", "initcod", "partcode", "statusco", "launchline", "precase", "initlink", "artcod", "needcode", " startsequence", "firstinfo", "initcode", "drawcod", "rankinfo", "initno", "drawcode", "partcache", "artdate", "launchcod", "needcase", "firstgo", "birthcod", "Startcase", "initcore", "stopevent", "casecode", "startCode", "launchmap", "birthcoded", "startingcode", "startentry", "basecoded", " startdate", "checkline", "launchentry", "stickco", "latcode", "startvalue", "startcoded", "startco", "startcard", "firstco", "spacex", "keycode", " startcommand", "lookcod", "initquery", "spacecode", "pickcycle", "stopquery", "rankcase", " startvalue", "headcode", "starttime", "stopcase", "casetime", "keycycle", " starttime", "startquery", "launchcase", "artx", "startcod", "padcode", " startx", "checkcode", "sendpage", "needline", "Startcod", "stopmodule", "lookcode", "startinfo", "Startcode", "initevent", "launchquery", "startmodule", "needcache", "birthCode", "drawpost", "checksequence", "statuscase", " startcoded", "startline", "statuscode", "startpage", "sharetime", "initpost", "birthdate", "shortcode", "lookcommand", "startpost", "partquery", "firstevent", "sendcode", "shortevent", " startcase", "startcommand", "startsequence", " startcache", "initentry", "stopcache", " startcod", "launchtry", "firstlink"], "v": ["V", "tv", "m", "vv", "vt", "vc", "inv", "q", "p", "ev", "d", "vs", "va", "value", "vm", "n", "y", "iv", "l", "b", "c", "r", "vp", "j", "uv", "lv", "i", "t", "k", "g", "u", "vr", "vert", "cv", "nv", "vu", "sv", "conv", "qv", "h", "x", "vo", "f", "val"]}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n    const uint8_t *buf_start= buf;\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1) * 2;\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        s->repeat_pict = 1;\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 5;\n\n                                else\n\n                                    s->repeat_pict = 3;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 2;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}\n", "idx": 20620, "substitutes": {"s": ["ctx", "js", "gs", "sets", "spec", "ssl", "sn", "ls", "so", "p", "sq", "es", "sp", "rs", "bs", "q", "w", "sb", "vs", "service", "ps", "n", "sc", "fs", "ds", "self", "ms", "sac", "c", "cs", "settings", "r", "as", "sw", "ts", "ses", "ss", "stats", "t", "aws", "less", "set", "g", "ns", "ins", "hs", "a", "e", "sts", "sv", "conv", "h", "ats", "sg", "os", "sys", "S", "f", "v"], "avctx": ["avsys", "avcomp", " avconn", "svcmp", "aveserver", "aftx", "svcontext", " avcontext", "avesys", "verctx", "afconn", "avercontext", "aversys", "avcmp", "averctx", "svsys", " avjac", "averserver", "vercomp", "avercomp", "devcontext", "afcontext", "avconn", "AVtx", "avecontext", "svpkg", "vertx", "avertx", " avsys", "avecmp", "devsys", "svconn", "avetx", "avectx", "avpkg", "afctx", "avcv", "avcontext", "devserver", "avserver", " avcmp", "avjac", "svctx", "AVjac", "averconn", " avcv", "AVctx", "avejac", "afcv", " avcomp", "svtx", "avercv", "verconn", " avtx", "avepkg", "devctx", "avtx", " avpkg", "AVcontext"], "buf": ["pkg", "pack", "end", "np", "grad", "bs", "cast", "bin", "tmp", "eng", "prop", "rb", "foo", "pb", "vec", "cam", "bf", "queue", "aka", "words", "keep", "block", "cb", "cv", "ctx", "cp", "bed", "uf", "data", "nb", "bar", "box", "padding", "xff", "wb", "bp", "cache", "BU", "b", "doc", "buff", "iter", "img", "pos", "loop", "args", "bh", "Buff", "mb", "read", "desc", "len", "emb", "ctr", "conv", "fb", "begin", "sofar", "v", "ff", "done", "pad", "length", "port", "ptr", "br", "orig", "rw", "lim", "text", "raw", "deg", "bl", "msg", "txt", "window", "batch", "err", "alloc", "cap", "pool", "bo", "bc", "mat", "nm", "def", "Buffer", "src", "bytes", "que", "true", "cmd", "go", "db", "buffer", "bg", "wait", "ref", "off", "late", "code", "mem", "pg"], "buf_size": ["buf__end", "buf__size", "buf_max", "buf__max", "buffer_length", "uf__end", "uf__SIZE", "buffer_from", "buf_length", "buf__SIZE", "uf_max", "uf_SIZE", "buffer_start", "buf_from", "buffer_size", "buf_SIZE", "uf__size", "uf_end", "uf__max", "uf_size"], "pc": ["ctx", "cp", "ac", "gc", "tp", "p", "vc", "pp", "isc", "soc", "amps", "pr", "td", "bc", "pm", "xc", "tc", "anc", "pd", "pan", "sc", "cm", "mc", "cc", "disc", "iac", "icc", "proc", "c", "cs", "fc", "acl", "asc", "wp", "lc", "sync", "tk", "enc", "arc", "psc", "ec", "vp", "pt", "func", "pa", "dc", "amp", "pb", "PC", "cam", "pac", "cu", "conv", "pic", "lp", "rc", "pi", "px", "cmp", "peer", "cv", "ct"], "buf_end": ["buf09start", "buf64end", "buffer_ends", "uf_max", "buf09ending", "buf2end", "buf_est", "buf09end", "bufjstart", "uf_end", "uf_start", "buf64ending", "buf_max", "bufjend", "buffer_est", "buffer_last", "buf_last", "buf_ending", "buf_END", "buf64start", "buf2END", "bufjest", "uf_End", " buf_exp", "buf09exp", "buf2start", "buf2max", "buf_End", "buf64exp", "buffer_end", "buf_exp", "bufjlast", " buf_ending", "buffer_start", "buffer_size", "buf_ends", "uf_END"], "buf_start": ["bufptend", "bufptinit", "bufptstart", "buf2st", "uf_init", "buffer_st", "buffer_start", "buf_init", "buf2start", "buffer_begin", "buf2end", "uf_left", "buf_begin", "buf_st", "uf_end", "bufptleft", "uf_start", "buf_left", "buffer_end", "buf2begin"], "start_code": ["startewCode", "start_component", " start_sequence", " start_Code", "parttenancetype", " start_codes", "parttenancecode", "start_codes", "start_case", "start_type", "start_Code", "part_event", " start_case", "parttenanceevent", " start_component", "startxsequence", " start_cod", "starttenancecode", "startaccode", "startxcode", "start_event", "part_code", " start_number", "parttenancetime", "starttenancetime", "part_type", "startacnumber", "startxcod", "startewcomponent", "startacCode", "startxcomponent", "startewcode", "start_number", "startxcodes", "start_cod", "starttenanceevent", "startxcase", "start_sequence", "start_time", "starttenancetype", "part_time", "startewsequence", "startxCode"], "frame_rate_index": ["frame_rate_Index", "frame_rates_ind", "frame_erate_id", "frame_range_index", "frame_rate_ind", "frame_erate_success", "frame_erate_index", "frame_erate_ex", "frame_rates_number", "frame_rate_info", "frame_time_link", "frame_rate_block", "frame_range_info", "frame_rates_Index", "frame_range_number", "frame_rate_id", "frame_time_Index", "frame_time_block", "frame_time_index", "frame_rate_link", "frame_range_ind", "frame_rates_index", "frame_rate_success", "frame_rate_ex", "frame_rate_number"], "ext_type": ["ext_name", "ext___description", "ext_sequence", "xt_name", "xt_type", "ext___sequence", "xt_description", "ext_description", "xt_sequence", "ext___type", "ext___name"], "bytes_left": ["bufixonly", "buf_fail", "bits_length", "boxes_inner", "bytes_right", "bytes5lit", "bytesityfail", "bufixleft", "bits_right", "bytes08fail", "bytes64inner", "bytes5inner", "boxes_lit", "bytes_len", "bytesityleft", "bufixlt", "tes_left", "bufixfail", "bytesitylt", "bytesixonly", "bytes_lit", "bytes_loaded", "bytesityonly", "buf_left", "bits_left", "bytes64limit", "tes_right", "boxes_limit", "bytes_limit", "bytes08left", "bytes08lt", "bytesixfail", "buf_only", "bytes_length", "bytes5left", "tes_available", "bytesixlt", "bytes5limit", "bytes_fail", "bits_len", "bytes_inner", "buf_lt", "bytes_available", "bytes64lit", "boxes5limit", "bytes64left", "boxes5lit", "tes_loaded", "bytes08only", "boxes5inner", "bytes_lt", "boxes_left", "bytesixleft", "bytes_only", "boxes5left"], "frame_rate_ext_n": ["frame_rate_exp_p", "frame_rate_exp_num", "frame_rate_exp_N", "frame_rate_ext_p", "frame_rate_ext_N", "frame_rate_ext_num", "frame_rate_exp_n"], "frame_rate_ext_d": ["frame_rate_ex_d", "frame_rate_ex_t", "frame_rate_ext_t", "frame_rate_ex_dim", "frame_rate_ex_n", "frame_rate_ext_dim"], "picture_structure": ["picture_instype", "picture_restype", "picture_construction", "picture_constructure", "picture_constrict", "picture_constype", "picture_strict", "picture_instrict", "picture_restruction", "picture_restructure", "picture_stype", "picture_struction", "picture_restrict", "picture_instructure", "picture_instruction"], "top_field_first": ["top_field_ref", "top_field_last", "top_fields_first", "top_field_part", "top_fields_last", "top_fields_ref", "top_fields_part"], "repeat_first_field": ["repeat_last_frame", "repeat_last_fields", "repeat_first_frame", "repeat_first_line", "repeat_last_field", "repeat_first_fields", "repeat_last_line"], "progressive_frame": ["progressiveablefeature", "progressiveingformat", "progression_frames", "progressive_feature", "progression_format", "progression_frame", "progressiveingfeature", "progression_feature", "progressiveableframes", "progressiveingframe", "progressive_frames", "progressiveingframes", "progressiveableformat", "progressive_format", "progressiveableframe"], "horiz_size_ext": ["horiz_size2ext", "horiz_size_exp", "horiz_space_external", "horiz_size2external", "horiz_size2exp", "horiz_size_ex", "horiz_space_ex", "horiz_space_ext", "horiz_size_external", "horiz_space_exp", "horiz_size2ex"], "vert_size_ext": ["vert_size_ex", "vert_size___ext", "vert_size___opt", "vert_Size_ex", "vert_size___ex", "vert_Size_init", "vert_size_init", "vert_Size_opt", "vert_Size_ext", "vert_size_opt", "vert_size___init"], "bit_rate_ext": ["bit_rate_Ext", "bit_rate2external", "bit_rate2ext", "bit_rate_external", "bit_rates_ex", "bit_rates_ext", "bit_rates_Ext", "bit_rate_ex", "bit_rate2ex", "bit_rate2Ext", "bit_rates_external"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int set_chroma_format(AVCodecContext *avctx)\n\n{\n\n    int num_formats = sizeof(schro_pixel_format_map) /\n\n                      sizeof(schro_pixel_format_map[0]);\n\n    int idx;\n\n\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    for (idx = 0; idx < num_formats; ++idx) {\n\n        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {\n\n            p_schro_params->format->chroma_format =\n\n                            schro_pixel_format_map[idx].schro_pix_fmt;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR,\n\n           \"This codec currently only supports planar YUV 4:2:0, 4:2:2\"\n\n           \" and 4:4:4 formats.\\n\");\n\n\n\n    return -1;\n\n}\n", "idx": 20623, "substitutes": {"avctx": ["Avcontext", "aftx", " avcontext", "Avpkg", "avercontext", "wavcontext", "averctx", "avkj", "Avctx", "AVpkg", "avekj", "afcontext", " avkj", "averkw", "Avtx", "AVtx", "avecontext", "wavctx", "avertx", "avetx", "wavkw", "avpkg", "avectx", "afctx", "avcontext", "AVctx", "afkj", "wavtx", "avkw", " avtx", " avkw", "avtx", " avpkg", "AVcontext"], "idx": ["ardj", "indx", "idz", "didwx", "Idx", "bidx", "bidix", "bidz", "sidxs", "idxs", "idlex", "sidlex", "Idex", " idxs", "idez", "midix", "ndx", " idz", "idwx", "keylex", "indz", "indix", "aidj", "ardxes", "indwx", "keyxs", "idj", "aidx", "ndxi", "sidxi", "ideix", "idexs", " idxi", "midex", " idlex", " idy", "aidxes", "didix", "didy", "midxs", "idex", " idix", "ndxes", " idex", " idwx", "bidxi", "indy", "midz", "sidx", "ardxi", "idix", "idxi", "midx", "Idxs", "aidxi", "indxs", "idxes", "ndj", "didx", "keyx", "idy", "keyxi", "ardx", "midxi"], "p_schro_params": ["p_schropydata", "p_schro2params", "p_schropyconfig", "p_schlo_params", "p_schlo_data", "p_schros_data", "p_schro_data", "p_schlo_ams", "p_schros2params", "p_schros_ams", "p_schropyams", "p_schro_settings", "p_schro2config", "p_schro2data", "p_schros2config", "p_schros_config", "p_schro_ams", "p_schros2ams", "p_schros_params", "p_schro2ams", "p_schlo_settings", "p_schro_config", "p_schropyparams", "p_schros2data"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n", "idx": 20631, "substitutes": {"ctx": ["cp", "ac", "gc", "bc", "jp", "kt", "xc", "tc", "conn", "sc", "nc", "cc", "cm", "src", "Context", "co", "proc", "c", "rt", "fc", "ctl", "lc", "tx", "tk", "kw", "nt", "cas", "jac", "pc", "ic", "cci", "unc", "ck", "cu", "context", "rl", "sys", "rec", "hw", "cmp", " cx", "cb", "cv", "ct"], "rb": ["rx", "bb", "erb", "ra", "nb", "rs", "bc", "sb", "ptr", "wb", "gb", "src", "rw", "b", "rt", "raf", "r", "ib", "db", "rf", "vr", "lb", "pb", "ru", "buf", "ro", "rob", "reb", "bf", "rl", "RB", "rg", "rr", "rd", "fb", "rm", "cb"], "rc": ["rin", "cp", "ac", "cr", "rx", "ra", "roc", "rs", "isc", "bc", "ptr", "tc", "src", "nc", "rw", "cc", "rn", "sc", "rt", "c", "RC", "fc", "irc", "r", "cs", "ec", "uc", "reg", "res", "pc", "ic", "dc", "ref", "ru", "cur", "ro", "rl", "rec", "sr", "rd", "rr", "arc", "cb", "cv"], "fn11": ["ln1111", "FN1111", "kn11", "fn118", "fen1", " fn14", "fn12", " fn118", " fn1111", "rn1111", "fn1", "kn12", "FN1", "rn11", "FN12", "FN11", "ln11", "fn2011", "bn011", "fn14", "anon1100", "sn118", "sn11", "pn2011", "fn011", "rn011", "anon11", "kn1", " fn1", "tn11", "dn12", "kn011", "pn14", "fen2011", " fn2011", "bn11", "anon011", "FN011", "bn1111", " fn12", "tn1111", "dn1111", "fen14", "sn1111", "dn111", "ln111", "rn1100", "fen11", "pn1", "dn11", "bn1100", "fn1100", "tn118", " fn011", "fn1111", "anon1111", "ln12", "pn11", "fn111", "FN111"], "vb": ["uvB", " vp", "vB", " vf", "wirebc", "uvbc", "VB", " vobj", "vvobj", "uvbe", "wiresb", "Vbe", "svB", "uvpb", "vobj", "svbe", "vvf", " vbe", "uvb", "vipb", "wirepb", "vbe", "cvrb", "vrb", "vp", "wireb", "vibc", "vpb", "Vb", "cvB", "vib", "vsb", "vf", "vvb", "vbc", "svrb", "uvsb", "visb", "cvbe", "cvp", "Vp", "uvf", " vB", "uvobj", "Vrb", "svb", "cvb"], "vc": ["cp", "vv", "vt", "cil", "ve", "ev", "pr", "vd", "bc", "vet", "xc", "vs", "vm", "vy", "cc", "vl", "ht", "lic", "b", "wt", "rt", "c", "cs", "fc", "vp", "lc", "bt", "uv", "lv", "dl", "pc", "vr", "VC", "ic", "dc", "voice", "vec", "cv", "nv", "ll", "cu", "voc", "sv", "gp", "qv", "conv", "rl", "wl", "fp", "vo", "vi", "cb", "v"]}}
{"project": "qemu", "commit_id": "0e86c13fe2058adb8c792ebb7c51a6a7ca9d3d55", "target": 1, "func": "static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 20643, "substitutes": {"dev": ["spec", "p", "data", "ev", "pad", "cast", "tr", "debug", "Dev", "w", "Device", "d", "ver", "def", "des", "DEV", "conn", "iv", "test", "tm", "ds", "att", "hd", "info", "proc", "doc", "raw", "ow", "dis", "serv", "scan", "nt", "cmd", "go", "pt", "pro", "env", "dem", "dd", "de", "device", "desc", "md", "out", "cam", "obj", "adv", "mem", "ch", "hw", "priv", "ad", "stick", "usb", "cont", "v"], "vser": ["versys", "evSER", " vserv", " vrev", "vears", " vsys", "wireserv", "vmserver", "wSER", "wsel", "evsys", "gserver", "hcur", " vSER", "vmcur", "vserv", "verserver", "ivser", "verstat", "formSer", "evsel", "svdes", "verSer", "wser", "verser", "vsel", " vther", "hder", "vrev", "evsoc", "verber", "wireears", "uvserv", "gcur", " vSer", "ivber", "versoc", "evder", "ivpro", "verther", "evpro", "gder", "vdesc", "wireser", "vber", "vSer", "verder", " vears", "vsys", "svber", "wserv", "verears", "svser", "verserv", "wprof", "formser", "vSER", " vsel", " vstat", "ivserv", "vcur", "vdes", "svuser", "svsoc", "wber", "verpro", "vctr", "wirectr", "evserver", "evrev", "evserv", "vuser", "svserver", "vserver", "vstat", "evdes", "uvserver", " vdesc", "evber", " vuser", "verprof", "vmder", " vctr", "uvser", "svsys", "veruser", "evser", "svstat", "formther", "gser", " vder", "svprof", "vpro", "vsoc", "uvrev", "hser", "vther", "verctr", "formdesc", "vmser", "vder", "hserver", "vprof", "svserv", "verdes", "verdesc", " vserver"], "vdev": ["avvar", "avdes", " vvar", "vdes", "wdev", "wvar", " vdef", "avdevice", "Vder", "Vdef", "wdes", "verdev", "Vserver", "avdev", " vder", "Vdev", "verdef", "vdevice", "verder", "vserver", "vdef", "vvar", " vdes", " vdevice", "wdevice", "vder", "verserver", " vserver"]}}
{"project": "qemu", "commit_id": "5666ca4ae06d20497f887241151278e266947087", "target": 1, "func": "int kvm_arch_init_vcpu(CPUState *cenv)\n\n{\n\n    int ret = 0;\n\n    struct kvm_sregs sregs;\n\n\n\n    sregs.pvr = cenv->spr[SPR_PVR];\n\n    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);\n\n\n\n    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);\n\n\n\n    return ret;\n\n}\n", "idx": 20644, "substitutes": {"cenv": ["centry", "cuenv", " cstate", "dcenvironment", " ccontext", "cwindow", "kviron", "ecenv", "menv", "cuentry", "fenvironment", "cusb", " cenvironment", "kenv", " centry", "concontext", "cviron", " cviron", "conenvironment", "ecsb", "fwindow", "cuwindow", "dcenv", "ecenvironment", "cuexe", "cstate", " cwindow", "menvironment", "conenv", "cexe", "ccontext", "constate", "cuenvironment", "ken", "mviron", "cen", "fenv", "men", "dcstate", "fexe", "dccontext", " cexe", "csb", " cen", "cenvironment", "kenvironment", " csb", "ecentry"], "sregs": ["sRegb", "smemn", " sregn", "sREGs", "sREGjs", "SRegb", "smems", "sremjs", "Sregs", "sregjs", "Sregb", "Sregjs", "sregS", "Sreges", "sREGfs", "sRegs", "sregn", "SReges", " smems", " sregS", "sgrb", "sregisterfs", "sremS", "sregisteres", "sregisters", "sregb", "smemS", " sregjs", "sREGes", "sREGS", "sRegjs", "sREGn", "Sregfs", " smemn", "srems", "sregfs", "sregisterjs", "SRegjs", "sRegfs", "SRegs", "sReges", "smemjs", " smemjs", "sremn", " smemS", "SRegfs", "sgrs", "sgrjs", "sreges"]}}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);", "idx": 20647, "substitutes": {"vq": [" vue", " vdq", "veqq", "hqu", "invqq", "vgr", "hue", "vQ", "veue", "invq", " vgr", "jue", "vqq", "vrequ", "xqq", " vqq", "jque", "mque", "svq", "invQ", "veiq", " vQ", "vdch", "vqs", "yue", "wq", "vch", "vue", "jq", "svch", "invque", "svdq", "wqq", "jQ", "evck", "hqq", "viewq", "mue", "svrequ", "xque", "invdq", "hq", "jqq", "wiq", "vdq", "wque", "xrequ", " vqs", " vck", "jqu", "mqq", "evqs", "veque", "viewue", "vque", " vque", "yque", "vdgr", "vdqq", "veq", "inviq", "mq", "viq", "invqu", "svck", " vch", "viewqu", "yq", "vck", "svqs", "vqu", "invck", "svque", "svqq", "evqq", "yrequ", "yqq", "evq", "xq", " vqu", "viewqq", "svgr"], "vdev": ["dev", "vdevice", " vgo", "svdev", "lval", "vpad", "uvvar", "mdb", "vgu", "mev", "ddb", "ddevice", "vgo", "mdevice", "visvar", "vmdev", "svdat", " vgu", "svval", "vev", "uvserial", " vval", "viewgu", "lev", "vmdat", " vdef", "svserial", "visserver", "uvdef", " vdb", "uvgu", "visdev", "viewvar", "vmgo", "svgu", " vev", "uvdev", "ldat", "svev", " vdat", "viewserver", "svgo", "visgu", "vserver", "svpad", "vdef", "vvar", "vval", "vmpad", "vserial", "ldev", "svdef", " vpad", "ddev", " vdevice", "viewdev", "vdb", "uvserver", "vdat", "mdev", " vserial"]}}
{"project": "FFmpeg", "commit_id": "8728360b5664ef9db31137d8d3104cac33b9a911", "target": 1, "func": "static av_cold int mp_decode_init(AVCodecContext *avctx)\n\n{\n\n    MotionPixelsContext *mp = avctx->priv_data;\n\n    int w4 = (avctx->width  + 3) & ~3;\n\n    int h4 = (avctx->height + 3) & ~3;\n\n\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"extradata too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    motionpixels_tableinit();\n\n    mp->avctx = avctx;\n\n    ff_dsputil_init(&mp->dsp, avctx);\n\n    mp->changes_map = av_mallocz(avctx->width * h4);\n\n    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;\n\n    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));\n\n    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&mp->frame);\n\n    return 0;\n\n}", "idx": 20659, "substitutes": {"avctx": ["averdl", "ajca", "ajcontext", " avconn", "avedl", "aftx", "vrctx", "wavcontext", "avcmp", "avconf", "evcontext", "avhistory", "wavcmp", "avetx", "avectx", "aveconf", "avcontext", "avdl", "ajcmp", "devtx", " avtx", " avcrit", "devctx", "avtx", "wavhistory", "averpkg", "afctl", "verctx", "avercmp", "avehistory", "avecp", "avca", "devcmp", "wavcp", "wavca", "ajctx", "evcmp", "avcp", "afctx", " avcmp", "ajctl", "afdl", "vercfg", "avepkg", " avconf", "evtx", " avpkg", "ajhistory", "afcmp", " avcontext", "averctx", "vrcmp", "afconf", "afcontext", "avconn", "devcp", "avertx", "wavconf", "avcfg", "devcfg", "averconn", "vrtx", "aveconn", "ajcp", "aveca", " avcfg", " avctl", "evctx", "afconn", "avercontext", "averconf", "devcontext", "ajpkg", "devcrit", "avcrit", "vercontext", "vrcontext", "avecontext", "afcp", "avecrit", "vertx", "wavctx", "avecmp", "wavconn", "ajtx", "avpkg", " avcp", "ajconn", "ajdl", "wavtx", "wavpkg", "avctl"], "mp": ["cp", "pkg", "m", "em", "Mp", "ep", "mx", "mm", "p", "pp", "rup", "mod", "mk", "imp", "amps", "emp", "ppo", "mar", "pm", "jp", "gm", "tmp", "aph", "mic", "mn", "ym", "ps", "cm", "mc", "pl", "tm", "ms", "rep", "proc", "wp", "mac", "bm", "app", "mmm", "psc", "map", "mit", "MP", "ma", "nom", "pa", "amp", "mint", "pb", "sim", "ip", "mb", "ap", "md", "mph", "sam", "omp", "fp", "cmp", "px", "cap", "mt"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void put_payload_header(\n\n                                AVFormatContext *s,\n\n                                ASFStream       *stream,\n\n                                int             presentation_time,\n\n                                int             m_obj_size,\n\n                                int             m_obj_offset,\n\n                                int             payload_len\n\n            )\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    ByteIOContext *pb = &asf->pb;\n\n    int val;\n\n    \n\n    val = stream->num;\n\n    if (s->streams[val - 1]->codec.coded_frame->key_frame)\n\n        val |= ASF_PL_FLAG_KEY_FRAME;\n\n    put_byte(pb, val);\n\n        \n\n    put_byte(pb, stream->seq);  //Media object number\n\n    put_le32(pb, m_obj_offset); //Offset Into Media Object\n\n         \n\n    // Replicated Data shall be at least 8 bytes long.\n\n    // The first 4 bytes of data shall contain the \n\n    // Size of the Media Object that the payload belongs to.\n\n    // The next 4 bytes of data shall contain the \n\n    // Presentation Time for the media object that the payload belongs to.\n\n    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);\n\n\n\n    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size\n\n    put_le32(pb, presentation_time);//Replicated Data - Presentation Time\n\n    \n\n    if (asf->multi_payloads_present){\n\n        put_le16(pb, payload_len);   //payload length\n\n    }\n\n}\n", "idx": 20662, "substitutes": {"s": ["js", "gs", "m", "spec", "ssl", "ls", "p", "sq", "sp", "rs", "z", "bs", "conf", "sb", "n", "sc", "ps", "fs", "ds", "b", "c", "cs", "as", "ts", "ses", "ss", "i", "utils", "t", "aws", "less", "set", "g", "ns", "hs", "sts", "sv", "h", "sys", "ats", "os", "S", "f", "is", "v"], "stream": ["stage", "Stream", "response", "sl", "data", "transform", "seq", "platform", "iterator", "length", "path", "port", "console", "range", "test", "each", "present", "chain", "ream", "sync", "sw", "stack", "host", "video", "version", "loop", "size", "message", "sample", "buffer", "pod", "read", "channel", "REAM", "window", "socket", "row", "context", "time", "local", "view", "os", "sequence", "st", "steam", "v"], "presentation_time": ["presentationtimeTIME", "presentATION_date", "presentATION_TIME", "presentATION_time", "presentations_date", "presentation_timer", "presentationTimetimer", "presentATION_duration", "presentation_duration", "presentations_Time", "presentation_date", "presentations_timer", "presentation_Time", "presentation___date", "presentationtimetime", "presentationtimedate", "presentation___TIME", "presentationtimeduration", "presentation___duration", "presentation_TIME", "presentationTimedate", "presentationTimeTime", "presentations_time", "presentationTimetime", "presentation___time"], "m_obj_size": ["m_obj_num", "m_Obj_Size", "m_Obj_num", "m_Obj_size", "m_obj_len", "m_obj_dim", "m_obj_Size"], "m_obj_offset": ["m_obj_Offset", "m_objxoffset", "m_obj_tile", "m_Obj_off", "m_Obj_offset", "m_objectxprefix", "m_obj____offset", "m_object_prefix", "m_objJtile", "m_obj_prefix", "m_Obj_tile", "m_obj____off", "m_Obj_Offset", "m_objxprefix", "m_obj____prefix", "m_objectxoff", "m_obj_off", "m_objJoffset", "m_object_off", "m_objJOffset", "m_object_offset", "m_objJoff", "m_objxoff", "m_objectxoffset"], "payload_len": ["payloads_length", "payload_Len", "payloadetylength", "payload2len", "payload_buf", "payl_lon", "payload00length", "payloadetylen", "payloadetybuf", "payloads_len", "payloads_Len", "payload00lon", "payload00Len", "payl_Len", "payload00len", "payl_length", "payload_lon", "payl_len", "payload_length", "payloads_buf", "payload2length", "payloadetyLen", "payload2lon", "payload2Len"], "asf": ["Asf", "rasrf", "asfs", "lasf", " asg", "Asrf", "lasfo", "rasp", "rasf", "ASg", "iasfo", "amsfo", " asfo", "amsf", "ASfac", "rasg", " asfs", " asfac", "amsfs", "asfac", "asrf", "asfo", "iasfs", "ASv", " asv", "ASf", "rasfac", "Asp", "lasp", "asv", "rasfo", "amsfi", "rasv", "Asfo", " asfi", "iasfi", "asp", "iasf", "lasrf", "asg", "asfi"], "pb": ["ctx", "cp", "pkg", "gc", "uf", "tp", "p", "np", "pp", "eb", "bs", "orp", "ub", "jp", "pm", "apa", "sb", "um", "tc", "gb", "wb", "bp", "pan", "typ", "vm", "ab", "pl", "tm", "mp", "ker", "wp", "stab", "tab", "vp", "tk", "tap", "PB", "pt", "bh", "kb", "db", "rb", "bj", "pc", "pa", "dc", "xb", "dp", "lb", "amp", "mb", "ap", "zb", "bps", "emb", "gp", "lp", "tf", "fb", "pg", "fp", "px", "peer", "pool", "cb", "cv"], "val": ["ctx", "high", "num", "sl", "aval", "vt", "p", "ival", "pr", "seq", "sel", "loc", " VAL", "ver", " Val", "value", "typ", "sil", "pl", "lev", "status", "ret", "b", "vol", " num", "VAL", "tx", " v", "serv", " value", "point", "pt", "eval", "pos", "res", " ver", "bl", "Val", "col", "li", "key", "pol", "ref", "al", "bal", " aval", "len", "buf", "rol", "el", "ind", "ch", " len", " el", "index", "vals", "elt", "dim", "valid", " valid", " eval", "v"]}}
{"project": "FFmpeg", "commit_id": "0eaec10550bd9a0682db9f7920ed0d86f1450f4b", "target": 1, "func": "static int pcm_encode_frame(AVCodecContext *avctx,\n\n\t\t\t    unsigned char *frame, int buf_size, void *data)\n\n{\n\n    int n, sample_size, v;\n\n    short *samples;\n\n    unsigned char *dst;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n    case CODEC_ID_PCM_S16BE:\n\n    case CODEC_ID_PCM_U16LE:\n\n    case CODEC_ID_PCM_U16BE:\n\n        sample_size = 2;\n\n        break;\n\n    default:\n\n        sample_size = 1;\n\n        break;\n\n    }\n\n    n = buf_size / sample_size;\n\n    samples = data;\n\n    dst = frame;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_S16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = (v + 128) >> 8;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = ((v + 128) >> 8) + 128;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_alaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_ulaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    avctx->key_frame = 1;\n\n    //avctx->frame_size = (dst - frame) / (sample_size * avctx->channels);\n\n\n\n    return dst - frame;\n\n}\n", "idx": 20697, "substitutes": {"avctx": ["autcv", "afcmp", "autctx", " avconn", "evctx", "aftx", " avcontext", "wavcontext", "avcmp", "navcv", "evcontext", "evconn", "cvwp", "afcontext", "avconn", "autwp", "cvcv", "AVtx", "wavcmp", "cvcmd", "evcmp", "navctx", "wavctx", "AVcmp", "AVconn", "navcmd", " avcmp", "avcv", "avcontext", "afctx", "navwp", "AVctx", "autcmd", "wavtx", "avcmd", "cvctx", "avwp", "avtx", "AVcontext"], "frame": ["face", "scene", "profile", "iframe", "state", "seq", "framework", "image", "fr", "force", "feat", "chain", "info", "Frame", "fram", "show", "raw", "header", "origin", "point", "video", "message", "sample", "buffer", "rame", "window", "channel", "code", "frames", "base", "context", "cf", "fb", "sequence", "space", "block", "f"], "buf_size": ["buf2size", "buf_sum", "buf8len", "buf_count", "buf2len", "buf_len", "buf_length", "buf8count", " buf_sum", " buf_Size", "buf2count", "buf2length", " buf_count", "buf_Size", "buf8length", " buf_length", " buf_len", "buf8size"], "data": ["m", "image", "bin", "length", "padding", "mu", "range", "value", "bytes", "feed", "result", "text", "values", "raw", "empty", "video", "pointer", "step", "extra", "area", "message", "sample", "buffer", "window", "buf", "next", "channel", "context", "DATA", "package", "ata", "batch", "binary", "sequence", "block", "Data", "table", "response"], "n": ["np", "name", "ln", "nos", "on", "N", " N", "fn", "nt", "gn", "yn", "non", "tn", "count", "con", "ll", "none", "after", "x", "f", "nb", "o", "z", "mn", "d", " ns", "nn", "syn", "rn", "l", "b", "nl", "k", "en", "pn", "len", "norm", "un", "m", "sn", "num", "cn", "nc", "an", "ren", "na", "g", "names", "note", "el", "err", "p", "nm", "y", "nor", "s", "c", "no", "j", "i", "t", "size", "dn", "ns", "number", "out", "all", "nan", "new", "ex", "ne"], "sample_size": ["ample_set", "sample_set", "sample_Size", " sample_len", "sample_range", "frame_range", "Sample_SIZE", "Sample_Size", "ample_size", "Sample_size", "ample_SIZE", "frame_Size", " sample_id", "frame_SIZE", "sample_SIZE", "sample_len", "sample_id", " sample_SIZE", "frame_size"], "v": ["V", "tv", "get", "vc", "ve", "at", "ver", "um", "wire", "video", "format", "rev", "ch", "x", "pi", "f", "cv", "vt", "q", "z", "d", "vs", "qu", "vm", "it", "iv", "l", "b", "html", "uv", "k", "u", "message", "en", "conv", "ov", "temp", "m", "vector", "ev", "av", "to", "status", "max", "lv", "version", "g", "var", "qv", "vi", "vv", "p", "inv", "w", "value", "y", "values", "c", "vp", "j", "i", "t", "vr", "nv", "e", "all", "sv", "h", "val"], "samples": ["spores", "spamps", "isamps", "sonents", "numps", "sents", "Socks", "Sores", "isents", "socks", "taces", "donents", "daves", "Sumps", "sales", "sources", "Sources", "ssamps", "bocks", "tources", "nents", "sores", "bamples", "Sonents", "ssents", "saces", "namples", " sents", "namps", "tocks", "isizes", "sumps", "baves", "sples", " sores", "isumps", " sales", "isources", "isples", "dents", "assocks", "samps", "Sales", "isocks", "dources", "damples", "samocks", "assamples", " samps", " sources", "Samps", "spamples", "daces", "isaves", "spales", "sizes", "samamples", "ssources", "docks", "isamples", "bizes", "samamps", "Sples", "isaces", "saves", "assamps", "assonents", "dizes", "ssamples", "damps", "Sents", "Samples", "tamples"], "dst": ["docdest", "bdstack", " dST", "fdst", " dut", "ddsts", "disdrop", " dset", "disstage", "dport", "dhdest", "dhstr", "DST", "disst", "dstack", "dsbs", "adbs", "docport", "fddrop", "derrd", "dsst", "dstage", "dolt", "distack", "dbst", "dstop", "dersts", "rdste", "disstack", "derut", "Dld", "dissts", "domt", "dstore", "diddrop", "ardman", "ardstore", "dset", "fdsts", "derust", "dists", "ardst", " dport", "dsest", "ddst", "bdut", "drest", "adstop", "dhstore", "dman", "dastore", " dists", "dhman", "dhmt", "dodest", " dste", "dest", " dstack", "bdstop", "dust", "ddstack", "dbs", "ldst", "dbstore", "bdstage", "dstr", " drd", "rdrd", "distore", " dmt", "addest", "distage", "ddest", "dadest", "drdest", "adstore", "dhst", "dtst", "daut", "didst", "disdest", "dtstop", "edST", "ddstore", "dld", "fdth", "bdst", "ddut", "Dstop", "ardsts", "dasl", "bdld", " dust", "dddest", " dman", "ldrest", " dstore", "arddest", "dost", "dth", "dhrest", "ddrop", "drlt", "dbstop", " ddest", "dsdest", "dsset", "dste", "bdstore", "ldstr", " dstr", "dhists", "dST", "darest", "derst", "dtdest", "dhsts", "docists", "dsl", "didth", " dstage", "Dsts", "adst", " dstop", "ardld", " dlt", "dsstore", "disstore", "bdST", "Ddest", "Dest", "adset", "rdust", " dbs", "didsts", "dist", " dsts", "drmt", "rdst", "dast", "dtrest", "eddest", "dastage", "edsts", "disth", "ldmt", "dlt", "docst", "derstage", "derste", "bdsl", "daST", "dbST", "Dstore", "adST", "dhport", "Dst", "drst", "Drest", "dissl", "dssts", "edst", "dmt", "bddest", "dut", " drest", "drd", "dasts", "dsts"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc, int16_t *filter, int16_t *filterPos, int filterSize) {\n\n  register int i;\n\n  int __attribute__ ((aligned (16))) tempo[4];\n\n\n\n  if (filterSize % 4) {\n\n    for(i=0; i<dstW; i++) {\n\n      register int j;\n\n      register int srcPos = filterPos[i];\n\n      register int val = 0;\n\n      for(j=0; j<filterSize; j++) {\n\n\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n      }\n\n      dst[i] = av_clip(val>>7, 0, (1<<15)-1);\n\n    }\n\n  }\n\n  else\n\n  switch (filterSize) {\n\n  case 4:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_vEven, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 12) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\t// now put our elements in the even slots\n\n\tsrc_v = vec_mergeh(src_v, (vector signed short)vzero);\n\n\n\n\tfilter_v = vec_ld(i << 3, filter);\n\n        // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2)\n\n\n\n        // the neat trick : we only care for half the elements,\n\n        // high or low depending on (i<<3)%16 (it's 0 or 8 here),\n\n        // and we're going to use vec_mule, so we chose\n\n        // carefully how to \"unpack\" the elements into the even slots\n\n\tif ((i << 3) % 16)\n\n\t  filter_v = vec_mergel(filter_v,(vector signed short)vzero);\n\n\telse\n\n\t  filter_v = vec_mergeh(filter_v,(vector signed short)vzero);\n\n\n\n\tval_vEven = vec_mule(src_v, filter_v);\n\n\tval_s = vec_sums(val_vEven, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 8:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_v, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 8) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tfilter_v = vec_ld(i << 4, filter);\n\n        // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2)\n\n\n\n\tval_v = vec_msums(src_v, filter_v, (vector signed int)vzero);\n\n\tval_s = vec_sums(val_v, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 16:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1 = vec_ld(srcPos + 16, src);\n\n\tvector unsigned char src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tvector signed short src_vA = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tvector signed short src_vB = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n\tvector signed short filter_v0 = vec_ld(i << 5, filter);\n\n       \tvector signed short filter_v1 = vec_ld((i << 5) + 16, filter);\n\n        // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2)\n\n\n\n\tvector signed int val_acc = vec_msums(src_vA, filter_v0, (vector signed int)vzero);\n\n\tvector signed int val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n\tvector signed int val_s = vec_sums(val_v, vzero);\n\n\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  default:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int j;\n\n\tregister int srcPos = filterPos[i];\n\n\n\n        vector signed int val_s, val_v = (vector signed int)vzero;\n\n\tvector signed short filter_v0R = vec_ld(i * 2 * filterSize, filter);\n\n        vector unsigned char permF = vec_lvsl((i * 2 * filterSize), filter);\n\n\n\n        vector unsigned char src_v0 = vec_ld(srcPos, src);\n\n        vector unsigned char permS = vec_lvsl(srcPos, src);\n\n\n\n        for (j = 0 ; j < filterSize - 15; j += 16) {\n\n          vector unsigned char src_v1 = vec_ld(srcPos + j + 16, src);\n\n          vector unsigned char src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          vector signed short src_vA = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          vector signed short src_vB = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n          vector signed short filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          vector signed short filter_v2R = vec_ld((i * 2 * filterSize) + (j * 2) + 32, filter);\n\n          vector signed short filter_v0 = vec_perm(filter_v0R, filter_v1R, permF);\n\n          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);\n\n\n\n          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);\n\n          val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n          filter_v0R = filter_v2R;\n\n          src_v0 = src_v1;\n\n        }\n\n\n\n        if (j < (filterSize-7)) {\n\n          // loading src_v0 is useless, it's already done above\n\n          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);\n\n          vector unsigned char src_v1, src_vF;\n\n          vector signed short src_v, filter_v1R, filter_v;\n\n          if ((((int)src + srcPos)% 16) > 8) {\n\n            src_v1 = vec_ld(srcPos + j + 16, src);\n\n          }\n\n          src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          src_v = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          // loading filter_v0R is useless, it's already done above\n\n          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);\n\n          filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          filter_v = vec_perm(filter_v0R, filter_v1R, permF);\n\n\n\n          val_v = vec_msums(src_v, filter_v, val_v);\n\n        }\n\n\n\n        val_s = vec_sums(val_v, vzero);\n\n\n\n        vec_st(val_s, 0, tempo);\n\n        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n\n\n    }\n\n  }\n\n}\n", "idx": 20698, "substitutes": {"dst": ["ststream", " dsrc", " dlt", " dwrite", "stdest", "dct", "dact", "dddest", "ddstream", "dstream", "dsst", "dwrite", "dast", "dasrc", "stwrite", "dlt", " ddest", "dsrc", "dalt", "dslt", "ddest", "ddst", "dssrc", " dct", "dsct", " dstream", "ddwrite", "stst"], "dstW": ["dspF", "gstWA", "dspN", "dsrcSize", "deltaWR", "gstW", "dndEW", "destV", "destM", "dbtN", "dotW", "gstEW", "dstEW", "dotWR", "gotEW", "DestV", "gotWR", "destSize", "dndF", "deltaWA", "distM", "dstSize", "distSize", " dspW", " dspF", "gotWA", "dstM", " dstN", "dscWA", "deltaEW", "DstM", "DstW", "dscEW", "DstSize", "dndN", "dspW", "gotW", "dsrcV", "DestM", " dstF", " dstEW", "destW", "dsrcW", "dbtW", " dspEW", "dstWR", "dotWA", "distW", " dspN", "DstV", "dbtF", "gstWR", "distV", "dstV", "DestW", "dsrcM", "dstF", "dndW", "dstWA", "dscWR", "dstN", "dspEW", "dscW", "deltaW", "dbtEW", "DestSize", "dotEW"], "src": ["pkg", "sn", "sl", "inst", "ssl", "inc", "Source", "sq", "input", "sort", "control", "secure", "bc", "sel", "loc", "supp", "image", "tmp", "sb", "ptr", "syn", "sc", "iv", "dest", "ser", "attr", "s", "sync", "lib", "sw", "fil", "in", "img", "sub", "txt", "stream", "target", "SOURCE", "std", "ins", "cur", "source", "ctr", "conv", "sr", "usr", "rl", "sf", "sys", "addr", "sur", "fp", "sup", "st", "cont", "rc"], "srcW": ["rcN", "stPos", "rcPos", "srcSize", " srcPos", "rcW", " srcSize", "stN", "srcN", "srcPos", "rcSize", " srcN", "stW", "stSize"], "xInc": ["xyInc", "zInit", "xEnc", "xyinc", "zEnc", "xyInit", "xInit", "zinc", " xinc", "zInc", "xyEnc", " xInit", " xEnc", "xinc"], "filter": ["ff", "check", "profile", "inc", "sort", "transform", "control", "fw", "fl", "length", "bin", "supp", "include", "scale", "sc", "test", "ilt", "chain", "lr", "proc", "fc", "r", "config", "fil", "flash", "only", "flat", "map", "pipe", "match", "reverse", "target", "stream", "ref", "vec", "select", "channel", "out", "source", "Filter", "conv", "usr", "stop", "tf", "mask", "fp", "block", "f", "cont", "term", "v", "val"], "filterPos": ["onlyPos", "filterRes", "filterPosition", "reportPOS", "sortPos", "FilterPoints", " filterPoints", "FilterSize", "FilterPOS", "controlPos", "blockSize", " filterRes", "FilterPos", "filterPOS", "sortRes", "onlyPOS", "controlSize", "blockPosition", "sortPOS", "onlyPosition", "blockPos", " filterPosition", "blockPOS", "reportRes", "onlySize", "filterPoints", " filterPOS", "reportPos", "controlPoints", "controlPOS"], "filterSize": ["FilterCount", " filterSIZE", "triggerCount", "batchSize", "batchPos", "tableSIZE", "triggerSize", " filterCount", "triggerSIZE", " filterSense", "filterCount", "windowSIZE", "FilterSIZE", "FilterStyle", " filterStyle", "FilterSize", "batchType", "hashSize", "testCount", "blockSize", "tableCount", "blockSIZE", "triggerSense", "testSIZE", "hashSIZE", "FilterPos", "tableSize", "testStyle", "filterType", "windowSize", "blockScale", "filterSense", "windowScale", " filterScale", "blockStyle", "windowStyle", "tablePos", "filterSIZE", "FilterType", "filterStyle", "blockCount", "filterScale", "batchCount", "testSize", "hashCount", "tableStyle", "hashSense", "tableType"], "i": ["name", "multi", "um", "ei", "ims", "mi", "info", "dr", "\u0438", "uri", "phi", "series", "ip", "ri", "iq", "a", "ini", "ind", "ii", "pi", "io", "f", "ki", "im", "o", " bi", "zi", "it", "l", "b", "qi", "iu", "iii", "iter", "di", "remote", "u", "source", "is", "v", "hi", "m", "me", "si", "to", "xi", "status", "init", "r", "point", "ai", "g", "ui", "li", " ti", "ci", "ix", "p", "id", "y", "ij", "ti", "s", "c", "t", "through", "ie", " ii", "gi", "ic", "sim", "ji", "bi", "e", "index", "I", "ia", "ami", "ex", "val"], "tempo": ["tempi", "timota", "empo", "surpt", "empt", "timpi", "timpo", "tempt", "timpt", "surpi", "temota", "surpo", "empi", "surota", "emota"], "j": ["js", "jj", "kh", "json", "q", "p", "o", "bs", "z", "at", "uj", "pr", "aj", "ja", "si", "jp", "by", "je", "fr", "on", "y", "it", "n", "oj", "dj", "l", "ij", "jc", "er", "jet", "b", "r", "jo", "jl", "pt", "ie", "k", "g", "bj", " ii", "col", " J", "J", "other", "note", "ji", "off", "obj", "next", "ind", "jump", "kj", "err", "ia", "v", "bo"], "src_v1": ["src_l1", "src_v4", "src_m4", "src_h7", "src_m7", "src_t4", "src_ver1", "src_ver0", "src_j4", "src_l0", "src_m2", "src_hN", "src_h1", "src_j2", "src_j0", "src_t2", "src_tF", "src_t0", "src_v7", "src_h0", "src_lN", "src_ver2", "src_verF", "src_t1", "src_vN", "src_j1", "src_l7", "src_m1", "src_mF", "src_v2", "src_v0", "src_mN", "src_m0"], "src_vF": ["src_w0", "src_wE", "src_vV", "src_bF", "src_p0", "src_hf", "src_hF", "src_vE", "src_m2", "src_avf", "src_vH", "src_pf", "src_avF", "src_VV", "src_VE", "src_mE", "src_VF", "src_av0", "src_b0", "src_wV", "src_p2", "src_h0", "src_vf", "src_avH", "src_b2", "src_mV", "src_hH", "src_V0", "src_bf", "src_pF", "src_mF", "src_mf", "src_v2", "src_v0", "src_wF", "src_m0"], "src_v": ["rc_h", "src__v", "src_vi", "rc_rev", "source_v", "src_f", "ser_vi", "ser_f", "src2V", "src_h", "src2v", "ser_v", "src_V", "src___h", "src_s", "src2i", "src_o", "src_m", "rc_o", "src__m", "source_p", "src_p", "rc_t", "src__V", "source_t", "src__i", "rc_v", "source_m", "src2p", "src_t", "src___o", "ser_s", "src___v", "src_i", "source_V", "rc_p", "src_rev", "src2t", "src2m", "source_i", "src___rev"], "filter_v": ["sort_uv", " filter_m", "filterpystatus", "fil_v", "filter_vr", "tail_vr", "fil_f", " filter_vs", "filter_status", "fil_vs", "filter___x", " filter_f", "filter_ve", "filterpym", "filter_f", "filter___tv", "filter___r", "sort_v", "filter_r", "tail_r", "filter_x", "filter_m", "filter_uv", "sort_m", "filter_tv", " filter_status", " filter_x", "filter___vr", "fil_ve", "filter___vs", "tail_tv", "filter___v", "filter___f", "tail_v", "filter_vs", "filterpyv", "fil_uv"], "val_vEven": ["val_h0", "val_vfree", "val_hzero", "val2vZero", "val_jEven", "val_u0", "val_mfree", "val______", "val_m0", "val_v0", "val2v0", "val_uzero", "val_mzero", "val2m0", "val_j0", "val_s0", "val_sEven", "val_mEven", " val_2", "val_4", "val__", "val_ufree", " val__", "val_hfree", "val_szero", "val_____4", "val_____2", "val2vzero", " val_4", "val_hZero", "val_2", "val_vzero", "val2mZero", "val2vfree", "val_jZero", "val_vZero", "val_mZero", "val_sZero", "val2mfree", "val_uZero", "val_jzero", "val2mzero"], "val_s": ["fail_v", "val_m", "val2s", "val2l", "fail_n", "val2v", " val_m", " val_sym", "val_n", "val2n", " val_n", "val_l", "val_sym", "fail_s", "fail_l"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n", "idx": 20716, "substitutes": {"env": ["ctx", "dev", "ev", "conf", "w", "environment", "attr", "scope", "config", "stack", "node", "func", "map", "set", " environment", "txt", "var", "cur", " st", "buf", "code", "obj", "context", "mem", "param", "qv", " context"], "value": ["action", "V", "vector", "Value", "get", "property", "json", " input", "data", "input", " Value", "ve", "type", "word", "image", "execute", "field", "widget", "request", "ue", " values", "self", "values", " message", "hello", "feature", "address", "VAL", "vp", " v", "function", "item", "raw", "go", "unknown", "server", "document", "size", "message", "buffer", "see", "create", "total", "VALUE", "select", "process", "job", "hash", "code", "now", "instance", "comment", "time", "package", "view", "attribute", "python", "commit", "block", "use", "v", "val"]}}
{"project": "qemu", "commit_id": "4715d42efe8632b0f9d2594a80e917de45e4ef88", "target": 1, "func": "static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n", "idx": 20722, "substitutes": {"obj": ["ctx", "js", "rect", "o", "imp", "pr", "ist", "objects", "ot", "gov", "tmp", "typ", "oj", "ht", "ob", "attr", "og", "nt", "org", "onet", "img", "act", "pt", "bh", "bj", "txt", "ref", "resp", "now", "obs", "xy", "op", "os", "hw", "object", "Obj", "ex", "bo"], "v": ["V", "m", "tv", "vt", "p", "q", "o", "ev", "vim", "w", "vs", "av", "vm", "vy", "iv", "l", "b", "c", "r", "vp", "j", "uv", "t", "g", "vr", "mint", "cv", "vis", "vu", "sv", "conv", "view", "h", "x", "vi", "f"], "opaque": ["opaques", "Opaque", " Opaco", " opaco", "opaco", "opque", "oplay", "Opque", " opatile", " Opque", "oppaques", " Opaque", " oplay", "Opatile", " opque", " Oplay", "Opaques", "oppque", "oppatile", "opatile", " opaques", "oppaque", "oppaco", "opplay"], "name": ["missing", "alias", "type", "word", "path", "w", "nm", "def", "n", "named", "ame", "prefix", " path", "text", "attr", " NAME", " key", "search", " Name", "error", "nam", "key", "names", " names", "NAME", "comment", " prefix", "title", "str", "Name", "part", "cap", "label", "term"], "errp": ["errpid", "ererpid", "errpun", " erpid", "lerp", "errm", " errP", " errpc", "lerpad", "errr", "ererpad", "lerpun", "erP", "ererpun", "rrr", "arrpa", "rrP", " errr", "ererp", " errm", "rrm", "erpc", "rrpa", " erpun", "arrm", " erp", "rrpc", " erpad", "errpc", "lerpid", "arrpc", "rrp", "erp", "errpa", "errP", "arrp", "err", " errpa", "errpad"], "prop": ["pkg", "cfg", "perm", "acc", "p", "rop", "mod", "pr", "jp", "per", " poss", "def", "tag", "ph", "Prop", "ps", "feat", "mp", " props", "att", "attr", "rep", "proc", "cmd", "pt", " pos", " Prop", "fac", "prof", "pro", "col", " p", "pa", "key", "pb", "pri", "fam", "desc", "pred", " pro", " prob", "comp", "op", " proc", "priv", " comp", "rel", "prot", "opt", "val"], "value": ["current", "tv", "Value", "json", "property", " Value", "data", "input", "state", "entry", "type", "id", "length", "distance", "unit", "field", "widget", "iv", "test", "expression", "ue", "result", "max", "values", "text", "address", "checked", "VAL", "vp", "version", "size", "set", "key", "see", "total", "VALUE", "number", "instance", "code", "byte", "index", "attribute", "valid", "object", "val"]}}
{"project": "qemu", "commit_id": "947995c09ebd35a752837a5573985ba5a9942ec1", "target": 0, "func": "static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n", "idx": 20728, "substitutes": {"path": ["ac", "pkg", "cp", "check", "dir", "ix", "end", "p", "spec", "full", "file", "Path", "transform", "name", "dot", "alias", "mat", "port", "w", "url", "prop", "component", "test", "dest", "chain", "prefix", "text", "PATH", "c", "raw", "pat", "empty", "template", "cmd", "host", "pointer", "pt", "remote", "uri", "txt", "stream", "link", "php", "out", "code", "pattern", "local", "str", "th", "ath", "cont", "present"]}}
{"project": "qemu", "commit_id": "1466cef32dd5e7ef3c6477e96d85d92302ad02e3", "target": 0, "func": "static int mch_init(PCIDevice *d)\n\n{\n\n    int i;\n\n    MCHPCIState *mch = MCH_PCI_DEVICE(d);\n\n\n\n    /* setup pci memory regions */\n\n    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), \"pci-hole\",\n\n                             mch->pci_address_space,\n\n                             mch->below_4g_mem_size,\n\n                             0x100000000ULL - mch->below_4g_mem_size);\n\n    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,\n\n                                &mch->pci_hole);\n\n\n\n    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,\n\n                       mch->pci_hole64_size);\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             mch->pci_info.w64.begin,\n\n                             mch->pci_hole64_size);\n\n    if (mch->pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    mch->pci_info.w64.begin,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n", "idx": 20738, "substitutes": {"d": ["dos", "m", "dat", "p", "dx", "w", "pd", "y", "fd", "dt", "ds", "l", "hd", "b", "c", "du", "j", "di", "da", "dr", "t", "dn", "dm", "g", "ed", "dc", "dd", "did", "md", "e", "h", "D", "bd", "sd", "f", "v"], "i": [" l", "m", " ti", "ix", "p", " iter", " e", " counter", " index", " li", " bi", "si", "multi", "n", "y", "xi", "l", "counter", "b", "mi", "s", "c", " v", "j", "di", " pos", " my", "t", " ii", " I", " k", "u", "g", " multi", "li", " j", " n", " err", " m", " x", "bi", " c", "index", "x", "ii", "pi", "I", " ni", "v", " pi"], "mch": ["rmcht", "remach", "tmch", " mcher", "mailch", "mchn", "tmcher", "cmche", "nich", "mzh", "parch", "emich", "rmach", "tmich", "mancht", "manche", "memchn", "amchan", "ych", " mht", "remech", "emcht", "ychid", "vmch", "nmach", "tmcht", "esmch", "emht", "cmsch", "esmarch", "imcht", " mcht", "amch", "rmoch", "esmcher", "mtach", "pchan", "remche", "manch", " mkh", "Mchid", "mrach", "pth", "amche", "memch", "vmcht", "emchn", "amchn", " mgt", "amkh", "nmcht", "mCh", "mech", "stanchid", "mtch", "cmchan", "mailCh", " mth", "pht", "matchan", "nmch", "smach", "mailchn", "mailche", "remcher", "smch", "pmche", "pmcht", "gmich", "memich", "pich", "gmcht", " mform", "esmkh", "modch", "stanoch", "tmchid", "mche", "mcher", "gmoch", "imach", "pmzh", "rmche", "emzh", " mach", "emach", "tmchn", "nchid", "mchan", "pche", "amcht", "mth", "cmchn", "mcht", "amech", "pkh", "mform", "emtch", " mCh", " mchn", "mgt", "mtchn", "yCh", "cmchid", "gmch", "mrcht", "emth", "remkh", "modcher", "cmgt", "modth", "msch", "smchid", "gmach", "cmarch", "esmzh", "emcher", "gmCh", "mailcht", "rmtch", "pach", "pmch", "cmach", "vmche", "moch", "rmchid", "cmch", "tmach", "mailich", "mrch", "mach", "remcht", "esmach", "ychn", "tmech", "rmkh", "emsch", "smich", "psch", "vmchn", "Mch", "cmcht", "nmcher", "rmich", " moch", "nach", "stanich", "tmCh", "remch", "rmth", "nmth", "esmCh", "tmzh", "pch", "cmich", "amth", "Mich", "vmach", "mkh", "rmch", "tmche", "gmkh", "rmcher", "pech", "rmchn", "cmech", " mich", "mailchid", "mrech", "pchn", "mht", "stanform", "gmchn", "modich", "emche", "mich", "amoch", "stanch", "nmche", "stangt", " mche", "manchn", "matoch", " mech", "emoch", "nch", "imzh", "tmchan", "esmche", "Mach", "tmth", "emch", "emchid", "imcher", "match", " mchid", "matkh", "gmtch", "mchid", "remzh", "pchid", "imch", "pcht", "emCh", "mtcht", "esmcht", "cmoch", "cmform", "gmchan", "pmcher", "mailcher", "gmche", "march", "esmech", "imich", "rmCh", "memach", "pmich"]}}
{"project": "FFmpeg", "commit_id": "ccff9da62a833238db7a22eb39be0814f522c2c5", "target": 0, "func": "static int h261_find_frame_end(ParseContext *pc, AVCodecContext* avctx, const uint8_t *buf, int buf_size){\n\n    int vop_found, i, j, bits_left, last_bits;\n\n    uint32_t state;\n\n\n\n    H261Context *h = avctx->priv_data;\n\n\n\n    if(h){\n\n        bits_left = h->bits_left;\n\n        last_bits = h->last_bits;\n\n    }\n\n    else{\n\n        bits_left = 0;\n\n        last_bits = 0;\n\n    }\n\n\n\n    vop_found= pc->frame_start_found;\n\n    state= pc->state;\n\n    if(bits_left!=0 && !vop_found)\n\n        state = state << (8-bits_left) | last_bits;\n\n    i=0;\n\n    if(!vop_found){\n\n        for(i=0; i<buf_size; i++){\n\n            state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    i++;\n\n                    vop_found=1;\n\n                    break;\n\n                }\n\n            }\n\n            if(vop_found)\n\n                    break;    \n\n        }\n\n    }\n\n    if(vop_found){\n\n        for(; i<buf_size; i++){\n\n            if(avctx->flags & CODEC_FLAG_TRUNCATED)//XXX ffplay workaround, someone a better solution?\n\n                state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pc->frame_start_found= vop_found;\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 20741, "substitutes": {"pc": ["ctx", "cp", "pkg", "gc", "tp", "p", "vc", "pp", "isc", "pr", "bc", "pm", "tc", "anc", "pd", "icc", "disc", "py", "cc", "iac", "cpu", "mp", "proc", "c", "wp", "cs", "acl", "sync", "lc", "pat", "po", "ec", "pt", "func", "pa", "dc", "amp", "unc", "pb", "pod", "PC", "process", "cam", "php", "pac", "cu", "pic", "sys", "peer", "lp", "pi", "pas", "px", "cmp", "arc", "rc", "ct"], "avctx": ["Avcontext", "avsys", "evconfig", " avconn", "evctx", "abctx", " avcontext", "avesys", "avcmp", "evcontext", "evconn", "Avctx", "avconfig", "abtx", "avconn", " avconfig", "AVtx", "avecontext", "abcontext", " avsys", "AVsys", "avetx", "avectx", "abcmp", "apctx", " avcmp", "Avconn", "avcontext", "AVctx", "Avconfig", " avtx", "aptx", "apcontext", "avtx", "apcmp", "AVcontext"], "buf": ["ctx", "pkg", "uf", "p", "np", "bar", "data", "bs", "bits", "seq", "cast", "bag", "bc", "bin", "nm", "wb", "bp", "br", "Buffer", "bytes", "que", "mus", "ob", "b", "proc", "doc", "buff", "cmd", "img", "map", "db", "rb", "buffer", "msg", "pb", "vec", "Buff", "cv", "bu", "cam", "window", "late", "mem", "bf", "arr", "queue", "aka", "batch", "fb", "words", "block", "cb", "v", "bn"], "buf_size": ["cb_length", "uf_fee", "buf_number", "buf_speed", "cb_size", "cb_ize", "buf8Size", "buf_length", "buf_no", "uf_speed", "bufibfee", "cb_SIZE", "bufibSize", "uf_Size", "uf_number", "buf_SIZE", "buf_Size", "buf_fee", "bufibspeed", "buf_ize", "uf_no", "buf8size", "buf8number", "buf8no", "bufibsize", "uf_size"], "vop_found": ["vop67forced", "vop5present", "vop___forced", "vomp_tested", "voplyfound", "vomp_found", "vap_Found", "vopLallowed", "vop___result", "voptLfind", "voop_fixed", "vop_present", "vopptfind", "vop_forced", "voom_found", "vop67for", "vomp_present", "vap_found", "voom___found", "voplyfd", "vopptpacked", "voom___sold", "vop_packed", "voptLallowed", "vop67find", "vop_result", "vok_fd", "voom___kept", "vopt_find", "vopt_found", "vop___given", "vop___packed", "vopt_full", "vop_kept", "vrop_for", "vopLfound", "vap_printed", "vopptmatched", "voom_kept", "vopCfounded", "voptLfull", "vopCpresent", "vop5tested", "vok_found", "vop___matched", "vop_failed", "vop_allowed", "vop_fixed", "vomp_founded", "vok_changed", "vop67sold", "vopLfind", "vopptfixed", "vop_Found", "vopLfull", "vop_given", "vop___found", "vrop_found", "vok_failed", "vop_printed", "vap_needed", "voop_packed", "vopCfound", "vop___kept", "vop_full", "vop_matched", "vop_tested", "vop5founded", "vop_find", "vop_changed", "voom___forced", "vop_needed", "vop5found", "vop_for", "vopptfound", "vopptfull", "vopptallowed", "vop67fd", "vop_fd", "voplychanged", "vop_founded", "vop___fixed", "vop67kept", "vop___sold", "vrop_fd", "vopCtested", "vop67found", "voop_result", "voptLfound", "voop_matched", "vrop_find", "voop_found", "vopt_allowed", "voop_given", "voom_forced", "voplyfailed", "voom_sold", "vop_sold"], "i": ["at", "multi", "ori", "iat", "ei", "ims", "mi", "info", "ir", "uri", "phi", "ip", "ri", "Index", "ini", "ind", "ii", "x", "pi", "io", "f", "ki", "im", "o", "z", "zi", "it", "l", "qi", "iu", "iter", "di", "in", "print", "k", "u", "ik", "is", "hi", "m", "me", "si", "to", "xi", "init", "status", "point", "ai", "g", "ui", "li", "iri", "ci", "ix", "p", "start", "parent", "id", "n", "y", "ij", "ti", "c", "gi", "ic", "cli", "sim", "out", "ji", "bi", "e", "oi", "index", "eu", "I", "ami", "ia", "ex"], "j": ["jj", "json", "at", "aj", "je", "by", "dj", "jl", "pt", "ng", "J", "ge", "other", "ind", "ch", "block", "try", "q", "o", "z", "uj", "jp", "mn", "d", "it", "l", "att", "b", "jc", "jo", "di", "k", "bj", "ed", "adj", "jump", "v", "js", "m", "my", "ja", "ev", "br", "fr", "er", "r", "res", "g", "li", "note", "obj", "el", "jit", "str", "err", "th", "bo", "ix", "p", "pr", "gov", "ion", "n", "y", "ij", "s", "c", "t", "ie", "out", "ji", "bi", "index", "kj", "ne"], "bits_left": ["bits_loc", "bits_length", "bits08entry", "fits_low", "bytes_found", "fitsityleft", "bytes_right", "bitsptfound", "bytes_needed", "bitsptlow", "bits08left", "files_left", "bit_enabled", "bits_enabled", "files_Left", "bits_right", "fits_needed", "bitsityleft", "bitsitylower", "fits_left", "bits_lt", "files_l", "fitsitylow", "bitspleft", "bits_lower", "bitslentry", "bitsitylow", "bits08length", "bitslleft", "bits32loc", "bits32right", "bits_low", "bitsityneeded", "bits_needed", "bit_entry", "ports_last", "bitspfound", "ports_left", "bits08enabled", "bits_found", "files_lt", "bits32left", "bitsllength", "ports_low", "bits_entry", "bits_l", "bit_length", "bitslenabled", "fits_lower", "bitspneeded", "bs_left", "bitspright", "bits_last", "bitsptleft", "bs_right", "bitsptlast", "ports_found", "fitsityneeded", "bytes_left", "bit_left", "bs_loc", "bits_Left", "fitsitylower"], "last_bits": ["last___bits", "last___pins", " last_bis", "last___bytes", "first_parts", "last\u0648bit", "last\u0648bugs", "last88stats", " last_stats", "last_bytes", "last__bps", "last_parts", "last\u0648bits", "last88bis", "last80stats", "first_pins", "last___bit", "first_bit", "first_bytes", "last__bytes", " last_bytes", "last___bugs", "last_bps", "last_bugs", "last\u0648blocks", "last88bits", " last_bit", "last80bis", "last80bits", " last_bps", " last_bugs", "last80bytes", "last_pins", "last88bytes", "last___bps", "last_bit", "last__bits", "last_bis", "last__bugs", "first_bits", "last_stats", " last_blocks", "last_blocks"], "state": [" code", "name", "memory", "type", "user", "can", " step", "conn", "test", "info", "mode", "what", "stats", "set", "where", "store", "color", "instance", " event", "queue", "resource", "st", "block", "trace", "list", "try", "data", "State", "be", "reason", " offset", " ignore", "tag", "range", "cache", "ps", "it", "component", "l", "we", "scope", "config", "STATE", "in", "print", "loop", "map", "error", "frame", "position", "see", "ping", " score", "hash", "comment", "local", " family", "powered", "is", "temp", " port", "public", "te", " timeout", "or", "length", "power", "port", "debug", "ace", " msg", "to", " action", "states", "offset", "init", "status", " block", "location", " key", " start", "timeout", "version", " choice", "msg", "al", " err", " body", " status", "policy", "rule", "err", "sequence", "progress", "stat", "zone", " speed", "close", "spec", "description", " error", "start", "id", " name", "value", " policy", "style", "result", "lock", "size", "update", "buffer", "key", "ns", " size", " rule", "out", "handle", "code", "all", "base", "index", "commit", "ne", "val"], "h": ["ctx", "hi", "kh", "m", "hr", "p", "hz", "zh", "o", "here", "oh", "ih", "ah", "ph", "hm", "l", "has", "hd", "ht", "b", "rh", "dh", "sh", "c", "history", "he", "eh", "uh", "enh", "host", "t", "bh", "H", "hp", "hash", "hs", "hh", "hal", "hl", "ch", "http", "hw", "v", "comm"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void address_space_write(AddressSpace *as, target_phys_addr_t addr,\n\n                         const uint8_t *buf, int len)\n\n{\n\n    address_space_rw(as, addr, (uint8_t *)buf, len, true);\n\n}\n", "idx": 20743, "substitutes": {"as": ["js", "ast", "ias", "As", "AS", "ass", "es", "asa", "bs", "rs", "nas", "am", "las", "ak", "ps", " es", "sis", "aw", "sa", "ms", "sac", "an", "s", "oss", "aos", "aus", "ar", "ns", "asm", " us", "a", "ase", "ach", "os", "pas", "ars", "is", "ras"], "addr": ["ac", "arp", "add", "adr", "alt", "at", "pad", "loc", "ag", "ptr", "src", "on", " address", "wid", "attr", "dh", "address", "r", "tx", "ord", "wd", "cmd", "dr", "act", "pos", "ar", "ip", "ref", " plat", "align", "coord", "off", "obj", "mem", "x", "hw", "err", "urg", "ad", "ack"], "buf": ["uf", "data", "seq", "bag", "box", "bc", " buffer", "Buffer", "bytes", "que", "etc", "result", "b", "doc", "buff", "raw", "cmd", "img", "map", "buffer", "ref", "vec", "pb", "Buff", "window", "late", "cv", "uffer", "mem", "arr", "queue", "aka", "batch", "new", "alloc", "cap", "block", "cb", "v", "bn"], "len": ["lf", " l", "num", " length", "seq", "L", "length", "loc", "ln", "n", "bytes", "wid", "pl", "Len", "l", "fin", "nl", "lan", "lit", "fil", "nt", "pos", "size", "en", "vec", "count", " clen", "el", "hl", "ll", "mem", "h", " bl", "lp", "lang", "elt", "kl", "val"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void audio_run_capture (AudioState *s)\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        int live, rpos, captured;\n\n        HWVoiceOut *hw = &cap->hw;\n\n        SWVoiceOut *sw;\n\n\n\n        captured = live = audio_pcm_hw_get_live_out (hw);\n\n        rpos = hw->rpos;\n\n        while (live) {\n\n            int left = hw->samples - rpos;\n\n            int to_capture = audio_MIN (live, left);\n\n            st_sample_t *src;\n\n            struct capture_callback *cb;\n\n\n\n            src = hw->mix_buf + rpos;\n\n            hw->clip (cap->buf, src, to_capture);\n\n            mixeng_clear (src, to_capture);\n\n\n\n            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n                cb->ops.capture (cb->opaque, cap->buf,\n\n                                 to_capture << hw->info.shift);\n\n            }\n\n            rpos = (rpos + to_capture) % hw->samples;\n\n            live -= to_capture;\n\n        }\n\n        hw->rpos = rpos;\n\n\n\n        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {\n\n            if (!sw->active && sw->empty) {\n\n                continue;\n\n            }\n\n\n\n            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {\n\n                dolog (\"captured=%d sw->total_hw_samples_mixed=%d\\n\",\n\n                       captured, sw->total_hw_samples_mixed);\n\n                captured = sw->total_hw_samples_mixed;\n\n            }\n\n\n\n            sw->total_hw_samples_mixed -= captured;\n\n            sw->empty = sw->total_hw_samples_mixed == 0;\n\n        }\n\n    }\n\n}\n", "idx": 20751, "substitutes": {"s": ["js", "gs", "spec", "ssl", "sl", "ls", "sn", "sq", "p", "sp", "rs", "sb", "ps", "sc", "fs", "sm", "ds", "spe", "sa", "c", "r", "as", "ses", "ts", "ss", "ys", "t", "set", "sim", "sing", "sts", "sv", "sys", "h", "sg", "os", "se", "S", "space", "is", "v"], "cap": ["CAP", "vc", "sp", "pp", "cast", "can", "copy", "prop", "aw", "chip", "acl", "grab", "ip", "buf", "cam", "sam", "ch", "cod", "cv", "ac", "cp", "ctx", "gc", "ctrl", "qu", "pan", "cc", "cl", "co", "mp", "serv", "tap", "shape", "map", "capt", "amp", "ap", "cu", "ach", "aps", "cr", "ape", "cn", "av", "craft", "com", "hap", "wp", "act", "snap", "window", "comm", "ct", "cfg", "ca", "bc", "clip", "w", "wa", "ab", "pl", "Cap", "spe", "sh", "c", "wav", "vp", "cmd", "sv", "cf", "addr", "cmp", "caps", "ipp"], "live": ["sp", "lo", "full", "hot", "ld", "lit", "Live", "sam", "ind", "fps", "ls", "d", "visible", "l", "mp", "tight", "nl", "living", "life", "iter", "ive", "lived", "sample", "ed", "lt", "ife", "len", "mid", "latest", "high", "hi", "sl", "enabled", "here", "length", "low", "lim", "max", "available", "load", "online", "act", "shot", "active", "watch", "fresh", "loaded", "hl", "valid", "liv", "locked", "le", "ctl", "old", "id", "player", "linked", "y", "pl", "bound", "line", "vp", "i", "only", "t", "prime", "db", "ref", "gt", "addr", "ready", "val"], "rpos": ["rPos", " rp", "lrpos", "pp", "rport", "rpl", "mrloc", "rpid", "rarpl", "lrcon", "lpt", "rcpos", " rposition", "ppt", "vrpt", "mrpose", "vrposition", "srpos", "lloc", "rcloc", " rPOS", "vrpro", "erport", "rloc", "Rpid", "mrpos", "pport", "lpo", "srpo", "Rpt", "rarpor", "mrpo", "lpid", "rpose", "lrpro", "vrcol", " rpor", "rp", "rpo", "erp", " rpo", "vrpos", "RPos", "srpor", "mrPos", "lpose", "erpt", "Rloc", "lpro", "Rpos", " rpl", "mrpl", "erpos", "rarpos", "rarpo", "srPOS", " rpt", "lposition", "rcpt", "rposition", "rarpt", "rpt", "Rpo", "vrcon", "rarPOS", " rpid", "ppos", "ppo", "rpro", "rarposition", " rPos", "ppose", "rcol", "rPOS", "lpl", "rpor", "ploc", "lcon", "rcpid", "lrcol", " rport", "mrpt", " rloc", "lcol", "rcon", "vrpl", "lpos", "mrposition"], "captured": [" captached", "captored", "paured", "configired", " capturized", "censired", "configurable", "Captored", "capture", "captached", "Captached", "capturated", "aptired", "mittorted", "apturable", "aptored", "censured", "quantuated", "capuated", "collecturable", "caported", "aptured", "capturized", " capturred", "censurred", "apturred", " capturated", "captpled", "captuated", "mittpled", "configured", "capturred", "paorted", "collecturized", " capture", " captored", "capturable", "quantured", "quantorted", "apturized", "collectorted", "collectuated", "paurred", "capured", "apture", "apturated", " captpled", "captorted", "collecturated", "Captured", "quantified", "collectified", "aptached", "papled", "configurred", "captired", "mittured", "Capture", "censurable", "captified", "capified", " capturable", " captorted", "censurated", "collectured", "mitturred"], "hw": ["pkg", "vc", "fw", "rew", "wit", "conn", "hm", "mg", "aw", "chip", "rh", "wind", "ow", "hop", "cam", "wcs", "rpm", "wx", "cv", "ctx", "nw", "hz", "iw", "ih", "wb", "ww", "ht", "hd", "we", "psc", "bh", "wi", "ew", "hh", "cu", "wy", "shake", "wm", "health", "rw", "ich", "craft", "wp", "hap", "hip", "kw", "wd", "lv", "igh", "aws", "watch", "window", "mph", "hs", "hl", "wn", "ha", "wo", "w", "haw", "wa", "dh", "sh", "vp", "wr", "vr", "mem", "h", "addr", "wl", "cmp", "wk"], "sw": ["wn", "wh", "wo", "nw", "wrap", "sn", "sl", "ssl", "so", "sp", "ev", "iw", "fw", "tr", "w", "sb", "rew", "sql", "nn", "qu", "tw", "syn", "sc", "wa", "rw", "warn", "ww", "sm", "aw", "we", "sa", "wt", "sh", "wp", "ess", "ow", "serv", "kw", "ss", "oss", "was", "watch", "amp", "ew", "ssh", "swe", "snap", "window", " SW", "sam", "ch", "sv", "sr", "sf", "esp", "se", "sys", "SW", "sk", "squ", "Sw", "wx", "th", "sd"], "src": ["ctx", "inst", "sl", "sn", "sq", "sp", "input", "rs", "bs", "sel", "loc", "supp", "tmp", "sb", "ptr", "url", "sc", "iv", "attr", "ser", "lr", "sh", "rt", "buff", "img", "bh", "rb", "buffer", "vr", "txt", "std", "buf", "ipl", "obj", "hl", "source", "ctr", "conv", "sr", "rl", "str", "sg", "sf", "sys", "addr", "usr", "new", "sur", "fp", "rc"], "cb": ["ctx", "cp", "cfg", "cr", "CB", "callback", "bb", "erb", "eb", "nb", "vc", "bs", "cn", "ub", "bc", "ctrl", "tmp", "sb", "wb", "gb", "nc", "cm", "conn", "cc", "cod", "ob", "b", "c", "kw", "tk", "lc", "buff", "bt", "cmd", "CU", "obb", "ec", "func", "db", "bj", "rb", "cd", "abb", "pb", "lb", "buf", "job", "zb", "obj", "abc", "ch", "cu", "bf", "conv", "cf", "rc", "fb", "cmp", "cell", "cv"]}}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761, "substitutes": {"chr": [" cher", "chebr", " charar", " charrc", " chear", "Char", "chbr", " chrt", " chro", " charrt", "chero", "Chrc", " charr", "chrc", "Chr", " chero", "chrt", "Chrt", " chbr", " chebr", "chear", " chrc", "chro", "cher"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n", "idx": 20766, "substitutes": {"base": ["m", "basic", "family", "parent", "start", "bs", "state", "p", "id", "name", "type", "bid", "length", "bp", "scale", "offset", "based", "init", "cpu", "bound", "prefix", "b", "max", "root", "address", "top", "i", "server", "size", "set", "buffer", "key", "ref", "create", "mb", "store", "balance", "out", "Base", "ase", "zero", "bf", "local", "index", "x", "back", "bas", "v"], "irq": ["nirq", "ibrq", "irqq", "nirqu", "irql", " arqq", " irqu", " arql", " irqq", "ibrql", " virq", " arq", "irqu", " virqq", "ibrqu", " virqu", " arqu", " virql", "ibrqq", "nirqq"], "version": ["VERSION", "command", "vector", "spec", "generation", "family", "direction", " versions", "depth", "supported", "type", "length", "power", "ver", "ion", "ception", "value", "release", "component", "status", "ision", "versions", "mode", "vers", "feature", "VER", "date", "order", "format", "vision", "step", "server", "Version", "position", "hash", "number", "level", "time", "development", "major", "index", "package", "sequence", "class", "v"], "dev": ["p", "data", "ve", "ev", "pad", "tr", "Dev", "w", "d", "ver", "Device", "def", "eng", "des", "av", "DEV", "test", "ds", "att", "sky", "gu", "sh", "an", "serv", "dis", "enc", "di", "nt", "cmd", "go", "pt", "dn", "det", "res", "pro", "cho", "dem", "ed", "dd", "de", "device", "DE", "md", "out", "obj", "ch", "mem", "ach", "adv", "sys", "new", "die", "priv", "ad", "vo", "ex", "th", "sd", "v", "val"], "s": ["js", "gs", "m", "sl", "ls", "sq", "p", "sp", "es", "rs", "bs", "us", "z", "sb", "vs", "n", "ps", "fs", "sm", "ds", "self", "l", "sa", "b", "ms", "sh", "cs", "ts", "ss", "stats", "g", "ns", "ins", "its", "socket", "hs", "sam", "sts", "sv", "sys", "h", "os", "S", "als", "sd", "is", "comm"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len / 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 20797, "substitutes": {"cpu": ["ctx", "cp", "pkg", "gc", "tp", "p", "linux", "CPU", "xc", "arch", "ka", "tc", "project", "conn", "nc", "vm", "aq", "exe", "ork", "uu", "proc", "c", "core", "gpu", "worker", "gnu", "aco", "bean", "processor", "mac", "aux", "bench", "nu", "apache", "uart", "docker", "t", "net", "frame", "pc", "ruby", "cli", "ck", "cv", "client", "process", "socket", "ean", "cu", "mem", "rpm", "kernel", "sys", "x", "nz", "os", "nan", "exec", "queue", "hw", "clock", "alloc", "runner", "eu", "pu", "stat", "boot", "rc"], "r1": ["attr3", "R2", " r8", "r5", "nr3", " raj", "nr5", "r9", "nr9", "rc5", " r2", "ar8", "raj", "nr8", "R9", " r01", "R1", "ar1", "R3", "nr01", "r0", "ar01", "p1", "rc0", "rc1", "r01", "rc9", "r8", "ar3", "nr1", "r2", "rc3", "R0", " r0", "attr2", "p3", "nr2", "nrOne", "Raj", "attraj", "rOne", "rc2", "p2", " r9", "rcOne", "ROne", "attr1", " r5"], "r3": ["R2", "R4", "r12", "pr12", " r2", "t6", "R3", " r12", " r6", "pr2", "r2", "r6", "p3", "t3", " r4", "R6", "t2", "r4", "t4", "p12", "p2", "pr3"], "gaddr": ["gmaddress", "bgaddress", "bgarch", "giaddr", "gptr", "gaddress", "bgaddr", "gmptr", "garch", "giptr", "bgptr", "giaddress", "gmarch", "giarch", "gmaddr"], "ar": ["ta", "dar", "arp", "ra", "bar", "par", "am", "or", "ara", "aster", "ear", "are", "ray", "tar", "AR", "er", "r", "atar", "ir", "dr", "rar", "ai", "var", "al", "arr", "rr", "star", "ars", "arc"], "env": ["pkg", "equ", "end", "viron", "sp", "ve", "conf", "shell", "esm", "pe", "eng", "conn", "ei", "ext", "environment", "worker", "eh", "org", "server", "extra", "home", " environment", "et", "buf", "queue", "hw", "gear", "docker", "erd", "cv", "ctx", "stage", "eni", "web", "vs", "den", "vm", "enter", "era", "site", "doc", "config", "serv", "ec", "uv", "net", "en", "ew", "desc", "kernel", "priv", "v", "dev", "state", "ev", "here", "engine", "req", "console", "ka", "nc", "oe", "init", "er", "stack", "network", "txt", "outer", "window", "obj", "el", "esp", "ee", "exec", "kh", "spec", "eg", "entry", "esc", "ah", "vp", "tx", "sw", "cmd", "t", "ie", "db", "nv", "code", "event", "e", "context", "eu", "Environment"], "pbdev": ["pbby", "bpDev", "PBdev", "lpdev", "ubdevice", "pbDev", "bpder", "fbval", "objdev", "lpserv", "pcder", "pcby", "PBdes", "objDev", "bpdes", "bpserv", "pbdef", "ubobj", "pgdevice", "pgval", "cpby", "lpdriver", "cbDev", "cbdes", "fbdevice", "pbder", "pbobj", "ubserv", "PBDev", "cbdevice", "bpdevice", "ubdev", "ubDev", "pbdriver", "PBdevice", "pbserv", "cpdev", "cpdef", "cbval", "cbobj", "ubdriver", "cbserv", "objobj", "pgdev", "fbdiv", "bpby", "pgdiv", "PBdiv", "pgDev", "pbdiv", "lpdevice", "pbdes", "cbdev", "pcdef", "cpder", "bpdev", "fbdev", "bpdriver", "objserv", "pcdev", "bpdef", "pbdevice", "pbval", "cbdiv"], "mr": ["hr", "m", "dar", "kr", "ur", "adr", "rs", "tr", "mn", "br", "fr", "mc", "Mr", "rn", "ocr", "lr", "bm", "r", "gr", "dr", "shr", "drm", "rar", "tur", "rb", "mor", "vr", "ml", "rpm", "sr", "usr", "MR", "rg", "rr", "rm", "mir", "wm", "mt"], "i": [" vi", " ti", "ci", "p", "si", " bi", " si", " mi", " di", "ei", "l", "r", " v", "j", "di", " pos", " I", "li", " p", " j", "a", "ii", "x", "I", " ni", "f", "v", " pi"], "fh": ["fdoh", " fH", "bch", "cfw", "fw", "ufch", "bc", "bw", "cfhi", "sfoh", "fdh", " fhandle", "lfc", "fH", "tfx", "fhs", "ffhl", "ffoh", "fekh", " fkh", "tfhandle", "fc", "fdhl", "sfh", "lfh", "dfhandle", "fhd", "ufw", "foh", "ffh", "fhl", "dfx", "fkh", "ffhs", "tfkh", "dfh", "bH", " fx", "bh", "tfH", "fth", "sfhs", "fec", "fhandle", "lfth", "tfc", "tfhd", "cfch", "cfh", "fdhs", "dfH", "feh", "sfhl", "bth", "ufh", "fhi", "ufhi", " fth", "lfH", " fhd", "fehd", "fch", "bhi", "tfh", " fc", "fx"], "pcias": ["piiAS", "pfiAS", "Pdios", "pdias", "pcuasy", " pdiasa", "pcuas", "ppios", "pciAs", "piiuna", "Pcios", "pfiAs", " pciasa", " piiAs", "pdios", " ppiAS", "ppiAS", "pvias", " piiuna", " pciAS", "piiasy", " piias", "pfias", " pdiAs", "pdiasa", "ppiac", " ppiAs", "pdiac", "pcuAS", "Pcias", "ppias", "piiAs", " pdiAS", " piiAS", " pciuna", "pdiuna", " pciAs", "piiasa", "pciuna", "piia", "pdia", "pdiAs", "pciasa", " ppias", " ppiasy", "pcios", "pviAS", " pciasy", "piiac", "pviAs", "ppia", "piios", "Pcia", "pviuna", "ppiasy", "pciasy", " pdias", "ppiAs", "pciac", "pfiasa", "pdiAS", "pcuAs", "Pciac", "piias", "Pdia", "pciAS", "Pdiac", "pcia", "Pdias"], "len": ["list", "spec", "sl", "ls", " length", "seq", "L", "fl", "name", "length", "mn", "loc", "ln", "n", "bytes", "lim", "abl", "lon", "Len", "l", "fin", "lic", "ret", "limit", "nl", "lib", "lc", "lan", "iter", "nt", "format", "pos", "size", "lis", "en", "dl", "li", "lt", "ref", "il", "lig", "ml", "late", "el", "hl", "ll", "mem", "str", "lp", "wl", "lang", "err", "elt", "cmp", "coll", "kl", "le", "val"], "buffer": ["command", "word", "length", "ptr", "cache", "Buffer", "region", "result", "address", "buff", "header", "pointer", "shape", "size", "message", "match", "stream", "ref", "count", "window", "buf", "base", "byte", "batch", "array", "cap", "block"]}}
{"project": "qemu", "commit_id": "293d2a0014a0e849477413f55aaa05f2743b2e04", "target": 0, "func": "static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,\n\n                                  void *opaque)\n\n{\n\n    monitor_flush(opaque);\n\n    return FALSE;\n\n}\n", "idx": 20802, "substitutes": {"chan": ["ctx", "chn", "Ch", "bin", "can", "anon", "ann", "conn", "chain", "proc", "an", "c", "tx", " ch", "focus", "cmd", "act", "pipe", "Channel", "txt", "con", "channel", "Chan", "obj", "ch", "ach", "mon", "err", "cb"], "cond": ["ctx", " whence", " code", "reason", "bc", " fut", "Condition", "Cond", " thread", " why", "proc", "c", "tx", " reason", "cmd", " condition", " pos", "pos", " exc", " Cond", " flock", " conditions", "code", " interrupt", "condition", " conditional", " proc", " chain"], "opaque": ["opaques", "OPane", "opacity", "ipaques", "OPaque", "OPaques", "opque", " opacity", "obaque", "ipacity", "obacity", "OPacity", "boane", "obque", " opque", "obade", "popacity", "popaque", "ipane", "boacity", "popque", " opade", "ipaque", "popade", "boaque", "boaques", "opade", "opane"]}}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static always_inline void gen_store_spr(int reg, TCGv t)\n\n{\n\n    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));\n\n}\n", "idx": 20803, "substitutes": {"reg": ["eg", " REG", "mod", "pr", "req", "loc", "ld", "tag", "eng", "typ", "rem", "Reg", "region", "ret", "attr", "tab", "grid", "ig", "order", "res", "db", "pc", "REG", "key", "ref", "re", "sec", "row", "ind", "leg", "mem", "rec", "rule", "addr", "stat", "cell", "im"], "t": ["ta", "m", "tp", " T", "p", "vt", "o", " g", "tr", "tt", " ts", "kt", "w", "d", "tc", "tree", "tg", " ot", "n", "y", "l", "b", "task", "rt", "c", "r", "tx", "ts", "j", "T", "k", "g", "u", " td", "tn", "txt", "f", "out", "a", "obj", " x", "e", "h", "st", "mt", " tc", "v"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_is_read_only(BlockDriverState *bs)\n\n{\n\n    return bs->read_only;\n\n}\n", "idx": 20811, "substitutes": {"bs": ["ls", "bb", "bing", "bc", "ba", "bes", "sb", "vs", "bp", "bis", "fs", "acs", "blocks", "ds", "b", "s", "as", "iss", "ses", "ib", "ts", "ss", "aos", "bles", "bh", "bl", "sbm", "BS", "ubs", "ns", "cks", "pb", "its", " BS", "ks", "hs", "obs", "bi", "qs", "bos", "lbs", "bd", "bas", "is", "bn"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bw_conf1_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    PCIBus *b = opaque;\n\n    pci_data_write(b, addr, val, size);\n\n}\n", "idx": 20812, "substitutes": {"opaque": ["tainaque", "iopaque", "opaques", "iopument", "opaco", "OPacle", "boque", "OPaque", "tainque", "OPaques", "opque", "iopque", "OPque", "obaque", "ankque", "boument", "ankaco", "opacle", "obque", "ankument", "boaco", "tainaques", "opument", "obacle", "obaques", "iopaco", "boaque", "ankaque", "tainacle"], "addr": ["ctx", "ac", "add", "Address", "adr", "alias", "rs", "id", "pad", "loc", "ptr", "ace", "src", " address", "wid", "offset", "inter", "attr", "dh", "rt", "address", "r", "tx", "ord", "cmd", "host", "dr", "pos", "ref", "ident", "var", "align", "store", " plat", "coord", "work", "handle", "x", "hw", "ad", "mt", "ack", "help", "fx"], "val": ["ctx", "vt", "aval", "data", "grad", "ival", "p", "loc", "sol", "value", "vol", "VAL", "tx", " v", "lit", "serv", " arg", " value", "eval", "res", "Val", "msg", "ref", "al", "resp", "buf", "bal", " aval", "len", "rol", "arg", "mem", "index", "cal", "vals", "valid", " eval", "v"], "size": ["ity", "height", "sn", "sent", "sq", "sp", "body", "name", "type", "SIZE", "length", "small", "scale", "n", "Size", "offset", "c", "send", "empty", "sum", "shape", "gz", "message", "count", "len", "sha", "mem", "index", "ize", "weight", "fee", "space", " Size", "sd", "iz"], "b": ["m", "bb", "p", "eb", "bar", "bs", "be", "ub", "bc", "BA", "ba", "bid", "d", "sb", " a", "gb", "bp", "br", "y", "ab", "l", " ab", "bound", "ob", "B", "c", "r", "j", "i", "bh", "db", "g", "rb", " B", "mb", "a", "base", "ch", "h", "fb", "f", "v"]}}
{"project": "qemu", "commit_id": "54ca9095f046dfa03c3d093cc55f6d76b61864e1", "target": 0, "func": "void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    int ret;\n\n    unsigned long pc;\n\n    CPUX86State *saved_env;\n\n\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);\n\n    if (ret) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc, NULL);\n\n            }\n\n        }\n\n        if (retaddr)\n\n            raise_exception_err(EXCP0E_PAGE, env->error_code);\n\n        else\n\n            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);\n\n    }\n\n    env = saved_env;\n\n}\n", "idx": 20831, "substitutes": {"addr": ["ctx", "ix", "arp", "add", "adr", "alias", "rs", "at", "id", "port", "ptr", "url", "src", " address", "offset", "attr", "rt", "address", "r", "ord", "cmd", "host", "act", "ar", "res", "ip", " plat", "align", "work", "handle", "a", "obj", "mem", "x", "rr", "hw", "err", "ad", "mt", "rc"], "is_write": ["iso_writer", "is_control", "is__writ", "iso__control", "is__write", "is___written", "is___writ", "iso_control", "is_writer", "is_written", "iso__write", "is_writing", " is_written", "is_writ", "is__writer", "is__written", " is_writ", "is___control", "is__control", "iso_write", "iso__writer", "is__writing", "is___writer", "iso_writing", "iso__writing", "is___writing", "is___write"], "is_user": [" is_other", "is_client", "is_other", "is_custom", " is_custom", "is___user", " is_username", " is_client", "is___username", "is___other", "is_users", " is_users", "is___custom", "is_username"], "retaddr": [" retptr", "Retadr", "Retstr", "Retptr", "Retexpr", "tryptr", "Retaddr", "retexpr", "altaddress", "retsaddress", "ftadr", "retsaddr", "tryaddr", "tryattr", "retsexpr", "altadd", "resetaddress", " retattr", "retadr", "altptr", " retadd", "resetstr", "ftaddress", "retattr", "ftexpr", "retadd", "ftaddr", "retsadr", "retaddress", "Retaddress", "resetaddr", "altstr", "retptr", "altaddr", "Retadd", "retstr", "Retattr", " retaddress", "tryaddress"], "tb": [" Tbt", "mintbr", "mintbelt", "noteblock", " Tbl", "ptb", "tbr", " tbm", " Tbm", " tpb", "atbp", " Tbp", "atbl", "ptbr", "tbi", " tblock", "ptbi", "ppb", "tbt", "notebb", "pbb", "ttbr", " Tb", "tbp", "mintbi", " tbp", "atb", " Tbb", "atbt", "tpb", " Tpb", "ttbelt", "tbelt", "pb", "noteb", "notebm", " tbt", "mintb", " Tblock", "tbb", "tbl", "pbl", "ttbi", "tbm", "ptbelt", "tblock", "ttb", " tbl", " tbb"], "ret": ["any", "reset", "get", "success", "alt", "rs", "Return", "ter", "tr", "__", "Ret", "jp", "gov", "def", "gb", "backed", "rem", " Ret", "result", "got", "rt", "ry", "xt", "pret", "lit", "ben", "nt", "flag", "ft", "det", "res", "fi", "not", " RET", "rev", "re", "il", "val", "back", "rets", "gt", "arr", "RET", "pas", "ert", "mt", "ne", "cont", "rc", "ct"], "pc": ["ctx", "cp", "pid", "gc", " PC", " cs", "tp", "p", " pas", " cp", "isc", "vc", "pr", "pad", "bc", "port", "ptr", "tc", " sc", "bp", "pan", "ps", "nc", "mc", "cc", "phy", "sc", " cc", " xp", " lac", " dc", "proc", "c", "cs", "asc", "fc", "mac", "lc", " ac", " rc", "psc", "point", "pt", "pointer", " pac", " p", "pa", "pn", "dc", "pb", "pod", "PC", "ping", "cam", "pic", " pad", "lp", "pi", " proc", "px", "arc", "pg", "rc"], "saved_env": ["saved_environment", "saved___proc", "saved2mem", "saned_state", "saved_mem", "save_conn", "saned___state", "saved___env", "saved___mem", "saved2env", "saved___environment", "saned_environment", "saned_env", "saned___environment", "save_mem", "saved2conn", "saved_state", "saved_en", "saved_proc", "saved_conn", "saved___conn", "save_env", "saved___state", "saned___env", "saved___en"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 20835, "substitutes": {"d": ["dev", "m", "done", "dat", "p", "data", "del", "o", "q", "dx", "debug", "ld", "def", "pd", "n", "y", "dt", "fd", "dj", "ds", "l", "dict", "self", "b", "dh", "info", "s", "c", "du", "r", "j", "di", "da", "dr", "i", "t", "ded", "dm", "dn", "args", "db", "dl", "nd", "ed", "dc", "dd", "od", "de", "md", "a", "e", "ind", "h", "D", "dq", "rd", "bd", "ad", "sd", "draw", "df"], "val": ["ctx", "dev", "num", "ix", "vt", "p", "data", "ival", "ve", "pr", "bo", "value", "it", "rem", "test", "status", "b", "vol", "VAL", "tx", "pret", "pt", "eval", "t", "res", "reg", "bl", "Val", "cho", "key", "pol", "ref", "vec", "var", "il", "al", "bal", "resp", "len", "buf", "el", "arg", "ind", "mem", "arr", "index", "x", "addr", "vals", "elt", "err", "valid", "v"], "ret": ["cert", "alt", "ter", "tr", "Ret", " fut", "def", "gb", "it", "rem", "inter", "bit", " Ret", "result", " resp", "rt", "ts", "nt", "flag", "cmd", "t", "ft", "res", "reg", "repl", "not", " res", " RET", "lt", "rev", "ref", "re", "back", "resp", "out", "arg", "leg", "ctr", "rets", "gt", "arr", "x", "nz", "bool", "comb", "elt", "RET", "valid", "ert", "cont"]}}
{"project": "qemu", "commit_id": "95c3df5a24e2f18129b58691c2ebaf0d86808525", "target": 1, "func": "block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n", "idx": 20840, "substitutes": {"format": ["command", "spec", "old", "p", "family", "data", "api", "file", "atter", "at", "name", "sort", "type", "qt", "reason", " Format", "parse", "pretty", "padding", "unit", "tag", "module", "service", "layout", "l", "status", "feat", "att", "style", "prefix", "text", "mode", "settings", "fn", "fc", "feature", "config", "template", "act", "version", "method", "size", "set", "error", "MAT", "Format", "color", "options", "pattern", "source", "form", "option", "policy", "ats", "op", "title", "err", "fp", "mt", "f", "v"], "QemuOpts": ["QemusOpts", "QemuObjectOptions", "QemusOptS", "QemuOptS", "QemuLogSpec", "QemuOptOptions", "QemusLogSpec", "QemuObjectSpec", "QemuObjects", "QemuLogs", "QemuObjectS", "QemusLogs", "QemusLogS", "QemusOptOptions", "QemusLogOptions", "QemusOptSpec", "QemuOptSpec", "QemuLogOptions", "QemuLogS"], "ov": ["uph", "fo", "tv", "kov", "om", "oc", "ev", "uj", "iov", "oh", "gov", "av", "iva", "va", "iv", "rov", "dj", "sov", "ovi", "OV", "ob", "orf", "oo", "ove", "og", "ow", "erv", "vp", "lov", "oven", "uv", "ever", "iev", "vg", "vr", "van", "aven", "ova", "off", "nv", "nov", "uo", "oval", "sv", "oi", "oid", "vo", "over", "mt", "ovan", "cv"], "ret": ["temp", "gc", "reset", "uf", "report", "ert", "p", "alt", "rs", "memory", "tr", "Ret", "jp", "vet", "tmp", "def", "dt", "it", "rem", "att", "result", "ob", "rep", "rt", "ry", "r", "lit", "j", "nt", "cmd", "pt", "print", "t", "ft", "det", "res", "reg", "g", "fi", "buffer", "tn", "lt", "txt", "ref", "rev", "re", "resp", "buf", "out", "obj", "ll", "arg", "rets", "mem", "gt", "OUT", "usr", "ber", "rc", "new", "err", "rm", "elt", "RET", "back", "mt", "f", "opt", "val"], "local_err": ["local_iter", "internal_err", "local3init", "local____out", "loc_ok", "locpyok", "localpyerr", "local3r", "where___eas", "local_errors", "where_rr", " local_error", "internal_r", "local____err", "loc_err", "error_err", "locpyerrors", "oldpyreq", "localpyout", "localErobj", "localErreq", "loc_msg", "error___priv", "where___bg", "where___rr", "local___priv", "local____req", "oldpyerr", "errormyev", "localpyok", "local___error", "local___er", "localMEr", "local_rr", "localmyerr", "local___eas", "error_priv", "localErmsg", "local_Er", "error_ev", "error___er", "loc_eas", "loc_rr", "localMiter", "localMemer", "localErerr", "localErok", "local___bg", "local_er", "local_msg", "old_err", "oldpyout", "local_r", " local_attr", "oldpyobj", " local_result", "localMemresult", "locpyerr", "old_obj", "where_bg", " local_iter", "localErout", "local_priv", "localpyobj", "localMemrr", "where_eas", "local_attr", "local_bg", "local_ev", "localErerrors", "local_init", " local_er", "local_error", "localMemmr", "local_out", "local_result", "local___attr", "local_ok", "where_err", "old_out", " local_mr", "error_obj", "local_eas", "localmyobj", "local_mr", "localMembg", "localErev", "error_er", "old_req", "localMerr", "localMemeas", "local3err", "localMemerr", "local___req", "error___err", "internal_init", " local_Er", "localpyerrors", "where___err", "locpymsg", "loc_errors", "local_obj", "localpymsg", "errormyobj", "localpyreq", "local___err", "local____obj", "errormyerr", " local_req", "local_req", "localmyev", "local___rr"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,\n\n                             const int16_t **lumSrc, int lumFilterSize,\n\n                             const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                             const int16_t **chrVSrc,\n\n                             int chrFilterSize, const int16_t **alpSrc,\n\n                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                             uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    if (uDest) {\n\n        x86_reg uv_off = c->uv_off;\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 20856, "substitutes": {"c": ["ctx", "cp", "m", "this", "p", "ca", "v", "conf", "w", "d", "util", "tc", "cache", "n", "cm", "cc", "C", "init", "co", "b", "s", "cs", "fc", "lc", "config", "ec", "t", "ce", "g", "unc", "dc", "con", "e", "ch", "h", "call", "f", "cont", "rc", "ct"], "lumFilter": ["lumeFil", "lumbFil", "lamChannel", "lumbChannel", "lamFil", "LamSort", "lumbFilter", "LamFil", "lamFilter", "LumSort", "lumChannel", "lumSort", "LamChannel", "LumFil", "lamSort", "LumFilter", "LamFilter", "lumFil", "lumeFilter", "lumeChannel", "lumeSort", "lumbSort", "LumChannel"], "lumSrc": ["lumsRC", "lumInsrc", "lumsrs", "lumInsRC", "luminSRC", "lumVSrc", "lumSrs", "luminSrs", "luminVSrc", "lumInsrs", "lumVSrs", "luminVSrs", "luminSrc", "lumSRC", "lumVSRC", "lumsrc", "luminVSRC"], "lumFilterSize": ["lamFilterSize", "lamMaskWeight", "lumControlStyle", "lumMaskStyle", "lumControlSize", "lamFilterWeight", "lumStreamStyle", "lumStreamWeight", "lamFilterStyle", "lumFilterStyle", "lumControlLength", "lumFilterLength", "lamMaskLength", "lumStreamSize", "lumStreamLength", "lamFilterLength", "lamMaskStyle", "lumMaskSize", "lumFilterWeight", "lumControlWeight", "lumMaskWeight", "lumMaskLength", "lamMaskSize"], "chrFilter": ["chrsFil", "CharQuery", "chrFil", "ChrQuery", "charFilter", "chrtFil", "chrtOnly", "ChrFil", "charOnly", "charFil", "CharFil", "chrsOnly", "ChrOnly", "ChrFilter", "chrsFilter", "CharOnly", "chrQuery", "CharFilter", "chrtFilter", "charQuery", "chrOnly", "chrtQuery", "chrsQuery"], "chrUSrc": ["chrVsur", "chrFSRC", "chrbUSrc", "chrSur", "chrbUSfx", "chrUSfx", "chrSRC", "chrUSRC", "chrFSur", "chrbUSRC", "chrbUSur", "chrVsrc", "chrSrc", "chrSfx", "chrVsfx", "chrFSrc", "chrbSRC", "chrbSrc", "chrVsRC", "chrbSur", "chrFSfx", "chrbSfx", "chrUSur"], "chrVSrc": ["chrcVSrc", "chrVSsrc", "chrVsr", "chrcVssrc", "chrSsrc", "chrFSRC", "chrcVSr", "chrVSr", "chrSRC", "chrSr", "chrcVsRC", "chrVsrc", "chrcVSsrc", "chrSrc", "chrVSRC", "chrcVsr", "chrcVsrc", "chrFSr", "chrFSsrc", "chrFSrc", "chrcVSRC", "chrVsRC", "chrVssrc"], "chrFilterSize": ["chrMaskSize", "chrChannelData", "chrMaskType", "chrcBufferSize", "chrcBufferType", "chrBufferSIZE", "chrFilterType", "chrChannelSIZE", "chrcBufferSIZE", "chrMaskData", "chrChannelType", "chrcFilterSize", "chrFilterData", "chrcBufferData", "chrcFilterType", "chrMaskSIZE", "chrcFilterSIZE", "chrBufferData", "chrFilterSIZE", "chrcFilterData", "chrBufferSize", "chrChannelSize", "chrBufferType"], "alpSrc": ["almSrc", "almSvc", "alpVsch", "alpVsvc", "alpSRC", "almSch", "alpDsvc", "alpVsRC", "almDsrc", "alpVsrc", "alpDsrc", "alpDsRC", "almDsch", "almDsvc", "almDsRC", "almSRC", "alpDsch", "alpSvc", "alpSch"], "dest": ["temp", "rest", "spec", "end", "p", "data", "us", "transform", "id", "tr", "loc", "Dest", "port", "w", "d", "master", "trans", "wb", "src", "orig", "dist", "win", "chain", "iter", "origin", "cas", "est", "gate", "dc", "target", "ident", "desc", "window", "out", "source", "mem", "comb", "usr", "st", "table", "v"], "uDest": ["ujThis", "gDesc", "uDesc", "gDest", "ujSource", "uuStream", "iuSource", "uiDest", "nuThis", "uedest", "uuChan", "ujdest", "ucDest", "ueEast", "uiEast", "uNet", "ouStream", "iudest", "uChan", "iuThis", "udest", "nudest", "uuDest", "uThis", "ujDest", "ouNet", "uidest", "iuDest", "ueDest", "uEast", "uiDesc", "uSource", "ucChan", "ucStream", "uuNet", "ueDesc", "nuSource", "nuDest", "ucNet", "ouChan", "gdest", "ouDest", "gEast", "uStream"], "vDest": ["vdest", "bDest", "uDesc", "dDat", "vDecl", "bEast", "Vdest", "uDecl", "bDat", "bdest", "VDesc", "VDecl", "vDat", "VEast", "vEast", "VDest", "vDesc", "VDat", "ddest", "dDest", "dEast", " vDesc", " vDecl"], "aDest": ["AWin", " aDesc", "vaTarget", " aWin", "aaTarget", "vaDest", "aQueue", "aStream", "oWorld", "oLoc", "vaDesc", "ALoc", "aaTrans", "aWorld", "aaDesc", "AQueue", "aaDest", "naDest", "AWorld", "aTarget", " aSource", "oSource", " aStream", "ADest", "aWin", "naStream", "naWin", " aTarget", "vaTrans", "AStream", " aWorld", " aLoc", "naQueue", "aDesc", "ASource", "aTrans", " aTrans", "aLoc", "oDest", " aQueue", "aSource"], "dstW": ["dgestHTML", "destL", "dgestV", "DstD", "destV", "destM", "dltB", " dstB", "dltW", " dltL", "dstD", "drestL", "dstH", "DestV", "dgestW", "dndV", "destHTML", "dblV", " dltV", "dblH", "dndH", "dstM", "DstM", "DstW", " dstL", "dstreamW", "DestHTML", " dstV", "DestM", "dblW", "dgestD", "dblM", "destD", "destW", "DstHTML", "dstB", "DestH", "dstHTML", "DstV", "drestW", "dstreamHTML", "DestD", "dstreamV", "dstV", "drestV", "DestW", "dltL", "dltV", "dndM", "dndW", " dltW", "destB", "dstL", "DstH", "drestB", "dstreamD", "destH", " dltB"], "chrDstW": ["chrLstS", "chrDsetG", "chrDsnSize", "chrDndS", "chrDzW", "chrDzG", "chrDrcS", "chrSstW", "chrDsstG", "chrDsnW", "chrLndS", "chrSstH", "chrDbrB", "chrDndR", "chrDstrW", "chrDstrH", "chrDstoreW", "chrSndWindows", "chrLndR", "chrDrcH", "chrLndH", "chrDbrWindows", "chrDstoreB", "chrDstoreH", "chrDsstSize", "chrDsnG", "chrLstW", "chrDssetP", "chrDstG", "chrDsetP", "chrDsetSize", "chrDstrR", "chrDstS", "chrDstWindows", "chrDzSize", "chrDndW", "chrSstB", "chrDsstW", "chrDsetW", "chrSstWindows", "chrDbrH", "chrDrcW", "chrLstH", "chrDstP", "chrDzP", "chrDbrW", "chrDndB", "chrDstoreWindows", "chrLstR", "chrDssetW", "chrDndH", "chrSndB", "chrDsnP", "chrDstrS", "chrDssetG", "chrDndWindows", "chrDrcR", "chrDstH", "chrDstB", "chrDssetSize", "chrDstSize", "chrDstR", "chrSndH", "chrLndW", "chrDsstP", "chrSndW"]}}
{"project": "qemu", "commit_id": "7a0e58fa648736a75f2a6943afd2ab08ea15b8e0", "target": 0, "func": "static void add_cpreg_to_list(gpointer key, gpointer opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    uint64_t regidx;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    regidx = *(uint32_t *)key;\n\n    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);\n\n\n\n    if (!(ri->type & ARM_CP_NO_MIGRATE)) {\n\n        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);\n\n        /* The value array need not be initialized at this point */\n\n        cpu->cpreg_array_len++;\n\n    }\n\n}\n", "idx": 20902, "substitutes": {"key": ["ctx", "pid", "mk", "id", "name", "type", "req", "path", "password", "port", "Key", "KEY", "ray", "value", "y", "prefix", "max", "info", "ry", "item", "query", "po", "i", "keys", "pointer", "sum", "owner", "k", "ek", "need", "ref", "link", "pri", "hash", "code", "base", "param", "index", "x", "icon", "v"], "opaque": ["ocaques", "opaques", "Opaque", "Opulence", "opulence", "oplaque", "opque", "ocatile", "Opque", "Oposter", "ocque", " opatile", "oplulence", "Opatile", " opque", "oplque", "Opaques", "ocaque", "opposter", "oppque", "oploster", "opatile", "oppulence", " opaques", "oppaque", "oposter"], "cpu": ["ctx", "cp", "pkg", "gc", "tp", "program", " CPU", "p", "np", " cp", "linux", "hz", "jp", "CPU", "rom", "unk", "ka", "util", "conn", "vm", "component", "ocr", "chip", "cum", "proc", "c", "gpu", "core", "worker", "aux", "aco", "processor", "nic", "bench", "print", "prof", "phys", "pc", "ruby", "cli", "php", "process", "cam", "ro", "ram", "ports", "cu", "rpm", "kernel", "sys", "nz", "runner", "cal", "hw", "clock", "alloc", "px", "pu", "pool", "boot", "trace", "cv", "physical"], "regidx": ["regparttx", "regminix", "regiterxx", "regpidy", "regIdix", " regIdxc", "regnamey", "regridx", "regoidtx", "regiterxb", "regfdex", " regidix", "regIdx", " regidxc", " regparttx", " regidtx", "regtryy", "regridxb", " regidxx", "regidxc", " regnameex", "regparty", "regoidy", "regtryx", "regminx", "reginxc", " regfdx", "regridw", "regIdxc", " regpartw", " regidw", " regIdz", "regidxb", "regminz", " regidy", "reginz", "regpidex", " regnamey", "regpartx", " regpartx", "regidy", "regidw", " regIdix", " regidex", " regfdxx", "regIdz", "regnameex", "regidex", "regridxx", "regnameix", "reginix", "regpidix", " regidxb", " regnamex", "reginx", "regidix", " regfdex", "regidxx", "regridtx", "regtryex", " regIdx", "regiterx", " regfdxb", "regtryix", "regoidw", "regpartw", "regfdxx", "regminxc", "regiterex", "regridex", "regoidx", "regidtx", "regfdx", "regridy", " regnameix", "regpidx", "regidz", "regnamex", "regfdxb", " regparty", " regidz"], "ri": ["rin", "hi", "ci", "ra", "rio", "ric", "rik", "rs", "ria", "si", "udi", "zi", "xi", "ti", "mi", "rt", "ry", "uti", "ani", "rir", "r", "di", "RI", "ir", "i", "ni", "ai", "uri", "li", "adi", "pri", "ru", "ro", "ini", "ati", "bi", "ris", "ii", "iri", "pi", "rid", "rm", "vi", "io", "ki", "rc"], "cpreg_array_len": ["cpreg_array2gen", "cpreg_array2Len", "cpreg_arr_length", "cpreg_array_gen", "cpreg_arr_gen", "cpreg_arr_Len", "cpreg_array2loc", "cpreg_array_no", "cpreg_array2no", "cpreg_array2len", "cpreg_array_Len", "cpreg_array_pos", "cpreg_arr_len", "cpreg_arr_pos", "cpreg_arr_no", "cpreg_array2length", "cpreg_arr_loc", "cpreg_array_loc", "cpreg_array_length", "cpreg_array2pos"]}}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_huffman_decode(unsigned char *dest, unsigned char *src)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    int counter = 0;\n\n\n\n    unsigned char bits = *ptr++;\n\n\n\n    while ( val != 0x16 ) {\n\n        if ( (1 << counter) & bits )\n\n            val = src[byte + val - 0x17];\n\n        else\n\n            val = src[val - 0x17];\n\n\n\n        if ( val < 0x16 ) {\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n\n\n        if (counter++ == 7) {\n\n            counter = 0;\n\n            bits = *ptr++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20903, "substitutes": {"dest": ["rest", "end", "tr", "loc", "Dest", "bin", "port", "master", "trans", "orig", "prop", "dist", "result", "ser", "asc", "decl", "iter", "origin", "pointer", "pos", "est", "target", "txt", "vec", "ident", "member", "desc", "buf", "out", "source", "mem", "usr", "str", "addr", "new", "rel", "cont", "v"], "src": ["inst", "sn", "sl", "sp", "rs", "cont", "impl", "seq", "sel", "loc", "length", "supp", "tmp", "sb", "gb", "trans", "sc", "bytes", "iv", "cc", "dist", "ser", "s", "proc", "fc", "lit", "serv", "in", "img", "ripp", "rb", "sub", "stream", "slice", "ins", "cur", "buf", "desc", "sec", "hl", "obj", "source", "ctr", "byte", "sr", "rl", "sys", "usr", "str", "addr", "sur", "st", "gin", "ctl", "rc"], "ptr": ["pointers", "ctx", "rect", "inst", "adr", "sp", "pad", "tr", "req", "loc", "jp", "pert", "ps", "br", "fr", "offset", "dist", "ret", "expr", "rep", "proc", "address", "ts", "iter", "point", "pt", "pointer", "dr", "pos", "prime", "bl", "pc", "pen", "vec", "cur", "coord", "sec", "ctr", "Ptr", "usr", "sys", "arr", "inters", "addr", "rel"], "counter": ["vector", "check", "num", "inner", "creator", "frequency", "ter", "cer", "ier", "length", "per", "console", "magic", "card", "timer", "value", "nc", "offset", "currency", "cover", "chain", "c", "scope", "processor", "ounter", "pointer", "loop", "size", "buffer", "controller", "key", "factor", "atomic", "outer", "count", "over", "con", "comment", "number", "code", "level", "upper", "writer", "zero", "ctr", "context", "TER", "condition", "index", "x", "created", "Counter", "clock", "mask", "nr", "sequence", "cmp", "container", "clear", "term"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)\n\n{\n\n    return t && t->rearm;\n\n}\n", "idx": 20908, "substitutes": {"t": ["ta", "m", "tp", "vt", "p", "te", "q", "o", "at", "td", "tin", "tr", "tt", "w", "d", "tc", "to", "n", "timer", "y", "dt", "it", "tm", "l", "ti", "task", "c", "r", "ts", "tap", "i", "T", "k", "g", "tn", "txt", "mint", "a", "e", "tim", "time", "h", "tf", "st", "f", "v", "ct"]}}
{"project": "FFmpeg", "commit_id": "3dbc0ff9c3e6f6e0d08ea3d42cb33761bae084ba", "target": 1, "func": "static int iff_read_header(AVFormatContext *s)\n\n{\n\n    IffDemuxContext *iff = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    uint8_t *buf;\n\n    uint32_t chunk_id, data_size;\n\n    uint32_t screenmode = 0, num, den;\n\n    unsigned transparency = 0;\n\n    unsigned masking = 0; // no mask\n\n    uint8_t fmt[16];\n\n    int fmt_size;\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->codec->channels = 1;\n\n    st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n    avio_skip(pb, 8);\n\n    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content\n\n    st->codec->codec_tag = avio_rl32(pb);\n\n    iff->bitmap_compression = -1;\n\n    iff->svx8_compression = -1;\n\n    iff->maud_bits = -1;\n\n    iff->maud_compression = -1;\n\n\n\n    while(!url_feof(pb)) {\n\n        uint64_t orig_pos;\n\n        int res;\n\n        const char *metadata_tag = NULL;\n\n        chunk_id = avio_rl32(pb);\n\n        data_size = avio_rb32(pb);\n\n        orig_pos = avio_tell(pb);\n\n\n\n        switch(chunk_id) {\n\n        case ID_VHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 14)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 12);\n\n            st->codec->sample_rate = avio_rb16(pb);\n\n            if (data_size >= 16) {\n\n                avio_skip(pb, 1);\n\n                iff->svx8_compression = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_MHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 32)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 4);\n\n            iff->maud_bits = avio_rb16(pb);\n\n            avio_skip(pb, 2);\n\n            num = avio_rb32(pb);\n\n            den = avio_rb16(pb);\n\n            if (!den)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 2);\n\n            st->codec->sample_rate = num / den;\n\n            st->codec->channels = avio_rb16(pb);\n\n            iff->maud_compression = avio_rb16(pb);\n\n            if (st->codec->channels == 1)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            else if (st->codec->channels == 2)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            break;\n\n\n\n        case ID_ABIT:\n\n        case ID_BODY:\n\n        case ID_DBOD:\n\n        case ID_MDAT:\n\n            iff->body_pos = avio_tell(pb);\n\n            iff->body_end = iff->body_pos + data_size;\n\n            iff->body_size = data_size;\n\n            break;\n\n\n\n        case ID_CHAN:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            if (avio_rb32(pb) < 6) {\n\n                st->codec->channels       = 1;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            } else {\n\n                st->codec->channels       = 2;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            }\n\n            break;\n\n\n\n        case ID_CAMG:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            screenmode                = avio_rb32(pb);\n\n            break;\n\n\n\n        case ID_CMAP:\n\n            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case ID_BMHD:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size <= 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            avio_skip(pb, 4); // x, y offset\n\n            st->codec->bits_per_coded_sample = avio_r8(pb);\n\n            if (data_size >= 10)\n\n                masking                      = avio_r8(pb);\n\n            if (data_size >= 11)\n\n                iff->bitmap_compression      = avio_r8(pb);\n\n            if (data_size >= 14) {\n\n                avio_skip(pb, 1); // padding\n\n                transparency                 = avio_rb16(pb);\n\n            }\n\n            if (data_size >= 16) {\n\n                st->sample_aspect_ratio.num  = avio_r8(pb);\n\n                st->sample_aspect_ratio.den  = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_DPEL:\n\n            if (data_size < 4 || (data_size & 3))\n\n                return AVERROR_INVALIDDATA;\n\n            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n\n                return fmt_size;\n\n            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n\n            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n\n            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n\n            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n\n            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n\n            else {\n\n                av_log_ask_for_sample(s, \"unsupported color format\\n\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            break;\n\n\n\n        case ID_DGBL:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size < 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            iff->bitmap_compression          = avio_rb16(pb);\n\n            st->sample_aspect_ratio.num      = avio_r8(pb);\n\n            st->sample_aspect_ratio.den      = avio_r8(pb);\n\n            st->codec->bits_per_coded_sample = 24;\n\n            break;\n\n\n\n        case ID_DLOC:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width  = avio_rb16(pb);\n\n            st->codec->height = avio_rb16(pb);\n\n            break;\n\n\n\n        case ID_TVDC:\n\n            if (data_size < sizeof(iff->tvdc))\n\n                return AVERROR_INVALIDDATA;\n\n            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));\n\n            if (res < 0)\n\n                return res;\n\n            break;\n\n\n\n        case ID_ANNO:\n\n        case ID_TEXT:      metadata_tag = \"comment\";   break;\n\n        case ID_AUTH:      metadata_tag = \"artist\";    break;\n\n        case ID_COPYRIGHT: metadata_tag = \"copyright\"; break;\n\n        case ID_NAME:      metadata_tag = \"title\";     break;\n\n        }\n\n\n\n        if (metadata_tag) {\n\n            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {\n\n                av_log(s, AV_LOG_ERROR, \"cannot allocate metadata tag %s!\\n\", metadata_tag);\n\n                return res;\n\n            }\n\n        }\n\n        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));\n\n    }\n\n\n\n    avio_seek(pb, iff->body_pos, SEEK_SET);\n\n\n\n    switch(st->codec->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);\n\n\n\n        if (st->codec->codec_tag == ID_16SV)\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;\n\n        else if (st->codec->codec_tag == ID_MAUD) {\n\n            if (iff->maud_bits == 8 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_U8;\n\n            } else if (iff->maud_bits == 16 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;\n\n            } else {\n\n                av_log_ask_for_sample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maud_compression, iff->maud_bits);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            st->codec->bits_per_coded_sample =\n\n                av_get_bits_per_sample(st->codec->codec_id);\n\n\n\n            st->codec->block_align =\n\n                st->codec->bits_per_coded_sample * st->codec->channels / 8;\n\n        } else {\n\n        switch (iff->svx8_compression) {\n\n        case COMP_NONE:\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;\n\n            break;\n\n        case COMP_FIB:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;\n\n            break;\n\n        case COMP_EXP:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Unknown SVX8 compression method '%d'\\n\", iff->svx8_compression);\n\n            return -1;\n\n        }\n\n        }\n\n\n\n        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        iff->bpp          = st->codec->bits_per_coded_sample;\n\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n\n            st->codec->bits_per_coded_sample = 24;\n\n        }\n\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n\n        iff->masking      = masking;\n\n        iff->transparency = transparency;\n\n\n\n        if (!st->codec->extradata) {\n\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n\n        buf = st->codec->extradata;\n\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n\n        bytestream_put_byte(&buf, iff->bpp);\n\n        bytestream_put_byte(&buf, iff->ham);\n\n        bytestream_put_byte(&buf, iff->flags);\n\n        bytestream_put_be16(&buf, iff->transparency);\n\n        bytestream_put_byte(&buf, iff->masking);\n\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 20917, "substitutes": {"s": ["js", "gs", "m", "ls", "p", "sq", "es", "sp", "bs", "rs", "sb", "n", "ps", "sc", "fs", "ds", "scl", "sa", "b", "c", "cs", "as", "ts", "ses", "ss", "stats", "t", "aws", "less", "set", "ns", "ins", "its", "hs", "sts", "qs", "sys", "ats", "sg", "os", "S", "f", "is", "v", "comm"], "iff": ["alf", "lf", "ff", "eff", "pkg", "uf", "ogg", "af", "diff", "bb", "eb", "pp", "dial", "ist", "sel", "conf", "pread", "iam", "supp", "image", "ifa", "ell", "aft", "abel", "png", "aff", "iffs", "fc", "lib", "tx", "html", "app", "img", "arf", "ef", "act", "tif", "xml", "gif", "less", "grab", "gz", "sect", "dl", "jpg", "aud", "patch", "txt", "amp", "et", "IFF", "xf", "ief", "ocl", "obj", "fax", "http", "conv", "bf", "crop", "x", "ata", "tf", "fb", "fp", "elt", "px", "ipp", "io", "cell", "cb", "fx"], "pb": ["ctx", "cp", "pkg", "pid", "meta", "gc", "uf", "tp", "bb", "p", "np", "pp", "nb", "erb", "sp", "td", "req", "jp", "port", "pm", "tmp", "sb", "um", "tc", "wb", "bp", "typ", "ab", "pl", "pro", "mp", "ob", "b", "stab", "wp", "proc", "tab", "vp", "tx", "tk", "msg", "buff", "PB", "pt", "func", "db", "bj", "rb", "buffer", "pc", "pa", "kb", "txt", "dc", "dp", "lb", "patch", "mb", "snap", "resp", "emb", "conv", "sys", "lp", "fb", "fp", "cb", "cmp", "px", "peer", "pool", "pg", "cv"], "st": ["ust", "ast", "rest", "mont", "sn", "sl", "inst", "start", "sp", "td", "ist", "ST", "tt", "sty", "must", "sb", "stable", "sc", "src", "fr", "sm", "ost", "sh", "St", "rt", "sw", "ss", "stack", "nt", "ut", "pt", "step", "stru", "t", "sta", "bl", "set", "put", "first", "nd", "est", "stream", "irst", "std", "et", "sth", "store", "sts", "usr", "h", "str", "se", "stri", "stop", "ste", "art", "sat", "th", "mt", "ct"], "buf": ["ctx", "ff", "uf", "seq", "bc", "tmp", "bp", "b", "buff", "raw", "uv", "img", "map", "bl", "buffer", "msg", "txt", "ref", "cv", "out", "bf", "batch", "rc", "err", "cap", "cb", "v"], "chunk_id": ["chunks_id", "chunks_ident", "chunkNamemode", "chianNamebid", "chunk___name", "chunk___bid", "chunk_name", "chunkNameid", "chunk___id", "chian_mode", "chianNamemode", "chunk___mode", "chunks_info", "chunkNamebid", "chunk_mode", "chianNameid", "chunk_bid", "chian_name", "chian_bid", "chunk_info", "chunks_name", "chunkNamename", "chian_id", "chunk_ident", "chunk_data", "chianNamename"], "data_size": ["ata_Size", "DATA_scale", "data_length", "DATA_Size", "dataLSize", "DATA_len", "data_description", "dataPSize", "dataPsize", "ata_too", "data_Size", " data_description", "data_rate", "data_scale", "data_SIZE", " data_rate", "DATA_length", "data_len", "DATA_size", "dataPrate", "data_too", "DATA_SIZE", "ata_size", "DATA_rate", "dataLscale", " data_Size", "dataLrate", " data_SIZE", "dataLsize"], "num": ["dev", "perm", "nb", "id", "mn", "nm", "ver", "common", "um", "n", "orig", "typ", "umi", "Num", "offset", "uni", "max", "proc", "no", "gen", "mark", "nu", "sum", "pos", "nom", "nam", "en", "msg", "con", "number", "coord", "len", "tim", "mem", "index", "mon", "dim", "mult", "NUM"], "den": ["dev", "perm", "high", "dir", "done", "alt", "seed", "range", "uni", "attr", "limit", "lan", "no", "flag", "quality", "en", "pen", "window", "len", "level", "none", "orient", "mem", "conv", "mon", "mid", "dim"], "fmt": [" fMT", "fxtx", "fxtype", "fcmt", "fcMT", "fxMT", " ftype", " ftx", "ftype", "fMT", "fxmt", "ftx", "fctx", "fctype"], "fmt_size": ["fformat_len", "fmt_len", "fmt_SIZE", "fmt_name", "fformat_SIZE", "fformat_size", "fformat_name"], "orig_pos": ["origin_pt", "orig_POS", " orig_offset", "orig_loc", "origptloc", "orig_offset", "origin_loc", "origptpos", "orig1seq", "orig_position", "orig1offset", " orig_seq", " orig_POS", "origptposition", "orig_pt", "orig67POS", "orig1POS", "origin_pos", "orig67seq", "orig67offset", "orig_seq", "origin_position", "origptpt", "orig1pos", "orig67pos"], "res": ["Conn", "rest", "reset", " cs", "rs", "req", "def", "rem", "RES", "rep", " resp", "VAL", "reg", " ver", "cond", " results", "re", "resp", "con", "Res", " rem", "resh", "ress", "os", "vals", "err", "val"], "metadata_tag": ["metadata_comment", "metadata_id", "meta_type", "metadata_type", "meta_tag", "meta_comment", "meta_id"]}}
{"project": "FFmpeg", "commit_id": "f3ace37a3b8c93218630a37b7df4dc195f1215a9", "target": 1, "func": "static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n\n{\n\n    int err, i, dash = 0, result = 0, code_found = 0;\n\n    char buf[CONTROL_BUFFER_SIZE];\n\n    AVBPrint line_buffer;\n\n\n\n    if (line)\n\n        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    while (!code_found || dash) {\n\n        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n\n            av_bprint_finalize(&line_buffer, NULL);\n\n            return err;\n\n        }\n\n\n\n        av_log(s, AV_LOG_DEBUG, \"%s\\n\", buf);\n\n\n\n        if (strlen(buf) < 4)\n\n            continue;\n\n\n\n        err = 0;\n\n        for (i = 0; i < 3; ++i) {\n\n            if (buf[i] < '0' || buf[i] > '9')\n\n                continue;\n\n            err *= 10;\n\n            err += buf[i] - '0';\n\n        }\n\n        dash = !!(buf[3] == '-');\n\n\n\n        for (i = 0; response_codes[i]; ++i) {\n\n            if (err == response_codes[i]) {\n\n                if (line)\n\n                    av_bprintf(&line_buffer, \"%s\", buf);\n\n                code_found = 1;\n\n                result = err;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (line)\n\n        av_bprint_finalize(&line_buffer, line);\n\n    return result;\n\n}\n", "idx": 20918, "substitutes": {"s": ["ctx", "js", "gs", "m", "p", "sq", "rs", "w", "d", "n", "sc", "ps", "fs", "sm", "ds", "scl", "b", "c", "cs", "an", "r", "as", "sw", "ts", "ses", "serv", "ss", "t", "g", "ns", "ap", "socket", "a", "e", "sts", "sv", "h", "x", "se", "os", "ats", "S", "f", "is", "v", "comm"], "line": ["lf", "stroke", "list", "lo", "file", "o", "name", "Line", "word", "eline", "port", "user", "ln", "length", "lin", "range", "l", "cl", "status", "text", "mode", "nl", "lock", "header", "online", "iter", "board", "cmd", "node", "flag", "point", "lines", "LINE", "print", "error", "pipe", "frame", "buffer", "page", "ine", "ip", "stay", "cli", "link", "comment", "out", "code", "el", "row", "lined", "len", "queue", "block", "cell", "le"], "response_codes": ["Response_odes", "responseablestates", " response_states", "Response_codes", "response_odes", "response_states", "Response_code", "responseablecode", " response_code", "response_cs", "responseablecs", "response_objects", "responseablecodes", "response2states", "response_seconds", "response2code", "resp_seconds", "resp_codes", "resp_objects", "response2codes", "response2cs", "response_values", "response_code", " response_cs", "resp_values"], "err": ["cor", "conf", "test", "attr", "score", "errors", "dr", "order", "gz", "rb", "rank", "rev", "resp", "ch", "arr", "die", "nr", "trace", "term", "cb", "der", "try", "inner", "it", "rn", "fail", "iter", "error", "len", "ctr", "ach", "usr", "norm", "Error", "rc", "cr", "mr", "or", "req", "ptr", "notice", "br", "fr", "orig", "oe", "er", "r", "raw", "ord", "act", "res", "msg", "txt", "ine", "var", "obj", "Er", "str", "progress", "diff", "pr", "n", "expr", "result", "lr", "c", "cmd", "ie", "ner", "cli", "out", "off", "code", "coord", "e", "rr", "addr", "ex", "val"], "i": ["hi", "m", "me", "ci", "ix", "p", "q", "o", "id", "si", "zi", "multi", "ori", "ei", "y", "it", "xi", "ij", "inter", "ti", "mi", "chain", "qi", "iu", "j", "iter", "di", "ir", "\u0438", "ai", "t", "ie", "g", "u", "gi", "phi", "ui", "li", "ic", "uri", "ip", "sim", "cli", "ri", "iq", "ji", "ini", "bi", "ind", "oi", "index", "ii", "x", "pi", "eu", "I", "ami", "io", "v"], "buf": ["pkg", "pack", "bag", "tmp", "prop", "rb", "vec", "cur", "resp", "bf", "arr", "queue", "aka", "words", "block", "cb", "cv", "ctx", "uf", "data", "bar", "box", "cache", "b", "doc", "buff", "iter", "img", "pos", "cat", "Buff", "desc", "len", "emb", "conv", "fb", "bd", "v", "seq", "pad", "tr", "br", "text", "max", "proc", "r", "raw", " b", "wd", "msg", "txt", "window", "obj", "str", "batch", "cap", "p", "bc", "nm", " buffer", "Buffer", "bytes", "que", "result", "tx", "bt", "cmd", "db", "buffer", "bg", "off", "out", "code", "late", "mem", "fg", "val"], "line_buffer": [" line_buf", "Line_buff", "char_size", "charingBuffer", "ine_cache", "point_Buffer", "line___limit", "char_Buffer", "line_buff", "line_match", "line_callback", "line___thread", "point_limit", "point_buffer", "lineingbuffer", "char_buffer", "char_entry", "line_entry", "lineaccache", "line___buffer", "line_Buffer", "charingentry", "line2buffer", "line_size", "Line_queue", "Line_buffer", "line___Buffer", "ine_buffer", "charingbuffer", "lineacdatabase", "line_database", "Line_callback", "lineacbuffer", "ine_match", "lineingentry", "line_queue", "lineptbuff", "line2Buffer", "lineptbuffer", "point___buffer", " line_Buffer", "line_thread", "charingsize", "lineingBuffer", "lineingsize", "lineptcallback", "line_limit", "ine_database", "point_thread", "lineacmatch", "point___Buffer", "line_cache", "line2buf", "line_buf", "lineptqueue", "point___thread", "point___limit"]}}
{"project": "qemu", "commit_id": "26e92f65525ef4446a500d85e185cf78835922aa", "target": 0, "func": "static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset)\n\n{\n\n    arm_sysctl_state *s = (arm_sysctl_state *)opaque;\n\n\n\n    switch (offset) {\n\n    case 0x00: /* ID */\n\n        return s->sys_id;\n\n    case 0x04: /* SW */\n\n        /* General purpose hardware switches.\n\n           We don't have a useful way of exposing these to the user.  */\n\n        return 0;\n\n    case 0x08: /* LED */\n\n        return s->leds;\n\n    case 0x20: /* LOCK */\n\n        return s->lockval;\n\n    case 0x0c: /* OSC0 */\n\n    case 0x10: /* OSC1 */\n\n    case 0x14: /* OSC2 */\n\n    case 0x18: /* OSC3 */\n\n    case 0x1c: /* OSC4 */\n\n    case 0x24: /* 100HZ */\n\n        /* ??? Implement these.  */\n\n        return 0;\n\n    case 0x28: /* CFGDATA1 */\n\n        return s->cfgdata1;\n\n    case 0x2c: /* CFGDATA2 */\n\n        return s->cfgdata2;\n\n    case 0x30: /* FLAGS */\n\n        return s->flags;\n\n    case 0x38: /* NVFLAGS */\n\n        return s->nvflags;\n\n    case 0x40: /* RESETCTL */\n\n        return s->resetlevel;\n\n    case 0x44: /* PCICTL */\n\n        return 1;\n\n    case 0x48: /* MCI */\n\n        return 0;\n\n    case 0x4c: /* FLASH */\n\n        return 0;\n\n    case 0x50: /* CLCD */\n\n        return 0x1000;\n\n    case 0x54: /* CLCDSER */\n\n        return 0;\n\n    case 0x58: /* BOOTCS */\n\n        return 0;\n\n    case 0x5c: /* 24MHz */\n\n        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());\n\n    case 0x60: /* MISC */\n\n        return 0;\n\n    case 0x84: /* PROCID0 */\n\n        /* ??? Don't know what the proper value for the core tile ID is.  */\n\n        return 0x02000000;\n\n    case 0x88: /* PROCID1 */\n\n        return 0xff000000;\n\n    case 0x64: /* DMAPSR0 */\n\n    case 0x68: /* DMAPSR1 */\n\n    case 0x6c: /* DMAPSR2 */\n\n    case 0x70: /* IOSEL */\n\n    case 0x74: /* PLDCTL */\n\n    case 0x80: /* BUSID */\n\n    case 0x8c: /* OSCRESET0 */\n\n    case 0x90: /* OSCRESET1 */\n\n    case 0x94: /* OSCRESET2 */\n\n    case 0x98: /* OSCRESET3 */\n\n    case 0x9c: /* OSCRESET4 */\n\n    case 0xc0: /* SYS_TEST_OSC0 */\n\n    case 0xc4: /* SYS_TEST_OSC1 */\n\n    case 0xc8: /* SYS_TEST_OSC2 */\n\n    case 0xcc: /* SYS_TEST_OSC3 */\n\n    case 0xd0: /* SYS_TEST_OSC4 */\n\n        return 0;\n\n    default:\n\n        printf (\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 20938, "substitutes": {"opaque": ["iopaque", "opaques", " opoid", "opade", "oplaque", "oplent", "oploid", "obaque", " oposter", "obent", "opent", "opoid", "obade", "oplaques", " opade", "ioposter", "oploster", "obaques", " opent", " opaques", "oposter", "oplade", "iopoid"], "offset": ["ocation", "command", "data", "start", "o", "sp", "z", "id", "pad", "slot", "type", "length", "padding", "mt", "shift", "Offset", "bound", "style", "ms", "address", "no", "location", "point", "pointer", "pos", "t", "size", "set", "error", "from", "buffer", "ock", "offs", "ref", "off", "a", "zero", "row", "operation", "base", "tz", "attribute", "index", "op", "oid", "addr", "mask", "clock", "object", "block", "zone"], "s": ["dates", "eds", "rs", "ants", "ails", "uns", "fs", "ims", "stats", "ies", "izes", "ins", "its", "a", "os", "ocks", " returns", "ls", "alls", "es", "o", "z", "d", " holds", "outs", "ances", "ps", "ds", "b", "ands", "ests", "ts", "umps", "rows", "ed", "ports", "ums", "locks", "js", "gs", "m", " outputs", "ches", "resses", "parts", " values", "ains", "er", "r", "ss", "aws", "g", "olds", "ations", "ions", "ers", "hs", "sts", "ats", "ists", " docs", "sq", "p", "ores", "w", "sb", "n", "ments", "c", "erences", "t", "itions", "e", "S", "als", "ries"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_is_self(cpu)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    wi.free = false;\n\n    if (cpu->queued_work_first == NULL) {\n\n        cpu->queued_work_first = &wi;\n\n    } else {\n\n        cpu->queued_work_last->next = &wi;\n\n    }\n\n    cpu->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(cpu);\n\n    while (!wi.done) {\n\n        CPUState *self_cpu = current_cpu;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        current_cpu = self_cpu;\n\n    }\n\n}\n", "idx": 20945, "substitutes": {"cpu": ["ctx", "cp", "pkg", "gc", "reset", "num", "tp", "program", "p", "np", "us", "linux", "hz", "library", "jp", "CPU", "port", "mu", "conn", "copy", "vm", "component", "java", "etc", "ork", "cum", "proc", "core", "gpu", "aco", "processor", "nic", "bench", "server", "net", "prof", "remote", "phys", "frame", "pc", "ck", "cli", "device", "process", "socket", "cu", "mem", "kernel", "sys", "os", "runner", "hw", "clock", "alloc", "pai", "px", "pu", "stat", "cmp", "boot"], "func": ["ctx", "pkg", "perm", "callback", "impl", "imp", "fx", "fw", "invoke", "util", "fr", "prop", "orig", "cc", "expr", "fun", "attr", "closure", "b", "proc", "apply", "fn", "fc", "cs", "aux", "kw", "wrapper", "function", "mac", "cmd", "go", "act", "fac", "method", "unc", "con", "work", "coord", "obj", "sec", "cu", "conv", "comp", "package", "sys", "str", "cf", "exec", "PF", "f", "cb", "val"], "data": ["any", "m", "list", "done", "dat", "p", "input", "missing", "name", "memory", "params", "d", "only", "rew", "def", "mu", "cache", "n", "value", "bytes", "result", "fun", "info", "Data", "what", "fn", "r", "empty", "no", "items", "di", "function", "da", "step", "extra", "t", "na", "size", "res", "error", "map", "output", "format", "buffer", "ns", "device", "window", "next", "out", "snap", "none", "row", "all", "mem", "DATA", "record", "x", "ata", "batch", "new", "rel", "f", "table", "val"], "wi": ["mie", "fw", "udi", " hi", "wit", "ei", "wid", "ye", "ushi", "wic", "mi", " xx", "wcs", "pai", "yi", "wx", " pi", "gra", "wik", "eni", "esi", " ho", "isi", " wh", "innie", "dit", "wen", " wid", "qi", "wt", "iu", " pci", "rus", "WI", " wa", "wei", " yo", "wig", "wal", " wit", "wy", "rek", "wm", "hi", "rw", "xi", " xp", "wp", "hei", " wo", "gui", " wip", "shi", "ni", "fi", "ui", "wiki", "fee", "Wi", " wifi", "wo", " ti", "wat", "wikipedia", "hog", "wine", "feat", "ti", " sir", "xe", "wr", "wu", "lis", "bi", "wl", "igi", "wife"], "self_cpu": ["selfProcpu", "selfJpu", "self_ctx", "self___pu", "self___gc", "selfJgc", "self___cpu", "selfPropu", "self___ctx", " self_gc", " self_conn", "selfJcpu", "self_gpu", "selfJctx", "selfProgpu", "self_pu", "selfProconn", "self_gc", " self_pu", " self_gpu", "self_conn", " self_ctx"]}}
{"project": "FFmpeg", "commit_id": "2bb62455c899cdccbdc2a6ad33f9582008ed9f05", "target": 0, "func": "double avpriv_strtod(char *restrict nptr, char **restrict endptr)\n\n{\n\n    char *end;\n\n    double res;\n\n\n\n    /* Skip leading spaces */\n\n    while (isspace(*nptr))\n\n        nptr++;\n\n\n\n    if (!av_strncasecmp(nptr, \"infinity\", 8)) {\n\n        end = nptr + 8;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"inf\", 3)) {\n\n        end = nptr + 3;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"nan\", 3)) {\n\n        end = check_nan_suffix(nptr + 3);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"+nan\", 4) ||\n\n               !av_strncasecmp(nptr, \"-nan\", 4)) {\n\n        end = check_nan_suffix(nptr + 4);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"0x\", 2) ||\n\n               !av_strncasecmp(nptr, \"-0x\", 3) ||\n\n               !av_strncasecmp(nptr, \"+0x\", 3)) {\n\n        /* FIXME this doesn't handle exponents, non-integers (float/double)\n\n         * and numbers too large for long long */\n\n        res = strtoll(nptr, &end, 16);\n\n    } else {\n\n        res = strtod(nptr, &end);\n\n    }\n\n\n\n    if (endptr)\n\n        *endptr = end;\n\n\n\n    return res;\n\n}\n", "idx": 20958, "substitutes": {"nptr": ["unpointer", "nwcert", "nanpol", "nanptr", "Naddr", "ntpert", "Npad", "nsp", "oncert", "dnpointer", "snreq", "gnpt", " nproc", "numfx", " npert", "anproc", "nanpert", "nameaddr", "jptr", " nreq", "nwproc", "ndr", "onptr", "anptr", "nanaddr", "namerect", "mnptr", "naddr", " naddr", "wcert", "onaddr", "numproc", "nfx", "nanadr", "npt", "enpad", "sntr", "noteptr", "Npointer", "gnpert", "neptr", "mntr", "wnpert", "antr", "mnpr", "onrect", "gnpointer", "nanPtr", "nPtr", "nincert", "snpr", "gncert", "nwptr", "ntptr", "Npol", "NPtr", "nametp", "nncert", " ncert", "onpad", "snadr", " ndr", "nttr", "ntr", "anpointer", "ntp", "numpointer", "snpost", "ntaddr", " nadr", "onpr", "nrect", "snpt", "namept", "nreq", "ansp", "wnptr", "onadr", " npt", "nproc", "wnrect", "namepert", "ontr", "annpert", "snpointer", "dnproc", "neproc", "annadr", "annaddr", "nonpointer", "enaddr", "dnpost", "unproc", "unptr", "nameadr", "onpt", "unpad", "nonptr", "snrod", "andr", "neaddr", "uncert", "enfx", "ncert", "anfx", "sndr", "sncert", "Npert", "nwpert", "numpt", "numrod", "numpad", "npost", "onproc", "nnptr", "ntcert", "onfx", "nonpert", "npol", "anpad", "dnptr", "dnpert", "unadr", "nadr", "npointer", "jcert", " nfx", "nrod", "wPtr", "npert", " nrod", "gnproc", "onpert", "nameptr", "npad", "ninptr", "ninrect", "wpert", "namedr", "nnproc", "wptr", "Nptr", "anaddr", "onpointer", "nnpointer", "snfx", "snproc", "snpad", "gnptr", "notetp", "ancert", "ntsp", "neadr", "dnPtr", "nepad", "snaddr", "ninpt", "mnpt", "onsp", "gnpost", "snpert", " npointer", "unfx", "jPtr", "anreq", " npol", "snptr", "nefx", "annptr", "wntp", "nonpt", "jpert", "notepert", "enptr", "anPtr", "numaddr", "unpt", "noterect", "ntadr", "snPtr", "npr", " nPtr", " npad", "numptr", "namecert"], "endptr": ["lastpt", "ENDtr", "endbp", "Endptr", " endp", "lastptr", " endtr", "endedpt", "ENDptr", "lasttr", "endedPtr", " endbp", "lastPtr", "Endpointer", "ENDpt", "Endp", "endtr", "endp", "ENDPtr", "endPtr", "endpointer", " endpointers", "endedbp", "endedptr", "endpointers", "Endpointers", "endpt", " endpointer", "Endtr", "endedp", "endedpointers", "endedtr", "endedpointer", "Endbp"], "end": ["rest", "check", "and", "ment", "full", "pend", "can", "ver", "ld", "eng", "conn", "ext", "good", "info", "hend", "wind", "enc", "server", "append", "set", " End", "nd", "run", "last", "ad", "st", "term", "rend", "post", "End", "ell", "it", "ending", "fail", "en", "len", "ent", "ended", "begin", "dev", "ff", "reset", "add", "alt", "des", "url", "fr", "rem", "max", "send", "r", "END", "re", "obj", "row", "str", "err", "then", "valid", "close", "old", "start", "id", "entry", "fin", "bound", "ender", "reg", "est", "gate", "except", "out", "event", "e", "all", "stop", "final"], "res": ["js", "dev", "reset", "der", "rest", "stock", "inv", "rs", "pr", "details", "req", " residual", " Res", "conf", "ver", "def", "des", "ps", "resolution", "conn", "red", "fr", "rem", "status", "ret", "result", "expr", "RES", "ms", "med", "vol", "cs", "gr", "r", "j", "results", "reg", "cond", "rez", "rev", "vec", "re", "ins", "resp", "val", "cons", " err", "Res", "out", "resh", "ress", "crit", "sys", " ret", "err", " result", "pres", "rel", "vals", "pas", "progress", " reg", "rek", "rend", " RES"]}}
{"project": "FFmpeg", "commit_id": "b2a8850969b89151677253be4d99e0ba29212749", "target": 0, "func": "static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {\n\n    double time = av_gettime() / 1000000.0;\n\n    /* update current video pts */\n\n    is->video_current_pts = pts;\n\n    is->video_current_pts_drift = is->video_current_pts - time;\n\n    is->video_current_pos = pos;\n\n    is->frame_last_pts = pts;\n\n    check_external_clock_sync(is, is->video_current_pts);\n\n}\n", "idx": 20961, "substitutes": {"is": ["any", "js", "get", "ism", "isf", "ls", "es", "isc", "bs", "tis", "bits", "ist", "ais", "isi", "iris", "are", "parts", "bis", "it", "isin", "IS", "fs", "has", "isl", "ims", "sis", "ms", "info", "s", "ics", "cs", "iss", "ts", "ib", "serv", "in", "i", "ir", "act", "ai", "oss", "lis", "set", "plays", "ns", "ip", "ish", "ri", "il", "its", "sim", "ins", "irm", "Is", "ois", "ris", "os", "hw", "does", "isa", "isal", "ik", "ists", "im"], "pts": ["aptws", "iptts", "apts", "ctls", "ffws", "points", "ptls", "plps", "iptS", "ptc", "ffts", "ctc", "psls", "pls", "cts", "plS", "aptts", "psc", "ptps", "plts", "ptts", "ctp", " ptls", "pkgS", "ffls", "ptp", "pointls", "ipts", "iptps", " ptws", "pss", "pointc", "ffs", "pkgts", "aptls", "ptws", "pointp", "ptS", "pkgs", "psp", " ptts", "pkgps"], "pos": ["js", "pid", " position", "rot", "spec", "p", "data", "o", "Pos", "seq", "type", "loc", "port", "d", "def", "vs", "trans", "ps", "offset", "ds", "win", "present", "ms", "s", "proc", " pose", "serv", "gen", "po", "POS", "point", "pt", " positions", "pro", "pc", "position", "pose", "resp", "snap", "len", "time", "xy", "os", " POS", " Pos", "seek", "v", "val"], "serial": [" sec", " scale", " id", " times", " step", " sid", " seek", " sleep", "ser", " total", " vel", " velocity", " stream", " start", " random", " snap", " seq", "res", " pid", " ver", " ser", " tick", " tid", " proc", " delay", " seed", " speed"]}}
{"project": "qemu", "commit_id": "a659979328fb6d4d6100d398f5bd9a2310c3e169", "target": 0, "func": "open_f(int argc, char **argv)\n\n{\n\n\tint flags = 0;\n\n\tint readonly = 0;\n\n\tint growable = 0;\n\n\tint c;\n\n\n\n\twhile ((c = getopt(argc, argv, \"snrg\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 's':\n\n\t\t\tflags |= BDRV_O_SNAPSHOT;\n\n\t\t\tbreak;\n\n\t\tcase 'n':\n\n\t\t\tflags |= BDRV_O_NOCACHE;\n\n\t\t\tbreak;\n\n\t\tcase 'r':\n\n\t\t\treadonly = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'g':\n\n\t\t\tgrowable = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&open_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (!readonly) {\n\n            flags |= BDRV_O_RDWR;\n\n        }\n\n\n\n\tif (optind != argc - 1)\n\n\t\treturn command_usage(&open_cmd);\n\n\n\n\treturn openfile(argv[optind], flags, growable);\n\n}\n", "idx": 20970, "substitutes": {"argv": ["argsz", " argV", " argc", "argsc", "argw", "argp", "argsp", "agz", " argz", " argvs", "argsv", " argw", "argss", " argp", "argumentw", "argumentV", "argumentc", "agv", "argc", "args", "argV", "argumentvs", "argumentv", "argsvs", "arguments", "argsw", "argsV", "argz", "agc", " args", "agp", "argvs"], "c": ["ac", "cp", "gc", "m", "p", "vc", "o", "v", "z", "bc", "conf", "w", "d", "xc", "tc", "cache", "n", "nc", "mc", "cc", "sc", "C", "l", "co", "com", "b", "cs", "fc", "r", "lc", "\u00e7", "ec", "i", "uc", "t", "ce", "k", "g", "u", "pc", "unc", "dc", "count", "cur", "code", "a", "e", "abc", "ch", "x", "cf", "rc", "cmp", "f", "cod", "ct"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; /* We wrote to 4 extra bytes from the header */\n\n}\n", "idx": 20975, "substitutes": {"s": ["js", "gs", "m", "spec", "sl", "ls", "p", "sq", "es", "rs", "bs", "details", "d", "sb", "ps", "bis", "y", "fs", "sis", "ds", "status", "has", "l", "ims", "b", "ess", "r", "sw", "ses", "ts", "ss", "stats", "t", "aws", "less", "set", "ns", "sim", "ins", "its", "changes", "store", "hs", "services", "sts", "sv", "qs", "sys", "se", "os", "S", "ops", "st", "is", "sports", "comm"], "buf": ["ctx", "pkg", "dev", "ff", "uf", "pack", "p", "bar", "v", "font", "ev", "pad", "cast", "bc", "bo", "ptr", " buffer", "br", "Buffer", "ah", "cache", "ab", "pool", "b", "proc", "doc", "tab", "buff", "kw", "iter", "cmd", "img", "func", "loop", "map", "db", "buffer", "env", "ref", "pb", "vec", "Buff", "desc", "off", "cam", "emb", "mem", "queue", "aka", "batch", "addr", "fb", "cap", "cb", "cv", "bn"], "event_code": ["owner_code", "eventopcode", "event5code", "eventletclose", "eventopsuccess", "event_status", "event_controller", "owner_success", "eventencomment", "event_reason", "ownerixcode", "eventenclose", "eventitycase", "eventitystatus", "eventixcomment", "version_close", "eventencereason", "event__status", "eventencode", "eventenchoice", "eventencecode", "event__case", "eventletcurrency", "versionencontroller", "eventencestatus", "owner_comment", "ownerixchoice", "event____status", "event_command", "event5order", "event____code", "event_success", "event____codes", "eventsetcurrency", "event____case", "owner_choice", "event5change", "eventixchoice", "eventixsuccess", "event_comment", "eventitycode", "event_codes", "event_case", "version_currency", "event__code", "eventsetcode", "versionenclose", "version_code", "eventencecase", "ownerixcomment", "state_change", "event__codes", "eventStatuscommand", " event_codes", "event_close", "event_currency", "eventensuccess", "versionencurrency", "eventencurrency", "state_code", "eventletcontroller", "eventStatuscode", "eventletcode", " event_case", "event_order", "eventsetclose", "state_command", " event_reason", "ownerixsuccess", "eventencontroller", "eventityreason", "versionencode", "version_controller", "eventsetcontroller", "event_choice", " event_status", "eventopchoice", "eventopcomment", "event_change", "event5command", "state_order", "eventStatuschange", "eventStatusorder", "eventixcode"], "media_status": ["media_Status", "media_access", "memory_set", "media_stat", "media_error", "media_start", "media67start", "medium_access", "mediaStatusStatus", "final_start", "media67post", "mediaitystat", "media_set", "media_display", "finalprostart", "media_operator", " media_info", "mediaprostart", "mediaityinfo", "media____code", "media67operator", "media_post", "area_code", "area____operator", "medium_stats", "mediaStatusstats", "mediaStatusstart", "mediaStatusstatus", "media_settings", " media_error", "mediaStatusdisplay", "finalproscore", "mediaStatusaccess", "media_strength", "mediaStatuspost", " media_settings", "finalpropost", "mediaitystatus", "media___status", "area____code", " media_stat", "medium_description", "media_state", "memory___set", "mediaitysettings", "media67code", "media_info", "finalprostatus", "mediaPaccess", "area____strength", "area_operator", "media67status", "media____status", "media____operator", "final_score", "media_description", "memory_Status", "media_stats", "memory_status", "mediaStatusscore", "media67score", "area____status", "final_status", " media_state", "memory___status", "mediaStatusset", "medium_status", "media_score", "area_status", "media____strength", "media___set", "final_post", "memory___display", "media___display", "memory_display", "mediapropost", "media___Status", "mediaproscore", "area_strength", "mediaPstatus", "media_code", "media67strength", "mediaStatusdescription", "mediaPdescription", "memory___Status", "mediaPstats", "mediaprostatus"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_REMOVED);\n\n    }\n\n\n\n    if (s->ctx) {\n\n        blk_op_unblock_all(sd->conf.blk, s->blocker);\n\n    }\n\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n\n}\n", "idx": 20994, "substitutes": {"hotplug_dev": ["hotplugedDev", "hotPlug_Dev", "hotplug2div", "hotplugeddef", "hotPlug_buf", "hotpl_device", "hotplug__div", "hotPlug_dev", "hotplug2dev", "hotplugableDev", "hotplug__Dev", "hotplugedbuf", "hotplugabledev", "hotplug_div", "hotplug_device", "hotplugeddev", "hotplug_Dev", "hotplug2buf", "hotplugablediv", "hotplug_buf", "hotplug2Dev", "hotplug__dev", "hotplug__buf", "hotPlug_def", "hotpl_dev", "hotplug_def", "hotpl_Dev", "hotplugablebuf"], "dev": ["der", "data", "ev", "pad", "vd", "tech", "debug", "Dev", "w", "d", "ver", "def", "des", "DEV", "test", "develop", "ds", "hd", "att", "doc", "raw", "wd", "dis", "ow", "hid", " device", "pro", "env", "dem", "watch", "dd", "de", "device", "md", "cam", "adv", "mem", "ch", "local", "h", "hw", "priv", "ad", "v"], "errp": ["errbp", "excp", "derp", " errP", " errpc", "excpa", "errpp", "derP", "derpp", "diepc", "derbp", " errbp", " errpp", "diebp", "diep", "errpc", "excpp", "dieP", "derpa", "excP", "errpa", "errP", " errpa", "derpc"], "vdev": ["svdev", "gpro", "avpro", "uvdevice", " vdiv", "svdiv", "vev", "svdevice", " vdef", "vtpro", "vtev", "avdevice", "uvdef", "Vdevice", "Vdef", "gdevice", "gdef", "avdev", "Vdiv", "vdiv", "gdev", "Vdev", "vpro", "uvdev", "vdevice", "vtdev", "vdef", "svdef", " vdevice", "gev", "uvdiv", "vtdevice", "avev", "gdiv"], "s": ["js", "gs", "south", "so", "sl", "ls", "sn", "p", "sq", "sp", "es", "rs", "si", "su", "sb", "sol", "des", "ps", "n", "fs", "sis", "ds", "sm", "sa", "ms", "b", "sh", "cs", "an", "iss", "sw", "ts", "sym", "j", "ss", "i", "stats", "g", "ns", "a", "sam", "sts", "sv", "h", "sf", "sg", "se", "S", "st", "is", "v"], "sd": ["sn", "sl", "sq", "sp", "ev", "td", "vd", "si", "d", "sb", "pd", "sc", "fd", "sis", "ds", "sm", "hd", "sky", "sa", "dh", "sh", "cs", "sw", "dis", "di", "ss", "SD", "dl", "od", "dd", "sid", "md", "sam", "sing", "sv", "sys", "dk", "sg", "sk", "bd", "sy"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,\n\n                                    SocketAddress *addr,\n\n                                    Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_connect_sync(ioc, addr);\n\n    fd = socket_connect(addr, NULL, NULL, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_connect_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_connect_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20996, "substitutes": {"ioc": ["atios", " iocon", "iocon", "diocon", " ioci", "tiocon", "ioci", "tioci", "tiOC", "cioid", " iOC", "diOC", " ioid", "piOC", "ioco", "ioOC", "piroc", "cioc", "diroc", "atioci", "pioci", "cioco", "iooc", "atioc", "ciocon", "piosc", "pioco", "iroc", "piocon", "pioc", "pioid", "ioos", " ioco", "iooci", "atiOC", "ioosc", " iroc", "tiroc", "tioc", "iosc", "ioroc", "tioco", "tiosc", "dioc", "iOC", "ioid"], "addr": ["ha", "ac", "ix", "arp", "add", "start", "inv", "adr", "alt", "Address", "mk", "rs", "aj", "loc", "ag", "ptr", "ace", "ash", "url", "src", "wid", "bind", "aw", "attr", "rt", "nl", "address", "r", "wd", "cmd", "host", "act", "pos", "map", "msg", "ip", "align", "oa", "md", "work", "coord", "a", "now", "rol", "arr", "live", "art", "ad", "rel", "mt", "ack", "fx"], "errp": ["errorP", "derps", "cerP", "derr", "derp", "errm", " errP", "errr", "errjp", "arrP", " errpost", "derP", "erP", "errorjp", " errr", "erps", "errpost", " errm", " erP", "cerpa", "errorp", "arrm", " erp", "errps", "errorm", " erpost", " erpa", "erp", "cerp", "arrjp", "errpa", "errP", "arrp", "err", "cerpost", " errpa", " errps", " errjp"], "fd": [" dur", "lf", "pid", " fin", " fa", "ff", "dat", " f", "td", "fx", " fid", "fl", "ffff", " fut", "d", "ptr", "ld", "ln", "gd", " sd", "pd", "fr", "dra", "dt", "fs", "fe", "ds", "fin", "hd", "fun", "fn", "fc", "da", "func", "cond", "gz", "fi", " td", "dl", "nd", "db", "unc", "dd", "ud", "FD", "dy", "sd", "handle", "FH", "bf", "cf", "created", " fs", "fb", " df", "fp", "dig", "fm", "fed", "elt", " fl", "f", " ff", "df"]}}
{"project": "FFmpeg", "commit_id": "e30b068ef79f604ff439418da07f7e2efd01d4ea", "target": 1, "func": "static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,\n                      int append)\n{\n    int buflen;\n    /** when the frame data does not need to be concatenated, the input buffer\n        is resetted and additional bits from the previous frame are copyed\n        and skipped later so that a fast byte copy is possible */\n    if (!append) {\n        s->frame_offset = get_bits_count(gb) & 7;\n        s->num_saved_bits = s->frame_offset;\n        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n    buflen = (s->num_saved_bits + len + 8) >> 3;\n    if (len <= 0 || buflen > MAX_FRAMESIZE) {\n        avpriv_request_sample(s->avctx, \"Too small input buffer\");\n    s->num_saved_bits += len;\n    if (!append) {\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),\n                     s->num_saved_bits);\n    } else {\n        int align = 8 - (get_bits_count(gb) & 7);\n        align = FFMIN(align, len);\n        put_bits(&s->pb, align, get_bits(gb, align));\n        len -= align;\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);\n    skip_bits_long(gb, len);\n    {\n        PutBitContext tmp = s->pb;\n        flush_put_bits(&tmp);\n    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);\n    skip_bits(&s->gb, s->frame_offset);", "idx": 21007, "substitutes": {"s": ["so", "sp", "rs", "bs", "conf", "sql", "fs", "ims", "settings", "cs", "stats", "set", "ies", "its", "ins", "store", "a", "x", "os", "ctx", "ls", "q", "es", "views", "d", "vs", "ps", "ds", "self", "l", "ts", "serv", "args", "less", "source", "is", "js", "gs", "tes", "ssl", "parts", "bis", "eps", "status", "ains", "ms", "ses", "ss", "results", "aws", "hs", "services", "sts", "sys", "ats", "comm", "sq", "p", "details", "w", "sb", "n", "sync", "tests", "as", "sw", "utils", "ns", "changes", "sv", "qs", "xs", "h", "sg", "S", "als", "ops"], "gb": ["ctx", "cfg", "gs", "gc", "uf", "bridge", "eg", "bb", "eb", "tp", "nb", "bs", "vd", "ub", "gg", "yg", "gm", "gov", "sb", "tg", "gd", "wb", "bp", "gio", "vm", "Gb", "py", "mg", "phy", "tm", "gpu", " GB", "GB", "lib", "gnu", "buff", "storage", "bm", "ib", "vp", "gh", "bt", "img", "gif", "gz", "kb", "db", "rb", "g", "bg", "buffer", "vg", "goo", "bj", "pb", "pc", "csv", "mb", "bps", "gp", "gt", "rl", "sys", "rg", "sg", "hub", "fb", "pg", "gin", "gom", "cb", "cv"], "len": ["lf", "list", "num", "ls", "end", "del", "data", "sp", "full", "alt", "gl", "seq", "fl", "length", "loc", "bin", "half", "ln", "ld", "ell", "n", "bytes", "offset", "lim", "lon", "Len", "l", "fin", "ret", "split", "cod", "nl", "lan", "iter", "enc", "nt", "pos", "size", "bl", "repl", "en", "lt", "vec", "il", "align", "ref", "compl", "el", "hl", "ll", "all", "mem", "conv", "gt", "str", "lp", "local", "lang", "elt", "valid", "cmp", "kl", "un", "val"], "append": ["close", "end", "add", "write", "alias", "push", "pad", "atten", "pend", "insert", "seed", "important", "raise", "prop", "ext", "force", "visible", "shift", "apply", "attr", "send", "fail", "join", "buff", "empty", "bold", "enc", "app", "flag", "only", "leaf", "ignore", "update", "open", "vert", "END", "replace", "note", "next", "grow", "drop", "equal", "after", "ended", "index", "batch", "enable", "valid", "attach", "bind"], "buflen": ["cuvellen", "bucilen", "bullan", "bufrah", "cuflen", "cuvelen", "cuflov", "lufrog", " bullan", "bufllen", "buvlan", "buplen", "bufxov", "luflen", "buclade", " bullun", "bullens", "buflov", "cuvelov", "buvelov", "bufrog", "buflun", "buvlen", "buplun", "buvelen", "buvlength", "luflade", "buclah", "luflah", "lufrade", "buvelens", "lufrah", "luflog", "lufren", "buflens", "cufllen", "bucilade", "bufrade", "bufren", " bullength", "buclen", "bucilog", "bucilah", "buplength", "buplan", "bulllen", "bufxen", "buflength", "buclog", "bufxlen", "buvlun", "cuflens", "buflog", "buvellen", "buflade", "bufxens", " buflan", " bullen", " buflun", "bullen", "bullov", "buflan", "bullun", "bullength", "cuvelens", "buflah", " buflength"]}}
{"project": "FFmpeg", "commit_id": "a55692a96099c40aabb25e1443890be99f9c845c", "target": 1, "func": "static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,\n\n                                 const ReadInterval *interval, int64_t *cur_ts)\n\n{\n\n    AVPacket pkt, pkt1;\n\n    AVFrame *frame = NULL;\n\n    int ret = 0, i = 0, frame_count = 0;\n\n    int64_t start = -INT64_MAX, end = interval->end;\n\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n\n\n    av_init_packet(&pkt);\n\n\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n\n\n    if (interval->has_start) {\n\n        int64_t target;\n\n        if (interval->start_is_offset) {\n\n            if (*cur_ts == AV_NOPTS_VALUE) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Could not seek to relative position since current \"\n\n                       \"timestamp is not defined\\n\");\n\n                ret = AVERROR(EINVAL);\n\n\n\n            target = *cur_ts + interval->start;\n\n        } else {\n\n            target = interval->start;\n\n\n\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n\n                   interval->start, av_err2str(ret));\n\n\n\n\n\n\n    frame = av_frame_alloc();\n\n\n\n\n\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n", "idx": 21012, "substitutes": {"w": ["nw", "m", "write", "p", "fw", "iw", "d", "wb", "wa", "rw", "W", "b", "wt", "s", "c", "r", "sw", "t", "g", "ew", "window", "writer", "a", "e", "h", "f", "v"], "fmt_ctx": ["ftm_ctx", "flt_context", "fmt_tx", "fmt_context", "ftx_context", "ftx_cmd", "fmt2context", "fmt_xc", "fmt_cmd", "fmt2ctx", "fmt2tx", "frt_tx", "fmt___ctx", "frt_context", "flt_xc", "fmt___context", "ftm_conf", "frt_ctx", "flt_tx", "frt_pkg", "ftm_pkg", "flt_ctx", "fmt___xc", "ftx_tx", "fmt2pkg", "fmt2xc", "fmt_conf", "ftm_context", "fmt___tx", "fmt_pkg", "ftx_ctx"], "interval": ["itermediate", "airchange", "INTERpoint", "INTERgrade", "intv", "interival", "inVAL", "intsection", "iterval", "innerVAL", "interallel", "inival", "Interval", "terVAL", "INTERv", "verval", "tervals", "intersection", "airceptor", " Interval", "intergrade", "inval", " interival", "Interv", "innerval", "airVAL", "interpoint", "iterv", "Interceptor", "scheVAL", "terchange", "invol", "terv", "terval", "vervol", "iterrange", " interVAL", "scheval", " interallel", "schemediate", "interrange", " interchange", "interv", "intvals", " Interival", "INTERmediate", " interv", "INTERVAL", "tergrade", "preVAL", "preval", "tersection", " intervol", " intervals", "innerallel", "interceptor", "vermediate", "interVAL", " Intervol", "iterpoint", "verrange", "intermediate", "intival", "Interchange", "Intervals", "Intersection", "intval", "prechange", "terpoint", "schevol", " intermediate", "innermediate", "INTERvals", "interchange", "INTERval", "intervals", "iterival", "airval", "itervol", "intervol", "INTERallel", "InterVAL", "preceptor", "iterVAL", " interrange", "INTERvol", " intergrade", " InterVAL"], "cur_ts": ["Cur_ts", "curThetz", "curThesnap", "cur__TS", "tmp_", "ctrl_tz", "cur_uts", "curpytz", "cur__times", "Cur_ms", "Cur__ts", "Cur__times", "cur_time", "Cur_tz", "cur_snap", "Cur_times", "cur_", "cur__snap", "ctrlTheks", "cur_TS", "Cur__time", "cur_ms", "ctrlThets", "cur__tz", "cur__cs", "cur_tz", "Cur_TS", "ctrl_snap", "Cur_uts", "curpyks", "cur__ks", "ctrl_ks", "curTheks", "cur_ks", "cur_times", "cur__uts", "Cur__tz", "ctrlThetz", "Cur_time", "cur_cs", "curThets", "cur__ts", "curpysnap", "curpyts", "current_", " cur_", "ctrl_ts", "ctrlThesnap", "cur__time", "Cur_cs"], "pkt": ["pingact", "pkg", "cmsg", " pmsg", "fact", "tkt", " punct", "npacket", " pwk", " pkg", "spcmd", "spkt", "tpacket", "peracket", "fcmd", "tacket", "pwd", "fwd", "prounct", "pact", "Pkt", "pingunct", "pingmsg", " pcmd", "fmsg", "cpwk", "pft", "pwk", "fft", "pet", "Packet", "Pet", " pwd", "spacket", "cpacket", " pact", "tpwk", "facket", "Pkg", "pingkg", "cpkt", "ckt", "tpkg", "tet", "perkg", "prokt", "packet", "tkg", "proacket", "spft", "perwk", "cpnt", "tpkt", "pmt", " pft", "ppnt", " packet", "perkt", "pmsg", "pingkt", "pcmd", "ppacket", "ppkt", "pnt", " pnt", " pmt", "cwd", "cmt", "pingacket", "fmt", "npkg", "promsg", "punct", "fkg", "ppwk", "fkt", "npet", "npkt"], "pkt1": [" pkt5", "pwk2", " pkt2", "pft2", "pwk5", "pct1", "pft5", " pkt0", " pwk0", "pct2", "pkt2", "pwk0", "pft1", "pct0", " pwk1", "pkt0", "pft0", "pct5", "pkt5", "pwk1", " pwk2", " pwk5"], "frame": ["relation", "face", " frames", "scene", "profile", "iframe", "state", "seq", "fw", "framework", "image", " framed", "fr", "force", "movie", "feat", "chain", "Frame", "fram", "feature", "ence", "cmd", "point", "ce", "error", "message", "fi", "cue", "window", "process", "head", "event", "frames", "channel", "row", "base", "context", "flow", "queue", "part", "sequence", "block", "f", "trace"], "target": ["ta", "eta", "height", "reset", "trap", "data", "start", "transform", "alt", "alias", "tr", "length", "path", "port", " targets", "tmp", "ptr", "padding", "to", "range", "iat", "offset", "ARGET", "dest", "inter", " targ", "result", "limit", "root", "top", "ts", "Target", "origin", "point", "pointer", "timeout", "format", "t", "bolt", "size", "set", "match", "buffer", " targeted", "seek", "goal", "until", "total", "arget", "window", "next", "eth", "obj", "arg", "source", "base", "gt", "jump", "created", "begin", "valid", "rel", "peer", "mt", "table", "trace", " Target"], "frame_count": [" frame_ctr", " frame_c", " frame2count", "frame2ctr", "frame2c", " frame2c", " frame2Count", " frame2ctr", "frame_Count", " frame_Count", "frame_c", "frame_ctr", "frame2count", "frame2Count"], "i": ["m", "ci", "q", "p", "si", "n", "it", "l", "ij", "ti", "mi", "b", "limit", "c", "r", "j", "ai", "t", "fi", "ip", "ind", "index", "ii", "pi", "I", "f", "im"], "stream_index": ["channel_index", " stream_offset", "stream_offset", " stream_position", "stream_id", "channel_hash", "stream_position", "stream_hash", " stream_id", "channel_ind", "channel_id", "stream_ind"]}}
{"project": "FFmpeg", "commit_id": "d32547a24a3fcc8286b318353f43805838b84775", "target": 1, "func": "int attribute_align_arg avcodec_encode_audio(AVCodecContext *avctx,\n                                             uint8_t *buf, int buf_size,\n                                             const short *samples)\n{\n    AVPacket pkt;\n    AVFrame *frame;\n    int ret, samples_size, got_packet;\n    av_init_packet(&pkt);\n    pkt.data = buf;\n    pkt.size = buf_size;\n    if (samples) {\n        frame = av_frame_alloc();\n        if (!frame)\n            return AVERROR(ENOMEM);\n        if (avctx->frame_size) {\n            frame->nb_samples = avctx->frame_size;\n        } else {\n            /* if frame_size is not set, the number of samples must be\n             * calculated from the buffer size */\n            int64_t nb_samples;\n            if (!av_get_bits_per_sample(avctx->codec_id)) {\n                av_log(avctx, AV_LOG_ERROR, \"avcodec_encode_audio() does not \"\n                                            \"support this codec\\n\");\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            nb_samples = (int64_t)buf_size * 8 /\n                         (av_get_bits_per_sample(avctx->codec_id) *\n                          avctx->channels);\n            if (nb_samples >= INT_MAX) {\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            frame->nb_samples = nb_samples;\n        }\n        /* it is assumed that the samples buffer is large enough based on the\n         * relevant parameters */\n        samples_size = av_samples_get_buffer_size(NULL, avctx->channels,\n                                                  frame->nb_samples,\n                                                  avctx->sample_fmt, 1);\n        if ((ret = avcodec_fill_audio_frame(frame, avctx->channels,\n                                            avctx->sample_fmt,\n                                            (const uint8_t *)samples,\n                                            samples_size, 1)) < 0) {\n            av_frame_free(&frame);\n            return ret;\n        }\n        /* fabricate frame pts from sample count.\n         * this is needed because the avcodec_encode_audio() API does not have\n         * a way for the user to provide pts */\n        if (avctx->sample_rate && avctx->time_base.num)\n            frame->pts = ff_samples_to_time_base(avctx,\n                                                 avctx->internal->sample_count);\n        else\n            frame->pts = AV_NOPTS_VALUE;\n        avctx->internal->sample_count += frame->nb_samples;\n    } else {\n        frame = NULL;\n    }\n    got_packet = 0;\n    ret = avcodec_encode_audio2(avctx, &pkt, frame, &got_packet);\n    if (!ret && got_packet && avctx->coded_frame) {\n        avctx->coded_frame->pts       = pkt.pts;\n        avctx->coded_frame->key_frame = !!(pkt.flags & AV_PKT_FLAG_KEY);\n    }\n    /* free any side data since we cannot return it */\n    av_packet_free_side_data(&pkt);\n    if (frame && frame->extended_data != frame->data)\n        av_freep(&frame->extended_data);\n    av_frame_free(&frame);\n    return ret ? ret : pkt.size;\n}", "idx": 21030, "substitutes": {"avctx": ["avekl", "ajcontext", " avconn", "avercp", "aftx", "wavcontext", "avcmp", "actcontext", "wavcmp", "vercmp", "avetx", "avectx", "avcontext", "vercmd", "avecmd", " avtx", "avtx", "avetc", " avkl", "afctl", " avreq", "ajjac", "verctx", "wavcfg", "averctl", "avercmp", "wavctl", "avecp", "avercmd", "ajctx", "avcp", "afctx", " avcmp", "avjac", "avtc", "avectl", "apcontext", "afcmp", "wavjac", "actctx", "averkl", "ajcfg", " avcontext", " avjac", "avereq", "averctx", "afcontext", "avconn", "actjac", "afkl", "avcfg", "apctx", "averconn", "avreq", " avcomp", "acttx", "aptx", "aveconn", " avcfg", "ajreq", "avcomp", " avtc", " avctl", "avkl", "avecomp", "avercontext", "avercomp", " avcmd", "avecontext", "afcp", "wavctx", "avecmp", "ajtx", " avcp", "ajconn", "avejac", "wavtx", "verctl", "avecfg", "avctl", "avcmd", "avertc", "apcp"], "buf": ["ctx", "uf", "q", "p", "data", "v", "seq", "pad", "box", "wb", "bp", "Buffer", "bytes", "bound", "b", "doc", "buff", "raw", "cmd", "img", "pos", "db", "rb", "buffer", "msg", "ref", "pb", "vec", "Buff", "window", "mem", "bf", "arr", "queue", "batch", "fb", "alloc", "block", "cb", "cv"], "buf_size": ["buf2size", "buf2len", "buf_len", "buf_length", "buf2Size", "buf_dim", " buf_Size", "buf2length", "buff_Size", "uf_Size", "buff_len", "buf_Size", " buf_length", "uf_dim", "buff_length", "buff_size", " buf_len", "uf_size"], "samples": ["sents", "nources", "sigs", "sources", "Sources", "ssamps", "nents", "ssents", "namples", " sents", "namps", " sigs", "samps", "asamps", " samps", " sources", "Samps", "asources", "asamples", "ssigs", "ssamples", "Sents", "Samples", "Sigs"], "pkt": ["pkg", "proacket", "packacket", "wkt", "appt", "cpix", "pet", " pix", "opet", " pkg", "wwd", " pet", "Packet", " packet", "Pet", " apkg", "wpt", " pwd", "wacket", " ppt", "apkt", "opkt", " apacket", "opacket", "cpacket", " apkt", "prokg", "pix", "apacket", "packpt", "packwd", "Pkg", "ppt", "cpkt", "packkt", "pwd", "apkg", "opix", "cpet", "prokt", "packet", "propt", " apet", "Pkt"], "frame": ["file", "force", "movie", "role", "chain", "info", "feature", "join", "embed", "video", "step", "cue", "rame", "client", "head", "frames", "instance", "package", "queue", "fake", "filter", "call", "block", "f", "table", "trace", "command", "data", "framework", "request", "range", "component", "self", "ence", "function", "remote", "error", "message", "flow", "local", "part", "fb", "object", "draw", "face", "reset", "scene", "profile", "state", "word", "image", "field", "module", "fr", "init", "Frame", "fram", "proc", "load", "header", "empty", "point", "version", "shot", "page", "session", "window", "channel", "next", "row", "time", "comp", "form", "fp", "sequence", "zone", "close", "iframe", "def", "fe", "feat", "style", "line", "show", "focus", "cmd", "host", "ce", "buffer", "process", "event", "code", "base", "context", "cf", "new", "response"], "ret": ["reset", "alt", "Return", "ter", "tr", "Ret", "def", "reply", "it", "rem", "status", "result", " Ret", "rt", "xt", "aux", "pret", "nt", "flag", "print", "t", "ft", "det", "res", "mel", "txt", "ref", "re", "count", "resp", "out", "len", "ll", "rets", "after", "gt", "ber", "virtual", "tf", "vals", "elt", "err", "RET", "back", "mt", "f", "val"], "samples_size": ["samples2count", "samps_no", "samps_name", "samples_name", "samples_num", "sampleszsize", "sampleszno", "samples2size", "samples_Size", "samples67no", "samps_size", "samps_count", "samples_no", "samples2Size", "samples67size", "samples67Size", "samples_count", "samples67num", "samps_ize", "sampleszSize", "samps_num", "samplesznum", "samples_ize", "samps_Size", "samples2name"], "got_packet": ["got_presets", "got_compacket", "got_packacket", "_", "got_packkt", "def", "got_ppacket", "n", "got_ppet", "got_preset", "func", "got_compkt", "got_preskt", "got_ppkt", "got_compet", "all", "got_packets", "got_presacket", "call", "new", "got_compets", "got_ppets"], "nb_samples": ["nb_nplays", "nb_nsonents", "nb_jsances", "nb_ments", "nb_bizes", "nb_sples", "nb_pamps", "nb_Sizes", "nb_nsamps", "nb_Sources", "nb_subes", "nb_ponents", "nb_desamples", "nb_dans", "nb_desamps", "nb_namps", "nb_desples", "nb_mamps", "nb_sizes", "nb_isplays", "nb_lizes", "nb_nsans", "nb_naves", "nb_psances", "nb_jsamps", "nb_nsounds", "nb_nizes", "nb_pamples", "nb_psamps", "nb_psources", "nb_csamples", "nb_nsizes", "nb_Slements", "nb_damples", "nb_Samples", "nb_maves", "nb_sans", "nb_nales", "nb_csamps", "nb_isamples", "nb_Sples", "nb_damps", "nb_sonents", "nb_Sances", "nb_bamps", "nb_isizes", "nb_nsamples", "nb_esamples", "nb_slements", "nb_nsaves", "nb_sounds", "nb_esamps", "nb_Saves", "nb_deslements", "nb_Samps", "nb_Sounds", "nb_pizes", "nb_sents", "nb_lales", "nb_jsamples", "nb_eslements", "nb_nents", "nb_sources", "nb_isales", "nb_Sans", "nb_Sents", "nb_sances", "nb_lamples", "nb_splays", "nb_nubes", "nb_jsources", "nb_bamples", "nb_bonents", "nb_csubes", "nb_sales", "nb_mamples", "nb_esples", "nb_Subes", "nb_samps", "nb_namples", "nb_psamples", "nb_dounds", "nb_lplays", "nb_saves"]}}
{"project": "qemu", "commit_id": "b36d24b6c3708413f1174e34bd86b4bf5116012f", "target": 1, "func": "static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n", "idx": 21034, "substitutes": {"function": ["action", "command", "vector", "program", "frequency", "family", "full", "Function", "name", "type", "handler", "length", "word", "library", "module", "service", "value", "force", "expression", "amount", "role", "fun", "closure", "fn", "address", "functional", "func", "method", "size", "document", "unc", "number", "event", "context", "form", "kernel", "index", "lambda", "cf", "connection", "attribute", "object", "array", "f", "table"], "count": ["ctx", "vector", "list", "num", "start", "nb", "id", "seq", "name", "length", "range", "cache", "n", "force", "amount", "test", "counter", "result", "c", "Count", "cs", "found", "nt", "sum", "size", "cycle", "total", "var", "hash", "number", "len", "code", "th", "base", "context", "ctr", "index", "batch", "call", "array", "ount", "table", "v"], "eax": ["eac", "xax", "eag", "edag", "eras", "erox", "ebox", "erax", "eae", "edax", " eaj", "ebag", "edac", "ecab", "erae", "eabs", "ecac", "eraj", "edabs", "xabs", "ebax", "ebas", "ebae", "erag", "ebab", "ecabs", "ebaj", "eas", "erab", " eox", "xac", "eaj", "eox", "ecag", " eas", "ecae", "eab", "ecax", "xag"], "ebx": ["abbox", " ebz", "ebex", "ubox", "ibx", "ebox", "ubx", "erbx", " ebix", "ebz", "abbix", "ebax", "ubz", "erbex", "ubix", "egz", "dbax", "erbax", "ibox", "ubax", "dbix", "dbex", "egix", "egax", "ebix", "ibex", "abbx", "dbx", "ibix", "ibax", "erbix", "egx", "abbax", " ebax"], "ecx": ["edw", " ecy", "edp", "edax", "ecw", "edix", "exx", "cey", "edy", "ecv", "cex", "ecix", "egxx", "cep", "ebax", " ecj", "ecp", "eby", " ecv", "ecxx", "edv", "ebj", "ebv", "ceax", "egw", "edj", "egix", "ebp", "edxx", "exxx", "exw", "exix", "ecj", "ecy", "ecax", "egx"], "edx": ["edux", "etix", "osedax", "osedx", "osedix", "osedxi", "eux", "edax", "edix", "nedxi", "edxi", "oledx", "nedax", " edxi", "atedix", "mentedx", "edctx", "mentedax", "etctx", "oledctx", "adix", "etx", "mentedix", " edix", "eix", "adax", "atedax", "nedx", "mentedxi", " edctx", "oledxi", "adux", "atedx", "etxi", "oledix", "ex", "nedix", "adx", "atedux"], "vec": ["pack", "vc", "ve", "kt", "bin", "ver", "wit", "prop", "test", "deep", "nt", "pt", "et", "buf", "cam", "vre", "queue", "cv", "ctx", "list", "vt", "data", "veh", "vs", "it", "iv", "doc", "serv", "ec", "uv", "sum", "fam", "len", "resh", "ele", "save", "v", "js", "dev", "vector", "ev", "seq", "req", "length", "vet", "ptr", "dict", "proc", "act", "point", "mit", "msg", "var", "obj", "str", "err", "vid", "cap", "Vector", "spec", "inv", "seed", "mat", "plot", "def", "result", "values", "fc", "vp", "tx", "cmd", "go", "func", "buffer", "vr", "vert", "mem", "sv", "index", "vals", "val"]}}
{"project": "FFmpeg", "commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "target": 1, "func": "static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,\n\n                           int flags)\n\n{\n\n    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];\n\n    DXVA2Mapping      *map;\n\n    D3DSURFACE_DESC    surfaceDesc;\n\n    D3DLOCKED_RECT     LockedRect;\n\n    HRESULT            hr;\n\n    int i, err, nb_planes;\n\n    int lock_flags = 0;\n\n\n\n    nb_planes = av_pix_fmt_count_planes(dst->format);\n\n\n\n    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error getting a surface description\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (!(flags & AV_HWFRAME_MAP_WRITE))\n\n        lock_flags |= D3DLOCK_READONLY;\n\n    if (flags & AV_HWFRAME_MAP_OVERWRITE)\n\n        lock_flags |= D3DLOCK_DISCARD;\n\n\n\n    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unable to lock DXVA2 surface\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    map = av_mallocz(sizeof(*map));\n\n    if (!map)\n\n        goto fail;\n\n\n\n    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,\n\n                                dxva2_unmap_frame, map);\n\n    if (err < 0) {\n\n        av_freep(&map);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < nb_planes; i++)\n\n        dst->linesize[i] = LockedRect.Pitch;\n\n\n\n    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,\n\n                           (uint8_t*)LockedRect.pBits, dst->linesize);\n\n\n\n    if (dst->format == AV_PIX_FMT_PAL8)\n\n        dst->data[1] = (uint8_t*)map->palette_dummy;\n\n\n\n    return 0;\n\nfail:\n\n    IDirect3DSurface9_UnlockRect(surface);\n\n    return err;\n\n}\n", "idx": 21037, "substitutes": {"ctx": ["cp", "pkg", "gc", "ca", "np", "cn", "fx", "kt", "jp", "tmp", "xc", "tc", "sc", "conn", "cc", "cm", "nc", "tnc", "prefix", "cpp", "kw", "tx", "wd", "config", "cmd", "cas", "jac", "txt", "ck", "setup", "resp", "con", "wcs", "obj", "cu", "context", "ctr", "tz", "sys", "cf", "rc", "hw", "cb", "cmp", "ctl", "cv", "ct"], "dst": ["ddth", " dST", "adwt", "hot", "sdest", "ddnd", "DST", "Dto", "ddsp", "dbst", " dtr", "deST", "doST", "deest", "ddto", "adest", "Dbr", "Dwt", "dsp", "hST", "hst", "Dend", "ddst", "sdth", "dnd", "dbr", "dest", "dput", " dnd", "Dsp", "Dot", "Dnd", " dbr", "adsts", "ddest", "doot", "hest", "dests", "Dth", " dend", "sdst", "dot", " dsp", "adtr", "ddend", "ddbr", "ddput", "dost", "sdput", "dth", " ddest", " dest", "dST", " dwt", "sdto", "dtr", "dend", "adst", "Dsts", "dbtr", "dosts", " dput", "Dest", "Ddest", "dto", "dbest", " dsts", " dot", "sdST", "sdnd", "adot", "dedest", "ddST", "dbST", "adST", "dwt", "Dst", "sdsts", "adbr", "dsts"], "src": ["face", "sn", "inst", "inner", "ur", "sq", "np", "sp", "input", "rs", "start", "via", "sel", "image", "tmp", "sb", "ptr", "nil", "syn", "sc", "iv", "dest", "init", "ser", "rt", "proc", "RC", "sync", "scan", "config", "img", "in", "from", "sub", "vr", "txt", "ins", "desc", "cur", "sec", "obj", "source", "ctr", "conv", "comp", "sr", "sf", "sys", "rl", "sur", "cmp", "st", "rc"], "flags": ["gs", "acts", "comments", "FLAG", "bits", "rates", "tags", "lag", "ants", "parts", "weights", "types", "bugs", "ms", "files", "values", "settings", "limits", "kind", "ts", "flag", "cmd", "args", "cond", "atts", "members", "names", "boxes", "actions", "ags", "wcs", "options", "ports", " Flags", "features", "planes", "aps", "fps", "properties", "mask", "words", "fields", "Flags", "styles", "locks"], "surface": ["face", "plane", "uf", "texture", "bridge", "profile", "rect", "ra", "data", "np", "tile", "ve", "image", "filename", "tmp", "ptr", "managed", "far", "screen", "reflect", "dra", "png", "unity", "inter", "proc", "FACE", "origin", "func", "fac", "prof", "uri", "ui", "buffer", "metadata", "sim", "subject", "window", "sam", "source", "sun", "context", "package", "view", "form", " surf", " Surface", "sur", "save", "Sur"], "map": ["ac", "cp", "m", "tool", "bridge", "pack", "ape", "make", "data", "bar", "transform", "tile", "texture", "mk", "pad", "cast", "conf", "box", "image", "tmp", "mt", "master", "tree", "cache", "scale", "copy", "mg", "apper", "mp", "result", "man", "lock", "Map", "tap", "config", "app", "img", "func", "shape", "maps", "size", "set", " MAP", "match", "metadata", "buffer", "txt", "ap", "window", "hash", "buf", "row", "mem", "view", "policy", "M", "addr", "MAP", "mask", "save", "block", "ack", "clear", "bind"], "surfaceDesc": ["faceDes", "facedesc", " surfSpec", " surfaceDes", "textureDesc", " surfacedesc", "surfaceDes", "surfaceSpec", "texturedesc", " surfDec", "surfaceName", "faceSpec", "faceDec", " surfaceName", " surfDesc", "textureDes", "surfacedesc", "faceName", " surfaceDec", "surfaceDec", "uridesc", "faceDesc", "uriDesc", "uriName", " surfdesc", " surfaceSpec"], "LockedRect": ["LockedDir", "ClockDir", "LiedRect", "latchedLoc", "LlockedRect", " mLockedLoc", "LockedRegion", " mLashedRECT", "Clockedrect", "LashedRect", "LiedRegion", "LockedText", "LiedLoc", "LachedRECT", "LatchedLoc", "LackedRegion", "ClockRect", "lockedLoc", "LashedLoc", "lockedRat", "LockedRat", "LatchedRat", "latchedRat", "LonedArea", "LockingRect", " LlockedRegion", " LockedRegion", "ClockedRegion", "LatchedRegion", " mLockedRect", "LockedArea", " mLashedLoc", "Lackedrect", "LachedArea", "lockedRegion", "lockedRect", "LockDir", "Lockrect", "LotedRegion", "Lockerrect", "latchedRect", "LockRect", "LiedRat", "LockerText", " LlockedRect", "LlockedText", "LockerRect", "LachedRect", "LotedLoc", "LlockedRegion", "LackedRect", "LashedRECT", "ClockedRect", "LonedLoc", " mLashedRect", " LockedText", " mLockedRECT", "LockerRegion", "LockedLoc", "ClockRegion", "LockerDir", "LashedArea", "LockRegion", " mLockedArea", " LlockedText", " mLashedArea", "LachedLoc", "LatchedRect", "LackedDir", "ClockedDir", "LotedRect", "LockingRegion", "LockingText", "LonedRECT", "Lockedrect", "Clockrect", "latchedRegion", "LockedRECT", "LotedRat", "LonedRect"], "hr": ["ha", "js", "rect", "kr", "mr", "hz", "rs", "pr", "here", "tr", " hrs", "JR", "req", "oh", "ths", "ih", "ptr", "Dr", "br", "fr", "timer", "hm", "Mr", "ah", "ij", "hd", "er", "rh", "lr", "proc", "yr", "gr", "r", "eh", "html", "DR", "dr", "roth", "drm", "HR", "HK", "vr", "her", "TR", "hl", " dr", " HR", "resh", "ctr", "hour", "h", "arr", "rr", "rd", "bd", "nr"], "i": ["hi", "m", "me", " ti", "ci", "ix", "p", "us", "o", " bi", "si", "multi", "zi", "span", " di", "n", "y", "it", "xi", "ims", "l", "ti", "mi", "qi", "gu", "r", "PI", "j", "di", "in", "ai", "t", " ii", " I", " k", "ui", "g", "li", "u", "gi", " j", "ip", "cli", "sim", "ic", "wi", "ini", " x", "bi", "ind", "e", "index", "ii", "x", "pi", "batch", "asi", "I", " ni", "ki", "im"], "err": ["dev", "cr", "der", "aaa", "kr", "mr", "pr", "cer", "req", "conf", "or", "ptr", "notice", "br", "fr", "timer", "test", "init", "result", "er", "attr", "lr", "score", "r", "iter", "ec", "errors", "ir", "order", "rar", "res", "error", "erer", "gz", "ner", "msg", "txt", "asm", "count", "resp", "buf", "eas", "len", "ind", "ctr", "arr", "Er", "str", "sys", "ger", "rr", "usr", "fee", "Error", "elt", "nr", "eor", "rc"], "nb_planes": ["nxframes", "nxplates", "nb_plates", "n_plates", "num_plates", "nbxports", "nbxplates", "nxplanes", "nn_plates", "nxports", "nn_planes", "n_ports", "nb_ports", "nn_pages", "nbxpins", "nbxplanes", "nb_pins", "nb_pages", "nbxpages", "nbtpins", "nbtpages", "n_planes", "num_pages", "num_planes", "nbtplanes", "nbtplates", "nb_frames", "nbxframes", "n_frames", "num_pins"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_help(void)\n\n{\n\n    const char *prog;\n\n    const OptionDef *po;\n\n    int i, expert;\n\n    \n\n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n\n\n\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n\n           prog);\n\n    \n\n    if (!do_play) {\n\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n\n               \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\");\n\n    } else {\n\n        printf(\"usage: ffplay [options] input_file...\\n\"\n\n               \"Simple audio player\\n\");\n\n    }\n\n           \n\n    printf(\"\\n\"\n\n           \"Main options are:\\n\");\n\n    for(i=0;i<2;i++) {\n\n        if (i == 1)\n\n            printf(\"\\nAdvanced options are:\\n\");\n\n        for(po = options; po->name != NULL; po++) {\n\n            char buf[64];\n\n            expert = (po->flags & OPT_EXPERT) != 0;\n\n            if (expert == i) {\n\n                strcpy(buf, po->name);\n\n                if (po->flags & HAS_ARG) {\n\n                    strcat(buf, \" \");\n\n                    strcat(buf, po->argname);\n\n                }\n\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n\n            }\n\n        }\n\n    }\n\n\n\n    exit(1);\n\n}\n", "idx": 21050, "substitutes": {"prog": [" proge", "procg", "comg", "proge", " progs", " progn", "Progn", "progp", "procgp", "Proge", " Proge", "Progp", "progn", " Prog", " progm", " proG", " Progs", "comgs", " Progp", "progm", "comgn", "procgn", "ProG", "comgm", "proG", "progs", " progp", "procG", "Progm", "Prog", "Progs"], "po": ["fo", "PO", "wo", "mo", "ta", "so", "p", "ko", "o", "oto", "O", "pr", "ppo", "pe", "apo", "ho", "roo", "pd", "flo", "ps", "oe", "co", "mot", "ato", "mi", "Mo", "oo", "ote", "aco", "pot", "jo", "obo", "pt", "pty", "pos", "ogo", "ota", "cho", "Po", "pa", "opa", "hea", "odo", "note", "ao", "obj", "cro", "ico", "ppa", "policy", "por", "pi", "vo", "elo", "bo"], "i": ["hi", "m", " ti", "ci", "ix", "p", "us", " bi", "si", "zi", "multi", "n", "ei", "y", "it", "ims", "xi", "init", "status", "l", "ti", "mi", "qi", "gu", "iu", "chain", "c", "s", "u", "j", "iter", "di", "in", "go", "ai", "t", "im", "ki", "ie", "k", " ii", "fi", "ui", "phi", "gi", "li", "ic", "g", " j", "cli", "sim", "iq", "ini", "bi", "ind", "oi", "index", "ii", "x", "pi", "batch", "asi", "h", "I", "yi", " ni", "f", "is", "v"], "expert": ["EXpert", "expcellent", "suprotected", "supert", " excellent", "exdebug", "Exprotected", "exotic", "exptern", "exper", " exotic", "EXdebug", "super", "Exference", " exper", "texcellent", "texotic", "exppert", "EXprotected", "exprotected", "Excellent", "expper", "texference", "sutern", " exference", "EXcellent", "Exotic", "Exdebug", "excellent", "expdebug", "exference", "Expert", "texpert", " exprotected", "expprotected"], "buf": ["ctx", "pkg", "uf", "data", "font", "tr", "req", "length", "tmp", "um", " buffer", "br", "Buffer", "needed", "result", "text", "proc", "buff", "vp", "iter", "cmd", "img", "uv", "bh", "db", "rb", "buffer", "cat", "txt", "ref", "vec", "var", "Buff", "window", "pb", "mb", "cur", "emb", "row", "zero", "out", "ctr", "mem", "conv", "queue", "str", "aka", "fb", "new", "err", "pg", "alloc", "cap", "block", "pool", "cb", "cv"]}}
{"project": "FFmpeg", "commit_id": "b8a2331a70b720e83e1be243f7d17941c8952ef2", "target": 1, "func": "av_cold int ffv1_common_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n\n\n    if (!avctx->width || !avctx->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    s->avctx = avctx;\n\n    s->flags = avctx->flags;\n\n\n\n    s->picture.f = avcodec_alloc_frame();\n\n    s->last_picture.f = av_frame_alloc();\n\n\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n\n\n    s->width  = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    // defaults\n\n    s->num_h_slices = 1;\n\n    s->num_v_slices = 1;\n\n\n\n    return 0;\n\n}", "idx": 21061, "substitutes": {"avctx": ["avsys", "avercp", "aftx", "abctx", "avcmp", "verkl", "vercmp", "avpy", "vancmd", "avetx", " avloc", "avectx", "avcontext", "vcp", " avtx", "avtx", "capctx", "awreq", "aveloc", "afsys", " avreq", "ajjac", "verctx", "wavcfg", "aversys", "afpy", "avercmp", "avobj", "afcfg", "ajctx", " avsys", "navctx", "avectr", "avcp", "afctx", " avcmp", "ajpy", "avjac", "wavcu", "navcfg", "avctr", "averjac", "vcmd", "afobj", " avpkg", "averkt", "navcu", "averkl", "navpkg", "abrt", "afloc", " avcontext", "avereq", "averctx", " avkt", "avercu", "abtx", "avkt", "afcontext", "awcmp", "avertx", "awctx", "avrt", "avcfg", " avobj", "abcp", "averpy", "vrt", "avreq", "avercfg", "verobj", "avloc", "vtx", "capkl", " avctr", "vancontext", " avcfg", "avkl", "vcontext", "avercontext", "averrt", "vercontext", " avcmd", "vancp", " avcu", "avcu", "vertx", "afjac", "wavctx", "avecmp", "ajtx", "vctx", "avpkg", " avcp", "capcmp", "captx", "awctr", "wavpkg", "vanctx", "avecfg", "wavkt", "avcmd"], "s": ["js", "gs", "spec", "sl", "ls", "sq", "ass", "es", "p", "rs", "bs", "z", "details", "conf", "sb", "vs", "gets", "parts", "ps", "n", "y", "eps", "fs", "acs", "ims", "ds", "has", "ms", "b", "c", "cs", "ess", "as", "ts", "ss", "i", "stats", "aws", "set", "ns", "ins", "its", "hs", "ports", "sts", "sv", "qs", "sys", "ats", "se", "os", "S", "als", "st", "is", "pers", "v", "comm"]}}
{"project": "FFmpeg", "commit_id": "c776531aef9b546ca576d4c8e3ec14a513394618", "target": 0, "func": "static int vqa_decode_chunk(VqaContext *s)\n\n{\n\n    unsigned int chunk_type;\n\n    unsigned int chunk_size;\n\n    int byte_skip;\n\n    unsigned int index = 0;\n\n    int i;\n\n    unsigned char r, g, b;\n\n    int index_shift;\n\n    int res;\n\n\n\n    int cbf0_chunk = -1;\n\n    int cbfz_chunk = -1;\n\n    int cbp0_chunk = -1;\n\n    int cbpz_chunk = -1;\n\n    int cpl0_chunk = -1;\n\n    int cplz_chunk = -1;\n\n    int vptz_chunk = -1;\n\n\n\n    int x, y;\n\n    int lines = 0;\n\n    int pixel_ptr;\n\n    int vector_index = 0;\n\n    int lobyte = 0;\n\n    int hibyte = 0;\n\n    int lobytes = 0;\n\n    int hibytes = s->decode_buffer_size / 2;\n\n\n\n    /* first, traverse through the frame and find the subchunks */\n\n    while (bytestream2_get_bytes_left(&s->gb) >= 8) {\n\n\n\n        chunk_type = bytestream2_get_be32u(&s->gb);\n\n        index      = bytestream2_tell(&s->gb);\n\n        chunk_size = bytestream2_get_be32u(&s->gb);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case CBF0_TAG:\n\n            cbf0_chunk = index;\n\n            break;\n\n\n\n        case CBFZ_TAG:\n\n            cbfz_chunk = index;\n\n            break;\n\n\n\n        case CBP0_TAG:\n\n            cbp0_chunk = index;\n\n            break;\n\n\n\n        case CBPZ_TAG:\n\n            cbpz_chunk = index;\n\n            break;\n\n\n\n        case CPL0_TAG:\n\n            cpl0_chunk = index;\n\n            break;\n\n\n\n        case CPLZ_TAG:\n\n            cplz_chunk = index;\n\n            break;\n\n\n\n        case VPTZ_TAG:\n\n            vptz_chunk = index;\n\n            break;\n\n\n\n        default:\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: Found unknown chunk type: %c%c%c%c (%08X)\\n\",\n\n            (chunk_type >> 24) & 0xFF,\n\n            (chunk_type >> 16) & 0xFF,\n\n            (chunk_type >>  8) & 0xFF,\n\n            (chunk_type >>  0) & 0xFF,\n\n            chunk_type);\n\n            break;\n\n        }\n\n\n\n        byte_skip = chunk_size & 0x01;\n\n        bytestream2_skip(&s->gb, chunk_size + byte_skip);\n\n    }\n\n\n\n    /* next, deal with the palette */\n\n    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CPL0 and CPLZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the palette chunk */\n\n    if (cplz_chunk != -1) {\n\n\n\n/* yet to be handled */\n\n\n\n    }\n\n\n\n    /* convert the RGB palette into the machine's endian format */\n\n    if (cpl0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the palette size */\n\n        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found a palette chunk with %d colors\\n\",\n\n                chunk_size / 3);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        for (i = 0; i < chunk_size / 3; i++) {\n\n            /* scale by 4 to transform 6-bit palette -> 8-bit */\n\n            r = bytestream2_get_byteu(&s->gb) * 4;\n\n            g = bytestream2_get_byteu(&s->gb) * 4;\n\n            b = bytestream2_get_byteu(&s->gb) * 4;\n\n            s->palette[i] = (r << 16) | (g << 8) | (b);\n\n        }\n\n    }\n\n\n\n    /* next, look for a full codebook */\n\n    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBF0 and CBFZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the full codebook chunk */\n\n    if (cbfz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if ((res = decode_format80(&s->gb, chunk_size, s->codebook,\n\n                                   s->codebook_size, 0)) < 0)\n\n            return res;\n\n    }\n\n\n\n    /* copy a full codebook */\n\n    if (cbf0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the full codebook size */\n\n        if (chunk_size > MAX_CODEBOOK_SIZE) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: CBF0 chunk too large (0x%X bytes)\\n\",\n\n                chunk_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n\n    }\n\n\n\n    /* decode the frame */\n\n    if (vptz_chunk == -1) {\n\n\n\n        /* something is wrong if there is no VPTZ chunk */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: no VPTZ chunk found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);\n\n    chunk_size = bytestream2_get_be32(&s->gb);\n\n    if ((res = decode_format80(&s->gb, chunk_size,\n\n                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)\n\n        return res;\n\n\n\n    /* render the final PAL8 frame */\n\n    if (s->vector_height == 4)\n\n        index_shift = 4;\n\n    else\n\n        index_shift = 3;\n\n    for (y = 0; y < s->frame.linesize[0] * s->height;\n\n        y += s->frame.linesize[0] * s->vector_height) {\n\n\n\n        for (x = y; x < y + s->width; x += 4, lobytes++, hibytes++) {\n\n            pixel_ptr = x;\n\n\n\n            /* get the vector index, the method for which varies according to\n\n             * VQA file version */\n\n            switch (s->vqa_version) {\n\n\n\n            case 1:\n\n                lobyte = s->decode_buffer[lobytes * 2];\n\n                hibyte = s->decode_buffer[(lobytes * 2) + 1];\n\n                vector_index = ((hibyte << 8) | lobyte) >> 3;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                /* uniform color fill - a quick hack */\n\n                if (hibyte == 0xFF) {\n\n                    while (lines--) {\n\n                        s->frame.data[0][pixel_ptr + 0] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 1] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 2] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 3] = 255 - lobyte;\n\n                        pixel_ptr += s->frame.linesize[0];\n\n                    }\n\n                    lines=0;\n\n                }\n\n                break;\n\n\n\n            case 2:\n\n                lobyte = s->decode_buffer[lobytes];\n\n                hibyte = s->decode_buffer[hibytes];\n\n                vector_index = (hibyte << 8) | lobyte;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                break;\n\n\n\n            case 3:\n\n/* not implemented yet */\n\n                lines = 0;\n\n                break;\n\n            }\n\n\n\n            while (lines--) {\n\n                s->frame.data[0][pixel_ptr + 0] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 1] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 2] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 3] = s->codebook[vector_index++];\n\n                pixel_ptr += s->frame.linesize[0];\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle partial codebook */\n\n    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBP0 and CBPZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (cbp0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n\n\n            /* time to replace codebook */\n\n            memcpy(s->codebook, s->next_codebook_buffer,\n\n                s->next_codebook_buffer_index);\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    if (cbpz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n            GetByteContext gb;\n\n\n\n            bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n\n            /* decompress codebook */\n\n            if ((res = decode_format80(&gb, s->next_codebook_buffer_index,\n\n                                       s->codebook, s->codebook_size, 0)) < 0)\n\n                return res;\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21070, "substitutes": {"s": ["js", "gs", "south", "spec", "ls", "p", "sq", "es", "rs", "bs", "state", "details", "conf", "w", "sb", "n", "ps", "bis", "fs", "ds", "status", "ains", "sa", "c", "cs", "an", "settings", "as", "sw", "ts", "ses", "serv", "ss", "stats", "t", "aws", "set", "ns", "ins", "a", "hs", "e", "sam", "source", "sts", "sv", "qs", "sys", "ats", "sg", "os", "se", "S", "ops", "ex", "is", "v", "comm"], "chunk_type": ["chacket_prefix", "chocolTypeType", "chault_option", "chunk_key", "chdownloadLtype", "chunk_stat", "chunktypetype", "chocolTyperole", "chunks_Type", "chunk_option", "chdownloadLtag", "chunkTypestat", "chacket_status", "chunkLype", "chunk64option", "chacket_tag", "chunks_class", "chacket_type", "chunk_class", "chunkTyperole", "chunkOsize", "chdownloadLsize", "chunk64typ", "chdownload_size", "chunktypeType", "chunk_TYPE", "chom_key", "chunkLtag", "chault_Type", "chunk_Type", "chunkTypeType", "chocol_role", "chault_TYPE", "chdownload_type", "chocolTypestat", "chunkLtype", "chunk_status", "chunk_tag", "chom_tag", "chom_kind", "chunk_typ", "chunkLsize", "chault_type", "chunk_role", "chunktypeTYPE", "chdownloadLype", "chunk64tag", "chunkOype", "chunk_ype", "chdownload_tag", "chunkPoption", "chdownload_ype", "chunkTypetype", "chunkOtag", "chunk_prefix", "chault_typ", "chunk_kind", "chunkPtyp", "chom_type", "chocol_Type", "chunkPtag", "chault_tag", "chocol_type", "chocolTypetype", "chunk64type", "chunks_type", "chunkPtype", "chunktypetyp", "chocol_stat", "chunkOtype", "chunks_size"], "chunk_size": ["chunk_Size", "chunk_offset", "chacket_size", "chob_Size", "chunk64size", "chacket_time", "chunk__size", "chunk_len", "chob_size", "chunk__type", "chunk_speed", "chacket_speed", "chacket_offset", "chunk__speed", "chunk64type", "chunk_length", "chunk__time", "chacket_length", "chob_len", "chunk64speed", "chob_length", "chunk64time", "chacket_type", "chunk_time"], "byte_skip": ["bytelexskip", "word_offset", "byte__offset", "byte__miss", "byteplaceoffset", "byte_miss", "byteplacefilter", "byte_filter", "word_skip", "bytelexshift", "byte__shift", " byte_shift", "bytelexoffset", "byte__skip", "word_shift", "bytelexfilter", "byte_shift", " byte_offset", "byteplaceskip", "byteplaceshift", "byte_offset", "word_filter", " byte_miss"], "i": ["m", "ci", "p", "z", "id", "si", "n", "it", "l", "info", "c", "j", "pos", "t", "ip", "bi", "e", "index", "ii", "pi", "I", "f", "v"], "r": ["m", "cr", "rx", "p", "name", "w", "br", "l", "er", "c", "t", "ar", "R", "rb", "vr", "re", "a", "e", "h", "str", "rc", "f", "v"], "g": ["gc", "m", "q", "p", "G", "gg", "ga", "d", "tg", "n", "l", "c", "j", "gh", "k", "u", "gi", "bg", "ge", "e", "gp", "h", "f", "v"], "b": ["m", "bb", "p", "eb", "nb", "be", "bc", "ba", "d", "sb", "ab", "l", "B", "c", "t", "db", "bg", "a", "bi", "bf", "h", "fb", "f", "cb", "v"], "index_shift": ["row_align", "row_shift", "index_size", "index_align", "indexmodshift", "indexmodsize", "index_start", "indexmodstart", "row_start", "row_size", "indexmodalign"], "res": ["rs", "bits", "req", "resolution", "ires", "result", "RES", "lock", "raw", "tx", "version", "results", "rows", "error", "rev", "Res", "ress", "mem", "base", "xy", "os", "vals", "err", "dim", "ex", "ries", "final"], "x": ["m", "ox", "rx", "ix", "p", "o", "dx", "pixel", "w", "l", "c", "tx", "point", "pos", "t", "lat", "X", "xy", "xs", "index", "px", "ex", "v"], "y": ["iy", "m", "p", "my", "o", "z", "ym", "vy", "py", "sky", "ny", "c", "Y", "j", "t", "yy", "col", "key", "ies", "ey", "ch", "xy", "index", "sy", "v"], "pixel_ptr": ["image_pointer", "image_set", "image_offset", "pixel_offset", "pixel_set", "image_ptr", "pixel_pointer"], "lobytes": ["elloyches", "lotches", "elloytes", "ellobyte", "elloyte", "lobyts", "locyts", "loyte", "elloyts", "locyches", "loyts", "locyte", "loyches", "ellobyts", "ellobytes", "lobyte", "loytes", "lottes", "lotte", "lobyches", "lotts", "ellobyches", "locytes"], "hibytes": ["hibbyces", "labobycks", "hibuycks", "labyces", "hibuytes", "hibyces", "labycks", "labobyte", "hibobyte", "labobyces", "labobytes", "hibbyte", "labytes", "hibbytes", "hibobytes", "hibobycks", "hibycks", "hibyte", "labyte", "hibuyces", "hibbycks", "hibobyces", "hibuyte"], "lines": ["pins", "bands", "sets", "steps", "ls", "heads", "ines", "points", "ln", "links", "bytes", "blocks", "les", "cells", "line", "limits", "errors", "keys", "faces", "ns", "verts", "boxes", "elines", "planes", "levels", "os", "vals", "pages", "codes"], "gb": ["cfg", "gc", "gs", "uf", "eg", "bb", "nb", "ground", "gg", "gm", "gov", "sb", "gd", "Gb", "got", "gpu", " GB", "GB", "storage", "html", "gh", "deg", "img", "args", "gif", "gz", "db", "kb", "rb", "bg", "vg", "jpg", "ge", "mb", "gp", "bf", "gt", "rg", "fb", "hub", "gom", "cb"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_mmio_map(PCIDevice *d, int region_num,\n\n                              pcibus_t addr, pcibus_t size, int type)\n\n{\n\n    int mmio_io_addr;\n\n\n\n    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,\n\n                                                 DEVICE_NATIVE_ENDIAN);\n\n\n\n    cpu_register_physical_memory(addr, size, mmio_io_addr);\n\n}\n", "idx": 21092, "substitutes": {"d": ["m", "p", "dx", "w", "pd", "dt", "fd", "ds", "dh", "s", "c", "r", "di", "da", "t", "dm", "g", "db", "did", "dc", "dd", "de", "e", "h", "D", "sd", "f", "v"], "region_num": [" region_Num", " region_number", " region_no", "region_no", "region_Num", "region_number"], "addr": ["add", "Address", "adr", "start", "rs", "data", "mod", "id", "pad", "loc", "port", "ptr", "ash", "url", "src", "fd", "offset", "attr", "dh", "nl", "address", "ord", "location", "cmd", "order", "dr", "pos", "map", "res", "arity", "ref", "var", "store", "oa", "coord", "handle", "eth", "mem", "arr", "index", "hw", "alloc", "ad", "mt"], "size": ["description", " format", "start", "data", "body", "name", "SIZE", "id", "length", "small", "fat", "range", "scale", "Size", "bytes", "offset", "amount", "max", "mode", "address", "kind", "storage", "empty", " sizes", "format", "shape", "args", "sum", "set", "area", "izes", "count", "store", "len", "code", "mem", "ize", "fee", "iz"], "type": ["p", "state", "name", "id", "pe", "unit", "tag", "typ", "Type", "types", "dt", "offset", "style", "ype", "mode", "info", "address", "kind", "speed", "t", "shape", "error", "TYPE", "count", "time", "weight"], "mmio_io_addr": ["mmio_io___addr", "mmio_io_ptr", "mmio_io___ad", "mmio_io_address", "mmio_io___address", "mmio_io_add", "mmio_i_ad", "mmio_io__id", "mmio_i_address", "mmio_i_ptr", "mmio_io_ad", "mmio_i_id", "mmio_i_add", "mmio_i_addr", "mmio_io__addr", "mmio_io_id", "mmio_io__address"]}}
{"project": "qemu", "commit_id": "ac4b0d0c4feb291643c0e8a07a92e449e13881b5", "target": 0, "func": "static void bt_submit_hci(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t cmd;\n\n    int paramlen, i;\n\n\n\n    if (length < HCI_COMMAND_HDR_SIZE)\n\n        goto short_hci;\n\n\n\n    memcpy(&hci->last_cmd, data, 2);\n\n\n\n    cmd = (data[1] << 8) | data[0];\n\n    paramlen = data[2];\n\n    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)\t/* NOP */\n\n        return;\n\n\n\n    data += HCI_COMMAND_HDR_SIZE;\n\n    length -= HCI_COMMAND_HDR_SIZE;\n\n\n\n    if (paramlen > length)\n\n        return;\n\n\n\n#define PARAM(cmd, param)\t(((cmd##_cp *) data)->param)\n\n#define PARAM16(cmd, param)\tle16_to_cpup(&PARAM(cmd, param))\n\n#define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle))\n\n#define LENGTH_CHECK(cmd)\tif (length < sizeof(cmd##_cp)) goto short_hci\n\n    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp\n\n     * needs to be updated every time a command is implemented here!  */\n\n    switch (cmd) {\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):\n\n        LENGTH_CHECK(inquiry);\n\n\n\n        if (PARAM(inquiry, length) < 1) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 0;\n\n        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n\n        hci->lm.responses = 0;\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):\n\n        if (!hci->lm.inquire || hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):\n\n        LENGTH_CHECK(periodic_inquiry);\n\n\n\n        if (!(PARAM(periodic_inquiry, length) <\n\n                                PARAM16(periodic_inquiry, min_period) &&\n\n                                PARAM16(periodic_inquiry, min_period) <\n\n                                PARAM16(periodic_inquiry, max_period)) ||\n\n                        PARAM(periodic_inquiry, length) < 1 ||\n\n                        PARAM16(periodic_inquiry, min_period) < 2 ||\n\n                        PARAM16(periodic_inquiry, max_period) < 3) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 1;\n\n        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n\n        hci->lm.responses = 0;\n\n        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):\n\n        if (!hci->lm.inquire || !hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        qemu_del_timer(hci->lm.inquiry_next);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):\n\n        LENGTH_CHECK(create_conn);\n\n\n\n        if (hci->lm.connecting >= HCI_HANDLES_MAX) {\n\n            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);\n\n            break;\n\n        }\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n\n            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):\n\n        LENGTH_CHECK(disconnect);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n\n                        PARAM(disconnect, reason));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):\n\n        LENGTH_CHECK(create_conn_cancel);\n\n\n\n        if (bt_hci_lmp_connection_ready(hci,\n\n                                &PARAM(create_conn_cancel, bdaddr))) {\n\n            for (i = 0; i < HCI_HANDLES_MAX; i ++)\n\n                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&\n\n                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,\n\n                                        &PARAM(create_conn_cancel, bdaddr)))\n\n                   break;\n\n\n\n            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?\n\n                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        } else\n\n            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):\n\n        LENGTH_CHECK(accept_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(accept_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_accept(hci, hci->conn_req_host);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):\n\n        LENGTH_CHECK(reject_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(reject_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_reject(hci, hci->conn_req_host,\n\n                        PARAM(reject_conn_req, reason));\n\n        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):\n\n        LENGTH_CHECK(auth_requested);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):\n\n        LENGTH_CHECK(set_conn_encrypt);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_encrypt_change(hci,\n\n                            PARAMHANDLE(set_conn_encrypt),\n\n                            PARAM(set_conn_encrypt, encrypt));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):\n\n        LENGTH_CHECK(remote_name_req);\n\n\n\n        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):\n\n        LENGTH_CHECK(remote_name_req_cancel);\n\n\n\n        bt_hci_event_complete_name_cancel(hci,\n\n                        &PARAM(remote_name_req_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):\n\n        LENGTH_CHECK(read_remote_features);\n\n\n\n        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):\n\n        LENGTH_CHECK(read_remote_ext_features);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_read_remote_ext_features(hci,\n\n                            PARAMHANDLE(read_remote_ext_features));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):\n\n        LENGTH_CHECK(read_remote_version);\n\n\n\n        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):\n\n        LENGTH_CHECK(read_clock_offset);\n\n\n\n        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):\n\n        LENGTH_CHECK(read_lmp_handle);\n\n\n\n        /* TODO: */\n\n        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):\n\n        LENGTH_CHECK(hold_mode);\n\n\n\n        if (PARAM16(hold_mode, min_interval) >\n\n                        PARAM16(hold_mode, max_interval) ||\n\n                        PARAM16(hold_mode, min_interval) < 0x0002 ||\n\n                        PARAM16(hold_mode, max_interval) > 0xff00 ||\n\n                        (PARAM16(hold_mode, min_interval) & 1) ||\n\n                        (PARAM16(hold_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n\n                                PARAM16(hold_mode, max_interval),\n\n                                acl_hold))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):\n\n        LENGTH_CHECK(park_mode);\n\n\n\n        if (PARAM16(park_mode, min_interval) >\n\n                        PARAM16(park_mode, max_interval) ||\n\n                        PARAM16(park_mode, min_interval) < 0x000e ||\n\n                        (PARAM16(park_mode, min_interval) & 1) ||\n\n                        (PARAM16(park_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n\n                                PARAM16(park_mode, max_interval),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):\n\n        LENGTH_CHECK(exit_park_mode);\n\n\n\n        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):\n\n        LENGTH_CHECK(role_discovery);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n\n        else\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(role_discovery),\n\n                            bt_hci_role_master(hci,\n\n                                    PARAMHANDLE(role_discovery)));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):\n\n        LENGTH_CHECK(set_event_mask);\n\n\n\n        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):\n\n        bt_hci_reset(hci);\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):\n\n        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n\n            /* No length check */;\n\n        else\n\n            LENGTH_CHECK(set_event_flt);\n\n\n\n        /* Filters are not implemented */\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):\n\n        LENGTH_CHECK(flush);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(flush));\n\n        else {\n\n            /* TODO: ordering? */\n\n            bt_hci_event(hci, EVT_FLUSH_OCCURRED,\n\n                            &PARAM(flush, handle),\n\n                            EVT_FLUSH_OCCURRED_SIZE);\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(flush));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):\n\n        LENGTH_CHECK(change_local_name);\n\n\n\n        if (hci->device.lmp_name)\n\n            free((void *) hci->device.lmp_name);\n\n        hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n\n                        sizeof(PARAM(change_local_name, name)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):\n\n        bt_hci_event_complete_read_local_name(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):\n\n        bt_hci_event_complete_read_conn_accept_timeout(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):\n\n        /* TODO */\n\n        LENGTH_CHECK(write_conn_accept_timeout);\n\n\n\n        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n\n                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):\n\n        bt_hci_event_complete_read_scan_enable(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):\n\n        LENGTH_CHECK(write_scan_enable);\n\n\n\n        /* TODO: check that the remaining bits are all 0 */\n\n        hci->device.inquiry_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n\n        hci->device.page_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):\n\n        bt_hci_event_complete_read_local_class(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):\n\n        LENGTH_CHECK(write_class_of_dev);\n\n\n\n        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n\n                        sizeof(PARAM(write_class_of_dev, dev_class)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):\n\n        bt_hci_event_complete_voice_setting(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):\n\n        LENGTH_CHECK(write_voice_setting);\n\n\n\n        hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):\n\n        if (length < data[0] * 2 + 1)\n\n            goto short_hci;\n\n\n\n        for (i = 0; i < data[0]; i ++)\n\n            if (bt_hci_handle_bad(hci,\n\n                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))\n\n                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)\n\n         * else\n\n         *     goto unknown_command */\n\n        bt_hci_event_complete_read_inquiry_mode(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)\n\n         * else\n\n         *     goto unknown_command */\n\n        LENGTH_CHECK(write_inquiry_mode);\n\n\n\n        if (PARAM(write_inquiry_mode, mode) > 0x01) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n", "idx": 21100, "substitutes": {"info": ["INFO", "fo", "check", "try", "basic", "success", "report", "json", "name", "id", "one", "conf", "by", "Info", "def", "information", "force", "it", "init", "status", "bit", "good", "inf", "history", "kind", "about", "error", "fi", "frame", "work", "is", "now", "index", "os", "nr", "stat", "f", " inf", "help"], "data": ["end", "name", "bin", "aw", "join", "extra", "buf", "a", "none", "DATA", "x", "block", "Data", "table", "list", "d", "trans", "cache", "it", "l", " DATA", "pointer", "pos", "message", "read", "hash", "len", "xy", "dev", "done", "bits", "pad", "mu", "to", "offset", "text", "limit", "raw", "res", "msg", "window", "next", "time", "str", "batch", "rel", "bus", "dat", "p", "start", "input", "w", "def", "value", "n", "bytes", "values", "no", "t", "size", "buffer", "out", "all", "ata", "addr", "new", "val"], "length": ["ty", " l", "vector", "height", "end", " lengths", "p", "full", "sp", "be", "type", "L", "ength", "w", "ptr", "padding", "maximum", "duration", "value", "component", "amount", "l", "capacity", "max", "available", "idth", "ENGTH", "address", "ow", "expected", "t", "shape", "size", "loop", "H", "message", "buffer", "phi", "position", "total", "count", " clen", "len", "number", " Length", "angle", " len", "form", "h", "time", "stop", "of", "f", "Length", "term"], "hci": [" hpi", "rco", "wci", "ohcu", " hcgi", "mcu", "ahcgi", "ohcit", " hdi", "thco", "thcu", "wdi", " hki", "rmi", "hdi", "hco", "thnic", "thpi", "hli", "ohce", "hcci", "ahce", "ohdi", "ohki", "hce", "hmco", "ohcgi", " hmi", "phcu", " hce", "hmci", "httpcu", "httpci", "phnic", "ohli", "thcci", "httpnic", "wli", "hnic", "phuci", "hcgi", "ahci", "thki", "lcci", " hco", "phci", "hmi", "ahco", "ohci", " hcci", "rcci", "httpuci", " hcu", "thuci", "hcu", "Hpi", "hmcit", "Hci", "wcci", "mco", "hki", "hpi", "mcci", "ohco", "Hcu", " hli", "rci", "Hcgi", "thci", "hcit", "lmi", "huci", "Hco", " hcit", "Hcci", "hmcu", "lco", "mci", "lci", "ohcci"], "cmd": ["ctx", "cp", "pkg", "command", "cfg", "tp", "grad", "qt", "mk", "name", "id", "handler", "req", "help", "quit", "path", "tmp", "def", "conn", "prop", "ext", "rn", "bind", "init", "text", "prefix", "attr", "mode", "kind", " command", "raw", "MD", "nt", "act", "comm", "auth", "det", "Command", "cd", "opt", "msg", "txt", "cat", "cli", "cur", "resp", "buf", "md", "rol", "handle", "obj", "code", "arg", "ind", "ctr", "ch", "mem", "gt", "param", "rpm", "op", "batch", "addr", "call", "Cmd", "cb", "cmp", "cont", "term", "cod", "ct"], "paramlen": ["inputlength", "aramlen", "ParamLen", "Paramlength", "aramLen", "keylength", "memberlen", "keylen", "inputcount", "membercoll", "Paramlen", "memcount", "paramcount", "inputLen", "parlen", "parlength", "paramcoll", "paramlength", "parcount", "aramcoll", "aramlength", "keylan", "parLen", "paramLen", "inputlen", "aramlan", "memberlength", "paramlan", "memlen", "memberlan", "keycoll", "memlength", "memLen"], "i": ["m", "ci", "p", "id", "iat", "n", "it", "init", "mi", "j", "di", "in", "ai", "t", "ip", "a", "ati", "ind", "h", "ii", "x", "pi", "index", "I", "dim", "f", "im"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,\n\n                                        uint8_t isc, bool swap,\n\n                                        bool is_maskable)\n\n{\n\n    struct kvm_s390_io_adapter adapter = {\n\n        .id = id,\n\n        .isc = isc,\n\n        .maskable = is_maskable,\n\n        .swap = swap,\n\n    };\n\n    KVMS390FLICState *flic = KVM_S390_FLIC(fs);\n\n    int r, ret;\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,\n\n        .addr = (uint64_t)&adapter,\n\n    };\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {\n\n        /* nothing to do */\n\n        return 0;\n\n    }\n\n\n\n    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);\n\n\n\n    ret = r ? -errno : 0;\n\n    return ret;\n\n}\n", "idx": 21102, "substitutes": {"fs": ["js", "ls", "es", "linux", "bs", "rs", "fw", "vs", "eks", "ps", "irs", "fd", "ims", "ds", "ms", "files", "ics", "s", "cs", "fc", "grid", "ts", "ss", "ys", "xml", "aws", "fi", "ns", "FS", "hs", "bf", "xs", "sys", "cf", "fps", "f", "is"], "id": ["ida", "pid", "ick", "name", "bid", "ide", "type", "ids", "ih", "path", "d", "tag", "fd", "wid", "init", "status", "ms", "info", "kind", "Id", "hid", "kid", "i", "cd", "key", "ref", "ident", "iq", "ip", "desc", "sid", "md", "ID", "aid", "h", "index", "oid", "uid", "rid", " tid", "mid", "addr", "ad", "vid", "f", "is"], "isc": ["gc", "isf", "oc", "inc", "bs", "soc", "secure", "iw", "tech", "ih", "mic", "iris", "disc", "sc", "cc", "ich", "status", "ISC", "wic", "ics", "irc", "cs", "fc", "isk", "iss", "isch", "cycles", "ib", "nic", "ec", "isp", "stats", "misc", "ic", "pc", "dc", "ish", "eth", "sec", "usc", "ico", "isco", "pic", "sys", "sk", "icons", "alloc", "isa", "stat", "is", "icon", "rc"], "swap": ["reshap", "twift", "wrap", "swape", "snift", " swrap", "wape", " swape", "swash", "snip", "snash", "maskap", "shop", "wap", "snop", "snarp", "wapped", "twip", "shap", "shift", "snrap", "reshrap", "swrap", "maskrap", "swift", "swarp", "swip", "wash", "maskash", "reshape", "warp", "maskarp", "snap", "swapped", "ship", " swapped", "reshapped", "twop", "twap", "swop"], "is_maskable": ["is_askability", "is_ask_", "is_Maskability", "is_asked", "is_allowed", "is_askworthy", "is_cleaned", "is_asker", "is_allow_", "is_mask_", "is_lockable", "is_locker", "is_locked", "is_masker", "is_Maskable", "is_cleanability", "is_cleanworthy", "is_Maskworthy", "is_Masked", "is_maskability", "is_lock_", "is_allower", "is_masked", "is_allowable", "is_askable", "is_cleanable", "is_maskworthy"], "flic": [" flict", " fLic", " fnic", "llic", "folin", "lolin", "fnic", "vlict", "volin", "kLic", "lic", "fic", " fic", "flig", "lnic", "vic", "klig", "flict", "klict", "vlic", "vLic", " flig", " folin", "vlig", "fLic", "klic", "vnic"], "r": ["ror", "m", "cr", "q", "p", "mr", "rs", "ter", "tr", "or", "w", "d", "n", "rw", "it", "l", "er", "b", "rt", "ry", "c", "i", "rar", "t", "ar", "k", "R", "u", "g", "rb", "vr", "re", "ru", "out", "e", "sr", "h", "x", "rg", "usr", "rc", "rr", "rd", "err", "nr", "f", "v"], "ret": ["gc", "reset", "q", "rs", "alt", "tr", "Ret", "jp", "dt", "rem", "att", "result", "attr", " Ret", "rt", "xt", "j", "nt", "flag", "dr", "t", "ar", "ft", "res", "error", "set", "rev", "ref", "re", "mb", "out", "rets", "gt", "sr", "nz", "arr", "rr", "rd", "usr", "new", "err", "rm", "RET", "rel", "st", "mt", "f", "rc", "val"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                int lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                int lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_ff1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_fl1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 21106, "substitutes": {"dc": ["ci", "oc", "dat", "td", "bc", "xc", "DC", "tc", "icc", "nc", "cm", "mc", "dt", "cc", "sc", "fc", "lc", "di", "ec", " DC", "da", "dm", "dl", "cd", "pc", "dp", "rc", "df"], "insn": ["tsgn", "itsl", "insnin", " insnw", "tsns", "itssn", "risn", "ksname", "ssc", "ssns", "imsn", "INSname", "INSgn", "ksnw", "pssn", "inssn", "linsnr", "insns", "ssn", "linsns", "inspan", "imsnin", "psgn", "intsn", "imssn", "vsgn", "tsc", "insnw", "pinssn", "psname", "kssn", "imsnr", "risnr", "attsnz", " inssn", "itsn", " insnz", "csns", "inl", "inns", "ksn", "pinspan", "rissn", "pinsnw", "insnz", "vssn", "insl", "attsnw", "intsnz", "linsnw", "INSsn", "attsn", "psn", "tsn", "insname", "kspan", "csc", "itsns", "csn", "linsl", "ksgn", "ksnr", "linssn", "pinsgn", "insgn", "pinsnr", "INSnin", "inn", "insc", "insnr", "risnin", "INSn", "attssn", "ssgn", "linsgn", "INSnr", "linsn", "intsnw", "vsn", "vspan", "csgn", "pinsn", "intssn"], "op0": ["opt00", "OP00", "OP2", "hop0", "OP5", "hop2", "p0", "hop1", "ip0", "op00", "p1", "opt2", "ip1", "p5", "OP0", "hop5", "op5", " op00", "p2", "opt1", "ip2", "OP1", "opt0"], "op1": ["Op2", "OP01", "OP2", "op01", "OP5", "Op5", "oper3", "Op01", "oper01", " op8", "oper2", "OP4", "oper1", "OP0", "Op0", "op5", "op3", "op4", "OP8", "op8", "Op3", "oper5", "oper8", " op01", "Op1", "OP1", "Op4", "OP3", " op4"], "op2": ["op6", "OP2", "OP5", "opt5", "OP6", " op6", "p1", "opt2", "ip1", "p5", " op3", "p3", "op5", "op3", "ip5", "opt6", "ip3", "p2", "opt1", " op5", "OP1", "ip2"], "ra": ["ta", "rx", "ur", "gra", "rs", "tra", "ara", "ba", "loc", "rom", "ora", "tar", "dra", "rain", "aria", "red", "era", "sa", "rise", "raf", "r", "ran", "la", "po", "RA", "da", "rar", "ar", "rap", "ina", "area", "ras", "ma", "from", "rf", "res", "ri", "ru", "Ra", "a", "ro", "cro", "au", "sr", "ata", "rum", "stra", "ring", "rc"], "rb": ["hr", "erb", "bb", "nb", "mr", "rs", "sb", "wb", "gb", "rw", "ab", "ob", "b", "lr", "rt", "raf", "r", "rar", "db", "rf", "vr", "lb", "pb", "ru", "zb", "ro", "rob", "rib", "reb", "rub", "rab", "rl", "rg", "RB", "sr", "rr", "rid", "fb", "nr", "cb", "rc"], "rd": ["ird", "hr", "cr", "rx", "mr", "rs", "td", "pr", "d", "ld", "nder", "fr", "rw", "red", "rn", "fd", "dra", "rh", "lr", "rt", "raf", "r", "dr", "rat", "rar", "rf", "nd", "cd", "dd", "ri", "ru", "RD", "ro", "rob", "rl", "sr", "rg", "rr", "rid", "rm", "bd", "rc"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n", "idx": 21110, "substitutes": {"timer_list": ["imer2spec", "timer_lists", "imer_spec", "imer2listed", "timer_out", " timermatout", "timermylist", "timer_spec", "imer_list", "timer_listed", " timermatdef", "timermatout", "imer_lists", " timermatarray", "imer2list", "timermatlist", "imer2lists", " timer_array", "timermatdef", "timer_array", "timer_def", "timer2lists", " timer_def", "timermyout", "timermyarray", "timermydef", " timer_out", "timermatarray", "timer2listed", "imer_listed", "timer2spec", " timermatlist", "timer2list"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);\n\n}\n", "idx": 21118, "substitutes": {"src": ["stock", "inst", "sl", "ur", "input", "rs", "our", "fx", "secure", "image", "supp", "filename", "loc", "sb", "gb", "screen", "sc", "dest", "ser", "s", "sh", "img", "in", "sub", "txt", "look", "ins", "cur", "ipl", "sec", "usc", "ind", "source", "sr", "view", "rl", "usr", "sys", "sur", "st", "rc"], "dst": ["dnd", "Dsts", "jset", " dset", "dsnd", "Ddest", "dct", "jct", "dsst", " dsts", " dnd", "jnd", " ddest", "dsdest", "dsset", "jst", "ddest", "Dst", " dct", "dset", "dsct", "dssts", "Dset", "dsts"], "num_pixels": ["num_pidims", "num_paims", "num_pidubs", "num_pidixels", "num_pims", "num_Pubs", "num_Pairs", "num_pubs", "num_spixels", "num_nponents", "num_picks", "num_ponents", "num_pidairs", "num_sponents", "num_Pixels", "num_Picks", "num_paubs", "num_spicks", "num_Pims", "num_npairs", "num_Ponents", "num_paairs", "num_spairs", "num_pairs", "num_npixels", "num_npicks", "num_paixels"], "palette": ["palue", "calte", "Palet", "Palue", " pallete", "palettes", "facettes", "facue", "pallete", "stalte", " palte", "facet", "palet", " palettes", "calettes", "facette", "palte", "Palette", " palue", "stallete", "Palettes", " palet", "stalettes", "calette", "callete", "stalette"], "i": [" li", "multi", " mi", "ei", "ims", "chain", "mi", "uu", " wi", "\u0438", "uri", "phi", "ip", "ri", "ini", "ind", "x", "ii", "pi", "f", "ki", "im", " pi", "o", "z", " bi", "zi", "jp", " it", "it", "l", "gu", "qi", "iu", "di", "in", " j", " ni", "is", "v", "m", "me", "my", "si", " si", " di", "xi", "init", "ms", " ki", " key", "ai", "g", "ui", " multi", "li", " err", " m", " Xi", " ti", "ci", "ix", " iter", " index", "span", " info", "ij", "ti", "j", "uli", " ii", "gi", "ic", "cli", "sim", "ji", "bi", "oi", "asi", "I", "ex"]}}
{"project": "qemu", "commit_id": "e155494cf0b876c45c3c68a9ab6c641aac22dfdf", "target": 1, "func": "static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n", "idx": 21135, "substitutes": {"obj": ["any", "js", "pkg", "ctx", "oc", "o", "objects", "bo", "ot", "tmp", "conn", "typ", "oj", "Object", "ob", "attr", "ok", "obo", "j", "cmd", "nt", "go", "onet", "act", "org", "bh", "bj", "txt", "ref", "resp", "obs", "xy", "hw", "alloc", "object", "Obj", "cmp", "cod", "comm"], "ioc": ["ioko", "ioci", "tioci", "tiOC", "biocy", "liroc", "adioca", " iocy", "piroc", "diroc", "biocon", "dioko", "uiocate", "iot", "zioca", "tiocated", "iOC", "piocy", " ioci", "adioco", "zioc", "iniroc", "iniocated", "zioko", " iocation", "iniocate", "ioca", "xioc", "gioci", "liocon", "diocate", "dioca", "tiocate", "piocon", "ciOC", "giroc", " ioco", "liocation", "xiroc", "inioc", "biroc", "dioc", "iocation", "adioc", " iocon", "uiocated", "tiocon", "ziocate", " iOC", "gioint", "iocy", "adiroc", "cioc", "cioco", "iocate", "bioc", "ioint", "gioco", "giocy", "dioci", "adioint", " iroc", "tiroc", "tioco", "giocon", "dioint", "xioco", "liot", "lioc", "piot", "iocon", "dioco", " iot", "adiocate", "xioci", "ioco", "tiocy", "gioc", "uiroc", "xiocation", "iroc", "pioc", "uioc", "lioci", "tioc", "adioko", "ciroc", "iocated"]}}
{"project": "FFmpeg", "commit_id": "028cc42a1638e6f93a857f11c2568d1c3a51e612", "target": 1, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt) {\n\n    if (!strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data+5) == 2) {\n\n        uint8_t desc[256];\n\n        int score = AVPROBE_SCORE_MAX / 2, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n\n                                              pkt->size - 7,\n\n                                              0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb      = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 21155, "substitutes": {"st": ["stan", "stage", "ust", "rest", "sn", "inst", "start", "sp", "state", "at", "ist", "cast", "ST", "kt", "sb", "stable", "sc", "src", "ost", "s", "St", "rt", "sh", "storage", "sw", "nt", "ut", "pt", "act", "t", "ft", "set", "sta", "nd", "est", "stat", "irst", " est", "std", "et", "stream", "store", "sth", "th", "sts", "sv", "str", "se", "stop", "spect", "ste", "art", "ad", "mt"], "pkt": ["pkg", "proacket", "cnt", "wkt", "payett", "Pett", "cpett", "pwk", "macket", "cpnt", " pwk", "payacket", "mnt", " pkg", "pdu", "cacket", "cwd", "Packet", " packet", "ppnt", "mkt", " pwd", "pront", "cpacket", "Pkg", "ppacket", "wkg", "prowd", "cpkt", "ckt", "pett", "pwd", "Pdu", "mdu", "paykt", "ppkt", "wnt", "prokt", "wwk", "packet", "pnt", "ppwk", " pnt", "paynt", " pdu", "Pnt", "Pwk", "Pkt"], "desc": ["meta", "ribe", "dir", "description", "data", "sort", "seq", "name", "id", "esc", "ptr", "def", "des", "sc", "disc", "ext", "ds", "dict", "text", "attr", "asc", "doc", "uc", "annot", "Desc", "bl", "dl", "sub", "cd", "msg", "dc", "ript", "txt", "vec", "buf", "md", "out", "comment", "summary", "obj", "sec", "DES", "mem", "rec", "osc", "str", "metadata", "err", "bd", "cmp", " Desc", "label", "cont"], "ret": ["gc", "get", "num", "uf", "success", "alt", "Ret", "jp", "tmp", "ptr", "des", "it", "test", "rem", "status", "result", " Ret", "rt", "xt", "nl", "r", "j", "nt", "deg", "dr", "t", "ft", "res", "reg", "lt", "txt", "ref", "rev", "re", "resp", "buf", "len", "sec", "ll", "mem", "rets", "gt", "arr", "err", "elt", "RET", "progress", "val"], "ast": ["ac", "af", "any", "ust", "rest", "mast", "past", "list", "old", "ard", "add", "and", "ait", "wat", "am", "at", "ist", "cast", "AST", "tt", "aster", "must", "ace", "ann", "aft", "master", "asts", "ah", "ab", "test", "dist", "walk", "aw", "each", "ost", "hd", "att", "bound", "esta", "acl", "ess", "as", "asting", "pat", "embed", "nt", "act", "sta", "nd", "est", "ed", "Ast", "irst", "asm", "std", "ref", "amd", "store", "a", "instance", "aid", "asted", "addr", "art", "ad", "bart", "quest", "mt"], "sub_demuxer": ["sub_demixers", "sub_demue", "sub_promuxe", "sub_demuxers", "sub_demluxers", "sub_demuxe", "sub_demuploade", "sub_demuier", "sub_promuxier", "sub_demuxier", "sub_deluxer", "sub_promxe", "sub_Demuxier", "sub_democer", "sub_Democe", "sub_demUXer", "sub_demluxed", "sub_deuxor", "sub_demxe", "sub_Democers", "sub_deluxers", "sub_deluxor", "sub_demixe", "sub_demuploadier", "sub_demuxed", "sub_democe", "sub_demluxor", "sub_Demuxers", "sub_demuploader", "sub_demixor", "sub_deuxed", "sub_Democer", "sub_promxer", "sub_promuxers", "sub_demixed", "sub_demuers", "sub_promxers", "sub_Democier", "sub_demixier", "sub_demUXers", "sub_demxers", "sub_deuxers", "sub_demxier", "sub_demuxor", "sub_Demuxer", "sub_demUXor", "sub_democers", "sub_demixer", "sub_demuer", "sub_promuxer", "sub_demUXed", "sub_democier", "sub_demuploaders", "sub_demxer", "sub_promxier", "sub_Demuxe", "sub_deluxed", "sub_deuxer", "sub_demluxer"], "time_base": ["time_only", "duration_ase", "duration_base", "time_bal", "timexBase", "time_ase", " time_bas", "timetimebase", "Time_bas", "time2bas", " time_bal", " time2Base", "timexbal", "Time_Base", "timexbase", "time_based", "time2Base", "Time_base", " time_Base", "time_Base", "durationtimebase", "durationtimease", "time_bas", "Time_only", " time2bas", "time2base", " time2base", "durationtimebased", "timetimebased", "duration_based", "timetimease"], "pb": ["ctx", "cp", "pkg", "gc", "uf", "tp", "bb", "p", "np", "pp", "sp", "bs", "eb", "nb", "td", "ub", "erb", "bc", "jp", "pm", "tmp", "sb", "tc", "tg", "gb", "bp", "py", "ab", "pl", "mp", "BP", "ob", "stab", "wp", "proc", "tab", "vp", "tx", "tk", "ib", "tap", "PB", "pt", "kb", "bj", "rb", "buffer", "pc", "patch", "pa", "dp", "lb", "ap", "buf", "mb", "emb", "lp", "tf", "fb", "fp", "cb", "px", "pool", "pg", "cv"], "pd": ["cp", "tp", "xd", "edd", "p", "np", " md", " std", "td", "vd", " prod", "pr", "pm", "d", "sb", " sd", "ps", " ad", "pard", "fd", "dt", "dj", "ds", "dict", "hd", "dh", " dc", "vp", "pat", "po", " td", "dl", "cd", "pc", " cd", " dd", "dd", "dp", "ud", "std", " db", " np", "md", " pdf", " PD", "PD", "pi", "dq", " dw", " ep", "bd", " df", "sd", "ctl", " od", "df"]}}
{"project": "FFmpeg", "commit_id": "add41decd94b2d3581a3715ba10f27168b8cdb1b", "target": 0, "func": "int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)\n\n{\n\n    int ret;\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    if (o_out)\n\n        *o_out = o;\n\n    if (!o)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n    if (!val || o->offset<=0)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (o->type == FF_OPT_TYPE_BINARY) {\n\n        uint8_t **dst = (uint8_t **)(((uint8_t*)obj) + o->offset);\n\n        int *lendst = (int *)(dst + 1);\n\n        uint8_t *bin, *ptr;\n\n        int len = strlen(val);\n\n        av_freep(dst);\n\n        *lendst = 0;\n\n        if (len & 1) return AVERROR(EINVAL);\n\n        len /= 2;\n\n        ptr = bin = av_malloc(len);\n\n        while (*val) {\n\n            int a = hexchar2int(*val++);\n\n            int b = hexchar2int(*val++);\n\n            if (a < 0 || b < 0) {\n\n                av_free(bin);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            *ptr++ = (a << 4) | b;\n\n        }\n\n        *dst = bin;\n\n        *lendst = len;\n\n        return 0;\n\n    }\n\n    if (o->type != FF_OPT_TYPE_STRING) {\n\n        int notfirst=0;\n\n        for (;;) {\n\n            int i;\n\n            char buf[256];\n\n            int cmd=0;\n\n            double d;\n\n\n\n            if (*val == '+' || *val == '-')\n\n                cmd= *(val++);\n\n\n\n            for (i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+' && val[i]!='-'; i++)\n\n                buf[i]= val[i];\n\n            buf[i]=0;\n\n\n\n            {\n\n                const AVOption *o_named = av_opt_find(obj, buf, o->unit, 0, 0);\n\n                if (o_named && o_named->type == FF_OPT_TYPE_CONST)\n\n                    d= o_named->default_val.dbl;\n\n                else if (!strcmp(buf, \"default\")) d= o->default_val.dbl;\n\n                else if (!strcmp(buf, \"max\"    )) d= o->max;\n\n                else if (!strcmp(buf, \"min\"    )) d= o->min;\n\n                else if (!strcmp(buf, \"none\"   )) d= 0;\n\n                else if (!strcmp(buf, \"all\"    )) d= ~0;\n\n                else {\n\n                    int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n\n                    if (res < 0) {\n\n                        av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\"\\n\", val);\n\n                        return res;\n\n                    }\n\n                }\n\n            }\n\n            if (o->type == FF_OPT_TYPE_FLAGS) {\n\n                if      (cmd=='+') d= av_get_int(obj, name, NULL) | (int64_t)d;\n\n                else if (cmd=='-') d= av_get_int(obj, name, NULL) &~(int64_t)d;\n\n            } else {\n\n                if      (cmd=='+') d= notfirst*av_get_double(obj, name, NULL) + d;\n\n                else if (cmd=='-') d= notfirst*av_get_double(obj, name, NULL) - d;\n\n            }\n\n\n\n            if ((ret = av_set_number2(obj, name, d, 1, 1, o_out)) < 0)\n\n                return ret;\n\n            val+= i;\n\n            if (!*val)\n\n                return 0;\n\n            notfirst=1;\n\n        }\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (alloc) {\n\n        av_free(*(void**)(((uint8_t*)obj) + o->offset));\n\n        val= av_strdup(val);\n\n    }\n\n\n\n    memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));\n\n    return 0;\n\n}\n", "idx": 21166, "substitutes": {"obj": ["ctx", "js", "this", "rect", "inst", "np", "ist", "objects", "ot", "tmp", "n", "typ", "src", "self", "expr", "ob", "attr", "vol", "rt", "buff", "j", "nt", "onet", "act", "pos", "t", "bh", "bj", "ns", "txt", "ref", "et", "cur", "window", "out", "off", "obs", "ind", "xy", "sys", "str", "os", "oid", "addr", "hw", "object", "Obj", "bo"], "name": ["spec", "num", "data", "alias", "id", "type", "word", "path", "w", "nm", "n", "san", "named", "ame", "prefix", "attr", "info", "c", "no", "cmd", "nam", "key", "ref", "names", "var", "NAME", "mem", "local", "str", "Name", "label", "term", "v"], "val": ["vc", "grad", "gl", "sel", "ver", "prop", "test", "attr", "lib", "pt", "vec", "arg", "arr", "x", "cal", "call", "ctx", "vt", "data", "ival", "tag", "it", "b", "vol", "ser", "doc", "buff", "serv", "pos", "Val", "pol", "len", "v", "dev", "aval", "loc", "eval", "cond", "bl", "msg", "txt", "var", "al", "el", "str", "exec", "elt", "valid", "rel", "stat", "p", "pr", "def", "value", "VAL", "tx", "vp", "cmd", "reg", "cho", "buffer", "key", "ref", "rol", "all", "mem", "rec", "index", "vals"], "alloc": ["ac", "oc", "req", "loc", "ack", "offset", "init", "attr", "vol", "ok", "buff", "empty", "pos", "ref", "var", "count", "coord", "all", "mem", "addr", "call", "pool", "rc"], "o_out": ["oo_found", "o_OUT", "o_found", "o__in", "o__no", "oo_check", "o_no", "oPfound", "o__out", "oixfound", " o_no", "oixout", " o_opt", "o_msg", "o__opt", "o_check", "oPcheck", "o_opt", "o_in", " o_msg", "oixcheck", " o_in", " o_OUT", "oPout", "oo_out"], "ret": ["data", "alt", "Return", "Ret", "def", "rem", "lit", "nt", "flag", "res", "set", " RET", "cat", "ref", "re", "il", "resp", "count", "out", "len", "ll", "mem", "elt", "RET"], "o": ["fo", "m", "so", "om", "oin", "p", "oc", "lo", "iso", "O", "one", "or", "image", "ot", "w", "yo", "ion", "n", "y", "oe", "original", "l", "co", "ob", "er", "s", "c", "oo", "an", "ow", "ok", "no", "po", "onet", "go", "owner", "t", "u", "g", "et", "other", "oa", "out", "off", "a", "e", "none", "oi", "h", "op", "os", "oid", "object", "io", "f", "v", "bo"], "dst": ["sdst", "sdend", "drest", " dST", " dint", " dset", "disists", "nint", " dth", "dpr", "lst", "disst", "dint", "dedfr", "nrest", "nST", "ldst", "dedST", "dust", "lST", "Dists", "dfr", "lrest", "sdST", "dbst", "dedst", "idth", "sdfr", "dth", "ldset", "lint", "Dsp", "ldth", "dbists", "idpr", "Dust", "dbsp", "dedend", "Dst", " dfr", "dbust", "dST", " dpr", "nst", "dsp", "disust", "dissp", "dset", "idst", "ldpr", "dists", " drest", "idset", " dend", "dend"], "lendst": ["lenderst", "lendSt", "llENDst", "lendsest", "glendsw", "lENDno", "llendno", "llENDno", "glenderest", "glendersw", "lenderST", "laddst", "glenderst", "lendno", "glenderno", "lrendsw", "glendno", "llENDbl", "lendest", " lendsw", "lrendSt", "lenderno", "laddno", "lrendst", "lENDst", "glendst", "lendssw", "lenderest", "lentno", "laddST", "lendersw", "lendsw", "llENDST", " lendedst", "lentest", "glendest", "lENDST", "lendedsw", "lenderbl", "lendbl", "lentst", "llendST", " lendSt", "lendedSt", " lendedsw", "lentsw", "laddbl", "llendst", "lendedst", "lendsst", " lendedSt", "llendbl", "lendST", "lENDbl", "lendsno"], "bin": ["bed", "inner", "big", "bc", "box", "obin", "tmp", "cache", "src", "n", "fr", "init", "bit", "win", "b", "pin", "lib", "buff", "cmd", "in", "pos", "sum", "reg", "db", "bl", "pipe", "buffer", "bg", "bn", "vec", "bu", "slice", "hash", "len", "pac", "bi", "base", "mem", "byte", "str", "bool", "binary", "batch", "bat", "back", "gin"], "ptr": ["pointers", "ctx", "inst", "ix", "end", "p", "sp", "pr", "pad", "tr", "loc", "port", "br", "src", "offset", "dest", "address", "buff", "pat", "cmd", "dr", "pointer", "pt", "pos", "db", "bl", "buffer", "pc", "ref", "vec", "var", "next", "len", "ind", "Ptr", "ctr", "mem", "arr", "index", "pi", "addr"], "i": ["hi", "m", "me", "ci", "ix", "p", "id", "si", "zi", "multi", "n", "ei", "y", "it", "xi", "l", "init", "ti", "mi", "qi", "b", "iu", "c", "s", "mac", "PI", "j", "iter", "di", "\u0438", "ai", "t", "im", "u", "g", "gi", "phi", "ic", "li", "ui", "key", "ip", "sim", "cli", "ji", "a", "ini", "bi", "oi", "index", "ii", "x", "h", "pi", "I", "ami", "io", "f", "is", "v"], "buf": ["ctx", "pkg", "uf", "data", "bs", "seq", "bc", "box", "loc", "length", "filename", "tmp", "def", " buffer", "wb", "br", "Buffer", "bytes", "ab", "proc", "buff", "kw", "iter", "cmd", " cmd", " buff", "img", "pos", "db", "bl", "rb", "buffer", "txt", "ref", "vec", "var", "Buff", "window", "md", "names", "off", "ctr", "mem", "arr", "str", "queue", "err", "cap", "block", " vec", "cb", "cv"], "d": ["dev", "done", "del", "p", "w", "def", "n", "fd", "it", "ds", "dh", "c", "wd", " D", "j", "g", "cd", "de", "md", "e", "ind", "x", "D", " dw", "new", "ad", "f", "v"], "o_named": [" o_identified", "onet_specified", "onet_name", "o_nm", "oktname", "o_specified", "o_amed", "O_amed", "O_nm", "O_named", "o_sn", "o_identified", " o_amed", "oktspecified", "O_name", "o_name", "onet_named", "onet_sn", " o_name", "oktnamed", "oktsn"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,\n\n                                    int alpha, int beta, int8_t *tc)\n\n{\n\n    uint8_t bs0 = 1;\n\n    uint8_t bs1 = 1;\n\n    uint8_t bs2 = 1;\n\n    uint8_t bs3 = 1;\n\n\n\n    if (tc[0] < 0)\n\n        bs0 = 0;\n\n    if (tc[1] < 0)\n\n        bs1 = 0;\n\n    if (tc[2] < 0)\n\n        bs2 = 0;\n\n    if (tc[3] < 0)\n\n        bs3 = 0;\n\n\n\n    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,\n\n                                               bs0, bs1, bs2, bs3,\n\n                                               tc[0], tc[1], tc[2], tc[3],\n\n                                               alpha, beta,\n\n                                               img_width);\n\n}\n", "idx": 21168, "substitutes": {"data": ["dev", "m", "dat", "p", "input", "table", "image", "d", "rew", "def", "block", "cache", "bytes", "c", "r", "raw", "img", "in", "video", "map", "buffer", "f", "device", "window", "buf", "out", "a", "DATA", "rec", "ata", "batch", "rc", "ad", "bus", "Data", "v"], "img_width": ["img2length", " img_w", "img_height", " img_length", "img_rate", "img_length", "img_w", "img2height", "img2rate", " img_rate", "img2width", "imglenrate", "imglenheight", " img_height", "imglenwidth", "imglenlength"], "alpha": ["ac", "ity", "ta", "hi", "height", "ra", "inc", "ca", "alias", "asa", "power", "anti", "important", "aria", "ica", "attr", "asc", "xa", "la", "da", "extra", "ar", "error", "area", "ma", "pro", "pha", "al", "sha", "a", "alph", "ppa", "title", "Alpha", "ia", "final"], "beta": ["meta", "ta", "dev", "eta", "secondary", "ba", "mu", "blue", "bis", "elta", "oe", "fa", "dust", "lr", "term", "lib", "mega", "po", "Beta", "video", "normal", "extra", "phi", "vert", "pb", "igma", "late", "bi", "bot", "lambda", "xy", "ii", "fine", "binary", "aylor", "fb", "Delta", "fee", "\u03b2", "latest", "ne", "fty"], "tc": ["ctx", "temp", "ta", "ty", "tv", "cases", "spec", "tp", "ci", "bs", "td", "bc", "tt", "ctrl", "tic", "TC", "tg", "tw", "icc", "cache", "abi", "mc", "cc", "nc", "tm", "cm", "types", "etc", "com", "tl", "c", "cs", "asc", "wp", "lc", "tk", "ts", "aco", "config", "cus", "toc", "ec", "uc", "t", "tu", " TC", "ic", "pc", "tn", "dc", "unc", "pb", "webkit", "desc", "cur", "cv", "tim", "cu", "tf", "fee", "cmp", " TTC", "ctl", "rc", "ct"]}}
{"project": "qemu", "commit_id": "f37343197708d90f119007ce5ecc2503be9c04c1", "target": 0, "func": "void slirp_select_poll(fd_set *readfds, fd_set *writefds, fd_set *xfds,\n\n                       int select_error)\n\n{\n\n    Slirp *slirp;\n\n    struct socket *so, *so_next;\n\n    int ret;\n\n\n\n    if (QTAILQ_EMPTY(&slirp_instances)) {\n\n        return;\n\n    }\n\n\n\n    global_readfds = readfds;\n\n    global_writefds = writefds;\n\n    global_xfds = xfds;\n\n\n\n    curtime = qemu_get_clock_ms(rt_clock);\n\n\n\n    QTAILQ_FOREACH(slirp, &slirp_instances, entry) {\n\n\t/*\n\n\t * See if anything has timed out\n\n\t */\n\n\t\tif (time_fasttimo && ((curtime - time_fasttimo) >= 2)) {\n\n\t\t\ttcp_fasttimo(slirp);\n\n\t\t\ttime_fasttimo = 0;\n\n\t\t}\n\n\t\tif (do_slowtimo && ((curtime - last_slowtimo) >= 499)) {\n\n\t\t\tip_slowtimo(slirp);\n\n\t\t\ttcp_slowtimo(slirp);\n\n\t\t\tlast_slowtimo = curtime;\n\n\t\t}\n\n\n\n\t/*\n\n\t * Check sockets\n\n\t */\n\n\tif (!select_error) {\n\n\t\t/*\n\n\t\t * Check TCP sockets\n\n\t\t */\n\n\t\tfor (so = slirp->tcb.so_next; so != &slirp->tcb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\t/*\n\n\t\t\t * FD_ISSET is meaningless on these sockets\n\n\t\t\t * (and they can crash the program)\n\n\t\t\t */\n\n\t\t\tif (so->so_state & SS_NOFDREF || so->s == -1)\n\n\t\t\t   continue;\n\n\n\n\t\t\t/*\n\n\t\t\t * Check for URG data\n\n\t\t\t * This will soread as well, so no need to\n\n\t\t\t * test for readfds below if this succeeds\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, xfds))\n\n\t\t\t   sorecvoob(so);\n\n\t\t\t/*\n\n\t\t\t * Check sockets for reading\n\n\t\t\t */\n\n\t\t\telse if (FD_ISSET(so->s, readfds)) {\n\n\t\t\t\t/*\n\n\t\t\t\t * Check for incoming connections\n\n\t\t\t\t */\n\n\t\t\t\tif (so->so_state & SS_FACCEPTCONN) {\n\n\t\t\t\t\ttcp_connect(so);\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} /* else */\n\n\t\t\t\tret = soread(so);\n\n\n\n\t\t\t\t/* Output it if we read something */\n\n\t\t\t\tif (ret > 0)\n\n\t\t\t\t   tcp_output(sototcpcb(so));\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Check sockets for writing\n\n\t\t\t */\n\n\t\t\tif (FD_ISSET(so->s, writefds)) {\n\n\t\t\t  /*\n\n\t\t\t   * Check for non-blocking, still-connecting sockets\n\n\t\t\t   */\n\n\t\t\t  if (so->so_state & SS_ISFCONNECTING) {\n\n\t\t\t    /* Connected */\n\n\t\t\t    so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t    ret = send(so->s, (const void *) &ret, 0, 0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXXXX Must fix, zero bytes is a NOP */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    }\n\n\t\t\t    /* else so->so_state &= ~SS_ISFCONNECTING; */\n\n\n\n\t\t\t    /*\n\n\t\t\t     * Continue tcp_input\n\n\t\t\t     */\n\n\t\t\t    tcp_input((struct mbuf *)NULL, sizeof(struct ip), so);\n\n\t\t\t    /* continue; */\n\n\t\t\t  } else\n\n\t\t\t    ret = sowrite(so);\n\n\t\t\t  /*\n\n\t\t\t   * XXXXX If we wrote something (a lot), there\n\n\t\t\t   * could be a need for a window update.\n\n\t\t\t   * In the worst case, the remote will send\n\n\t\t\t   * a window probe to get things going again\n\n\t\t\t   */\n\n\t\t\t}\n\n\n\n\t\t\t/*\n\n\t\t\t * Probe a still-connecting, non-blocking socket\n\n\t\t\t * to check if it's still alive\n\n\t \t \t */\n\n#ifdef PROBE_CONN\n\n\t\t\tif (so->so_state & SS_ISFCONNECTING) {\n\n                          ret = qemu_recv(so->s, &ret, 0,0);\n\n\n\n\t\t\t  if (ret < 0) {\n\n\t\t\t    /* XXX */\n\n\t\t\t    if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\terrno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t      continue; /* Still connecting, continue */\n\n\n\n\t\t\t    /* else failed */\n\n\t\t\t    so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t    so->so_state |= SS_NOFDREF;\n\n\n\n\t\t\t    /* tcp_input will take care of it */\n\n\t\t\t  } else {\n\n\t\t\t    ret = send(so->s, &ret, 0,0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXX */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    } else\n\n\t\t\t      so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t  }\n\n\t\t\t  tcp_input((struct mbuf *)NULL, sizeof(struct ip),so);\n\n\t\t\t} /* SS_ISFCONNECTING */\n\n#endif\n\n\t\t}\n\n\n\n\t\t/*\n\n\t\t * Now UDP sockets.\n\n\t\t * Incoming packets are sent straight away, they're not buffered.\n\n\t\t * Incoming UDP data isn't buffered either.\n\n\t\t */\n\n\t\tfor (so = slirp->udb.so_next; so != &slirp->udb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\tif (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                            sorecvfrom(so);\n\n                        }\n\n\t\t}\n\n\n\n                /*\n\n                 * Check incoming ICMP relies.\n\n                 */\n\n                for (so = slirp->icmp.so_next; so != &slirp->icmp;\n\n                     so = so_next) {\n\n                     so_next = so->so_next;\n\n\n\n                    if (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                        icmp_receive(so);\n\n                    }\n\n                }\n\n\t}\n\n\n\n\t/*\n\n\t * See if we can start outputting\n\n\t */\n\n\tif (slirp->if_queued) {\n\n\t    if_start(slirp);\n\n\t}\n\n    }\n\n\n\n\t/* clear global file descriptor sets.\n\n\t * these reside on the stack in vl.c\n\n\t * so they're unusable if we're not in\n\n\t * slirp_select_fill or slirp_select_poll.\n\n\t */\n\n\t global_readfds = NULL;\n\n\t global_writefds = NULL;\n\n\t global_xfds = NULL;\n\n}\n", "idx": 21202, "substitutes": {"readfds": ["readlds", "readerfuds", " readfns", "readablefbrs", "readlns", " readljs", "readfsuds", "readablefrs", "readfjs", "readfdjs", " readlds", "readerfns", "readfrs", " readfcs", "readerfsds", "readdds", "readerfrs", " readlcs", "readfuds", "readxjs", "readfms", "readablefxs", "readrfrs", "readfdcs", "readlcs", " readfjs", "readerfds", "readfbxs", "readfsds", "readablefms", "readablefbms", "readablefbds", "readfcs", "readablefbxs", "readxcs", "readfdds", "readrfds", "readerfsns", "readfsns", "readfbds", "readljs", "readdrs", "readfbms", "readfbrs", "readxds", "readdns", "readrfxs", "readerfsuds", "readfsrs", "readrfms", "readfns", "readfdns", "readxns", " readlns", "readerfsrs", "readablefds", "readfxs", "readduds"], "writefds": ["updatefsts", "writeinfts", "writeinfds", "writecdds", "writefcds", "writects", "writefts", "writefsuds", "writefsd", "writecds", "writecdt", "writerfds", "writefdt", "readfsuds", "readfdays", "writerfcs", "writeinfdds", "writefords", "writerfunords", "writeofds", "writeofdays", "writefdays", "writerfords", "writerfms", "writerfunds", "writeofd", "writefsts", "writefms", "writefccs", "readfuds", "writefpds", "writefpdays", "writefsdds", "writefunords", "writeFds", "writeFcs", "readfsds", "updatefdt", "updatefds", "writefunms", "writerfuncs", "updatefsdt", "writefcms", "writefsds", "writeinfdt", "writefunds", "readfsdays", "writefpd", "writefsdays", "writeofuds", "writefcords", "writefpuds", "writerfunms", "updatefts", "writefd", "updatefdds", "writefdds", "writefsdt", "writefuncs", "updatefsds", "updatefsdds", "writeFms", "readfsd", "writefuds", "writefcs", "writeFords", "readfd"], "xfds": ["fxns", "xfuds", "fxonents", "fxcs", "fwcs", "fbonents", "fxands", "fxrs", "fbuds", "cfands", "xfonents", "fxdos", "fxeds", "fwds", "xfeds", "cfcs", "cfeds", "fwands", "feers", "fxds", "fifrs", "xfands", "fifdos", "cfds", "fifds", "fwonents", "fbns", "xfrs", "xfdos", "fwuds", "fwns", "fbds", "feens", "fweds", "xfcs", "xfns", "feedos", "fifns", "fxuds", "feeds"], "select_error": ["select_Error", "Select_Error", "select2error", "Select_error", "select__ok", "select__error", "select2err", "select_warning", "select2Error", "select__Error", " select_err", " select_ror", "select_err", "Select_warning", "select_ror", "select2ror", "Select_ok", "select_ok", "select__warning", " select_Error"], "slirp": ["dlirpers", "sliterp", "slrirpp", "sliterpc", "slrirpre", "slIrping", "slirtping", "slirkpp", "slircpp", "twrirpp", "glirr", "twirper", "islpirpad", "lirping", "slpirpe", "sslibrr", "glirpr", "sliorpre", "dliterpc", "glirp", "slpirphp", "scheirpp", "slrirpers", "slircp", "twirpp", "glpirr", "sliterpers", "slirkp", "slrirr", "slibrpy", "slirtpr", "sslirp", "glirpe", "slyrpad", "slirpre", "slrirper", "islirP", "sliorr", "slyrP", "glpirpe", "slIrpp", "sliterpa", "slrirpa", "slirpe", "slyrpr", "slrirpy", "librpr", "sslirpre", "glpirpr", "slirer", "slyrping", "slirper", "sliorpy", "slpirpad", "lirpr", "slircping", "slrirP", "slibrpre", "sligp", "islpirphp", "slairpr", "sloidping", "islirphp", "twirp", "slrirpc", "sloidp", "slpirpr", "sslibrp", "slirpers", "slpirp", "islirpad", "librping", "sloidpp", "slarp", "slairp", "slirping", "slirtp", "islirp", "slyrphp", "sslibrpy", "scheoidpp", "slibrping", "lirp", "slrirp", "slirpa", "dlirpc", "slIrphp", "dliterp", "dlirpa", "twrirper", "slpirP", "sligpers", "islpirP", "slibrp", "librp", "sslirpy", "slarper", "slrirsp", "slirpad", "slrirphp", "sligpa", "slirr", "slirpp", "twirsp", "sslibrpre", "slairr", "slibrpr", "slirep", "scheoidping", "twrirp", "sliorp", "slirpc", "slpirr", "slyrp", "slairpe", "slirphp", "dlirp", "islpirp", "slircphp", "slirepr", "slrirpad", "scheirphp", "slirksp", "dliterpa", "slirsp", "sligpc", "slibrr", "slIrp", "slirepe", "twrirsp", "scheirp", "dliterpers", "slirkper", "glpirp", "sloidphp", "slirP", "scheirping", "slirpy", "slirpr", "scheoidp", "sslirr", "slarpp", "slarsp", "scheoidphp"], "so": ["stone", "sp", "lo", "oto", "ve", "bs", "sel", "sa", "mi", "cs", "ski", "ow", "dll", "oss", "pro", "goo", "client", "store", "ro", "ao", "sam", "ico", "ii", "os", "SO", "st", "io", "sie", "mo", "o", "iso", "yes", "dylib", "syn", "co", "oo", "osp", "sum", "\u00f8", "sing", "usr", "se", "since", "fo", "hi", "ssl", "sl", "sn", "inho", "So", "ko", "soc", "si", "ka", "sm", "po", "ss", "esh", "obj", "sys", "ste", "th", "bo", "stro", "su", "ho", "sh", "s", "sync", "sw", "no", "j", "go", "opa", "sim", "isco", "sk", "she", "ne"], "so_next": ["go__state", "go_err", "go__new", "lo_next", "so_state", "so_new", "go_next", "se_next", "so__new", "so_self", "so_adj", "go__err", "so__err", "so_name", "so_err", "se_link", "go_new", "go_state", "so_parent", " so_link", "so_start", "lo_adj", "lo_name", "so_prev", "SO_next", "SO__next", "SO__new", " so_future", "se_prev", "lo_parent", "so_future", " so_start", "so_link", "SO_state", "se_self", "SO_new", "so__state", "SO__state", "so__next", "go__next"], "ret": ["reset", "try", "success", "cert", "alt", "rs", "ter", "tr", "Ret", "def", "magic", "reply", "ext", "dt", "rem", "result", "fun", " Ret", "rt", "ry", "r", "ts", "iter", "j", "nt", "deg", "flag", "cmd", "t", "ft", "args", "res", "reg", "rf", "tn", "lt", "txt", "et", "re", "resp", "desc", "hash", "out", "len", "ll", "arg", "rets", "mem", "gt", "usr", "nz", "rm", "elt", "err", "RET", "back", "mt", "cont", "val"]}}
{"project": "qemu", "commit_id": "970d622e8ab1de8fdf5762e23e92a2dea9d7d36c", "target": 0, "func": "uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 7; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb)\n\n            res |= 1 << i;\n\n    }\n\n    return res;\n\n}\n", "idx": 21218, "substitutes": {"op1": ["op0", "oop11", "post0", "bit3", "post1", "oop1", "bit0", " op8", "post3", "OP11", "OP0", " op3", "bit4", "post4", "op3", "op4", "OP8", "op8", " op11", " op0", "bit1", "oop0", "OP1", "op11", "oop8", " op4"], "op2": ["opTwo", "op102", "ap2", "hop2", "aptwo", "apTwo", "exp3", "expb", "ipb", "ip02", "ap102", " op102", " op3", "optwo", "op02", "hopTwo", "op3", " optwo", "hop102", " op02", "hoptwo", "ip3", "ip2", "exp2", "exp02", " opTwo"], "opa": ["ola", "fo", " po", "arp", "rio", "asa", "ppo", "apt", "apa", "ahi", "apo", "pps", "tar", "appy", "pox", " xp", "ti", " proto", "ski", "aco", "oga", "obo", " fo", "jo", "po", "ona", "opus", "ma", "pa", " pap", "osa", "ip", "hop", " zo", "php", "oa", "ap", "anza", "oop", " php", " pol", "ppa", "op", " ro", "za", " ip", "pai", "vo", "ipp", " hop", "elo", "zo"], "opb": ["operbar", "optl", "opernb", "ropbd", "optba", "ap2", "ropbase", "operb", "opba", "apbd", "opbar", "iopbi", " opl", "rop2", "opbase", "hop2", "hopbase", "apbase", "optb", "iopb", "optbi", " opba", " opbi", "ropb", "opl", "opbi", "iopba", "iopl", " opbar", "hopb", " opnb", "opbd", "opera", "opnb", "hopbar", "apb", "hopa", "hopnb", "hopbd"], "res": ["reset", "rest", "ows", "p", "rs", "pr", "yes", "req", "conf", " Res", "resources", "def", "des", "ps", "resolution", "red", "rem", "init", "has", "rss", "result", "ret", "expr", "RES", "vol", "ms", "gr", "r", "final", "respons", "results", "reg", "vec", "re", "resp", "cons", "hash", "out", "Res", "off", "zero", "resh", "ress", "mem", "arr", "resource", "new", "pres", "err", "vals", "rel", "pas", "block", "pers", "val"], "i": ["hi", "me", "m", " ti", "ci", "ix", "p", "my", " iter", "o", "id", " li", "ex", "name", "si", "zi", " bi", "multi", "by", " si", " mi", "ei", "y", "it", "xi", "ims", "ij", "status", "ti", "mi", "qi", "info", "iu", "j", "di", "in", "point", "\u0438", "ni", "ai", "print", " ii", "fi", "ui", "phi", "ic", "li", " multi", "gi", "ma", "ip", "sim", "iq", "ri", "is", "ji", "ini", "bi", "ind", " Xi", "oi", "index", "ii", "x", "pi", "I", " ni", "ki", "im", " pi"]}}
{"project": "qemu", "commit_id": "7b527b86eb3560d68f41218cec0cdf3d60a38323", "target": 0, "func": "static int s390_ipl_init(SysBusDevice *dev)\n\n{\n\n    S390IPLState *ipl = S390_IPL(dev);\n\n    uint64_t pentry = KERN_IMAGE_START;\n\n    int kernel_size;\n\n\n\n    int bios_size;\n\n    char *bios_filename;\n\n\n\n    /*\n\n     * Always load the bios if it was enforced,\n\n     * even if an external kernel has been defined.\n\n     */\n\n    if (!ipl->kernel || ipl->enforce_bios) {\n\n        uint64_t fwbase = (MIN(ram_size, 0x80000000U) - 0x200000) & ~0xffffUL;\n\n\n\n        if (bios_name == NULL) {\n\n            bios_name = ipl->firmware;\n\n        }\n\n\n\n        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (bios_filename == NULL) {\n\n            hw_error(\"could not find stage1 bootloader\\n\");\n\n        }\n\n\n\n        bios_size = load_elf(bios_filename, bios_translate_addr, &fwbase,\n\n                             &ipl->bios_start_addr, NULL, NULL, 1,\n\n                             ELF_MACHINE, 0);\n\n        if (bios_size > 0) {\n\n            /* Adjust ELF start address to final location */\n\n            ipl->bios_start_addr += fwbase;\n\n        } else {\n\n            /* Try to load non-ELF file (e.g. s390-zipl.rom) */\n\n            bios_size = load_image_targphys(bios_filename, ZIPL_IMAGE_START,\n\n                                            4096);\n\n            ipl->bios_start_addr = ZIPL_IMAGE_START;\n\n            if (bios_size > 4096) {\n\n                hw_error(\"stage1 bootloader is > 4k\\n\");\n\n            }\n\n        }\n\n        g_free(bios_filename);\n\n\n\n        if (bios_size == -1) {\n\n            hw_error(\"could not load bootloader '%s'\\n\", bios_name);\n\n        }\n\n\n\n        /* default boot target is the bios */\n\n        ipl->start_addr = ipl->bios_start_addr;\n\n    }\n\n\n\n    if (ipl->kernel) {\n\n        kernel_size = load_elf(ipl->kernel, NULL, NULL, &pentry, NULL,\n\n                               NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"could not load kernel '%s'\\n\", ipl->kernel);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the\n\n         * kernel parameters here as well. Note: For old kernels (up to 3.2)\n\n         * we can not rely on the ELF entry point - it was 0x800 (the SALIPL\n\n         * loader) and it won't work. For this case we force it to 0x10000, too.\n\n         */\n\n        if (pentry == KERN_IMAGE_START || pentry == 0x800) {\n\n            ipl->start_addr = KERN_IMAGE_START;\n\n            /* Overwrite parameters in the kernel image, which are \"rom\" */\n\n            strcpy(rom_ptr(KERN_PARM_AREA), ipl->cmdline);\n\n        } else {\n\n            ipl->start_addr = pentry;\n\n        }\n\n\n\n        if (ipl->initrd) {\n\n            ram_addr_t initrd_offset;\n\n            int initrd_size;\n\n\n\n            initrd_offset = INITRD_START;\n\n            while (kernel_size + 0x100000 > initrd_offset) {\n\n                initrd_offset += 0x100000;\n\n            }\n\n            initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n            if (initrd_size == -1) {\n\n                fprintf(stderr, \"qemu: could not load initrd '%s'\\n\",\n\n                        ipl->initrd);\n\n                exit(1);\n\n            }\n\n\n\n            /*\n\n             * we have to overwrite values in the kernel image,\n\n             * which are \"rom\"\n\n             */\n\n            stq_p(rom_ptr(INITRD_PARM_START), initrd_offset);\n\n            stq_p(rom_ptr(INITRD_PARM_SIZE), initrd_size);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 21219, "substitutes": {"dev": ["ctx", "spec", "serial", "p", "data", "ev", "conf", "Dev", "w", "d", "Device", "ptr", "ver", "def", "DEV", "iv", "proc", "wd", "serv", " device", "nt", "dm", "pro", "dem", "disk", "device", "de", "eth", "handle", "obj", "ch", "mem", "ach", "sys", "hw", "ad", "sd", "usb", "v"], "ipl": ["uph", "ips", "pel", "pp", "sel", "iov", "sil", "opp", "owl", "phi", "dl", "ip", "iq", "ind", "inyl", "iper", "inc", "impl", " pl", "fl", "ih", "ell", "ept", "yp", "iv", "each", "isl", "cl", "iph", "iu", "pol", "ipt", "iol", "ik", "prov", "ssl", "imp", "includes", "abl", "vl", "scl", "fol", "tl", "elf", "gif", "il", "ocl", "PL", "compl", "ief", "hl", "spl", "ith", "rl", "multipl", "mult", "liv", "upp", "coll", "expl", "ix", "inv", "cil", "supp", "nil", "pl", "obl", "inf", "vp", "abul", "repl", "impact", "opl", "rob", "empl", "iop", "ippers", "qq", "ipp"], "kernel_size": ["kernel_source", "kernelityweight", "wrapper00loss", "channelitysource", "kernel2count", "kernel67ize", "kernel_count", "kernel_capacity", "kernel64loss", "kernelitySize", "kernel0space", "kernel_strength", " kernel2strength", "kernel0capacity", "kernel2Size", "channel_Size", "wrapper00percent", "worker_length", "kernellogsize", "wrapper_ize", "kernel_write", "channelitySize", "kernel00loss", "kernel2size", "kernel_Size", "kernel2SIZE", "kernellogstrength", " kernel_SIZE", "kernel00percent", "kernel67write", "kernel64source", " kernel2size", "kernellogize", "channelityweight", " kernel_write", "kernellogcount", "kernelitysize", "worker_capacity", "wrapper00size", "kernel_space", "kernel64Size", "channel_weight", "wrapper00ize", "kernel64ize", "worker_space", "channel_source", "worker_size", " kernel2ize", "kernel2write", "channelitysize", "kernel_SIZE", " kernel2count", " kernel_count", "kernel67Size", "kernel2strength", "kernel00size", "kernelitysource", "kernel67percent", " kernel_strength", "kernel67size", "kernel_percent", "kernel64percent", "wrapper_loss", "kernel0size", "wrapper_size", "kernel64weight", "kernel67SIZE", "kernel_loss", "channel_size", "kernel_ize", "kernel2ize", "kernel0length", "kernel_weight", "kernel67loss", " kernel_ize", "wrapper_percent", "kernel00ize", "kernel64size", " kernel_Size", "kernel_length"], "bios_size": ["bios00info", "bios_speed", "bockets_time", "bios_time", "bii00size", "bios6filename", "bios_space", "bios4sized", "bio_size", "bios4SIZE", "bios_scale", "bios5space", "bios_ize", "biosistspeed", "bios_SIZE", "bios00speed", "bios8error", "bios6size", "bios7sized", "bios00size", "bios8size", "bockets_sized", "bio_SIZE", "bio_name", "bios_info", "bios_name", "bio_address", "bio_ize", "bios_address", "bio_sized", "bii00speed", "bios4error", "bockets_size", "bii_speed", "bios7size", "bios00filename", "bii_filename", "bios7error", "bio_error", "bios5error", "bios6speed", "bii_size", "bii_info", "bii00info", "bios5size", "bios8SIZE", "biosistfilename", "bio_scale", "bios_sized", "bios6info", "bios7SIZE", "biosistsize", "bios_error", "bii00filename", "bios5SIZE", "bio_space", "biosistinfo", "bios8space", "bockets_SIZE", "bios4size"], "bios_filename": ["bios2username", "bios___folder", "bios___filename", "bios_Filename", "bios2filename", "bios___txt", "bio_username", "bios__fil", "bounces___Filename", "bounces___status", "bio_file", "bios2file", "bio_fp", "bios___handle", "bios___Filename", "bios_handle", "bios__Filename", "bounces___filename", "bios_fp", "bounces___folder", "bios__username", "bio_name", "bio_wav", "bio_handle", "bios_name", "bios___fp", "bounces_folder", "bio_filename", "bios_fil", "bios___status", "bios__filename", "bounces_Filename", "bios_uri", "bios2name", "bounces_filename", "bios_wav", "bios_file", "bio_Filename", "bios_status", "bios_txt", "bio_fil", "bio_txt", "bounces_status", "bio_uri", "bios_username", "bios_folder"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static int virtcon_parse(const char *devname)\n\n{\n\n    QemuOptsList *device = qemu_find_opts(\"device\");\n\n    static int index = 0;\n\n    char label[32];\n\n    QemuOpts *bus_opts, *dev_opts;\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_VIRTIO_CONSOLES) {\n\n        fprintf(stderr, \"qemu: too many virtio consoles\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    bus_opts = qemu_opts_create(device, NULL, 0);\n\n    if (arch_type == QEMU_ARCH_S390X) {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-s390\");\n\n    } else {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-pci\");\n\n    } \n\n\n\n    dev_opts = qemu_opts_create(device, NULL, 0);\n\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\");\n\n\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n\n    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!virtcon_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\",\n\n                devname, strerror(errno));\n\n        return -1;\n\n    }\n\n    qemu_opt_set(dev_opts, \"chardev\", label);\n\n\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 21250, "substitutes": {"devname": ["DevName", "Devno", "deviceName", "Devlen", " devno", "evnames", "evName", "devName", "devicename", "volnames", "volname", "volnm", " devnm", "volName", "devno", "devlen", " devName", "devnm", "evlen", "evnm", "evname", " devnames", " devlen", "Devname", "evno", "deviceno", "devnames"], "device": ["dev", "product", "volume", "serial", "family", "ve", "engine", "image", "database", "port", "Device", "project", "module", "DEV", "bus", "gpu", "address", "slave", "di", "node", "server", "directory", "network", "remote", "document", "pipe", "buffer", "controller", "driver", "position", "drive", "disk", "link", "pod", "window", "handle", "interface", "context", "connection", "model", "peer", "devices", "draw"], "label": ["stroke", "list", " L", "description", "data", "alias", "hide", "control", "name", "L", "slot", "type", "id", "loc", "tag", "field", "block", "url", "module", "value", "abel", "layout", "l", "els", "role", "lab", "style", "prefix", "line", "nl", "kind", " Label", "node", "leaf", "shape", "size", "key", "LAB", "position", "link", "desc", "color", "route", "comment", "handle", "el", "group", "EL", "Label", "local", "str", "lay", "title", "call", "mask", "bus", " labels", "cell"], "bus_opts": ["bus_covs", "bus_opters", "bus_propt", "bus_pyents", "bus_pyts", "bus_hvs", "bus_opvs", "bus_optts", "bus_optters", "bus_attts", "bus_OPts", "bus_cops", "bus_optuts", "bus_otcs", "bus_hps", "bus_oputs", "bus_hpt", "bus_pyps", "bus_OPters", "bus_oppt", "bus_hts", "bus_pyuts", "bus_copt", "bus_ops", "bus_attents", "bus_cots", "bus_OPs", "bus_otps", "bus_OPps", "bus_OPcs", "bus_attps", "bus_optps", "bus_prots", "bus_opents", "bus_otters", "bus_attuts", "bus_opps", "bus_optcs", "bus_props", "bus_optents", "bus_opcs", "bus_otts", "bus_provs", "bus_ots"], "dev_opts": ["dev_prot", "dev_ott", "dev_orts", "dev_opTS", "dev2optrs", "dev2optters", "dev2ops", "dev_opds", "dev_catds", "dev_popters", "dev_procs", "dev_orcs", "dev_OPcs", "dev_ops", "dev_ords", "dev_opt", "dev_OPts", "dev_catTS", "dev_verts", "dev_verters", "dev_opters", "dev_catts", "dev_optrs", "dev_optters", "dev_otts", "dev_popts", "dev_catcs", "dev_vers", "dev_otcs", "dev_orTS", "dev_opcs", "dev_verrs", "dev_oprs", "dev2optts", "dev_optts", "dev_OPs", "dev_optcs", "dev2opts", "dev_pros", "dev_poprs", "dev2oprs", "dev2opters", "dev_prots", "dev_optTS", "dev_pops", "dev_optds", "dev_optt"], "index": ["height", "list", "IND", "num", "success", "connect", "add", "ix", "state", "id", "ex", "mount", "engine", "insert", "length", "ion", "value", "n", "offset", "status", "capacity", "select", "max", "available", "thread", "lock", "address", "no", "iter", "connected", "location", "i", "order", "axis", "timeout", "pos", "loop", "version", "size", "point", "active", "directory", "open", "position", "total", "count", "link", "process", "number", "Index", "level", "zero", "ind", "row", "instance", "context", "condition", "x", "created", "connection", "batch", "fee", "weight", " Index"]}}
{"project": "qemu", "commit_id": "6cff3e8594cd974a507d531da09455d1c7aeb30d", "target": 0, "func": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n') {\n\n            qstring_append_chr(mon->outbuf, '\\r');\n\n        }\n\n        qstring_append_chr(mon->outbuf, c);\n\n        if (c == '\\n') {\n\n            monitor_flush(mon);\n\n        }\n\n    }\n\n}\n", "idx": 21256, "substitutes": {"mon": ["min", "m", "mont", "mond", "mx", "mm", "dog", "my", "wat", "manager", "mat", "mn", "mons", "mut", "util", "ann", "mu", "dom", "master", "den", "conn", "MON", "demon", "san", "mp", "don", "man", "mi", " man", " monitor", "admin", "serv", "di", "meter", "monkey", "ai", "dm", "mit", "Mon", "met", "mint", "sim", "mun", "client", "mind", "sam", "mate", "monitor", "ston", "mir", "tem", "mt"], "str": ["cr", "Str", "list", "sp", "par", "seq", "name", "tr", "or", "br", "fr", "sc", "status", "s", "gr", "r", "cut", "enc", "dr", "print", "t", "STR", "ar", "res", "buf", "obj", "ch", "ctr", "arr", "stri", "exec", "new", "st", "is"], "c": ["ac", "cp", "gc", "m", "cr", "q", "ca", "vc", "p", "v", "z", "bc", "d", "tc", "cache", "sc", "cm", "mc", "cc", "cod", "C", " cr", "l", "co", "cl", "com", "cum", "b", "chain", "cs", "fc", "r", "lc", "cut", "\u00e7", "ec", "go", "i", "comm", "uc", "ce", "t", "k", "u", "cat", "unc", "dc", "cur", "con", "a", "e", "ch", "cu", "ach", "comp", "conv", "cf", "cy", "err", "cmp", "arc", "f", "cont", "rc", "ct"]}}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_movl_seg_T0(DisasContext *s, int seg_reg)\n\n{\n\n    if (s->pe && !s->vm86) {\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);\n\n        /* abort translation because the addseg value may change or\n\n           because ss32 may change. For R_SS, translation must always\n\n           stop as a special handling must be done to disable hardware\n\n           interrupts for the next instruction */\n\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_op_movl_seg_T0_vm(seg_reg);\n\n        if (seg_reg == R_SS)\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    }\n\n}\n", "idx": 21261, "substitutes": {"s": ["js", "gs", "m", "spec", "ssl", "sl", "ls", "sq", "p", "es", "rs", "bs", "state", "conf", "sb", "mys", "ties", "ps", "n", "service", "fs", "ysis", "ims", "ds", "has", "status", "ains", "b", "c", "cs", "settings", "as", "ts", "ses", "ss", "i", "stats", "t", "aws", "ar", "set", "g", "ns", "ies", "ins", "its", "changes", "hs", "a", "e", "ares", "services", "sts", "sv", "qs", "h", "se", "os", "S", "is", "comm"], "seg_reg": ["seg2val", "seg2loc", "segpyaddr", "segm2num", "sege2reg", "seg_val", "segment_res", "semapylabel", "sema_rem", "segm_num", "sege_register", "sep_reg", "seg2reg", "sema_addr", "segm_addr", "seg2rom", "segpylabel", "sep2addr", "segm_val", "sege_addr", "seg2res", "segpyreg", "sege_rom", "sep_res", "seg_label", "seg_addr", "seg2REG", "seg_rom", "semapyaddr", "segment_reg", "segment_REG", "sep_loc", "seg_REG", "seg2addr", "sege2rom", "seg_num", "sege2addr", "segm2val", "sege2register", "seg_loc", "sep_addr", "segm_reg", "sema_reg", "sep2num", "seg_rem", "semapyreg", "segpyrem", "segm2addr", "seg2num", "seg2register", "seg_register", "sep_num", "sema_label", "segm2reg", "sep2reg", "segment_addr", "sege_reg", "semapyrem", "seg_res"]}}
{"project": "qemu", "commit_id": "5d98bf8f38c17a348ab6e8af196088cd4953acd0", "target": 0, "func": "void gen_intermediate_code_a64(ARMCPU *cpu, TranslationBlock *tb)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUARMState *env = &cpu->env;\n\n    DisasContext dc1, *dc = &dc1;\n\n    target_ulong pc_start;\n\n    target_ulong next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n\n\n    dc->tb = tb;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n\n\n    dc->aarch64 = 1;\n\n    /* If we are coming from secure EL0 in a system with a 32-bit EL3, then\n\n     * there is no secure EL1, so we route exceptions to EL3.\n\n     */\n\n    dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&\n\n                               !arm_el_is_aa64(env, 3);\n\n    dc->thumb = 0;\n\n    dc->bswap_code = 0;\n\n    dc->condexec_mask = 0;\n\n    dc->condexec_cond = 0;\n\n    dc->mmu_idx = ARM_TBFLAG_MMUIDX(tb->flags);\n\n    dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (dc->current_el == 0);\n\n#endif\n\n    dc->fp_excp_el = ARM_TBFLAG_FPEXC_EL(tb->flags);\n\n    dc->vec_len = 0;\n\n    dc->vec_stride = 0;\n\n    dc->cp_regs = cpu->cp_regs;\n\n    dc->features = env->features;\n\n\n\n    /* Single step state. The code-generation logic here is:\n\n     *  SS_ACTIVE == 0:\n\n     *   generate code with no special handling for single-stepping (except\n\n     *   that anything that can make us go to SS_ACTIVE == 1 must end the TB;\n\n     *   this happens anyway because those changes are all system register or\n\n     *   PSTATE writes).\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 1: (active-not-pending)\n\n     *   emit code for one insn\n\n     *   emit code to clear PSTATE.SS\n\n     *   emit code to generate software step exception for completed step\n\n     *   end TB (as usual for having generated an exception)\n\n     *  SS_ACTIVE == 1, PSTATE.SS == 0: (active-pending)\n\n     *   emit code to generate a software step exception\n\n     *   end the TB\n\n     */\n\n    dc->ss_active = ARM_TBFLAG_SS_ACTIVE(tb->flags);\n\n    dc->pstate_ss = ARM_TBFLAG_PSTATE_SS(tb->flags);\n\n    dc->is_ldex = false;\n\n    dc->ss_same_el = (arm_debug_target_el(env) == dc->current_el);\n\n\n\n    init_tmp_a64_array(dc);\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n    if (max_insns > TCG_MAX_INSNS) {\n\n        max_insns = TCG_MAX_INSNS;\n\n    }\n\n\n\n    gen_tb_start(tb);\n\n\n\n    tcg_clear_temp_count();\n\n\n\n    do {\n\n        tcg_gen_insn_start(dc->pc, 0);\n\n        num_insns++;\n\n\n\n        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n\n            CPUBreakpoint *bp;\n\n            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n\n                if (bp->pc == dc->pc) {\n\n                    gen_exception_internal_insn(dc, 0, EXCP_DEBUG);\n\n                    /* Advance PC so that clearing the breakpoint will\n\n                       invalidate this TB.  */\n\n                    dc->pc += 2;\n\n                    goto done_generating;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n\n\n        if (dc->ss_active && !dc->pstate_ss) {\n\n            /* Singlestep state is Active-pending.\n\n             * If we're in this state at the start of a TB then either\n\n             *  a) we just took an exception to an EL which is being debugged\n\n             *     and this is the first insn in the exception handler\n\n             *  b) debug exceptions were masked and we just unmasked them\n\n             *     without changing EL (eg by clearing PSTATE.D)\n\n             * In either case we're going to take a swstep exception in the\n\n             * \"did not step an insn\" case, and so the syndrome ISV and EX\n\n             * bits should be zero.\n\n             */\n\n            assert(num_insns == 1);\n\n            gen_exception(EXCP_UDEF, syn_swstep(dc->ss_same_el, 0, 0),\n\n                          default_exception_el(dc));\n\n            dc->is_jmp = DISAS_EXC;\n\n            break;\n\n        }\n\n\n\n        disas_a64_insn(env, dc);\n\n\n\n        if (tcg_check_temp_count()) {\n\n            fprintf(stderr, \"TCG temporary leak before \"TARGET_FMT_lx\"\\n\",\n\n                    dc->pc);\n\n        }\n\n\n\n        /* Translation stops when a conditional branch is encountered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefetch aborts occur at the right place.\n\n         */\n\n    } while (!dc->is_jmp && !tcg_op_buf_full() &&\n\n             !cs->singlestep_enabled &&\n\n             !singlestep &&\n\n             !dc->ss_active &&\n\n             dc->pc < next_page_start &&\n\n             num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n\n\n    if (unlikely(cs->singlestep_enabled || dc->ss_active)\n\n        && dc->is_jmp != DISAS_EXC) {\n\n        /* Note that this means single stepping WFI doesn't halt the CPU.\n\n         * For conditional branch insns this is harmless unreachable code as\n\n         * gen_goto_tb() has already handled emitting the debug exception\n\n         * (and thus a tb-jump is not possible when singlestepping).\n\n         */\n\n        assert(dc->is_jmp != DISAS_TB_JUMP);\n\n        if (dc->is_jmp != DISAS_JUMP) {\n\n            gen_a64_set_pc_im(dc->pc);\n\n        }\n\n        if (cs->singlestep_enabled) {\n\n            gen_exception_internal(EXCP_DEBUG);\n\n        } else {\n\n            gen_step_complete_exception(dc);\n\n        }\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_UPDATE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            /* fall through */\n\n        case DISAS_JUMP:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n        case DISAS_EXC:\n\n        case DISAS_SWI:\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_WFI:\n\n            /* This is a special case because we don't want to just halt the CPU\n\n             * if trying to debug across a WFI.\n\n             */\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n    }\n\n\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start,\n\n                         4 | (dc->bswap_code << 1));\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n", "idx": 21267, "substitutes": {"cpu": ["ctx", "cp", "ola", "gc", "tp", "mx", "np", "linux", "jp", "CPU", "pixel", "ka", "nc", "vm", "conn", "sc", "environment", "ork", "chip", "proc", "core", "gpu", "mac", "gnu", "aco", "bean", "nic", "nu", "onet", "net", "phys", "pc", "ck", "pb", "process", "cam", "cu", "mem", "base", "upt", "rpm", "sys", "uci", "os", "hw", "clock", "alloc", "pu", "boot", "rc"], "tb": ["tv", "pbt", "treebt", "ttbl", "itxb", "tebb", "tbi", "twb", "ttybd", "tsbl", "pb", "ptx", "noteb", "ttybt", "timbi", "Tbl", "toB", "tov", "tobt", "notexb", "itb", "tba", "ptbe", "pbi", "treebd", "itbi", "tebi", "tbe", "tbt", "tob", "itbl", "tsb", "notebm", "tozb", "Tbb", "itbm", "tagb", " tfb", "toolwb", "tB", "itB", "ptb", "Tbi", "tenzb", "tgb", "toxb", "ttbt", "tenj", "traceb", "pbb", "tracefb", "itba", "txb", "treeba", "tsbe", "tracev", "tracebm", "tobi", "traceba", "itbb", "tbl", "ttbe", "tebl", "ttyb", "ttba", "tbm", "ttb", " txb", "ttx", "tj", "tbd", "ttyba", "tfb", "ptbl", " tB", "ttbd", "tracexb", "toolb", "Tb", "tracewb", "teb", "tzb", "tab", "timb", "tx", "tengb", "timbt", "tsx", "tazb", "toolv", "tenb", "togb", "tobb", "noteba", "tbb", "timbb", "toj", " tv", "toolfb", "treeb", " twb", "itv", "taj"], "cs": ["ac", "cp", "CS", "ls", "ci", "ca", "rs", "bs", "cms", "vs", "tc", "ps", "sc", "nc", "cc", "css", "acs", "ds", "c", "lc", "ts", "cus", "ec", "ss", "ys", "pc", "ns", "cks", "ck", "ks", "wcs", "sts", "sys", "os", "cmp", "caps", "rc"], "env": ["equ", "end", "viron", "np", "conf", "eng", "tc", "conn", "sc", "ei", "ext", "environment", "eh", "enc", "org", "server", "et", "buf", "hw", "eve", "docker", "cb", "cv", "ctx", "vs", "den", "vm", "dt", "era", "ds", "core", "config", "serv", "ec", "ens", "net", "en", "ew", "desc", "eas", "ent", "kernel", "priv", "v", "dev", "ev", "here", "nc", "ea", "er", "proc", "window", "next", "ect", "el", "estate", "hl", "eg", "inv", "esc", "dh", "vp", "sw", "cmd", "ef", "erc", "ce", "db", "nv", "e", "context"], "dc1": ["cca3", "tc2", "tc3", "dc9", "cca9", "cca2", "cca1", "DC2", " DC9", " DC1", "dc3", "DC3", "fc2", " dc2", "dc2", " DC2", "tc1", " dc3", " dc9", "DC1", " DC3", "fc1", "fc3"], "dc": ["oc", "vc", "adr", "central", "tc", "disc", "sc", "acl", "mac", "dr", "dm", "dl", "pc", "dd", "de", "cam", "condition", "nz", "die", "arc", "ctx", "cp", "ac", "gc", "cms", "d", "cc", "dt", "tm", "enter", "ds", "doc", "admin", "di", "ec", "document", "cat", "dp", "see", "desc", "comment", "bd", "draw", "rc", "cr", "td", "nc", "cm", "oe", "css", "currency", "wp", "lc", "kw", "drm", "controller", "cca", "fee", "ctl", "df", "design", "dat", "ca", "api", "bc", "ga", "DC", "def", "mc", "c", "fc", "du", "no", "da", "db", "cd", "isco", "dq", "dim"], "pc_start": ["sc23end", "pc23end", "pc00start", "pxWfirst", "pc_stop", "pc8first", "sc_end", "proc_stop", "pc_base", "pcWbase", "pcWpart", "sc_start", "pc8base", "px_first", "sc23start", "pc__start", "pcWstart", "pxWpart", "pc0end", "px_base", "proc_set", "PC_end", "pcWfirst", "pc__begin", "pxWstart", "pc00set", "pxWbase", "PC_start", "pc__end", "pc_begin", "pc23first", "px_start", "PC_pos", "pc_end", "pc_part", "pc00end", "pc0set", "pc8part", "pc00stop", "proc_end", "pc_pos", "pc_first", "pc8start", "pc0stop", "pc__pos", "sc23first", "proc_start", "pc0start", "sc_first", "pc_set", "pc23start", "PC_begin", "px_part"], "next_page_start": ["next_pages_start", "next_pages_pos", "next_page_end", "next_page_size", "next_page_pos", "next_page2offset", "next_pc_offset", "next_page2pos", "next_pages_size", "next_page2size", "next_page2start", "next_page_offset", "next_pc_pos", "next_pc_start", "next_pc_end", "next_pages_end", "next_page2end"], "num_insns": ["num_isinns", "num_innns", "num_inns", "num_inscs", "num_lsnz", "num_innfs", "num_inn", "num_lsn", "num_incns", "num_inncs", "num_incnis", "num_isincs", "num_insn", "num_lsns", "num_incs", "num_insfs", "num_infs", "num_incn", "num_isinfs", "num_insnis", "num_lsnis", "num_isinn", "num_innis", "num_innn", "num_innz", "num_insnz", "num_incnz"], "max_insns": ["max_rsn", "total__", "maxLex", "max_insuns", "max_incn", "max_rsuns", "maxL_", "max_minsns", "max_rsns", "max_incns", "max_minsuns", "max_incuns", "max_insne", "total_ex", "max_rsne", "max_minsn", "max__", "max_ex", "max_insn", "max_minsne", "max_incne"]}}
{"project": "FFmpeg", "commit_id": "2ac00d2d1d51047c6ce69d5fbe1a08392d142658", "target": 0, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {\n\n            sc->stsc_data[i].id = 0;\n\n            if (c->fc->error_recognition & AV_EF_EXPLODE) {\n\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 21281, "substitutes": {"c": ["ctx", "ac", "m", "cr", "cor", "ci", "p", "ca", "vc", "v", "cn", "bc", "conf", "can", "tc", "anc", "cache", "nc", "cm", "cc", "n", "mc", "C", "l", "co", "etc", "com", "chain", "cs", "fc", "lc", "config", "enc", "ec", "t", "ce", "g", "pc", "cd", "dc", "cv", "cur", "con", "cam", "e", "abc", "cu", "conv", "cf", "call", "coll", "f", "cont", "rc", "ct"], "pb": ["ctx", "cp", "pkg", "pel", "uf", "tp", "pack", "bb", "p", "erb", "pp", "sp", "bs", "eb", "ub", "conf", "req", "jp", "pm", "sb", "tc", "wb", "bp", "pan", "typ", "pl", "phy", "mp", "ob", "b", "stab", "wp", "proc", "fc", "tab", "vp", "tk", "buff", "PB", "pt", "db", "pro", "bj", "rb", "pc", "pa", "patch", "txt", "amp", "dp", "lb", "asm", "resp", "buf", "mb", "emb", "conv", "lp", "tf", "fb", "fp", "cb", "px", "pg"], "atom": ["m", " nm", " symb", "om", "p", "o", "entry", "or", "nm", "um", " atoms", " Atom", " ob", " ab", "orm", "bm", " orb", " cmd", " om", " exc", " p", " buf", " err", " x", " app", " form", "x"], "st": ["ust", "rest", "cr", "sn", "so", "inst", "p", "start", "sp", "ist", "tr", "ST", "ace", "stable", "src", "ost", "ocr", "sh", "St", "s", "sw", "ss", "ut", "t", "ft", "sta", "set", "nd", "est", "std", "cur", "sec", "th", "ch", "sts", "sv", "str", "ste", "stra", "stat", "mt", "ct"], "sc": ["ctx", "ac", "gc", "cr", "spec", "ci", "sci", "sp", "isc", "soc", "ok", "cer", "bc", "Sc", "loc", "can", "esc", "cgi", "tc", "anc", "qu", "scale", "nc", "mc", "cc", "cl", "scl", "craft", "com", "asc", "cs", "fc", "sh", "sync", "SC", "lc", "scope", "sw", "scan", "config", "ec", "ss", "psc", "uc", "set", "capt", "pc", "sch", "dc", "sche", "cv", "desc", "cam", "sec", "usc", "sic", "cu", "ch", "comp", "osc", "sys", " subsc", "scrib", "sd", "rc"], "i": ["rest", "multi", "ei", "ims", "mi", "\u0438", "uri", "phi", "series", "ip", "iq", "ri", "ini", "ind", "ii", "x", "pi", "f", "ki", "im", "q", " bi", "zi", "esi", "cgi", "it", "l", "qi", "iu", "iter", "di", "in", "k", "slice", " ni", "is", "v", "hi", "m", "me", "us", "si", "xi", "init", "ms", "ai", "g", "fi", "ui", "li", "iri", "batch", " ti", "ci", "ix", "p", "id", "n", "y", "ij", "ti", "s", "j", "t", " ii", "gi", "ic", "cli", "sim", "ji", "bi", "e", "oi", "index", "I", "ami"], "entries": ["mentries", "entsrys", "gentrys", "Entries", "entslements", "entsries", "ntures", "ntRY", "gentry", "entRY", "entsriers", "ENTRY", "entry", "curions", "enents", "curires", "Entencies", "entencies", "entsrance", "genties", "entures", "ENTrys", "nties", "mentrates", "gentlements", "Entrance", "ntries", "ntlements", "gentries", "Entry", "entriers", "entsions", "entsry", "entrys", "entsencies", "entsies", "Entures", "enires", "entlements", "ENTlements", "EntRY", "entires", "entsrates", "Entlements", "curents", "entsires", "entsures", "enties", "mentencies", "enries", "entions", "enions", "entsents", "Enties", "Entriers", "Entrates", "mentrys", "Entrys", "ntriers", "entents", "curries", "ENTies", "ntrys", "entrance", "gentrance", "ENTries", "entrates"]}}
{"project": "FFmpeg", "commit_id": "29b0d94b43ac960cb442049a5d737a3386ff0337", "target": 1, "func": "static int decode_copy(uint8_t *frame, int width, int height,\n\n                       const uint8_t *src, const uint8_t *src_end)\n\n{\n\n    const int size = width * height;\n\n\n\n    if (src_end - src < size)\n\n        return -1;\n\n    bytestream_get_buffer(&src, frame, size);\n\n    return 0;\n\n}\n", "idx": 21284, "substitutes": {"frame": [" Frame", "face", " frames", "scene", "iframe", "hide", "state", "id", "image", "fr", "force", "offset", "self", "feat", "style", "info", "Frame", "fram", "show", "stack", "point", "pointer", "error", "buffer", "target", "ref", "rame", "window", "channel", "frames", "code", "row", "base", "context", "local", "block", "f", "trace", "draw"], "height": ["above", "stroke", "Height", "volume", "ty", "ows", "alpha", "depth", "length", "padding", "resolution", "y", "ht", "sky", "style", "gravity", "history", "holes", "kw", "yt", "html", "density", "shape", "rows", "size", "count", "window", "hang", "grow", "row", "ch", "angle", "h", "ish", "gy"], "src": ["inst", "sl", "inner", "sq", "input", "rs", "seq", "sel", "req", "loc", "supp", "tmp", "sb", "ptr", "sc", "fr", "iv", "dist", "dest", "init", "ser", "text", "attr", "s", "rt", "RC", "load", "raw", "embed", "img", "target", "stream", "std", "slice", "ins", "cur", "buf", "now", "sec", "rob", "ind", "source", "ctr", "obj", "comp", "usr", "sr", "str", "sys", "rl", "addr", "st", "ack", "rc"], "src_end": ["rc_fin", "rc_End", "rc_ends", "src_fin", "src_ends", "src_End", "rc_end"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n", "idx": 21296, "substitutes": {"n": ["cdn", "m", "nw", "sn", "num", "p", "np", "nb", "o", "cn", "or", "mn", "w", "d", "nm", "nn", "nc", "conn", "N", "rn", "on", "y", "l", "co", "nor", "b", "an", "c", "nl", "fn", "r", "j", "nt", "nu", "node", "i", "gn", "t", "na", "dn", "g", "en", "ng", "f", "adj", "note", "out", "nv", "norm", "nr", "ne", "v"], "cmd": ["ctx", "cp", "cfg", "command", "m", "pkg", "q", "and", "control", "quit", "ctrl", "nm", "def", "conn", "nc", "ext", "it", "bind", "good", "quick", "term", "c", "send", "tab", "kw", "wd", "tx", "nt", "act", "ct", "build", "pt", "msg", "news", "ck", "cli", "iq", "cur", "desc", "resp", "md", "job", "ind", "ctr", "ch", "mem", "form", "crit", "comp", "op", "batch", "exec", "call", "urg", "Cmd", "cb", "cmp", "cont", "help", "comm"], "req": ["ctx", "pkg", "js", "rx", "q", "sq", "required", "qt", "seq", "jp", "eq", "request", "fr", "good", "quick", "tab", "requ", "r", "tx", "aux", "j", "res", "cond", "gz", "pro", "dem", "need", "msg", "fresh", "ref", "iq", "cur", "desc", "buf", "md", "resp", "ind", "mem", "comp", "crit", "rec", " requ", "usr", "dq", "rd", "urg", "fee", "qq", "rel", "quest", "ack"], "ns": ["js", "gs", "acts", "sn", "ls", "irms", "sp", "bs", "nas", "mn", "nos", "vs", "nn", "outs", "conn", "uns", "eps", "fs", "ims", "ds", "ains", "ons", "ms", "s", "cs", "nt", "ss", "ys", "NS", "na", "ans", "aos", "names", "ks", "its", "ins", " names", "sts", "qs", "xs", "ites", "ats", "aps", "os", "als", "ents", "Ns", "ne", "locks"]}}
{"project": "FFmpeg", "commit_id": "90c6963daea9210d7d2104e2ece94dd4e2fffc17", "target": 1, "func": "void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n", "idx": 21302, "substitutes": {"link": ["ick", "check", "pack", "sp", "ment", "lo", "type", "ln", "ld", "test", "join", "address", "set", "ip", "store", "call", "block", "cell", "action", "list", "zip", "parse", "tag", "l", "html", "flag", "Link", "loop", "map", "error", "ping", "ink", "flow", "local", "relation", "connect", "word", "loc", "image", "ay", "url", "thread", "load", "scan", "node", "li", "ck", "play", "route", "lay", "way", "share", "le", "close", "tool", "entry", "id", "linked", "def", "flex", "style", "task", "line", "lock", "light", "sync", "query", "mark", "build", "match", "let", "disk", "process", "label"], "i": ["json", "name", " li", "multi", "ori", " mi", "ei", "ims", "chain", "mi", "ski", "\u0438", "phi", "iq", "ini", "ind", "x", "ii", "pi", "yi", "io", "ki", "im", " pi", " bi", "it", "gu", "qi", "iu", "di", "print", "u", " j", " ni", "is", "v", "m", "si", " si", " di", "xi", "init", "ai", "g", "ui", "li", " multi", " err", " m", " ti", "ci", "ix", "p", "id", "span", "y", "ij", "ti", "s", "c", "j", "uli", "t", " ii", "gi", "ic", "key", "sim", "bi", "e", "oi", "index", "I", "ami"], "picref": ["picnum", "pcinfo", "piclink", "txtob", "pinconf", "picinfo", "ericreq", "picro", "PicRef", "pictab", "icrel", " picnum", "pinreq", "picrel", "picreference", " picrel", "ericref", "icentry", "photoref", "txtref", "icRef", "icreg", "icdef", "txtlink", "picconf", "icreq", "piccell", "pinref", "ericRef", "picreg", "phototab", "pictref", " picob", "icref", " piclink", "pcref", "ictab", "niccell", "nictab", "nicref", "pinentry", "ericreg", "pinnum", "txtinfo", "icro", "Picref", "iccell", "icconf", "pinrel", "pictrel", "ericentry", "ericreference", "picob", "picdef", "icreference", "picreq", "photoro", "photocell", "picRef", " picinfo", "picentry", " picconf", "pinreference", "pclink", " picdef", "pcob", "Picreq", "pictnum", "pictdef", "Picreg", "nicro", "pindef"]}}
{"project": "qemu", "commit_id": "375cb560295484b88898262ebf400eff9a011206", "target": 0, "func": "static uint64_t pl110_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    pl110_state *s = (pl110_state *)opaque;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return idregs[s->version][(offset - 0xfe0) >> 2];\n\n    }\n\n    if (offset >= 0x200 && offset < 0x400) {\n\n        return s->raw_palette[(offset - 0x200) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* LCDTiming0 */\n\n        return s->timing[0];\n\n    case 1: /* LCDTiming1 */\n\n        return s->timing[1];\n\n    case 2: /* LCDTiming2 */\n\n        return s->timing[2];\n\n    case 3: /* LCDTiming3 */\n\n        return s->timing[3];\n\n    case 4: /* LCDUPBASE */\n\n        return s->upbase;\n\n    case 5: /* LCDLPBASE */\n\n        return s->lpbase;\n\n    case 6: /* LCDIMSC */\n\n        if (s->version != PL110) {\n\n            return s->cr;\n\n        }\n\n        return s->int_mask;\n\n    case 7: /* LCDControl */\n\n        if (s->version != PL110) {\n\n            return s->int_mask;\n\n        }\n\n        return s->cr;\n\n    case 8: /* LCDRIS */\n\n        return s->int_status;\n\n    case 9: /* LCDMIS */\n\n        return s->int_status & s->int_mask;\n\n    case 11: /* LCDUPCURR */\n\n        /* TODO: Implement vertical refresh.  */\n\n        return s->upbase;\n\n    case 12: /* LCDLPCURR */\n\n        return s->lpbase;\n\n    default:\n\n        hw_error(\"pl110_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 21306, "substitutes": {"opaque": ["opaques", " opoid", "Opaque", "opacity", "ropoxy", "oplaque", "opque", "Opoxy", " opacity", "Opque", " opity", "opity", "Opacity", "ropoid", "oplity", "opoid", "Opoid", "ropaque", " opoxy", "oplacity", " opque", "oplque", "Opaques", "opoxy", "Opity", " opaques", "ropaques"], "offset": ["associated", "sp", "at", "slot", "payment", "Offset", "address", "origin", "order", "ft", "set", "output", "et", "client", "after", "attribute", "peer", "trace", "term", "command", "o", "esi", "adjusted", "padding", "range", "shift", "prefix", "pointer", "pos", "tif", "encrypted", "area", "error", "message", "position", "align", "len", "xy", "kernel", "topic", "oid", "seek", "ff", "reset", "pad", "length", "ptr", "scroll", "url", "empty", "location", "point", "timeout", "outer", "window", "OFF", "ix", "start", "id", "entry", "path", "layout", "style", "bound", "offer", "no", "buffer", "usage", "key", "ref", "off", "out", "code", "now", "article", "operation", "index", "addr", "response"], "size": ["start", "sp", "body", "z", "name", "type", "SIZE", "length", "Size", "n", "shift", "c", "send", "address", "empty", "sum", "format", "set", "area", "message", "count", "window", "len", "code", "mem", "ize", "cap"], "s": ["eds", "sp", "rs", "bs", "points", "ants", "types", "fs", "ims", "settings", "stats", "packs", "lines", "ies", " ads", "izes", "its", "ords", "a", "sam", "os", "ls", "es", "z", "ials", "aches", "vs", "outs", "ps", " mods", "sis", "ds", "self", "b", "ands", " counts", "ess", "ests", "ts", "umps", "rows", "less", "ubs", " styles", "ed", " formats", " results", " parts", " objects", "ports", "reports", "se", "is", "v", "js", "gs", "m", "sets", "tes", "ssl", "sl", "bits", "rates", "ches", "resses", "des", "parts", "bis", "sm", " values", "iffs", "ains", "ses", "ss", "aws", "olds", "g", "ations", "ions", "ers", " instruments", "hs", "services", "sts", "sys", "ats", "aces", "ists", "styles", "sports", "comm", "forms", "sq", "p", "ths", "details", "sb", "y", "ments", "values", "aints", "c", "grades", "sw", "j", "mods", "erences", "t", "ns", "itions", " streams", "changes", "sv", "qs", "h", "S", "als", "vals", "ents", "ries"]}}
{"project": "FFmpeg", "commit_id": "eb38d8fe926bdce8110fa4be4fddf6598a079a20", "target": 0, "func": "static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,\n\n                sb_int8_array coding_method, int nb_channels,\n\n                int c, int superblocktype_2_3, int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    // This should never happen\n\n    if (nb_channels <= 0)\n\n        return;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 21311, "substitutes": {"tone_level_idx": ["tone_level_timex", "tone_level_idsox", "tone_level_idsg", "tone_level__inx", "tone_level2idsxs", "tone_level3timeox", "tone_level_idsn", "tone_level2idg", "tone_level__ing", "tone_level_Idpx", "tone_level3timep", "tone_levelllistb", "tone_level_idg", "tone_level3timeg", "tone_level_idexes", "tone_levellidb", "tone_levellidg", "tone_level_idsx", "tone_level_Idn", "tone_level__idn", "tone_level__idp", "tone_level_idn", "tone_level_inx", "tone_level_timeg", "tone_level_idxes", "tone_level2idn", "tone_level_idp", "tone_level_idsxs", "tone_levellidpx", "tone_level_idxs", "tone_level_iden", "tone_level_inn", "tone_level_timeox", "tone_level_idpx", "tone_levellidx", "tone_level_Idb", "tone_level_listpx", "tone_levelllistpx", "tone_level_ing", "tone_level_inxs", "tone_level_idsxes", "tone_level_Idx", "tone_level_idsp", "tone_level2idsg", "tone_level2idxs", "tone_level__idg", "tone_level_idb", "tone_level2idsn", "tone_level2idsx", "tone_level_idexs", "tone_level_Idg", "tone_level__inxs", "tone_level_ideg", "tone_level3timex", "tone_level2idx", "tone_level__idxes", "tone_level_idex", "tone_level3idg", "tone_level_listg", "tone_level_idv", "tone_level_idep", "tone_level_timep", "tone_level_listx", "tone_level_Idxs", "tone_level__idx", "tone_level__idxs", "tone_level__inn", "tone_levelllistx", "tone_level_idsv", "tone_level3idp", "tone_levelllistg", "tone_level_listb", "tone_level_idox", "tone_level3idox", "tone_level_idev", "tone_level3idx"], "tone_level_idx_temp": ["tone_level_idg_temp", "tone_level_idz_current", "tone_level_idg_current", "tone_level_idg_Temp", "tone_level_idx2current", "tone_level_idz_temp", "tone_level_idg_result", "tone_level_idg_buffer", "tone_level_idx2temp", "tone_level_idx2tmp", "tone_level_idx0temp", "tone_level_idx2buffer", "tone_level_idz_local", "tone_level_idx_buffer", "tone_level_idg_tmp", "tone_level_idx_cache", "tone_level_idx_tmp", "tone_level_idx_result", "tone_level_idz_tmp", "tone_level_idx_current", "tone_level_idx_Temp", "tone_level_idx0local", "tone_level_idx0current", "tone_level_idg_cache", "tone_level_idx0tmp", "tone_level_idx_local"], "coding_method": ["codingamemethod", "coder_method", "coder_data", "codingameoptions", "coder_options", "coding_options", "codingamedata", "codingamename", "coding_name", "coder_name", "coding_data"], "nb_channels": ["nb_cannels", "nb_Chones", "nb_chairs", "nb_chanairs", "nb_chones", "nb_achones", "nb_chanannels", "nb_Channels", "nb_chans", "nb_Chairs", "nb_chars", "nb_achans", "nb_champles", "nb_Chars", "nb_achiers", "nb_cars", "nb_cairs", "nb_multiplannels", "nb_chanars", "nb_achannels", "nb_chanamples", "nb_multipliers", "nb_multiplones", "nb_Chans", "nb_chiers", "nb_camples", "nb_Champles", "nb_chanans", "nb_multiplans", "nb_cans", "nb_Chiers"], "c": ["ac", "cp", "m", "p", "v", "bc", "d", "cache", "n", "cm", "sc", "cc", "C", "l", "b", "cs", "fc", "lc", "t", "count", "cv", "h", "rc", "f", "cb", "cod", "ct"], "superblocktype_2_3": ["superblocktype_2_2", "superblocktype_3_7", "superblocktype_1_0", "superblocktype_3_2", "superblocktype_2x7", "superblocktype_2_7", "superblocktype_2x0", "superblocktype_3_3", "superblocktype_2_1", "superblocktype_2x3", "superblocktype_1_2", "superblocktype_1_3", "superblocktype_2x2", "superblocktype_2_0", "superblocktype_3_1", "superblocktype_1_1", "superblocktype_2x1"], "cm_table_select": ["cm_type_select", "cm_table_filter", "cm_table_selection", "cm_type_selection", "cm_table2select", "cm_table2selection", "cm_table2table", "cm_type_filter", "cm_table_table", "cm_table2filter", "cm_type_table"], "ch": ["cor", "vc", "Ch", "chi", "cha", "ot", "arch", "sc", "conn", "cht", "cs", "ut", "chrom", "CH", "et", "count", "cur", "con", "work", "x", "hw", "chan", "cb", "ac", "cp", "q", "zh", "z", "ih", "qu", "gb", "ht", "att", "b", "sch", "che", "ach", " Ch", "yet", "m", "cr", "hr", "mk", "chart", "br", "ph", "fr", "ich", "ech", "sky", "mot", "er", "history", "gr", "atch", "g", "channel", "batch", "tch", "chy", "th", "ct", "kh", "chron", "chn", "och", "ca", "ur", "_", "uch", "ah", "y", "sh", "he", "bt", "gh", "i", "cho", "cd", "chat", "all", "h", " CH", "sk", "new"], "sb": ["jj", "ebin", "bb", "sp", "bs", "SB", "shell", "esm", "sc", "sa", "sit", "rb", "pb", "sth", "bps", "sam", "bf", "cb", "gc", "erb", "nb", "jp", "isi", "gb", "wb", "bp", "shop", "b", "buff", "serv", "osp", "bh", "bj", "sch", "abb", "mb", "hh", "sf", "se", "lp", "fb", "usb", "sn", "ssl", "eb", "ja", "ub", "si", "bis", "sm", "meg", "orb", "kb", "sbm", "fi", "ssh", "hs", "sys", "bn", "ha", "kh", "bc", "gov", "src", "typ", "ij", "arb", "dh", "stab", "s", "sh", "sw", "ib", "bt", "db", "bg", "lb", "zb", "ji", "bi", "bot", "sv", "sr", "ibl", "sg", "sat", "sd"], "j": ["jj", "js", "m", "json", "eg", "ix", "q", "p", "sp", "bs", "z", "ja", "uj", "at", "aj", "pr", "jp", "ot", "je", "ion", "br", "n", "fr", "y", "it", "jas", "oj", "dj", "l", "ij", "att", "ht", "jc", "b", "jet", "er", "jo", "kid", "i", "jl", "pt", "k", "db", "bj", "g", "jac", "ng", "J", "adj", "note", "job", "ji", "ju", "obj", "bi", "jit", "str", "jump", "kj", "ia", "ik", "v", "bo"], "tmp": ["temp", "cp", "jj", "perm", "Temp", "pkg", "aaa", "mm", "trap", "np", "sp", "p", "mk", "prep", "td", "emp", "tt", "gm", "tc", "cache", "copy", "prop", "src", "test", "appy", "tm", "mp", "etc", "result", "attr", "buff", "empty", "mmm", "cmd", "img", "timeout", "pos", "t", "prime", "MP", "msg", "txt", "amp", "ip", "resp", "buf", "snap", "out", "obj", "xy", "pre", "tf", "qq", "cmp", "sup", "cb", "yet"], "acc": ["ac", "eff", "perm", "inc", "alpha", "ca", "mod", "conf", "cache", "sc", "cc", "aff", "att", "attr", "aa", "ACC", "sum", "fac", "amp", "adj", "angle", "rec", "arr", "op", "alloc", "cont", "cell"], "esp_40": ["esp8temp", "ampxw", "esp_w", "ampxmult", "esp_mult", "esp_temp", "amp_mult", "espx40", "esp840", "esp8w", "amp_40", "esp8mult", "espxw", "amp_temp", "ampx40", "espxtemp", "ampxtemp", "amp_w", "espxmult"], "comp": ["ctx", "cp", "perm", "prep", "mod", "conf", "sup", "cache", "component", "com", "attr", "proc", "fc", "buff", "app", "img", "cond", "amp", "butt", "ip", "comment", "change", "omp", "op", "Comp", "cmp", "qq", "rc"], "add1": ["add91", "plus1", "append1", "attach1", "append4", "Add4", " add100", "AddOne", "ADD2", "attach100", " add5", "ADDOne", "add5", "Add2", " add91", "Add5", "attach3", "plusOne", "Add91", "append91", "dd1", " addOne", "dd2", "Add3", "plus5", "addOne", "Add100", "ADD1", "append2", "Add1", "attachOne", "add100", "ddOne", "plus2"], "add2": ["add404", "Add6", "pad404", "add14", "create404", " add6", "Add4", "att404", "pad42", "pad2", "att2", "Add2", "Add02", "create42", "create1", "dd4", "attTwo", "add42", "dd3", "create2", "create02", "adder2", "add02", "dd1", "att42", "create6", "add6", "adder4", "dd2", " add14", "padTwo", "Add3", " add02", "Add14", "Add1", "adder14", "createTwo", "addTwo"], "add3": ["Add4", "addthird", " add103", "ext1", "buildthree", "add103", "find1", "attach6", "addthree", "attach43", "add003", "ad6", "add43", " addthree", "ADD2", " addIII", "attachThree", " add003", "make02", "add6", "Add43", "Add3", "ord003", "ext3", "ad1", " add43", "ad3", "apply003", "ext6", "make1", "ord103", "ord03", "attach1", "make3", "apply03", "findthird", "build3", "create1", " addThree", "add02", " add03", "makethree", "findIII", "cond1", "ADD4", "cond43", "addThree", " add02", "condThree", "attach5", "ord3", "ADD43", "build02", "cond3", "ad5", "ADD3", "create3", "add5", "ext5", "Add2", "createthird", "attach3", "apply3", "apply103", " addthird", "find3", "add03", "build1", "createIII", "addIII"], "add4": [" addFour", "join4", "addfour", "add04", "Add6", "attach2", "ADD04", "append04", "append4", " add6", "Add4", "join9", "joinfour", " addfour", "join3", "ADD3", "attachFour", "add7", "Add2", " add7", "dd4", "load4", "load3", " add9", "attach3", "attach9", "dd3", "Add04", "dd1", "attachfour", "add6", "attach6", "dd7", "Add7", "attach4", "addFour", "dd2", "ADD4", "ddFour", " add04", "append2", "Add1", "add9", "load04"], "multres": ["modvals", "divvals", "_RES", "_vals", "modres", "_res", "putvals", "putRES", "modRES", "modRes", "_Res", "putRes", "divres", "divRES", "divRes", "putres"]}}
{"project": "qemu", "commit_id": "1e577cc7cffd3de14dbd321de5c3ef191c6ab07f", "target": 0, "func": "void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                        int flags)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    int i;\n\n\n\n    if (is_a64(env)) {\n\n        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);\n\n        return;\n\n    }\n\n\n\n    for(i=0;i<16;i++) {\n\n        cpu_fprintf(f, \"R%02d=%08x\", i, env->regs[i]);\n\n        if ((i % 4) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n        else\n\n            cpu_fprintf(f, \" \");\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t xpsr = xpsr_read(env);\n\n        const char *mode;\n\n\n\n        if (xpsr & XPSR_EXCP) {\n\n            mode = \"handler\";\n\n        } else {\n\n            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {\n\n                mode = \"unpriv-thread\";\n\n            } else {\n\n                mode = \"priv-thread\";\n\n            }\n\n        }\n\n\n\n        cpu_fprintf(f, \"XPSR=%08x %c%c%c%c %c %s\\n\",\n\n                    xpsr,\n\n                    xpsr & XPSR_N ? 'N' : '-',\n\n                    xpsr & XPSR_Z ? 'Z' : '-',\n\n                    xpsr & XPSR_C ? 'C' : '-',\n\n                    xpsr & XPSR_V ? 'V' : '-',\n\n                    xpsr & XPSR_T ? 'T' : 'A',\n\n                    mode);\n\n    } else {\n\n        uint32_t psr = cpsr_read(env);\n\n        const char *ns_status = \"\";\n\n\n\n        if (arm_feature(env, ARM_FEATURE_EL3) &&\n\n            (psr & CPSR_M) != ARM_CPU_MODE_MON) {\n\n            ns_status = env->cp15.scr_el3 & SCR_NS ? \"NS \" : \"S \";\n\n        }\n\n\n\n        cpu_fprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\",\n\n                    psr,\n\n                    psr & CPSR_N ? 'N' : '-',\n\n                    psr & CPSR_Z ? 'Z' : '-',\n\n                    psr & CPSR_C ? 'C' : '-',\n\n                    psr & CPSR_V ? 'V' : '-',\n\n                    psr & CPSR_T ? 'T' : 'A',\n\n                    ns_status,\n\n                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);\n\n    }\n\n\n\n    if (flags & CPU_DUMP_FPU) {\n\n        int numvfpregs = 0;\n\n        if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n            numvfpregs += 16;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n            numvfpregs += 16;\n\n        }\n\n        for (i = 0; i < numvfpregs; i++) {\n\n            uint64_t v = float64_val(env->vfp.regs[i]);\n\n            cpu_fprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\",\n\n                        i * 2, (uint32_t)v,\n\n                        i * 2 + 1, (uint32_t)(v >> 32),\n\n                        i, v);\n\n        }\n\n        cpu_fprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARM_VFP_FPSCR]);\n\n    }\n\n}\n", "idx": 21324, "substitutes": {"cs": ["ctx", "cp", "CS", "js", "ls", "ix", "es", "rs", "bs", "ces", "vs", "ps", "sc", "icks", "cc", "css", "fs", "acs", "ds", "ms", "ics", "s", "c", "ts", "cus", "ss", "ec", "ys", "cas", "ns", "cks", "ks", "cv", "csv", "hs", "sts", "cf", "rc"], "f": ["lf", "fo", "ff", "uf", "q", "p", "full", "file", "o", "fw", "fl", "w", "d", "um", "fr", "ile", "fe", "fd", "fs", "fa", "l", "b", "s", "c", "fn", "fc", "r", "ef", "t", "ft", "g", "fi", "rf", "xf", "out", "e", "F", "bf", "form", "sf", "h", "cf", "tf", "fb", "fp", "fm", "v", "fx"], "cpu_fprintf": ["cpu_cprintf", "cpu_cprint", "cpu_fwformat", "cpu___fprint", "cpu_cwrite", "cpu_fpush", "cpu_dpdf", "cpu_reprintln", "cpu_fpdf", "cpu_dwrite", "cpu___frint", "cpu_rprint", "cpu_fxformat", "cpu_fpprintf", "cpu_frep", "cpu_fwpdf", "cpu___fpprint", "cpu_rprintln", "cpu_lprint", "cpu_dprintf", "cpu_fxprint", "cpu_dpush", "cpu_fpprintln", "cpu_cformat", "cpu___fpprintf", "cpu_fxrep", "cpu_frint", "cpu_fprint", "cpu_fapply", "cpu_fprintln", "cpu___fprintf", "cpu_dformat", "cpu_mprint", "cpu_dprintln", "cpu_dapply", "cpu_rwrite", "cpu_mprintln", "cpu_fpprint", "cpu_tprintf", "cpu_rprintf", "cpu_mprintf", "cpu_mapply", "cpu_lformat", "cpu_lprintln", "cpu_fxprintf", "cpu_lprintf", "cpu_drep", "cpu_crep", "cpu_fwrite", "cpu_repush", "cpu_drint", "cpu___fprintln", "cpu_tprintln", "cpu___fpprintln", "cpu_reprintf", "cpu_fwprint", "cpu_cpdf", "cpu_dprint", "cpu_rformat", "cpu_tapply", "cpu_fformat", "cpu_tprint", "cpu_fwprintf", "cpu_reprint"], "flags": ["pins", "alf", "gs", "comments", "FLAG", "ints", "bits", "details", "tags", "lag", "ants", "eps", "types", "fs", "status", "ensions", "ms", "files", "settings", "kind", "limits", "ts", "flag", "args", "cond", "atts", "members", "ags", "frames", "options", "features", "ports", "ats", "fps", "properties", "mask", "fee", "ents", "fields", "heads", "Flags"], "cpu": ["ctx", "cp", "ola", "gc", "mx", "linux", "cn", "CPU", "rom", "ka", "util", "arch", "tc", "anc", "conn", "nc", "aq", "ork", "proc", "c", "core", "gpu", "mac", "aco", "bean", "processor", "bench", "pc", "ck", "setup", "process", "cu", "mem", "comp", "cf", "hw", "clock", "pu", "stat", "ack", "cv"], "env": ["pkg", "equ", "end", "viron", "esm", "conf", "shell", "pe", "eng", "conn", "ei", "sc", "ext", "environment", "attr", "worker", "enc", "org", "server", "et", "hw", "docker", "erd", "cv", "ctx", "der", "qt", "manager", "vs", "den", "vm", "self", "era", "scope", "config", "ec", "net", "map", "en", "ew", "desc", "kernel", "priv", "v", "rc", "js", "dev", "te", "ev", "engine", "console", "ea", "nc", "oe", "ten", "init", "er", "proc", "outer", "window", "obj", "hl", "esp", "err", "cfg", "spec", "eg", "inv", "esc", "sw", "cmd", "ce", "dn", "ie", "db", "ner", "nv", "e", "context", "mem", "runner", "eu"], "i": ["m", "me", "list", " ti", "ci", "ix", "p", "o", "id", " bi", "si", "multi", "zi", "span", "ei", "it", "ims", "xi", "ij", "ti", "mi", "ms", "qi", "iu", "c", " v", "j", "di", "in", "point", "\u0438", "ai", "t", "ki", " ii", " I", "g", "gi", "ui", "li", "ic", "key", " j", "ip", "sim", "cli", "number", "ini", "bi", "ind", "oi", "index", "x", "ii", "pi", "batch", "asi", "I", "ami", "is", "v", " pi"], "mode": ["meta", "stage", "command", "m", "me", "mm", "te", "direction", "state", "mod", "MODE", "name", "type", "power", "password", "pe", "master", "module", "layout", "status", "role", "style", "lock", "mac", "show", "config", "format", "move", "mit", "message", "phrase", "metadata", "key", "position", "device", "language", "md", "code", "ase", "mate", "none", "zero", "mem", "time", "Mode", "model", "mid", "mask", "ode", "sequence", "mt", "use", "menu"], "ns_status": ["ims_source", "ns__source", "ims__source", "ns_str", "ns_Status", "nz_stats", "ims__Status", "ns_stats", "ns_atus", "ns__Status", "nz_spin", "nz_status", "ims__status", "ims_Status", "ims_status", "ns__status", "ns_spin", "ims__str", "ims_str", "nz_atus", "ns_source", "ns__str"]}}
{"project": "qemu", "commit_id": "07d4e69147b4957e617812206a62a86f03294ad3", "target": 1, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n    int ret = 0;\n\n\n\n    trace_vmstate_load_state(vmsd->name, version_id);\n\n    if (version_id > vmsd->version_id) {\n\n        error_report(\"%s: incoming version_id %d is too new \"\n\n                     \"for local version_id %d\",\n\n                     vmsd->name, version_id, vmsd->version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too new\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        if (vmsd->load_state_old &&\n\n            version_id >= vmsd->minimum_version_id_old) {\n\n            ret = vmsd->load_state_old(f, opaque, version_id);\n\n            trace_vmstate_load_state_end(vmsd->name, \"old path\", ret);\n\n            return ret;\n\n        }\n\n        error_report(\"%s: incoming version_id %d is too old \"\n\n                     \"for local minimum version_id  %d\",\n\n                     vmsd->name, version_id, vmsd->minimum_version_id);\n\n        trace_vmstate_load_state_end(vmsd->name, \"too old\", -EINVAL);\n\n        return -EINVAL;\n\n    }\n\n    if (vmsd->pre_load) {\n\n        int ret = vmsd->pre_load(opaque);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    }\n\n    while (field->name) {\n\n        trace_vmstate_load_state_field(vmsd->name, field->name);\n\n        if ((field->field_exists &&\n\n             field->field_exists(opaque, version_id)) ||\n\n            (!field->field_exists &&\n\n             field->version_id <= version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            vmstate_handle_alloc(first_elem, field, opaque);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n\n                                             field->vmsd->version_id);\n\n                } else {\n\n                    ret = field->info->get(f, curr_elem, size, field);\n\n                }\n\n                if (ret >= 0) {\n\n                    ret = qemu_file_get_error(f);\n\n                }\n\n                if (ret < 0) {\n\n                    qemu_file_set_error(f, ret);\n\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n\n                                 field->name);\n\n                    trace_vmstate_load_field_error(field->name, ret);\n\n                    return ret;\n\n                }\n\n            }\n\n        } else if (field->flags & VMS_MUST_EXIST) {\n\n            error_report(\"Input validation failed: %s/%s\",\n\n                         vmsd->name, field->name);\n\n            return -1;\n\n        }\n\n        field++;\n\n    }\n\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n    if (vmsd->post_load) {\n\n        ret = vmsd->post_load(opaque, version_id);\n\n    }\n\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n\n    return ret;\n\n}\n", "idx": 21335, "substitutes": {"f": ["lf", "af", "m", "uf", "p", "o", "file", "fw", "w", "d", "fr", "ile", "fd", "fs", "l", "self", "b", "c", "fc", "r", "ef", "t", "fi", "rf", "xf", "con", "e", "F", "bf", "form", "h", "sf", "cf", "tf", "fb", "fee", "fp", "fm", "fed", "v", "fx"], "vmsd": [" vmsde", "vmosd", "vmemsord", "vtsda", "vjsdh", "revcmsdid", "vimsisd", "vejsda", "vstatsdk", "vmmsds", "vejssd", "vmsmd", "vMSds", "revmsdid", "vermsds", "viasd", "vMSda", "vminsmd", "vbsds", "vmmsd", "viewmmd", "vatsden", "vmjsda", "viasdh", "vmmsda", " varmsd", "vinsda", "vomsde", "vantsda", "vamsbd", "vmsds", "vjsdl", "vmmsmd", "vbsl", "vmsdh", "vmesdh", "vlsda", "vmersdid", "vearsds", "vjsdc", " vjsdc", "vjssd", " vmdord", "vmsda", "evomsd", "vinsdm", "vcamsgd", "avmsisd", "vemsds", "verbsl", "vmmsord", "vminsisd", "vstatsdis", "vjsds", "verantsdh", "vcmsds", "vtsD", "vvsd", "ventsd", "cvmsl", "viewmmds", "vmemsmd", "viewmmdid", " vjsdo", "vstatsd", "vmsdis", "viasl", "vtsdc", "ventsdh", "vminsord", "vtsd", "vmosdi", "veratsd", "vmesgd", "avimsd", "veratsbd", "vmmdis", "avmsd", "vjsd", "vmesdx", "vminsden", "vcamsds", "vmld", " varmsdo", "vejsdl", "cmesds", "verbsd", "vlssd", "vmesl", "vomssd", "veksd", "vantsdis", "vmsdid", "vksd", "vemsdis", "ventsdx", "verantsdi", "vvssd", "evmssd", "vMSdid", "vmsord", "vsysden", "cmesda", "vmyda", " vmsbd", "vMSd", "vcmsd", "vmsdm", "vimsd", "vmsdo", " vmdd", "revcmsds", "vejsd", "mmsd", "vminssd", "vistsds", "vemsdl", "vamsd", "vermsdid", "evmsd", "vysdo", "vmosord", " vmsdc", " vmdsd", "vistsgd", "vmersde", "vsysbd", "vmosD", "viewmsdid", "vsysdid", "vermsd", "vbsdc", "vcamsd", "avimsisd", "mmesd", "vemsord", "vmsbd", "cmsda", "verbsds", "vmsden", "vmsdc", "vmersdo", "vminsde", "vemsd", " vjssd", "vMSdis", "varmsdo", " vjsd", "vmersd", " vmssd", " varmsdx", "vmmdid", "viewmsds", "varmsdx", "vinsd", "verantsd", "vportsdl", "vjsD", "vvsdo", "viewmsdis", "revmsds", "cvmsgd", "vmesds", "vtsds", "vportsda", "vminsd", "cmsd", "vmssd", " vmsord", "vminsdis", "vantsd", "vmdord", "cmesd", "vamsdm", "vmsdl", "vjsdi", "evmsde", "vatesda", "verantsD", "veratsden", "vcmsdis", "vmjsD", "vemssd", "ventsda", "vamsord", "evomsord", "vermsden", "vmesda", "vermsdc", "vmsisd", "viewmmdis", "vlsdl", "ventsde", "cvmsda", "vatesl", "vearsord", "varmsde", " varmsde", "vmmd", "vomsord", "vstatsisd", "vemsdi", "vmosdh", "vMSD", "vmlda", "vportssd", "vamsgd", "vistsdc", "vamsda", "evomssd", "vimsdis", "vysd", "vmmds", "cmesdm", "vmdbd", "vcmsdid", "mmsda", "vmersdx", "vmesd", "ventsl", "vmossd", "mmesdh", "vamsdc", "verbsdc", "vermsdi", "veksda", "vmsl", "cvatesl", "vmsdx", "vmdd", "evomsde", "vbsd", "vemsde", "vminsds", " vmsdx", "vatsbd", "vmesdc", "avimsdis", "vantsdi", "vjsdo", "veratsdid", "ventsdo", "vatsdid", "vinsds", "vatesgd", "cmsdm", "vmesdid", "vmsdk", "mmsdh", "vmemsds", "vantsD", "vamsds", "vatesd", "vermsl", "cvatesgd", "vminsdk", "vmydis", "varmsd", "vvsdc", "avmsdk", "vcmsdc", "avmsdis", "vimsdk", "vyssd", "vmmsD", "vmyd", "vmll", "vmsD", "vistsd", "revcmsdx", "vminsdid", "veksdi", "mmesda", "revmsdx", "viewmsd", "avimsdk", "vysdc", "vmydi", "vermsdh", " vmdbd", "vtsl", "vminsbd", "vsysd", "cvatesda", "vermsbd", "vmersds", "vlsd", "vmsdi", "vemsda", "vatsd", "vomsd", "vmsde", "vmemsd", "mmesl", "cvmsd", "veksdis", "vearsd", "vmdsd", "revmsd", "vmesdm", "vksdis", "vmlgd", "vksda", "vamssd", "cvatesd", "mmsl", "vjsda", "vcamsdc", "revcmsd", "vmjsd", "evmsord", " vmsdo", "viasda", "vcmsgd", "vmosbd", "vermsD", "vksdi", "vcmsdx", "vmjsds", "vantsdh", "vmsgd", "vearsmd", "cmsds", "vportsd", "vemsmd"], "opaque": ["Opaque", "patile", "obaco", "itaco", "opsent", "opsque", "obaque", "ipacity", "opsolete", "compaque", "alaque", "operaque", "chacity", " opque", " opsole", "imacity", "chaque", "opsaque", "opoch", "popque", " opent", "operatile", "hopaque", "imaques", "itatile", " opacity", "itaque", "psole", "pque", "pacity", "ipaque", "chatile", "operaques", "hopsole", " opaques", "choch", "opacity", "hopacity", "ipaques", "operque", "imque", "compque", "ipent", "obatile", "opsole", "compacity", "alatile", "hopempty", "itacity", "operacity", "opity", "ipque", "obity", "paque", "opent", "popsolete", "Opaques", "popaque", "chque", "Opsolete", "compoch", "pempty", "opaques", "opsaques", "obsolete", "opaco", "opque", " opempty", "Opque", "alaques", "obacity", "imaque", "popaques", "chaco", "obque", "oboch", "operity", "ipatile", "obaques", "opatile", "ality", "opempty"], "version_id": ["nodeetyflag", "version___id", "version1oid", "version_flag", "vision_id", "vision_oid", "version_type", " version_info", "versionThelong", "vision_mid", "version_info", "Version_ID", "version_source", "version____ad", "version_Id", "vision___ad", "version_mid", "versionetyname", "Version_ids", " version_uid", "version___mid", "version___ids", "vision_it", "versionxi", "version_oid", "version_if", "versionTheb", "module___mid", "versionWip", "Version_type", "versionetyflag", "version_ids", "versionityif", "version____name", "version_pid", "vision_url", "node_name", "versionetysource", "version_number", "vision_b", "version_ide", "version2info", "vision_number", "versionableid", "version_part", "version___ad", "version_i", "module_oid", " version_ide", "node_flag", "version1number", "versionTheid", "version2it", "versionablebit", "version2b", "nodeetyname", "module_d", "version_ip", "module_id", "version_ad", "version_ID", "vision1number", "module___d", "version___part", "version___d", "versionWid", "versionityuid", "version1id", "module___oid", "versionableids", "vision1mid", "version_bit", "Version_id", " version_bit", "vision___part", " version_no", " version_Id", "version_d", "vision___id", "vision_ids", "version2ids", "version_uid", "version___oid", "version____id", "versionWi", "vision_ip", " version_ids", "versionxid", "vision_ad", "versionetyid", "version_name", "version____part", "vision1oid", "version_url", "nodeetysource", "version_long", "version____ids", "version____source", "node_source", "module___id", "vision_i", "version2id", "versioningpid", "vision___ids", "vision_part", "versioningid", "version2long", "versionxurl", "version____flag", "version_it", "versionityid", "versionWurl", "version1mid", "node_id", " version_if", "versionTheit", "nodeetyid", "version2no", "versionableif", " version_pid", "version_no", "version_b", "versioninginfo", "module_mid", "vision1id", "versionxip", "vision_long"], "field": ["lf", "ment", "file", "name", "handler", "type", "user", "ld", "good", "holder", "attr", "feature", "address", "lib", "ield", "dr", "server", "child", "store", "arg", "attribute", "class", "table", "cell", "term", "command", "list", "FIELD", "manager", "util", "tag", "range", "man", "prefix", "function", "flag", "pointer", "member", "comment", "local", "part", "relation", "add", "word", "module", "domain", "lc", "item", "node", "section", "var", "window", "level", "row", "param", "option", "rule", "display", "comp", "form", "fields", "spec", "entry", "mount", "def", "service", "value", "fe", "task", "line", "storage", "match", "key", "sim", "link", "job", "Field", "pair", "operator", "label"], "first_elem": ["first_elelements", "first_belem", "first_nelem", "first_seom", "first_beld", "first_elelement", "first_neep", "first_nelements", "first_eelem", "first_Elem", "first_beom", "first_Ele", "first_eld", "first_eleld", "first_elementlems", "first_belems", "first_eleom", "first_Eep", "first_elelem", "first_elementlement", "first_eep", "first_eele", "first_seld", "first_elelems", "first_elements", "first_selement", "first_nele", "first_elems", "first_belements", "first_eeep", "first_eelements", "first_ele", "first_Elements", "first_elementlem", "first_eom", "first_elementlements", "first_belement", "first_element", "first_selem"], "i": ["m", "ci", "p", "o", "z", "si", "n", "y", "it", "xi", "l", "mi", "b", "c", "r", "j", "t", "set", "phi", "li", "ip", "e", "ii", "x", "pi", "I", "io", "v"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n\n                          int128_get64(section->size));\n\n}\n", "idx": 21348, "substitutes": {"listener": ["listcaster", "listeners", "wardcaster", "parentening", "listency", "leners", "openers", "lister", "wardency", "listening", "Listency", "parentender", "lener", "lening", "broadener", "listender", "Listener", "parentener", "warder", "wardener", "Lister", "lender", "parenteners", "broader", "opender", "Listcaster", "broadcaster", "opening", "broadency", "opener"], "section": ["sections", "description", "ment", "mod", "entry", "setting", "word", "division", "tag", "journal", "definition", "component", "region", "prefix", "address", "storage", "header", "config", "version", "directory", "format", "size", "area", "sect", "page", "member", "session", "desc", "comment", "job", "event", "sec", "sector", "piece", "option", "portion", "connection", "Section", "part", "pair", "block", "table", "cell"], "state": ["check", "list", "cor", "start", "State", "bar", "parent", "type", "port", "up", "tag", "states", "test", " region", "status", "dict", "init", "info", "root", "lock", " State", "config", "STATE", " states", "city", "map", "area", "al", "store", "next", "instance", "row", "local", "rule", "monitor", "runner", "private", "stat", "is"]}}
{"project": "FFmpeg", "commit_id": "d59591fb02c29b41e5b8d611160971a4493394c2", "target": 1, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 4;\n\n                                else\n\n                                    s->repeat_pict = 2;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}", "idx": 21374, "substitutes": {"s": ["ctx", "js", "gs", "m", "spec", "ssl", "so", "ls", "q", "p", "sq", "es", "sp", "rs", "bs", "w", "sb", "vs", "service", "ps", "n", "sc", "fs", "ds", "self", "b", "sac", "c", "cs", "r", "as", "sw", "ts", "ses", "ss", "i", "stats", "t", "aws", "less", "ans", "set", "g", "ns", "ins", "hs", "a", "e", "sts", "sv", "h", "ats", "sg", "os", "sys", "S", "f", "v"], "avctx": [" avcfg", "afctl", "auxcfg", "avcb", " avctl", "AVctl", "auxcu", "abctx", " avcontext", "avercontext", " avjp", "afconfig", "avcmp", "auxctx", "averctx", "avecv", "avconfig", "abtx", "avobj", "avepid", "AVconfig", "cvobj", "avercb", " avcb", "afcontext", "avecontext", "ovctx", " avcu", "avcu", "wavcmp", "abcontext", "avecb", "cvcontext", "wavctx", "averpid", "avecmp", "avcfg", "avetx", " avobj", "avpid", "avectx", "afctx", "ovcfg", "avcontext", " avpid", "avcv", " avcmp", "ovcu", "afjp", " avcv", "AVctx", "wavtx", "avecu", "avctl", "ovcontext", "AVcu", " avtx", "abobj", "avjp", "avectl", "auxcontext", "cvtx", "cvctx", "aveconfig", "avtx", "avejp", "AVcontext", "wavcv"], "buf": ["pkg", "pack", "end", "np", "grad", "bs", "cast", "bin", "tmp", "eng", "prop", "rb", "foo", "pb", "vec", "cam", "bf", "arr", "queue", "aka", "words", "block", "cb", "cv", "ctx", "cp", "bed", "uf", "list", "data", "nb", "box", "paste", "padding", "xff", "wb", "bp", "cache", "b", "doc", "buff", "iter", "uv", "img", "pos", "loop", "bh", "args", "Buff", "read", "desc", "len", "emb", "ctr", "conv", "fb", "sofar", "ff", "seq", "length", "port", "ptr", "br", "orig", "lim", "proc", "history", "raw", "deg", "act", "bl", "msg", "txt", "boxes", "window", "next", "str", "batch", "err", "alloc", "cap", "pool", "bo", "bc", "mat", "nm", "def", "Buffer", "src", "bytes", "que", "true", "cmd", "go", "func", "burst", "db", "buffer", "bg", "ref", "off", "late", "mem", "pg"], "buf_size": ["queue_start", " buf_speed", "queue_length", "buf_speed", "buf_space", "buf_length", "buf_start", "buf7area", "queue_space", "buf7size", "buf7speed", "buf_area", "queue_size", " buf_area"], "pc": ["ctx", "cp", "ac", "gc", " cs", "tp", "p", "vc", "ca", "soc", "pp", "pr", "td", "bc", "pm", "xc", "tc", "anc", "pd", "pan", "sc", "disc", "mc", "cc", "iac", "icc", "py", "cl", "mp", "proc", "c", "cs", "fc", "wp", "acl", "lc", "asc", "sync", "vp", "psc", "ec", "pt", "func", "pro", "pa", "dc", "amp", "pb", "PC", "cam", "pac", "cu", "conv", "pic", "lp", "pi", "rc", "px", "cmp", "peer", "cv", "ct"], "buf_end": [" buf_ended", " buf1ends", "buffer_ends", "uf_ends", "uf_max", " buf_ends", " buf1ended", " buf_End", "buf8length", "bufjstart", "uf_end", "uf_start", "buf_max", "bufjend", "buf_start", "buf1ends", "buf_ending", "buf8start", "buf1end", "buf_ended", "buf_length", "buf8end", "buf1start", "buf1ended", "buf_End", "uf_stop", "buffer_end", "bufjlength", "bufjends", "uf_length", "buffer_length", " buf1start", " buf_start", " buf_ending", " buf1end", "buffer_start", "buf_stop", "buf_ends", "buf8stop"], "start_code": ["end_type", "start_cue", "startlytype", "startPstart", " start_type", " start_Code", "start00Code", "start00error", " start_start", "startCcode", "startCclass", "startlyCode", "startPCode", " start_value", "startlycode", "start00cue", "startedcode", "startPcode", "start_start", "end_cue", "start00code", "startlyvalue", "end_Code", "startPno", "startedclass", "startCCode", "startedCode", "start_value", "start_no", "start_class", " start_no", "start_type", "startedtype", "end_error", "start_Code", "end_class", "startCtype", "end_code", "start_error"], "frame_rate_index": ["frame_rate_Index", "frame_rate____Index", "frame_rates_ind", "frame_range_index", "frame_rate_sequence", "frame_rate_ind", "frame_rat_find", "frame_length_image", "frame_rat_index", "frame_rates_number", "frame_length_index", "frame_rate_image", "frame_range_sequence", "frame_rat_Index", "frame_length_Index", "frame_rate_find", "frame_rate____index", "frame_rates_Index", "frame_range_number", "frame_rate____interface", "frame_rat_interface", "frame_rate____find", "frame_rate_interface", "frame_length_offset", "frame_range_ind", "frame_rates_index", "frame_rate_offset", "frame_rate_number"], "ext_type": ["ext_types", "exturedescription", "exturemethod", "xt_method", "xt_type", "xt_types", "xt_description", "ext_description", "exturetypes", "ext_method", "exturetype"], "bytes_left": ["videos_Left", "terms1left", "videos10lf", "bytes_right", "terms1limit", "bytes_cost", "bytes_last", "bytesJlt", " bytesPleft", "bytesPleft", "bits_right", " bytesPlength", "videos10Left", "terms_lo", " bytesPcost", "bytesswlimit", "bytes10lt", "terms_left", "bytes_lo", "videos10left", "bytesPcost", " bytes_right", " bytes_cost", "bytes10Left", "bytes_Left", "bits_left", "bytesPlength", "bytes_limit", "terms1last", "bytes1left", "bytes10left", "bytesswleft", " bytesPright", "terms_limit", "bytes1limit", "bytes_length", "bytes1lo", "terms1lo", "bytes_lf", "bytesJlf", "videos_left", "bytesPright", "bytesswlo", "videos_lt", "bytes10lf", " bytes_length", "bytesJLeft", "terms_last", "bytes1last", "bytesJleft", "bytes_lt", "videos10lt", "bits_Left", "bytesswlast", "videos_lf"], "frame_rate_ext_n": ["frame_rate_ex_num", "frame_rate_ex_N", "frame_rate_ext_i", "frame_rate_ext2i", "frame_rate_ext_N", "frame_rate_ext2n", "frame_rate_ext_num", "frame_rate_ex_n", "frame_rate_ext2N", "frame_rate_ext2num", "frame_rate_ex_i"], "frame_rate_ext_d": ["frame_rate_ex_d", "frame_rate_ex_t", "frame_rate_ext_t", "frame_rate_ex_dim", "frame_rate_ex_n", "frame_rate_ext_dim"], "picture_structure": ["picture_stage", "picture_structage", "picture_restype", "picture_construction", "picture_constructure", "picture_constype", "picture_structype", "picture_restruction", "picture_structructure", "picture_restructure", "picture_stype", "picture_structruction", "picture_struction", "picture_restage", "picture_constage"], "top_field_first": ["top_fields_def", "top_field_def", "top_field_last", "top_fields_first", "top_field_part", "top_fields_last", "top_fields_part"], "repeat_first_field": ["repeat_top_fields", "repeat_first_key", "repeat_first_frame", "repeat_firstlyfield", "repeat_firstlyframe", "repeat_first_fields", "repeat_top_field", "repeat_firstlykey", "repeat_firstlyfields", "repeat_top_frame", "repeat_top_key"], "progressive_frame": ["proleadfulfeature", "progressive2feature", "prolead_picture", "proleadfulframes", "progressivefulfeature", "progressivefulframes", "progressive_picture", "progressive_feature", "progressive2picture", "proleadfulframe", "progressivefulpicture", "prolead_frames", "progressive2frames", "prolead_feature", "progressive2frame", "proleadfulpicture", "progressive_frames", "prolead_frame", "progressivefulframe"], "horiz_size_ext": ["horiz_size2ext", "horiz_space_external", "horiz_size_extra", "horiz_size2external", "horiz_size2extra", "horiz_size_ex", "horiz_space_ex", "horiz_space_ext", "horiz_space_extra", "horiz_size_external", "horiz_size2ex"], "vert_size_ext": ["vert_size_ex", "vert_size1extra", "vert_size1ex", "vert_size_xt", "vert_size1ext", "vert_size_extra", "vert_size1xt"], "bit_rate_ext": ["bit_rates_max", "bit_rate2max", "bit_rate_extra", "bit_rate2ext", "bit_rates_extra", "bit_rate_exp", "bit_rates_ext", "bit_rate2exp", "bit_rate_max", "bit_rates_exp", "bit_rate2extra"]}}
{"project": "qemu", "commit_id": "5efed5a172881f601ac3c57c22ec5c5721f895be", "target": 1, "func": "static void test_smbios_ep_address(test_data *data)\n\n{\n\n    uint32_t off;\n\n\n\n    /* find smbios entry point structure */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10) {\n\n        uint8_t sig[] = \"_SM_\";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"_SM_\", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n    data->smbios_ep_addr = off;\n\n}\n", "idx": 21383, "substitutes": {"data": ["action", "ta", "dev", "list", "done", "num", "dat", "p", "o", "parent", "state", "image", "d", "def", "mu", "master", "cache", "bus", "test", "aw", "info", "da", "db", "message", "msg", "reader", "device", "session", "window", "group", "writer", "buf", "next", "DATA", "ata", "batch", "rel", "block", "Data", "table", "val"], "off": ["eff", "end", "full", "track", "on", "ext", "aff", "info", "front", "ok", "ut", "pt", "set", "offs", "buf", "head", "after", "op", "of", "command", "o", "it", "shift", "att", "fun", "pos", "en", "read", "ap", "ent", "art", "over", "un", "dev", "ff", "pad", "push", "along", "offset", "load", "raw", "ord", "point", "from", "open", "oa", "window", "Off", "obj", "pres", "then", "OFF", "wo", "old", "start", "def", "offer", "hand", "j", "cmd", "ef", "t", "det", "ref", "out", "now", "handle", "zero", "before", "index", "new"], "sig": [" sif", "jsIG", "spet", "specigma", "nig", " sigh", "spig", "sigh", "sess", "gsigs", "nign", " sigma", "spign", "sigs", "sert", "gsign", "psigs", "sigma", "nif", " sign", "jsigma", "psigma", "ssigma", "specigs", " sigs", " sess", " set", "spif", "sature", "net", "set", "sIG", "gsess", "psig", "psature", "jsigh", "specig", "ssig", "specert", " sert", "sign", "gsig", " sIG", "sif", "ssigs", "ssature", "specature", "jsig"], "i": ["hi", "m", "me", " ti", "ci", "ix", "q", "uri", "p", "o", "v", "z", "id", "si", "multi", "zi", "port", "ei", "n", "y", "it", "xi", "init", "l", "ti", "mi", "ms", "gu", "iu", "qi", "b", "s", "u", "j", "iter", "di", "\u0438", "ai", "t", "ie", "k", " ii", " I", "ui", "gi", "phi", "li", "ic", "fi", " j", "ip", "sim", "ri", "ini", "bi", "ind", "e", "oi", "ii", "x", "pi", "I", " ni", "io", "is", "im"]}}
{"project": "FFmpeg", "commit_id": "d59bfcd11229300182c672ca734568919a85f773", "target": 1, "func": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n", "idx": 21385, "substitutes": {"sc": ["ctx", "ac", "gc", "cr", "sl", "ci", "sp", "isc", "bc", "cms", "Sc", "esc", "tc", "anc", "nc", "cc", "acs", "cl", "scl", "ocr", "sh", "c", "cs", "asc", "acl", "irc", "lc", "SC", "ss", "ec", "psc", "uc", "comm", "pc", "sch", "dc", "sec", "usc", "ch", "context", "osc", "cmp", "arc", "rc", "ct"], "duration": ["relation", "description", "frequency", "direction", "start", "translation", "length", "distance", "database", "span", "d", "lag", "quarter", "padding", "value", "resolution", "future", "Duration", "amount", "component", "minimum", "gravity", "uration", "seconds", "application", "delay", "date", "relative", "video", "timeout", " Duration", "document", "message", "until", "during", "window", "len", "number", "after", "time", "record", "portion", "period", "sequence", "foundation", "latest", "century"]}}
{"project": "FFmpeg", "commit_id": "1197c04896423c6c7db65f69da8bc3865b26bb50", "target": 1, "func": "static void fft_calc_c(FFTContext *s, FFTComplex *z) {\n\n\n\n    int nbits, i, n, num_transforms, offset, step;\n\n    int n4, n2, n34;\n\n    FFTSample tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;\n\n    FFTComplex *tmpz;\n\n    const int fft_size = (1 << s->nbits);\n\n    int64_t accu;\n\n\n\n    num_transforms = (0x2aab >> (16 - s->nbits)) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 2;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[0].re + tmpz[1].re;\n\n        tmp5 = tmpz[2].re + tmpz[3].re;\n\n        tmp2 = tmpz[0].im + tmpz[1].im;\n\n        tmp6 = tmpz[2].im + tmpz[3].im;\n\n        tmp3 = tmpz[0].re - tmpz[1].re;\n\n        tmp8 = tmpz[2].im - tmpz[3].im;\n\n        tmp4 = tmpz[0].im - tmpz[1].im;\n\n        tmp7 = tmpz[2].re - tmpz[3].re;\n\n\n\n        tmpz[0].re = tmp1 + tmp5;\n\n        tmpz[2].re = tmp1 - tmp5;\n\n        tmpz[0].im = tmp2 + tmp6;\n\n        tmpz[2].im = tmp2 - tmp6;\n\n        tmpz[1].re = tmp3 + tmp8;\n\n        tmpz[3].re = tmp3 - tmp8;\n\n        tmpz[1].im = tmp4 - tmp7;\n\n        tmpz[3].im = tmp4 + tmp7;\n\n    }\n\n\n\n    if (fft_size < 8)\n\n        return;\n\n\n\n    num_transforms = (num_transforms >> 1) | 1;\n\n\n\n    for (n=0; n<num_transforms; n++){\n\n        offset = ff_fft_offsets_lut[n] << 3;\n\n        tmpz = z + offset;\n\n\n\n        tmp1 = tmpz[4].re + tmpz[5].re;\n\n        tmp3 = tmpz[6].re + tmpz[7].re;\n\n        tmp2 = tmpz[4].im + tmpz[5].im;\n\n        tmp4 = tmpz[6].im + tmpz[7].im;\n\n        tmp5 = tmp1 + tmp3;\n\n        tmp7 = tmp1 - tmp3;\n\n        tmp6 = tmp2 + tmp4;\n\n        tmp8 = tmp2 - tmp4;\n\n\n\n        tmp1 = tmpz[4].re - tmpz[5].re;\n\n        tmp2 = tmpz[4].im - tmpz[5].im;\n\n        tmp3 = tmpz[6].re - tmpz[7].re;\n\n        tmp4 = tmpz[6].im - tmpz[7].im;\n\n\n\n        tmpz[4].re = tmpz[0].re - tmp5;\n\n        tmpz[0].re = tmpz[0].re + tmp5;\n\n        tmpz[4].im = tmpz[0].im - tmp6;\n\n        tmpz[0].im = tmpz[0].im + tmp6;\n\n        tmpz[6].re = tmpz[2].re - tmp8;\n\n        tmpz[2].re = tmpz[2].re + tmp8;\n\n        tmpz[6].im = tmpz[2].im + tmp7;\n\n        tmpz[2].im = tmpz[2].im - tmp7;\n\n\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp1 + tmp2);\n\n        tmp5 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 - tmp4);\n\n        tmp7 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp2 - tmp1);\n\n        tmp6 = (int32_t)((accu + 0x40000000) >> 31);\n\n        accu = (int64_t)Q31(M_SQRT1_2)*(tmp3 + tmp4);\n\n        tmp8 = (int32_t)((accu + 0x40000000) >> 31);\n\n        tmp1 = tmp5 + tmp7;\n\n        tmp3 = tmp5 - tmp7;\n\n        tmp2 = tmp6 + tmp8;\n\n        tmp4 = tmp6 - tmp8;\n\n\n\n        tmpz[5].re = tmpz[1].re - tmp1;\n\n        tmpz[1].re = tmpz[1].re + tmp1;\n\n        tmpz[5].im = tmpz[1].im - tmp2;\n\n        tmpz[1].im = tmpz[1].im + tmp2;\n\n        tmpz[7].re = tmpz[3].re - tmp4;\n\n        tmpz[3].re = tmpz[3].re + tmp4;\n\n        tmpz[7].im = tmpz[3].im + tmp3;\n\n        tmpz[3].im = tmpz[3].im - tmp3;\n\n    }\n\n\n\n    step = 1 << ((MAX_LOG2_NFFT-4) - 4);\n\n    n4 = 4;\n\n\n\n    for (nbits=4; nbits<=s->nbits; nbits++){\n\n        n2  = 2*n4;\n\n        n34 = 3*n4;\n\n        num_transforms = (num_transforms >> 1) | 1;\n\n\n\n        for (n=0; n<num_transforms; n++){\n\n            const FFTSample *w_re_ptr = ff_w_tab_sr + step;\n\n            const FFTSample *w_im_ptr = ff_w_tab_sr + MAX_FFT_SIZE/(4*16) - step;\n\n            offset = ff_fft_offsets_lut[n] << nbits;\n\n            tmpz = z + offset;\n\n\n\n            tmp5 = tmpz[ n2].re + tmpz[n34].re;\n\n            tmp1 = tmpz[ n2].re - tmpz[n34].re;\n\n            tmp6 = tmpz[ n2].im + tmpz[n34].im;\n\n            tmp2 = tmpz[ n2].im - tmpz[n34].im;\n\n\n\n            tmpz[ n2].re = tmpz[ 0].re - tmp5;\n\n            tmpz[  0].re = tmpz[ 0].re + tmp5;\n\n            tmpz[ n2].im = tmpz[ 0].im - tmp6;\n\n            tmpz[  0].im = tmpz[ 0].im + tmp6;\n\n            tmpz[n34].re = tmpz[n4].re - tmp2;\n\n            tmpz[ n4].re = tmpz[n4].re + tmp2;\n\n            tmpz[n34].im = tmpz[n4].im + tmp1;\n\n            tmpz[ n4].im = tmpz[n4].im - tmp1;\n\n\n\n            for (i=1; i<n4; i++){\n\n                FFTSample w_re = w_re_ptr[0];\n\n                FFTSample w_im = w_im_ptr[0];\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].re;\n\n                accu += (int64_t)w_im*tmpz[ n2+i].im;\n\n                tmp1 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[ n2+i].im;\n\n                accu -= (int64_t)w_im*tmpz[ n2+i].re;\n\n                tmp2 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].re;\n\n                accu -= (int64_t)w_im*tmpz[n34+i].im;\n\n                tmp3 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].im;\n\n                accu += (int64_t)w_im*tmpz[n34+i].re;\n\n                tmp4 = (int32_t)((accu + 0x40000000) >> 31);\n\n\n\n                tmp5 = tmp1 + tmp3;\n\n                tmp1 = tmp1 - tmp3;\n\n                tmp6 = tmp2 + tmp4;\n\n                tmp2 = tmp2 - tmp4;\n\n\n\n                tmpz[ n2+i].re = tmpz[   i].re - tmp5;\n\n                tmpz[    i].re = tmpz[   i].re + tmp5;\n\n                tmpz[ n2+i].im = tmpz[   i].im - tmp6;\n\n                tmpz[    i].im = tmpz[   i].im + tmp6;\n\n                tmpz[n34+i].re = tmpz[n4+i].re - tmp2;\n\n                tmpz[ n4+i].re = tmpz[n4+i].re + tmp2;\n\n                tmpz[n34+i].im = tmpz[n4+i].im + tmp1;\n\n                tmpz[ n4+i].im = tmpz[n4+i].im - tmp1;\n\n\n\n                w_re_ptr += step;\n\n                w_im_ptr -= step;\n\n            }\n\n        }\n\n        step >>= 1;\n\n        n4   <<= 1;\n\n    }\n\n}\n", "idx": 21386, "substitutes": {"s": ["js", "m", "gs", "q", "p", "sq", "es", "rs", "bs", "bits", "conf", "w", "sb", "fs", "ds", "self", "scl", "c", "cs", "r", "sw", "ts", "ses", "ss", "t", "g", "ns", "a", "hs", "e", "sts", "sv", "xs", "h", "sf", "ats", "os", "S", "space", "f"], "z": ["az", "m", "ez", "zip", "q", "zes", "p", "zh", "hz", "Z", "zi", "zer", "d", "zone", "zos", "iaz", "y", "cz", "zz", "b", "c", "storage", "j", "zy", "t", "gz", "g", "rez", "window", "out", "now", "zero", "tz", "nz", "yz", "x", "os", "uz", "zen", "f", "iz", "zo", "v", "ze"], "nbits": ["dints", "cnbytes", "nbytes", "cnwords", "Nbit", "nbit", "ncbits", "cnbits", "Nbs", "nbs", "dbs", "npoints", " nints", "mints", "ncpoints", "numbs", " nbytes", "nwords", "mbytes", " nwords", "dbytes", " npoints", "cnpoints", "numbits", "ncbytes", "numbit", "ncwords", "mbits", " nbit", "mbs", "Nbits", "nints", "dbits", " nbs"], "i": ["m", "ci", "ix", "p", "si", "it", "l", "ij", "b", "iu", "c", "j", "ai", "t", "k", "g", "ic", "ip", "bi", "index", "ii", "x", "pi", "I", "f", "v"], "n": ["name", "ln", "conn", "on", "N", "fn", "nt", "nu", "gn", "yn", "ng", "count", "ll", "ind", "x", "nr", "nw", "nb", "o", "mn", "ann", "nn", "rn", "l", "net", "k", "en", "pn", "local", "norm", "un", "v", "m", "num", "sn", "cn", "br", "nc", "init", "an", "r", "ren", "ni", "na", "network", "g", "names", "al", "note", "el", "hn", "batch", "wn", "p", "span", "y", "nor", "c", "no", "j", "t", "dn", "ns", "ul", "out", "number", "nan", "index", "new", "ex", "ne"], "num_transforms": ["num_transform", "num_translations", "num_interforms", "num_timesposes", "num_subfixes", "num_subitions", "num_surform", "num_inputlations", "num2transposes", "num_timesmissions", "num_inputmissions", "num_surforms", "num_ransfixes", "num_Transitions", "num_Transactions", "num_interits", "num2transforms", "num2inputmissions", "num2inputforms", "num_inputforms", "num_transits", "num_Transposes", "num_Transforms", "num_renditions", "num_timesforms", "num_ransits", "num_Transfixes", "num_ransforms", "num_rendforms", "num_rendmaps", "num_transfixes", "num_ransmissions", "num_ransactions", "num_transmaps", "num_Transform", "num_surmissions", "num2translations", "num_intermissions", "num2inputlations", "num_interactions", "num_Transmaps", "num2inputposes", "num_interlations", "num_ransform", "num_Transits", "num_inputposes", "num_ranslations", "num_Transmissions", "num2transmissions", "num_transitions", "num_submissions", "num_ransitions", "num_surposes", "num_subforms", "num_transactions", "num_transmissions", "num_timeslations", "num_Translations", "num_ransmaps", "num_ransposes", "num_rendmissions", "num_transposes"], "offset": ["ocation", "reset", "end", "frequency", "start", "o", "transform", "alias", "entry", "pad", "slot", "seed", "length", "ot", "adjusted", "debug", "padding", "order", "block", "scroll", "force", "original", "shift", "init", "Offset", "style", "lock", "address", "delay", "location", "origin", "ut", "pointer", "timeout", "pos", "point", "size", "onet", "set", "error", "extra", "print", "skip", "encrypted", "initial", "position", "et", "hop", "align", "link", "window", "off", "operation", "office", "angle", "index", "attribute", "stop", "seek"], "step": ["height", "steps", "data", "start", "power", "ffff", "scale", "shift", "chain", "load", "delay", "loop", "shape", "set", "error", "skip", "wait", "window", "snap", "Step", "stop", "batch", "weight", "dim", "save", "sd", "sleep"], "n4": ["x1", "max4", "n3", "x6", "N6", "N4", "N1", "N3", "n1", "x3", "max6", "n6", "max3", "max1", "x4"], "n2": [" n3", "N02", "note25", "n3", "N25", "N3", " n02", "note02", "n25", " n25", "note2", "note3", "n02", "N2"], "n34": [" n3", "N23", "n3", "N35", " n03", " n23", "N3", "n23", "int3", "n35", "n03", "int23", "int35", "int03", "N03", " n35"], "tmp1": ["mp2", "perm3", " tmp01", "tmpf", "tcf", "mpxy", "temp2", "tmp01", "tcxy", "prop1", "cmp5", " tmpxy", "perm5", "temp1", "tc_", "prop2", "perm01", "cmp2", "mp1", "tmpxy", "mp5", "cmp01", "pot1", "perm2", " tmpf", "cmp1", "mp3", "perm1", "pot3", " tmp_", "temp01", "mpf", "mp01", "cmp3", "tmp_", "prop3", "temp3", "pot2", "mp_"], "tmp2": ["mp2", "txt2", "table4", "buff02", "txt4", "buff5", "tmpTwo", "mpTwo", "temp2", "txt3", "obj4", "buffTwo", "timeout02", "tmp02", "temp1", "temp02", "timeout3", "cache1", "mp1", "mp5", "table2", "cache2", "txt5", "mp4", "tempTwo", "mp3", "mp02", "timeout2", "buff2", "timeout4", "table3", "obj2", "obj3", "temp5", "cache02", "table02", "obj5"], "tmp3": ["mp83", "tempThree", "pkg1", "tmpThree", "temp03", "prop1", "tmp83", "td3", "tmpCommand", "td5", "mp7", "pkgCommand", "tmp103", "timeout83", "cache5", "timeout3", "cache4", "timeout1", "timeout5", "mp1", "cache3", "mp5", "prop6", "tmp03", "rep103", "mp4", "mp03", "cache7", "mp3", "pkg3", "pkg83", "mpThree", "prop103", "rep6", "mp6", "prop3", "tdThree", "timeout4", "temp3", "rep1", "mp103", "timeoutCommand", "temp5", "mpCommand", "td03", "timeout7", "rep3"], "tmp4": ["mp2", "obj6", "tmp42", "temp2", " tmp42", "temp4", "obj4", " tmp44", "temp44", "temp42", "tt5", "cache4", "obj44", "mp5", "cache2", "proc4", "tmp44", "tt44", "mp4", "cache6", "proc6", "tt4", "mp6", "tt6", "obj2", "mp42", "proc5", "mp44", "proc44"], "tmp5": [" tmpFive", "tmp45", "table4", "obj6", "cmd6", "time5", "time4", "top5", "cmp5", "app4", "table6", "time6", "table5", "cmd5", "cmd1", "mp45", "cache5", "cmp45", "cache1", "cache4", "cmpFive", " tmp45", "mp1", "time1", "mp5", "table2", "app5", "top6", "app6", "mp4", "cache6", "obj1", "mp6", "tmpFive", "top2", "app2", "top4", "mpFive", "obj5"], "tmp6": ["td8", "pot6", "tmpSix", "pot8", "cache8", "pot72", "cmp5", "pkg8", "td4", "mp68", "td5", "cmp6", "temp8", "tmp72", "cache5", "cmp8", "td6", "cache4", "pkgSix", "mp5", "cmp68", "mp8", "temp6", "mp4", "cmp96", "cache6", "pkg6", "tmp68", "pot96", "pkg72", "mp6", "mpSix", "cmp72", " tmp68", "pkg96", "tempSix", "temp5", "tmp96", "pkg5"], "tmp7": ["tu7", "temp7", "cache8", "img7", "img5", "tu8", "tmp77", "test8", "temp77", "cmp5", "test7", "temp8", "tu77", "cmp6", "mp7", "img8", "img4", "timeout6", "cache5", "cmp8", "timeout3", "cache4", "timeout5", "mp5", "mp8", "temp6", "cmp77", "mp4", "cache7", "cache6", "cmp3", "tu5", "mp6", "temp3", "test4", "temp5", "cmp7", "test6", "timeout7"], "tmp8": ["td8", "html7", "tmp9", "html15", "tmp15", "temp08", " tmpail", "tar2", "cp7", "temp2", "temp9", "td15", "temp80", "mp80", " tmp08", "temp8", "tmpail", "tmp08", "proc8", "mp7", "cmp6", "html8", "tar08", "tempail", "html6", "cmp8", "td6", "mp15", "proc9", "tar8", "mp9", "tmp80", "tarail", "mp8", "temp6", "proc80", "proc6", "mp6", "cp8", "cp6", "cmp7", "td7"], "tmpz": ["tpz", "tpld", "buffzes", "trapzip", "tclike", "pkgiz", "nbzh", "appyzer", "jsonstr", "tempy", "propzes", "buffld", "cvz", "timeoutoz", "nbze", "mpld", "tempyz", "applike", "appiz", "imgz", "ttzi", "tarj", "tczi", "xxxstr", "cmdoz", "qqzh", "tpyz", "cvze", "jsonzh", "dumpzh", "prefixz", "potzi", "buffll", "tptry", "tpzone", "tabiz", "nodey", "tpzes", "tabz", "tpzip", "qqze", "pkgzer", "tmpyz", "ttstr", "tempzer", "imgzes", "prefixgz", "timeoutgz", "tmpzz", "tdz", "potzip", "trapz", " tmpjs", "tciz", "timeoutld", "appytry", "nodecz", "appystr", "tuoz", "mpzer", "mpj", "dumpz", "tempjs", "tarzes", "timeoutzes", "tmpls", "soclog", "tparr", "cptry", "mpzh", "potz", "cmpzh", "tarzer", "propz", "tmpzi", "tpzi", "tpls", "propzi", "imgtry", "mpze", "cmdz", "appyzes", "pkggz", "timeoutstr", "timeoutiz", "qqzip", "cmdzer", "exprz", "tpstr", " tmpl", "cvzip", "templd", "tmplog", "tnj", "cpz", "tartry", "cmpzone", "tczh", "tpzer", "cmpz", "tczes", "pkgld", "tcz", "trapzes", "prefixzi", "tfze", "tempcz", "cmdtry", "appzer", "tmpiz", "ppozer", "tmpzone", "potarr", "soczes", "tpjs", "tmpstr", "sociz", "pkgoz", "tpl", "tmpzh", "buffzh", "tpgz", "dumpl", "tmpld", "mpstr", "exprzz", "tabzes", "cmpze", "tmpzip", "imgzer", "tempiz", "pkgzes", "tustr", "ppotry", "cmdiz", "pkgzh", "tmpzes", "timeoutzer", "tuzes", "tfzi", "appylike", "tempzh", "tmpjs", "timeoutzi", "xxxze", "tmpcz", "tablog", "nodezi", "timeoutz", "tmpzer", "tdzone", "tmpj", "buffarr", " tmpls", "potld", "tuzip", "buffze", "dumptry", "tfz", "permld", "timeoutzh", "prefixzip", "tmptry", "ttll", "tnze", "tmparr", "appyzh", "cmpzi", "tempzi", "socz", "tnz", "etczone", "nodez", "tmpll", "cmdzip", "tmpoz", "nbz", "pkgz", "templl", "cmpgz", "pkgzip", "pkgzi", "timeoutzone", "expriz", "ttz", "tmpy", "tczer", "buffoz", "templike", "tpze", " tmptry", "tmpze", "cpl", "tarzip", " tmpzi", " tmpy", "cpls", "taroz", "ppoz", "temparr", "mpz", "propzip", "tnld", " tmparr", "tmpgz", "cvzh", "pkgzone", "timeoutll", "tuj", "tplike", "tempzone", "tnzer", "etcll", "etczi", "tntry", "xxxz", "tdlike", "cmdzi", "tmpl", "tplog", "ppoj", "tuz", "buffzi", "buffzip", "etcz", "permzi", "permzh", "permz", "cmdzes", "mptry", "pkgll", "cmdzz", "tdld", "tpiz", "potgz", " tmpyz", "qqz", "tpll", "cmpld", "tpzh", " tmpcz", "xxxj", "appyz", "tmplike", "trapzi", "exprzi", "mpl", "nbzi", "jsonz", "tempzz", "appz", "pkglike", "tempz", "buffz", "tuze", "jsonlike", "tfzh", "tarz"], "accu": ["Acccu", "Accu", "Accuum", "raccu", "accur", "racur", "Accur", "racuum", "acccu", "accuum", "acur", "racu", "acu", "acuum"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "int cpu_ppc_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n\n                             int mmu_idx)\n\n{\n\n    mmu_ctx_t ctx;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n    if (rw == 2) {\n\n        /* code access */\n\n        rw = 0;\n\n        access_type = ACCESS_CODE;\n\n    } else {\n\n        /* data access */\n\n        access_type = env->access_type;\n\n    }\n\n    ret = get_physical_address(env, &ctx, address, rw, access_type);\n\n    if (ret == 0) {\n\n        tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0) {\n\n        LOG_MMU_STATE(env);\n\n        if (access_type == ACCESS_CODE) {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    env->error_code = 1 << 18;\n\n                    env->spr[SPR_IMISS] = address;\n\n                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;\n\n                    goto tlb_miss;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    env->exception_index = POWERPC_EXCP_IFTLB;\n\n                    goto tlb_miss_74xx;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    env->error_code = 0x40000000;\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_ITLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    return -1;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x08000000;\n\n                break;\n\n            case -3:\n\n                /* No execute protection violation */\n\n                if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                    (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_ESR] = 0x00000000;\n\n                }\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                env->exception_index = POWERPC_EXCP_ISI;\n\n                env->error_code = 0x10000000;\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_ISI;\n\n                    /* XXX: this might be incorrect */\n\n                    env->error_code = 0x40000000;\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_ISEG;\n\n                    env->error_code = 0;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        } else {\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables or TLB */\n\n                switch (env->mmu_model) {\n\n                case POWERPC_MMU_SOFT_6xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                        env->error_code = 1 << 16;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                        env->error_code = 0;\n\n                    }\n\n                    env->spr[SPR_DMISS] = address;\n\n                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;\n\n                tlb_miss:\n\n                    env->error_code |= ctx.key << 19;\n\n                    env->spr[SPR_HASH1] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[0], HASH_PTE_SIZE_32);\n\n                    env->spr[SPR_HASH2] = env->htab_base +\n\n                        get_pteg_offset(env, ctx.hash[1], HASH_PTE_SIZE_32);\n\n                    break;\n\n                case POWERPC_MMU_SOFT_74xx:\n\n                    if (rw == 1) {\n\n                        env->exception_index = POWERPC_EXCP_DSTLB;\n\n                    } else {\n\n                        env->exception_index = POWERPC_EXCP_DLTLB;\n\n                    }\n\n                tlb_miss_74xx:\n\n                    /* Implement LRU algorithm */\n\n                    env->error_code = ctx.key << 19;\n\n                    env->spr[SPR_TLBMISS] = (address & ~((target_ulong)0x3)) |\n\n                        ((env->last_way + 1) & (env->nb_ways - 1));\n\n                    env->spr[SPR_PTEHI] = 0x80000000 | ctx.ptem;\n\n                    break;\n\n                case POWERPC_MMU_SOFT_4xx:\n\n                case POWERPC_MMU_SOFT_4xx_Z:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] = 0x00800000;\n\n                    } else {\n\n                        env->spr[SPR_40x_ESR] = 0x00000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_32B:\n\n                case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n                case POWERPC_MMU_620:\n\n                case POWERPC_MMU_64B:\n\n                case POWERPC_MMU_2_06:\n\n\n#endif\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                    break;\n\n                case POWERPC_MMU_MPC8xx:\n\n                    /* XXX: TODO */\n\n                    cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n                    break;\n\n                case POWERPC_MMU_BOOKE206:\n\n                    booke206_update_mas_tlb_miss(env, address, rw);\n\n                    /* fall through */\n\n                case POWERPC_MMU_BOOKE:\n\n                    env->exception_index = POWERPC_EXCP_DTLB;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                    return -1;\n\n                case POWERPC_MMU_REAL:\n\n                    cpu_abort(env, \"PowerPC in real mode should never raise \"\n\n                              \"any MMU exceptions\\n\");\n\n                    return -1;\n\n                default:\n\n                    cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n                    return -1;\n\n                }\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                env->exception_index = POWERPC_EXCP_DSI;\n\n                env->error_code = 0;\n\n                if (env->mmu_model == POWERPC_MMU_SOFT_4xx\n\n                    || env->mmu_model == POWERPC_MMU_SOFT_4xx_Z) {\n\n                    env->spr[SPR_40x_DEAR] = address;\n\n                    if (rw) {\n\n                        env->spr[SPR_40x_ESR] |= 0x00800000;\n\n                    }\n\n                } else if ((env->mmu_model == POWERPC_MMU_BOOKE) ||\n\n                           (env->mmu_model == POWERPC_MMU_BOOKE206)) {\n\n                    env->spr[SPR_BOOKE_DEAR] = address;\n\n                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;\n\n                } else {\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x0A000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x08000000;\n\n                    }\n\n                }\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    env->exception_index = POWERPC_EXCP_ALIGN;\n\n                    env->error_code = POWERPC_EXCP_ALIGN_FP;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or stwcx. */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    /* XXX: this might be incorrect */\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_DSEG;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 21387, "substitutes": {"env": ["equ", "end", "viron", "ve", "conf", "esm", "editor", "eng", "conn", "environment", "info", "worker", "eh", "org", "server", "set", "et", "buf", "hw", "gear", "erd", "cb", "cv", "vt", "eni", "manager", "vs", "den", "vm", "enter", "dt", "era", "doc", "config", "ec", "ener", "net", "en", "ew", "desc", "eas", "v", "dev", "te", "ev", "here", "req", "engine", "console", "init", "er", "kw", "network", "msg", "outer", "window", "answer", "obj", "estate", "eg", "inv", "entry", "ter", "esc", "ah", "vp", "query", "cmd", "ef", "db", "ner", "nv", "event", "actor", "e", "context", "addr", "operator", "Environment"], "address": ["command", "description", "add", "Address", "adr", "alias", "memory", "entry", "word", "port", "password", "path", "ptr", "ace", "ash", "request", "range", "value", "service", "offset", "region", "holder", "result", "prefix", "r", "array", "location", "host", "order", "point", "server", "pointer", "shape", "network", "message", "argument", "phrase", "dress", "page", "ip", " Address", "route", "number", "event", "a", "handle", "e", "ress", "context", "record", "reference", "interface", "attribute", "index", "resource", "addr", "object", "block", "email"], "rw": ["wn", "nw", "RW", "write", "nb", "rs", "iw", "word", "rans", "w", "ptr", "rew", "wb", "wa", "offset", "aw", "rss", "rh", "wp", "rt", "wer", "wind", "r", "ow", "sw", "wd", "kw", "aux", "wr", "rb", "rf", "ng", "ew", "ru", "buf", "window", "row", "usr", "nz", "dq", "rd", "rid", "hw", "wx", "nr"], "mmu_idx": ["mmu_Idz", "mmu_midnt", "mmu_IDy", "mmu_Idx", "mmu_midz", "mmu_midX", "mmu_IDxf", "mmu_idX", "mmu_idnt", "mmu_midy", "mmu_Idy", "mmu_idy", "mmu_idz", "mmu_IDx", "mmu_idxf", "mmu_IdX", "mmu_Idxf", "mmu_IDnt", "mmu_midxf", "mmu_midx", "mmu_Idnt"], "ctx": ["cfg", "pkg", "cp", "kh", "ca", "np", "qt", "handler", "bc", "conf", "loc", "kt", "ctrl", "tmp", "xc", "ptr", "tc", "anc", "conn", "sc", "mc", "cc", "Context", "vm", "nc", "self", "co", "rt", "history", "aux", "kw", "tx", "config", "tk", "scope", "cmd", "nt", "act", "cas", "jac", "txt", "dc", "except", "cur", "handle", "obj", "context", "conv", "tz", "xs", "addr", "hw", " context", "alloc", "wx", "cmp", "ctl", "cv", "ct"], "access_type": ["actionureType", "access_ty", "press_type", "accessetytag", "actionureype", "accessproty", "accessTypeype", " access_level", "press_length", "accessureype", "action_field", "accessprotype", "access_details", "accessetydetails", "accessTypeType", "accessedfield", "matchetytype", " access_types", "play_Type", "access_typ", "action_ype", "actionurefield", "access_Type", "accessedtype", "match_type", "accessTypetype", "play_type", "press_typ", "access_ype", "action_Type", "match_details", "accessuredetails", "access_types", " access_ty", "access_field", "accessuretype", "play_ty", " access_mode", "pressTypetyp", "accessurefield", "match_ty", "pressTypetype", "accessTypety", "access_length", "playprotype", "accessproype", "access_tag", "accessproType", "pressTypelength", "accessureType", "accessedType", "playproype", "accessetytype", "accessetyty", "accessurety", "actionuretype", "matchetydetails", "accessedype", "matchetyty", "playproType", "accessTypelength", "access_level", "play_ype", "playproty", "access_mode", "accessTypetyp", "matchetyType", "action_type", " access_tag", "match_Type", "accessetyType"]}}
{"project": "qemu", "commit_id": "bdd4df332a1bdb20b7fa39ea741f7830e41e1187", "target": 1, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 21392, "substitutes": {"ds": ["dos", "js", "gs", "ls", "eds", "ows", "rs", "bs", "ads", "d", "vs", "des", "ods", "ps", "icks", "dt", "fd", "fs", "ysis", "ims", "els", "hd", "dh", "s", "cs", "ts", "dis", "dll", "ss", "ys", "da", "di", "uds", "ded", "dm", "db", "dl", "ns", "dc", "dd", "ks", "hs", "dds", "DS", "sts", "qs", "os", "dq", "Ds", "sd", "df"]}}
{"project": "qemu", "commit_id": "f8a2e5e3ca6146d4cc66a4750daf44a0cf043319", "target": 0, "func": "static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                              int nb_sectors, int *pnum)\n\n{\n\n    uint64_t cluster_offset;\n\n    int ret;\n\n\n\n    *pnum = nb_sectors;\n\n    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't\n\n     * pass them on today */\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n    }\n\n\n\n    return (cluster_offset != 0);\n\n}\n", "idx": 21411, "substitutes": {"bs": ["js", "gs", "ls", "bb", "es", "bc", "ba", "blog", "sb", "vs", "bp", "bis", "fs", "ds", "b", "ms", "cs", "bm", "iss", "ts", "ss", "aos", "bh", "bl", "ubs", "BS", "ns", "ks", "its", "bps", "bi", "bf", "bos", "lbs", "bd", "bas", "bn"], "sector_num": ["sector2name", "ector_num", "sector_nm", "sector_loc", "sector_mon", "ector_number", "sector2mon", " sector_number", "ector_mon", " sector_loc", "sector2num", " sector_nm", "sector_number", "ector_name", "sector_name", "sector2number"], "nb_sectors": ["nb_pegments", "nb_segments", "nb_servgments", "nb_psectors", "nb_pemissions", "nb_servctors", "nb_servors", "nb_vegments", "nb_idectors", "nb_vectors", "nb_pseters", "nb_peors", "nb_ideters", "nb_ideors", "nb_pseors", "nb_seters", "nb_servmissions", "nb_psegments", "nb_idegments", "nb_vemissions", "nb_veors", "nb_semissions", "nb_seors", "nb_veters", "nb_pectors"], "pnum": ["gnum", "panum", "pnom", "pinumer", "penom", "panumer", "nnnum", "nnUM", "wnenum", "pnenum", "penumb", "penumer", "panom", "panumb", "pnnum", "pnumb", "nnum", "penUM", "wnUM", "pnumer", "penum", "gnumb", "pinum", "panummer", "pum", "gnenum", "pnummer", "penummer", "gnnum", "pinumb", "pennum", "pnUM", "gnom", "pinummer", "wnum", "wnnum", "pumb", "penenum", "nnenum", "panenum"], "cluster_offset": ["clusteristsize", "clusters_data", "clust_error", "clocation_index", "cluster_error", "clusters_Offset", "cluster__data", "clusteringindex", "clocationingindex", "clusterabilityOffset", "cluster__pos", "clusteringaddress", "cluster_option", "clocation_size", "cluster_address", "cluster_pos", "cluster_index", "clocationingsize", "clusteristaddress", "clusterabilityerror", "clocation_address", "clocationingoffset", "cluster_Offset", "cluster__Offset", "clusteringsize", "clust_offset", "clusteristoffset", "clusters_offset", "clocation_offset", "clusterabilityoption", "cluster__offset", "clusteringoffset", "clust_option", "clusteristindex", "clust_Offset", "cluster_data", "cluster_size", "clusterabilityoffset", "clusters_pos", "clocationingaddress"], "ret": ["reset", "cert", "alt", "ter", "tr", "Ret", "red", "rem", "inter", "result", " Ret", "fun", "rt", "ry", "r", "pret", "aux", "pat", "nt", "deg", "cmd", "print", "t", "ft", "det", "res", "reg", "lt", "txt", "et", "re", "back", "hash", "out", "arg", "rets", "gt", "arr", "ber", "tf", "err", "elt", "RET", "prot", "ert", "mt", "ne", "cont", "val"]}}
{"project": "qemu", "commit_id": "01fa55982692fb51a16049b63b571651a1053989", "target": 0, "func": "static void migrate_params_test_apply(MigrateSetParameters *params,\n\n                                      MigrationParameters *dest)\n\n{\n\n    *dest = migrate_get_current()->parameters;\n\n\n\n    /* TODO use QAPI_CLONE() instead of duplicating it inline */\n\n\n\n    if (params->has_compress_level) {\n\n        dest->compress_level = params->compress_level;\n\n    }\n\n\n\n    if (params->has_compress_threads) {\n\n        dest->compress_threads = params->compress_threads;\n\n    }\n\n\n\n    if (params->has_decompress_threads) {\n\n        dest->decompress_threads = params->decompress_threads;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_initial) {\n\n        dest->cpu_throttle_initial = params->cpu_throttle_initial;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_increment) {\n\n        dest->cpu_throttle_increment = params->cpu_throttle_increment;\n\n    }\n\n\n\n    if (params->has_tls_creds) {\n\n        dest->tls_creds = g_strdup(params->tls_creds);\n\n    }\n\n\n\n    if (params->has_tls_hostname) {\n\n        dest->tls_hostname = g_strdup(params->tls_hostname);\n\n    }\n\n\n\n    if (params->has_max_bandwidth) {\n\n        dest->max_bandwidth = params->max_bandwidth;\n\n    }\n\n\n\n    if (params->has_downtime_limit) {\n\n        dest->downtime_limit = params->downtime_limit;\n\n    }\n\n\n\n    if (params->has_x_checkpoint_delay) {\n\n        dest->x_checkpoint_delay = params->x_checkpoint_delay;\n\n    }\n\n\n\n    if (params->has_block_incremental) {\n\n        dest->block_incremental = params->block_incremental;\n\n    }\n\n}\n", "idx": 21413, "substitutes": {"params": ["pins", "pkg", "ctx", "gs", "roots", "assets", "spec", "photos", "mm", "p", "posts", "amps", "ams", "points", "details", "conf", "las", "modules", "pretty", "tags", "cms", "headers", "sql", "parents", "marks", "docs", "parts", "ps", "pps", "models", "types", "masters", "ims", "values", "users", "versions", "settings", "mas", "as", "terms", "config", "packages", "images", "units", "errors", "stats", "keys", "args", "shape", "chains", "phys", "relations", "members", "names", "changes", "actions", "makes", "plugins", "ports", "options", "param", "rpm", "fps", "properties", "words", "ops", "vals", "caps", "devices", "styles", "pers"], "dest": ["rest", "end", "transform", "conf", "bin", "tmp", "ver", "master", "copy", "prop", "test", "good", "chain", "attr", "decl", "gen", "origin", "server", "nom", "output", "other", "resp", "st", "peer", "table", "dep", "list", "data", "must", "trans", "root", "iter", "sum", "shape", "desc", "writer", "ports", "source", "usr", "created", "priv", "pas", "v", "temp", "dev", "this", "public", "success", "req", "loc", "port", "orig", "max", "slave", "results", "total", "obj", "options", "comp", "rel", "opt", "physical", "spec", "p", "Dest", "path", "foreign", "src", "dist", "etc", "result", "cmd", "host", "est", "target", "out", "coord", "mem", "new"]}}
{"project": "qemu", "commit_id": "03e6e5017757645f00b2f3b4f3a257973985e455", "target": 0, "func": "void cpu_state_reset(CPUMIPSState *env)\n\n{\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", env->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n\n    tlb_flush(env, 1);\n\n\n\n    /* Reset registers to their default values */\n\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n\n#endif\n\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n\n                                 << env->cpu_model->CP0_LLAddr_shift;\n\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n\n    env->CCRes = env->cpu_model->CCRes;\n\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n\n    env->current_tc = 0;\n\n    env->SEGBITS = env->cpu_model->SEGBITS;\n\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->SEGMask |= 3ULL << 62;\n\n    }\n\n#endif\n\n    env->PABITS = env->cpu_model->PABITS;\n\n    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);\n\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n\n    env->insn_flags = env->cpu_model->insn_flags;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->hflags = MIPS_HFLAG_UM;\n\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n\n       hardware registers.  */\n\n    env->CP0_HWREna |= 0x0000000F;\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        env->hflags |= MIPS_HFLAG_FPU;\n\n    }\n\n#ifdef TARGET_MIPS64\n\n    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {\n\n        env->hflags |= MIPS_HFLAG_F64;\n\n    }\n\n#endif\n\n#else\n\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n\n        /* If the exception was raised from a delay slot,\n\n           come back to the jump.  */\n\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n\n    } else {\n\n        env->CP0_ErrorEPC = env->active_tc.PC;\n\n    }\n\n    env->active_tc.PC = (int32_t)0xBFC00000;\n\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n\n    env->CP0_Wired = 0;\n\n    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);\n\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n\n    /* vectored interrupts not implemented, timer on int 7,\n\n       no performance counters. */\n\n    env->CP0_IntCtl = 0xe0000000;\n\n    {\n\n        int i;\n\n\n\n        for (i = 0; i < 7; i++) {\n\n            env->CP0_WatchLo[i] = 0;\n\n            env->CP0_WatchHi[i] = 0x80000000;\n\n        }\n\n        env->CP0_WatchLo[7] = 0;\n\n        env->CP0_WatchHi[7] = 0;\n\n    }\n\n    /* Count register increments in debug mode, EJTAG version 1 */\n\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n\n    env->hflags = MIPS_HFLAG_CP0;\n\n\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        int i;\n\n\n\n        /* Only TC0 on VPE 0 starts as active.  */\n\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n\n            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;\n\n            env->tcs[i].CP0_TCHalt = 1;\n\n        }\n\n        env->active_tc.CP0_TCHalt = 1;\n\n        env->halted = 1;\n\n\n\n        if (!env->cpu_index) {\n\n            /* VPE0 starts up enabled.  */\n\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n\n\n\n            /* TC0 starts up unhalted.  */\n\n            env->halted = 0;\n\n            env->active_tc.CP0_TCHalt = 0;\n\n            env->tcs[0].CP0_TCHalt = 0;\n\n            /* With thread 0 active.  */\n\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n\n        }\n\n    }\n\n#endif\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n#endif\n\n    env->exception_index = EXCP_NONE;\n\n}\n", "idx": 21427, "substitutes": {"env": ["ende", "equ", "end", "viron", "ve", "shell", "esm", "conf", "editor", "eng", "conn", "ei", "ext", "environment", "worker", "eh", "enc", "org", "een", "order", "server", "rb", "et", "buf", "queue", "hw", "eve", "gear", "erd", "cb", "cv", "ctx", "stage", "vt", "erb", "exc", "eni", "manager", "esi", "web", "eq", "vs", "den", "vm", "enter", "iv", "era", "ds", "dest", "doc", "serv", "uv", "ec", "net", "ener", "en", "ew", "desc", "eas", "ent", "ov", "v", "dev", "export", "eb", "ev", "ja", "here", "engine", "req", "console", "ea", "timer", "oe", "ue", "ten", "er", "header", "erv", "app", "act", "msg", "txt", "outer", "var", "nav", "window", "obj", "estate", "el", "ee", "ger", "err", "vv", "eg", "inv", "forge", "oder", "alias", "entry", "ter", "esc", "sb", "ah", "door", "vp", "query", "cmd", "ef", "dn", "db", "buffer", "ner", "gate", "vert", "nv", "code", "event", "e", "keeper", "actor", "context", "eur", "het", "addr", "operator", "Environment"]}}
{"project": "qemu", "commit_id": "57ef3f1278585fbac5f6102362d3c5e066976fdc", "target": 0, "func": "bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n\n        if (errp) {\n\n            *errp = error_copy(blocker->reason);\n\n            error_prepend(errp, \"Node '%s' is busy: \",\n\n                          bdrv_get_device_or_node_name(bs));\n\n        }\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 21430, "substitutes": {"bs": ["js", "gs", "ls", "bb", "irms", "rs", "bits", "bc", "cms", "bes", "sb", "vs", "bp", "bis", "ps", "bus", "fs", "acs", "ims", "ds", "b", "cs", "bm", "ts", "bt", "ss", "abilities", "aos", "aws", "bh", "bl", "BS", "ubs", "ns", "cks", "pb", "ks", "its", "bps", "hs", "obs", "bi", "sts", "bf", "qs", "sys", "bos", "os", "lbs", "als", "bsp", "uts", "bas", "bn"], "op": ["cp", "xp", "post", "tp", "ep", "pop", "p", "Op", "oc", "o", "sp", "id", " cop", "type", "loc", "jp", "ot", "pe", "up", "typ", "ps", "it", "pl", "ext", "oe", "bit", "cop", "top", "ok", "tx", "pat", "cmd", "oper", "k", "prev", "update", "key", "msg", "opa", "ip", "hop", "ap", "tip", "oop", "e", "operation", "zero", "comp", "x", "batch", "OP", " ip", "ops", " hop", "block", "ack", "mop", "operator", "opt"], "errp": ["rrpp", "nerp", "nerr", " errpc", "rrps", "errr", "errpp", "Erpe", "errorpb", "errpress", "attrr", "errpe", " errr", "arrpa", " errpp", "erpc", "errpb", "rrpb", "attrpp", "errorp", "diep", "errps", "Erper", "attrp", "errper", "errpc", " errpe", " errpress", "nerpa", "rrp", "erp", "dieper", "arrpress", " errper", "arrr", " errpb", "errpa", "arrp", "nerpress", "err", " errpa", " errps", "erpp", "errorpp", "Erp", "errorps", "attrpc", "diepe"], "blocker": ["buszer", " blockER", "busonder", "bloser", "checktimer", " blockzer", "lockonder", "blockoser", "joinger", "joinner", "blockzer", "buser", "checkener", "blockER", "lockzer", "blockinger", "checker", "blockonder", "blocktimer", "blockingtimer", "blockner", "bltimer", "joiner", "blockers", " blockner", "busER", "checkoser", "blener", "blockingoser", "blockingener", "ankger", "ankner", " blockers", "locker", "bler", "ankers", "joiners", " blockonder", " blockger", "blockener", "anker", "lockER", "blockger"]}}
{"project": "qemu", "commit_id": "3ddf3efefa364505ee44582873612dd8f6abb838", "target": 0, "func": "static BlockJob *find_block_job(const char *device, AioContext **aio_context,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    *aio_context = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        goto notfound;\n\n    }\n\n\n\n    *aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(*aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        goto notfound;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs->job) {\n\n        goto notfound;\n\n    }\n\n\n\n    return bs->job;\n\n\n\nnotfound:\n\n    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n\n              \"No active block job on device '%s'\", device);\n\n    if (*aio_context) {\n\n        aio_context_release(*aio_context);\n\n        *aio_context = NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21435, "substitutes": {"device": ["dev", "product", "command", "serial", "description", "end", "family", "name", "pad", "path", "pe", "Device", "block", "module", "DEV", "plugin", "component", "android", "mode", "feature", "address", "kind", "hid", "slave", "query", "location", "directory", "remote", "network", "VICE", "controller", "driver", "series", " Device", "disk", "pod", "handle", "display", "connection", "resource", "model", "devices", "label"], "aio_context": ["aio_Context", "aio___Context", "aive_Context", "aiop_resource", "aao____connection", "aip_mask", "aio_ctx", "aip_context", "aio____cache", "aiao_Context", "aio___ctx", "aio____package", "aio_mask", "aai_mask", "aio_cache", "aiao_mask", "aao_connection", "aiop_connection", "aiao_context", "aio___info", "aioaxyContext", "aIO_Context", "aai_ctx", "aiao_tx", "aio_info", "aIO_info", "aio_tx", "aiop_context", "aio____context", "aao____context", "aio___context", "aai_scope", "aIO_context", "aio_group", "aio_mem", "aao____cache", "aive_condition", "aio_connection", "aao_package", "aioaxycondition", "aio_condition", "aio___mask", "aai_context", "aioaxygroup", "aao_cache", "aao____package", "aio_scope", "aip_ctx", "aio_package", "aio____connection", "aive_group", "aive_context", "aioaxycontext", "aiop_mem", "aao_context", "aio_resource"], "errp": ["errpid", " errP", "dieps", "erP", "diepa", "erps", "diepid", "diep", "errps", "scorepid", "scorep", "erp", "dieP", "errpar", "scorepar", " errpid", "errpa", "errP", " errpa", "scoreps", " errps", "diepar", " errpar", "erpa"], "blk": ["broek", "slk", "brock", "bleak", "bgk", "plk", "blck", "Blck", " blak", "bleck", " blb", "slak", "oblk", "slke", "blb", "slck", "Blb", "toolck", "bleek", "blak", " blj", " blkg", "plak", "bgck", "Blk", "toolkg", "oblak", "toolak", "bgak", " blke", " blek", "bgek", " blck", "oblck", "blek", "oblke", "plck", "brob", "blke", "brok", "Blek", "blkg", "Blak", "oblj", "Blj", "plj", "oblkg", "toolk", "blj"], "bs": ["busters", "js", "gs", "bed", "bas", "bb", "bing", "ls", "banks", "irms", "bits", "bc", "bes", "sb", "vs", "outs", "bp", "bis", "bytes", "ab", "css", "fs", "blocks", "b", "ms", "cs", "bm", "ts", "aos", "bles", "bh", "aus", "bl", "uses", "BS", "ubs", "ns", "pb", "its", "boxes", "bps", "bi", "obs", "qs", "bos", "lbs", "bd", "vals", "flows", "uts", "bys", "bus", "boot", "cb"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n", "idx": 21450, "substitutes": {"str": ["Str", "spec", "p", "sp", "name", "seq", "tr", "w", "br", "fr", "sc", "it", "text", "b", "s", "c", "cs", "r", "raw", "arc", "enc", "in", "i", "t", "STR", "res", "buffer", "txt", "cur", "buf", "out", "ch", "arr", "stri", "st", "f"], "hci": [" hli", "hcci", " hpi", "ihci", "wci", "hcm", " hcgi", "ihdi", "rci", " hco", " hcli", "heli", " hcci", " hcul", "cpi", "ihco", "ahcgi", "rcci", "ahci", "htci", " hdi", " hcu", "heci", "rhcgi", "ncul", "ahcli", "hcu", "htco", "Hpi", "ihcci", "wdi", "hcli", " hcm", "cco", "Hco", "hecci", "nco", "htcul", "hdi", "hcul", "Hci", "Hcci", "cci", "wcci", "rhcm", "htcci", "nci", "rli", "hecu", "cdi", "wco", "hpi", "rhci", "hco", "rhcli", "ncci", "hcgi", "rcu", "Hdi", "hli", "ahcm"], "bdaddr": ["cdaddress", "ndconn", "disabledloc", "ndadr", "bdobj", "dadd", "disabledcoord", "cdnenv", "bdconn", "bladdress", "bcaddr", "ndloc", "bdreq", "condobj", "dptr", "condaddr", "cdptr", "daddress", "bcaddress", "bdadr", "desaddr", "desobj", "bdside", "ddloc", "disabledaddr", "ddaddress", "cdnaddress", "bcconn", "daddr", "bdaddress", "djside", "ddcoord", "bdcoord", "disabledconn", "baenv", "bart", "desside", "cdnrt", "bdadd", "condadr", "dbadr", "bladr", "dbaddress", "ndside", "ndaddr", "dbaddr", "bcreq", "desconn", "condconn", "bcadr", "djaddr", "bcobj", "dbenv", "BDadr", "bdrt", "baaddress", "djadr", "ndcoord", "dbrt", "ddreq", "BDptr", "cdnaddr", "dbptr", "cdaddr", "cdadd", "bdloc", "dbadd", "BDadd", "bladd", "BDreq", "BDaddr", "desadr", "baaddr", "ddconn", "bdptr", "bdenv", "bladdr", "djconn", "BDaddress", "ddaddr", "BDconn"]}}
{"project": "qemu", "commit_id": "58aebb946acff82c62383f350cab593e55cc13dc", "target": 0, "func": "static int cris_mmu_translate_page(struct cris_mmu_result *res,\n\n\t\t\t\t   CPUState *env, uint32_t vaddr,\n\n\t\t\t\t   int rw, int usermode, int debug)\n\n{\n\n\tunsigned int vpage;\n\n\tunsigned int idx;\n\n\tuint32_t pid, lo, hi;\n\n\tuint32_t tlb_vpn, tlb_pfn = 0;\n\n\tint tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;\n\n\tint cfg_v, cfg_k, cfg_w, cfg_x;\t\n\n\tint set, match = 0;\n\n\tuint32_t r_cause;\n\n\tuint32_t r_cfg;\n\n\tint rwcause;\n\n\tint mmu = 1; /* Data mmu is default.  */\n\n\tint vect_base;\n\n\n\n\tr_cause = env->sregs[SFR_R_MM_CAUSE];\n\n\tr_cfg = env->sregs[SFR_RW_MM_CFG];\n\n\tpid = env->pregs[PR_PID] & 0xff;\n\n\n\n\tswitch (rw) {\n\n\t\tcase 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;\n\n\t\tcase 1: rwcause = CRIS_MMU_ERR_WRITE; break;\n\n\t\tdefault:\n\n\t\tcase 0: rwcause = CRIS_MMU_ERR_READ; break;\n\n\t}\n\n\n\n\t/* I exception vectors 4 - 7, D 8 - 11.  */\n\n\tvect_base = (mmu + 1) * 4;\n\n\n\n\tvpage = vaddr >> 13;\n\n\n\n\t/* We know the index which to check on each set.\n\n\t   Scan both I and D.  */\n\n#if 0\n\n\tfor (set = 0; set < 4; set++) {\n\n\t\tfor (idx = 0; idx < 16; idx++) {\n\n\t\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\t\t\ttlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n\n\t\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\n\n\t\t\tprintf (\"TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\\n\", \n\n\t\t\t\t\tset, idx, hi, lo, tlb_vpn, tlb_pfn);\n\n\t\t}\n\n\t}\n\n#endif\n\n\n\n\tidx = vpage & 15;\n\n\tfor (set = 0; set < 4; set++)\n\n\t{\n\n\t\tlo = env->tlbsets[mmu][set][idx].lo;\n\n\t\thi = env->tlbsets[mmu][set][idx].hi;\n\n\n\n\t\ttlb_vpn = hi >> 13;\n\n\t\ttlb_pid = EXTRACT_FIELD(hi, 0, 7);\n\n\t\ttlb_g  = EXTRACT_FIELD(lo, 4, 4);\n\n\n\n\t\tD_LOG(\"TLB[%d][%d][%d] v=%x vpage=%x lo=%x hi=%x\\n\", \n\n\t\t\t mmu, set, idx, tlb_vpn, vpage, lo, hi);\n\n\t\tif ((tlb_g || (tlb_pid == pid))\n\n\t\t    && tlb_vpn == vpage) {\n\n\t\t\tmatch = 1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\n\n\tres->bf_vec = vect_base;\n\n\tif (match) {\n\n\t\tcfg_w  = EXTRACT_FIELD(r_cfg, 19, 19);\n\n\t\tcfg_k  = EXTRACT_FIELD(r_cfg, 18, 18);\n\n\t\tcfg_x  = EXTRACT_FIELD(r_cfg, 17, 17);\n\n\t\tcfg_v  = EXTRACT_FIELD(r_cfg, 16, 16);\n\n\n\n\t\ttlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n\n\t\ttlb_v = EXTRACT_FIELD(lo, 3, 3);\n\n\t\ttlb_k = EXTRACT_FIELD(lo, 2, 2);\n\n\t\ttlb_w = EXTRACT_FIELD(lo, 1, 1);\n\n\t\ttlb_x = EXTRACT_FIELD(lo, 0, 0);\n\n\n\n\t\t/*\n\n\t\tset_exception_vector(0x04, i_mmu_refill);\n\n\t\tset_exception_vector(0x05, i_mmu_invalid);\n\n\t\tset_exception_vector(0x06, i_mmu_access);\n\n\t\tset_exception_vector(0x07, i_mmu_execute);\n\n\t\tset_exception_vector(0x08, d_mmu_refill);\n\n\t\tset_exception_vector(0x09, d_mmu_invalid);\n\n\t\tset_exception_vector(0x0a, d_mmu_access);\n\n\t\tset_exception_vector(0x0b, d_mmu_write);\n\n\t\t*/\n\n\t\tif (cfg_k && tlb_k && usermode) {\n\n\t\t\tD(printf (\"tlb: kernel protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 2;\n\n\t\t} else if (rw == 1 && cfg_w && !tlb_w) {\n\n\t\t\tD(printf (\"tlb: write protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t  vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\t/* write accesses never go through the I mmu.  */\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (rw == 2 && cfg_x && !tlb_x) {\n\n\t\t\tD(printf (\"tlb: exec protected %x lo=%x pc=%x\\n\", \n\n\t\t\t\t vaddr, lo, env->pc));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 3;\n\n\t\t} else if (cfg_v && !tlb_v) {\n\n\t\t\tD(printf (\"tlb: invalid %x\\n\", vaddr));\n\n\t\t\tmatch = 0;\n\n\t\t\tres->bf_vec = vect_base + 1;\n\n\t\t}\n\n\n\n\t\tres->prot = 0;\n\n\t\tif (match) {\n\n\t\t\tres->prot |= PAGE_READ;\n\n\t\t\tif (tlb_w)\n\n\t\t\t\tres->prot |= PAGE_WRITE;\n\n\t\t\tif (tlb_x)\n\n\t\t\t\tres->prot |= PAGE_EXEC;\n\n\t\t}\n\n\t\telse\n\n\t\t\tD(dump_tlb(env, mmu));\n\n\t} else {\n\n\t\t/* If refill, provide a randomized set.  */\n\n\t\tset = env->mmu_rand_lfsr & 3;\n\n\t}\n\n\n\n\tif (!match && !debug) {\n\n\t\tcris_mmu_update_rand_lfsr(env);\n\n\n\n\t\t/* Compute index.  */\n\n\t\tidx = vpage & 15;\n\n\n\n\t\t/* Update RW_MM_TLB_SEL.  */\n\n\t\tenv->sregs[SFR_RW_MM_TLB_SEL] = 0;\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);\n\n\n\n\t\t/* Update RW_MM_CAUSE.  */\n\n\t\tset_field(&r_cause, rwcause, 8, 2);\n\n\t\tset_field(&r_cause, vpage, 13, 19);\n\n\t\tset_field(&r_cause, pid, 0, 8);\n\n\t\tenv->sregs[SFR_R_MM_CAUSE] = r_cause;\n\n\t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc));\n\n\t}\n\n\n\n\tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\n\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\n\n\t\t  __func__, rw, match, env->pc,\n\n\t\t  vaddr, vpage,\n\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \n\n\t\t  pid,\n\n\t\t  r_cause,\n\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\n\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));\n\n\n\n\tres->phy = tlb_pfn << TARGET_PAGE_BITS;\n\n\treturn !match;\n\n}\n", "idx": 21459, "substitutes": {"res": ["reset", "rs", "pr", "req", "rou", "def", "des", "ret", "RES", "proc", "tx", "serv", "reg", "rez", "rev", "re", "resp", "Res", "resh", "ress", "mem", "rec", "sys", "pres", "vals", "err", "rc", "val"], "env": ["ctx", "dev", "equ", "end", "viron", "te", "exc", "inv", "vt", "ev", "eni", "manager", "here", "conf", "pe", "esc", "eng", "den", "conn", "ext", "environment", "hess", "ten", "era", "er", "attr", "info", "proc", "worker", "config", "ec", "org", "ef", "net", "network", "en", "ner", "ew", "disk", "cv", "desc", "buf", "con", "window", "nv", "code", "e", "context", "mem", "param", "ee", "hw", "err", "operator", "Environment", "erd", "pg", "v"], "vaddr": ["nvaddr", "vpad", "vaddress", "waddr", "vconn", "cvstore", "wstore", "cvaddress", "svoffset", "cvaddr", "nvoffset", "svaddress", "cvconn", "nvaddress", " vconn", "svpad", "wconn", "voffset", "vtpad", "nvpad", "vstore", " vstore", "waddress", " vaddress", "svaddr", "vtaddress", "vtoffset", "vtaddr"], "rw": ["wn", "nw", "wrap", "RW", "writ", "write", "weak", "iw", "fw", "w", "rew", "wb", "range", "tw", "aw", "rss", "rt", "wp", "r", "kw", "wd", "wr", "wu", "rb", "rf", "ru", "resp", "route", "writer", "wcs", "ro", "rr", "rd", "rid", "hw", "wx", "nr", "rc"], "usermode": ["usrmode", "flagmode", "userflag", "testflags", "usrcache", "testcache", "testflag", "usrflags", "flagflag", "testmode", "flagcache", "usrflag", "flagflags", "usercache", "userflags"], "debug": ["dev", "diff", "depth", "mod", "deb", "DEBUG", "web", "d", "tag", "cache", "scale", "warn", "doc", "date", "render", "flag", "Debug", "error", "db", "dc", "comment", "coord", "bug", "priv", "progress", "trace"], "vpage": [" vport", "vrow", " vpages", "vage", "vpages", "nvpage", "pport", "uvpc", "uvrow", "ppage", "prow", " vnode", "vnode", "nvchannel", "nvoffset", "tpages", "uvpage", " Vpages", " vchannel", "ppc", "Vchannel", "Vpage", "voffset", " Vpage", "tage", " Vnode", " vpc", "Vage", " vrow", " Vage", "Voffset", "nvage", "tnode", " voffset", " vage", "tpage", "vpc", "vport", "uvport", "vchannel"], "idx": ["indx", "inity", "initxd", "idxs", "idxe", "initrox", "partx", "identex", " idix", " idex", "indn", "IDxd", "idrox", "IDex", "IDlex", "indxs", "midnex", "initx", " idxe", "Idz", " idnex", "midy", "kidy", " idxc", " idz", "ideex", " idxd", "Idy", "kidix", "midxs", "indrox", "idexes", "identnex", "idnex", "partxc", " idrox", "idy", "Idix", "Idx", " idxf", "idxc", "Idex", "Idxes", "indxf", "idxf", "indy", "midz", " idn", "Idxs", "idxes", "initxe", "idz", "partlex", "idlex", " idxs", "midix", "IDxe", "identix", "indz", "idey", "IDx", "initex", "initxf", "ideix", "idexs", "midex", " idlex", " idy", "midn", "idex", "identx", "kidxes", "idxd", "kidx", "party", "idn", "idix", "IDxc", "index", "midx", "IDy"], "pid": ["ctx", "pkg", "wan", "p", "id", "pm", "port", "notice", "pan", "typ", "fd", "phy", "png", "status", "win", "proc", "pin", "po", "pt", "pos", "sta", "pro", "phi", "pc", "page", "pa", "pn", "sid", "process", "base", "oid", "pi", "mid", "uid", "part", "pai", "pu", "vid", "pool", "pg"], "lo": ["lf", "ilo", "fo", "mo", "so", "ko", "stone", "o", "iso", "loc", "ln", "low", "lin", "ld", "pl", "zo", "que", "lon", "l", "isl", "lim", "lie", "co", "mi", "lr", "line", "oo", "lu", "lc", "los", "LO", "no", "lan", "la", "po", "go", "loe", "loop", "phi", "li", "lt", "lb", "Lo", "ro", "ao", "local", "h", "elo", "le", "bo"], "hi": ["ha", "high", "fo", "wo", "ci", "ko", "iso", "id", "loc", "ih", "ho", "Hi", "low", "mu", "ph", "py", "lim", "ashi", "hd", "ht", "ti", "mi", "rh", "info", "history", "sh", "hei", "hip", "hid", "no", "po", "i", "go", "ni", "bh", "fi", "gi", "phi", "ui", "HI", "li", "wi", "ip", "hea", "ri", "hy", "hel", "hh", "ro", "hl", "his", "upper", "hu", "cu", "ch", "h", "ris", "pi", "mid"], "tlb_vpn": ["tlb_vgn", "tlb_tvlan", "tlb_vnp", "tlb_tvpn", "tlb_pnp", "tlb_evPN", "tlb_avnp", "tlb_tvbn", "tlb_vPN", "tlb_pbn", "tlb_lbn", "tlb_ivbn", "tlb_evpn", "tlb_ppas", "tlb_avn", "tlb_evn", "tlb_pn", "tlb_lpas", "tlb_ivn", "tlb_ivPN", "tlb_vlan", "tlb_tvnp", "tlb_ivgn", "tlb_vpas", "tlb_plan", "tlb_evbn", "tlb_lgn", "tlb_ivpas", "tlb_ivpn", "tlb_ppn", "tlb_lpn", "tlb_tvPN", "tlb_tvn", "tlb_vbn", "tlb_pgn", "tlb_avlan", "tlb_vn", "tlb_avpn"], "tlb_pid": ["tpl_pg", "tlb__pi", "tpl_pid", "tpl_p", "tpl_pi", "tlb__pg", "tlb_p", "tlb_pi", "tlb__pid", "tlb__p", "tlb_pg"], "tlb_g": ["tlp_p", "tlb8g", "tlp_k", "tlp_g", "tlb8k", "tlb_p", "tlp_gc", "tlb_gc", "tlb8gc", "tlb8p"], "tlb_v": ["tlb_b", "tlp_k", "tlp_w", "tlp_b", "tlp_v"], "tlb_k": ["tlp_k", "tlp_w", "tlp_v", "tlp_q", "tlb_q"], "tlb_w": ["tlp_h", "tlbxw", "tlbxr", "tlp_w", "tlb_r", "tlbxh", "tlp_v", "tlp_r", "tlbxv", "tlb_h"], "tlb_x": ["tlb_y", "tlp_h", "tlp_w", "tlp_y", "tlp_x", "tlb_h"], "cfg_v": ["ctrl_f", "cfg_g", "ctrl_w", "cfg_f", "ctrl_g", "ctrl_v"], "cfg_k": ["config_u", "config_k", "config_g", "cfg_g", "config_v", "cfg_u"], "cfg_w": ["cfg_wk", "cfg00wk", "cfg2wk", "cfg2w", "cfgxh", "cfg00h", "cfg00v", "storage_v", "storage_w", "storage_h", "storage00w", "cfgxw", "storage_wk", "cfg_h", "cfgxwk", "storage00h", "cfgxv", "storage00wk", "storage00v", "cfg2h", "cfg2v", "cfg00w"], "cfg_x": ["cfg_ex", "tm_ex", "tm_w", "tm_f", "tm_x", "cfg_f"], "set": ["check", "get", "pack", "end", "sp", "oto", "ve", "setting", "name", "cast", "type", "ver", "tree", "iat", "sc", "test", "chain", "spot", "sche", "et", "store", "sec", "run", "ind", "st", "clear", "use", "stage", "post", "list", "try", "Set", "pop", "mod", "common", "range", "it", "shift", "site", "ser", "sum", "net", "move", "en", "see", "ate", "read", "SET", "equal", "local", "se", "save", "draw", "reset", "num", "add", "alt", "san", "split", "init", "act", "msg", "section", "session", "row", "batch", "spec", "diff", "start", "id", "def", "scale", "single", "sync", "no", "mark", "i", "go", "size", "match", "sub", "ident", "sha", "handle", "base", "index", "new", "commit", "ex", "pair"], "r_cause": ["r___forge", "r__cause", "r_ca", "r_reason", "r___reason", "pr_cf", "r_forge", "cr__reason", "r__reason", "r__ca", "cr__forge", "pr_cfg", "r_cf", "r___cause", "cr_forge", "r__forge", "pr_cause", "cr__cause", "cr__ca", "cr_reason", "pr_controller", "cr_ca", "cr_cause", "r___ca", "r_controller"], "r_cfg": ["r__cmd", "r__cfg", " r2category", "r2category", "rdjcfg", "R_config", "r2cfg", "r__fg", " r_config", "R_cmd", " r2cf", "r_cf", "r2cmd", "r2config", " r_cf", "r_config", "rdjcf", "r2fg", "r2cf", "R_cfg", "r__config", "R_fg", "rdjconfig", " r_category", "r_cmd", "r_fg", " r2cfg", "r_category", "rdjcategory", " r2config"], "rwcause": ["kwcause", "rewnotice", "rewCause", "rewreason", "nwreason", "rwcorruption", "RWchoice", "kwscore", "wrreason", "winecause", "RWnotice", "rfreason", "RWcause", "rwreason", "rewerr", "rfscore", "werr", "wrCause", "winechoice", "wrcause", "wreason", "rewchoice", "RWscore", "kwreason", "RWbecause", "wcause", "rwchoice", "kwcorruption", "kwbecause", "rwnotice", "RWreason", "winereason", "rwCause", "wrerr", "rfcause", "rfbecause", "wCause", "rwscore", "rwbecause", "winenotice", "hwcorruption", "hwreason", "nwcause", "rewcause", "nwcorruption", "rwerr", "hwcause"], "vect_base": ["vectationbas", "vect__offset", "vect_offset", "vex_bas", "vect__base", "vector_base", "vect__bas", "vectationbase", "vector_bas", "vect_b", "vectationb", "vectationoffset", "vector_offset", "vect_bas", "vex_balance", "vector_b", "vect_balance", "vex_Base", "vect_Base", "vect__b", "vex_base"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n", "idx": 21466, "substitutes": {"ctx": ["cp", "cfg", "pkg", "kh", "gc", "jj", "vc", "np", "mk", "bc", "req", "loc", "jp", "kt", "ctrl", "tmp", "xc", "tc", "anc", "nc", "conn", "cm", "cc", "mc", "sc", "Context", "ij", "c", "kw", "tx", "lc", "cmd", "nt", "bh", "kb", "jac", "unc", "txt", "ck", "cur", "obj", "abc", "ctr", "context", "crit", "kj", "cmp", "cb", "ctl", "ct"]}}
{"project": "qemu", "commit_id": "96193c22ab39ea24f81e386ad7883260ff24f5fd", "target": 0, "func": "static void x86_cpu_enable_xsave_components(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n\n\n    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n        return;\n\n    }\n\n\n\n    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n        const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n        if (env->features[esa->feature] & esa->bits) {\n\n            env->xsave_components |= (1ULL << i);\n\n        }\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        KVMState *s = kvm_state;\n\n        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n        kvm_mask <<= 32;\n\n        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        env->xsave_components &= kvm_mask;\n\n    }\n\n}\n", "idx": 21473, "substitutes": {"cpu": ["ctx", "cp", "ola", "gc", "tp", "p", "linux", "hog", "CPU", "arch", "anc", "nc", "vm", "uda", "ork", "chip", "uu", "proc", "c", "core", "gpu", "bean", "aco", "processor", "nic", "ec", "bench", "apache", "pc", "ck", "process", "cam", "cu", "mem", "hw", "clock", "alloc", "pu", "ack", "boot"], "env": ["equ", "end", "viron", "ve", "shell", "eng", "ei", "conn", "vas", "environment", "worker", "eh", "org", "eco", "server", "et", "buf", "head", "queue", "gear", "peer", "erd", "cv", "ctx", "vt", "exc", "manager", "ell", "vs", "vm", "enter", "era", "bean", "scope", "config", "ec", "net", "en", "ew", "desc", " en", "eas", "ent", "kernel", "v", "dev", "export", "state", "ev", "here", "engine", "req", "console", "chart", "oe", "er", "header", "outer", "session", "window", "obj", "policy", "cfg", "spec", "forge", "entry", "ah", "expr", "vp", "ef", "ce", "db", "ner", "gate", "disk", "code", "e", "context", "runner", "eu", "Environment", "response"], "i": ["m", " ti", "ci", "ix", "p", "id", "si", " bi", "multi", "zi", "port", "span", " si", "mu", "n", "y", "it", "xi", "ims", "ij", "ti", "mi", "gu", "qi", "c", "iu", "j", " ki", "di", "in", "go", "\u0438", "ni", "ai", "t", "im", "print", " ii", "fi", "ui", "phi", "ic", "li", " multi", "gi", " j", "ip", "sim", "key", "ri", "ji", "a", "ini", "bi", "e", " m", "ind", "oi", "index", "x", "ii", "pi", "batch", "asi", "I", "yi", "ami", "is", "pers", "v", " pi"], "esa": ["usa", "eta", "ema", "abus", "es", "iso", "sea", "aze", "esi", "apa", "ozo", "uca", "asar", "ea", "acs", "sis", "era", "ista", "sa", "eus", "osi", "ski", "ses", "edes", "ESA", "aos", "emis", "sama", "atari", "iste", "acha", "eas", "ette", "anza", "ideo", "aki", "ase", "una", "estro", "ean", "essa", "pai", " Mesa", "ya", "isa", "asse", "cow", "mes"], "s": ["js", "gs", "south", "spec", "sl", "ls", "p", "sq", "sp", "us", "rs", "w", "sb", "vs", "ps", "n", "fs", "ds", "sa", "c", "cs", "r", "ts", "serv", "ses", "ss", "t", "set", "ns", "hs", "sam", "sts", "sv", "h", "se", "os", "sg", "S", "space", "st", "sd", "is", "v"]}}
{"project": "qemu", "commit_id": "2bcf018340cbf233f7145e643fc1bb367f23fd90", "target": 0, "func": "int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    /* TODO: low address protection once we flush the tlb on cr changes */\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    /* TODO: storage key handling */\n\n    return 0;\n\n}\n", "idx": 21487, "substitutes": {"env": ["ctx", "viron", "te", "state", "ev", "manager", "engine", "conf", "gov", "esc", "ptr", "eng", "vs", "conn", "environment", "ten", "info", "proc", "scope", "vp", "config", "stack", "org", "En", "server", "map", "en", "EN", "store", "window", "buf", "handle", "obj", "estate", "e", "context", "mem", "gear", "Environment", "erd", "v"], "raddr": ["rAddress", "radr", "rcaddress", "rcadd", "Raddress", "rararp", " rfx", "Radr", "rarfx", "Raddr", "raraddr", "Rarp", "rcaddr", "Rfx", " raddress", "rarp", "radd", " radd", "rfx", "Radd", "RAddress", "raddress", " radr", " rAddress", "rcadr", "rarAddress", " rarp"], "rw": ["xp", "nw", "RW", "write", "w", "ln", "eng", "wa", "wid", " wr", "aw", "self", "lr", "wp", "lock", "wind", "sw", "wd", "wr", "rb", "rf", "window", "row", "rl", "hw", "weight", "wx", "rc"], "addr": ["ix", "arp", "add", "rs", "alt", "id", "pad", "loc", "ag", "ptr", "ace", "src", "offset", "attr", "rt", "address", "r", "wd", "tx", "cmd", "dr", "act", "pos", "map", "res", "amp", "ref", "align", "store", "buf", "coord", "rad", "obj", "mem", "arr", "rr", "ad", "ack", "rc"], "flags": ["alf", "acts", "ff", "events", "bits", "tags", "lag", "ants", "vs", "weights", "ps", "states", "types", "fs", "settings", "limits", "grades", "ts", "flag", "units", "faces", "args", "pages", "actions", "ags", "options", "features", "planes", "levels", "aps", "fps", "properties", "mask", "ents", "ops", "fields", "Flags", "locks"]}}
{"project": "qemu", "commit_id": "6cded3a43ad0044d9831590795d9c6cf0dc2d2ee", "target": 0, "func": "static void nic_selective_reset(EEPRO100State * s)\n\n{\n\n    size_t i;\n\n    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);\n\n    //~ eeprom93xx_reset(s->eeprom);\n\n    memcpy(eeprom_contents, s->conf.macaddr.a, 6);\n\n    eeprom_contents[0xa] = 0x4000;\n\n    if (s->device == i82557B || s->device == i82557C)\n\n        eeprom_contents[5] = 0x0100;\n\n    uint16_t sum = 0;\n\n    for (i = 0; i < EEPROM_SIZE - 1; i++) {\n\n        sum += eeprom_contents[i];\n\n    }\n\n    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;\n\n    TRACE(EEPROM, logout(\"checksum=0x%04x\\n\", eeprom_contents[EEPROM_SIZE - 1]));\n\n\n\n    memset(s->mem, 0, sizeof(s->mem));\n\n    uint32_t val = BIT(21);\n\n    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));\n\n\n\n    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));\n\n    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));\n\n}\n", "idx": 21492, "substitutes": {"s": ["js", "gs", "spec", "sl", "ls", "p", "sq", "es", "o", "rs", "bs", "events", "bits", "details", "reads", "sb", "vs", "n", "bis", "ps", "y", "states", "fs", "ds", "l", "status", "b", "c", "cs", "r", "sw", "ts", "ses", "ss", "in", "stats", "t", "aws", "less", "args", "ns", "ies", "ins", "its", "changes", "store", "a", "hs", "e", "source", "sts", "sv", "qs", "http", "h", "ats", "sys", "os", "S", "als", "ops", "ex", "f", "is", "v", "comm"], "i": ["m", " vi", " ti", "ci", "ix", "p", "q", "o", " bi", "si", "multi", "zi", "span", " si", " mi", " di", "n", "y", "it", "xi", "l", "ti", "mi", "b", "qi", "info", "c", "fi", " ki", "j", "di", "go", "\u0438", "point", "ai", "im", "k", " ii", "uri", " k", "gi", "ui", "li", "phi", "key", " j", "ip", "sim", "ic", "ji", "ini", "bi", " x", " m", "ind", "index", "ii", "x", "pi", "asi", "I", " ni", "f", "ki", "v", " pi"], "eeprom_contents": ["eeprom7variainers", "eeprom_cmars", "eeprom_codants", "eeprom_contentens", "eeprom_ContENTS", "eeprom_contenters", "eeprom_compaps", "eeprom_contentars", "eeprom_varients", "eeprom_datent", "eeprom_intent", "eeprom_datainers", "eeprom_cment", "eeprom_contentists", "eeprom_contentents", "eeprom_descENTS", "eeprom_contentensions", "eeprom_descens", "eeprom7content", "eeprom2Content", "eeprom_constents", "eeprom_intents", "eeprom_cmENTS", "eeprom_codent", "eeprom2contentENTS", "eeprom2contents", "eeprom2ContENTS", "eeprom7varients", "eeprom_content", "eeprom_contars", "eeprom_extents", "eeprom_compENTS", "eeprom_conters", "eeprom2contentents", "eeprom2Contents", "eeprom_intensions", "eeprom_datists", "eeprom_containers", "eeprom_contensions", "eeprom_compents", "eeprom_codensions", "eeprom_contants", "eeprom_variists", "eeprom_varient", "eeprom_extENTS", "eeprom_contentaps", "eeprom2Contens", "eeprom_intants", "eeprom_codens", "eeprom_Contents", "eeprom_presenters", "eeprom2content", "eeprom_constars", "eeprom_contens", "eeprom_extent", "eeprom_presentENTS", "eeprom_contentants", "eeprom_variainers", "eeprom_contaps", "eeprom_descensions", "eeprom2contentensions", "eeprom7variists", "eeprom_contentainers", "eeprom_Contens", "eeprom_constENTS", "eeprom7containers", "eeprom_codENTS", "eeprom7varient", "eeprom_datents", "eeprom7contists", "eeprom_contentent", "eeprom_extens", "eeprom_Content", "eeprom_contentENTS", "eeprom_presentaps", "eeprom_descents", "eeprom_presentents", "eeprom2contentens", "eeprom_contENTS", "eeprom_compers", "eeprom_codents", "eeprom_contists", "eeprom7contents", "eeprom2contENTS", "eeprom2contens", "eeprom_cments", "eeprom_constent", "eeprom2contensions"]}}
{"project": "qemu", "commit_id": "0208def1cadd4f72f862e62548c2af268a543b20", "target": 1, "func": "void pci_bridge_reset_reg(PCIDevice *dev)\n\n{\n\n    uint8_t *conf = dev->config;\n\n\n\n    conf[PCI_PRIMARY_BUS] = 0;\n\n    conf[PCI_SECONDARY_BUS] = 0;\n\n    conf[PCI_SUBORDINATE_BUS] = 0;\n\n    conf[PCI_SEC_LATENCY_TIMER] = 0;\n\n\n\n    conf[PCI_IO_BASE] = 0;\n\n    conf[PCI_IO_LIMIT] = 0;\n\n    pci_set_word(conf + PCI_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);\n\n    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);\n\n\n\n    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);\n\n}\n", "idx": 21508, "substitutes": {"dev": ["serial", "spec", "ve", "ev", "pad", "debug", "Dev", "Device", "ver", "def", "av", "block", "DEV", "conn", "phy", "test", "plug", "serv", "app", " device", "devices", "det", "dem", "disk", "device", "de", "cam", "mem", "exec", "hw", "die", "ad", "bus", "usb", "v"], "conf": ["pkg", "acc", " Conf", "cast", "Conf", "um", "conn", "disc", "prop", "aff", "info", "apache", "dc", "cons", "con", "work", "ch", "cb", "ctx", "cp", "list", "try", "zh", "range", "cache", "cc", "co", "fab", "config", "sum", "map", "sch", "hash", "comment", "conv", "priv", "rc", "ff", "pub", "req", "loc", "xc", "cm", "init", "com", "scan", "app", "fac", "nav", "err", "th", "cap", "cfg", "spec", "ca", "alias", "bc", "Con", "gov", "def", "etc", "inf", "c", "query", "cmd", "func", "auth", "db", "ns", "gate", "fg", "cf"]}}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,\n\n                                        target_phys_addr_t start_addr,\n\n                                        target_phys_addr_t end_addr)\n\n{\n\n    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);\n\n}\n", "idx": 21511, "substitutes": {"client": ["product", "contact", "p", "manager", "type", "path", "project", "service", "cache", "conn", "cl", "c", "core", "grid", "config", " Client", "cmd", "node", "server", "pc", " clients", "cli", "window", "channel", "connection", "Client", "cell"], "start_addr": ["end_src", "startxaddress", "startername", "starteraddr", "end_phys", "starteraddress", "start_phys", "startfxaddr", "start_src", "startfxsrc", "start_sha", "startfxaddress", "startersha", "start_address", "startxaddr", "end_sha", "startfxphys", "end_address", "end_name", "startxsrc", "startxphys", "start_name"], "end_addr": ["end_tag", " end_tag", " end_address", "end_cmd", "start_address", "end_address", "end_adr", " end_adr", "start_cmd"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 21513, "substitutes": {"opaque": ["opacity", "OPaque", "opce", "opque", "OPac", "opac", "OPque", "oce", "oaque", "popac", "OPacity", "opsade", "paque", "pque", "popacity", "popaque", "opsce", "pacity", "pac", "opsaque", " opade", "popque", " opce", "oade", "opade"], "addr": ["ctx", "ix", "add", "Address", "adr", "grad", "np", "hz", "at", "id", "pad", "start", "sp", "loc", "kt", "ptr", "ay", "trans", "src", " address", "offset", "shift", "l", "dh", "lr", "rt", "alt", "address", "tx", "ord", "cmd", "dr", "act", "pos", "ref", "asm", "var", "align", "hash", "coord", "work", "eth", "now", "sha", "hl", "mem", "gt", "arr", "tz", "x", "hw", "err", "alloc", "ad", "mt", "rc"], "s": ["js", "gs", "m", "ls", "p", "sq", "es", "o", "rs", "w", "d", "bes", "resses", "parts", "n", "ps", "fs", "acs", "ds", "b", "c", "ts", "ses", "ss", "i", "stats", "t", "g", "ubs", "ns", "ations", "its", "ers", "a", "hs", "sts", "h", "os", "S", "ents", "is"], "saddr": ["dkid", " scoord", "ssptr", "Sha", "dsha", "dscmd", "svcoord", " saddress", "submitadd", "dsaddr", "Sptr", "dadd", " susr", "Sadd", "svaddress", " sref", "submitaddr", "daddr", "submitaddress", " sptr", "Scoord", "synha", "svptr", "Skid", "scmd", "dsptr", "synptr", "Sref", "Scmd", "ssaddr", "submitkid", "susr", "sha", "sref", "ssusr", "sadd", "daddress", "sptr", "ssref", "svaddr", "Saddr", "syncmd", "synaddr", "skid", "Saddress", "scoord", "saddress", "Susr"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,\n\n                unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    int i;\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    qemu_irq dma_irqs[6];\n\n    DriveInfo *dinfo;\n\n    SysBusDevice *busdev;\n\n\n\n    if (!core)\n\n        core = \"ti925t\";\n\n\n\n    /* Core */\n\n    s->mpu_model = omap310;\n\n    s->cpu = cpu_arm_init(core);\n\n    if (s->cpu == NULL) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP15XX_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    memory_region_init_ram(&s->emiff_ram, NULL, \"omap1.dram\", s->sdram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->emiff_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_EMIFF_BASE, &s->emiff_ram);\n\n    memory_region_init_ram(&s->imif_ram, NULL, \"omap1.sram\", s->sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->imif_ram);\n\n    memory_region_add_subregion(system_memory, OMAP_IMIF_BASE, &s->imif_ram);\n\n\n\n    omap_clkm_init(system_memory, 0xfffece00, 0xe1008000, s);\n\n\n\n    s->ih[0] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[0], \"size\", 0x100);\n\n    qdev_prop_set_ptr(s->ih[0], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[0]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[0]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_IRQ));\n\n    sysbus_connect_irq(busdev, 1,\n\n                       qdev_get_gpio_in(DEVICE(s->cpu), ARM_CPU_FIQ));\n\n    sysbus_mmio_map(busdev, 0, 0xfffecb00);\n\n    s->ih[1] = qdev_create(NULL, \"omap-intc\");\n\n    qdev_prop_set_uint32(s->ih[1], \"size\", 0x800);\n\n    qdev_prop_set_ptr(s->ih[1], \"clk\", omap_findclk(s, \"arminth_ck\"));\n\n    qdev_init_nofail(s->ih[1]);\n\n    busdev = SYS_BUS_DEVICE(s->ih[1]);\n\n    sysbus_connect_irq(busdev, 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_15XX_IH2_IRQ));\n\n    /* The second interrupt controller's FIQ output is not wired up */\n\n    sysbus_mmio_map(busdev, 0, 0xfffe0000);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dma_irqs[i] = qdev_get_gpio_in(s->ih[omap1_dma_irq_map[i].ih],\n\n                                       omap1_dma_irq_map[i].intr);\n\n    }\n\n    s->dma = omap_dma_init(0xfffed800, dma_irqs, system_memory,\n\n                           qdev_get_gpio_in(s->ih[0], OMAP_INT_DMA_LCD),\n\n                           s, omap_findclk(s, \"dma_ck\"), omap_dma_3_1);\n\n\n\n    s->port[emiff    ].addr_valid = omap_validate_emiff_addr;\n\n    s->port[emifs    ].addr_valid = omap_validate_emifs_addr;\n\n    s->port[imif     ].addr_valid = omap_validate_imif_addr;\n\n    s->port[tipb     ].addr_valid = omap_validate_tipb_addr;\n\n    s->port[local    ].addr_valid = omap_validate_local_addr;\n\n    s->port[tipb_mpui].addr_valid = omap_validate_tipb_mpui_addr;\n\n\n\n    /* Register SDRAM and SRAM DMA ports for fast transfers.  */\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->emiff_ram),\n\n                         OMAP_EMIFF_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, memory_region_get_ram_ptr(&s->imif_ram),\n\n                         OMAP_IMIF_BASE, s->sram_size);\n\n\n\n    s->timer[0] = omap_mpu_timer_init(system_memory, 0xfffec500,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER1),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[1] = omap_mpu_timer_init(system_memory, 0xfffec600,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER2),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n    s->timer[2] = omap_mpu_timer_init(system_memory, 0xfffec700,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_TIMER3),\n\n                    omap_findclk(s, \"mputim_ck\"));\n\n\n\n    s->wdt = omap_wd_timer_init(system_memory, 0xfffec800,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_WD_TIMER),\n\n                    omap_findclk(s, \"armwdt_ck\"));\n\n\n\n    s->os_timer = omap_os_timer_init(system_memory, 0xfffb9000,\n\n                    qdev_get_gpio_in(s->ih[1], OMAP_INT_OS_TIMER),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->lcd = omap_lcdc_init(system_memory, 0xfffec000,\n\n                            qdev_get_gpio_in(s->ih[0], OMAP_INT_LCD_CTRL),\n\n                            omap_dma_get_lcdch(s->dma),\n\n                            omap_findclk(s, \"lcd_ck\"));\n\n\n\n    omap_ulpd_pm_init(system_memory, 0xfffe0800, s);\n\n    omap_pin_cfg_init(system_memory, 0xfffe1000, s);\n\n    omap_id_init(system_memory, s);\n\n\n\n    omap_mpui_init(system_memory, 0xfffec900, s);\n\n\n\n    s->private_tipb = omap_tipb_bridge_init(system_memory, 0xfffeca00,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PRIV),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n    s->public_tipb = omap_tipb_bridge_init(system_memory, 0xfffed300,\n\n                    qdev_get_gpio_in(s->ih[0], OMAP_INT_BRIDGE_PUB),\n\n                    omap_findclk(s, \"tipb_ck\"));\n\n\n\n    omap_tcmi_init(system_memory, 0xfffecc00, s);\n\n\n\n    s->uart[0] = omap_uart_init(0xfffb0000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART1),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    omap_findclk(s, \"uart1_ck\"),\n\n                    s->drq[OMAP_DMA_UART1_TX], s->drq[OMAP_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap_uart_init(0xfffb0800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_UART2),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    omap_findclk(s, \"uart2_ck\"),\n\n                    s->drq[OMAP_DMA_UART2_TX], s->drq[OMAP_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap_uart_init(0xfffb9800,\n\n                                qdev_get_gpio_in(s->ih[0], OMAP_INT_UART3),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    omap_findclk(s, \"uart3_ck\"),\n\n                    s->drq[OMAP_DMA_UART3_TX], s->drq[OMAP_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->dpll[0] = omap_dpll_init(system_memory, 0xfffecf00,\n\n                                omap_findclk(s, \"dpll1\"));\n\n    s->dpll[1] = omap_dpll_init(system_memory, 0xfffed000,\n\n                                omap_findclk(s, \"dpll2\"));\n\n    s->dpll[2] = omap_dpll_init(system_memory, 0xfffed100,\n\n                                omap_findclk(s, \"dpll3\"));\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap_mmc_init(0xfffb7800, system_memory,\n\n                           blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_OQN),\n\n                           &s->drq[OMAP_DMA_MMC_TX],\n\n                    omap_findclk(s, \"mmc_ck\"));\n\n\n\n    s->mpuio = omap_mpuio_init(system_memory, 0xfffb5000,\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_KEYBOARD),\n\n                               qdev_get_gpio_in(s->ih[1], OMAP_INT_MPUIO),\n\n                               s->wakeup, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"clk\", omap_findclk(s, \"arm_gpio_ck\"));\n\n    qdev_init_nofail(s->gpio);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->gpio), 0,\n\n                       qdev_get_gpio_in(s->ih[0], OMAP_INT_GPIO_BANK1));\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s->gpio), 0, 0xfffce000);\n\n\n\n    s->microwire = omap_uwire_init(system_memory, 0xfffb3000,\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireTX),\n\n                                   qdev_get_gpio_in(s->ih[1], OMAP_INT_uWireRX),\n\n                    s->drq[OMAP_DMA_UWIRE_TX], omap_findclk(s, \"mpuper_ck\"));\n\n\n\n    s->pwl = omap_pwl_init(system_memory, 0xfffb5800,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n    s->pwt = omap_pwt_init(system_memory, 0xfffb6000,\n\n                           omap_findclk(s, \"armxor_ck\"));\n\n\n\n    s->i2c[0] = qdev_create(NULL, \"omap_i2c\");\n\n    qdev_prop_set_uint8(s->i2c[0], \"revision\", 0x11);\n\n    qdev_prop_set_ptr(s->i2c[0], \"fclk\", omap_findclk(s, \"mpuper_ck\"));\n\n    qdev_init_nofail(s->i2c[0]);\n\n    busdev = SYS_BUS_DEVICE(s->i2c[0]);\n\n    sysbus_connect_irq(busdev, 0, qdev_get_gpio_in(s->ih[1], OMAP_INT_I2C));\n\n    sysbus_connect_irq(busdev, 1, s->drq[OMAP_DMA_I2C_TX]);\n\n    sysbus_connect_irq(busdev, 2, s->drq[OMAP_DMA_I2C_RX]);\n\n    sysbus_mmio_map(busdev, 0, 0xfffb3800);\n\n\n\n    s->rtc = omap_rtc_init(system_memory, 0xfffb4800,\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_TIMER),\n\n                           qdev_get_gpio_in(s->ih[1], OMAP_INT_RTC_ALARM),\n\n                    omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    s->mcbsp1 = omap_mcbsp_init(system_memory, 0xfffb1800,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP1RX),\n\n                    &s->drq[OMAP_DMA_MCBSP1_TX], omap_findclk(s, \"dspxor_ck\"));\n\n    s->mcbsp2 = omap_mcbsp_init(system_memory, 0xfffb1000,\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_TX),\n\n                                qdev_get_gpio_in(s->ih[0],\n\n                                                 OMAP_INT_310_McBSP2_RX),\n\n                    &s->drq[OMAP_DMA_MCBSP2_TX], omap_findclk(s, \"mpuper_ck\"));\n\n    s->mcbsp3 = omap_mcbsp_init(system_memory, 0xfffb7000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3RX),\n\n                    &s->drq[OMAP_DMA_MCBSP3_TX], omap_findclk(s, \"dspxor_ck\"));\n\n\n\n    s->led[0] = omap_lpg_init(system_memory,\n\n                              0xfffbd000, omap_findclk(s, \"clk32-kHz\"));\n\n    s->led[1] = omap_lpg_init(system_memory,\n\n                              0xfffbd800, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    /* Register mappings not currenlty implemented:\n\n     * MCSI2 Comm\tfffb2000 - fffb27ff (not mapped on OMAP310)\n\n     * MCSI1 Bluetooth\tfffb2800 - fffb2fff (not mapped on OMAP310)\n\n     * USB W2FC\t\tfffb4000 - fffb47ff\n\n     * Camera Interface\tfffb6800 - fffb6fff\n\n     * USB Host\t\tfffba000 - fffba7ff\n\n     * FAC\t\tfffba800 - fffbafff\n\n     * HDQ/1-Wire\tfffbc000 - fffbc7ff\n\n     * TIPB switches\tfffbc800 - fffbcfff\n\n     * Mailbox\t\tfffcf000 - fffcf7ff\n\n     * Local bus IF\tfffec100 - fffec1ff\n\n     * Local bus MMU\tfffec200 - fffec2ff\n\n     * DSP MMU\t\tfffed200 - fffed2ff\n\n     */\n\n\n\n    omap_setup_dsp_mapping(system_memory, omap15xx_dsp_mm);\n\n    omap_setup_mpui_io(system_memory, s);\n\n\n\n    qemu_register_reset(omap1_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 21538, "substitutes": {"system_memory": ["base_metadata", "systemitymem", "baseitystorage", "system_library", "problem_area", " system_media", "system5media", "system_metadata", "system_mem", " system_region", "problemitymemory", "systempylibrary", "problemitystorage", "systempymedia", "baseitymemory", "systemityarea", "systempymemory", "system5region", "problem_memory", "base_memory", "system5storage", "baseitymem", "system_area", "base_storage", "base_mem", "baseitymetadata", " system_storage", "systempymem", " system_library", "problem_storage", "system_region", "system5memory", "systemitymetadata", "system_storage", "systemitymemory", "system_media", "systemitystorage", " system_mem", "problemitymem", "problemityarea", "problem_mem"], "sdram_size": ["sdgram_info", "sdrum_height", "sdram2name", "sdgram_length", "sdrum_shape", "sdram2info", "sdram_info", "sdram_height", "sdram_length", "sdram32shape", "sdgram2size", "sdgram_name", "sdram2length", "sdgram2length", "sdram2SIZE", "sdram1scale", "sdgram_size", "sdram67SIZE", "sdgram2name", "sdram2scale", "sdgram2scale", "sdram_scale", "sdram__name", "sdram2len", "sdram67scale", "sdgram_scale", "sdgram_SIZE", "sdgram2info", "sdram67info", "sdram__SIZE", "sdram32SIZE", "sdram_len", "sdram67size", "sdram__size", "sdram_shape", "sdram__length", "sdram32height", "sdram1info", "sdram2size", "sdram_SIZE", "sdrum_SIZE", "sdram1size", "sdgram2SIZE", "sdram_name", "sdram1SIZE", "sdram32size", "sdrum_size", "sdgram_len"], "core": ["cp", "crypt", "gc", "any", "cr", "cor", "program", "ice", "ca", "Core", "ores", "forge", "cer", "type", "aster", "one", "library", "CPU", "copy", "sc", "force", "css", "cpu", "currency", "c", "sync", "score", "sw", "processor", "pure", "board", "ce", "wheel", "ie", "cycle", "pc", "random", "gate", "ge", "con", "process", "socket", "ro", "none", "base", "gp", "ore", "native", "binary", "cy", "clock", "prot", "th", "rc"], "i": ["m", " l", "p", "sp", " out", "si", " si", "n", " v", " start", "t", " fi", " I", " ii", " p", " j", " err", "a", "e", " m", " x", " len", " init", " sp", "I", " count", " copy", " pi"], "s": ["south", "sp", "rs", "bs", "params", "esm", "conf", "copy", "fs", "ims", "sa", "settings", "cs", "stats", "set", "ies", "its", "store", "a", "sam", "os", "ls", "es", "o", "d", "vs", "ps", "ds", "l", "b", "ts", "args", "csv", "ports", "source", "se", "is", "v", "js", "gs", "m", "steps", "bits", "parts", "states", "sm", "status", "ms", "r", "ses", "ss", "results", "aws", "g", "services", "hs", "obj", "sts", "sys", "ats", "space", "sports", "comm", "spec", "p", "details", "w", "sb", "service", "n", "y", "has", "c", "sync", "as", "sw", "j", "t", "ns", "changes", "e", "all", "sv", "qs", "h", "S", "als", "ops", "sd"], "dma_irqs": [" dma_IRgs", " dma_mrqq", " dma_irgs", " dma_ibrqq", " dma_ibrq", " dma_mrqs", " dma_irqq", " dma_ibrgs", " dma_IRqq", " dma_IRqs", " dma_ibrqs", " dma_IRq", " dma_mrq", " dma_irq", " dma_mrgs"], "dinfo": ["vinfo", "vdata", "rInfo", " dInfo", "ddata", "dInfo", " ddata", "rdata", "vInfo", "rinfo"], "busdev": [" busdevice", "blockdev", "busDEV", "blockDEV", " busDev", "blockDev", "blockdevice", " busDEV", "boarddevice", "boardDev", "boardDEV", "busDev", "boarddev", "busdevice"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "void nbd_client_close(NBDClient *client)\n\n{\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    client->closing = true;\n\n\n\n    /* Force requests to finish.  They will drop their own references,\n\n     * then we'll close the socket and free the NBDClient.\n\n     */\n\n    shutdown(client->sock, 2);\n\n\n\n    /* Also tell the client, so that they release their reference.  */\n\n    if (client->close) {\n\n        client->close(client);\n\n    }\n\n}\n", "idx": 21549, "substitutes": {"client": ["check", "at", "name", "type", "handler", "quit", "user", "band", "tree", "conn", "force", "google", "builder", "lib", "address", "nt", "server", "pc", "store", "con", "pattern", "resource", "private", "Client", "peer", "block", "use", "cell", "cod", "command", "list", "closed", "project", "request", "component", "confirmed", "cl", "co", "self", "man", "prefix", "core", "admin", "config", "remote", "net", "local", "connect", "public", "secure", "port", "console", "ace", "ay", "problem", "module", "plugin", "header", "template", "active", "controller", "open", "patch", "window", "channel", "obj", "row", "form", "rule", "policy", "connection", "ct", "current", "close", "contact", "control", "entry", "player", "complete", "friend", "c", "query", "cmd", "db", "key", "cli", "link", "out", "event", "code", "handle", "null", "new", "response"]}}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static bool find_dirty_block(RAMState *rs, PageSearchStatus *pss,\n\n                             bool *again, ram_addr_t *ram_addr_abs)\n\n{\n\n    pss->offset = migration_bitmap_find_dirty(rs, pss->block, pss->offset,\n\n                                              ram_addr_abs);\n\n    if (pss->complete_round && pss->block == rs->last_seen_block &&\n\n        pss->offset >= rs->last_offset) {\n\n        /*\n\n         * We've been once around the RAM and haven't found anything.\n\n         * Give up.\n\n         */\n\n        *again = false;\n\n        return false;\n\n    }\n\n    if (pss->offset >= pss->block->used_length) {\n\n        /* Didn't find anything in this RAM Block */\n\n        pss->offset = 0;\n\n        pss->block = QLIST_NEXT_RCU(pss->block, next);\n\n        if (!pss->block) {\n\n            /* Hit the end of the list */\n\n            pss->block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n            /* Flag that we've looped */\n\n            pss->complete_round = true;\n\n            rs->ram_bulk_stage = false;\n\n            if (migrate_use_xbzrle()) {\n\n                /* If xbzrle is on, stop using the data compression at this\n\n                 * point. In theory, xbzrle can do better than compression.\n\n                 */\n\n                flush_compressed_data(rs);\n\n            }\n\n        }\n\n        /* Didn't find anything this time, but try again on the new block */\n\n        *again = true;\n\n        return false;\n\n    } else {\n\n        /* Can go around again, but... */\n\n        *again = true;\n\n        /* We've found something so probably don't need to */\n\n        return true;\n\n    }\n\n}\n", "idx": 21567, "substitutes": {"rs": ["gs", "ls", "ra", "mr", "bs", "amps", "rates", "ros", "times", "RS", "vs", "ps", "src", "Rs", "fs", "rings", "ds", "rss", "rys", "ims", "ms", "rt", "s", "cs", "ry", "vers", "r", "ts", "ss", "acks", "rows", "res", "orts", "vr", "runs", "ks", "ins", "wcs", "hs", "sts", "qs", "sr", "aps", "ris", "sys", "fps", "rc", "os", "rpm", "xs", "rm", "ars", "ack", "ras"], "pss": ["ppps", "Pcss", "cpass", "opss", "cpSS", " piss", "Pass", "psSS", "cpiss", "prews", "ppws", " phess", "ppiss", "cpws", " pcss", "prps", "piss", "pcss", "ppcss", "prhess", "pps", "press", "pass", "opcss", "cpss", "PSS", "opse", " pps", "phess", "psws", "cpse", "opess", "pse", " pws", "cpcss", "pphess", "ppess", "prSS", "prss", "Pess", "ppss", "psss", "cpess", "precss", "Piss", " pse", "opws", "opass", " pSS", "pws", "pSS", " pess", "Pss", " pass", "preess", "ppSS", "pess", "opSS", "psess"], "again": ["still", "ebin", "done", "please", "aaa", "alt", "addon", "Again", "many", "repeat", "also", "yo", "said", "abl", "each", "coin", "etc", "there", "alin", "actually", "average", "ago", "made", "some", "din", "only", "later", "extra", "forth", "peat", "fresh", "stay", "second", "these", "eas", "successfully", "out", "another", "called", "after", " Again", "aye", "more", "plain", "often", "stall"], "ram_addr_abs": ["ram_address_ts", "ram_address_absolute", "ram_addr_ref", "ram_add_abs", "ram_addr_ab", "ram_add_ref", "ram_addr_absolute", "ram_address_abs", "ram_add_ab", "ram_addr_ts", "ram_add_absolute", "ram_address_ab"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n", "idx": 21569, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)\n\n{\n\n    Wmv2Context *const w = (Wmv2Context *) s;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        if (w->j_type_bit)\n\n            w->j_type = get_bits1(&s->gb);\n\n        else\n\n            w->j_type = 0; // FIXME check\n\n\n\n        if (!w->j_type) {\n\n            if (w->per_mb_rl_bit)\n\n                s->per_mb_rl_table = get_bits1(&s->gb);\n\n            else\n\n                s->per_mb_rl_table = 0;\n\n\n\n            if (!s->per_mb_rl_table) {\n\n                s->rl_chroma_table_index = decode012(&s->gb);\n\n                s->rl_table_index        = decode012(&s->gb);\n\n            }\n\n\n\n            s->dc_table_index = get_bits1(&s->gb);\n\n        }\n\n        s->inter_intra_pred = 0;\n\n        s->no_rounding      = 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \\n\",\n\n                   s->qscale, s->rl_chroma_table_index, s->rl_table_index,\n\n                   s->dc_table_index, s->per_mb_rl_table, w->j_type);\n\n        }\n\n    } else {\n\n        int cbp_index;\n\n        w->j_type = 0;\n\n\n\n        parse_mb_skip(w);\n\n        cbp_index = decode012(&s->gb);\n\n        if (s->qscale <= 10) {\n\n            int map[3]         = { 0, 2, 1 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else if (s->qscale <= 20) {\n\n            int map[3]         = { 1, 0, 2 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else {\n\n            int map[3]         = {2,1,0};\n\n            w->cbp_table_index = map[cbp_index];\n\n        }\n\n\n\n        if (w->mspel_bit)\n\n            s->mspel = get_bits1(&s->gb);\n\n        else\n\n            s->mspel = 0; // FIXME check\n\n\n\n        if (w->abt_flag) {\n\n            w->per_mb_abt = get_bits1(&s->gb) ^ 1;\n\n            if (!w->per_mb_abt)\n\n                w->abt_type = decode012(&s->gb);\n\n        }\n\n\n\n        if (w->per_mb_rl_bit)\n\n            s->per_mb_rl_table = get_bits1(&s->gb);\n\n        else\n\n            s->per_mb_rl_table = 0;\n\n\n\n        if (!s->per_mb_rl_table) {\n\n            s->rl_table_index        = decode012(&s->gb);\n\n            s->rl_chroma_table_index = s->rl_table_index;\n\n        }\n\n\n\n        s->dc_table_index   = get_bits1(&s->gb);\n\n        s->mv_table_index   = get_bits1(&s->gb);\n\n\n\n        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);\n\n        s->no_rounding     ^= 1;\n\n\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \"\n\n                   \"per_mb_abt:%d abt_type:%d cbp:%d ii:%d\\n\",\n\n                   s->rl_table_index, s->rl_chroma_table_index,\n\n                   s->dc_table_index, s->mv_table_index,\n\n                   s->per_mb_rl_table, s->qscale, s->mspel,\n\n                   w->per_mb_abt, w->abt_type, w->cbp_table_index,\n\n                   s->inter_intra_pred);\n\n        }\n\n    }\n\n    s->esc3_level_length = 0;\n\n    s->esc3_run_length   = 0;\n\n    s->picture_number++; // FIXME ?\n\n\n\n    if (w->j_type) {\n\n        ff_intrax8_decode_picture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1);\n\n\n\n        ff_er_add_slice(&w->s.er, 0, 0,\n\n                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21576, "substitutes": {"s": ["south", "sp", "rs", "bs", "params", "conf", "fs", "ims", "aw", "settings", "cs", "stats", "set", "https", "series", "ies", "its", "ins", "wcs", "a", "sam", "os", "st", "ls", "es", "z", "d", "vs", "ps", "acs", "ds", "l", "self", "we", "b", "ess", "ts", "serv", "args", "less", "csv", "source", "conv", "se", "is", "v", "js", "gs", "m", "ssl", "state", "bits", "ges", "parts", "bis", "status", "scl", "er", "ms", "ses", "ss", "aws", "g", "ers", "hs", "services", "sts", "http", "sys", "ats", "err", "space", "sports", "comm", "spec", "sq", "p", "sb", "n", "wa", "y", "c", "sh", "as", "sw", "t", "ns", "Ws", "changes", "sv", "qs", "h", "sg", "S", "als", "ex"], "w": ["wh", "wo", "nw", "q", "write", "mm", "wat", "rs", "fw", "iw", "word", "wine", "web", "d", "rew", "wb", "tw", "wa", "rw", "y", "wed", "ww", "self", "W", "ht", "aw", "we", "l", "wt", "wp", "c", "ow", "sw", "kw", "warning", "wr", "t", "saw", "g", "watch", "ns", "wi", "ew", "Ws", "window", "writer", "work", "wcs", "cam", "wal", "mem", "h", "x", "wl", "hw", "words", "way", "lang", "wx", "ex", "f", "v"], "cbp_index": ["cbp_status", "cbpy_server", "cbpt_value", "cbptindex", "cbpatkey", "cbp_server", "cbp_handle", "cbp_entry", "cbpatindex", "cbpd_entry", "cbpy_status", "cbpd_handle", "cbpati", "cbpa_i", "cbpa_index", "cbp_i", "cbpd_index", "cbpatIndex", "cbpti", "cbpt_ind", "cbp_seed", "cbpy_num", "cbpt_position", "cbpt_size", "cbp_ind", "cbpt_seed", "cbpt_index", "cbp_key", "cbp_Index", "cbpd_zero", "cbp_size", "cbpa_Index", "cbptkey", "cbp_value", "cbp_zero", "cbp_num", "cbptIndex", "cbpy_index", "cbp_position", "cbpa_key"], "map": ["m", "check", "list", "wrap", "bridge", "pack", "mm", "add", "table", "ape", "transform", "bar", "export", "pad", "conf", "master", "def", "tree", "cache", "copy", "scale", "mg", "test", "dict", "load", "show", "config", "tap", "app", "Map", "print", "maps", "size", "set", "match", "age", "link", "ap", "hash", "window", "snap", "code", "view", "index", "filter", "mask", "MAP", " Map", "down", "save", "cap", "block", "clear", "use", "le", "v", "menu"]}}
{"project": "FFmpeg", "commit_id": "a494792961a08f9f0e47e7eeed65e609178ff436", "target": 1, "func": "static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,\n\n                       const int inc, void *y_tab)\n\n{\n\n    int i;\n\n    uint8_t *y_table = y_tab;\n\n\n\n    y_table -= elemsize * (inc >> 9);\n\n\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n\n        table[i] = y_table + elemsize * (cb >> 16);\n\n    }\n\n}\n", "idx": 21583, "substitutes": {"table": ["list", "try", "public", "file", "state", "entry", "tr", "database", "master", "stable", "able", "tree", "module", "cache", "result", "tab", "header", "empty", "map", "set", "db", "buffer", "page", "variable", "total", "store", "window", "Table", "code", "article", "row", "TABLE", "all", "source", "interface", "index", "batch", "private", "array", "block", "final"], "elemsize": ["eleMSize", "Elecsizer", "Elecsize", "elemesize", "elmsiz", "elemsze", "elemsizes", " eleminscale", "elecsize", "elemersize", "elecsocket", "elecsiz", "elemsime", "elecsizes", "elemesizes", "eleminsize", " eleminsize", "elemsocket", "elminsizer", " eleminsizer", "eleminsime", "elemersizer", "eleminsiz", " eleminsime", "Elemsze", "elmsizer", " elemsime", "Elemsizer", "Elemsizes", "elemscale", "eleminsocket", "elemesizer", "elmsize", " elemscale", "elemersizes", "eleminsizer", "eleminscale", "elecsze", "elecsizer", "elemesime", "elminsize", "elminsocket", "elelemsize", "eleMSizer", "elmsocket", "Elemsize", "elelemsime", "elemescale", " elemsizer", "elelemsizer", "Elecsizes", "Elecsze", "elemsizer", "eleMSocket", "elminsiz", "elemesze", "elelemscale", "elemsiz", "elemersze", "eleMSiz"], "inc": ["ac", "acc", "pack", "inv", "exc", "add", "alpha", "conf", "Inc", "up", "include", "incre", "includes", "disc", "sc", "cc", "ext", "pl", "amount", "init", "vol", "asc", "inf", "occ", "fc", "iter", "enc", "ec", "in", "gain", "integ", "sum", "frac", " INC", "ref", "ins", "desc", "resp", "ipl", "ind", "rec", "INC", "err", "circ"], "y_tab": ["my_tab", "yjbuf", "yjtab", "y_list", "y_buf", "y_ab", "ytbuf", "y2Tab", "my_table", " y_Tab", "my_list", "yjlist", "ytlist", "y2tab", "y2table", "yjtable", "y_Tab", "y2ab", "my_buf", "yttab", "yttable", " y_ab"], "i": ["hi", "m", "ci", "ix", "q", "p", "id", "si", "multi", "zi", "span", "n", "ei", "y", "it", "xi", "ims", "init", "ij", "ti", "mi", "chain", "qi", "iu", "b", "j", "iter", "di", "in", "\u0438", "ai", "t", "im", " ii", "g", "gi", "phi", "ic", "li", "ui", "fi", "ip", "sim", "cli", "is", "ji", "ini", "bi", "ind", "oi", "index", "ii", "x", "pi", "batch", "asi", "I", "f", "ki", "v"], "y_table": ["my_tab", "y_cache", " y_t", "my_master", "y_TABLE", "my_TABLE", "y__tab", "y_t", "yPtab", "y__cache", "y_buffer", "y__top", "y__table", "my_top", "my_table", "my_cache", "yPtable", "y_master", "y_top", " y_buffer", "yPmaster", "yPTABLE"]}}
{"project": "FFmpeg", "commit_id": "f3e5a7844bbf13620ca4b6a5e19aa087c9141b15", "target": 0, "func": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        if (alac->sample_size == 16) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 21584, "substitutes": {"alac": ["altacc", "aljac", "malacc", "elAc", "relAc", "haliac", "aliiac", "aldacon", "balAc", "balact", "alifc", "placc", "altac", "alliac", "alerac", " alAC", " alacc", "alact", "stalacon", "eljac", "elljac", "alAC", "allaca", "alAc", "aldcam", "balcache", "alljac", "malace", "aleraca", "halac", "malcache", "aliace", "alacs", "altfc", "malacon", "relac", "ellAC", " alAc", " alace", "malacs", "aliacet", "aliaca", "alacer", "aldAC", "allAC", "balace", "altacon", "aliAc", "balac", "stalaca", "aldacet", "ellacc", "allac", "alace", "alijac", "aldac", "malac", "malact", "altaca", "stalcam", "allacc", "alicache", " alacet", "alcache", "alerica", "aliacc", "balacer", "placs", "stalAc", "aliacer", "placon", "talacs", "relaca", "talacon", "alacc", "halacc", "alacet", "aliAC", "aldacs", "ellac", "allAc", "haljac", "malacer", "elAC", "talac", "altacs", " aljac", "malAc", "alcam", "aliac", "elac", "aliica", "alaca", "aliact", "alerfc", "plac", "stalac", "alfc", "alacon", "talcam", " alacer", "stalacs", "altica", "alica"], "ch": ["cor", "Ch", "conf", " sc", "conn", "cht", "chip", "chain", "cs", " ex", "chrom", " cur", "CH", "cur", "client", "unch", "ind", " c", "x", " batch", "chan", "cell", "cp", "zh", "ih", " channel", "unk", "qu", "cl", "ht", "bh", "col", "sch", "ach", " th", "quant", " col", "wh", "mk", "chart", "ich", "ech", " cho", "history", "gr", "atch", "ek", "msg", "channel", "el", "hl", "batch", "tch", " cha", "th", " y", "kh", "chron", " cs", "och", "chn", "ca", "y", "pl", "sh", "c", " sch", " chip", "bt", "gh", "i", "go", " h", "cho", "bg", "chat", "out", "h", "sk"]}}
{"project": "FFmpeg", "commit_id": "83fd377c94d8fbffdb3e69fb3efe1976ff897a88", "target": 0, "func": "static int put_cod(Jpeg2000EncoderContext *s)\n\n{\n\n    Jpeg2000CodingStyle *codsty = &s->codsty;\n\n\n\n    if (s->buf_end - s->buf < 14)\n\n        return -1;\n\n\n\n    bytestream_put_be16(&s->buf, JPEG2000_COD);\n\n    bytestream_put_be16(&s->buf, 12); // Lcod\n\n    bytestream_put_byte(&s->buf, 0);  // Scod\n\n    // SGcod\n\n    bytestream_put_byte(&s->buf, 0); // progression level\n\n    bytestream_put_be16(&s->buf, 1); // num of layers\n\n    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){\n\n        bytestream_put_byte(&s->buf, 2); // ICT\n\n    }else{\n\n        bytestream_put_byte(&s->buf, 0); // unspecified\n\n    }\n\n    // SPcod\n\n    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height\n\n    bytestream_put_byte(&s->buf, 0); // cblk style\n\n    bytestream_put_byte(&s->buf, codsty->transform); // transformation\n\n    return 0;\n\n}\n", "idx": 21585, "substitutes": {"s": ["js", "gs", "m", "tes", "ls", "sq", "es", "o", "bs", "rs", "events", "params", "details", "ads", "conf", "gins", "times", "sb", "vs", "gets", "ties", "n", "bis", "ps", "eps", "fs", "acs", "ims", "ds", "has", "ms", "b", "c", "cs", "ess", "as", "ts", "ses", "serv", "ss", "stats", "results", "aws", "less", "g", "ns", "its", "changes", "ers", "hs", "a", "e", "sts", "sv", "qs", "xs", "sys", "ats", "se", "os", "h", "S", "als", "ops", "ars", "is", "sports", "comm"], "codsty": ["condstri", "cvestyle", "Codstyle", " codestyles", "codeso", "codstyle", "odestyle", "condstyle", " codstyle", "codstri", "odstra", "odsty", " copfo", "odstyle", " codusr", "labstra", "odfo", "labusr", "codesty", " copsty", " codfo", "codstro", " codstri", "codstra", "labsty", "odstro", " copstyle", "cvso", "condfo", "rodsty", "Codestyle", " copstro", "Codsty", "codso", "rodusr", "odstri", "odso", "rodstyle", "labestyle", "Codusr", " codstra", "cvstyle", " codestyle", "codestyle", "codestyles", "codeestyle", "odestyles", "odusr", "codusr", "rodestyles", "condsty", "cvsty", "codfo", " codstro"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n", "idx": 21612, "substitutes": {"mr": ["hr", "m", "kr", "mm", "adr", "rs", "mk", "pr", "tr", "mn", "RM", "pm", "MT", "br", "Mr", "rn", "hm", "tm", "ocr", "ms", "lr", "bm", "r", "wr", "dr", "drm", "rar", "vr", "asm", "ml", "rpm", "sr", "irm", "MR", "rl", "rr", "rm", "nr", "mt"], "addr": ["ha", "oad", "ix", "arp", "add", "alias", "id", "pad", "ag", "ptr", "ld", "ace", "url", "wid", "offset", "attr", "rt", "address", "r", "ow", "tx", "ord", "node", "host", "dr", "act", "map", "res", "ip", "ref", "var", "align", "hash", "work", "sha", "eth", "coord", "arr", "hw", "ad", "ack"], "size": ["ty", "ci", "sq", "z", "type", "SIZE", "length", "scale", "Size", "bytes", "needed", "offset", "style", "max", "mode", "sh", "cs", "address", "storage", "sym", " sizes", "sum", "owner", "gz", "area", "count", "len", "sha", "code", "ram", "mem", "ize", "fee", "alloc", "dim", "st", "sd", "iz", "sy"], "client": ["ctx", "m", "public", "contact", "parent", "file", "name", "manager", "id", "port", "util", "cache", "conn", "ient", "confirmed", "self", "address", "connected", "node", "server", "owner", "t", "net", "buffer", "et", "cli", "sim", "window", "socket", "ping", "con", "obj", "null", "local", "connection", "new", "Client", "block", "cell"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n    int ret;\n\n\n\n    ret = bdrv_get_info(bs, &bdi);\n\n    if (ret < 0 || bdi.cluster_size == 0) {\n\n        return bs->request_alignment;\n\n    } else {\n\n        return bdi.cluster_size;\n\n    }\n\n}\n", "idx": 21622, "substitutes": {"bs": ["gs", "ls", "bb", "rs", "bits", "bc", "bes", "sb", "vs", "bp", "bis", "ps", "ab", "fs", "blocks", "ds", "b", "ms", "s", "cs", "bm", "iss", "ses", "ts", "bt", "ss", "bles", "bh", "bl", "BS", "ubs", "ns", "cks", "pb", "its", "ks", "bps", "bi", "obs", "sts", "bf", "bos", "lbs", "bas", "is"], "bdi": ["cini", "abni", "bddi", "abci", "dini", "bbci", "ddi", "bmzi", "bdci", "bini", "bmidi", "bbidi", "bzi", "bdidi", "wbci", "bmdi", "bidi", "bbdi", "abidi", "bni", "wbidi", "dci", "bci", "wbni", "bdzi", "abzi", "cidi", "cci", "jci", "wbdi", "abdi", "didi", "jidi", "cdi", " bidi", " bni", " bini", "jdi", " bci", "bmci"], "ret": ["reset", "ert", "cert", "alt", "ter", "Return", "tr", "Ret", "vet", "it", "red", "rem", "ext", "status", "bit", "inter", "att", "result", " Ret", "rt", "ry", "r", "lit", "iter", "nt", "deg", "sat", "cmd", "print", "t", "ft", "det", "res", "set", "oret", "sub", "et", "re", "back", "out", "rets", "gt", "usr", "err", "elt", "RET", "ount", "mt", "f", "cont", "v", "val"]}}
{"project": "FFmpeg", "commit_id": "40cf1bbacc6220a0aa6bed5c331871d43f9ce370", "target": 0, "func": "static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                                        const AVFrame *frame, int *got_packet)\n\n{\n\n    int enc_size = 0;\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroEncoder *encoder = p_schro_params->encoder;\n\n    struct FFSchroEncodedFrame *p_frame_output = NULL;\n\n    int go = 1;\n\n    SchroBuffer *enc_buf;\n\n    int presentation_frame;\n\n    int parse_code;\n\n    int last_frame_in_sequence = 0;\n\n    int pkt_size, ret;\n\n\n\n    if (!frame) {\n\n        /* Push end of sequence if not already signalled. */\n\n        if (!p_schro_params->eos_signalled) {\n\n            schro_encoder_end_of_stream(encoder);\n\n            p_schro_params->eos_signalled = 1;\n\n        }\n\n    } else {\n\n        /* Allocate frame data to schro input buffer. */\n\n        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);\n\n        if (!in_frame)\n\n            return AVERROR(ENOMEM);\n\n        /* Load next frame. */\n\n        schro_encoder_push_frame(encoder, in_frame);\n\n    }\n\n\n\n    if (p_schro_params->eos_pulled)\n\n        go = 0;\n\n\n\n    /* Now check to see if we have any output from the encoder. */\n\n    while (go) {\n\n        int err;\n\n        SchroStateEnum state;\n\n        state = schro_encoder_wait(encoder);\n\n        switch (state) {\n\n        case SCHRO_STATE_HAVE_BUFFER:\n\n        case SCHRO_STATE_END_OF_STREAM:\n\n            enc_buf = schro_encoder_pull(encoder, &presentation_frame);\n\n            if (enc_buf->length <= 0)\n\n                return AVERROR_BUG;\n\n            parse_code = enc_buf->data[4];\n\n\n\n            /* All non-frame data is prepended to actual frame data to\n\n             * be able to set the pts correctly. So we don't write data\n\n             * to the frame output queue until we actually have a frame\n\n             */\n\n            if ((err = av_reallocp(&p_schro_params->enc_buf,\n\n                                   p_schro_params->enc_buf_size +\n\n                                   enc_buf->length)) < 0) {\n\n                p_schro_params->enc_buf_size = 0;\n\n                return err;\n\n            }\n\n\n\n            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,\n\n                   enc_buf->data, enc_buf->length);\n\n            p_schro_params->enc_buf_size += enc_buf->length;\n\n\n\n\n\n            if (state == SCHRO_STATE_END_OF_STREAM) {\n\n                p_schro_params->eos_pulled = 1;\n\n                go = 0;\n\n            }\n\n\n\n            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {\n\n                schro_buffer_unref(enc_buf);\n\n                break;\n\n            }\n\n\n\n            /* Create output frame. */\n\n            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));\n\n            if (!p_frame_output)\n\n                return AVERROR(ENOMEM);\n\n            /* Set output data. */\n\n            p_frame_output->size     = p_schro_params->enc_buf_size;\n\n            p_frame_output->p_encbuf = p_schro_params->enc_buf;\n\n            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&\n\n                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))\n\n                p_frame_output->key_frame = 1;\n\n\n\n            /* Parse the coded frame number from the bitstream. Bytes 14\n\n             * through 17 represesent the frame number. */\n\n            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);\n\n\n\n            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,\n\n                                     p_frame_output);\n\n            p_schro_params->enc_buf_size = 0;\n\n            p_schro_params->enc_buf      = NULL;\n\n\n\n            schro_buffer_unref(enc_buf);\n\n\n\n            break;\n\n\n\n        case SCHRO_STATE_NEED_FRAME:\n\n            go = 0;\n\n            break;\n\n\n\n        case SCHRO_STATE_AGAIN:\n\n            break;\n\n\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown Schro Encoder state\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* Copy 'next' frame in queue. */\n\n\n\n    if (p_schro_params->enc_frame_queue.size == 1 &&\n\n        p_schro_params->eos_pulled)\n\n        last_frame_in_sequence = 1;\n\n\n\n    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);\n\n\n\n    if (!p_frame_output)\n\n        return 0;\n\n\n\n    pkt_size = p_frame_output->size;\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n\n        pkt_size += p_schro_params->enc_buf_size;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", pkt_size);\n\n        goto error;\n\n    }\n\n\n\n    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n\n    avctx->coded_frame->key_frame = p_frame_output->key_frame;\n\n    /* Use the frame number of the encoded frame as the pts. It is OK to\n\n     * do so since Dirac is a constant frame rate codec. It expects input\n\n     * to be of constant frame rate. */\n\n    pkt->pts =\n\n    avctx->coded_frame->pts = p_frame_output->frame_num;\n\n    pkt->dts = p_schro_params->dts++;\n\n    enc_size = p_frame_output->size;\n\n\n\n    /* Append the end of sequence information to the last frame in the\n\n     * sequence. */\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n\n        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n\n               p_schro_params->enc_buf_size);\n\n        enc_size += p_schro_params->enc_buf_size;\n\n        av_freep(&p_schro_params->enc_buf);\n\n        p_schro_params->enc_buf_size = 0;\n\n    }\n\n\n\n    if (p_frame_output->key_frame)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\nerror:\n\n    /* free frame */\n\n    libschroedinger_free_frame(p_frame_output);\n\n    return ret;\n\n}\n", "idx": 21641, "substitutes": {"avctx": ["afctl", " avconn", " avctl", "aftx", "abctx", "svcontext", " avcontext", "abtx", "afcontext", "avconn", "abcontext", "cvcontext", "cvconn", "abconn", "svconn", "apctx", "afctx", "avcontext", "svctx", "apctl", "avctl", "svtx", " avtx", "aptx", "cvtx", "cvctx", "apcontext", "avtx"], "pkt": ["ppdu", "cpdu", "cpacket", " pqt", "pdu", "ppkt", "ppqt", " packet", "packet", "ppacket", "cpkt", " pdu", "pqt", "cpqt"], "frame": [" Frame", "face", "close", "profile", "scene", "iframe", "data", "one", "fw", "word", "image", "forced", " framed", "allowed", "fr", "feat", "chain", "hello", "Frame", "fram", "feature", "show", "info", "ence", "ce", " timeframe", "message", "error", "rame", "window", "process", "channel", "event", "frames", "instance", "row", "code", "none", "context", "flow", "time", "cf", "part", "fb", "AME", "sequence", "block", "f", "trace"], "got_packet": ["got_compacket", "got_packacket", "got_ppacket", "got_ppet", "got_packET", "got_buckacket", "got_compET", "got_ppET", "got_compet", "got_buckET", "got_packed", "got_bucked", "got_bucket", "got_comped", "got_pped"], "p_schro_params": ["p_schrojparams", "p_schro_errors", "p_schacocams", "p_schroproparams", "p_schrob_params", "p_schrocparams", "p_schro__marks", "p_schro_ctx", "p_schlo_points", "p_schrob_args", "p_schaco_params", "p_schrocmodules", "p_schlo_ops", "p_schlo_args", "p_schro3params", "p_schro__data", "p_schra__ctx", "p_schro_pins", "p_schrosparams", "p_schro_ams", "p_schroptconf", "p_schro_ops", "p_ch_", "p_schro_names", "p_schro__ops", "p_schros_names", "p_schroprodata", "p_schrob_ams", "p_schro_args", "p_schrospins", "p_schros_args", "p_schro__ctx", "p_schro3ams", "p_schra__data", "p_schaco_modules", "p_schro2data", "p_schro__errors", "p_schrob_pins", "p_schrocams", "p_schra_data", "p_schrosargs", "p_schra_ctx", "p_schrojmarks", "p_schroptams", "p_schro2ams", "p_schros_ops", "p2ch_", "p_schlo_params", "p_schacocparam", "p_schro2args", "p_schra__params", "p_schroproams", "p_schrojops", "p_schroptcaps", "p_schlo_marks", "p_schro2ctx", "p_schlo_ams", "p_schros_ams", "p_schacocmodules", "p_schro__params", "p_schra_ams", "p_schrojerrors", "p_schro_conf", "p_schrob_mode", "p_schro_modules", "p_schro2ops", "p_schra_params", "p_schro_param", "p_schro3pins", "p_schro_points", "p_schrosams", "p_schros_params", "p_schroptparams", "p_schro_marks", "p_her_", "p_schrob_data", "p_schro2params", "p_schro_mode", "p_schro_data", "p_sch_", "p_schacocparams", "p_schaco_ams", "p_schropromode", "p_schro__ams", "p_schros_conf", "p_schlo_errors", "p_schro3args", "p_schro_caps", "p_schros_caps", "p2sch_", "p_schra__ams", "p_Sch_", "p_schaco_param", "p_schro__args", "p_schrocparam"], "encoder": ["encressor", "ecuter", "ecramer", "encoding", "ecater", "esccer", "escoder", "ecoe", "encer", "fcamer", "enamer", "ecoding", "encener", "escoding", "fcener", " encramer", "escoe", "eccer", "encator", "enater", "ecoser", "enramer", "ecator", "enccer", "enator", "Encressor", "escamer", "encramer", "ecoded", "encamer", "ecoder", "encoser", " encater", " encoded", "enoded", "ecressor", "eniever", "fccer", "encoe", "enoder", "enciever", " encator", "eciever", " enccer", "enoding", " encuter", "encuter", "encater", "enressor", "enoser", "encoded", "enener", "Encoder", "Enciever", "enoe", "escener", "enuter", "fcoder", "ecamer", "Encoser"], "p_frame_output": ["p_frame2out", "p_channel_output", "p_frame_input", "p_channel_input", "p_frame2data", "p_frame_data", "p_frame2output", "p_frame2input", "p_channel_out", "p_channel_data", "p_frame_out"], "enc_buf": ["dec_vec", " enc2buf", " enc_br", "enc_bag", "enc2uf", "enc2buf", "encMemdata", "enc_uf", "ENC_data", "ec_max", "encockbuf", "ec_buffer", "dec_buf", "encockuf", "ec_bag", "enc64buffer", "enc_data", "ENC_msg", "enc64pkg", "encMembuf", "enc_func", "encablebuf", "enc_vec", "enc64buf", "abc_buf", "abcablebuf", "enc_bu", "ec_cb", " enc_cv", " enc_buffer", "enc2vec", "encablefunc", "ENC_buff", "dec2buff", "dec2vec", "dec_buffer", "abcablefunc", "enc_cv", " enc_code", " enc_vec", "enc_max", "enc_br", "enc_msg", "encockbag", "ENC_buf", " enc2br", "enc_buffer", "abc_bu", "enc64bu", "enc2queue", "enc_pkg", " enc_uf", " enc2queue", "enc2pkg", "enc64func", " enc2buffer", "abc_func", "enc_buff", "dec2buf", "dec_buff", " enc_buff", "enc_cb", "enc2buff", "encMembuff", "encablebu", "enc64queue", "enc_code", "dec2buffer", "enc_queue", "enc2br", "encMemmsg", "encockbuffer", "enc2buffer", "ec_buf", "enc64br", "abcablebu", "ec_uf", "ec_pkg", " enc_queue"], "presentation_frame": ["presentATION_info", "presentation_event", "presentation_flow", "presentation____flow", "presentation_info", "presentation____frames", "presentATION_event", "presentation____info", "presentation____component", "presentation____event", "presentation____frame", "presentATION_frames", "presentation_component", "presentATION_frame", "presentATION_component", "presentATION_flow", "presentation_frames"], "parse_code": ["parse2error", "parse_error", "parse___error", "parseabledata", "parse_message", "se_codes", "parse_data", "parse___codes", "parse_codes", " parse_codes", "parse2data", "parseableerror", "parseablecodes", "parse2codes", " parse_message", "se_code", "parseablecode", "parse2code", " parse_error", "parse___code", "se_error", "se_data", "parse___message"], "pkt_size": ["packet_size", "packet_len", "pkt_len", "pkt_fee", "packet_fee", "pkt_name", "packet_name"], "ret": ["gc", "reset", "big", "Ret", "jp", "fin", "result", "info", "flag", "cmd", "format", "args", "res", "fi", "txt", "ref", "resp", "out", "len", "mem", "gt", "new", "RET", "val"], "in_frame": ["in67message", " in_Frame", "any_frame", "in67row", "in_message", " in_time", " in_sample", "any_message", "inmybody", "inOneFrame", "inmysample", "inOneframe", "in_sample", "in_body", "in_row", "any_row", "in_time", " in_stream", "inmyFrame", "in_Frame", "any67Frame", "any_Frame", "any67frame", "in67frame", "inmyframe", "inOnebody", "any67row", "in_stream", "inOnesample", " in_body", "in67Frame", "any67message"], "err": ["ror", "cfg", "cr", "try", "inner", "kr", "mr", "pr", "cer", "or", "req", "conf", "notice", "br", "fr", "it", "rn", "attr", "er", "r", "iter", "cmd", "order", "act", "res", "error", "gz", "rb", "vr", "msg", "ner", "txt", "count", "resp", "buf", "out", "code", "bug", "e", "obj", "ch", "ach", "usr", "h", "arr", "str", "Er", "rr", "Error", "die", "nr", "cb", "val"], "state": ["m", "list", "success", "start", "State", "name", "type", "debug", "can", "tag", "to", "states", "it", "test", "init", "status", "has", "style", "result", "info", "mode", "lock", "kind", "r", "scope", "no", "STATE", "go", "print", "t", "loop", "active", "error", "reg", "area", "from", "where", "key", "msg", "stat", "count", "store", "next", "al", "event", "code", "policy", "str", "index", "st", "commit", "progress", "ne", "clear", "trace", "zone"]}}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int fill_default_ref_list(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n    int smallest_poc_greater_than_current = -1;\n\n    int structure_sel;\n\n    Picture sorted_short_ref[32];\n\n    Picture field_entry_list[2][32];\n\n    Picture *frame_list[2];\n\n\n\n    if (FIELD_PICTURE) {\n\n        structure_sel = PICT_FRAME;\n\n        frame_list[0] = field_entry_list[0];\n\n        frame_list[1] = field_entry_list[1];\n\n    } else {\n\n        structure_sel = 0;\n\n        frame_list[0] = h->default_ref_list[0];\n\n        frame_list[1] = h->default_ref_list[1];\n\n    }\n\n\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        int list;\n\n        int len[2];\n\n        int short_len[2];\n\n        int out_i;\n\n        int limit= INT_MIN;\n\n\n\n        /* sort frame according to POC in B slice */\n\n        for(out_i=0; out_i<h->short_ref_count; out_i++){\n\n            int best_i=INT_MIN;\n\n            int best_poc=INT_MAX;\n\n\n\n            for(i=0; i<h->short_ref_count; i++){\n\n                const int poc= h->short_ref[i]->poc;\n\n                if(poc > limit && poc < best_poc){\n\n                    best_poc= poc;\n\n                    best_i= i;\n\n                }\n\n            }\n\n\n\n            assert(best_i != INT_MIN);\n\n\n\n            limit= best_poc;\n\n            sorted_short_ref[out_i]= *h->short_ref[best_i];\n\n            tprintf(h->s.avctx, \"sorted poc: %d->%d poc:%d fn:%d\\n\", best_i, out_i, sorted_short_ref[out_i].poc, sorted_short_ref[out_i].frame_num);\n\n            if (-1 == smallest_poc_greater_than_current) {\n\n                if (h->short_ref[best_i]->poc >= s->current_picture_ptr->poc) {\n\n                    smallest_poc_greater_than_current = out_i;\n\n                }\n\n            }\n\n        }\n\n\n\n        tprintf(h->s.avctx, \"current poc: %d, smallest_poc_greater_than_current: %d\\n\", s->current_picture_ptr->poc, smallest_poc_greater_than_current);\n\n\n\n        // find the largest POC\n\n        for(list=0; list<2; list++){\n\n            int index = 0;\n\n            int j= -99;\n\n            int step= list ? -1 : 1;\n\n\n\n            for(i=0; i<h->short_ref_count && index < h->ref_count[list]; i++, j+=step) {\n\n                int sel;\n\n                while(j<0 || j>= h->short_ref_count){\n\n                    if(j != -99 && step == (list ? -1 : 1))\n\n                        return -1;\n\n                    step = -step;\n\n                    j= smallest_poc_greater_than_current + (step>>1);\n\n                }\n\n                sel = sorted_short_ref[j].reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n                frame_list[list][index  ]= sorted_short_ref[j];\n\n                frame_list[list][index++].pic_id= sorted_short_ref[j].frame_num;\n\n            }\n\n            short_len[list] = index;\n\n\n\n            for(i = 0; i < 16 && index < h->ref_count[ list ]; i++){\n\n                int sel;\n\n                if(h->long_ref[i] == NULL) continue;\n\n                sel = h->long_ref[i]->reference | structure_sel;\n\n                if(sel != PICT_FRAME) continue;\n\n\n\n                frame_list[ list ][index  ]= *h->long_ref[i];\n\n                frame_list[ list ][index++].pic_id= i;\n\n            }\n\n            len[list] = index;\n\n        }\n\n\n\n        for(list=0; list<2; list++){\n\n            if (FIELD_PICTURE)\n\n                len[list] = split_field_ref_list(h->default_ref_list[list],\n\n                                                 h->ref_count[list],\n\n                                                 frame_list[list],\n\n                                                 len[list],\n\n                                                 s->picture_structure,\n\n                                                 short_len[list]);\n\n\n\n            // swap the two first elements of L1 when L0 and L1 are identical\n\n            if(list && len[0] > 1 && len[0] == len[1])\n\n                for(i=0; h->default_ref_list[0][i].data[0] == h->default_ref_list[1][i].data[0]; i++)\n\n                    if(i == len[0]){\n\n                        FFSWAP(Picture, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n                        break;\n\n                    }\n\n\n\n            if(len[list] < h->ref_count[ list ])\n\n                memset(&h->default_ref_list[list][len[list]], 0, sizeof(Picture)*(h->ref_count[ list ] - len[list]));\n\n        }\n\n\n\n\n\n    }else{\n\n        int index=0;\n\n        int short_len;\n\n        for(i=0; i<h->short_ref_count; i++){\n\n            int sel;\n\n            sel = h->short_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->short_ref[i];\n\n            frame_list[0][index++].pic_id= h->short_ref[i]->frame_num;\n\n        }\n\n        short_len = index;\n\n        for(i = 0; i < 16; i++){\n\n            int sel;\n\n            if(h->long_ref[i] == NULL) continue;\n\n            sel = h->long_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->long_ref[i];\n\n            frame_list[0][index++].pic_id= i;\n\n        }\n\n\n\n        if (FIELD_PICTURE)\n\n            index = split_field_ref_list(h->default_ref_list[0],\n\n                                         h->ref_count[0], frame_list[0],\n\n                                         index, s->picture_structure,\n\n                                         short_len);\n\n\n\n        if(index < h->ref_count[0])\n\n            memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));\n\n    }\n\n#ifdef TRACE\n\n    for (i=0; i<h->ref_count[0]; i++) {\n\n        tprintf(h->s.avctx, \"List0: %s fn:%d 0x%p\\n\", (h->default_ref_list[0][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[0][i].pic_id, h->default_ref_list[0][i].data[0]);\n\n    }\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        for (i=0; i<h->ref_count[1]; i++) {\n\n            tprintf(h->s.avctx, \"List1: %s fn:%d 0x%p\\n\", (h->default_ref_list[1][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[1][i].pic_id, h->default_ref_list[1][i].data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 21665, "substitutes": {"h": ["m", "kh", "this", "q", "p", "zh", "o", "hz", "z", "here", "HH", "oh", "ih", "w", "cache", "ah", "ph", "y", "hm", "it", "each", "has", "ht", "hd", "b", "dh", "rh", "c", "sh", "history", "he", "header", "eh", "j", "sw", "host", "bh", "H", "k", "g", "hp", "her", "hash", "event", "hs", "hh", "hal", "hl", "handle", "ch", "http", "mem", "hw", "th", "f", "v", "comm"], "s": ["js", "gs", "m", "spec", "ls", "p", "es", "rs", " ts", "w", "d", "sb", "ps", "src", "sc", "ab", "css", "fs", "acs", "ims", "ds", "scl", "b", "ms", "c", "cs", "an", "cpp", "as", "sh", "sw", "ses", "ts", "serv", "ss", "stats", "t", "aus", "aws", "g", "u", "ns", "session", "ap", "wcs", "hs", "a", "e", "sts", "conv", "sv", "sys", "ats", "os", " fs", "S", " inputs", "f", "v", "comm"], "i": ["hi", "m", "me", "ci", "ix", "p", "us", "z", "id", "si", "zi", "multi", "ori", "n", "y", "it", "xi", "l", "ij", "init", "chain", "mi", "ti", "qi", "iu", "info", "j", "iter", "di", "in", "ir", "go", "\u0438", "ai", "t", "im", "remote", "point", "k", "g", "uri", "gi", "phi", "ui", "li", "ic", "key", "ip", "cli", "ri", "ji", "instance", "ini", "bi", "ind", "e", "index", "ii", "x", "pi", "batch", "I", "ia", "ami", "ex", "f", "ki", "v"], "structure_sel": ["struction_Sel", "struction_num", "structure__sel", "structure__ser", "struction_ser", "structure_ls", "structure2sels", "structure_Sel", "structure_selected", "struction_sels", "struction2ser", "struction2ls", "struction2sel", "struction2sels", "structure2ls", "struction_selected", "structure_select", "structure__sels", "struction_ls", "structure2ser", "struction_select", "structure_num", "structure_ser", "structure2sel", "structure_sels", "struction_sel", "structure__ls"], "sorted_short_ref": ["sorted_short2val", "sorted_short_rel", "sorted_shortlyarg", "sorted_long_arg", "sorted_short2rel", "sorted_long_rel", "sorted_short_mem", "sorted_short_arg", "sorted_short_val", "sorted_short_map", "sorted_long_mem", "sorted_long_def", "sorted_long_ref", "sorted_short_def", "sorted_short_Ref", "sorted_short2def", "sorted_shortlyref", "sorted_short2mem", "sorted_long_val", "sorted_short2ref", "sorted_shortlyrel", "sorted_shortlymem"], "field_entry_list": ["field_entry2list", "field_def_ref", "field_entryptlist", "field_def_def", "field_entryationdef", "field_entry2name", "field_element_top", "field_entryationlist", "field_entry_ref", "field_element_list", "field_entry_def", "field_entry_type", "field_elementpttop", "field_entry_entry", "field_entry2ref", "field_entry_name", "field_entryingdef", "field_entry_sequence", "field_entry2type", "field_entryptsequence", "field_entry_dict", "field_elementptdef", "field_element_sequence", "field_def_dict", "field_def_entry", "field_elementptsequence", "field_element_def", "field_entrypttop", "field_entryingentry", "field_entryingdict", "field_entryationtop", "field_entryationsequence", "field_def_list", "field_entry_top", "field_def_name", "field_entryptdef", "field_def_type", "field_elementptlist", "field_entryinglist"], "frame_list": ["profilelistlist", "profilelisttree", "frameaclist", " frame_lists", "profile_list", "frameListpath", "frameListlist", "Frame_pair", "frame_pair", "frame_tree", "frame___pair", "field_cache", "frameListpair", "frameListtree", "frameableref", "profilelistlists", "frameSetlist", "frameListlists", "profilelistpair", "Frame_path", "fieldaclist", "frame___lists", "Frame_lists", "frameListcode", "frameabledef", "frame_cache", "framelistlists", " frame_def", "framelisttree", "framelistlist", "frame_code", "Frame_list", "field_code", "frameactree", "frameaccache", " frame_ref", "window_lists", "frameablelist", "window_pair", "profile_tree", "frameListcache", "frame_lists", "frameaccode", "frame___tree", "fieldaccache", "window_list", "framelistpair", "window_tree", "fieldactree", "frameSetlists", "frameablelists", "profile_pair", "field_list", "field_tree", "frame_ref", "frame_path", "frame_def", "frameSetpair", "frameSetpath", "fieldaccode", "profile_lists", "frame___list"], "list": ["spec", "num", "parent", "name", "ist", "conf", "def", "lists", "test", "l", "info", "List", "pair", "LIST", "map", "set", "li", "count", "code", "level", "all", "str", "elist", "array", "st", "table", "val"], "len": ["ls", "fl", "length", "loc", "ln", "lon", "Len", "l", "vl", "fin", "lic", "line", "nl", "lan", "la", "pos", "size", "layer", "en", "li", "el", "ll", "all", "rel", "label", "le"], "short_len": ["short2length", "short_length", "short_list", " short_length", " short_list", "short_ref", "short2len", "short2ref", " short_ref", "short2list"], "out_i": ["OUT_i", "out_is", "outptini", "go_e", "outMemi", "out__iu", "outplaceji", " best0ii", "out_zi", "out_ui", "out_p", "out_ip", "batchYi", "high_i", " best0p", "batchYis", "outplaceli", "out_li", "out0p", "outMemit", "out____i", "outaxyinit", "out_l", "go_ui", "off_ip", "outplacei", "outpti", "out0li", "out_e", "out_I", " best_li", "go_i", "out____ci", "out__i", "outMemli", "off_it", " best_l", "go_iu", "outYis", "out0i", "out____di", "batch_is", "outptI", " out_is", "out_ji", "OUT_li", "batchYinit", " best_p", "outptli", "outaxymulti", "OUT_ini", "outplaceip", "outdevindex", "outdevji", "outplaceis", " out_ji", "out_init", "out__e", "batchYmulti", "out__di", "out0ii", "outaxyis", " best0i", "outplaceit", "out_ii", "out_di", "batch_i", " best0li", "high_di", "off_i", "out_index", "outMemip", "out____ip", "batch_init", "out_ci", "batch_multi", " best_i", " out_index", " best_e", "high_ip", "outaxyi", "outYmulti", "out_ini", " out_iu", " out_di", "out_iu", "outYinit", " out_e", "out_multi", "outYi", "OUT_I", "outdevis", "outplaceindex", " best_ii", "outdevi", "off_li", "out_it", " best_zi", "high_ci"]}}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 21670, "substitutes": {"f": ["af", "lf", "file", "fw", "conf", "um", "fd", "fs", "fn", "ft", "rf", "ge", "F", "bf", "x", "tf", "gc", "uf", "q", "o", "z", "impl", "uint", "d", "ile", "self", "l", "b", "k", "u", "sf", "fb", "fm", "v", "fx", "fo", "ff", "fr", "thread", "r", "g", "fi", "xf", "form", "comp", "exec", "fp", "p", "_", "w", "def", "y", "fa", "c", "fc", "j", "cmd", "func", "t", "buffer", "out", "e", "mem", "h", "cf"], "vmdesc": ["vmddesc", "vMDec", "mmdest", "vcmdeps", "vmadesc", "vamdese", "vmdef", "vsmadesc", "vndesc", " vmanagedef", "vndef", "vMDef", "vbindeg", "mndeg", "vamdest", "vmetesc", "avmdec", "vmdeman", "vmdesp", "vndest", "vmdec", "avmindesc", "mndeker", "vunderella", "vmndesc", "vbindef", " vmanagedesc", "vcmdesc", "vmondew", " vmdef", "vmandesp", "vsmdew", "mndeca", "vndeman", "vndec", "vcdesc", "vndesp", "mnddesc", "vndeker", "avmindpeg", "vmetec", "vmdeca", "vsmadey", "vmindec", "vmondeg", "vamdef", "vundew", "vmdest", " vmanagedest", "vmandec", "vnderella", "wcmdesc", "vcmdec", "vmondef", "vcmdest", "mmdeker", "vmindpeg", "vMDeps", "mmdeca", "vcmderella", "vmdeps", "vMDesc", "mnderella", "vdmec", "avmindec", "vundesc", "vndeps", "vmondesc", "wmdec", "vmdeg", "vsmderella", "vmdey", "vcdeca", "vbindesc", "mndew", "mmderella", "mmdeg", "mmdesc", "mmdeps", "mndesp", "vmanagedest", "vmanderella", "vndpeg", "vmadey", "vndew", "vcmdey", "mndeps", "mmdef", "vmetesp", "avmdpeg", "vmondec", "avmdeman", "vMDest", "vMDeca", "vcmdew", "vmindeman", "vmadew", "vsmdey", "vmderella", "vmanagedese", "vmdeker", "vmanagedesc", "vndeg", "mndest", "mndesc", "mmddesc", "vmdew", "vMDese", "avmindeman", "avmdesc", "vcddesc", "vcmdeker", "vdmeman", " vmdest", "vmanagedef", "vmindesc", "vmdese", "vmnesc", "mmdew", "wmdest", "vnddesc", "vdmesc", "wcmdec", "vmdpeg", "vmnec", "vmeterella", "vmondeker", "wmdeca", "wmdesc", "vmneca", "vamdesc", " vmdese", "vdmpeg", "vmaderella", "vsmdesc", "vbindec", "mmdesp", "vmandesc", "wcmdeca", "vcmdeca", "vcdec", "vsmadew", "wcmdest", "vsmaderella", "vndeca", "vundey", "mndef", "mndec", "mmdec", " vmanagedese"], "vmdesc_len": ["vmdesc_length", "vmdec_ls", "vmdec_Len", "vmdec_length", "vmdec_len", "vmdesc_Len", "vmdesc_ls"], "se": ["so", "ve", "sel", "pe", "sa", "ae", "Se", "sed", "sche", "de", "ge", "ade", "sec", "sle", "use", "ke", "try", "cle", "es", "ide", "esi", "parse", "SE", "esse", "exe", "sis", "we", "ser", "ene", "pse", "ess", "ense", "see", "sem", "sing", "ent", "ele", "me", "ree", "ice", "te", "sea", "si", "ace", "des", "lex", "send", "ses", "ese", "ine", "re", "al", "el", "ase", "sys", "ste", "th", "le", "sq", "entry", "ga", "su", "spe", "sh", "ry", "he", "sw", "ce", "ie", "est", "e", "sv", "sex", "sr", "she", "ne", "ze"], "ret": ["gc", "reset", "num", "success", "sp", "alt", " alt", "tr", "Ret", "vet", "ptr", "fit", "git", "def", "reply", "red", "rem", "status", "att", "fin", "result", " Ret", "fun", "rt", "nl", "fail", "final", "ben", "nt", "deg", "flag", "rat", "ft", "res", "error", " RET", "tn", "msg", "txt", "ref", "re", "resp", "desc", "len", "code", "out", "ll", "ctr", "rets", "after", "gt", "nz", "usr", "str", "tf", "rm", "elt", "err", "RET", "back", "mt", "cb", "val"]}}
{"project": "qemu", "commit_id": "f45cb2f43f5bb0a4122a64e61c746048b59a84ed", "target": 1, "func": "static void mvp_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));\n\n\n\n    /* MVPConf1 implemented, TLB sharable, no gating storage support,\n\n       programmable cache partitioning implemented, number of allocatable\n\n       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs\n\n       implemented, 5 TCs implemented. */\n\n    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |\n\n                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |\n\n// TODO: actually do 2 VPEs.\n\n//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |\n\n//                             (0x04 << CP0MVPC0_PTC);\n\n                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |\n\n                             (0x00 << CP0MVPC0_PTC);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Usermode has no TLB support */\n\n    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);\n\n#endif\n\n\n\n    /* Allocatable CP1 have media extensions, allocatable CP1 have FP support,\n\n       no UDI implemented, no CP2 implemented, 1 CP1 implemented. */\n\n    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |\n\n                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |\n\n                             (0x1 << CP0MVPC1_PCP1);\n\n}\n", "idx": 21694, "substitutes": {"env": ["ctx", "dev", "vv", "equ", "bridge", "eg", "end", "te", "forge", "eb", "export", "ve", "ev", "entry", "manager", "erb", "engine", "here", "w", "esc", "console", "eng", "vs", "ah", "conn", "vm", "oe", "environment", "enter", "nc", "init", "etc", "er", "doc", "worker", "eh", "enc", "query", "ec", "uv", "ef", "En", "server", "db", "rb", "en", "ner", "gate", "open", "EN", "ew", "et", "see", "disk", "window", "buf", "cv", "code", "obj", "e", "el", "ent", "context", "sv", "ee", "ov", "gear", "Environment", "erd", "v"], "def": ["define", "ctx", "dev", "spec", "conf", "definition", "Def", "doc", "DEF", "decl", "du", "kw", "tx", "lit", "ef", "da", " Def", "ded", "det", "pro", "dem", "ref", "vec", "desc", "buf", "form", "crit", "df"]}}
{"project": "FFmpeg", "commit_id": "ae3da0ae5550053583a6f281ea7fd940497ea0d1", "target": 1, "func": "static int decode_band(IVI45DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2, pos;\n\n    IVITile     *tile;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    if (!band->buf) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Band buffer points to no data!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = ctx->decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return result;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i * 2];\n\n        idx2 = band->corr[i * 2 + 1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    pos = get_bits_count(&ctx->gb);\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        if (tile->mb_size != band->mb_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MB sizes mismatch: %d vs. %d\\n\",\n\n                   band->mb_size, tile->mb_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n            if (!tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted tile data encountered!\\n\");\n\n                break;\n\n            }\n\n\n\n            pos += tile->data_size << 3; // skip to next tile\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#ifdef DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return result;\n\n}\n", "idx": 21708, "substitutes": {"ctx": ["cp", "pkg", "gc", "this", "cfg", "grad", "np", "cn", "params", "bc", "conf", "req", "jp", "kt", "unk", "xc", "mt", "tc", "iat", "conn", "cm", "mc", "cc", "nc", "co", "course", "history", "c", "today", "fc", "settings", "lib", "kw", "tx", "config", "buff", "cmd", "org", "act", "comm", "kb", "jac", "cd", "ck", "ang", "std", "resp", "cam", "wcs", "obj", "piece", "context", "conv", "tz", "cu", "sys", "ctr", "cf", "voc", "batch", "hw", "cb", "cmp", "wx", "px", "qq", " cx", "ctl", "cv", "ct"], "plane_num": ["band1num", "band_mon", "band1Num", "plane_no", "band_Num", "plane_Num", "band1no", "band_num", "plane_mon", "band_no", "band1mon"], "band": ["raid", "bands", "bridge", "bb", "and", "pp", "grad", "cast", "bag", "bid", "bin", "camp", "bright", "chain", "decl", "iband", "org", "chrom", "format", "grab", "layer", "need", "ud", "buf", "work", "rad", "bug", "idd", "binary", "bool", "filter", "block", "ogram", "cell", "product", "bed", "command", "mm", "data", "bar", "box", "lag", "unk", "beam", "tag", "ann", "range", "bit", "man", "bm", "buff", "flag", "amp", "fam", "group", "piece", "amber", " bandwidth", "byte", "bd", "art", "bart", "back", "ack", "hub", "report", " cand", "word", "power", " Band", "port", "plugin", "bor", "broad", "plug", "wd", "app", "flash", "patch", "ck", "play", " bands", "form", "display", "batch", "tool", "bank", "prep", "library", "brand", "plot", "dom", "def", "bound", "style", "tab", "light", "Band", "cmd", "road", "burst", "db", "cd", "key", "ang", "disk", "cand", "pair", "bind"], "avctx": ["avetc", "aveca", "wavjac", "avecf", "afcmd", "avercp", " avconn", "navconn", "avewcs", " avctl", " avjac", "afconn", "averctx", "camctx", "averctl", "navcas", " avcc", "wavtc", "afcfg", "avconn", "avca", "avecp", "afcas", "avercmd", "jamctx", "camcu", " avcu", "avcu", "averwcs", "wavctx", "navctx", "afwcs", "navcf", "avercc", "jamjac", "jamtc", "avetx", "avcfg", "avectx", "avpkg", " avcp", "avecc", "avcp", "afctx", "averconn", "afcf", " avca", "avjac", "avcc", "jampkg", "camtx", "avejac", "wavpkg", "avecfg", "averjac", "avtc", "avecu", "avctl", "avecas", "avercfg", "avecmd", "avcas", "avepkg", " avtx", "avectl", "camctl", "avcf", "avcmd", "avwcs", "aveconn", "avtx", "averca"], "result": ["relation", "product", "response", "json", "success", "diff", "contact", "data", "report", "ter", "reason", "tr", "details", "type", "length", "params", "password", "name", "ULT", "complete", " Result", "def", "duration", "value", "definition", "test", "status", "currency", "ret", "chain", "true", "feature", "final", "r", "function", "date", "RESULTS", "results", "res", "error", "message", "match", " res", "goal", "count", "answer", "out", "event", "comment", "different", "mate", "number", "code", "zero", "record", "created", "ger", "new", "Result", "err", "valid", "ult", "were", "term", "rc", "val"], "i": ["hi", "m", "me", "this", "ci", "ix", "p", "q", "id", "si", "multi", "zi", "by", "n", "y", "it", "xi", "l", "status", "ti", "b", "mi", "chain", "qi", "c", "iu", "info", "PI", "j", "di", "in", "\u0438", "im", "ai", "ki", "u", "g", "gi", "phi", "ic", "li", "ui", "series", "ip", "cli", "ri", "out", "ji", "ini", "bi", "ind", "index", "ii", "x", "pi", "h", "I", "ami", "ex", "is", "v"], "t": ["temp", "ta", "ty", "m", " T", "p", "te", "q", "o", "vt", "qt", "at", "td", "tr", "tt", "type", "kt", "ot", "port", "unit", "tc", "tree", "tw", "ant", "n", "y", "dt", "it", "tm", "l", "ht", "ti", "b", "token", "wt", "rt", "c", "task", "tx", "ts", "j", "nt", "T", "pt", "tu", "set", "g", "txt", "total", "tip", "lat", "ent", "title", "x", "tf", "f", "trace", "v"], "idx1": ["fdx1", "fdrx01", "idy1", "idy01", "idz2", "idzOne", " idy2", " idyOne", "fdx2", " idXOne", "idrx01", "idxf2", "idvONE", "idx01", "idv3", "idex2", " idX0", "idx0", " idx0", " idy01", "idxf01", "fdx01", "fdrxONE", "idyOne", "idxONE", "idv2", "idxf1", " idy1", "idx3", " idx3", "idv01", "idex0", " idex0", " idxOne", "idrxONE", "idxOne", "idv0", "idX3", " idex2", "idrx2", "idxfONE", "idXOne", " idx01", "idX1", "idix0", "idX0", "fdrx2", "fdrx1", "idz0", "idex1", " idex1", "idvOne", "idz1", "idy2", "fdxONE", "idz3", " idX3", "idrx1", "idv1", "idix2", " idX1", "idix1", "idz01"], "idx2": ["protxtwo", "idX2", "namex1", "idex02", "idX02", "idixtwo", "protx2", "idxtwo", "proxtwo", "idtx8", "idx12", "idon2", "nameix1", "idtx2", " idy12", "idy2", "idtxtwo", "idv1", "prox10", "idextwo", "idy12", "idt8", "idx8", "idix1", "idxftwo", "idttwo", " idy2", "prox02", "idon102", "prox2", "idon1", "idx02", "idx102", "idix102", "idix12", "idtx10", "idxf8", "idtx02", "idy102", " idx102", "idt2", "namex2", "protx10", "idvtwo", "nameixtwo", " idy1", "prox8", "idx10", "protx8", "idex10", " idy102", " idx12", "nameix2", "idy1", "idxf2", "idX10", "idex2", "idytwo", "idon12", "idXtwo", "idv2", "namextwo", "protx02", "idix2"], "pos": ["pid", "rot", "p", "o", "Pos", "at", "pad", "conf", "loc", "ot", "port", "def", "trans", "ps", "offset", "limit", "doc", "top", "po", "POS", "origin", "point", "pt", "neg", "cond", "pro", "col", "pc", "position", "ref", "total", "pose", "len", "base", "os", "pi", "part", "pres", "val"], "tile": ["face", "texture", "profile", "tier", "stone", "te", "file", "sel", "player", "til", "kt", "pixel", "port", "mat", "image", "tmp", "unit", "trace", "tree", "flake", "ile", "phy", "test", "bit", "feat", "chip", "info", "mobile", "feature", "tab", "grid", "template", "trip", "detail", "Tile", "tif", "bolt", "ie", "tu", "format", "ite", "layer", "buffer", "league", "slice", "member", "tip", "il", "tle", "tiny", "entity", "late", "sector", "mate", "piece", "byte", "tele", "title", "lay", "batch", "tf", "bat", "ele", "table", "cell", "term"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21723, "substitutes": {"dev": ["pack", "end", "vc", "ve", "conf", "ver", "conn", "prop", "disc", "test", "info", "ow", "enc", "server", "home", "pro", "game", "dd", "de", "store", "buf", "md", "cam", "bug", "hw", "die", "ad", "der", "data", "mod", "d", "util", "tag", "cache", "att", "gu", "vol", "doc", "serv", "error", "env", "device", "desc", "comment", "ach", "priv", "usb", "draw", "v", "pub", "ev", "req", "loc", "debug", "des", "av", "develop", "max", "send", "scan", "dis", "app", "wd", "dem", "watch", "driver", "var", "form", "err", "th", "serial", "Dev", "w", "def", "DEV", "cmd", "go", "build", "auth", "db", "cho", "disk", "out", "event", "mem", "addr", "stick", "sd", "val"], "vdev": ["Vev", " vgo", "vegu", "vgu", " vver", "vgo", "tserv", "vrdev", "vdes", " vgu", "pev", "vrdes", "vev", "tdevice", "vedev", "pdef", "Vdef", "gdevice", "vever", "vrgu", "gdev", "Vdev", " vev", "pserv", "vdevice", "pdev", "vdef", "vrver", " vdes", "tdev", " vdevice", "gev", "tgo", "vserv", "vver", "tdef", "Vserv", "vedes", "ggo", "tev"], "bus": ["bridge", "full", "bs", "BUS", "cast", "user", "tmp", "conn", "chain", "join", "gen", "nt", "phys", "buf", "bug", "os", "block", "use", "ac", "ctx", "data", "Bus", "box", "util", "cache", "self", "bit", "b", "root", "pos", "loop", "socket", "local", "usb", "book", "hub", "num", "us", "state", "bits", "loc", "length", "port", "proc", "aux", "plug", "driver", "http", "sys", "mask", "pool", "bank", "bc", "mount", "kit", "c", "lock", "hand", "as", "board", "host", "t", "db", "buffer", "gate", "disk", "off", "out", "handle", "base", "h", "addr", "boot"], "dev_len": ["devptdes", "readaxylen", "dev_l", " dev_lan", "devtLen", "dev_ln", "boot_en", "dev2Len", " dev_l", "devaxyran", " dev_le", " dev_ln", "boot_fun", "read_len", "ev_len", "devpten", "devaxydes", "dev_des", "readaxydes", "devten", "dev_le", "ev_den", "read_des", "read_en", "devaxyen", "dev_lig", "dev2lig", "dev_ran", "dev_den", " dev2en", "dev2len", "read_ran", "devptlen", "ev_ls", "boot_len", "dev_lan", "devtlen", " dev2lig", "readaxyran", "dev_Len", " dev_en", "devaxylen", "dev_lif", "dev_fun", "dev_ls", "readaxyen", " dev2Len", " dev_Len", "devptran", "dev_en", "devtlig", " dev_lig", " dev2len", "ev_en", "dev2en", "boot_lif"], "cpu": ["cp", "pid", "pkg", "num", " CPU", "us", "linux", "memory", "slot", "CPU", "port", "mu", "chip", "cum", "uu", "proc", "core", "gpu", "thread", "processor", "nic", "nu", "node", "uart", "prof", "nice", "phys", "pc", "ck", "process", "cu", "mem", "sys", "hw", "clock", "alloc", "pu", "boot"]}}
{"project": "qemu", "commit_id": "0a75601853c00f3729fa62c49ec0d4bb1e3d9bc1", "target": 0, "func": "RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n", "idx": 21731, "substitutes": {"size": ["height", "description", "body", "name", "id", "type", "SIZE", "slot", "length", "small", "path", "password", "power", "padding", "zone", "range", "scale", "Size", "n", "bytes", "offset", "init", "capacity", "style", "max", "mode", "too", "doc", "root", "address", "send", "storage", "scope", "empty", "timeout", "pos", "owner", "shape", "sum", "area", "set", "network", "usage", "city", "g", "news", "position", "total", "count", "store", "window", "len", "number", "code", "time", "index", "format", "ize", "fee", "dimension", "dim", "space", "term"], "max_size": ["Max_Size", " max_length", "MAX_size", "new_site", "maxiplength", "Max_link", "max_block", "max_length", "maxptlength", "max0range", "max_site", "MAX_length", "max5Size", "max0length", "max10size", "maxopsize", " max_SIZE", "max10number", "max0site", "MAX_range", "maxipblock", "max_since", "max_Size", "Max_size", "max_SIZE", "maxoplength", "Max_number", "maxoprange", "max10link", "MAX_site", "max_number", "new_Size", "max_link", "maxipsize", "max_range", "MAX_SIZE", "maxopsite", "maxptSIZE", "max5size", "maxptblock", "max5site", "MAX_since", "new5Size", "new5size", "new5site", " max_block", "maxptsize", "new_size", "maxipSIZE", "max10Size", "max0size"], "resized": ["resize", "rawised", "rawizable", "msized", "reizing", "presize", "resocated", "resizing", "presized", "revizing", "msocated", "rawized", "asizing", "persized", "sizable", "asizable", "mserved", "reized", "served", "persize", "resised", "asised", "asized", "persizing", "reocated", "resizable", "reverved", "reerved", "reserved", "perserved", "persised", "preserved", "sized", "msizing", "revocated", "persizable", "presizable", "revized", "rawizing"], "host": ["any", "dev", "height", "public", "cert", "parent", "full", "name", "here", "slot", "cast", "handler", "loc", "smart", "port", "path", "user", "domain", "Host", "self", "ost", "holder", "chain", "root", "address", "mac", "raw", "empty", "node", "dr", "server", "owner", "remote", "map", "network", "home", "target", "stream", "ref", "ip", "ssh", "link", "device", "over", "socket", "group", "handle", "null", "base", "context", "http", "local", "gt", "h", "hard", "localhost", "native", "addr", "x", "container", "ex", "ready", "hook", "bind"], "resizeable": ["resimabled", "resizeble", "resizeabled", "resizble", " resizeabled", "resIZEabled", "RESimizeorable", " resizabl", "resizabl", "RESizeability", "rescaleabled", "rescaleabl", "resIZEorable", "rescaleable", "rescaleble", "resimizeable", "resimizeorable", "resizeorable", "resizabled", " resizeble", "resizeabl", "resignability", " resizble", " resizable", "RESimizeabled", "resimable", "RESimizeable", "resignable", "RESimizeability", "resimabl", "resignabled", "resizable", "resimizeabled", "resIZEability", " resizabled", " resizeabl", "resizeability", "RESizeorable", "resIZEable", "RESizeabled", "RESizeable", "resimizeability", "resimble", "resignorable"], "mr": ["hr", "m", "kr", "mx", "adr", "mm", "rs", "mn", "RM", "pm", "gm", "br", "cm", "mc", "Mr", "rn", "hm", "rw", "mp", "ocr", "lr", "bm", "r", "gr", "dr", "wr", "shr", "drm", "rar", "rb", "vr", "mb", "mos", "ml", "rpm", "usr", "rl", "MR", "rg", "sr", "rr", "irm", "rm", "nr", "nah", "mt"], "errp": ["ferpa", " errP", "arrP", " errpost", "rrpost", " errnp", "erP", "errnp", "ferp", "ferP", "rrP", "arrpost", "erps", "erpa", "errpost", "rrnp", "errps", "rrp", "arrnp", "erp", "errpa", "errP", "arrp", " errpa", " errps", "ferps"], "new_block": [" new_piece", "uniqueptlock", "new_snap", "newlyobject", "news___point", "new_page", "new_prefix", "newPpage", "new_base", "new__lock", "unique_snap", "new_volume", "newThebase", " new_lock", "new1piece", "new___point", " new_cell", "new___Block", "newObjblock", "new1Block", "news___mix", "new_bit", "New_point", "news_block", "new_row", "new_word", "unique_block", "newlyblock", "new___row", " new_device", " new_row", "newTheBlock", " new_version", " new_object", "new1lock", "new_struct", "new_lock", "newlingblock", "new_Block", "unique1snap", "uniqueptbl", "news___word", " new_chain", "new___line", "new_bl", "newJblock", "new_version", "newetsession", "newptbl", " new_bit", "newedchain", "new_tag", "new___block", "newetlock", "newlystruct", "newlexpoint", "newlinglock", "news_word", "newptlock", " new__lock", "newlexblock", "unique1base", "newobjchain", "unique_struct", "New_session", "new1version", "news___block", "new__type", "new_session", "newPobject", " new__block", " new_session", "new___lock", "new___volume", " new_snap", "new1block", "new_cell", "unique_bl", "newedsession", "new_chain", "newPblock", "new__row", "new1device", "new1snap", "New_prefix", "newobjvolume", "newlypage", "newptstruct", "New_lock", "newlingcell", "newThesnap", "new_device", "newlylock", "new_object", "unique_base", "newedtag", "new__block", "new_piece", " new__type", " new_page", "newedline", "newObjBlock", "news_point", "new___mix", "new_type", "new___tag", "newetword", "uniqueptstruct", "unique1block", " new__row", "news_mix", "newetmix", "uniqueptblock", "new___word", " new_Block", " new_box", " new_tag", "new___chain", "new_point", "new_line", "newobjblock", "newJpiece", "newObjbox", "newObjbit", "newedblock", "unique_Block", "newetblock", "new_mix", " new_type", "newlexprefix", "newptblock", "unique_lock", "newlybl", "newedsnap", "unique1Block", "new_box", "newetpoint", "newTheblock", "New_block", "newJversion", " new_line", "newedBlock", " new_volume", "new1base"], "local_err": ["localpyrr", "loc_error", "localpyerr", "local__error", "loc___error", " local_error", "loc_err", "loc_msg", "local___error", "local___er", "loc___gz", "local_rr", "local___loc", " local_rr", "local_gz", "local_er", " local_log", "local_msg", "local__er", "local___gz", "local_cb", "loc_loc", " local_er", "local_error", "local__log", "local_log", "loc___err", "local___req", "local_loc", "localpyer", "localpyreq", "local__err", "local___err", " local_req", "loc_gz", "local_req", "loc___loc", "local___rr", "loc_cb"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_movi(TCGContext *s, TCGType type,\n\n                                int ret, tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with constant %ld\\n\", __func__, arg);\n\n#endif\n\n    if (arg == (arg & 0xfff))\n\n        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |\n\n                  INSN_IMM13(arg));\n\n    else {\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));\n\n        if (arg & 0x3ff)\n\n            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |\n\n                      INSN_IMM13(arg & 0x3ff));\n\n    }\n\n}\n", "idx": 21739, "substitutes": {"s": ["js", "m", "gs", "south", "p", "us", "es", "sq", "rs", "z", "w", "d", "sb", "n", "sc", "y", "ds", "self", "b", "c", "cs", "sync", "r", "as", "sw", "ts", "ses", "ss", "i", "stats", "t", "g", "ns", "socket", "a", "sts", "sv", "qs", "h", "sys", "os", "S", "f", "is", "v"], "type": ["ty", "p", "state", "name", "pe", "tag", "typ", "Type", "types", " ty", "test", "style", "ype", "rt", "kind", "r", "tor", " TYPE", "t", "TYPE", " pt", " Type", "ref", "et", " kind", " typ", "class"], "ret": ["reset", "alt", "rs", "tr", "Ret", " fut", "def", "red", "l", "inter", "att", " Ret", "result", "rt", "ry", "r", "aux", "lit", "ts", "nt", "flag", "dr", " def", "ct", "t", "ft", "res", "reg", "g", " RET", "cat", "ref", "rev", "re", "std", "desc", "out", "len", "mem", "rets", "gt", "usr", "str", "err", "RET", "back", "st", "mt", " reg", "rc", "val"], "arg": [" argument", "eng", "prop", "attr", "mac", "ok", "agg", "ar", "other", "sec", "bug", "arr", "x", "op", "call", "ad", "f", "arp", "mm", "ax", "jp", "parse", "tag", "inter", " targ", "asc", "doc", "iter", "in", "flag", "args", "local", "usr", "ack", " reg", "rc", "v", "Arg", "num", "add", "alt", "loc", "ag", "field", " Arg", "r", "raw", "empty", "deg", "act", "g", "msg", "var", "al", "param", "star", "valid", "opt", "p", " larg", "w", "pl", "ob", "j", "ig", "cmd", "t", "reg", "argument", "target", "ref", "out", "mem", "gt", "addr", "pg", "val"]}}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter 'key-secret' is required for cipher\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];\n\n    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, &local_err, opaque);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              &local_err,\n\n              opaque);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 21740, "substitutes": {"luks": ["lukes", "pukes", "nuks", " bluk", "flukes", "lucs", "Luks", " blukes", "puks", " blucs", "Lukes", "Luk", "nukas", "pukas", "luk", "nucs", "flucs", "flukas", "nukes", " bluks", "lukas", "fluks", "Lucs", "pucs", "fluk"], "luks_opts": ["luks__opts", "luks_opns", "luks_optx", "luksdboptimcons", "luks_typms", "luks_procs", "luksdbtypts", "luks_optths", "luks_critcons", "luks_coptr", "luks_opertx", "luks_OPgs", "luks_OPtp", "luks_optionts", "luksdbopms", "luks_opte", "luks__opns", "luks_opths", "luks_dropcons", "luks_critts", "luks_imcons", "luks_opttons", "luks_pret", "luks_iopts", "luks_optiontx", "luks_ports", "luks_popt", "luksdbopths", "luks_catgs", "luks_okgs", "luks_Opps", "luks_optons", "luks_opcs", "luks_optters", "luks_dropters", "luks_OPths", "luks_opgs", "luks_optionths", "luks_speps", "luks_okts", "luks_OPts", "luks_optimters", "luks_alls", "luks_compts", "luks_optp", "luks_hopjs", "luks_porents", "luks_hopt", "luks_props", "luks_logents", "luks_opters", "luks_opers", "luks_ioptx", "luks_optimcons", "luks_OPs", "luks_logtp", "luks_OPnt", "luks_hopts", "luks_opcons", "luks_OPpt", "luks_OPtr", "luks_Opgs", "luks_alte", "luks_prote", "luks_optes", "luks_droptes", "luks_opstes", "luks_optionnt", "luks_opnt", "luks_opls", "luks_alpt", "luks_prems", "luks_catts", "luks_iopths", "luks_optr", "luksdboptimtx", "luks_optimts", "luks_oppt", "luks_OPents", "luks_okps", "luks_oks", "luks_alps", "luks_typths", "luksdbopcons", "luksdboptimths", "luks_logs", "luks_ors", "luks_compjs", "luks_optv", "luksdboptimts", "luks_als", "luks_prets", "luks_opsns", "luks_optionss", "luks_logts", "luks_crittons", "luks_optionsps", "luks_pregs", "luksdbops", "luks_optimtons", "luksdbopts", "luks_dropts", "luks__opms", "luks_hopgs", "luks_OPv", "luks_coppt", "luks_opjs", "luksdbtyps", "luks_opv", "luks_optcons", "luks_opsms", "luks_Ops", "luks_spete", "luks_imtes", "luks_optts", "luks_hopnt", "luks_typts", "luks_optionops", "luks_popts", "luks_opouts", "luks_optimtes", "luks_opents", "luks_specs", "luks_opsts", "luks_orms", "luks_ops", "luks_iopcons", "luks_opops", "luks_compgs", "luks_copls", "luks_compouts", "luks_critters", "luksdboptx", "luks_cops", "luks_alts", "luksdbtypms", "luks_OPls", "luks_spets", "luks_popms", "luks_catjs", "luks_hopops", "luks_opms", "luks_pops", "luks_optimtx", "luks_OPps", "luks_pors", "luks_portp", "luks_prots", "luks_copts", "luks_optms", "luks_orts", "luks_pres", "luks_optimths", "luks_Opts", "luks_optps", "luks_OPms", "luks_optiont", "luks_alcs", "luks_OPt", "luks_orgs", "luks_optioncons", "luks__optes", "luks_OPtx", "luksdbtypths", "luks_imts", "luks_opertr", "luks_catouts", "luks_optns", "luks_opt", "luks_OPops", "luks_hopouts", "luks_operts", "luks_optionsv", "luks_coptx", "luks_imters", "luks_optionsts", "luks_opttes", "luks_typs", "luks_opps"], "local_err": ["internal_error", "internal_err", "local___msg", "internal_er", "local__error", "local_msg", "local_er", "local_error", "local__err", "local___err", "local__msg", "internal_msg", "local__er", "internal___er", "local___error", "local___er", "internal___error", "internal___err", "internal___msg"], "masterkey": ["primarykey", "masterdata", "primaryblock", "primarydata", "mainkey", "masterblock", "prefixdata", "mainblock", "prefixblock", "prefixkey", "maindata"], "slotkey": ["slotbyte", "partk", "partkey", "snapkey", "splitk", "partKey", "splitbyte", "slotk", "snapk", "snapbyte", "partbyte", "slotKey", "snapKey", "splitKey"], "splitkey": ["halfKey", "altkey", "halfseed", "halfcode", "altKey", "switchKey", "switchseed", "switchcode", "altseed", "switchkey", "splitcode", "altcode", "splitKey", "halfkey", "splitseed"], "i": ["ta", "ci", "ix", "p", "id", "si", "bin", "abi", "init", "b", "iu", "j", "di", "in", "ai", "ui", "phi", "ip", "a", "ini", "bi", "h", "ii", "pi", "I", "ia", "io", "is"], "cipher": ["ccoder", "chiper", "curpter", "ccipher", "curoder", "cciper", "chpter", "ccpter", "ciper", "choder", "curiper", "chipher", "curipher", "cpter", "coder"], "ivgen": ["ivmsg", " ivmsg", "ivgeneration", "iverGen", "evmsg", "ivergen", "evgen", "ivergeneration", "evGen", " ivGen", "ivGen", "evgeneration", " ivgeneration", "ivermsg"], "password": ["parser", "command", "description", "word", "padding", "security", "pass", "chain", "prefix", "token", "text", "address", "username", "query", "auth", "encrypted", "message", "phrase", "secret", "buffer", "session", "hash", "channel", "comment", "PASS", "context", "attribute", "private", "Password"], "cipher_alg": ["cdriver_mg", "cipher___mg", "cdriver_org", "cdriverfulalg", "cdriverfulorg", "cipher___img", "cipher_mg", "cipher_attr", "cipher_org", "cdriverfulimg", "cipher___org", "cipher_img", "cip_alg", "cipher___alg", "cdriver_img", "cipherfulmg", "cdriverfulmg", "cipherfulimg", "cdriver_alg", "cipherfulorg", "cipher_mem", "cip_mem", "cipherfulalg", "cip_attr", "cip_mode"], "cipher_mode": ["cursor_mode", "caster_md", "cipher___no", "cursorlytype", "cipher_type", "cursor_no", "cursorlyopt", "cipher_opt", "cipherlymode", "caster_method", "caster_mode", "caster_operator", "cursor_type", "cipher___opt", "cursorlymode", "cipherlyopt", "cursorlyno", "cipher_md", "cipher_operator", "cipher___mode", "cursor_opt", "cipherlyno", "cipherlytype", "cipher___type", "cipher_no", "cipher_method"], "ivgen_alg": ["ivnode_alt", "ivGen_mode", "ivgenxalg", "ivgen_alt", "ivgen_arch", "ivgen_mode", "ivnode_rg", "ivgenerationximg", "ivgenxhash", "ivgeneration_hash", "ivgen7op", "ivgeneration_impl", "ivgen___alg", "ivgen_img", "ivgen7mode", "ivgen7arch", "ivgen___hash", "ivgen_rg", "ivnode_alg", "ivgen___img", "ivgen_op", "ivGen_alg", "ivgen_hash", "ivnode_gen", "ivGen_op", "ivgeneration_img", "ivgenximpl", "ivgeneration_alg", "ivgenerationxhash", "ivgen___impl", "ivgenerationximpl", "ivgen7alg", "ivGen_arch", "ivgenerationxalg", "ivgen_impl", "ivgen_gen", "ivgenximg"], "ivgen_hash_alg": ["ivgen_hashmmcmd", "ivgen_hashmmimpl", "ivgen_search_alg", "ivgen_search_org", "ivgen_search_impl", "ivgen_search_cmd", "ivgen_hash_org", "ivgen_hash_impl", "ivgen_hash_cmd", "ivgen_hashmmorg", "ivgen_hashmmalg"], "hash_alg": ["hash_aug", "hashableaug", "hashablefac", "hashgraug", "hash_fac", "hashgrexp", "shadow_alg", "shadowgrexp", "hash_attr", "hashablealg", "search_attr", "search_alg", "shadow_aug", "search_mem", "shadowgrfac", "shadowgraug", "hash_gen", "hashgralg", "hashgrfac", "shadow_fac", "search_gen", "shadow_exp", "hash_exp", "shadowgralg", "hashableexp", "hash_mem"], "cipher_mode_spec": ["cipher_mode2spe", "cipher_type_match", "cipher_type_spec", "cipher_type_tag", "cipher_mode_match", "cipher_mode2tag", "cipher_mode2match", "cipher_mode2spec", "cipher_mode_tag", "cipher_mode_spe", "cipher_type_spe"], "iters": ["litERS", "itering", "ITers", " itered", "litered", "itERS", "ITered", "itered", " itERS", "litering", "ITERS", " itering", "liters", "ITering"]}}
{"project": "FFmpeg", "commit_id": "17269bdfcdb79679f6b92024d1228e876b799a63", "target": 1, "func": "static int swf_write_trailer(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int file_size, i;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = &s->streams[i]->codec;\n\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    put_swf_tag(s, TAG_END);\n\n    put_swf_end_tag(s);\n\n    \n\n    put_flush_packet(&s->pb);\n\n\n\n    /* patch file size and number of frames if not streamed */\n\n    if (!url_is_streamed(&s->pb) && video_enc) {\n\n        file_size = url_ftell(pb);\n\n        url_fseek(pb, 4, SEEK_SET);\n\n        put_le32(pb, file_size);\n\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n\n        put_le16(pb, video_enc->frame_number);\n\n    }\n\n    av_free(swf);\n\n    return 0;\n\n}\n", "idx": 21750, "substitutes": {"s": ["js", "gs", "m", "tes", "comments", "ls", "sq", "p", "v", "o", "z", "bs", "rs", "details", "times", "w", "parts", "n", "ps", "eps", "fs", "ims", "ds", "scl", "b", "ms", "c", "cs", "settings", "an", "as", "r", "ts", "ses", "j", "ss", "stats", "t", "aws", "less", "args", "g", "ns", "ins", "its", "hs", "a", "services", "source", "sts", "sv", "qs", "sys", "ats", "h", "os", "S", "als", "f", "is", "sports", "comm"], "swf": ["swfs", " swfo", "avv", "SwF", "essfx", "swfx", "iwfx", "Swfo", "wsf", "avF", "Swfs", " swfx", "wsv", " swfw", "svv", "swfo", "wsF", " swfs", "avfx", "avf", "swF", "svf", "awfo", "awf", " swF", "essf", "swfw", "iwfw", "swv", "essfw", "awfs", "svF", "wsfx", "svfx", "iwf", "awF", "Swf"], "pb": ["ctx", "pkg", "cp", "gc", "uf", "tp", "vt", "p", "np", "pp", "nb", "bb", "eb", "erb", "td", "ub", "orp", "jp", "pm", "sb", "ptr", "um", "tc", "gb", "wb", "bp", "pan", "typ", "ab", "phy", "pl", "appy", "tm", "mp", "b", "wp", "proc", "vp", "tk", "PB", "obb", "pt", "func", "aus", "bh", "phys", "db", "bj", "pc", "pa", "abb", "amp", "dp", "prototype", "lb", "mb", "buf", "resp", "bps", "emb", "gp", "bf", "lp", "fb", "fp", "cb", "pool", "pg", "cv"], "enc": ["ac", "ctx", "ENC", "acc", "oc", "inc", "vc", "ev", "loc", "util", "xc", "eng", "anc", "conn", "nc", "iv", "Enc", "cod", "eric", "c", "fc", "sw", "ec", "nt", "erc", "act", "en", "pc", "et", "vec", "iq", "cv", "con", "buf", "nv", "code", "ent", "abc", "conv", "comp", "rec", "lang", "alloc", "cmp", "coll", "ack", "rc", "comm"], "video_enc": ["video___ent", "VIDEO_enc", "Video_ec", " video_ENC", "video_crit", "Video_enc", "channel_conn", " video_dec", "video_inc", "video___con", "VIDEO_en", "video_con", "video_en", " video_ec", "channel_con", "video___inc", "VIDEO_inc", "video___ENC", "channel_enc", "channel_en", "video___coll", "Video_crit", "video___ec", "Video_coll", "video_ec", "Video_ent", "video_ENC", "video_dec", "video_ent", "video___dec", "VIDEO_ec", "video_coll", "video___en", "video___conn", "video___enc", "video_conn"], "file_size": ["file_sized", "file___size", "file10size", " file_sized", "file___sized", " file_Size", "file10small", " file_speed", "file_len", "file64len", "file_position", " file_small", "file___small", " file_len", " file_length", "file_small", "file64length", "file_length", "file64Size", "file10sized", "file_Size", " file_position", "file64size", "file_speed"], "i": ["hi", "m", "me", "ci", "ix", "p", "us", "my", "v", "q", "id", "name", "si", "zi", "multi", "ei", "y", "it", "mc", "ims", "l", "xi", "init", "chain", "mi", "ms", "qi", "c", "iu", "ti", "ski", "info", "j", "iter", "di", "\u0438", "ai", "t", "ie", "uri", "g", "ui", "phi", "ic", "li", "key", "gi", "ip", "sim", "cli", "ri", "ji", "ini", "e", "ind", "bi", "oi", "index", "ii", "x", "pi", "batch", "I", "ami", "ex", "ki", "im"]}}
{"project": "FFmpeg", "commit_id": "fbfbd97be25c4da0562ef61e2f27192d1ec4d276", "target": 1, "func": "static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame, AVPacket *avpkt)\n\n{\n\n    XPMDecContext *x = avctx->priv_data;\n\n    AVFrame *p=data;\n\n    const uint8_t *end, *ptr = avpkt->data;\n\n    int ncolors, cpp, ret, i, j;\n\n    int64_t size;\n\n    uint32_t *dst;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n\n\n    end = avpkt->data + avpkt->size;\n\n    while (memcmp(ptr, \"/* XPM */\\n\", 10) && ptr < end - 10)\n\n        ptr++;\n\n\n\n    if (ptr >= end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n\n        return ret;\n\n\n\n    if (cpp <= 0 || cpp >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size = 1;\n\n    for (i = 0; i < cpp; i++)\n\n        size *= 94;\n\n\n\n    if (ncolors <= 0 || ncolors > size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size *= 4;\n\n\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n\n    if (!x->pixels)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n\n    for (i = 0; i < ncolors; i++) {\n\n        const uint8_t *index;\n\n        int len;\n\n\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        if (ptr + cpp > end)\n\n            return AVERROR_INVALIDDATA;\n\n        index = ptr;\n\n        ptr += cpp;\n\n\n\n        ptr = strstr(ptr, \"c \");\n\n        if (ptr) {\n\n            ptr += 2;\n\n        } else {\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        len = strcspn(ptr, \"\\\" \");\n\n\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n\n            return ret;\n\n\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    for (i = 0; i < avctx->height; i++) {\n\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n\n\n        for (j = 0; j < avctx->width; j++) {\n\n            if (ptr + cpp > end)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n\n                return ret;\n\n\n\n            *dst++ = x->pixels[ret];\n\n            ptr += cpp;\n\n        }\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    p->key_frame = 1;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 21762, "substitutes": {"avctx": ["wavconfig", "avekl", "avercp", "aftx", "abctx", "wavcontext", "avcmp", "afpkg", " avconfig", "AVcfg", "wavcmp", "avectx", " avgc", "avcontext", "avecmd", " avtx", "avergc", "avtx", "averpkg", "afctl", " avreq", "averreq", "wavcfg", "afconfig", "averctl", "avercmp", "avecp", "vctl", "avercmd", "abcfg", "abcontext", "ajctx", "avcp", " avcmp", "afctx", "wavkl", "ajctl", "avepkg", "avectl", "AVcontext", "afcmd", "averkl", "ajcfg", "avgc", "AVctl", " avcontext", "afcu", "avereq", "averctx", "avercu", "abtx", "avconn", "avertx", "avcfg", "averconn", "avreq", "abcu", "avecu", "avercfg", "vtx", "ajcp", "afgc", " avcfg", " avctl", "avkl", "ajcmd", "vcontext", "avercontext", "afconn", "ajconfig", "abgc", "avconfig", "ajpkg", " avcmd", "avecontext", "averconfig", "avcu", " avcu", "afcp", "wavctx", "avecmp", "ajtx", "abctl", "vctx", "ajgc", "avpkg", " avcp", "ajconn", "AVctx", "wavpkg", "avecfg", "avctl", "avcmd", "ajcu"], "data": ["action", "m", "dat", "o", "file", "start", "id", "pad", "name", "image", "bin", "length", "d", "padding", "mu", "to", "value", "bytes", "content", "feed", "offset", "text", "mode", "address", "r", "raw", "empty", "in", "origin", "pointer", "video", "format", "t", "extra", "pos", "error", "message", "frame", "buffer", "key", "f", "ref", "device", "read", "window", "buf", "next", "out", "a", "obj", "hash", "mem", "DATA", "xy", "form", "str", "ata", "batch", "mid", "rel", "block", "Data", "table"], "got_frame": ["gotpframe", "gotpcode", "received_code", "gotpstate", "gotpmessage", "received_state", "got_state", "got_code", "received_frame", "received_message", "got_message"], "avpkt": ["avjptx", "vanjpst", "avppwk", "avjpkat", "vanjptx", "afpacket", "avwpkt", "afpdu", "avppacket", "afpkg", "avcpdu", "avwpct", "afpkat", "avcpkt", "afPkt", "afcpacket", "vanptx", "avnpcmd", "avPkt", "avcpkat", "avptx", "avPacket", "vanjpct", "afpct", "avcpwk", "afcpkt", "avwdu", "avjpst", "afPkg", "avcpacket", "afpcmd", "avppcmd", "avPct", "avpkat", "afpwk", "avpst", "avpwk", "avcpcmd", "avpckt", "avPkg", "avnpwk", "avpcct", "afpkt", "afcpwk", "avwkat", "avpdu", "afPct", "afcpcmd", "avPtx", "afcpdu", "avjpacket", "vanjpkt", "avnpkt", "avpacket", "afPacket", "avnpacket", "avwpst", "avjpkt", "vanpst", "avjpct", "vanpct", "avwacket", "afcpkat", "avpct", "avppkt", "avpcmd", "avwkt", "vanpkt", "avpckg", "avjpdu", "avwptx", "avcpkg", "avpkg", "avPst", "avpcacket", "avcpct"], "x": ["ctx", "xp", "check", "ox", "rx", "ix", "mx", "my", "z", "xx", "xxx", "ax", "w", "xc", "inx", "y", "xi", "l", "status", "xe", "c", "xt", "lex", "tx", "act", "xml", "t", "xxxxxxxx", "xes", "ux", "client", "xf", "X", "xy", "xs", "h", "wx", "px", "ex", "xxxx", "f", " cx", "v", "fx"], "p": ["ctx", "cp", "m", "q", "pp", "o", "sp", "pr", "jp", "pm", "w", "d", "ph", "n", "P", "b", "rep", "c", "r", "vp", "pt", "t", "u", "g", "pc", "pa", "pb", "ap", "a", "h", "lp", "fp", "f", "v"], "end": ["dev", "ff", "rest", "old", "start", "End", "add", "id", "pend", "length", "w", "range", "orig", "ext", "offset", "bound", "max", "ending", "limit", "hend", "send", "wind", "append", "set", " End", "pent", "en", "buffer", "est", "nd", "END", "ref", "until", "buf", "next", "head", "window", "off", "e", "ent", "all", "last", "ended", "h", "stop", "addr", "begin", "st"], "ptr": ["pointers", "rect", "inst", "adr", "sp", "pend", " pointer", "assert", "address", "wind", "dr", "pt", "pc", "rev", "cur", "ind", "Ptr", "inters", "pi", "prot", "peer", "dep", "rod", "ctx", "try", "tp", "jp", "shift", "each", "inter", "rt", "ts", "iter", "pointer", "pos", "tip", "ctr", "reset", "depth", "td", "pad", "tr", "req", "push", "length", "loc", "br", "fr", "offset", "rep", "proc", "r", "point", "hl", "fp", "rel", "ix", "pr", "ter", "far", "src", "dist", "ij", "cmd", "prime", "buffer", "ref", "off", "mem", "pre", "addr"], "ncolors": ["nrconstores", " ncolORS", "nCollections", "nColORS", "nconstores", " ncolores", " nColores", "ncontORS", "ncolORS", " ncolorores", "nctors", "nchainers", "nctORS", "nColors", "ncilors", "nrcolores", "ncolorainers", " nColors", "ncolorORS", "nrcollections", "nicolors", "nicolores", "ncolainers", " ncolainers", "ncolourors", " ncollections", "nicolORS", "ncolorors", "ncollections", "ncilainers", "nrconstors", "ncolourores", "ncontords", " nColainers", " ncolorORS", "ncolorords", "ncilores", "ncolorlections", " ncolords", "nconstators", "Ncolors", "Ncolores", "NcolORS", "nchords", "ncolourators", "ncontores", "ncontlections", "ncolords", "nrcolators", "ncolores", "nconstors", "nColores", "nchores", "ncolorators", "nrconstlections", " ncolorlections", "nCollers", "ncillers", "Ncolorlections", "nchlers", "Ncollections", "nrconstators", "nColainers", "nicollections", "ncollers", "nctlections", "ncontainers", "nrcolors", "Ncolorors", "ncolourlections", "ncolators", "Ncolorores", " ncolorainers", "NcolorORS", "nchors", "ncolorores", " ncolorors", " ncollers", " ncolorords", " nCollers", "nctores", "nconstlections", "ncontors"], "cpp": ["ctx", "cp", "pkg", "js", "ff", "height", "xp", "tp", "pack", "heads", "inc", "np", "pp", "sp", "zh", "imp", "xx", "push", "ppo", "sup", "jp", "clip", "ffff", "xff", "bp", "pps", "cc", "ext", "cpu", "java", "proc", "c", "cs", "fc", "vp", "html", "cmd", "pointer", "PP", "pc", "cd", "amp", "ip", "kk", "php", "mph", "hl", "grow", "ctr", "crop", "omp", "CP", "comp", "esp", "cf", "fps", "pi", "fp", "cmp", "px", "cap", "ipp", "prot", "cb", "cv", "ct"], "ret": ["gc", "reset", "try", "success", "v", "alt", "Ret", "jp", "def", "fr", "prop", "reply", "ext", "it", "rem", "red", "status", "att", "result", "fun", "true", "rt", "tail", "nl", "ry", " Ret", "lit", "iter", "nt", "flag", "dr", "print", "ft", "res", "repl", "buffer", "rf", "ref", "rev", "re", "resp", "out", "ll", "mem", "rets", "gt", "nz", "sys", "arr", "ber", "usr", "addr", "err", "rm", "elt", "RET", "back", "mt", "ne", "cont", "rc", "val"], "i": ["hi", "m", "me", "ci", "ix", "start", "us", "o", "id", "si", "zi", "multi", "n", "ei", "y", "it", "xi", "ij", "ti", "mi", "qi", "gu", "iu", "di", "\u0438", "ai", "im", "ie", "gi", "phi", "ic", "li", "ui", "ip", "sim", "a", "ini", "e", "ind", "bi", "ii", "pi", "I", "ki", "v"], "j": ["jj", "js", "m", "json", "q", "z", "aj", "jp", "br", "n", "l", "ij", "jc", "b", "mi", "jl", "ni", "pos", "k", "g", "jac", "J", "ji", "obj", "jump", "kj", "v"], "size": ["sp", "name", "type", "sc", "capacity", "speed", "set", "count", "ize", "pi", " Size", "sent", "z", "SIZE", "padding", "Size", "sum", "shape", "pos", "member", "v", "m", "sn", "export", "si", "length", "small", "offset", "max", "send", "empty", "false", "timeout", "g", "ui", "news", "window", "time", "err", "fee", "space", "height", "ci", "start", "body", "flags", "w", "scale", "n", "bytes", "sh", "c", "s", "storage", "sw", "buffer", "number", "code", "zero", "mem", "sv", "ne", "iz"], "dst": ["pbr", "psts", "dST", "fst", "fbr", "fST", "dbr", "bdst", "pst", "pST", "bdbr", "bdST", "bdsts", "fsts", "dsts"]}}
{"project": "FFmpeg", "commit_id": "452ac2aaecf7210a2912d9156869c6314142a794", "target": 0, "func": "static void ripemd160_transform(uint32_t *state, const uint8_t buffer[64], int ext)\n\n{\n\n    uint32_t a, b, c, d, e, f, g, h, i, j;\n\n    uint32_t block[16];\n\n    int n;\n\n\n\n    if (ext) {\n\n        a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4];\n\n        f = state[5]; g = state[6]; h = state[7]; i = state[8]; j = state[9];\n\n    } else {\n\n        a = f = state[0];\n\n        b = g = state[1];\n\n        c = h = state[2];\n\n        d = i = state[3];\n\n        e = j = state[4];\n\n    }\n\n\n\n    for (n = 0; n < 16; n++)\n\n        block[n] = AV_RL32(buffer + 4 * n);\n\n\n\n    for (n = 0; n < 16 - 1;) {\n\n        ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_0_TO_15(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_0_TO_15(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_0_TO_15(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);\n\n    }\n\n    ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);\n\n    SWAP(a,f)\n\n\n\n    for (; n < 32 - 1;) {\n\n        ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_16_TO_31(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_16_TO_31(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_16_TO_31(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_16_TO_31(a,b,c,d,e,f,g,h,i,j);\n\n    }\n\n    ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);\n\n    SWAP(b,g)\n\n\n\n    for (; n < 48 - 1;) {\n\n        ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_32_TO_47(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_32_TO_47(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_32_TO_47(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_32_TO_47(e,a,b,c,d,j,f,g,h,i);\n\n    }\n\n    ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h);\n\n    SWAP(c,h)\n\n\n\n    for (; n < 64 - 1;) {\n\n        ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n        ROUND160_48_TO_63(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_48_TO_63(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_48_TO_63(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_48_TO_63(d,e,a,b,c,i,j,f,g,h);\n\n    }\n\n    ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n    SWAP(d,i)\n\n\n\n    for (; n < 75;) {\n\n        ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_64_TO_79(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_64_TO_79(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_64_TO_79(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_64_TO_79(c,d,e,a,b,h,i,j,f,g);\n\n    }\n\n    ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n    SWAP(e,j)\n\n\n\n    if (ext) {\n\n        state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e;\n\n        state[5] += f; state[6] += g; state[7] += h; state[8] += i; state[9] += j;\n\n    } else {\n\n        i += c + state[1];\n\n        state[1] = state[2] + d + j;\n\n        state[2] = state[3] + e + f;\n\n        state[3] = state[4] + a + g;\n\n        state[4] = state[0] + b + h;\n\n        state[0] = i;\n\n    }\n\n}\n", "idx": 21766, "substitutes": {"state": ["m", "check", "list", "spec", "close", "q", "p", "start", "State", "memory", "seed", "conf", "power", "port", "user", "unit", "tag", "trace", "range", "cache", "states", "it", "test", "init", "self", "dict", "result", "info", "history", "core", "r", "config", "iter", "STATE", "item", "template", "app", "point", "step", "print", "t", "map", "loop", "area", "initial", "open", "see", "al", "hash", "store", "job", "event", "device", "row", "handle", "base", "context", "the", "local", "rule", "queue", "monitor", "resource", "pal", "call", "policy", "space", "cell"], "buffer": ["command", "m", "vector", "program", "q", "p", "bar", "input", "length", "padding", "cache", "Buffer", "screen", "offset", "capacity", "limit", "address", "bm", "buff", "function", "stack", "size", "message", "output", "ref", "count", "window", "buf", "len", "code", "base", "view", "index", "queue", "binary", "batch", "sequence", "array", "v"], "ext": ["js", "check", "rest", "end", "full", "seq", "fit", "external", "def", "quote", "transfer", "EXT", "test", "text", "xt", "Ext", "lex", "aux", "embed", "empty", "enc", "flag", "ef", "only", "extra", "append", "im", "ed", "vert", "txt", "ref", "tim", "ctr", "bf", "ended", "binary", "tf", "valid", "mult", "ex", "cont", "rend"], "a": ["ac", "af", "ta", " fa", "m", "A", "this", "aaa", "p", "ca", "o", "am", "at", "aj", "ga", "ba", "w", "ak", "va", "ea", "y", "ab", " ca", "era", "l", "att", " A", "sa", "ae", "aa", "s", "an", "access", "er", "as", "aux", " ba", "app", "la", "da", "ai", "t", "ar", "area", "u", "ma", "pa", "ate", "al", "ap", "oa", "ao", "au", "ach", "x", "ata", "ia", "ad"], "b": ["m", "bb", "eb", "p", "nb", "o", "bs", "bar", "z", "be", "bc", "ba", "by", "w", "sb", "gb", "wb", "to", "br", "y", "ab", "it", "l", "ob", "B", "r", "as", "ib", "bt", "ble", "u", "rb", "db", "bg", "bl", "bu", "mb", "bi", "bf", "fb", "bd", "ad", "cb", "v", "bo"], "c": ["ac", "cp", "gc", "m", "cr", "cor", "ci", "ca", "vc", "v", "o", "cn", "bc", "can", "tc", "cache", "cm", "y", "cc", "sc", "mc", "co", "com", "cs", "fc", "r", "lc", "ec", "ce", "ar", "u", "col", "cd", "cat", "unc", "dc", "cur", "cv", "con", "cu", "ch", "cf", "ad", "arc", "cb", "rc", "ct"], "d": ["dev", "m", "der", "dir", "dat", "p", "o", "z", "id", "td", "dx", "w", "ld", "dt", "y", "it", "l", "ds", "dh", "er", "r", "du", "di", "dr", "da", "t", "dn", "dm", "u", "db", "nd", "ed", "dc", "dd", "cd", "dp", "de", "md", "D", "ad", "sd", "v", "df"], "e": ["eff", "m", "em", "me", "eg", "q", "p", "eb", "es", "o", "ev", "ne", "be", "w", "eng", "um", "ei", "y", "oe", "it", "ea", "ue", "l", "er", "ae", "r", "enc", "ec", "ef", "ie", "k", "u", "en", "ek", "ed", "E", "et", "ate", "de", "entity", "el", "ent", "ing", "ee", "se", "eu", "le", "v"], "f": ["fo", "ff", "m", "uf", "q", "p", "o", "z", "be", "fl", "conf", "w", "def", "um", "fr", "fe", "fd", "y", "it", "fa", "l", "er", "fn", "fc", " F", "r", "ef", "t", "fac", "k", "u", "fi", "ul", "off", "F", "bf", "form", "fg", "cf", "sf", "tf", "fb", "of", "err", "fm", "fp", "v", "df"], "g": ["gam", "m", "gc", "gs", "eg", "q", "p", "G", "o", "v", "z", "gl", "gg", "ga", "ag", "gm", "w", "um", "gb", "gas", "y", "mg", "it", "l", "gu", "er", "s", "sh", "gr", "r", "og", "ig", "gh", "go", "t", "gz", "u", "gi", "bg", "ic", "msg", "ng", "ge", "al", "erg", "ch", "gp", "rg", "sg", "ger", "fg", "x", "pg", "im"], "h": ["ha", "hi", "kh", "hr", "m", "q", "p", "o", "v", "z", "oh", "ih", "w", "ho", "ash", "ah", "y", "it", "hm", "ph", "l", "hd", "rh", "dh", "sh", "he", "r", "eh", "html", "gh", "bh", "H", "u", "ic", "hp", "hash", "hh", "hal", "hl", "ch", "hs", "hang", "x", "th", "ish", "help", "im"], "i": ["iy", "hi", "m", "ci", "ix", "p", "o", "z", "si", "ih", "w", "y", "it", "l", "ij", "ti", "mi", "info", "iu", "s", "er", "r", "di", "ir", "ai", "im", "ie", "u", "fi", "phi", "ic", "li", "ed", "gi", "ip", "ri", "is", "el", "bi", "oi", "ii", "pi", "ia", "then", "ik", "io", "ish", "v"], "j": ["jj", "js", "hi", "m", "json", "try", "q", "p", "o", "un", "z", "ja", "uj", "ne", "aj", "be", "at", "si", "jp", "fr", "y", "it", "dt", "dj", "l", "ij", "jc", "er", "r", "jl", "im", "ie", "u", "db", "jac", "J", "note", "job", "ji", "el", "bi", "obj", "ch", "out", "x", "jump", "kj", "v"], "block": ["check", "pack", "type", "box", "image", "unit", "field", "cache", "offset", "blocks", "bit", "chain", "line", "lock", "join", "sync", "node", "map", "k", "set", "frame", "output", "open", "link", "other", "hash", "window", "channel", "group", "Block", "view", "batch", "filter", "model", "commit", "object", "array", "ack", "response"], "n": ["np", "name", "ln", "conn", "on", "N", " N", "fn", "nt", "gn", "yn", "tn", "ng", "count", "con", "after", "x", " l", "nb", "o", "mn", "nn", "syn", "rn", "l", "nl", "k", "en", "pn", "len", " len", "norm", " fn", "un", "v", "m", "num", "sn", "cn", "br", "nc", "init", "an", "node", "ren", "na", "names", "note", "p", "span", "w", "nm", "nor", "no", "t", "dn", "ns", "ul", "out", "number", "all", "nan", "new", "ne"]}}
{"project": "FFmpeg", "commit_id": "bc7eb330e3d42f6cff3f95432da999bd4538e2e1", "target": 0, "func": "static void opt_frame_size(const char *arg)\n\n{\n\n    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {\n\n        fprintf(stderr, \"Incorrect frame size\\n\");\n\n        av_exit(1);\n\n    }\n\n    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {\n\n        fprintf(stderr, \"Frame size must be a multiple of 2\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n", "idx": 21767, "substitutes": {"arg": ["Arg", "num", "spec", "oc", "p", "bar", "name", "ax", "ag", "parse", "ob", "doc", "og", "config", "ig", "flag", "cmd", "in", "agg", "args", "ar", "reg", "argument", "g", "key", "var", "other", "event", "param", "arr", "str", "op", "ad", "block", "pg", "v", "val"]}}
{"project": "FFmpeg", "commit_id": "20fe316e47fedb28787e77e77a7011133f3d4e73", "target": 1, "func": "static int sdl_write_trailer(AVFormatContext *s)\n\n{\n\n    SDLContext *sdl = s->priv_data;\n\n\n\n    sdl->quit = 1;\n\n\n\n    if (sdl->overlay)\n\n        SDL_FreeYUVOverlay(sdl->overlay);\n\n\n    if (sdl->event_thread)\n\n        SDL_WaitThread(sdl->event_thread, NULL);\n\n\n    if (sdl->mutex)\n\n        SDL_DestroyMutex(sdl->mutex);\n\n\n    if (sdl->init_cond)\n\n        SDL_DestroyCond(sdl->init_cond);\n\n\n\n\n    if (!sdl->sdl_was_already_inited)\n\n        SDL_Quit();\n\n\n\n    return 0;\n\n}", "idx": 21776, "substitutes": {"s": ["js", "gs", "m", "p", "sq", "o", "rs", "z", "w", "d", "sb", "n", "ps", "fs", "ds", "l", "b", "c", "cs", "r", "ts", "ss", "i", "t", "aws", "set", "ns", "a", "sts", "sv", "qs", "h", "ats", "os", "S", "als", "f", "v"], "sdl": ["SDL", " sddl", "sdlu", "skyls", "svdl", " cdl", "SDdl", "sdlp", "skydl", "skyli", "dddl", "sdlc", "sdla", "ddsl", "SDl", "svli", "mdls", " cdsl", " sdle", "SDli", "svlp", "skyl", "sdli", "skyel", "easel", "svls", " cdlc", "ddli", "sdL", "easl", " cddl", "easdl", "sdel", "sddl", "easler", "mdL", "svel", "hdl", "SDv", "hdla", "easls", "ndli", "ndla", "SDel", "sdle", " sdL", "SDls", "easle", "mdli", "skyll", "SDql", "svv", "stickls", " sdlu", "stickql", "sdler", "mddl", "skyler", " sdll", "svL", "svyl", "hdli", "stickl", "mdlp", "SDler", "SDll", "stickle", "sdyl", "stickla", " sdsl", "sdql", "svl", "SDla", "ndl", "sdv", " sdv", "mdla", "hddl", "dkL", "easyl", "mdl", " sdls", "dkla", "easlu", "dkl", "sdsl", "dkql", "ddl", "stickL", "sticklu", "SDlp", "sdll", "ddel", "nddl", "ddlc", " sdlc", "sdls", "SDyl"]}}
{"project": "FFmpeg", "commit_id": "7f2fe444a39bca733d390b6608801c5f002bfd31", "target": 0, "func": "void MPV_decode_mb(MpegEncContext *s, DCTELEM block[6][64])\n\n{\n\n    int mb_x, mb_y;\n\n    int dct_linesize, dct_offset;\n\n    op_pixels_func *op_pix;\n\n    qpel_mc_func *op_qpix;\n\n\n\n    mb_x = s->mb_x;\n\n    mb_y = s->mb_y;\n\n\n\n#ifdef FF_POSTPROCESS\n\n    quant_store[mb_y][mb_x]=s->qscale;\n\n    //printf(\"[%02d][%02d] %d\\n\",mb_x,mb_y,s->qscale);\n\n#endif\n\n\n\n    /* update DC predictors for P macroblocks */\n\n    if (!s->mb_intra) {\n\n        if (s->h263_pred || s->h263_aic) {\n\n          if(s->mbintra_table[mb_x + mb_y*s->mb_width])\n\n          {\n\n            int wrap, xy, v;\n\n            s->mbintra_table[mb_x + mb_y*s->mb_width]=0;\n\n            wrap = 2 * s->mb_width + 2;\n\n            xy = 2 * mb_x + 1 +  (2 * mb_y + 1) * wrap;\n\n            v = 1024;\n\n            \n\n            s->dc_val[0][xy] = v;\n\n            s->dc_val[0][xy + 1] = v;\n\n            s->dc_val[0][xy + wrap] = v;\n\n            s->dc_val[0][xy + 1 + wrap] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[0][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + wrap], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[0][xy + 1 + wrap], 0, 16 * sizeof(INT16));\n\n            if (s->h263_msmpeg4) {\n\n                s->coded_block[xy] = 0;\n\n                s->coded_block[xy + 1] = 0;\n\n                s->coded_block[xy + wrap] = 0;\n\n                s->coded_block[xy + 1 + wrap] = 0;\n\n            }\n\n            /* chroma */\n\n            wrap = s->mb_width + 2;\n\n            xy = mb_x + 1 + (mb_y + 1) * wrap;\n\n            s->dc_val[1][xy] = v;\n\n            s->dc_val[2][xy] = v;\n\n            /* ac pred */\n\n            memset(s->ac_val[1][xy], 0, 16 * sizeof(INT16));\n\n            memset(s->ac_val[2][xy], 0, 16 * sizeof(INT16));\n\n          }\n\n        } else {\n\n            s->last_dc[0] = 128 << s->intra_dc_precision;\n\n            s->last_dc[1] = 128 << s->intra_dc_precision;\n\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n\n        }\n\n    }\n\n    else if (s->h263_pred || s->h263_aic)\n\n        s->mbintra_table[mb_x + mb_y*s->mb_width]=1;\n\n\n\n    /* update motion predictor, not for B-frames as they need the motion_val from the last P/S-Frame */\n\n    if (s->out_format == FMT_H263) { //FIXME move into h263.c if possible, format specific stuff shouldnt be here\n\n      if(s->pict_type!=B_TYPE){\n\n        int xy, wrap, motion_x, motion_y;\n\n        \n\n        wrap = 2 * s->mb_width + 2;\n\n        xy = 2 * mb_x + 1 + (2 * mb_y + 1) * wrap;\n\n        if (s->mb_intra) {\n\n            motion_x = 0;\n\n            motion_y = 0;\n\n            goto motion_init;\n\n        } else if (s->mv_type == MV_TYPE_16X16) {\n\n            motion_x = s->mv[0][0][0];\n\n            motion_y = s->mv[0][0][1];\n\n        motion_init:\n\n            /* no update if 8X8 because it has been done during parsing */\n\n            s->motion_val[xy][0] = motion_x;\n\n            s->motion_val[xy][1] = motion_y;\n\n            s->motion_val[xy + 1][0] = motion_x;\n\n            s->motion_val[xy + 1][1] = motion_y;\n\n            s->motion_val[xy + wrap][0] = motion_x;\n\n            s->motion_val[xy + wrap][1] = motion_y;\n\n            s->motion_val[xy + 1 + wrap][0] = motion_x;\n\n            s->motion_val[xy + 1 + wrap][1] = motion_y;\n\n        }\n\n      }\n\n    }\n\n    \n\n    if (!(s->encoding && (s->intra_only || s->pict_type==B_TYPE))) {\n\n        UINT8 *dest_y, *dest_cb, *dest_cr;\n\n        UINT8 *mbskip_ptr;\n\n\n\n        /* avoid copy if macroblock skipped in last frame too \n\n           dont touch it for B-frames as they need the skip info from the next p-frame */\n\n        if (s->pict_type != B_TYPE) {\n\n            mbskip_ptr = &s->mbskip_table[s->mb_y * s->mb_width + s->mb_x];\n\n            if (s->mb_skiped) {\n\n                s->mb_skiped = 0;\n\n                /* if previous was skipped too, then nothing to do ! \n\n                   skip only during decoding as we might trash the buffers during encoding a bit */\n\n                if (*mbskip_ptr != 0 && !s->encoding) \n\n                    goto the_end;\n\n                *mbskip_ptr = 1; /* indicate that this time we skiped it */\n\n            } else {\n\n                *mbskip_ptr = 0; /* not skipped */\n\n            }\n\n        }\n\n\n\n        dest_y = s->current_picture[0] + (mb_y * 16 * s->linesize) + mb_x * 16;\n\n        dest_cb = s->current_picture[1] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n        dest_cr = s->current_picture[2] + (mb_y * 8 * (s->linesize >> 1)) + mb_x * 8;\n\n\n\n        if (s->interlaced_dct) {\n\n            dct_linesize = s->linesize * 2;\n\n            dct_offset = s->linesize;\n\n        } else {\n\n            dct_linesize = s->linesize;\n\n            dct_offset = s->linesize * 8;\n\n        }\n\n\n\n        if (!s->mb_intra) {\n\n            /* motion handling */\n\n            if((s->flags&CODEC_FLAG_HQ) || (!s->encoding)){\n\n                if ((!s->no_rounding) || s->pict_type==B_TYPE){                \n\n                    op_pix = put_pixels_tab;\n\n                    op_qpix= qpel_mc_rnd_tab;\n\n                }else{\n\n                    op_pix = put_no_rnd_pixels_tab;\n\n                    op_qpix= qpel_mc_no_rnd_tab;\n\n                }\n\n\n\n                if (s->mv_dir & MV_DIR_FORWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture, op_pix, op_qpix);\n\n                    if ((!s->no_rounding) || s->pict_type==B_TYPE)\n\n                        op_pix = avg_pixels_tab;\n\n                    else\n\n                        op_pix = avg_no_rnd_pixels_tab;\n\n                }\n\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture, op_pix, op_qpix);\n\n                }\n\n            }\n\n\n\n            /* add dct residue */\n\n            add_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            add_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            add_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            add_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            add_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            add_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        } else {\n\n            /* dct only in intra block */\n\n            put_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            put_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            put_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            put_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            put_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            put_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        }\n\n    }\n\n the_end:\n\n    emms_c(); //FIXME remove\n\n}\n", "idx": 21779, "substitutes": {"s": ["comments", "rs", "bs", "params", "conf", "ants", "gets", "fs", "ims", "settings", "cs", "stats", "ins", "its", "a", "os", "ls", "es", "z", "ads", "times", "vs", "ties", "ps", "ds", "l", "b", "ts", "less", "ports", "se", "is", "locks", "js", "gs", "m", "bits", "rates", "parts", "bis", "eps", "ms", "ses", "terms", "ss", "results", "aws", "g", "ers", "hs", "services", "sts", "uploads", "http", "sys", "ats", "styles", "pers", "comm", "orders", "spec", "p", "sq", "details", "w", "n", "y", "has", "c", "tests", "as", "storage", "sw", "i", "ns", "webkit", "changes", "e", "sv", "qs", "h", "sg", "properties", "S", "als", "ex"], "block": ["data", "type", "length", "def", "field", "info", "line", "lock", "raw", "config", "shape", "map", "size", "bl", "buffer", "buf", "len", "code", "obj", "row", "null", "byte", "record", "Block", "alloc", "object", "array"], "mb_x": ["mb___ax", "media67xml", "mm_y", "emb_y", "mb67px", "mb08image", "MB_x", "orb_y", "mb10y", "mm_z", "MB_rx", "mb67y", "media67ax", "MB_width", "MB_ex", "orb_x", "orb___y", "mb___x", "mb67xf", "emb_x", "mb10ox", "mm_x", "mm_w", "media_ax", "mb67x", "mb__width", "mb_rx", "mb_image", "MB_y", "mb67ax", "mb_m", "emb_dx", "mb08y", "mb__ex", "orb___x", "media_x", "mb_w", "mb_px", "mb_xml", "mb__y", "mb_width", "mb_X", "orb_px", "mb_ax", "media_px", "mb67ox", "mb67xml", "orb_m", "orb___px", "mx_x", "mb08x", "mb___px", "emb_X", "mx_ox", "mb_dx", "mb10xf", "mb_ox", "mb_xp", "mx_xp", "MB_image", "media67x", "mb10x", "mb_z", "mb_ex", "mb08rx", "media_xml", "mb_xf", "mb__x", "emb_ox", "emb_xf", "mb___xml", "media67px", "mb___y", "mb___m", "orb___m"], "mb_y": ["bigaxyy", "mb5y", "mm_y", "mm_yy", "mb_sy", "big_iy", "raw____ye", "bigaxysy", "record68y", "mb______yy", "mb_vy", "mb68ym", "mp_b", "bigaxyiy", "mb____ys", "mp_Y", "mb_ys", "mt_yy", "mb5ys", "raw_ye", "mb_b", "mbaxyiy", "mb_ym", "mt_x", "mb____ye", "mbtheight", "mp_x", "record_yy", "mb_iy", "big_y", "raw_y", "mm_Y", "raw_ys", "mb5top", "mb_Y", "raw____yy", "mbJtop", "record_ym", "mt_y", "record68ym", "mb______y", "record68yy", "raw____ys", "record_y", "mm_vy", "mt_xy", "mb_ye", "mbJy", "mb____yy", "raw____y", "mbJyy", "raw_yy", "big_sy", "mb68top", "mbtx", "mb_top", "mb____y", "mbJym", "mbtb", "mb5ym", "mb68y", "mbty", "mb68ys", "mbaxyy", "mbaxysy", "mb68yy", "mb_yy", "mp_height", "record68top", "mb______Y", "mp_y", "mb_xy", "mb5yy", "mb______vy", "record_top", "mb_height", "mb68ye", "mb5ye"], "dct_linesize": ["dct_lineszie", "dct_inesizes", "dct_valsz", "dct_codesizes", "dct_valszie", "dct_codeszie", "dct_inesize", "dct_valsize", "dct_valsizes", "dct_codesize", "dct_linesizes", "dct_codesz", "dct_inesz", "dct_linesz", "dct_ineszie"], "dct_offset": ["dft__pos", "dft_pos", "dct__pos", "dft__start", "dct__start", "dct__origin", "dft_origin", "dft_start", "dct_origin", "dct_start", "dft__offset", "dct_pos", "dft__origin", "dft_offset", "dct__offset"], "op_pix": ["op_ppixels", "op_pprix", "op_jpixels", "op_prix", "op_jpix", "op_jprix", "op_pixels", "op_cpixels", "op_cpix", "op_ppix", "op_cpio", "op_ppio", "op_pio", "op_cprix", "op_jpio"], "op_qpix": ["op_wpex", "op_qcpx", "op_qcpix", "op_qppixels", "op_wpx", "op_qnpex", "op_qcpixels", "op_qpixels", "op_qppex", "op_qnpix", "op_wcpex", "op_qppx", "op_wcpix", "op_qppix", "op_qcpex", "op_wcpixels", "op_wcpx", "op_wpixels", "op_qpex", "op_qnpixels", "op_wpix", "op_qpx", "op_qnpx"], "wrap": ["pack", "end", "sp", "hold", "track", "rew", "aw", "wire", "chain", "wind", "roll", "order", "step", "format", "rap", "cycle", "set", "count", "grow", "angle", "x", "safe", "use", "nw", "zip", "box", "range", "shift", "each", "inter", "we", "root", "wrapper", "edge", "html", "loop", "shape", "ew", "align", "ap", "len", "draw", "add", "wra", "pad", "push", "tr", "length", "scroll", "orig", "py", "rw", "offset", "max", "limit", "wp", "raw", "kw", "skip", "patch", "xf", "window", "snap", "row", "crop", "cap", "start", "w", "scale", "wa", "win", "tab", "sw", "wr", "size", "round", "wait", "zag", "code", "arrow"], "xy": ["iy", "xp", "ox", "json", "np", "mie", "yx", "oxy", "copy", "prop", "zz", "dj", "yy", "foo", "axy", "ip", "ge", "x", "yz", "wx", "px", "io", "mo", "zip", "try", "mx", "iso", "o", "xxx", "box", "proxy", "iter", "tif", "wy", "xxxx", "fo", "te", "my", "XY", "xx", "scroll", "orig", "py", "oe", "phy", "offset", "lon", "aux", "axis", "timeout", "pose", "dy", "xf", "route", "note", "lat", "ee", "mop", "bo", "y", "expr", "ti", "xe", "kit", "zx", "go", "ie", "xxxxxxxx", "cho", "ey", "coord", "late", "ji", "zero", "index", "dim", "ex", "ne", "gy"], "v": ["current", "V", "m", "tv", "vv", "vt", "p", "inv", "vc", "ve", "ev", "w", "up", "vs", "av", "va", "value", "n", "y", "vm", "iv", "it", "l", "b", "vol", "c", "vp", "j", "uv", "lv", "i", "version", "t", "size", "u", "g", "vr", "vert", "mint", "cv", "vis", "nv", "sv", "conv", "qv", "h", "x", "pi", "vi", "f", "val"]}}
{"project": "qemu", "commit_id": "ab3ad07f89c7f9e03c17c98e1d1a02dbf61c605c", "target": 1, "func": "static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n", "idx": 21794, "substitutes": {"ram_addr": ["gram_id", "gramptaddr", "rammyaddress", "am_addr", "rampuborder", "rammyadd", "ramptorder", "ram_desc", "ram_ptr", "gram_cmd", "am_address", " ram_len", "ram_address", "gramptorder", " ram_ref", "gram_desc", "am_ptr", "gramitycmd", " ram_address", "ram_cmd", "ram_adr", "ramitycmd", " ram_adr", "ramptaddress", "ramityid", "gramptaddress", "ramityaddr", "ram_ref", "rammyaddr", "gram_src", "gramityaddr", "gramptdesc", "ram_len", "gram_addr", "gram_order", "rampubaddr", "ramitysrc", "ramptdesc", "am_add", "ram_ord", "ram_src", "gramityid", "ram_order", "rammyptr", "rampubaddress", "gramitysrc", "gram_address", "ram_add", "ramptaddr", " ram_ord", "ram_id", "rampubdesc"], "page": ["current", "pid", "command", "post", "list", "profile", "p", "pp", "bar", "file", "parent", "sp", "entry", "image", "pixel", "port", "request", "module", "payment", "copy", "cache", "pl", "result", "line", "tab", "item", "empty", "node", "go", "point", "Page", "pty", "pointer", "server", "map", "document", "step", "message", "phrase", "button", "buffer", "pc", "wait", "collection", "see", "section", "age", "link", "window", "group", "comment", "number", "wiki", "next", "row", "draw", "package", "form", "index", "queue", "policy", "stop", "batch", "new", "commit", "peer", "block", "pool", "table", "pg", "menu"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int decode_i_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n    return 0;\n\n}\n", "idx": 21796, "substitutes": {"v": ["current", "V", "dev", "m", "vv", "tv", "vt", "vc", "inv", "p", "q", "ve", "ev", "vd", "w", "ver", "vs", "av", "qu", "value", "cache", "vm", "y", "iv", "l", "wire", "b", "s", "c", "history", "vp", "j", "uv", "lv", "i", "video", "version", "g", "env", "vr", "rev", "cv", "window", "nv", "ch", "sv", "conv", "qv", "view", "x", "form", "ov", "vi", "f", "val"], "gb": ["ctx", "cfg", "ha", "gc", "gs", "gam", "uf", "eg", "bb", "eb", "nb", "bs", "hog", "bc", "gg", "gm", "sb", "cgi", "tg", "gd", "wb", "Gb", "bytes", "gy", "gu", "GB", "bm", "gnu", "html", "bt", "gh", "deg", "gif", "db", "kb", "g", "rb", "bg", "vg", "pc", "goo", "csv", "mb", "xf", "bf", "xy", "gt", "rg", "fb", "hw", "bys", "hub", "cb", "cv", "bn"], "pqindex": ["Pixaxis", "preqx", "pqaxis", "PixIndex", "pixname", "cqlindex", "pqux", "pquantimage", "pageqfind", "paqindex", "pageqiindex", "pquindex", "pqqind", "pqfind", "Pixindex", "pqqname", "pixaxis", "pqualindex", "pueind", "pqqposition", "Pqindex", "pQnumber", "pageqindex", "cqind", "pageqiimage", "pqualposition", "pQind", "pqnumber", "pqimage", "pueindex", "preqqx", "cqnumber", "paqIndex", "pqualx", "preqqrow", "paixind", "piqindex", "pqIndex", "pqname", "preqqindex", "preqrow", "paixIndex", "pageqimage", "pQIndex", "pqlindex", "pqlnumber", "pquantindex", "pixind", "Pqaxis", "pquposition", "paixname", "pqqx", "paqind", "pqiindex", "pqx", "preqindex", "pageqifind", "paqname", "pqualrow", "pqurow", "cqlind", "pqrow", "piqaxis", "piqIndex", "cqlnumber", "puenumber", "cqindex", "pixIndex", "pQaxis", "pqiimage", "pqifind", "pixindex", "pqposition", "preqposition", "pquantfind", "pQindex", "pqqindex", "pqind", "paixindex", "preqqposition", "pqlind", "pqqrow", "PqIndex", "pqqIndex"]}}
{"project": "qemu", "commit_id": "43e86c8f5b6d9f6279e20dede4e1f7829bdc43b7", "target": 1, "func": "static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n", "idx": 21820, "substitutes": {"s": ["js", "gs", "ls", "sq", "p", "es", "bs", "rs", "si", "sb", "gets", "bis", "n", "ps", "fs", "ds", "b", "c", "cs", "r", "ts", "ses", "ss", "stats", "t", "ns", "its", "hs", "sts", "sv", "sys", "os", "S", "usb", "is", "comm"], "mmcfg_addr": ["mmcfg__addr", "mmcfg_attr", "mmconf_offset", "mmcf_offset", "mmcf_attr", "mmcfg__offset", "mmcf_addr", "mmcfg_ref", "mmfg_addr", "mmcfg_offset", "mmcfg_address", "mmcfg__address", "mmcfg__ref", "mmfg_ref", "mmcf_address", "mmconf_address", "mmconf_addr", "mmfg_address"], "val": ["ctx", "aval", "vt", "data", "p", "ival", " bin", "sel", "loc", " VAL", "util", " msg", "sol", " Val", "value", " al", " lac", "ret", "vol", " resp", "doc", "VAL", "lit", " v", "serv", " arg", " value", "eval", "res", "Val", "pol", "vec", "al", "buf", " aval", "rol", "el", "hal", "mem", " el", " bl", "qual", "vals", "valid", " eval", "v"], "len": ["lf", " l", "num", "ls", " length", "fl", "length", "ln", "ld", "syn", "den", "n", "wid", "Len", "l", "fin", "nl", "lib", "lc", "lan", "fil", "nt", "pos", "t", "size", "en", " le", " clen", "el", "ll", "mem", "h", " bl", "lp", "mid", "elt", "kl", "le", "un"], "pci_dev": ["pci_ev", "pca_Dev", "pci_adv", "pca_gu", "pca_dev", "pciipadv", "pct_adv", "pct_dev", "pci_device", "pca_home", "pci_loc", "pdi_loc", "pci_home", "pciipdev", "pdi_dev", "pci_Dev", "pci_gu", "pdi_device", "pci_switch", "pdi_ev", "pciipswitch", "pct_switch"]}}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n\n{\n\n    int res = 0;\n\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n\n        return AVERROR_INVALIDDATA;\n\n    while (--n >= 0) {\n\n        res <<= 1;\n\n        if (s->bit_index == 0) {\n\n            s->bit_index = 7 + (*s->buf != 0xff);\n\n            s->buf++;\n\n        }\n\n        s->bit_index--;\n\n        res |= (*s->buf >> s->bit_index) & 1;\n\n    }\n\n    return res;\n\n}\n", "idx": 21822, "substitutes": {"s": ["js", "gs", "m", "spec", "tes", "ls", "sq", "es", "rs", "bs", "state", "z", "details", "span", "d", "sb", "vs", "gets", "parts", "ps", "eps", "bis", "fs", "acs", "ims", "ds", "status", "l", "ms", "c", "cs", "as", "sw", "ses", "ts", "serv", "ss", "stats", "aws", "less", "set", "g", "ns", "ies", "its", "ins", "store", "client", "hs", "source", "sts", "sv", "qs", "xs", "sys", "ats", "se", "os", "h", "conv", "S", "als", "ops", "is", "comm"], "n": ["m", "nw", "num", "sn", "p", "np", "nb", "o", "z", "cn", "mn", "w", "nm", "d", "nos", "nn", "nc", "N", "l", " N", "nor", "b", "c", "nl", "no", "j", "nt", "i", "net", "na", "t", "k", "u", "g", "en", "non", "ns", "ng", "count", "number", "len", "a", "e", "nan", "x", "ne", "v"], "bit_index": ["git_key", "bit_name", "bit___index", "bit_value", "byte_max", "bit_position", "byte_level", "bit8length", "bit8ind", " bit_set", " bit_Index", "bit_level", "bit_max", " bit_value", "bit___length", " bit_length", "bit___name", " bit_ind", "bit___ind", "bit8index", "git_index", " bit_name", "bit_Index", "byte_index", "bit_set", "byte_num", "bit_key", "bit_num", "bit_length", "bit_ind", "bit8name", "git_position"], "buf": ["dev", "uf", "num", "data", "big", "nb", "seq", "bag", "bc", "loc", "box", "bin", "mu", "br", "src", "orig", "cache", "lim", "dest", "good", "bound", "text", "max", "limit", "doc", "buff", "raw", "gen", "cmd", "img", "known", "pos", "brace", "fac", "db", "output", "nom", "buffer", "bg", "env", "msg", "vec", "cur", "bu", "off", "desc", "window", "obj", "arr", "str", "queue", "norm", "err", "keep", "cap", "cb"]}}
{"project": "FFmpeg", "commit_id": "bf252f7f6fa9c79743242f3efdd30827c97407b4", "target": 0, "func": "static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    char *str = NULL;\n\n    int size;\n\n    uint16_t str_size;\n\n\n\n    if (c->itunes_metadata) {\n\n        int data_size = get_be32(pb);\n\n        int tag = get_le32(pb);\n\n        if (tag == MKTAG('d','a','t','a')) {\n\n            get_be32(pb); // type\n\n            get_be32(pb); // unknown\n\n            str_size = data_size - 16;\n\n        } else return 0;\n\n    } else {\n\n        str_size = get_be16(pb); // string length\n\n        get_be16(pb); // language\n\n    }\n\n    switch (atom.type) {\n\n    case MKTAG(0xa9,'n','a','m'):\n\n        str = c->fc->title; size = sizeof(c->fc->title); break;\n\n    case MKTAG(0xa9,'A','R','T'):\n\n    case MKTAG(0xa9,'w','r','t'):\n\n        str = c->fc->author; size = sizeof(c->fc->author); break;\n\n    case MKTAG(0xa9,'c','p','y'):\n\n        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;\n\n    case MKTAG(0xa9,'c','m','t'):\n\n    case MKTAG(0xa9,'i','n','f'):\n\n        str = c->fc->comment; size = sizeof(c->fc->comment); break;\n\n    case MKTAG(0xa9,'a','l','b'):\n\n        str = c->fc->album; size = sizeof(c->fc->album); break;\n\n    }\n\n    if (!str)\n\n        return 0;\n\n    get_buffer(pb, str, FFMIN(size, str_size));\n\n    dprintf(c->fc, \"%.4s %s\\n\", (char*)&atom.type, str);\n\n    return 0;\n\n}\n", "idx": 21828, "substitutes": {"c": ["ctx", "cp", "ac", "gc", "m", "cr", "ci", "p", "ca", "vc", "bc", "conf", "xc", "tc", "anc", "cache", "nc", "cm", "mc", "cc", "n", "cod", "C", "sc", "l", "co", "cl", "etc", "com", "chain", "b", "cs", "fc", "lc", "config", "enc", "ec", "comm", "t", "ce", "g", "pc", "ic", "dc", "cv", "cur", "con", "cam", "e", "abc", "ch", "cu", "h", "rec", "cf", "rc", "call", "cal", "err", "cmp", "coll", "f", "cont", "cb", "v", "ct"], "pb": ["ctx", "cp", "pkg", "mont", "uf", "tp", "bb", "p", "np", "pp", "erb", "sp", "bs", "bank", "td", "eb", "req", "jp", "pm", "gm", "tmp", "sb", "tc", "wb", "bp", "pan", "pl", "mp", "ob", "b", "wp", "proc", "vp", "tk", "PB", "pt", "rb", "pc", "pa", "patch", "amp", "msg", "asm", "lb", "dp", "mb", "resp", "snap", "emb", "sys", "lp", "tf", "fb", "fp", "cb", "px", "peer", "pool", "pg"], "atom": ["m", "num", "om", "p", "data", "soc", "at", "name", "entry", "type", "or", "word", "mat", "conf", "kat", "ver", "unit", "ether", "tag", "typ", "tar", "prop", "abel", "tm", "component", "att", "com", "text", "b", "orm", "attr", "canon", "tab", "application", "storage", "item", "sym", "orb", "app", "node", "nt", "format", "element", "key", "msg", "atomic", "al", "coord", "obj", "base", "http", "form", " app", "x", "ata", "part", "op", "binary", "tem", "chem", "term"], "str": ["cr", "Str", "inst", "spec", "rest", "data", "sp", "list", "p", "seq", "name", "tr", "String", "ptr", "tree", "url", "br", "fr", "n", "bytes", "dist", "init", "expr", "chain", "attr", "vol", "rep", "s", "gr", "r", "raw", "iter", "enc", "units", "i", "dr", "print", "t", "STR", "res", "pos", "g", "bl", "buffer", "output", "msg", "txt", "buf", "out", "obj", "ctr", "arr", "usr", "addr", "exec", "err", "st", "f", "cont", "v"], "size": ["height", "get", "sn", "export", "add", "num", "sp", "ose", "body", "z", "name", "SIZE", "si", "length", "small", "type", "notice", "unit", "scale", "Size", "n", "cache", "global", "shift", "amount", "l", "style", "chain", "max", "send", "storage", "scope", "sw", "function", "empty", "speed", "sum", "shape", "args", "loss", "set", "message", "g", "ui", "pos", "see", "count", "member", "len", "zero", "grow", "equal", "form", "format", "ize", "use", "fee", "weight", "dim", "space", "iz", "ze"], "str_size": ["str_length", "str_type", "str_SIZE", "str_Size", "STR_SIZE", " str_ize", "str_ize", "str_set", "STR_set", " str_Size", " str_type", " str_scale", "str_scale", " str_length", " str_SIZE", "STR_size"]}}
{"project": "qemu", "commit_id": "147dfab747dd1720cb6350b6b746ca84e15f9a24", "target": 1, "func": "void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n", "idx": 21836, "substitutes": {"ctx": ["cp", "cfg", "pkg", "gc", "xp", "ac", "check", "ca", "np", "mk", "bc", "req", "loc", "kt", "jp", "quit", "ctrl", "tmp", "xc", "tc", "that", "iat", "conn", "nc", "mc", "cc", "Context", "warn", "co", "etc", "prefix", "acl", "aux", "kw", "tk", "tx", "config", "wd", "scope", "nt", "cmd", "act", "timeout", "auth", "unc", "txt", "ck", "ns", "setup", "wcs", "obj", "ind", "ctr", "context", "crit", "x", "cf", "addr", "hw", "alloc", "ops", "wx", "cmp", "cb", "rc", "ct"], "errp": ["errr", "erP", "errps", "rP", "rr", "errP", "err", " errr", "erps", "rp", " errps", " errP", "rps", "erp"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n\n                                        int buf_size, AVSubtitle *sub)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n\n\n    DVBSubRegion *region;\n\n    DVBSubRegionDisplay *display;\n\n    AVSubtitleRect *rect;\n\n    DVBSubCLUT *clut;\n\n    uint32_t *clut_table;\n\n    int i;\n\n    int offset_x=0, offset_y=0;\n\n\n\n    sub->rects = NULL;\n\n    sub->start_display_time = 0;\n\n    sub->end_display_time = ctx->time_out * 1000;\n\n    sub->format = 0;\n\n\n\n    if (display_def) {\n\n        offset_x = display_def->x;\n\n        offset_y = display_def->y;\n\n    }\n\n\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects <= 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,\n\n                                  sizeof(*sub->rects));\n\n    if (!sub->rects)\n\n        return AVERROR(ENOMEM);\n\n\n\n    i = 0;\n\n\n\n    for (display = ctx->display_list; display; display = display->next) {\n\n        region = get_region(ctx, display->region_id);\n\n        rect = sub->rects[i];\n\n\n\n        if (!region)\n\n            continue;\n\n\n\n        rect->x = display->x_pos + offset_x;\n\n        rect->y = display->y_pos + offset_y;\n\n        rect->w = region->width;\n\n        rect->h = region->height;\n\n        rect->nb_colors = 16;\n\n        rect->type      = SUBTITLE_BITMAP;\n\n        rect->pict.linesize[0] = region->width;\n\n\n\n        clut = get_clut(ctx, region->clut);\n\n\n\n        if (!clut)\n\n            clut = &default_clut;\n\n\n\n        switch (region->depth) {\n\n        case 2:\n\n            clut_table = clut->clut4;\n\n            break;\n\n        case 8:\n\n            clut_table = clut->clut256;\n\n            break;\n\n        case 4:\n\n        default:\n\n            clut_table = clut->clut16;\n\n            break;\n\n        }\n\n\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n        if (!rect->pict.data[1]) {\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n\n        if (!rect->pict.data[0]) {\n\n            av_free(rect->pict.data[1]);\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n\n\n        i++;\n\n    }\n\n\n\n    sub->num_rects = i;\n\n\n\n#ifdef DEBUG\n\n    save_display_set(ctx);\n\n#endif\n\n\n\n    return 1;\n\n}\n", "idx": 21841, "substitutes": {"avctx": [" avconn", " avcontext", "vcontext", "apcmd", "camconn", "camctx", "avconn", "AVtx", " avcmd", "AVconn", "vctx", "apctx", "avcontext", "camtx", "AVctx", "camcontext", " avtx", "avcmd", "vcmd", "aptx", "vtx", "apcontext", "avtx", "AVcontext"], "buf": ["uf", "data", "v", "seq", "bin", "tmp", "bp", "b", "doc", "buff", "img", "db", "buffer", "msg", "ref", "pb", "vec", "mb", "read", "mem", "bf", "arr", "queue", "err", "alloc", "cap", "cb", "cv"], "buf_size": ["buf2size", "buf2len", "buf_len", " buf_SIZE", "buf2Size", " buf_Size", "buf2SIZE", "buf_SIZE", "buf_Size", " buf_len"], "sub": ["rest", "sp", "bs", "sel", "conf", "tmp", "ver", "ray", "sc", "copy", "ext", "test", "lib", "search", "set", "pro", "pb", "summary", "replace", "subject", "con", "sec", "sam", "ch", " subsc", "sup", "st", " unsub", "pop", "mod", "tag", "b", "sum", "member", "desc", "sing", "Sub", "part", "sur", " subp", "rc", "dev", "add", "imp", "seq", "ub", "push", "req", " subs", "super", "aux", "scan", "cond", "watch", "section", "snap", " subt", "rub", "form", "exec", "rel", "stat", "sq", "control", "span", "sb", "delete", "ab", "review", "sh", "tab", "utils", "reg", "match", "repl", "sim", "job", "coord", "rob", "bi", "pre", "rm", "cmp", "val"], "ctx": ["cp", "cfg", "gc", "pkg", "xp", "ca", "np", "qt", "mk", "bc", "conf", "loc", "req", "jp", "kt", "ctrl", "xc", "def", "tc", "iat", "conn", "cm", "mc", "cc", "Context", "sc", "co", "fn", "fc", "lc", "tx", "config", "vp", "kw", "cmd", "org", "act", "ct", "func", "kb", "jac", "cd", "pc", "txt", "ck", "pb", "cv", "setup", "resp", "cam", "wcs", "obj", "context", "mem", "conv", "tz", "sys", "cf", "addr", "exec", "hw", "ia", "cmp", "px", "course", "cb", "ctl", "comm"], "display_def": ["displayistdef", "display_if", "route_id", "displaytdef", "displaydefparent", "recordtDEF", "displaypydefined", "release_def", "releasepydef", "displaydefdef", "play_defined", "releasepydes", "recordtdict", "record_dict", "display_defined", "displayistDEF", "displaylydef", "display_dict", "display_parent", "displaydefid", "displaylydes", "displaylydefinition", "display_des", "display2definition", "display2des", "displaytdict", "play_if", "displaydefdefined", "display_definition", "displaypydec", "display2dec", "displaypyif", "routedefdef", "release_des", "display_decl", "displayistdict", "displaypydefinition", "routedefid", "record_decl", "record_DEF", "displaypydes", "displaypydef", "displaytDEF", "displayistdecl", "displaypydecl", "play_decl", "release_definition", "route_parent", "releasepydec", "routedefparent", "display_id", "release_dec", "route_def", "display2def", "route_defined", "displaylydec", "record_def", "displaytdecl", "recordtdecl", "routedefdefined", "display_DEF", "releasepydefinition", "display_dec", "play_def", "recordtdef"], "region": ["rest", "associated", "direction", "memory", "slot", "unit", "definition", "browser", "role", "feature", "address", "render", "format", "collection", "summary", "ge", "gru", "record", "reference", "resource", "dimension", "block", "country", "table", "cell", "command", "gc", "character", "radius", "manager", "division", "widget", "range", "cache", "resolution", "component", "scope", "config", "remote", "directory", "area", "relation", "texture", "program", "roy", "module", "domain", "application", "r", "grid", "angular", "location", "network", "REG", "section", "language", "monitor", "connection", "progress", "zone", "riot", "volume", "description", "library", "layout", "script", "Region", "rar", "reg", "regulation", "dim"], "display": ["rest", "check", "full", "gl", "by", "can", "disc", "definition", "browser", "role", "chain", "displayText", "mac", "render", "origin", "store", "record", "condition", "table", "command", "list", "data", "be", "d", "execute", "widget", "range", "screen", "visible", "doc", "date", "find", "print", "remote", "map", "message", "position", "see", "device", "local", "present", "draw", "program", "report", "PLAY", "debug", "domain", "rem", "application", "dis", "app", "readable", "location", "pose", "play", "route", "form", "view", "monitor", "design", "description", "played", "player", "def", "layout", "show", "Display", "no", "plays", "update", "buffer", "process", "out", "dim"], "rect": ["ror", "rog", "rest", "dir", "cor", "json", "rot", "dial", "tri", "sc", "RECT", "ret", "attr", "assert", "dr", "pt", "grab", "client", "resp", "store", "ind", "prot", "mod", "box", "rn", "prefix", "rt", "remote", "col", "desc", "hist", "rib", "art", "cont", "tr", "loc", "ptr", "br", "rem", "rep", "r", "act", "res", "txt", "nav", "lat", "row", "form", "Rect", "err", "rel", "progress", "opt", "riot", "pr", "def", "tar", "feat", "rent", "expr", "cmd", "reg", "round", "vr", "ref", "coord", "rob", "rr", "addr", "rm", "val"], "clut": ["ctou", "klott", "ctat", "Clut", "crut", "llcut", "lcou", "Cluti", "klut", "slut", "lluti", "llut", "sclut", "clud", "clu", " cluti", "cam", "ccud", " clute", "crur", "Cluts", "ccuti", "sclott", "slute", "ccu", "squut", " clutter", "cluts", "crutt", "compou", "llutation", " clutt", "jpg", "clutt", " clust", "sluti", "ccut", "lut", "cont", "lcutter", "llott", "clcut", "slust", "sclcut", "compute", "cruti", "clur", "slutter", "ctu", "clust", " clur", "kluti", "bl", "ccat", "luts", "clott", "blud", "obj", "lutation", "squat", "ccou", "exec", "cluti", "klur", "lcust", " clou", "squou", "blutter", "slud", "clute", "_", "lluts", "ctut", "def", "clutter", "scluti", "c", "bluti", "klutt", "func", "lcute", "clutation", "klcut", "select", "clat", "squu", "comput", "luti", "Clutation", "ccutter", "blut", "dim", "clou", "lcut"], "clut_table": ["clut2table", "clut___table", "clurt___table", "clurt_Table", "clut_collection", "clurt___Table", "clut_internal", "clut___interface", "clurt_table", "clurt___interface", "clUT_table", "clut67interface", "clut67Table", "clurt_interface", "clut67function", "clut_buffer", "clut67table", "clut___TABLE", "clut___buffer", "clut___internal", "clUT_collection", "clurt_function", "clut2TABLE", "clut_Table", "clut_function", "clut_interface", "clut___function", "clurt___function", "clUT_internal", "clUT_Table", "clut_TABLE", "clUT_buffer", "clUT_TABLE", "clut___Table", "clut2Table"], "i": ["iy", "m", "me", "ci", "ix", "p", "id", " bi", "si", "ori", "n", "ei", "y", "it", "xi", "ij", "ti", "mi", "qi", "c", "r", "j", "di", "ai", "k", " ii", "gi", "phi", "ic", "li", " j", "ip", "sim", "ri", "ji", "ini", "bi", "ind", "index", "ii", "x", "pi", "I", "ia", "yi", "ik", "im"]}}
{"project": "FFmpeg", "commit_id": "7b46add7257628bffac96d3002308d1f9e1ed172", "target": 0, "func": "static QUANT_FN(pvq_encode_band)\n\n{\n\n    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,\n\n                               lowband_out, level, gain, lowband_scratch, fill, 1);\n\n}\n", "idx": 21851, "substitutes": {}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_set_phys_mem(target_phys_addr_t start_addr,\n\n\t\t\t     ram_addr_t size,\n\n\t\t\t     ram_addr_t phys_offset)\n\n{\n\n    KVMState *s = kvm_state;\n\n    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;\n\n    KVMSlot *mem, old;\n\n    int err;\n\n\n\n    /* kvm works in page size chunks, but the function may be called\n\n       with sub-page size and unaligned start address. */\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    start_addr = TARGET_PAGE_ALIGN(start_addr);\n\n\n\n    /* KVM does not support read-only slots */\n\n    phys_offset &= ~IO_MEM_ROM;\n\n\n\n    while (1) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);\n\n        if (!mem) {\n\n            break;\n\n        }\n\n\n\n        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&\n\n            (start_addr + size <= mem->start_addr + mem->memory_size) &&\n\n            (phys_offset - start_addr == mem->phys_offset - mem->start_addr)) {\n\n            /* The new slot fits into the existing one and comes with\n\n             * identical parameters - nothing to be done. */\n\n            return;\n\n        }\n\n\n\n        old = *mem;\n\n\n\n        /* unregister the overlapping slot */\n\n        mem->memory_size = 0;\n\n        err = kvm_set_user_memory_region(s, mem);\n\n        if (err) {\n\n            fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\",\n\n                    __func__, strerror(-err));\n\n            abort();\n\n        }\n\n\n\n        /* Workaround for older KVM versions: we can't join slots, even not by\n\n         * unregistering the previous ones and then registering the larger\n\n         * slot. We have to maintain the existing fragmentation. Sigh.\n\n         *\n\n         * This workaround assumes that the new slot starts at the same\n\n         * address as the first existing one. If not or if some overlapping\n\n         * slot comes around later, we will fail (not seen in practice so far)\n\n         * - and actually require a recent KVM version. */\n\n        if (s->broken_set_mem_region &&\n\n            old.start_addr == start_addr && old.memory_size < size &&\n\n            flags < IO_MEM_UNASSIGNED) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = old.memory_size;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error updating slot: %s\\n\", __func__,\n\n                        strerror(-err));\n\n                abort();\n\n            }\n\n\n\n            start_addr += old.memory_size;\n\n            phys_offset += old.memory_size;\n\n            size -= old.memory_size;\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->phys_offset = old.phys_offset + size_delta;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size)\n\n        return;\n\n\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED)\n\n        return;\n\n\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->phys_offset = phys_offset;\n\n    mem->flags = 0;\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n", "idx": 21863, "substitutes": {"start_addr": ["wind_attr", "startingptptr", "startippoints", "start_tag", " start__addr", "head00addr", "start___arch", "start_offset", "startingptattr", "rootwaddr", "start67arm", "starting_tag", "head_alt", "head_grad", "firstabledir", "startablereq", "scan_inter", " start_adr", " start_ag", "firstableaddr", "startippad", "startingloc", "startingingadr", " start_add", "startingjadr", "starting_conn", "start__ord", "start67ptr", "starting_addr", "start_address", "startwarch", "end_address", "scan67arr", "start__add", " start_address", "startxad", " start_url", "scan_adr", "from_addr", "start00grad", "start_gz", "startablearm", "root_offset", "startipadr", "fromableerr", "start00addr", "start___ord", "start67adr", "startjaddr", "start___offset", "start_attr", "first_addr", "start2dir", "starting_dir", "startptaddr", " start_attr", "startipattr", "wind_loc", "startingjdir", "start_ptr", " start_ad", "start_loc", "startwoffset", "starting___err", "start_points", "startingjaddr", "starting_mag", "start67tag", "start_conn", "start2addr", "startjpad", "rootwarch", "start_dir", "root_addr", "start___mt", "startptptr", "startjadr", "startingattr", "startingingaddr", "fromablereq", "startingaddr", " start__ag", "rootwoffset", "start_err", "scan67addr", "start_grad", "startingjmag", "startipaddr", "start2mag", "startingadd", "startableadd", "startableconn", "starting_attr", "starting_arm", "start_alt", "start__ag", "starting_ord", "startableerr", "start_url", "head_addr", "end_add", "start_mt", "scan67inter", "starting___addr", "fromablearm", "start___err", "startingdir", "startxaddr", "startingmt", "start_inter", "startipurl", " start_points", "start67arr", "starting_gz", "startwaddr", "start_add", "start_az", "starting_adr", "startableaddr", "starting_req", "start_adr", "start67az", "startingingmt", "end_attr", "starting___gz", "start__address", "start67addr", "wind_addr", "start00conn", " start__add", "startingurl", "start67ad", "startjmag", "start2adr", "startingptaddr", "head00alt", " start__address", "startingadr", "root_arch", "startxaz", "start_arr", "startableaddress", "startwmt", "startjdir", "startingingreq", "startobjgz", "scan_addr", "first_dir", " start_az", "start__adr", "rootwmt", "start67conn", " start_pad", "first_add", "startptattr", " start_ord", "start00alt", "first_address", "start67inter", "startobjaddr", "startingreq", "start__addr", "start67cmd", "start___gz", "startingaddress", "starting_ptr", "end_addr", "startablealt", "start_pad", "startobjord", "start_ad", "start_cmd", "start67attr", "head_conn", "scan67adr", "startockerr", "wind_adr", "from_err", "starting_cmd", "startabledir", "start_mag", "scan_arr", "firstableadd", "startingptconn", "startablegrad", "head00grad", "starting___ord", "start_arm", "starting_mt", "start_arch", "startjpoints", "startptconn", "start_req", "from_arm", "fromableaddr", "startockarm", "starting_err", "start_ord", "root_mt", "startockreq", "firstableaddress", "startobjerr", "start___addr", "startockaddr", "start_ag", " start_arr", "head00conn", "from_req"], "size": ["south", "name", "type", "by", "needed", "capacity", "large", "too", "mode", "settings", "address", "speed", "set", "izes", "count", "sized", "ize", "dimension", "command", "data", "z", "SIZE", "resources", "Size", "shift", "scope", "sum", "shape", "pos", "area", "message", "members", "member", "len", "equal", "sy", "m", "state", "si", "length", "small", "offset", "status", "max", "ms", "send", "empty", "g", "news", "total", "window", "time", "fee", "space", "stat", "zone", "height", "start", "body", "id", "scale", "n", "win", "style", "sh", "storage", "sw", " sizes", "number", "code", "zero", "sex", "index", "addr", "new", "dim", "iz"], "phys_offset": ["physipOffset", "phys_addr", "phys_align", "phys_offer", "phys___offset", "physmingOffset", "hist_padding", "phys_delay", "phys_Offset", "physical_start", "phys8offset", "physjpadding", "phys8offs", "physical_count", "physical_address", "cpu_offs", "physical_pad", "physableoffset", "hist_delay", "histacdelay", "phys8Offset", "phys_pad", "phys____position", "physactile", "physical_off", "physjdelay", "physmingoff", "phys__pad", "phys___offer", "physical_offer", "physical_position", "physacoffset", "physipposition", "physablepad", "phys___Offset", "histactile", "phys_tile", "physacdelay", "physongpadding", "physjtile", "hist_tile", "phys___address", "physipstart", "phys_count", "physical_offset", "phys_start", "histacoffset", "physongtile", "physongdelay", "hist_offset", "physical_align", "cpu_Offset", "histacpadding", "phys_padding", "phys__Offset", "phys_unit", "phys_address", "physical_Offset", "physablealign", "phys____offset", "physical_addr", "physipoffset", "physongoffset", "phys8addr", "physmingoffset", "phys_off", "phys__align", "phys_position", "physjoffset", "phys_offs", "physacpadding", "physmingunit", "cpu_offset", "physical_unit", "physableOffset", "cpu_addr", "phys____Offset", "phys__offset", "phys____start"], "s": ["js", "m", "gs", "south", "spec", "sl", "ls", "p", "sq", "sp", "rs", "state", "z", "es", "conf", "w", "sb", "service", "n", "ps", "fs", "sis", "ds", "self", "sm", "ims", "ms", "c", "settings", "as", "r", "sw", "ses", "ts", "serv", "ss", "i", "t", "args", "less", "set", "g", "ns", "ies", "setup", "its", "hs", "a", "sam", "ares", "sts", "sv", "qs", "support", "h", "sys", "os", "S", "new", "space", "is", "v", "comm"], "mem": ["memory", "slot", "um", "copy", "ret", "mi", "med", "arm", "mac", "ems", "phys", "nom", "store", "buf", "md", "ram", "sam", "term", "mm", "mx", "am", "mod", "mn", "ann", "cache", "tm", "mp", "man", "doc", "buff", "serv", "known", "sum", "map", "member", "mb", "hist", "emb", "tim", "temp", "js", "m", "me", "program", "my", "alt", "pm", "ptr", "imm", "rem", "lim", "sm", "ame", "ms", "raw", "item", "na", "gram", "mor", "dem", "msg", "txt", "mind", "lem", "alloc", "mop", "em", "mini", "mat", "nm", "Mem", "mc", "tab", "cmd", "go", "reg", "met", "ref", "sim", "gem", "EM", "index", "addr", "new", "rm", "dim", "tem", "mt", "ne", "val"], "old": ["lf", "ard", "and", "full", "hold", "told", "tmp", "ver", "ld", "ext", "test", "good", "expected", "set", "et", "two", "other", "md", "ind", "last", "OLD", "same", "list", "mod", "common", "range", "dirty", "att", "buff", "args", "less", "ed", "lt", "Old", "au", "local", "art", "back", "un", "temp", "high", "m", "reset", "my", "alt", "or", "small", "low", "orig", "original", "aux", "raw", "existing", "ord", "item", "act", "olds", "from", "var", "al", "el", "obj", "def", "bound", "bold", "cmd", "older", "ref", "off", "event", "all", "pre", "lost", "hard", "new", "ex", "val"], "err": ["aaa", "kr", "cer", "conf", "conn", "ext", "test", "eric", "attr", "yr", "dr", "gz", "erer", "rev", "count", "arr", "ler", "die", "erd", "cb", "der", "try", "inner", "exc", "hz", "z", "are", "orer", "doc", " ptr", "iter", "later", "error", "eas", " score", "len", " len", "norm", "Error", "priv", "eor", "js", "rer", "cr", "mr", "state", "ere", "ev", "req", "or", "notice", "ptr", "fr", "timer", "better", "er", "act", "res", "msg", "obj", "Er", "sys", "str", "esp", "ger", "elt", "fee", "valid", "rel", "cfg", "pr", "ier", "orum", "n", "ah", "expr", "lr", "cmd", "t", "ner", "out", "late", "coord", "e", "rr", "plain", "ered"]}}
{"project": "qemu", "commit_id": "0fbf50b6ec126600dca115adb1563c657cc27695", "target": 1, "func": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n", "idx": 21889, "substitutes": {"opaque": ["ocaddress", "ipaddress", "ipce", "opce", "ocaque", "appaque", "ipaque", "opaddress", "appce", "occe", "appaddress"], "addr": ["spec", "add", "Address", "start", "id", "name", "req", "ptr", "tag", "url", "src", "offset", "attr", "address", "ord", "cmd", "host", "map", "key", "var", "hash", "len", "handle", "str", "rel", "label", "bind"], "val": ["ctx", "Value", "sl", "bin", "value", " tx", "b", "tx", "serv", " arg", " value", "eval", "bl", "db", "Val", "ref", "vec", "al", "buf", "len", "arg", "base", "arr", "ee", "vals", " interval", "v"], "size": ["name", "type", "SIZE", "length", "loc", "tag", "scale", "Size", "n", "offset", "info", "send", "address", "empty", "sum", "pos", "message", "count", "align", "desc", "len", "code", "index", "ize", "weight", "fee", "cap"]}}
{"project": "FFmpeg", "commit_id": "c81185a18333b28439476fdc00979225158c8755", "target": 1, "func": "void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = ALIGN(*width , w_align);\n\n    *height= ALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n}", "idx": 21899, "substitutes": {"s": ["js", "gs", "m", "south", "comments", "spec", "ls", "tes", "p", "rs", "bs", "details", "conf", "w", "d", "sb", "vs", "sports", "n", "ps", "bis", "ims", "ds", "status", "b", "c", "cs", "r", "ts", "ses", "terms", "ss", "stats", "t", "aws", "less", "set", "g", "ns", "ies", "its", "changes", "a", "hs", "e", "sam", "sts", "sv", "qs", "h", "sys", "os", "S", "ops", "ex", "is", "v", "comm"], "height": ["Height", "stroke", "ty", "volume", "ows", "data", "depth", "radius", "background", "length", "distance", "w", "padding", "resolution", "y", "ht", "capacity", "style", "gravity", "history", "density", "build", "shape", "size", "position", "total", "window", "hang", "grow", "th", "ch", "angle", "view", "h", "x", "bottom", "block", "ish"]}}
{"project": "FFmpeg", "commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "target": 1, "func": "void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n", "idx": 21919, "substitutes": {"c": ["ac", "cp", "ctx", "gc", "cr", "ci", "oc", "p", "ca", "vc", "v", "z", "at", "bc", "conf", "d", "xc", "tc", "anc", "cache", "nc", "cm", "mc", "cc", "sc", "C", "cl", "co", "l", "etc", "com", "chain", "b", "proc", "cs", "fc", "acl", "lc", "config", "enc", "ec", "uc", "comm", "t", "ce", "g", "cd", "pc", "ic", "dc", "unc", "count", "cv", "con", "cam", "e", "abc", "ch", "cu", "form", "cf", "call", "err", "cmp", "coll", "f", "cont", "cb", "rc", "ct"], "buf": ["ctx", "cp", "uf", "end", "p", "data", "bar", "v", "seq", "bc", "loc", "tmp", "ptr", "xff", "bp", "br", "Buffer", "orig", "bytes", "b", "buff", "raw", "cmd", "pos", "map", "bl", "rb", "buffer", "msg", "txt", "stream", "ref", "pb", "vec", "read", "cur", "off", "len", "ctr", "mem", "bf", "queue", "batch", "new", "begin", "alloc", "cap", "block", "pool", "cb", "cv"], "buf_size": ["bufswargs", "buf2size", "bufswSize", "buf_args", "buf2Size", " buf_Size", "buffer_Size", "buf2ize", "buffer_size", "buffer_ize", "buf2SIZE", " buf_args", "buf_SIZE", "buf_Size", "buf2args", "buf_ize", "bufswsize", "buffer_SIZE"]}}
{"project": "FFmpeg", "commit_id": "2c90316b46fce5785bc6af72c8fd369c31666604", "target": 1, "func": "static int hls_read_header(AVFormatContext *s)\n\n{\n\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n\n    HLSContext *c = s->priv_data;\n\n    int ret = 0, i;\n\n    int highest_cur_seq_no = 0;\n\n\n\n    c->ctx                = s;\n\n    c->interrupt_callback = &s->interrupt_callback;\n\n    c->strict_std_compliance = s->strict_std_compliance;\n\n\n\n    c->first_packet = 1;\n\n    c->first_timestamp = AV_NOPTS_VALUE;\n\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n\n\n    if (u) {\n\n        // get the previous user agent & set back to null if string size is zero\n\n        update_options(&c->user_agent, \"user-agent\", u);\n\n\n\n        // get the previous cookies & set back to null if string size is zero\n\n        update_options(&c->cookies, \"cookies\", u);\n\n\n\n        // get the previous headers & set back to null if string size is zero\n\n        update_options(&c->headers, \"headers\", u);\n\n\n\n        // get the previous http proxt & set back to null if string size is zero\n\n        update_options(&c->http_proxy, \"http_proxy\", u);\n\n    }\n\n\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = save_avio_options(s)) < 0)\n\n        goto fail;\n\n\n\n    /* Some HLS servers don't like being sent the range header */\n\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n\n\n    if (c->n_variants == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n    /* If the playlist only contained playlists (Master Playlist),\n\n     * parse each individual playlist. */\n\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n\n        for (i = 0; i < c->n_playlists; i++) {\n\n            struct playlist *pls = c->playlists[i];\n\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n\n                goto fail;\n\n        }\n\n    }\n\n\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n\n\n    /* If this isn't a live stream, calculate the total duration of the\n\n     * stream. */\n\n    if (c->variants[0]->playlists[0]->finished) {\n\n        int64_t duration = 0;\n\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n\n        s->duration = duration;\n\n    }\n\n\n\n    /* Associate renditions with variants */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *var = c->variants[i];\n\n\n\n        if (var->audio_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n\n        if (var->video_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n\n        if (var->subtitles_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n\n    }\n\n\n\n    /* Create a program for each variant */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *v = c->variants[i];\n\n        AVProgram *program;\n\n\n\n        program = av_new_program(s, i);\n\n        if (!program)\n\n            goto fail;\n\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n\n    }\n\n\n\n    /* Select the starting segments */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n\n    }\n\n\n\n    /* Open the demuxer for each playlist */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        AVInputFormat *in_fmt = NULL;\n\n\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->index  = i;\n\n        pls->needed = 1;\n\n        pls->parent = s;\n\n\n\n        /*\n\n         * If this is a live stream and this playlist looks like it is one segment\n\n         * behind, try to sync it up so that every substream starts at the same\n\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n\n         * all active streams within the first few seconds). This is not very generic,\n\n         * though, as the sequence numbers are technically independent.\n\n         */\n\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n\n            pls->cur_seq_no = highest_cur_seq_no;\n\n        }\n\n\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n\n        if (!pls->read_buffer){\n\n            ret = AVERROR(ENOMEM);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n\n                          read_data, NULL, NULL);\n\n        pls->pb.seekable = 0;\n\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n\n                                    NULL, 0, 0);\n\n        if (ret < 0) {\n\n            /* Free the ctx - it isn't initialized properly at this point,\n\n             * so avformat_close_input shouldn't be called. If\n\n             * avformat_open_input fails below, it frees and zeros the\n\n             * context, so it doesn't need any special treatment like this. */\n\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        pls->ctx->pb       = &pls->pb;\n\n        pls->ctx->io_open  = nested_io_open;\n\n\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n\n            goto fail;\n\n\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n\n            avformat_queue_attached_pictures(pls->ctx);\n\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n\n            pls->id3_deferred_extra = NULL;\n\n        }\n\n\n\n        if (pls->is_id3_timestamped == -1)\n\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n\n\n        /*\n\n         * For ID3 timestamped raw audio streams we need to detect the packet\n\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n\n         * on us if they want to.\n\n         */\n\n        if (pls->is_id3_timestamped) {\n\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n\n\n        /* Create new AVStreams for each stream in this playlist */\n\n        ret = update_streams_from_subdemuxer(s, pls);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n\n    }\n\n\n\n    update_noheader_flag(s);\n\n\n\n    return 0;\n\nfail:\n\n    free_playlist_list(c);\n\n    free_variant_list(c);\n\n    free_rendition_list(c);\n\n    return ret;\n\n}\n", "idx": 21925, "substitutes": {"s": ["ctx", "js", "gs", "south", "m", "sets", "spec", "ls", "p", "sq", "es", "rs", "bs", "conf", "times", "w", "sb", "vs", "parts", "sc", "n", "ps", "bis", "fs", "ims", "ds", "b", "cs", "settings", "as", "sw", "ses", "ts", "ss", "stats", "t", "aws", "less", "ns", "its", "ins", "changes", "csv", "a", "hs", "sts", "sv", "qs", "xs", "sys", "ats", "sg", "h", "os", "se", "S", "ex", "is", "sports", "comm"], "u": ["uf", "ur", "p", "us", "yu", "o", "un", "q", "ex", "su", "user", "util", "up", "um", "uk", "mu", "it", "ue", "etc", "uni", "b", "edu", "uu", "iu", "ou", "lu", "gu", "r", "gnu", "uv", "nu", "unic", "ut", "t", "tu", "g", "U", "ui", "upload", "ux", "ul", "ru", "out", "au", "cu", "hu", "uid", "eu", "fu", "pu", "f"], "c": ["ctx", "cp", "ac", "gc", "m", "cr", "comments", "current", "ci", "p", "ca", "vc", "o", "cn", "bc", "conf", "can", "tc", "anc", "cache", "sc", "cm", "mc", "cc", "nc", "n", "C", "cl", "co", "l", "etc", "com", "chain", "b", "cs", "fc", "r", "lc", "config", "enc", "cus", "ec", "uc", "comm", "t", "ce", "pc", "cd", "unc", "dc", "cur", "cv", "con", "cam", "e", "abc", "cu", "h", "cf", "rc", "call", "cmp", "coll", "f", "cont", "cb", "ct"], "i": ["hi", "m", "me", "ci", "ix", "p", "us", "o", "id", "si", "zi", "multi", "n", "ei", "y", "it", "xi", "l", "ims", "ij", "ti", "mi", "b", "qi", "iu", "r", "j", "di", "in", "ir", "\u0438", "ai", "t", "k", "g", "ma", "gi", "phi", "ic", "li", "ui", "cli", "sim", "ip", "iq", "ri", "ji", "ini", "e", "bi", "ind", "oi", "index", "ii", "x", "pi", "batch", "I", "ami", "f", "ki"], "pls": ["splts", " plls", "slis", "Plts", "slds", " plgs", "sls", "plds", " plts", "Plls", "Pls", "Plgs", "Plds", " plds", "spls", "splis", "Plis", "plls", "plts", "slgs", " plis", "plgs", "slls", "plis", "splls"]}}
{"project": "FFmpeg", "commit_id": "8a9641a652ed1546fedfda22584f79d3d423096e", "target": 0, "func": "AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)\n\n{\n\n    AVBitStreamFilter *bsf = first_bitstream_filter;\n\n\n\n    while (bsf) {\n\n        if (!strcmp(name, bsf->name)) {\n\n            AVBitStreamFilterContext *bsfc =\n\n                av_mallocz(sizeof(AVBitStreamFilterContext));\n\n            bsfc->filter    = bsf;\n\n            bsfc->priv_data =\n\n                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;\n\n            return bsfc;\n\n        }\n\n        bsf = bsf->next;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21938, "substitutes": {"name": ["action", "description", "p", "data", "family", "ment", "alias", "id", "type", "word", "filename", "power", "path", "w", "priority", "tag", "value", "n", "on", "named", "init", "ame", "text", "prefix", "info", "admin", "scope", "no", "template", "order", "format", "search", "version", "size", "buffer", "key", "ref", "names", "NAME", "code", "now", "base", "local", "title", "str", "Name", "filter", "new", "space", "sequence", "cap", "ne"], "bsf": ["inscf", "jscf", "insfac", "bsfp", "bpfs", "bsfe", "absf", "vsfac", "bpsuf", "byscf", "gsf", "gscf", "lsfc", "insf", "bpcf", "bysfs", "ckscf", "jsfc", "lsf", "itsf", "bscf", "abscf", "insfc", "besfe", "bysfe", "psuf", "atsf", "gsv", "jsf", "itscf", "gsfc", "jsuf", "psfac", "bpf", "tsfc", "bescf", "itsfac", "bpscf", "nsfc", "bsfac", "itsfc", "psf", "nscf", "bsuf", "bpsfc", "bpsf", "tscf", "gsfac", "gsfx", "bysf", "jsfp", "bsfx", "bpfc", "bsfs", "cksfp", "cksf", "nsf", "lsv", "besf", "tsfs", "itsfs", "vsfc", "lsfx", "bpsfx", "vscf", "atscf", "psfp", "atsuf", "psfc", "absfc", "absfac", "nsuf", "atsfc", "itsfe", "vsf", "bsv", "pscf", "nsfs", "bpsv", "cksfc", "tsf", "besfs"], "bsfc": ["actionscf", "fsfw", "bitscf", "ksf", "actionsfd", "bitsfc", "ubspic", "bpsfd", "ckscf", "fsunc", "bpscf", "fsfc", "bspic", "fscf", "bscf", "absf", "bsfac", "abscf", "ubsfac", "bitsfw", "lspic", "bsfw", "bpsfac", "bpsfc", "ubsfc", "lsfd", "cksfw", "bsunc", "cksunc", "kspic", "ubscf", "lsfc", "bsfd", "bitsunc", "ubsfd", "absfc", "lscf", "ksfc", "kscf", "absfd", "ubsf", "ksfd", "cksfc", "actionsfac", "actionsfc"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 21957, "substitutes": {}}
{"project": "qemu", "commit_id": "cdad4bd8940c6fb1616733550663d006c611b2f4", "target": 1, "func": "BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n", "idx": 21958, "substitutes": {"bdrv": ["btrh", "bdrm", "bbdrvr", "btrf", "bderw", " bderv", " bdrh", "brv", "brvr", "ddrv", "bbdrV", "bderi", "bgrf", "dsri", "bdrf", "bsrw", "bgrm", "bdriv", "bderh", "bbrv", "bdrvr", "dsrw", "brvd", "bderf", "bdrj", " bdrf", " bdrm", "bsrv", "ddri", "bcrvr", "bbrvr", "bsri", "bdrii", "bgrh", "bdrw", " bderm", "btrm", "bbdrv", "bderv", "bdri", "bdrh", "bderj", "bbrvd", "bdriw", "bcrvd", "brV", "bdrvd", "btrv", "ddrw", "bdrij", "bderm", " bderh", "ddrj", " bderf", "bcrV", "dsrv", "bsrj", "bdrV", "bbrV", "dsrj", "bgrv", "bbdrvd", "bcrv"], "index": ["check", "ox", "write", "column", " ind", " indic", "test", "capacity", "address", "unknown", "cycle", "where", "collection", "count", "Index", "instance", "ind", "x", "call", "ask", "dimension", "list", "exist", "nn", "suggest", "each", "prefix", "mix", "config", "iter", "date", "find", "in", "loop", "document", "position", "read", "local", "seek", "draw", "present", "connect", "num", "add", "loc", "send", "empty", "axis", "point", "act", "timeout", "open", "create", "level", "row", "display", "connection", "coll", "bo", "IND", "ix", "alias", " sidx", "seed", "foot", "author", "scale", " indent", "eight", "show", "sw", "\u00e7", "connected", "query", "go", "size", "update", "key", "gate", "select", "process", "number", "out", "zero", "context", "EX", "stick", "ex", "label"]}}
{"project": "qemu", "commit_id": "671f66f87fbf6cc6a3879f3055f16347b1db91e9", "target": 1, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}", "idx": 21962, "substitutes": {"obj": ["any", "js", "ctx", "inst", "inv", "o", "objects", "gov", "tmp", "typ", "orig", "it", "Object", "att", "ht", "expr", "ob", "attr", "stuff", "obo", "tk", "j", "po", "cmd", "nt", "onet", "go", "act", "unknown", "org", "bh", "bj", "txt", "resp", "obs", "xy", "str", "os", "oid", "hw", "elt", "object", "Obj", "ex", "cont", "bo"], "nf": ["onfc", "cnbf", " nfe", "ynaf", "onf", "cnfo", "pnf", "cnuf", "pnfac", "nbf", "ynv", "nefo", "cnaf", " nuf", "nuf", "nfb", "cnv", " nfac", "pnaf", " nv", "pnfc", "cnf", "naf", " nxf", "nfe", "nef", "ynfc", "nxf", "ynf", "onfg", "cnfac", "nefc", "ynxf", " nfb", "nfg", " nbf", "onfo", "nefe", "nv", "ynbf", "ynuf", "onfe", "pnfb", "cnxf", "cnfc", "cnfb", " nfg", "ynfb", " nfo", "nfo", "cnfg", "nfac"], "nfc": ["onfc", "anxf", "npc", "onlc", "panfc", "onf", "nonlc", " ncf", " nlc", "nlc", "panlc", "nonfc", "panfr", "nonpc", "onpc", "Nxf", "ncf", " nfr", " nxf", "Ncf", "anfc", "nxf", "nfr", "Nf", "nonf", "onfr", "anf", "Nfc", " npc", "ancf", "panf"]}}
{"project": "qemu", "commit_id": "7839ff593be03a7de3c6760e0b50c565ea751d36", "target": 1, "func": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n", "idx": 21967, "substitutes": {"args": ["cfg", "gs", "bits", "params", "ams", "amps", "flags", "ants", "gb", "parts", "eps", "css", "fs", "ims", "init", "ds", "ms", "limits", "cs", "settings", "Args", "ts", "terms", "config", "cmd", "aws", "aus", "atts", "ns", "ks", "md", "ags", "arg", "qs", "uments", "properties", "vals", "caps", "fields", "GS"]}}
{"project": "qemu", "commit_id": "ef0e8fc768a561dd13a86420b3268f6f3d5d0621", "target": 1, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 21969, "substitutes": {"dev": ["spec", "serial", "p", "data", "ve", "ev", "pad", "adj", "Dev", "w", "Device", "d", "ver", "def", "des", "av", "cache", "DEV", "conn", "prop", "test", "dist", "ds", "develop", "er", "serv", "app", "nt", "cmd", "go", "home", "db", "pro", "env", "dd", "de", "device", "var", "desc", "disk", "cam", "out", "obj", "link", "head", "buf", "adv", "mem", "h", "os", "pi", "addr", "hw", "priv", "ad", "devices", "v", "val"], "err": ["cfg", "der", "cr", "aaa", "kr", "mr", "exc", "rs", "ev", "conf", "req", "ptr", "ah", "eps", "it", "ext", "test", "warn", "result", "er", "r", "ok", "iter", "ec", "errors", "order", "res", "error", "gz", "rb", "msg", "txt", "resp", "eas", "buf", "eth", "obj", "e", "ch", "arr", "usr", "str", "Er", "rr", "addr", "fee", "die", "Error", "cb"], "s": ["get", "sp", "rs", "bs", "params", "conf", "fs", "ims", "settings", "cs", "stats", "set", "store", "its", "a", "sam", "os", "f", "ls", "es", "z", "times", "vs", "ps", "ds", "self", "l", "b", "ts", "serv", "args", "less", "ports", "source", "se", "is", "v", "js", "gs", "m", "us", "state", "states", "er", "ms", "r", "ses", "ss", "aws", "g", "session", "services", "hs", "sts", "sys", "ats", "str", "exec", "space", "sports", "comm", "spec", "p", "sq", "details", "_", "w", "sb", "def", "service", "n", "y", "c", "tests", "as", "j", "cmd", "i", "utils", "func", "t", "ns", "changes", "out", "e", "all", "sv", "qs", "h", "addr", "S", "als"], "x86_iommu": ["x86_iormU", "x86_Iommu", "x86_iOMU", "x86_iOMue", "x86_iommue", "x86_Iomu", "x86_Iommpu", "x86_iomput", "x86_diowu", "x86_iormu", "x86_iowue", "x86_iommU", "x86_Iompu", "x86_iowu", "x86_iowut", "x86_iomU", "x86_iompue", "x86_iowU", "x86_diowut", "x86_iompu", "x86_iormpu", "x86_IomU", "x86_IommU", "x86_iommpu", "x86_diommu", "x86_iOMu", "x86_iommut", "x86_diommU", "x86_iomu", "x86_diowU", "x86_iompU", "x86_diommut", "x86_diowue", "x86_iOMut", "x86_iomppu", "x86_diommue"], "bus": ["ac", "bridge", "p", "us", "Bus", "bar", "bs", "state", "bits", "soc", "BUS", "data", "mount", "bc", "box", "util", "machine", "cache", "usb", " BUS", "chain", "b", "proc", "c", "lock", "lib", "as", "config", "gen", "board", "host", "pos", "loop", "bolt", "t", "phys", "g", "driver", "buf", "is", "handle", "bug", "vc", "local", "sys", "h", "os", "way", "back", "block", "book", "boot", "v"]}}
{"project": "FFmpeg", "commit_id": "7441d1ec330da810a0ffd44a02b2fc60add5b719", "target": 1, "func": "int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)\n\n{\n\n    DynBuffer *d = s->opaque;\n\n    int size;\n\n    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};\n\n    int padding = 0;\n\n\n\n    if (!s) {\n\n        *pbuffer = NULL;\n\n        return 0;\n\n    }\n\n\n\n    /* don't attempt to pad fixed-size packet buffers */\n\n    if (!s->max_packet_size) {\n\n        avio_write(s, padbuf, sizeof(padbuf));\n\n        padding = FF_INPUT_BUFFER_PADDING_SIZE;\n\n    }\n\n\n\n    avio_flush(s);\n\n\n\n    *pbuffer = d->buffer;\n\n    size = d->size;\n\n    av_free(d);\n\n    av_free(s);\n\n    return size - padding;\n\n}\n", "idx": 21971, "substitutes": {"s": ["js", "gs", "m", "sl", "ls", "sq", "p", "es", "sp", "rs", "bs", "w", "sb", "gets", "n", "ps", "sc", "fs", "ims", "ds", "sm", "self", "sa", "ms", "c", "cs", "an", "r", "as", "ses", "ts", "ss", "i", "stats", "t", "aws", "less", "g", "ns", "ins", "its", "socket", "a", "hs", "source", "sts", "sv", "qs", "sys", "ats", "h", "os", "se", "S", "st", "f", "is", "comm"], "pbuffer": ["Pbuf", "dbuffer", "dpointer", "pbbuffer", "dblock", "Pbuffer", "dtable", "ppointer", "prebuf", "Pblock", "pingbuf", " ptable", "prepointer", "pbbuf", "dstream", "pstream", "pblock", "pingbuffer", "ptable", " pstream", " ppointer", "pingstream", "dbuf", "plength", "Ppointer", " plength", " pbuf", "pblength", "pbuf", "pingtable", " pblock", "prebuffer", "prelength", "pbpointer"], "d": ["dos", "m", "done", "del", "p", "o", "z", "mod", "dx", "w", "ld", "des", "gd", "pd", "n", "dt", "fd", "ds", "l", "dict", "b", "dh", "c", "r", "j", "di", "da", "dr", "ded", "t", "dm", "dn", "db", "g", "dl", "dc", "dd", "dp", "did", "md", "h", "D", "dq", "ad", "sd", "f", "v"], "size": ["height", "sn", "sent", "description", "p", "data", "start", "sp", "z", "when", "name", "SIZE", "length", "small", "span", "padding", "notice", "scale", "Size", "n", "needed", "cache", "offset", "IZE", "capacity", "max", "c", "send", "address", "used", "storage", "empty", " sizes", "performance", "speed", "sum", "shape", "ce", "loss", "area", "message", "set", "g", "buffer", "key", "position", "news", "count", "device", "window", "group", "len", "number", "handle", "now", "e", "equal", "time", "ize", "fee", "dimension", "space", "cap", "since", "zone", "v"], "padbuf": ["padBuffer", "padbuff", " paddbytes", " paddbuffer", "barbuff", " paddbuf", " padBuffer", "adbytes", "padqueue", " padbuffer", "adbuffer", "wrapbuf", "adqueue", "adbuff", "wrapqueue", "padbytes", "wrapbuff", " padqueue", " padbytes", "wrapbuffer", "barqueue", "padbuffer", " paddBuffer", " padbuff", "barbuf", "adbuf", "adBuffer", "barbuffer"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}", "idx": 21995, "substitutes": {"queue": ["command", "list", "q", "file", "state", "seq", "manager", "handler", "quit", "database", "port", "util", "priority", "Queue", "complete", "widget", "journal", "master", "cache", "force", "que", "ue", "ques", "result", "info", "history", "core", "lock", "worker", "grid", "config", "processor", "utils", "server", "archive", "message", "buffer", "cue", "env", "wait", "league", "client", "store", "channel", "job", "count", "event", "context", "batch", "dq", "sequence", "block", "pool", "menu"], "sender": ["sink", "resend", "Sceiver", "sriber", "nink", "isiter", "Send", "Sender", "resiter", "mend", "insender", "mceiver", " send", "resender", "nporter", "csink", " siter", "mender", "sener", "mriber", "csender", "insener", "resceiver", "csporter", "isceiver", "send", "insend", "nender", "siter", "mporter", "csriber", "mener", "isender", "Sener", "isend", "mink", "nriber", "sporter", " sceiver", "insceiver", "sceiver"], "flags": ["alf", "acts", "comments", "irms", "data", "FLAG", "posts", "bits", "nets", "amps", "type", "details", "tags", "ants", "links", "parts", "weights", "bytes", "types", "fs", "bugs", "iffs", "phones", "ms", "files", "s", "cs", "leases", "grades", "packages", "flag", "cmd", "faces", "stats", "utils", "lines", "args", "atts", "offs", "count", "window", "actions", "ags", "frames", "options", "ports", " Flags", "issues", "reports", "aps", "fps", "properties", "mask", "weight", "ops", "vals", "heads", "Flags", "locks"], "buf": ["ctx", "pkg", "uf", "data", "bar", "pad", "bag", "box", "bc", "bin", "bp", "br", "Buffer", "orig", "bytes", "fd", "blocks", "ob", "b", "doc", "buff", "raw", "img", "map", "db", "rb", "buffer", "msg", "txt", "vec", "Buff", "window", "cur", "mem", "pg", "cap", "block", "cb", "cv"], "size": ["any", "ctx", "height", "spec", "num", "sent", "data", "sp", " length", "body", "name", "id", "type", "SIZE", "length", "small", "scale", "Size", "bytes", "offset", "capacity", "sum", "limit", "mode", "too", "send", "address", "info", "storage", "empty", " sizes", "timeout", "pos", "shape", "args", "loss", "area", "message", "format", "ui", "set", "news", "total", " resize", "count", "out", "number", "len", "code", "equal", "time", "package", "index", "ize", "os", "new", "fee", "space", "cmp", " Size", "is", "since", "zone"], "sent_cb": ["sent___callback", " sent_job", "encrypted_bs", "sent_cv", "sent____cb", "sent_bs", "encrypted_cb", "sent_ctx", "sent_job", "sent____job", "sent2bs", "sent2cb", "sent_pb", "sent____rb", "encrypted_ctx", "encrypted_msg", "sentptctx", "sent_rb", "sent2msg", "sent_msg", "sent___job", "send_pb", " sent_callback", "sentptbs", "sent___rb", "sent_buf", " sent_rb", "sent_callback", "send_buf", "sent____callback", " sent_cv", "send_callback", "sent___cb", "sentptcb", "send_cb", "sent2ctx", "sentptmsg"], "packet": ["compacket", "buckant", "cleanet", "looket", "payet", "captacket", "productacket", "captoint", "bucket", "signet", "participant", "signette", "payed", "lookacket", "buckunct", "codet", "signunct", "compline", "pppet", "compet", "payacket", "packinet", "productet", "cleanacket", "claimacket", "packline", "makeed", "propet", "cleanant", "propacket", "Packlet", "productpet", "pet", "Packline", "Packet", "Packant", "propette", "packett", "makeset", "participet", "makeacket", "captet", "packageacket", "ppant", "pplet", "packpet", "packoint", "packsinet", "makeet", "codec", "formet", "packageant", "compinet", "packageunct", "packageet", "formacket", "packette", "ppoint", "codoint", "packset", "packET", "packlet", "packsacket", "looked", "compant", "Packpet", "propunct", "participunct", "cleanET", "ppacket", "lookset", "payset", "compett", "Packacket", "formett", "signacket", "ppet", "packageET", "packunct", "packacket", "packed", "ppline", "claimette", "packant", "forminet", "pant", "claimunct", "buckacket", "packsett", "packec", "ppec", "participacket", "codacket", "claimet", "productlet", "captec", "pET"]}}
{"project": "FFmpeg", "commit_id": "02591641f88097aec2a573f0ae384c8b87bcfe3b", "target": 1, "func": "static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n\n{\n\n    int sum, i, j;\n\n    int coeffs[pred_order];\n\n\n\n    for (i=0; i<pred_order; i++)\n\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n\n\n    for (i=0; i < s->blocksize; i++) {\n\n        sum = s->lpcqoffset;\n\n        for (j=0; j<pred_order; j++)\n\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n\n    }\n\n}\n", "idx": 22003, "substitutes": {"s": ["js", "gs", "comments", "ls", "p", "sq", "es", "rs", "bs", "events", "details", "sb", "gets", "n", "ps", "y", "bis", "fs", "ims", "ds", "l", "ains", "b", "ms", "c", "cs", "settings", "r", "ses", "ts", "serv", "ss", "stats", "t", "aws", "less", "ns", "ins", "its", "changes", "hs", "a", "sam", "ares", "services", "sts", "sv", "qs", "h", "sys", "sg", "os", "ats", "S", "als", "space", "f", "is", "comm"], "channel": ["height", "chron", "chn", "parent", "name", "hole", "pixel", "panel", "column", "unit", "chart", "range", "domain", "component", "chip", "chain", "c", "annels", "config", "axis", "server", "version", "uri", "frame", "col", "key", "Channel", "variable", "CH", "member", "client", "color", "group", "coord", "row", "ch", "attribute", "queue", "category", "batch", "filter", "mask", "chan", "block", "label", "table", "course", "v"], "residual_size": ["residitional_Size", "residitional_dim", "residualtsize", "residualtshape", "residualtSize", "residual_shape", "residUAL_shape", "residual_Size", "residitional_SIZE", "residUAL_size", "residUAL_Size", "residitional_size", "residual_dim", "residual_SIZE"], "pred_order": ["predationorders", "pred_Order", "pred8force", "Pred_num", "pred8position", "predationsort", " pred_orders", "pred___force", "pred_mode", "pred_force", "predationorder", "Pred_after", " pred8over", "pred_sort", " pred8force", "predationmode", "pred_ord", "pred_after", " pred_mode", " pred_position", " pred_force", "pred___position", "predNameOrder", "predityorder", "predityposition", " pred_sort", "pred___over", "pred_position", "predNameorder", "pred_num", " pred_over", "predNamescale", "Pred_order", "Pred_Order", "predityforce", "Pred_scale", "predityover", "pred_over", "pred_scale", " pred8order", "pred8over", "pred___order", "pred8order", " pred8position", "pred_orders", "Pred_ord"], "sum": ["dev", "m", "umm", "num", "acc", " summ", "add", "us", "hum", "ass", "dot", "si", "su", " Sum", "um", "scale", "n", "tm", "result", "cum", "sa", "vol", "max", " SUM", "c", "score", "average", "oss", "fac", "size", "tu", "loss", "u", "ul", "total", "sim", "count", "summary", "hash", "out", "ge", "comment", "other", " sums", "sam", "au", "mem", "Sum", "mean", "cal", "weight", "sup", "pool", " summed", "v"], "i": ["at", "name", "multi", "ori", "iat", "ei", "ims", "chain", "mi", "info", "ir", "\u0438", "phi", "ip", "a", "ini", "ind", "ii", "x", "pi", "io", "f", "ki", "im", "list", "z", "zi", "it", "l", "qi", "iu", "iter", "di", "in", "u", "is", "v", "hi", "me", "m", "us", "si", "xi", "init", "r", "point", "ai", "g", "ui", "li", "iri", "batch", "ci", "ix", "p", "id", "n", "y", "ij", "ti", "c", "ie", "gi", "ic", "cli", "sim", "out", "e", "bi", "I", "ami", "ia", "ex"], "j": ["js", "jj", "m", "json", "try", "ix", "q", "p", "o", "bs", "z", "at", "uj", "ax", "aj", "pr", "ja", "ev", "jp", "by", "ot", "_", "br", "n", "fr", "y", "it", "oj", "dj", "l", "ij", "b", "jc", "c", "r", "jo", "di", "jl", "pt", "k", "g", "bj", "jac", "col", "nd", "key", "li", "u", "J", "ge", "other", "next", "note", "ji", "ju", "el", "obj", "bot", "ind", "ch", "bi", "jit", "x", "jump", "h", "kj", "err", "f", "v", "bo"], "coeffs": ["coffes", " coefs", "coEFFs", "coeffice", "COeffs", " coefes", "coeffics", "coefs", "COeffjs", "coffS", "COffes", "COefs", "coeffS", "coefe", "COefS", "coeffes", "coefficientjs", "coffs", "COefjs", "coefficientses", " coeffS", "coeffjs", "coefficS", "COffs", "coefficientss", "COeffe", "coefjs", "coefficjs", "coEFFS", "coefficients", "coeffe", "coefficientS", "coefficiente", "COefe", "coefS", " coefS", "coEFFes", "COeffes", "COeffS", " coeffes", "coefes"]}}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 22006, "substitutes": {"timer_list": ["imer_module", "timerPleft", "Timer_list", "Timer_List", "imer_alist", "imer_list", "timeraccollection", "timer_listed", "timeristcollection", "timeracname", "coord_list", "wrapperistname", "timeritylist", "imer_collection", "timeristalist", "wrapperistlist", "timerricint", "wrapper_add", "timeritytree", "Timer_table", "ter_left", "timer_li", "timeracadd", "timer_tree", "coord_net", "timeristnet", "timer_lists", "timeritycollection", "ter_listed", "timerriclist", "timerricalist", "timeritytable", "timer_add", "timer_LIST", "timer_table", "timeristlists", "timeristlisted", "wrapperistcollection", "timeristname", "Timer_tree", "timer_alist", "wrapper_name", "timeristint", "coordistalist", "timerityList", "wrapper_collection", "wrapper_list", "timerPlist", "imer_lists", "timerPLIST", "timer_module", "coordistlist", "timer_name", "timerPlisted", "imer_link", "timeristlink", "timer_List", "timer_int", "timeritylists", "coord_int", "timeristadd", "timeraclist", "imer_li", "ter_LIST", "timer_link", "ter_list", "timerricnet", "timeristlist", "timer_collection", "coordistint", "timer_left", "wrapperistadd", "imer_listed", "coordistnet", "coord_alist", "timer_net"], "expire_time": ["expiration_Time", "exiry_no", "expirexTime", "expireptsequence", "expireThetime", "expirepttime", "expireThestart", "expire_Time", "exiryzlock", "expirezlock", "exiry_lock", "expiremattime", "expirexcount", "expiretimetime", "expiration_count", "expiration_time", "expireztime", "expire_ime", "expire_no", "expireUno", "expire_lock", "expire_delay", "expireThelock", "expiretimestart", "exiryzstart", "expireptlock", "exiryUime", "exiryUtime", "exiry_start", "expirextime", "expire_count", "expire_start", "expirexdelay", "exiry_ime", "expireThesequence", "expirematime", "exiryztime", "exiryUno", "expiretimeTime", "exiry_time", "exiryzsequence", "expireUtime", "expire_sequence", "expirezstart", "exiry_sequence", "expirematno", "expireUime", "expiration_start", "expireptstart", "expiration_delay", "expirezsequence"]}}
{"project": "FFmpeg", "commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "target": 1, "func": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n\n                            int compressed_size, int uncompressed_size,\n\n                            EXRThreadData *td)\n\n{\n\n    unsigned long dest_len, expected_len = 0;\n\n    const uint8_t *in = td->tmp;\n\n    uint8_t *out;\n\n    int c, i, j;\n\n\n\n    for (i = 0; i < s->nb_channels; i++) {\n\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n\n            expected_len += (td->xsize * td->ysize * 2);\n\n        } else {//UINT 32\n\n            expected_len += (td->xsize * td->ysize * 4);\n\n        }\n\n    }\n\n\n\n    dest_len = expected_len;\n\n\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (dest_len != expected_len) {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    out = td->uncompressed_data;\n\n    for (i = 0; i < td->ysize; i++)\n\n        for (c = 0; c < s->nb_channels; c++) {\n\n            EXRChannel *channel = &s->channels[c];\n\n            const uint8_t *ptr[4];\n\n            uint32_t pixel = 0;\n\n\n\n            switch (channel->pixel_type) {\n\n            case EXR_FLOAT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                ptr[2] = ptr[1] + td->xsize;\n\n                in     = ptr[2] + td->xsize;\n\n\n\n                for (j = 0; j < td->xsize; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                                    (*(ptr[1]++) << 16) |\n\n                                    (*(ptr[2]++) << 8);\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_HALF:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                in     = ptr[1] + td->xsize;\n\n                for (j = 0; j < td->xsize; j++) {\n\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n\n\n                    pixel += diff;\n\n                    bytestream_put_le16(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_UINT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + s->xdelta;\n\n                ptr[2] = ptr[1] + s->xdelta;\n\n                ptr[3] = ptr[2] + s->xdelta;\n\n                in     = ptr[3] + s->xdelta;\n\n\n\n                for (j = 0; j < s->xdelta; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                    (*(ptr[1]++) << 16) |\n\n                    (*(ptr[2]++) << 8 ) |\n\n                    (*(ptr[3]++));\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            default:\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 22009, "substitutes": {"s": ["ctx", "js", "m", "gs", "spec", "south", "ls", "p", "sq", "sp", "v", "rs", "d", "sb", "n", "ps", "fs", "ims", "ds", "l", "sm", "self", "sis", "sa", "b", "ms", "cs", "r", "as", "sw", "ts", "ses", "ss", "t", "aws", "less", "set", "g", "ns", "series", "ins", "hs", "a", "e", "sam", "sts", "sv", "qs", "h", "ats", "sg", "sys", "os", "S", "als", "space", "st", "is", "sports", "comm"], "src": ["rect", "inst", "inner", "ur", "sq", "start", "input", "rs", "impl", "sel", "image", "bin", "supp", "tmp", "sb", "trans", "sc", "init", "dest", "ser", "r", "img", "rb", "sub", "txt", "stream", "ins", "source", "sr", "rl", "str", "usr", "sys", "addr", "sur", "st", "gin", "rc"], "compressed_size": ["compendeditytype", "compendeditysize", "compendedityscale", "compendeditywidth", "compended_width", "compressed67size", "complied_size", "compressed_name", "compresseditywidth", "compended_scale", "compresseditytype", "compressed67width", "compresseditysize", "compressed67scale", "compressed_SIZE", "compended_size", "compressedityscale", "compressed_type", "compressed_Size", "complied_SIZE", "compressed67type", "compressed_scale", "complied_name", "complied_Size", "compressed_width", "compended_type"], "uncompressed_size": ["uncompressededtype", "uncompressed_time", "uncompressed_type", "uncompressededtime", "uncomplated_type", "uncompressededSize", "uncompressededsize", "uncompressed_Size", "uncomplated_time", "uncomplated_Size", "uncomplated_size"], "td": ["dev", "ta", "mont", "edd", "vt", "dat", "xd", "SD", "dial", "vd", "tr", "tt", "pad", "d", "tmp", "ld", "tc", "managed", "pd", "ods", "tar", "dt", "fd", "tm", "cz", "ds", "hd", "ht", "att", "dh", "rt", "tk", "ts", "tap", "dll", "nt", "cmd", "pt", "tif", "t", "dn", "det", "cond", "db", "tu", "od", "cd", "nd", "dl", "txt", "dd", "dem", "pb", "std", "ud", "desc", "them", "md", "sam", "TD", "ent", "dad", "gt", "pc", "tf", "bd", "elt", "ad", "th", "sd", "table", "ctl"], "dest_len": [" dest_l", "dest_l", "destlylength", " dest2length", "dest_ln", "current_ln", "Dest_size", "dest_en", "current_en", "Dest_ln", "destityen", "destitylen", "current_lit", " dest2l", "dest2len", "dest2l", "dev_den", "dev_pos", "dest_lang", "Dest_len", "dest2length", "destlylen", " dest2del", "destlyl", "dev_len", "dest_size", "Dest_Len", "destityln", "dest_del", " dest2len", "dest_lit", "dev_lang", " dest_del", "destlydel", "dest_Len", "current_len", " dest_length", "dest_length", "destitylit", "dest_pos", "dest_den", "dest2del"], "in": ["rin", "min", "m", "inner", "old", "p", "data", "inn", "input", "file", "o", "IN", "id", "inc", "name", "bin", "In", "tmp", "up", "n", "inf", "pin", "r", "raw", "din", "pos", "t", "en", "from", "ref", "ins", "is", "ind", "source", "index", "str", "st", "f", "gin"], "out": ["this", "list", "end", "p", "data", "o", "file", "at", "Out", "image", "ot", "word", "w", "tmp", "to", "outs", "n", "it", "result", "chain", "b", "ou", "array", "nt", "point", "t", "set", "u", "output", "buffer", "window", "obj", "e", "ch", "conv", "OUT", "x", "op", "batch", "new", "ex", "io", "pool", "table", "v"], "c": ["ac", "cp", "m", "cr", "cor", "ci", "p", "ca", "at", "bc", "d", "tc", "cache", "n", "sc", "y", "cm", "mc", "C", "l", "co", "chain", "b", "cs", "fc", "lc", "ec", "uc", "t", "ce", "k", "g", "col", "ic", "cat", "cd", "dc", "unc", "from", "count", "cv", "con", "cam", "ico", "ch", "cu", "conv", "x", "cf", "call", "ex", "f", "cont", "cb", "v", "ct"], "i": ["at", "name", "multi", "by", "ei", "ims", "chain", "mi", "info", "\u0438", "uri", "phi", "series", "ip", "ri", "ini", "ind", "record", "ii", "x", "pi", "io", "f", "ki", "im", "any", "list", "q", "o", "zi", "it", "l", "b", "qi", "iu", "di", "remote", "u", " I", "II", "is", "m", "me", "si", "to", "xi", "status", "init", "point", "ai", "ui", "li", "ci", "ix", "p", "n", "y", "ij", "ti", "t", "ie", "gi", "ic", "cli", "sim", "ji", "e", "bi", "oi", "index", "h", "I", "ia", "ami", "ex"], "j": ["js", "jj", "m", "json", "try", "ix", "q", "p", "o", "z", "ja", "uj", "pr", "aj", "bc", "jp", "mn", "br", "n", "fr", "y", "it", "oj", "dj", "l", "ij", "att", "b", "jc", "r", "jl", "t", "k", "g", "bj", "jac", "col", "key", "J", "ji", "obj", "e", "ch", "h", "x", "jump", "jit", "kj", "f", "v"], "channel": ["chron", "data", "type", "word", "panel", "pixel", "can", "band", "column", "ann", "service", "global", "component", "chip", "chain", "feature", "header", "config", "board", "video", "col", "buffer", "key", "Channel", "client", "member", "cam", "color", "cell", "row", "all", "ch", "byte", "conv", "attribute", "category", "connection", "batch", "resource", "container", "chan", "table", "course"], "ptr": ["pointers", "ped", "js", "rect", "inst", "tp", "grad", "sp", "adr", "tile", "prep", "pr", "pad", "tr", "req", "loc", "pend", "bp", "br", "fr", "pert", "eps", "iv", "offset", "dist", "inter", "expr", "attr", "proc", "rt", "embed", "ts", "iter", "vp", "deg", "cmd", "dr", "pointer", "pt", "ct", "pos", "prime", "cond", "buffer", "pc", "ref", "var", "cur", "desc", "buf", "coord", "code", "sec", "ind", "Ptr", "ctr", "arr", "index", "pre", "inters", "dq", "addr", "err", "alloc", "fp", "rel", "ctl", "dep"]}}
{"project": "FFmpeg", "commit_id": "caa7a3914f499f74b3ee346f26d598ebdc0ec210", "target": 1, "func": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    int64_t total_size = 0;\n\n    MOVAtom a;\n\n    int i;\n\n\n\n    if (atom.size < 0)\n\n        atom.size = INT64_MAX;\n\n    while (total_size + 8 <= atom.size && !avio_feof(pb)) {\n\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n\n        a.size = atom.size;\n\n        a.type=0;\n\n        if (atom.size >= 8) {\n\n            a.size = avio_rb32(pb);\n\n            a.type = avio_rl32(pb);\n\n            if (a.type == MKTAG('f','r','e','e') &&\n\n                a.size >= 8 &&\n\n                c->moov_retry) {\n\n                uint8_t buf[8];\n\n                uint32_t *type = (uint32_t *)buf + 1;\n\n                avio_read(pb, buf, 8);\n\n                avio_seek(pb, -8, SEEK_CUR);\n\n                if (*type == MKTAG('m','v','h','d') ||\n\n                    *type == MKTAG('c','m','o','v')) {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n\n                    a.type = MKTAG('m','o','o','v');\n\n                }\n\n            }\n\n            if (atom.type != MKTAG('r','o','o','t') &&\n\n                atom.type != MKTAG('m','o','o','v'))\n\n            {\n\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n\n                {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n\n                    avio_skip(pb, -8);\n\n                    return 0;\n\n                }\n\n            }\n\n            total_size += 8;\n\n            if (a.size == 1) { /* 64 bit extended size */\n\n                a.size = avio_rb64(pb) - 8;\n\n                total_size += 8;\n\n            }\n\n        }\n\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n\n        if (a.size == 0) {\n\n            a.size = atom.size - total_size + 8;\n\n        }\n\n        a.size -= 8;\n\n        if (a.size < 0)\n\n            break;\n\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n\n            if (mov_default_parse_table[i].type == a.type) {\n\n                parse = mov_default_parse_table[i].parse;\n\n                break;\n\n            }\n\n\n\n        // container is user data\n\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n\n                       atom.type == MKTAG('i','l','s','t')))\n\n            parse = mov_read_udta_string;\n\n\n\n        if (!parse) { /* skip leaf atoms data */\n\n            avio_skip(pb, a.size);\n\n        } else {\n\n            int64_t start_pos = avio_tell(pb);\n\n            int64_t left;\n\n            int err = parse(c, pb, a);\n\n            if (err < 0)\n\n                return err;\n\n            if (c->found_moov && c->found_mdat &&\n\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n\n                 start_pos + a.size == avio_size(pb))) {\n\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n\n                    c->next_root_atom = start_pos + a.size;\n\n                return 0;\n\n            }\n\n            left = a.size - avio_tell(pb) + start_pos;\n\n            if (left > 0) /* skip garbage at atom end */\n\n                avio_skip(pb, left);\n\n            else if (left < 0) {\n\n                av_log(c->fc, AV_LOG_WARNING,\n\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n\n                       (char*)&a.type, -left);\n\n                avio_seek(pb, left, SEEK_CUR);\n\n            }\n\n        }\n\n\n\n        total_size += a.size;\n\n    }\n\n\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n\n        avio_skip(pb, atom.size - total_size);\n\n\n\n    return 0;\n\n}\n", "idx": 22013, "substitutes": {"c": ["ctx", "cp", "ac", "gc", "m", "cr", "ci", "p", "ca", "vc", "cn", "bc", "conf", "w", "tc", "anc", "cache", "cm", "mc", "cc", "cod", "C", "l", "co", "com", "chain", "b", "cs", "fc", "lc", "ec", "t", "ce", "g", "pc", "cd", "ic", "dc", "cv", "con", "cam", "e", "abc", "cu", "h", "cf", "rc", "call", "f", "cb", "v", "ct"], "pb": ["ctx", "cp", "pkg", "uf", "tp", "bb", "p", "eb", "pp", "sp", "bs", "np", "erb", "td", "ub", "jp", "apa", "tmp", "sb", "apy", "tc", "wb", "bp", "pan", "sc", "ps", "ab", "mp", "BP", "ob", "b", "wp", "proc", "vp", "tk", "PB", "pt", "db", "pro", "rb", "buffer", "pc", "pa", "bj", "amp", "patch", "dp", "asm", "client", "resp", "ap", "prototype", "snap", "emb", "sys", "lp", "tf", "fb", "cb", "px", "pg"], "atom": ["ebin", "alpha", "at", "cer", " o", "tmp", "ver", "unit", "ether", "prop", "abel", "ext", "ator", "attr", " orb", "some", "nt", "ANY", "unknown", "normal", "format", " exc", "xml", "phys", "element", "atomic", "other", " x", "attribute", "x", "op", "binary", "cell", "term", "any", " self", "att", "b", " entry", "map", " any", "byte", "xy", " app", "meta", "m", "num", "om", "soc", "or", "ace", "tg", "ym", "that", "orm", "canon", "application", " b", "item", "app", "orb", "msg", "news", "window", " err", "el", "abc", "http", "form", " symb", "p", " ans", "entry", "mat", "typ", "tar", "ob", "tab", "top", "no", "cmd", "article", "het", "ata", "operator"], "a": ["acc", "aaa", "alpha", "and", "at", "aq", "test", "sa", "ae", "aa", "xa", "la", "apache", "ar", "ao", "attribute", "x", "aka", "ac", "any", "o", "am", "apa", "era", "l", "att", "b", "admin", "area", "ap", "eas", "another", "au", "part", "ack", "dev", "m", " ta", "this", "ba", "ace", "ea", "an", "aux", "app", "act", "na", "sta", "g", "ma", "AA", "al", "oa", "el", "ta", "A", "p", " ans", "ca", "parent", "ga", "ada", "ab", "access", "as", "j", "t", "e", "all", "ata", "ia"], "i": ["m", " ti", "ci", "p", " e", "z", " bi", "iat", "n", "it", "b", " v", "j", "t", " ii", " p", " j", " m", "e", "ii", "x", "pi", "I", "ia", "f", "v"], "parse": ["parser", "cp", "gc", "arse", "json", "pack", "np", "cast", "can", "util", "bp", "init", "aw", "P", "info", "send", "raw", "func", "format", "unc", "read", "conv", "alloc", "fp", "cmp", "pair", "ack"], "type": ["check", "get", "pack", "file", "name", "pe", "ver", "unit", "tree", "types", "test", "role", "ype", "info", "speed", "format", "set", "sche", "rank", "count", "color", "block", "class", "action", "ty", "post", "try", "data", "tag", "cache", "Type", "dt", "scope", "shape", "error", "message", "not", "member", "desc", "ping", "comment", "group", "hash", "source", "byte", "part", "state", "length", "port", "offset", "status", "kind", "template", "timeout", "version", "TYPE", "var", "time", "title", "batch", "sequence", "close", "spec", "description", "start", "id", "value", "typ", "style", "result", "lock", "no", "t", "size", "buffer", "key", "link", "code", "null", "index", "category", "weight"], "buf": ["ctx", "ff", "uf", "pack", "end", "data", "bar", "length", "bin", "tmp", "ptr", "xff", "bp", "br", "Buffer", "bytes", "offset", "result", "b", "max", "limit", "text", "buff", "raw", "iter", "cmd", "pos", "buffer", "rb", "ref", "vec", "mb", "next", "Buff", "cur", "code", "len", "read", "count", "off", "byte", "out", "arr", "str", "queue", "batch", "new", "err", "alloc", "cap", "cb", "cv"]}}
{"project": "qemu", "commit_id": "9fbf0fa81fca8f527669dd4fa72662d66e7d6329", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n\n                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)\n\n{\n\n    uint16_t opts = le16_to_cpu(cmd->opts);\n\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n\n    uint64_t prdt_addr = cfis_addr + 0x80;\n\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    uint64_t sum = 0;\n\n    int off_idx = -1;\n\n    int64_t off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    /*\n\n     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n\n     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n\n     * 512 byte sector size. We limit the PRDT in this implementation to\n\n     * a reasonably large 2GiB, which can accommodate the maximum transfer\n\n     * request for sector sizes up to 32K.\n\n     */\n\n\n\n    if (!prdtl) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (prdtl > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 22016, "substitutes": {"ad": ["ac", "post", "arp", "ard", "add", "ass", "adr", "and", "Ad", "end", "mod", "id", "pad", "ax", "ads", "ag", "d", "ld", "ann", "ay", "ace", "ada", "conn", "ab", "att", "an", "doc", "admin", "wd", "db", "od", "quad", "aud", "adi", "dd", "adj", "ud", "pod", "al", "ade", "md", "play", "a", "rad", "AD", "ind", "adv", "addr", "art", "ack"], "sglist": [" sgnIST", " sglalist", " sgnists", "sgzIST", "sglalist", " sgnalist", "sblist", "sgzist", "sgzalist", "sgnists", "sblIST", "sblists", "sgnist", " sgnist", "sglists", " sglists", "sgnIST", " sglIST", "sglIST", "sgnalist", "sgzists", "sblalist"], "cmd": ["ctx", "cp", "cfg", "command", "pkg", "check", "req", "quit", "help", "conf", "ctrl", "def", "range", "conn", "bind", "init", "kick", "c", "send", "kind", "ctl", "raw", "act", "ct", "build", "auth", "args", "det", "map", "cd", "msg", "news", "cli", "md", "obj", "ctr", "ch", "crit", "op", "batch", "call", "exec", "Cmd", "cmp", "cont", "cb", "cod", "comm"], "limit": ["end", "clip", "maximum", "Limit", "range", "limited", "lim", "amount", "capacity", "bound", "margin", "tail", "limits", "lock", "iter", "origin", "skip", "page", "buffer", "slice", "base", "filter", "commit", "alloc", "cap", "block", "pool"], "offset": ["reset", "end", "start", "sp", "o", "entry", "pad", "slot", "length", "padding", "ptr", "scroll", "range", "shift", "amount", "Offset", "attr", "address", "top", "location", "origin", "point", "pointer", "timeout", "pos", "sum", "size", "error", "set", "skip", "buffer", "seek", "position", "offs", "slice", "align", "next", "head", "off", "len", "row", "base", "index", "addr", "alloc", "block"], "prdt": ["trdat", "propdt", " prnot", "pstk", "trdl", "predtf", "trdt", "prdl", "preddl", "sprbd", "propnot", "prbd", "Prdl", "sprdt", "prednot", "preddt", " prdl", "psmt", "proptf", "Prdt", "psdt", "Prmt", " prdat", "propdl", " prbd", "prtk", "prdat", "sprdl", "PRmt", "prmt", "PRtk", "psdl", "Prtk", "PRdt", "PRdl", "prnot", "trbd", " prtf", "prtf", "sprdat"], "i": ["hi", "m", "me", "ci", "ix", "p", "o", " index", " bi", "multi", "zi", "si", "ori", "n", "ei", "y", "it", "xi", "ims", "l", "ti", "mi", "qi", "info", "iu", "c", "r", " v", "j", "item", "di", " pos", "\u0438", "ai", "t", "im", "ie", "k", " ii", "u", "ui", "phi", "ic", "li", "gi", " j", "ip", "sim", "cli", "ri", "a", "ini", " m", " x", "e", "bi", "ind", "oi", "index", "x", "ii", "pi", "I", "yi", "f", "ki", "v"], "tbl_entry_size": ["tbl_entry_SIZE", "tbl_ry_space", "tbl_row_sum", "tbl_entry___index", "tbl_entry___size", "tbl_ry_size", "tbl_Entry_sum", "tbl_entry___Size", "tbl_entry_space", "tbl_ry_SIZE", "tbl_Entry_size", "tbl_entry_Size", "tbl_entry_index", "tbl_row_size", "tbl_Entry_Size", "tbl_entry_sum", "tbl_Entry_index", "tbl_row_SIZE"], "bus": ["dev", "vc", "us", "Bus", "alias", "bs", "state", "BUS", "bid", "mount", "box", "port", "proxy", "card", "cc", "chain", "b", "hand", "lock", "config", "board", "host", "pos", "loop", "bolt", "driver", "gate", "device", "pod", "buf", "handle", "bug", "interface", "base", "cf", "os", "way", "book", "boot", "bind"], "qbus": ["dqstate", " qstate", "dqBus", "dqbus", " qBUS", "qBUS", "QBus", "dqBUS", "Qbus", " qBus", "qBus", "qstate", "Qstate", "QBUS"], "tbl": [" tBl", "bbr", "nBL", "tbr", " tll", "tBl", "tll", " tpl", "bbl", "nbl", "nll", "tBL", " tBL", "Tpl", "nbr", "ppl", "Tbl", "bBL", " tbr", "tpl", "pbl", "TBl", "pBl", "bll"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void dwt_encode97_int(DWTContext *s, int *t)\n\n{\n\n    int lev,\n\n        w = s->linelen[s->ndeclevels-1][0];\n\n    int *line = s->i_linebuf;\n\n    line += 5;\n\n\n\n    for (lev = s->ndeclevels-1; lev >= 0; lev--){\n\n        int lh = s->linelen[lev][0],\n\n            lv = s->linelen[lev][1],\n\n            mh = s->mod[lev][0],\n\n            mv = s->mod[lev][1],\n\n            lp;\n\n        int *l;\n\n\n\n        // VER_SD\n\n        l = line + mv;\n\n        for (lp = 0; lp < lh; lp++) {\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lv; i++)\n\n                l[i] = t[w*i + lp];\n\n\n\n            sd_1d97_int(line, mv, mv + lv);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n        // HOR_SD\n\n        l = line + mh;\n\n        for (lp = 0; lp < lv; lp++){\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lh; i++)\n\n                l[i] = t[w*lp + i];\n\n\n\n            sd_1d97_int(line, mh, mh + lh);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n    }\n\n}\n", "idx": 22034, "substitutes": {"s": ["js", "m", "gs", "ows", "p", "sq", "es", "rs", "bs", "bits", "rates", "details", "times", "w", "d", "sb", "vs", "parts", "ties", "n", "ps", "bis", "eps", "irs", "fs", "ims", "ds", "b", "c", "cs", "an", "r", "as", "sw", "ts", "ses", "ss", "stats", "aus", "less", "g", "ns", "re", "ins", "its", "a", "hs", "e", "sts", "sv", "qs", "xs", "h", "ats", "sg", "se", "os", "conv", "S", "als", "ops", "ex", "f", "is", "v", "comm"], "t": ["ta", "m", "tp", "p", "te", "o", "qt", "at", "td", "tr", "tt", "mat", "ot", "w", "tc", "tree", "tg", "to", "n", "y", "dt", "it", "b", "wt", "rt", "c", "xt", "r", "tl", "tk", "ts", "bt", "nt", "T", "pt", "tu", "g", "lt", "txt", "target", "et", "total", "out", "ll", "ent", "all", "tf", "st", "mt", "f", "table", "trace", "v", "ct"], "lev": ["xp", "rog", "gew", " elev", "eg", "lo", "tile", "depth", "lvl", "ev", "loc", "lag", "water", "Lev", "ld", "ell", "lin", "camp", "den", "wid", "pl", "lim", "cod", "vel", "vl", "rep", "hend", "lex", " lvl", "lu", "lc", "vp", "serv", "iter", "ble", "lv", "deg", "dr", "ded", "ie", "dem", "ged", "pol", "league", "vec", "bal", "lig", "len", "compl", "lif", "level", "el", "hl", "leg", "ind", "coord", "rax", "lay", "ger", "gent", "wl", "lem", "weight", "elt", "vals", "ele", "liv", "cell", "le", "v", "val"], "line": ["lf", "try", "liner", "file", "lo", "o", "entry", "ide", "Line", "eline", "port", "pe", "ln", "w", "path", "lin", "range", "fr", "limit", "mode", "nl", "lock", "lc", "edge", "online", "iter", "lv", "node", "go", "point", "lines", "LINE", "net", "set", "home", "frame", "page", "li", "ine", "position", "link", "store", "len", "out", "code", "level", "row", "lane", "handle", "change", "byte", "rule", "lay", "se", "call", "block", "ne", "le"], "lp": ["lf", "xp", "cp", "pkg", "sie", "oji", "tp", "ls", "p", "LP", "pp", "np", "sp", "lvl", "ijk", "pr", "loc", "jp", "isi", "lag", "yp", "bp", "pd", "ps", "pert", "pl", "abl", "ij", "phal", "lik", "lr", "wp", "iu", "lu", "lc", "vp", "lit", "lan", "lv", "isp", "jl", "lis", "dl", "pc", "li", "pa", "lt", "pn", "lip", "lb", "pb", "msg", "php", "len", "ml", "bps", "hl", "ll", "gp", "rl", "sg", "pi", "tf", "lbs", "lang", "fp", "elt", "bsp", "kl", "pers"], "l": ["m", "list", "sl", "ls", "p", "o", "lo", "L", "fl", "loc", "ol", "ln", "w", "ell", "lin", "ld", "n", "pl", "b", "lr", "tl", "c", "nl", "lock", "lib", "lc", "lit", "la", "lv", "lis", "g", "dl", "li", "lt", "ul", "lb", "il", "al", "ml", "el", "ll", "hl", "rl", "h", "wl", "le", "v"], "i": ["iy", "ili", "pp", "at", "multi", "ori", "ei", "ims", "mi", "info", "ski", "\u0438", "uri", "phi", "pc", "ip", "ri", "ini", "ind", "ii", "x", "pi", "io", "ki", "im", "zi", "jp", "isi", "bp", "it", "qi", "iu", "ani", "iii", "iter", "di", "in", "u", "ik", "is", "v", "ici", "hi", "this", "me", "si", "xi", "init", "ni", "ai", "ite", "ui", "li", "il", "iri", "ci", "ix", "p", "id", "y", "ij", "ti", "ie", "gi", "ic", "cli", "sim", "ji", "ati", "bi", "oi", "asi", "I", "ami", "ia"], "j": ["js", "jj", "json", "try", "ix", "q", "p", "sp", "bs", "z", "ja", "uj", "pr", "aj", "ijk", "si", "jp", "je", "user", "tree", "br", "n", "fr", "y", "it", "bis", "oj", "dj", "jas", "ij", "status", "init", "jc", "r", "jo", "di", "jl", "ni", "pt", "im", "ie", "jac", "bj", "gi", "li", "J", "adj", "note", "job", "ji", "out", "obj", "bi", "bot", "next", "ju", "jit", "str", "jump", "kj", "io", "v", "bo"]}}
{"project": "FFmpeg", "commit_id": "0424e052f83adc422d8a746e3cdc5ab6bc28679e", "target": 1, "func": "static void decode_postinit(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture *out = s->current_picture_ptr;\n\n    Picture *cur = s->current_picture_ptr;\n\n    int i, pics, out_of_order, out_idx;\n\n\n\n    s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_H264;\n\n    s->current_picture_ptr->pict_type= s->pict_type;\n\n\n\n    if (h->next_output_pic) return;\n\n\n\n    if (cur->field_poc[0]==INT_MAX || cur->field_poc[1]==INT_MAX) {\n\n        //FIXME this allows the next thread to start once we encounter the first field of a PAFF packet\n\n        //This works if the next packet contains the second field. It does not work if both fields are\n\n        //in the same packet.\n\n        //ff_thread_finish_setup(s->avctx);\n\n        return;\n\n    }\n\n\n\n    cur->interlaced_frame = 0;\n\n    cur->repeat_pict = 0;\n\n\n\n    /* Signal interlacing information externally. */\n\n    /* Prioritize picture timing SEI information over used decoding process if it exists. */\n\n\n\n    if(h->sps.pic_struct_present_flag){\n\n        switch (h->sei_pic_struct)\n\n        {\n\n        case SEI_PIC_STRUCT_FRAME:\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_FIELD:\n\n        case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n            cur->interlaced_frame = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n            if (FIELD_OR_MBAFF_PICTURE)\n\n                cur->interlaced_frame = 1;\n\n            else\n\n                // try to flag soft telecine progressive\n\n                cur->interlaced_frame = h->prev_interlaced_frame;\n\n            break;\n\n        case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n        case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n            // Signal the possibility of telecined film externally (pic_struct 5,6)\n\n            // From these hints, let the applications decide if they apply deinterlacing.\n\n            cur->repeat_pict = 1;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n            // Force progressive here, as doubling interlaced frame is a bad idea.\n\n            cur->repeat_pict = 2;\n\n            break;\n\n        case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n            cur->repeat_pict = 4;\n\n            break;\n\n        }\n\n\n\n        if ((h->sei_ct_type & 3) && h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)\n\n            cur->interlaced_frame = (h->sei_ct_type & (1<<1)) != 0;\n\n    }else{\n\n        /* Derive interlacing flag from used decoding process. */\n\n        cur->interlaced_frame = FIELD_OR_MBAFF_PICTURE;\n\n    }\n\n    h->prev_interlaced_frame = cur->interlaced_frame;\n\n\n\n    if (cur->field_poc[0] != cur->field_poc[1]){\n\n        /* Derive top_field_first from field pocs. */\n\n        cur->top_field_first = cur->field_poc[0] < cur->field_poc[1];\n\n    }else{\n\n        if(cur->interlaced_frame || h->sps.pic_struct_present_flag){\n\n            /* Use picture timing SEI information. Even if it is a information of a past frame, better than nothing. */\n\n            if(h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM\n\n              || h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)\n\n                cur->top_field_first = 1;\n\n            else\n\n                cur->top_field_first = 0;\n\n        }else{\n\n            /* Most likely progressive */\n\n            cur->top_field_first = 0;\n\n        }\n\n    }\n\n\n\n    //FIXME do something with unavailable reference frames\n\n\n\n    /* Sort B-frames into display order */\n\n\n\n    if(h->sps.bitstream_restriction_flag\n\n       && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n        s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n        s->low_delay = 0;\n\n    }\n\n\n\n    if(   s->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT\n\n       && !h->sps.bitstream_restriction_flag){\n\n        s->avctx->has_b_frames= MAX_DELAYED_PIC_COUNT;\n\n        s->low_delay= 0;\n\n    }\n\n\n\n    pics = 0;\n\n    while(h->delayed_pic[pics]) pics++;\n\n\n\n    assert(pics <= MAX_DELAYED_PIC_COUNT);\n\n\n\n    h->delayed_pic[pics++] = cur;\n\n    if(cur->reference == 0)\n\n        cur->reference = DELAYED_PIC_REF;\n\n\n\n    out = h->delayed_pic[0];\n\n    out_idx = 0;\n\n    for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame && !h->delayed_pic[i]->mmco_reset; i++)\n\n        if(h->delayed_pic[i]->poc < out->poc){\n\n            out = h->delayed_pic[i];\n\n            out_idx = i;\n\n        }\n\n    if(s->avctx->has_b_frames == 0 && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset))\n\n        h->next_outputed_poc= INT_MIN;\n\n    out_of_order = out->poc < h->next_outputed_poc;\n\n\n\n    if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)\n\n        { }\n\n    else if((out_of_order && pics-1 == s->avctx->has_b_frames && s->avctx->has_b_frames < MAX_DELAYED_PIC_COUNT)\n\n       || (s->low_delay &&\n\n        ((h->next_outputed_poc != INT_MIN && out->poc > h->next_outputed_poc + 2)\n\n         || cur->pict_type == AV_PICTURE_TYPE_B)))\n\n    {\n\n        s->low_delay = 0;\n\n        s->avctx->has_b_frames++;\n\n    }\n\n\n\n    if(out_of_order || pics > s->avctx->has_b_frames){\n\n        out->reference &= ~DELAYED_PIC_REF;\n\n        out->owner2 = s; // for frame threading, the owner must be the second field's thread\n\n                         // or else the first thread can release the picture and reuse it unsafely\n\n        for(i=out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i+1];\n\n    }\n\n    if(!out_of_order && pics > s->avctx->has_b_frames){\n\n        h->next_output_pic = out;\n\n        if(out_idx==0 && h->delayed_pic[0] && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset)) {\n\n            h->next_outputed_poc = INT_MIN;\n\n        } else\n\n            h->next_outputed_poc = out->poc;\n\n    }else{\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"no picture\\n\");\n\n    }\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n}\n", "idx": 22037, "substitutes": {"h": ["hi", "m", "kh", "p", "zh", "o", "hz", "here", "oh", "ih", "w", "ah", "ph", "hm", "l", "self", "ht", "hd", "b", "rh", "dh", "c", "sh", "history", "he", "r", "info", "eh", "host", "bh", "H", "k", "hp", "her", "hash", "hs", "hh", "hl", "hal", "handle", "ch", "ach", "http", "his", "x", "hw", "th", "v", "comm"], "s": ["js", "m", "gs", "sections", "sl", "ls", "p", "sq", "sp", "bs", "rs", " ts", "w", "sb", "ps", "n", "css", "fs", "sm", "ds", "l", "self", "ms", "b", "c", "cs", "ess", "sh", "as", "sw", "ses", "ts", "j", "serv", "ss", "stats", "t", "less", "g", "ns", "session", "its", "wcs", "hs", "a", "e", "his", "ch", "sts", "conv", "sv", "http", "sys", "ats", "os", "S", " inputs", "th", "is", "v"], "out": ["gs", "m", "p", "o", "Out", "conf", "ot", "w", "tmp", "outs", "n", "co", "c", "serv", "in", "img", "t", "res", "g", "output", "obj", "OUT", "sys", "op", "os", "new", "v"], "cur": ["cor", "conf", "tmp", "ver", "copy", "sc", "ret", "nt", "dr", "dc", "pri", "con", "ch", "keep", "cv", "cp", "gc", "try", "ctrl", "qu", "cache", "co", "ser", "serv", "Cur", "col", "cat", "desc", "comment", "ctr", "cu", "conv", "usr", "sur", "cont", "rc", "cr", "public", "tr", "req", "loc", "ptr", "ph", "nc", "er", "gr", "r", "kw", "fac", "res", "obj", "row", "str", "err", "coll", "current", "close", "car", "ur", "ah", " Cur", "ocr", "etc", "result", "lr", "c", "cmd", "now", "rec", "cmp", "pg"], "i": [" ti", "ci", "p", "o", "id", " li", "si", " bi", "ori", " mi", "it", "l", "ti", "info", "r", "j", "ai", " ii", "li", "ip", "ati", "e", "ii", "x", "I", "io", "f", "is"], "pics": [" picks", "picks", "Pik", "npic", "npics", "pic", " pic", "npik", "Pics", "Pic", " pik", "pik", "Picks", "npicks"], "out_of_order": ["out_of_sequence", "out_OF_sequence", "out_of_frame", "out_of_orders", "out_OF_orders", "out_OF_order", "out_OF_frame"], "out_idx": ["out_midxs", "out_idX", "out_midxc", "out_Idx", "out_IdX", "out_midX", "out_Idxs", "out_idxs", "out_Idxc", "out_idxc", "out_midx"]}}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n", "idx": 22047, "substitutes": {"dst_errp": ["dst_erpa", "dst_errr", "dst_errorps", "dst_erd", "dst_errorpa", "dst_errpa", "dst_statep", "dst_erm", "dst_errm", "dst__errps", "dst_rrP", "dst__errp", "dst_rps", "dst_arrps", "dst_erp", "dst_rrpa", "dst_stater", "dst_arrpa", "dst_arrP", "dst_stated", "dst_erP", "dst_errorp", "dst_rrp", "dst_rP", "dst_errorm", "dst_stateP", "dst_errorP", "dst_errps", "dst_rrps", "dst_arrm", "dst__errP", "dst_errP", "dst_rp", "dst_errd", "dst_err", "dst_arrp", "dst_erps"], "local_err": ["local__error", " local_error", "localitycmd", "loc_err", "localityerr", " local_any", "local_notice", "loc_msg", "local___error", "local___er", "local_rr", "localmyerr", "loc_er", "local_cmd", "localmypriv", " local_rr", "local_er", "local_msg", "localityer", "local__er", "local_cfg", " local_cfg", "local_priv", "local_cb", "local__rr", "localmycmd", " local_er", " local_msg", "local_error", "local__msg", "localmyer", "local___msg", "local__err", "local___err", " local_notice", "localitypriv", " local_priv", " local_cmd", "local_any", "loc_cb"]}}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058, "substitutes": {"ret": ["alt", "Ret", "test", "result", "expr", "iter", "flag", "eval", "reg", "res", "buffer", "ref", "rev", "re", "cur", "val", "store", "read", "rets", "mem", "arr", "RET", "valid", "cell", "rc", "final"], "TCGv": ["TCGUvs", "TCGregq", "TCGarq", "TCGmax", "TCGGqv", "TEGUv", "TCGelu", "WCGq", "TFGPlu", "TEGc", "TFGPj", "TFGj", "TCGarf", "TCGDvi", "TCGev", "TPGGve", "TCLGf", "TCGGv", "TCGj", "TCGarw", "TCGUve", "TCGUvar", "TCGDtv", "TCGej", "TPGUnv", "TPGUvi", "TCGPget", "TCGPv", "TCGPvs", "TCGPw", "TCGInv", "TCGDnv", "TEGv", "TCGPqv", "TCGAv", "TCGraphj", "TCGAw", "TCGPmax", "TCGUv", "WCGUq", "TPGtv", "WCGUvar", "TCGnv", "TCGf", "TPGUv", "TCGPnv", "TPGUtv", "TCLGv", "TCGUmax", "TCGqv", "TCGUnv", "TCGItv", "ACGUvs", "TEGget", "TFGlu", "TCGarqv", "TCGAf", "TCGvs", "TCHAv", "TCGvar", "TPGGv", "TPGGvs", "ACGvs", "TCGPve", "TPGve", "ACGUnv", "TCGPc", "TEGUget", "tcGPv", "TCGUc", "TPGv", "TCGraphv", "TCGUf", "ACGUv", "TCGget", "TCHAmax", "TCGPf", "TCGUget", "TCGIv", "TCGq", "TCHAget", "TPGqv", "tcGv", "TCGraphf", "TCGvi", "TCGve", "TCGPlu", "TCGUq", "TPGvi", "TFGPf", "TCGraphlu", "TCGUvi", "WCGqv", "TCGDv", "tcGPvs", "tcGw", "ACGnv", "TCGAvs", "ACGf", "WCGUv", "ACGv", "ACGUf", "TCGUqv", "TCGregv", "TEGUc", "TCGarvs", "TCGregvar", "TCGtv", "TCGPj", "TPGnv", "TCGIvi", "WCGUqv", "TFGPv", "TFGf", "TCGw", "TCGarvar", "TCGGve", "TPGvs", "tcGPw", "TEGmax", "TFGv", "TCLGnv", "WCGvar", "tcGvs", "TCGGvs", "TPGGqv", "TCLGvs", "WCGv", "TCGregqv", "TEGUmax", "TCHAc", "TCGlu", "TCGef", "tcGf", "TCGUtv", "tcGPf", "TCGarv", "TCGc"], "uint32_t": ["uint256_m", "uint32_m", "uint256_l", "uint32_p", "uint32_l", "uint256_n", "uint32_n", "uint256_p", "uint256_t"]}}
{"project": "qemu", "commit_id": "b3a6a2e0417c78ec5491347eb85a7d125a5fefdc", "target": 1, "func": "int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( 0x41E < aExp ) {\n\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = 0x433 - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n", "idx": 22065, "substitutes": {"STATUS_PARAM": ["STATUS_TAR", "STATUS_PARV", "STATUS_VV", "STATUS_PARAR", "STATUS_VAR", "STATUS_TAM", "STATUS_PARAMS", "STATUS_ParAR", "STATUS_VAM", "STATUS_TAMS", "STATUS_VAMS", "STATUS_ParV", "STATUS_TV", "STATUS_ParAM", "STATUS_ParAMS"], "aSign": ["asMask", "cacheNeg", " aSIGN", "aaSign", " aForce", "anPos", " aForm", "ASign", " aIdent", "aForm", "saMask", "aoIncre", "paSign", "aaSc", " aIncre", "acLog", "AForm", "sasign", "paIdent", "saSign", "asSign", "aaIdent", "aSIGN", "asign", "asSIGN", " asign", "aIncre", "saNeg", "cacheDesign", "cacheMask", "aoSign", "anForce", "saForm", "aLog", " aLog", "saSIGN", "anSign", "aDesign", "aasign", "aMask", " aSc", "saSc", "acSIGN", "ASIGN", "anIncre", "aoPos", "asNeg", "aSc", "aPos", "Asign", "asLog", "aNeg", " aPos", "aaSIGN", "paSIGN", "acSign", "saDesign", "asDesign", "aoForce", "cacheSign", "aIdent", "aForce"], "aExp": ["anSec", "aoExpress", "aAg", "aExpress", "aIncre", "aExt", "anEXP", "anReg", "alphaExpress", "aEv", "aaaExt", "areaExp", "oaProp", "saSec", "aSec", "asEXP", "alphaExp", "anProp", " aRest", "asReg", "aaExp", " aAg", "aEx", "aRest", "aReg", "xaExt", "aLog", "arLog", " aSec", "asExp", "akaAg", "oaReg", "aaEv", "aEXP", "aaaExp", "oaEXP", "amEv", "eExt", "aaExpress", "eExp", "aaExt", "oaExp", "aoIncre", "xaEXP", "arExpress", " aReg", "akaEv", "saReg", "areaComp", "akaExp", "arEXP", "eEx", "aoExt", "aaComp", "areaExt", "anExp", "aProp", " aExt", "aaaIncre", "aaEXP", "asProp", "amReg", "xaExp", "arExp", "amAg", "anRest", "saExp", "aComp", "aaEx", "aaaExpress", "saRest", "alphaExt", " aComp", " aLog", "alphaIncre", "aaLog", "eEXP", "amExp", " aExpress", "areaEv", " aEXP", " aEv", "xaEx", "akaReg", "aoExp"], "shiftCount": ["switchCount", "shiftFlag", "shiftCounter", "shiftcount", "hiftCondition", " shiftCounter", "offsetCode", " shiftType", "shiftCondition", "hiftFlag", "hiftCode", "hiftSize", "hiftCounter", "hiftLength", " shiftSize", "ShiftCount", "ShiftCounter", " shiftLength", " shiftCode", "pushType", "shiftSize", " shiftCondition", "shiftLength", "hiftCount", "switchLength", "Shiftcount", "hiftcount", "pushCount", "offsetCount", "hiftType", "pushcount", "ShiftFlag", " shiftFlag", "shiftType", "shiftCode", "pushSize", " shiftcount", "offsetSize", "offsetCondition"], "aSig": ["aSignature", "aAssIG", "aPsIG", "aAsig", "aaAssIG", "aSigs", "aSIG", " aAssigh", "waSourceigs", " aSignature", "aAssig", "asigs", "aBSiger", "aAssigs", "aaSigned", "aAsign", "aaAssig", "aSignig", "asIG", "aCSigs", "aSourceigs", "aASig", "aSSiger", "aDsg", "aTig", "aSourceiger", "saAsign", "aSetock", "aAssuff", "aaSg", "saAsig", "aSetigs", "aSignock", "aSysign", "aBSg", "aSigniger", "aSigned", "aSysiger", "aaSign", "saSess", "aSeg", "waSig", " aSature", "aDsiger", " aSigs", "aTIG", "saSign", "aBSig", "waSock", " aSigh", "asiger", "aDesature", "aSignIG", "vaSSiger", "aaSigma", "aSetig", "aSysig", "aAsiger", "aPosign", "aaSiger", "saAsess", " aSiger", "aSysic", "aBSign", "aDesig", "aCSuff", "aSSign", "aAssess", "aASigh", "aaSig", "aDsig", "aAsic", "aaAssigma", "aCSigh", "aSSig", "vaSSig", "aAsature", "waSigs", " aSignIG", "aSiger", "aSigneg", "aPosigs", "aAssign", "vaSSign", " aSeg", "aDsigma", "aSigh", "aaAssigned", "aASigs", "aDsIG", "aAsIG", "aSg", "aPsature", " aSigneg", "aCSig", "aSic", "vaSig", "aSuff", "asig", "aAssigma", "aTigma", "aSourceig", "aPsig", "aAssigned", "saSigs", "aDsign", "saAsigs", "aPosess", " aAssig", "aSignigs", "waSourceig", "aSigma", "aTigned", "aPosiger", "aSSic", "waSiger", "aAssigh", "waSourceock", "aSetiger", "aAsess", "saSig", "aSature", " aSuff", "aDeseg", "aPosig", "aSourceock", "vaSign", "aSess", "vaSSic", "vaSiger", "aASuff", "aaSIG", "aDsigned", " aSIG", " aSignig", "vaSic", "aSock", "aPosIG", " aAssigs", "aAsigs", "waSourceiger", " aAssuff"], "savedASig": ["savedSick", "savedASigs", "savedACIG", "savedFSib", "savedPSig", "savesASock", "saveAseg", "savesBSock", "savedPSeg", "saveASig", "saveAsigs", "savedAsigs", "savedAsib", "savedACock", "savedPSib", "savedBSig", "savedBSeg", "savesBSIG", "savedBSIG", "savesBSig", "savedAseg", "savedAsIG", "savedBSock", "saveASib", "saveAsib", "savedASIG", "savedACig", "savesASIG", "savedBSick", "savesASig", "savedACeg", "savesASick", "savedPSigs", "saveASeg", "savedASeg", "savedACick", "savedAsig", "savedFSig", "savedASib", "savedSock", "saveASigs", "savedASick", "savedFSigs", "savedSig", "savedSIG", "saveAsig", "savedFSeg", "savesBSick", "savedASock"], "z": ["az", "m", "ez", "zip", "q", "p", "zh", "o", "hz", "oz", "Z", "zi", "zer", "w", "d", "n", "iaz", "y", "cz", "zo", "shift", "it", "sc", "l", "b", "s", "c", "j", "i", "t", "gz", "g", "u", "rez", "count", "zag", "sign", "zero", " az", "tz", "nz", "h", "yz", "x", "str", "uz", "zen", "f", "iz", "zone", "v", "ze"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n", "idx": 22082, "substitutes": {"bs_queue": ["bs__buffer", "bs_que", "bsPqueue", "bles_dq", "bs_buffer", "ns_entry", "bles_queue", "lbs_queue", "js_entry", "ns_que", "BS_entry", "bs___component", "lbs_q", "bs_q", "bs___entry", "bs__ue", "bsuchque", "bs___queue", "bs_dq", "bsPque", "blesPdq", "BS_buf", "js_queue", "vs_queue", "ns_queue", "vs_ue", "bs_component", "blesPque", "lbs_ue", "vs_buffer", "bs__que", "BS_queue", "bsuchdq", "bsPdq", "bs__queue", "BS_que", "bs_ue", "lbs_que", "js_ue", "blesPspace", "bs_master", "abs_master", "blesPqueue", "abs_component", "abs_queue", "bs_space", "bsuchspace", "ns_client", "abs_entry", "bles_space", "bsPspace", "vs_que", "js_que", "bles_que", "bsuchqueue", "bs_client", "bs_buf", "bs___master"], "bs": ["js", "bed", "gs", "bridge", "ls", "bb", "hz", "bits", "bid", "bc", "bes", "sb", "vs", "outs", "bp", "bis", "ps", "css", "fs", "acs", "browser", "ds", "bus", "b", "ics", "ms", "cs", "ses", "ts", "ss", "stats", "aos", "aws", "bh", "bl", "ubs", "BS", "ns", "pb", "lb", "ks", "its", "fts", "boxes", "bps", "obs", "bi", "sts", "qs", "xs", "sys", "bos", "aps", "os", "lbs", "ats", "als", "vals", "uts", "bas", "cb", "bn"], "flags": ["pins", "acts", "sets", "comments", "tools", "FLAG", "posts", "bits", "ints", "amps", "tags", "lag", "ants", "outs", "parts", "weights", "ps", "states", "types", "acs", "ensions", "s", "settings", "cs", "ts", "terms", "items", "flag", "utils", "stats", "func", "args", "atts", "orts", "members", "cons", "fts", "actions", "ags", "options", "features", " Flags", "ports", "issues", "levels", "aps", "ats", "fps", "properties", "mask", "vals", "ops", "uts", "fields", "heads", "Flags", "locks"], "bs_entry": ["ts_entry", "bs_archive", "blog_channel", "bs__Entry", "blog_entry", "ts_ry", "bsMry", "bn_entity", "blog__system", "bsMchannel", "blog_ry", "bsMarchive", "bs_child", "bsMsystem", "bs_value", "blog__ry", "bn_child", "bsMentity", "obs_entry", "bs_member", "bed_ent", "bnMry", "bs_next", "bs__queue", "bed_value", "bnMentry", "blog_system", "bs_system", "bnMentity", "bn_entry", "bsMent", "bed_entry", "bsMchild", "bs_ry", "bs_ent", "bs__system", "bs_channel", "bsMentry", "bs__channel", "bnMchild", "bs__ry", "blog__entry", "bs_entity", "blog__channel", "ts_queue", "bsMvalue", "bed_archive", "obs_member", "obs_entity", "bs_Entry", "bn_ry", "bs__entry", "ts_Entry", "obs_next"]}}
{"project": "FFmpeg", "commit_id": "808c10e728db2d92ccbb0f8b3bcd4a2f4305a2cf", "target": 0, "func": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n\n                        AVBPrint part[3], int *print_prefix, int type[2])\n\n{\n\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n\n    av_bprint_init(part+0, 0, 1);\n\n    av_bprint_init(part+1, 0, 1);\n\n    av_bprint_init(part+2, 0, 65536);\n\n\n\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n\n    if (*print_prefix && avc) {\n\n        if (avc->parent_log_context_offset) {\n\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n\n                                   avc->parent_log_context_offset);\n\n            if (parent && *parent) {\n\n                av_bprintf(part+0, \"[%s @ %p] \",\n\n                         (*parent)->item_name(parent), parent);\n\n                if(type) type[0] = get_category(parent);\n\n            }\n\n        }\n\n        av_bprintf(part+1, \"[%s @ %p] \",\n\n                 avc->item_name(ptr), ptr);\n\n        if(type) type[1] = get_category(ptr);\n\n    }\n\n\n\n    av_vbprintf(part+2, fmt, vl);\n\n\n\n    if(*part[0].str || *part[1].str || *part[2].str) {\n\n        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;\n\n        *print_prefix = lastc == '\\n' || lastc == '\\r';\n\n    }\n\n}\n", "idx": 22086, "substitutes": {"ptr": ["ctx", "pointers", "rect", "tp", "vt", "p", "np", "sp", "pr", "pad", "tr", "td", "req", "loc", "port", " pointer", "br", "typ", "src", "pert", "ps", "pl", "offset", "fr", "inter", "attr", "rep", "proc", "xt", "pair", "address", "checked", "vp", "r", "iter", "ts", "nt", "dr", "pt", "pointer", "tor", "t", "point", "buffer", "pc", "vr", "txt", "ref", "cur", "desc", "snap", "tip", "resp", "eth", "handle", "hl", "obj", "ipt", "Ptr", "ctr", "arr", "esp", "inters", "addr", "hw", "err", "fp", "alloc", "peer", "mt", "cont"], "level": ["ity", "depth", "lvl", "fl", "loc", "debug", "ln", "priority", "tag", "unit", "scale", "Level", "vel", "style", "mode", "line", " lvl", "lc", "flag", "format", "pos", "layer", "link", "color", "code", "local", "levels", "le"], "fmt": ["vMT", "fmat", "vmt", "flt", "cformat", "cprintf", "Flt", "fformat", " flt", "cmt", "clt", " fMT", "infmat", "Fformat", "infprintf", "Fprintf", " fmat", "infmt", " fformat", "infMT", "fMT", "Fmt", "vmat"], "vl": ["list", "tp", " lev", "vc", "VL", " rel", "lvl", " li", " pl", "fl", "sel", "pe", "ln", "lists", "typ", "pl", "iv", "abl", "l", " sl", "vel", "vol", "nl", " lvl", "vp", " ml", "lv", " cl", "phrase", "msg", "bol", "ml", "len", "el", " val", " bl", " vol", "wl", " dw", " tv", " loc", "elt", " il", "rel", " fl", "kl", "v", "val"], "part": ["ror", "and", "name", "user", "on", "test", "join", "pt", "step", "format", "repair", "layer", "pod", "work", "attribute", " Part", "ad", "block", "command", "post", "der", "PART", "try", "one", "per", "trans", "component", "partial", "inter", "prefix", "vol", "detail", "pos", "error", "message", "sample", "first", " parts", "member", "piece", "mid", "art", "add", "state", "pad", "word", "power", "port", "quarter", "parts", "split", "point", "phrase", "patch", "msg", "var", "view", "star", "space", "diff", "p", "start", "par", "half", "span", "Part", "line", "vp", "pty", "party", "plan", "process", "base", "pre", "pair", "fix"], "print_prefix": ["printablepre", "printf_prefix", " print___prefix", " print___fix", "print_key", "printf_pre", " print___leading", "printf_key", "print___fix", "print_padding", "print2prefix", "printmmfix", "printablefix", " print___padding", "print___padding", "print2alias", "print___prefix", " print_fix", "print_leading", "print_alias", " print_leading", "printmmprefix", "printableprefix", "printmmalias", "print_fix", "print___leading", "print_pre", " print_padding", "printf_fix", "printablekey", "printf_alias", "print2fix"], "type": ["ty", "list", "try", "tp", "pack", "p", "start", "sp", "sort", "file", "state", "name", "pr", "cast", "length", "port", "pe", "ver", "tag", "unit", "range", "typ", "Type", "types", "test", "status", "inter", "role", "style", "ype", "info", "line", "core", "top", "scope", "function", "print", "t", "map", "shape", "format", "error", "set", "TYPE", "size", "buffer", "where", "key", "position", "var", "member", "link", "ping", "comment", "color", "count", "other", "null", "options", "all", "none", "time", "form", "view", "pre", "index", "call", "class", "trace"], "avc": ["aveic", "avct", "avic", "avercat", "afct", "avec", "afcat", " avg", " avcs", "afc", "avg", "afcs", "averc", "afcu", "avect", "averC", "avercu", "aveC", "avC", " avcc", " avct", "afac", "avcs", "avecs", " avcu", "avcu", "avelc", " avcat", "autic", "aveac", "averlc", "autC", "avcat", "autc", "avercc", "avecc", "averct", " avlc", "avercs", "avcc", "averac", "avlc", "afg", "avecu", " avac", "autcs", "averic", "avac", "aveg"], "parent": ["ctx", "relation", "pid", "cp", "m", "pkg", "Parent", "p", "mother", "sp", "par", "name", "params", "pr", "port", "per", "user", "tmp", "up", "master", "parents", "tree", "unit", "fat", "ps", "prop", "global", "test", "self", "holder", "chain", "man", "root", "top", "wrapper", "nt", "node", "stack", "origin", "pt", "server", "owner", "remote", "net", "map", "paren", "buffer", "pc", "pa", "child", "key", "ip", "var", "client", "tip", "snap", "instance", "null", "source", "comp", "op", "new", "fp", "rel", "cmp", "peer", "mt", "pool"]}}
{"project": "FFmpeg", "commit_id": "1f4ff53aea7c5090f31cd1323d95f7c407c9b2bb", "target": 0, "func": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)\n\n{\n\n    if (cid != ctx->cid) {\n\n        int index;\n\n\n\n        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);\n\n            return AVERROR(ENOSYS);\n\n        }\n\n        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);\n\n\n\n        ff_free_vlc(&ctx->ac_vlc);\n\n        ff_free_vlc(&ctx->dc_vlc);\n\n        ff_free_vlc(&ctx->run_vlc);\n\n\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n\n                 ctx->cid_table->ac_bits, 1, 1,\n\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,\n\n                 ctx->cid_table->dc_bits, 1, 1,\n\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n\n                 ctx->cid_table->run_bits, 1, 1,\n\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n\n\n        ctx->cid = cid;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22089, "substitutes": {"ctx": ["pkg", "xp", "check", "inst", "handler", "conf", "kt", "tmp", "tc", "iat", "conn", "sc", "nih", "kick", "worker", "nt", "pc", "unc", "resp", "work", "wcs", "cam", "tz", "crit", "hw", "wx", "px", "cb", "cv", "cp", "gc", "command", "qt", "jp", "ctrl", "cc", "tm", "cl", "co", "prefix", "config", "cas", "args", "document", "desc", "cu", "conv", "urg", "kl", "rc", "temp", "mk", "cn", "td", "req", "loc", "xc", "ka", "anc", "that", "nc", "cm", "Context", "proc", "lex", "history", "wp", "aux", "kw", "lc", "act", "jac", "msg", "txt", "ck", "std", "window", "obj", "abc", "comp", "exec", "ctl", "ct", "comm", "cfg", "ca", "parent", "bc", "typ", "mc", "etc", "c", "tx", "tk", "cmd", "func", "kk", "event", "context", "cf", "addr", "cmp"], "cid": ["ucify", "cpix", "cuid", "cID", "acdata", " cbid", "xcbid", "recvalid", "cnify", "cnh", "cuident", "Cide", "acide", "mcoid", "cids", "cidem", "recid", "cname", "xcid", "ch", "cppy", "cnid", " ctry", " cix", "ccid", "cph", "ctry", "cptry", "cnvalid", " cpy", "Cident", " cID", "camify", "ccide", "ccdata", "ccID", "coid", "xcID", "Cbid", " cidem", "Cdata", " crid", "ucip", "mcids", " cip", "cit", " cvalid", "cix", "cuids", "xcname", "Cit", "cdata", " cit", "cpid", "cpy", "cider", "cide", "camid", " ch", " cname", "xcvalid", "xcrid", "cnip", "recider", "crid", "camvalid", "xcip", "xcit", "acID", "xcider", "Coid", "gcidem", "cident", "ucvalid", " cider", "recip", "mcident", "gctry", "cip", "acid", "Crid", "cbid", "cvalid", "gcid", "Cid", "mcid", "cify", "cuoid", "Cids", "cnix", "ucid", "camip", "CID", "cpidem", "Cname", "gcpy"], "index": ["current", "check", "list", "num", "IND", "connect", "add", "get", "ix", "id", "si", "length", "insert", "port", "loc", "column", "value", "n", "delete", "test", "max", "available", "lock", "address", "scope", "no", "j", "item", "empty", "find", "query", "i", "point", "axis", "server", "pos", "loop", "active", "size", "in", "set", "match", "update", "from", "page", "key", "open", "gate", "position", "count", "link", "select", "read", "Index", "number", "instance", "len", "zero", "ind", "row", "all", "code", "local", "x", "connection", "new", "ex", "f", "draw"]}}
{"project": "FFmpeg", "commit_id": "e89f58810d0d508552089495781e2a70e95edb99", "target": 0, "func": "static void check_default_settings(AVCodecContext *avctx)\n\n{\n\n    X264Context *x4 = avctx->priv_data;\n\n\n\n    int score = 0;\n\n    score += x4->params.analyse.i_me_range == 0;\n\n    score += x4->params.rc.i_qp_step == 3;\n\n    score += x4->params.i_keyint_max == 12;\n\n    score += x4->params.rc.i_qp_min == 2;\n\n    score += x4->params.rc.i_qp_max == 31;\n\n    score += x4->params.rc.f_qcompress == 0.5;\n\n    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;\n\n    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;\n\n    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;\n\n    if (score >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Default settings detected, using medium profile\\n\");\n\n        x4->preset = av_strdup(\"medium\");\n\n        if (avctx->bit_rate == 200*1000)\n\n            avctx->crf = 23;\n\n    }\n\n}\n", "idx": 22093, "substitutes": {"avctx": ["wavjac", " avconn", "savcu", " avctl", "aftx", "savtx", " avcontext", "afcu", "savctx", " avjac", "avercontext", "wavcontext", "wavcfg", "averctx", "avercm", "wavctl", "afcontext", "avconn", "awcontext", "AVtx", "avecontext", " avcu", "avcu", "awctl", "wavcm", "awctx", "wavctx", "avcm", "savcontext", "AVconn", "avetx", "avcfg", "avectx", "afctx", "avcontext", "avjac", "AVctx", "avecm", "avejac", "wavtx", "avecfg", "avctl", "awtx", "avercfg", " avtx", "aveconn", "avtx", "AVcontext"], "x4": ["px49", "rx84", "xd04", "x400", "ix2004", "php2004", "xml2", "x49", " x6", "X04", "mx84", "x84", "tx44", "rxrin", "xml04", "ix4", "phpFour", "Xfour", "ixrin", "ixFour", "ixrib", "xd44", "rx104", "rx49", "fx4", "check54", "wx400", "work2004", "php400", "xrib", "tx4", "xd6", "upload4", " x44", "xrin", "xml104", "ox4", "rxFour", "upload2", "fxFour", "php104", "xdfour", "mx4", "ix49", "phpfour", "x2", "workrib", "xOutput", "xd2", "x2004", "check464", "ox400", "x54", "mx104", "xmlrib", "work4", "xmlfour", "check94", "xmlOutput", "php4", "wxFour", "fxrib", "ixfour", "xfour", "x44", "xml4", "X4", "wx4", " xfour", "x464", "rx4", "check2", "check4", " x464", "ix400", "php256", "xFour", "tx04", "upload94", "xml49", "ixOutput", "wxfour", "px2004", "x94", " x2", "x6", "php54", "php464", "xx2", "x104", "xd4", "fxfour", "ox2004", "oxrib", "upload464", "xx4", "xx04", "xmlFour", "rxfour", " x94", "mxfour", "x256", "X2", "x04", " x04", "tx6", "xx464", "xml464", "check104", "php49", "xml54", "work400", "xml84", "px4", "ix256", "wxrib", "px256"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n", "idx": 22094, "substitutes": {"env": ["ctx", "dev", "me", "vt", "viron", "te", "v", "end", "ve", "ev", "forge", "entry", "conf", "esm", "shell", "pe", "w", "esc", "ptr", "vs", "den", "ah", "conn", "enter", "environment", "expr", "er", "proc", "config", "eh", "ec", "org", "act", "server", "en", "open", "ew", "desc", "window", "next", "nv", "code", "obj", "e", "context", "h", "gear", "erd", "cv"], "sigset": ["siget", "sibmask", "sesigmaset", "sigmamask", " sIGmask", "sigmano", "insigmamask", "sigbase", "signmap", " sIGset", "sigmalock", "signspace", "sibset", "sigmasc", "sigstr", "sIGlist", "insigset", " siglist", "segset", "segget", "sogset", "sgmask", "sogstart", "signstring", "sigsc", "insigmastart", "sogno", "sigSet", "sigspace", " sIGmap", "insigenbase", "sgsc", "signame", " sIGstr", "signname", " sigstr", " sigstring", "sesiglock", "sibstr", "siblist", "sigsget", "siglist", " sigspace", "sesigsc", "sigsmap", "segspace", " sigsset", "segmask", " sigsget", "sigsset", "insigenset", " sIGlist", "signstart", "sesigmalock", "sigstring", "sigsSet", "sigget", "sigenset", "sigenbase", "sigmap", "signmask", "sesigset", "sesigmasc", "signsc", "sigsspace", "sgset", "insigmask", " sigsspace", "signlock", "sigsbase", "insigenet", "sigsclear", "signo", "insigmano", "insigstart", "signclear", " sigclear", "signno", "segstr", "sIGstr", "sigclear", "sIGmask", "signset", " sIGclear", "insiget", "sigenet", "sigmaset", "sogmask", "sesigmask", "insigenSet", "sIGmap", "sesigmamask", " signame", "insigSet", " sigget", "signget", " sIGname", "sIGclear", "sigmastart", "segstring", "sigenSet", "sigsstring", "sIGset", "sIGname", "seglist", "insigno", "sglock", "insigbase", "insigmaset", "sigstart", "siglock", " sigmap", " sigsstring", "sigsname"], "sigmask": ["sigask", "sigmmask", "sigmaak", "sigrak", "sigmamask", "insammmask", "sammmask", "Sigmmask", " sigmape", "sirmask", "sirmak", " sigmamask", " sigmaak", "sigmatak", "sigmaain", "siblake", " sigmaask", "sigrasks", "semicmask", "sigake", " sigmain", " sigmantle", "sichask", "sikkask", " sigmaain", "sikkantle", "sammask", "sigmaantle", "insammak", "siblak", " sigmaape", "sikkak", "insammask", "Sigmak", "sirmmask", "sirmape", "sigmasks", "sigak", "sigmape", "semicak", "semicask", "insigmasks", "sigmaake", "sigmap", "insammasks", " sigmatap", "sigmatask", "sigmaask", "sigape", "sigmaap", " sigmaantle", "insigmask", "sirmake", "sichain", "sigmain", "sammasks", "sichantle", " sigmmask", " sigmatak", " sigmaake", "insigmmask", "sigrmask", "sirmap", "sikkmask", "insigmak", "Sigmask", "siblask", "sigmake", "Sigmaask", "sigmaape", "semicantle", "Sigmamask", " sigmatmask", "siblmask", " sigmak", "sigmak", "sammak", "sigmatmask", "Sigmaake", "sichak", " sigmatask", " sigmake", "Sigmaak", "sigmaasks", "sigmatap", "sikkain", "sigmantle", " sigmap", "sigrask", "Sigmake"], "r": ["ror", "m", "cr", "q", "p", "kr", "mr", "v", "o", "rs", "pr", "or", "w", "d", "n", "fr", "rw", "rn", "l", "result", "er", "b", "rt", "c", "ry", "attr", "i", "dr", "rar", "t", "ar", "k", "R", "u", "g", "re", "e", "run", "h", "x", "rr", "rd", "err", "rel", "f", "rc"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n", "idx": 22132, "substitutes": {"opaque": ["iopaque", "opaques", "paques", "operque", "oplaque", "ipa", " opvious", "opvious", "opque", "iopque", "iopa", "ipque", "iopient", "paque", "operaque", " opque", "pque", "oplque", "opa", "ipient", "oplaques", "opient", "operient", "opera", "oplvious", "ipaque", "pvious", " opaques"], "s": ["js", "gs", "ssl", "ls", "q", "p", "sq", "sp", "o", "rs", "z", "es", "ps", "eps", "y", "fs", "ds", "b", "c", "ess", "cs", "r", "ts", "j", "ss", "i", "t", "aws", "less", "g", "ns", "its", "socket", "a", "hs", "sts", "sv", "h", "ats", "os", "S", "als", "f", "is", "v"]}}
{"project": "FFmpeg", "commit_id": "de1824e970d448a84bedce4936c301c322baa714", "target": 0, "func": "static int mpeg_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    Mpeg1Context *s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n\n    av_dlog(avctx, \"fill_buffer\\n\");\n\n\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE)) {\n\n        /* special case for last picture */\n\n        if (s2->low_delay == 0 && s2->next_picture_ptr) {\n\n            *picture = s2->next_picture_ptr->f;\n\n            s2->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return buf_size;\n\n    }\n\n\n\n    if (s2->flags & CODEC_FLAG_TRUNCATED) {\n\n        int next = ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);\n\n\n\n        if (ff_combine_frame(&s2->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0)\n\n            return buf_size;\n\n    }\n\n\n\n    s2->codec_tag = avpriv_toupper4(avctx->codec_tag);\n\n    if (s->mpeg_enc_ctx_allocated == 0 && (   s2->codec_tag == AV_RL32(\"VCR2\")\n\n                                           || s2->codec_tag == AV_RL32(\"BW10\")\n\n                                          ))\n\n        vcr2_init_sequence(avctx);\n\n\n\n    s->slice_count = 0;\n\n\n\n    if (avctx->extradata && !avctx->frame_number) {\n\n        int ret = decode_chunks(avctx, picture, data_size, avctx->extradata, avctx->extradata_size);\n\n        if(*data_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"picture in extradata\\n\");\n\n            *data_size = 0;\n\n        }\n\n        if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n\n            return ret;\n\n    }\n\n\n\n    return decode_chunks(avctx, picture, data_size, buf, buf_size);\n\n}\n", "idx": 22137, "substitutes": {"avctx": ["avsys", "ajcontext", " avconn", "avcb", "aftx", "abctx", "wavcontext", "avcmp", "avconf", " avcb", "afpkg", " avconfig", "wavcmp", "avetx", "avectx", "aveconf", "avcontext", "aftxt", "avetxt", " avtx", "aveconfig", "avtx", "averpkg", "ajjac", "aversys", "averctl", "avercmp", "wavctl", "avecp", "avca", "ajsys", "wavcp", "abcontext", "avecb", "ajctx", " avsys", "abkt", "abcmp", "avcp", " avcmp", "afctx", "avjac", "avepkg", "avectl", " avconf", " avpkg", "AVcontext", "avesys", " avcontext", "afcu", " avjac", "averctx", " avkt", "avercu", "abtx", "avercb", "avkt", "afcontext", "avconn", "AVtx", "avertx", "averconn", "avertxt", "vkt", "avecu", "vtx", "aveconn", "wavtxt", "averca", "aveca", "vcontext", "avercontext", "ajconfig", "afconn", "avconfig", " avtxt", "avecontext", " avcu", "avcu", "afcp", "wavctx", "wavsys", "wavconn", "vctx", "avpkg", " avca", "abpkg", "AVctx", "avejac", "wavtx", "wavpkg", "AVcu", "avctl", "ajconf", "avtxt"], "data": ["dat", "p", "input", "file", "family", "name", "pad", "image", "bin", "length", "d", "rew", "def", "to", "value", "bytes", "feed", " DATA", "text", "join", "raw", "empty", "images", "img", "video", "format", "t", "size", "area", "message", "frame", "sample", "buffer", "first", "reader", "stream", "device", "read", "window", "next", "a", "DATA", "package", "media", "ata", "batch", "rel", "block", "Data", "table"], "data_size": ["data_count", "data_number", " data_SIZE", "dataptSize", "dataptcache", " data_number", " data_cache", "data_Size", "result_count", "result_start", "data_length", "data8Size", "dataptlength", "data8SIZE", "data_SIZE", "result_SIZE", "result_size", " data_length", "data_cache", " data_Size", "data_start", "data8size", "data8number", "dataptsize"], "avpkt": ["avdpction", "avewpkg", "avwpkl", "avdpkl", "avpct", "avepct", "avpnt", "avepnt", "avepix", "avpix", "avwpction", "avepkt", "avdpkg", "averdppt", "avPacket", "avdpix", "avwpkt", "avPix", "avjpkl", "avdpacket", "avppt", "avPnt", "avdpkt", "averdpkl", "avwpct", "avdppt", "averdpkt", "avewpacket", "avjppt", "avewpnt", "avPqt", "avjpction", "avcpkt", "averpkt", "avPct", "avpacket", "avpkg", "avpkl", "avcpqt", "avwpacket", "averpkl", "avpction", "avewpqt", "avepqt", "avcpnt", "avewpct", "averppt", "avPkg", "avjpkt", "avpqt", "avwppt", "avcpct", "avPkt", "avwpqt", "averdpction", "avwpkg", "avwpnt", "avewpkt", "avepkg", "averpction", "avepacket", "avewpix", "avwpix"], "buf": ["ctx", "pkg", "uf", "p", "np", "seq", "box", "length", "bin", "loc", "tmp", "xff", "wb", "br", "Buffer", "bytes", "ob", "b", "text", "doc", "buff", "raw", "cmd", "img", "brace", "map", "bh", "rb", "buffer", "msg", "txt", "stat", "pb", "vec", "Buff", "next", "cam", "len", "mem", "queue", "batch", "rc", "fb", "pg", "err", "alloc", "cap", "cb", "cv"], "s": ["js", "m", "gs", "ssl", "sl", "ls", "sq", "p", "sp", "rs", "bs", "sb", "sports", "parts", "ps", "n", "sc", "fs", "sm", "ds", "self", "ims", "sa", "b", "c", "cs", "ess", "sw", "ts", "j", "ss", "stats", "t", "aws", "g", "ns", "hs", "a", "source", "sts", "sv", "sys", "ats", "h", "os", "S", "st", "is", "v"], "picture": ["ctx", "pkg", "profile", "p", "file", "pr", "name", "id", "image", "photo", "pict", "sharp", "password", "length", "util", "camera", "png", "movie", "feat", "P", "style", "peg", "info", "feature", "query", "Picture", "img", "video", "format", "document", "gif", "frame", "fi", "figure", "pen", "friendly", "piece", "support", "context", "pic", "media", "policy", "fp", "share", "stat"], "s2": [" s02", "cstwo", " sorter", " s3", "ls3", "e1", "sb2", "h3", "cssecond", "ts2", "ps2", "ps02", "less12", "ses1", "tssecond", "serv2", "ps1", "ts3", "csorter", "dssecond", "ls1", "sorter", "h2", "self2", "ds2", "less2", "s02", "sts2", "cs1", "sb1", "sbtwo", " stwo", "servtwo", "stsorter", "sts1", "s12", "sestwo", "ls2", "stwo", "less3", "ststwo", "sb3", "s1", "ses02", "e2", "S02", "etwo", "cs2", "dstwo", "servlet", "ses2", "S2", "s3", " slet", "ssecond", " s12", "lslet", "selftwo", "tstwo", "less02", "sts3", " s1", "ps3", "ts1", "self3", "pstwo", "stslet", "h02", "lstwo", "slet", "h12", "serv3", "S3", "S1", "selflet"]}}
{"project": "qemu", "commit_id": "9bd7854e1e5d6f4cfe4558090bbd9493c12bf846", "target": 0, "func": "static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n", "idx": 22140, "substitutes": {"opaque": ["Opaco", "iopaque", "imatile", "Opaque", "opacity", "ropaco", "paco", "opaco", "OPaco", " opaco", "imque", "operque", "OPaque", "opque", "ropacity", "iopque", " opacity", "OPque", "Opque", "ipacity", "operacity", "imaque", "ipque", "OPoid", " open", "paque", "opoid", "Opoid", "ropaque", "operaque", "open", "imacity", "pen", "pacity", "ipatile", "ropen", "opatile", "iopaco", "ipaque", "operatile", "iopoid"], "chr": ["chmr", "ichr", "hwrc", "shar", "Chdr", "Char", "ochr", "echdr", "chdr", "chrb", "Chc", "corar", " chro", "ochrb", "corr", "hwar", "cordr", "ichdr", "ichro", "ochar", " chrb", "qar", "Chrc", "chc", "shr", "qrc", "echr", " chdr", "echrc", "chrc", "ichrc", "hwr", "Chr", "qr", "hwmr", "Chmr", "shrc", " chc", "corc", "qrb", "shmr", " chrc", "chro", "echro", "ochrc"], "s": ["js", "gs", "spec", "sl", "ls", "sq", "p", "es", "rs", "bs", "conf", "sb", "vs", "ps", "n", "fs", "ims", "ds", "self", "er", "b", "c", "cs", "ess", "sw", "ts", "ses", "j", "serv", "ss", "stats", "less", "g", "ns", "its", "ins", "hs", "a", "sam", "source", "sts", "sv", "http", "sys", "ats", "se", "os", "h", "S", "als", "ex", "is", "v", "comm"], "size": ["south", "sp", "name", "type", "capacity", "score", "speed", "set", "gz", "count", "grow", "sized", "x", "ize", "any", "sent", "z", "SIZE", "esi", "year", "Size", "l", "scope", "iter", "sum", "args", "pos", "shape", "loss", "area", "message", "en", "see", "equal", "since", "v", "num", "sn", "export", "si", "length", "small", "notice", "to", "max", "limit", "send", "empty", "city", "g", "il", "fee", "space", "height", "start", "body", "id", "span", "scale", "n", "c", "no", "t", "number", "sha", "now", "e", "mem", "index", "dim"], "len": ["lf", "sl", "ls", "del", "end", "sp", "alt", "gl", "L", "fl", "length", "loc", "mn", "ln", "ld", "den", "n", "bytes", "wid", "pl", "lim", "lon", "l", "Len", "fin", "els", "fun", "limit", "nl", "lib", "lan", "iter", "enc", "la", "nt", "gen", "cap", "fil", "pos", "t", "fac", "gz", "en", "dl", "li", "il", "al", "resp", "late", "el", "ll", "hl", "all", "mem", "comp", "lp", "elt", "cmp", "mil", "coll", "label", "kl", "le", "val"], "buf": ["ctx", "temp", "uf", "p", "data", "bar", "seq", "tr", "bc", "box", "ba", "bin", "nm", "tmp", " buffer", "wb", "br", "Buffer", "ah", "bytes", "orig", " buffers", "BU", "b", "text", "doc", "buff", "raw", "iter", "cmd", "img", " buff", "pos", "bh", "db", "rb", "buffer", "msg", "txt", "ref", "vec", "var", "Buff", "window", "cv", "out", "mem", "str", "queue", "rc", "fb", "err", "cap", "cb", "v"]}}
{"project": "qemu", "commit_id": "fc3b32958a80bca13309e2695de07b43dd788421", "target": 0, "func": "static void smbios_build_type_1_fields(QemuOpts *opts)\n\n{\n\n    const char *val;\n\n\n\n    val = qemu_opt_get(opts, \"manufacturer\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"product\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"version\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"serial\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"uuid\");\n\n    if (val) {\n\n        if (qemu_uuid_parse(val, qemu_uuid) != 0) {\n\n            error_report(\"Invalid UUID\");\n\n            exit(1);\n\n        }\n\n    }\n\n    val = qemu_opt_get(opts, \"sku\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"family\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n}\n", "idx": 22151, "substitutes": {"opts": ["alms", "ackt", "optals", " opTs", "opjs", "opms", "opsouts", "synouts", "opTS", "iopts", "orts", "imouts", "optths", "opsths", " opt", " oprets", "opsts", "prot", "opouts", " opTS", "orters", "ioprets", "opsnt", "Opals", "royrets", "ackjs", "royts", "optts", "Opt", "opsats", "opspt", "Opouts", "opps", "porters", "porTS", "opnt", "opsals", "ports", "ipt", "iopps", "opals", "imls", "royps", "ackths", "ipnt", "optt", "opls", " opps", "orats", "imters", "alt", "opst", "optjs", "imts", "alts", "Opts", "ackts", "orpt", "ipts", "prots", "optpt", "optnt", "proms", "opths", "opt", "opters", "optouts", "optats", "optTS", "opTs", "opsjs", "opats", "optTs", "optters", "oppt", "iopters", "optls", "porTs", " opms", "synls", "synters", "synts", "oprets", " opters", "royters", "opsters"], "val": ["del", "gl", "sel", "conf", "sil", "virt", "prop", "test", "ret", "lib", "lit", "pt", "buf", " aval", "ind", "leg", "crit", "arr", "x", "pal", "cal", "echo", "ctx", "vt", "ival", "fl", "it", "l", "vol", "fail", "serv", "Val", "pol", "len", "urg", " eval", "kl", "v", "sl", "aval", "cert", "alt", "req", "vet", "gold", "fol", "tl", "lex", "item", "eval", "res", "bl", "li", "msg", "txt", "il", "var", "al", "compl", "el", "obj", "str", "lay", "err", "elt", "valid", "rel", "cfg", "old", "p", "pr", "def", "value", "pl", "VAL", "tx", "t", "reg", "cho", "ref", "ul", "rol", "all", "mem", "sv", " el", "vals", "als", "gal"]}}
{"project": "qemu", "commit_id": "5829b097204189c56dd1fb62c7f827360394bb39", "target": 0, "func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd, colour;\n\n    int args, len;\n\n    int x, y, dx, dy, width, height;\n\n    struct vmsvga_cursor_definition_s cursor;\n\n    uint32_t cmd_start;\n\n\n\n    len = vmsvga_fifo_length(s);\n\n    while (len > 0) {\n\n        /* May need to go back to the start of the command if incomplete */\n\n        cmd_start = s->cmd->stop;\n\n\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n\n        case SVGA_CMD_UPDATE:\n\n        case SVGA_CMD_UPDATE_VERBOSE:\n\n            len -= 5;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n\n            break;\n\n\n\n        case SVGA_CMD_RECT_FILL:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            colour = vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_FILL_ACCEL\n\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_RECT_COPY:\n\n            len -= 7;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            dx = vmsvga_fifo_read(s);\n\n            dy = vmsvga_fifo_read(s);\n\n            width = vmsvga_fifo_read(s);\n\n            height = vmsvga_fifo_read(s);\n\n#ifdef HW_RECT_ACCEL\n\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n\n                break;\n\n            }\n\n#endif\n\n            args = 0;\n\n            goto badcmd;\n\n\n\n        case SVGA_CMD_DEFINE_CURSOR:\n\n            len -= 8;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            cursor.id = vmsvga_fifo_read(s);\n\n            cursor.hot_x = vmsvga_fifo_read(s);\n\n            cursor.hot_y = vmsvga_fifo_read(s);\n\n            cursor.width = x = vmsvga_fifo_read(s);\n\n            cursor.height = y = vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            cursor.bpp = vmsvga_fifo_read(s);\n\n\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n\n            if (SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n\n                    goto badcmd;\n\n            }\n\n\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n\n            }\n\n#ifdef HW_MOUSE_ACCEL\n\n            vmsvga_cursor_define(s, &cursor);\n\n            break;\n\n#else\n\n            args = 0;\n\n            goto badcmd;\n\n#endif\n\n\n\n        /*\n\n         * Other commands that we at least know the number of arguments\n\n         * for so we can avoid FIFO desync if driver uses them illegally.\n\n         */\n\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            args = x * y;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_FILL:\n\n            args = 6;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_COPY:\n\n            args = 7;\n\n            goto badcmd;\n\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n\n            len -= 4;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n\n            goto badcmd;\n\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n\n            args = 12;\n\n            goto badcmd;\n\n\n\n        /*\n\n         * Other commands that are not listed as depending on any\n\n         * CAPABILITIES bits, but are not described in the README either.\n\n         */\n\n        case SVGA_CMD_SURFACE_FILL:\n\n        case SVGA_CMD_SURFACE_COPY:\n\n        case SVGA_CMD_FRONT_ROP_FILL:\n\n        case SVGA_CMD_FENCE:\n\n        case SVGA_CMD_INVALID_CMD:\n\n            break; /* Nop */\n\n\n\n        default:\n\n            args = 0;\n\n        badcmd:\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            while (args--) {\n\n                vmsvga_fifo_read(s);\n\n            }\n\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n\n                   __func__, cmd);\n\n            break;\n\n\n\n        rewind:\n\n            s->cmd->stop = cmd_start;\n\n            break;\n\n        }\n\n    }\n\n\n\n    s->syncing = 0;\n\n}\n", "idx": 22155, "substitutes": {"s": ["js", "gs", "m", "sl", "ls", "p", "sq", "es", "rs", "z", "bs", "params", "details", "conf", "w", "d", "sb", "bes", "sports", "ties", "n", "ps", "bis", "fs", "sm", "ds", "ims", "self", "er", "b", "c", "an", "ms", "r", "as", "ts", "ses", "serv", "j", "ss", "stats", "erences", "t", "im", "less", "set", "ns", "series", "ins", "its", "changes", "ers", "a", "hs", "sam", "ports", "source", "sts", "sv", "qs", "h", "sys", "ats", "os", "S", "is", "v", "comm"], "cmd": ["ctx", "cp", "cfg", "command", "close", "dir", "id", "req", "quit", "def", "conn", "ext", "init", "cl", "fun", "text", "c", "send", "kind", "fn", "ctl", "kw", "raw", "config", "flag", "act", "ct", "func", "method", "g", "fast", "col", "cd", "bg", "msg", "txt", "cli", "desc", "md", "head", "job", "code", "obj", "ind", "ctr", "sys", "op", "batch", "call", "Cmd", "err", "stat", "cb", "rc", "comm"], "colour": ["action", "wh", "stroke", "hair", "p", "v", "state", "our", "border", "filename", "image", "d", "which", " Colour", "blue", "phy", "l", "style", "text", "c", "focus", "html", "fil", " colours", "black", "format", "active", "g", "frame", "col", "txt", "color", "md", "ind", "source", "xy", "fg", "grey", "rg", "h", "filter", "pal", "theme", "f", "colored", "draw"], "args": ["gs", "Arg", "num", "ls", "alls", "bits", "params", "ax", "flags", "w", "parts", "n", "fs", "ds", "Len", "l", "ret", "cs", "Args", "ts", "axis", "func", "pos", "rows", "size", "ns", "md", "ags", "actions", "arg", "all", "xs", "arr", "vals", "fields"], "len": ["lf", "list", "num", "sl", "ls", "del", "alt", "lvl", "gl", "L", "fl", "length", "loc", "ln", "vet", "ell", "ann", "ellen", "lin", "syn", "den", "n", "pl", "lim", "lon", "l", "Len", "fin", "vl", "lic", "fun", "els", "vol", "limit", "tl", "nl", "lib", "fn", "lc", "lan", "lit", "gen", "nt", "pos", "size", "lis", "bl", "dl", "en", "li", "ul", "rev", "var", "vec", "resp", "compl", "lif", "el", "ll", "hl", "mem", "conv", "lp", "elt", "mult", "cmp", "coll", "kl", "un", "val"], "x": ["xp", "ox", "rx", "ix", " ox", "xd", "mx", "at", "ax", "xx", "yx", " ax", "length", "path", "w", "d", "xc", " tx", "xi", "lon", "ij", "l", "xt", "ry", "lex", "tx", "i", "foo", "ux", "ip", " i", " xx", "lat", "el", "X", "xy", "xs", "index", "addr", "wx", "px", "ex", "xxxx", "f", " cx", "v", "fx"], "y": ["iy", "ty", "yl", "oy", "my", "ady", "z", "fy", "ot", "ym", "ay", "on", "py", "vy", "sky", "ye", "b", "ny", "ry", "yr", "Y", "asy", "yt", "j", "icy", "ys", "i", "t", "yy", "yn", "uy", "axy", "key", "ies", "ey", "hy", "ind", "ch", "xy", "sys", "cy", "yi", "wy", "yer", "ya", "sy", "v", "gy"], "dx": ["xp", "eddy", "ox", "dir", "rx", "ix", "xd", "del", "mx", "xx", "yx", "ex", "ax", "d", "dt", "xi", "ds", "dh", "du", "tx", "dr", "dl", "ind", "xy", "xs", "dq", "dim", "wx", "wy", "px", "fx"], "dy": ["iy", "dos", "ty", "eddy", "dir", "ady", "fly", "dial", "dot", "length", "d", "dt", "phy", "py", "dj", "lon", "ds", "dh", "dies", "ded", "dn", "yy", "uy", "dl", "dd", "rison", "ji", "xy", "dq", "die", "wy", "dim", "yer"], "height": ["Height", "wh", "ty", "volume", "above", "depth", "radius", "background", "hold", " heights", "length", "power", "w", "headers", "padding", "confidence", "resolution", "png", "ht", "capacity", "style", "gravity", "strength", "history", "kw", "holes", "density", "build", "shape", "through", "size", "quality", "rank", "total", "window", "color", "hash", "hang", "grow", "th", "ch", "angle", "h", "weight", "dim", "bottom"], "cursor": ["ctor", "icoder", "dcursor", "icascade", "xcoder", "icursor", "dcoder", "ictor", "xcursor", "dcascade", "cascade", "dctor", "xcascade", "coder", "xctor"], "cmd_start": ["cmd_sp", " cmd_stop", "cmd_st", "cmd_stop", " cmd_st", " cmd_end", " cmd_sp", "cmd_end"]}}
{"project": "qemu", "commit_id": "69583490856713f693291b32fc74b6d0f5992b72", "target": 1, "func": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n", "idx": 22167, "substitutes": {"st": ["stage", "ust", "ast", "rest", "inst", "start", "sp", "ist", "ST", "sty", "d", "src", "sc", "fr", "status", "l", "ost", "rt", "St", "decl", "r", "nt", "t", "sta", "set", "stat", "est", "irst", "std", "desc", "ind", "sts", "usr", "str", "stop", "ste", "th", "mt"], "buf": ["ctx", "pkg", "ff", "uf", "data", "nb", "bs", "pad", " Buffer", "bag", "tr", "cast", "box", "w", "tmp", "ptr", " buffer", "wb", "br", "Buffer", "cache", "bytes", "fd", " buffers", "result", "b", "text", "doc", "buff", " b", "raw", "iter", "bt", "cmd", " buff", "pos", "db", "rb", "buffer", "cat", "txt", "msg", "ref", "vec", "var", "Buff", "cur", "off", "out", "pb", "window", "desc", "next", "mem", "str", "queue", "batch", "fb", "err", "cap", "block", "pool", "cb", "cv"], "end": ["dev", "ff", "wrap", "rest", "reset", "close", "start", "data", "End", "alt", "id", "pad", "name", "pend", "w", "ext", "it", "offset", "dest", "fin", "max", "ending", "text", "ender", "hend", "send", "enc", "ec", "ef", "append", " END", " End", "en", "nd", "est", "END", "et", "except", "desc", "comment", "out", "event", "len", "e", "ent", "all", "last", "ended", "h", "str", "stop", "begin", "ad", "east", "term", "rend"], "sysfspath": ["syscspopath", "sysfispopath", "sysvspaths", "sysfslile", "sysfosppath", "syscSpath", "sysfSPoint", "sysfaspath", "sysfspopath", "sysfospaths", "syscSpaths", "sysfSpATH", "sysfaspaths", "sysfscpath", "sysfslath", "sysfssaths", "sysvssile", "syscSPoint", "syscSpATH", "sysfisppath", "sysfospath", "sysfsppath", "sysfaspopath", "sysfspATH", "sysfSPath", "sysvssaths", "sysfispaths", "sysvsspath", "sysfslaths", "sysfispath", "sysfaspATH", "sysvsppath", "sysfscopath", "syscSPath", "sysfSpath", "sysfsspath", "sysfSpopath", "sysfSPpath", "sysvspile", "sysfSpaths", "sysfasppath", "sysfspoint", "sysfslopath", "sysvspath", "syscspoint", "syscspATH", "syscSPpath", "sysfspile", "sysfssile", "syscspaths", "syscSPopath", "sysfssopath", "sysfscath", "sysfscoint", "syscspath", "sysfspaths", "syscSpopath", "sysfslpath", "sysfssath", "sysfsloint", "syscsppath", "sysfSPopath", "sysvssath", "sysfospile"], "ret": ["grad", "at", "ext", "fd", " Ret", "ort", "lit", "nt", "dr", "pt", "ft", "oret", "rev", "resp", "arg", "leg", "after", "nz", "arr", "RET", "gc", "uf", "try", "vt", "Ret", "dt", "att", "fun", "rt", "pret", "iter", "flag", "print", "net", "not", " RET", "cat", "desc", "len", "rets", "usr", "pas", "back", "cont", "reset", "num", "success", "alt", "tr", "vet", "ptr", "red", "rem", "r", "ord", "deg", "res", "stay", "re", "err", "elt", "rel", "opt", "ter", "def", "result", "expr", "ry", "xt", "no", "j", "cmd", "func", "t", "det", "reg", "ref", "out", "eth", "gt", "rm", "mt", "val"], "max_segments": ["max_sements", "maxlensegments", "max_segs", "max_selements", "maxlensegs", "max_begments", "max_selevels", "max_schegments", "max_degments", "maxlenbeges", "max_velevels", "max_belevels", "max_beges", "maxlenseges", "max_teges", "max_tegs", "max_dements", "maxlenbegment", "maxlenbegments", "max_begs", "max_parsegments", "max_segment", "max_megments", "max_megment", "max_begment", "max_degment", "maxlensegment", "max_belements", "max_vegments", "max_parsements", "max_schements", "maxlenbegs", "max_vements", "max_seges", "max_megs", "max_tegments", "max_tegment", "max_schegment", "max_bements", "max_schelements", "max_parselevels", "max_vegment", "max_delements", "max_meges", "max_parsegment"]}}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n", "idx": 22201, "substitutes": {"s": ["js", "gs", "m", "spec", "ls", "p", "sq", "es", "rs", "z", "bs", "details", "d", "sb", "ties", "n", "ps", "sc", "states", "fs", "sm", "ds", "l", "self", "b", "c", "cs", "an", "sw", "ts", "ses", "serv", "ss", "i", "t", "aws", "less", "ns", "ies", "store", "session", "a", "hs", "services", "source", "sts", "sv", "qs", "h", "ats", "se", "os", "sys", "S", "als", "is", "v", "comm"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 22250, "substitutes": {}}
{"project": "qemu", "commit_id": "113fe792fd4931dd0538f03859278b8719ee4fa2", "target": 1, "func": "static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n", "idx": 22265, "substitutes": {"bs": ["js", "gs", "ls", "bb", "rs", "bits", "bc", "blog", "bes", "sb", "vs", "bp", "bis", "ps", "bytes", "fs", "ds", "b", "ms", "cs", "bm", "ts", "ib", "bt", "ubis", "aos", "bh", "bl", "BS", "ubs", "ns", "ils", "pb", "its", "ks", "bps", "obs", "bi", "sts", "bf", "bos", "ats", "lbs", "als", "bas", "cb"], "options": ["tools", "tops", "bits", "params", "details", "times", "classes", "parts", "ps", "types", "ims", "Options", "currency", "style", "values", "info", "settings", "scope", "terms", "config", "ts", "abilities", "IONS", "stats", "keys", "results", "args", "errors", "atts", "metadata", "offs", "option", "policy", "ptions", "properties", "os", "als", "ops", "vals", "caps", "styles", "locks"], "flags": ["FLAG", "bits", "details", "times", "tags", "lag", "parts", "ps", "states", "types", "bugs", "status", "ms", "files", "settings", "ts", "flag", "allows", "faces", "stats", "lines", "args", "uses", "atts", "names", "xf", "ags", "features", " Flags", "levels", "aps", "fps", "properties", "mask", "vals", "ops", "fields", "Flags", "locks"], "errp": [" erps", "errorP", "errorpc", " errP", " errpc", "rrps", "rrP", " erpb", "errpb", "rrpb", "errorp", "rrpa", "errorpa", " erp", "errps", " erpa", "errpc", "rrp", " errpb", "errpa", "errP", " errpa", " errps", "rrpc"], "client": ["cp", "close", "connect", "public", "contact", "p", "entry", "manager", "secure", "handler", "web", "util", "proxy", "block", "cache", "conn", "oe", "force", "cl", "co", "google", "c", "lock", "lib", "wrapper", "config", "app", "nt", "cmd", "i", "server", "remote", "controller", "open", "key", "cli", "et", "store", "con", "ip", "writer", "out", "socket", "channel", "window", "obj", "session", "ch", "http", "context", "local", "connection", "batch", "call", "Client", "io", "cell", "cod", "bo"], "ret": ["sp", "at", "reply", "ext", " Ret", "nt", "pt", "ft", "oret", "tn", "rev", "resp", "ll", "arg", "last", "after", "nz", "arr", "RET", "prot", "gc", "try", "Ret", "jp", "dt", "inter", "att", "fun", "rt", "pret", "ben", "flag", "print", "sum", " RET", "cat", "lt", "desc", "val", "len", "rets", "usr", "ert", "cont", "reset", "num", "success", "alt", "tr", "ptr", "red", "rem", "status", "deg", "res", "txt", "re", "err", "elt", "opt", "ter", "def", "result", "ry", "xt", "j", "cmd", "t", "det", "reg", "ref", "out", "mem", "gt", "rm", "mt", "final"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n", "idx": 22270, "substitutes": {"opaque": ["iopaque", "opaques", "Opaque", "iopaques", "oplasi", "oplaque", "OPaque", "OPaques", "opque", "iopque", "oplay", "OPque", "Opque", "opasi", " oplay", "Oplay", " opque", "oplque", "Opaques", "OPasi", "oplaques", "iopasi", "OPlay", " opaques"], "addr": ["end", "np", "adr", "rs", "at", "name", "attr", "address", "mac", "dr", "phys", "ip", "rev", "a", "ress", "arr", "x", "hw", "ad", "block", "arp", "trans", "range", " address", "shift", "b", "rt", "nl", "pos", "align", "hash", "len", "ack", "add", "Address", "alt", "state", "pad", "loc", "ptr", "ace", "ay", "url", "offset", "r", "ord", "act", "res", "obj", "err", "alloc", "rel", "ix", "alias", "id", "n", "src", "expr", "dh", "tx", "cmd", "host", "i", "ref", "off", "sha", "eth", "now", "handle", "gt", "index", "cmp", "mt"], "retval": ["RETVAL", " retvals", "fulvol", "RETbal", "RetVal", " returnbal", "retfac", "RETval", "retVal", "RetVAL", "Retret", "retcal", "returnVal", "retvalue", "retvol", " returnVal", "retsvol", "fulvals", "mtval", " retcal", "retsfac", " returnval", " retVAL", "fulval", "reVal", "reval", "retVAL", "retsval", "retv", " retVal", " retvalue", " returnVAL", "reret", " retv", "fulfac", "Retv", "mtvalue", "rev", "retret", "returnval", "mtcal", "RETVal", " retvol", " retbal", "returnvalue", "mtVal", " retfac", "Retval", "retsvals", "retvals", " retret", "returncal", "retbal"], "d": ["dos", "done", "dat", "o", "mod", "debug", "ld", "des", "gd", "pd", "fd", "dj", "ds", "dict", "dh", "du", "ord", "di", "da", "dr", "ded", "dm", "dn", "db", "dl", "od", "dc", "dd", "did", "de", "ade", "md", "ind", "D", "cal", "bd", "ad", "sd", "ctl"]}}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n", "idx": 22276, "substitutes": {"env": ["ctx", "dev", "kh", "end", "viron", "te", "sp", "ve", "ev", "esm", "conf", "engine", "pe", "esc", "sb", "ptr", "eng", "vs", "ah", "vm", "sc", "enter", "environment", "proc", "vp", "scope", "eh", "serv", "ec", "org", "ef", "uv", "En", "en", "vr", "gate", " environment", "ew", "cv", "window", "eas", "buf", "nv", "estate", "e", "context", "ope", "sv", "param", "eu", "ov", "gear", "cap", "Environment", "erd", "v"], "tlb": ["tLB", " tbh", "hotlbs", "ttbh", "vlbs", "vpl", "ttlp", "antLB", "antlbs", "ttlbs", "tbh", "vlb", "tlp", "hotlb", " tpl", "TLB", "itlp", " tlbs", "Tlp", "itlb", "Tlbs", "hotlp", "Tpl", "itlbs", "antlb", "Tlb", "antlp", "itLB", " tlp", "hotbh", "tpl", "tlbs", "ttlb"], "tlbncfg": ["tlbnjp", "tlbanconfig", "tlBNgov", "tlbincmd", "tlijnfg", "tlBNfg", "tlbmfg", "llbmcfg", "tlbingov", "llbncfg", "hlBNgov", "tlgnfg", "tlijnconfig", "tlcnfg", "llbnfg", "tlBNcfg", "llbmconfig", "tlbncmd", "hlBNconfig", "rlbncfg", "llbmjp", "rlcnalg", "tlBNconf", "tlcncfg", "tlbnconfig", "tlbincfg", "tlijncfg", "tlbancfg", "tlgncmd", "llbnjp", "tlbinconfig", "tlijngov", "rlcnfg", "llbnconfig", "tlgnconfig", "tlBNconfig", "rlcnconf", "llbncmd", "tlbngov", "hlBNcfg", "llbmfg", "rlcncfg", "hlbngov", "hlbnconfig", "tlbmconf", "tlbanfg", "rlbnconf", "tlbnalg", "hlbnfg", "tlgncfg", "tlbmconfig", "rlbnfg", "rlbnalg", "tlbanjp", "tlcnalg", "tlbmjp", "tlbmcmd", "tlbnconf", "tlBNjp", "hlBNfg", "tlbmalg", "tlbinfg", "tlbnfg", "tlbmcfg", "tlcnconf", "hlbncfg", "llbmcmd", "tlBNalg"], "tlbm_size": ["tlbn_scale", "tlbn_Size", "tlbn_SIZE", "tlbm67scope", "tlbm_Size", "tlbal_Size", "tlbm_sum", "tlbm67size", "tlmn_size", "tlbal_SIZE", "tlbm_scale", "tlbn_sum", "tlbm67Size", "tlbm2scale", "tlmn_SIZE", "tlbn_size", "tlbn_scope", "tlbm_SIZE", "tlbal_size", "tlbm_scope", "tlmn_Size", "tlbm67dim", "tlbm2SIZE", "tlbm_dim", "tlbm2Size", "tlbm_ize", "tlmn_ize", "tlbn_dim", "tlbm2size"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n", "idx": 22279, "substitutes": {"xfer": ["ixiter", "xhr", "hffer", "pxvert", "yfe", "eyforge", "eypir", "lexFER", "yfer", "oxiter", "ixpir", "xforge", "hference", "xypire", "oxlate", "ixff", "ryference", "xyference", "yFER", "hfer", "rossfer", "ixfer", "oxferred", "crossFER", "ixFer", "eyference", "xFER", "wxmit", "xvert", "xpire", "xff", "xference", "oxvert", "xporter", "workference", "xfe", "ixference", "xFer", "hff", "eyFer", "xxFER", "eyffer", " xferred", "crossmit", "workiter", "xiter", "ixferred", "xxfe", "ixforge", "ixvert", "oxfer", "pxfer", "xyfer", "rypire", "htransfer", "hFer", "lexiter", "xmit", "workffer", " xference", "oxference", "crossporter", "wxfer", "rosspire", "wxfe", " xffer", "workfer", " xlate", "ixffer", "pxference", "xffer", "oxffer", "pxiter", "wxFER", "pxferred", " xtransfer", "pxpir", "ixFER", "oxFER", "xlate", "xtransfer", "oxmit", "xpir", " xmit", "xferred", "xxfer", "eyfer", "xxhr", "ixporter", "ixlate", "ixtransfer", "crossfer", " xff", "rossference", " xiter", "ryfer", " xFER", "wxporter", "pxforge", "yhr", "wxhr", "lexfer", "ixmit"], "port": ["parent", "type", "cast", "pport", "range", "test", "ort", "limit", "address", "serv", "host", "pt", "mit", "buffer", "pc", "ref", "et", "link", "pod", "select", "channel", "socket", "Port", "ports", "gp", "PORT", " sport", "eport"], "ep": ["cp", "eg", "ape", "p", "eb", "pp", "tp", " e", "sp", "ev", "pe", "ether", "bp", "eps", "ech", "mp", "Ep", "peak", "vp", "tap", "ec", "ef", "point", "ek", "lip", "dp", "ip", "ew", "ap", "eth", "e", "EP", "gp", "ope", "eur", "esp", "op", "cap", "dep"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void thread_pool_cancel(BlockAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        qemu_bh_schedule(pool->completion_bh);\n\n\n\n        elem->state = THREAD_DONE;\n\n        elem->ret = -ECANCELED;\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool->lock);\n\n}\n", "idx": 22280, "substitutes": {"acb": ["Acbo", " acbo", "aconp", "acony", "aconb", " cacy", "aconfb", "acp", "accba", " acbb", "aconbo", "acbb", "Acb", "acbo", "Acbb", "aconbb", "aconba", " acp", "Acp", "acfb", "acba", " cacfb", "accfb", " cacba", " cacb", "accb", "acy", "accy"], "elem": ["entlem", " elev", "eem", "eclement", "eelems", "telem", "erleg", "peom", "pele", " element", "elelem", "telev", "elev", " ept", "eclev", "mept", "eept", "entm", "element", "erlev", "slem", "pelement", " em", "pelam", "melement", "telement", "melev", "pelems", "entom", "eele", "melam", "celem", "dlem", "elelements", "celems", "npt", "eclem", " elam", "spt", "elements", "eelam", "eelements", "ept", "pem", "veleg", "slement", "velem", "vem", "elelt", "elelement", "ecleg", " eom", " ele", "dlev", "ele", "nlement", "velement", "erlem", "melem", "eelement", "velev", "pelem", "dem", "elam", "teem", "elt", "elems", "elelems", "em", "eelem", "velements", "erlement", "celev", "eelev", "entlement", "nlem", "slev", "eleg", "celt", "eom", "elelev", "meem", " elems", "dlement", "nlam", " elt"], "pool": ["pkg", "hold", "memory", "type", "ool", "conn", "rain", "role", "chain", "pt", "pro", "pc", "client", "store", "queue", "px", "container", "block", "table", "ctx", "cp", "list", "manager", "box", "util", "common", "range", "cache", "quote", "prefix", "core", "wrapper", "loop", "shape", "socket", "flow", "ools", "meter", "temp", "program", "profile", "state", "platform", "length", "port", "pm", "phy", "limit", "thread", "Pool", "timeout", "network", "driver", "phony", "window", "view", "policy", "connection", "height", "p", "layout", "lock", "host", "pty", "prof", "size", "buffer", "select", "process", "out", "handle", "mem", "context", "pg"]}}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n", "idx": 22300, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "5952b8da0b7f65dfa23991e71737e0abdaeb339c", "target": 1, "func": "static int seek_test(const char *input_filename, const char *start, const char *end)\n\n{\n\n    AVCodec *codec = NULL;\n\n    AVCodecContext *ctx= NULL;\n\n    AVCodecParameters *origin_par = NULL;\n\n    AVFrame *fr = NULL;\n\n    AVFormatContext *fmt_ctx = NULL;\n\n    int video_stream;\n\n    int result;\n\n    int i, j;\n\n    long int start_ts, end_ts;\n\n\n\n    size_of_array = 0;\n\n    number_of_elements = 0;\n\n    crc_array = pts_array = NULL;\n\n\n\n    result = avformat_open_input(&fmt_ctx, input_filename, NULL, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't open file\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avformat_find_stream_info(fmt_ctx, NULL);\n\n    if (result < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't get stream info\\n\");\n\n        return result;\n\n    }\n\n\n\n    start_ts = read_seek_range(start);\n\n    end_ts = read_seek_range(end);\n\n    if ((start_ts < 0) || (end_ts < 0))\n\n        return -1;\n\n\n\n    //TODO: add ability to work with audio format\n\n    video_stream = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);\n\n    if (video_stream < 0) {\n\n      av_log(NULL, AV_LOG_ERROR, \"Can't find video stream in input file\\n\");\n\n      return -1;\n\n    }\n\n\n\n    origin_par = fmt_ctx->streams[video_stream]->codecpar;\n\n\n\n    codec = avcodec_find_decoder(origin_par->codec_id);\n\n    if (!codec) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't find decoder\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx = avcodec_alloc_context3(codec);\n\n    if (!ctx) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate decoder context\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = avcodec_parameters_to_context(ctx, origin_par);\n\n    if (result) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't copy decoder context\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avcodec_open2(ctx, codec, NULL);\n\n    if (result < 0) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Can't open decoder\\n\");\n\n        return result;\n\n    }\n\n\n\n    fr = av_frame_alloc();\n\n    if (!fr) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate frame\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);\n\n    if (result != 0)\n\n        return -1;\n\n\n\n    for (i = start_ts; i < end_ts; i += 100) {\n\n        for (j = i + 100; j < end_ts; j += 100)\n\n        result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 0);\n\n        if (result != 0)\n\n            return -1;\n\n    }\n\n\n\n    av_freep(&crc_array);\n\n    av_freep(&pts_array);\n\n    av_frame_free(&fr);\n\n    avcodec_close(ctx);\n\n    avformat_close_input(&fmt_ctx);\n\n    avcodec_free_context(&ctx);\n\n    return 0;\n\n}\n", "idx": 22316, "substitutes": {"input_filename": ["inputingfilename", "inputilefp", "input_username", " input_username", "input_file", "input_package", " input_fp", "inputilefilename", " input_string", "inputilefile", "input_string", "input_fp", "inputingstring", "inputilepackage", "inputingusername", " input_package", "inputingfp", " input_file"], "start": ["rest", "check", "get", "reset", "close", "add", "entry", "name", "starting", "range", "offset", "init", "inter", "Start", "wind", "iter", "date", "query", "step", "pos", "set", "match", "first", "from", "need", "open", "create", "read", "next", "change", "before", "base", "time", "stop", "part", "begin", "art", "st", "seek", "use", "help"], "end": ["post", "close", "old", "add", "End", "id", "pad", "length", "to", "range", "ext", "chain", "max", "ending", "send", "load", "edge", "step", "append", "size", " End", "en", "nd", "est", "open", "END", "wall", "except", "until", "out", "change", "e", "last", "after", "ended", "stop", "ad", "east", "term"], "codec": ["acoder", " codcc", "coddec", "odcc", "codtor", "Codec", "pedec", "codstream", "odec", "callEC", " coddec", " codeca", "odtor", "codcc", "cmpstream", " codstream", " codEC", "coec", "coEC", "callcc", "Cododer", "oddec", "odeca", "odEC", "camdec", "pedEC", "CodEC", "odstream", "acEC", "odef", " codef", "codrc", "coef", "cmp_", "codef", "camtor", "callec", "camEC", "calleca", "Codeca", " codtor", "od_", "camec", "corc", "pedoder", " cod_", "codEC", " codrc", "codeca", "pedeca", "odrc", "cod_", "aceca", "acec", "cododer"], "ctx": ["cp", "pkg", "cfg", "gc", "kr", "ca", "np", "grad", "mk", "fw", "bc", "loc", "jp", "kt", "ctrl", "tmp", "ptr", "tc", "iat", "cache", "conn", "nc", "mc", "cc", "cm", "init", "co", "aux", "kw", "tx", "ctl", "cmd", "nt", "act", "cond", "jac", "unc", "txt", "ck", "buf", "obj", "voc", "context", "ctr", "cu", "sys", "cf", "addr", "hw", "alloc", "wx", "cmp", "pool", "cb", "cv", "ct"], "origin_par": ["origin_rel", "origin_param", "origin__par", "origin__param", "originerpar", "originercomp", "origin___comp", "translation_pair", "originetypair", "translation_rel", "origin_prep", "originitycomp", "translationetyrel", "origin_pas", "origin___par", "origin_har", " originerpas", " originercomp", "translation_par", "originetypar", "origin__comp", "origin_pol", "translationetypar", " originerhar", "originerhar", " origin_har", "originerpas", "translation_prep", " originerpar", "translationetyprep", " origin_param", "origin_part", "originetyprep", "origin_pair", "originitypas", " origin_pol", " origin_part", "origin___part", "originetyrel", " origin_comp", " origin_pas", "originitypar", "translationetypair", "originityhar", "origin_comp", "origin___pol"], "fr": ["ff", "pr", "tr", "fl", "fw", "jp", "ptr", "iat", "br", "fd", "rn", "fin", "rt", "fram", "fn", "fc", "FR", "dr", "res", "fi", "nd", "pol", "ch", "arr", "tf", "fb", "fm", "fp", "mt"], "fmt_ctx": ["flt_context", "fmt_tx", "fmt_context", "ftx_context", "fmt_cmd", "ftx_co", "fmt_co", "flt_mk", "flt_cmd", "fmt_dict", "flt_tx", "flt_ctx", "ftx_tx", "flt_dict", "fmt_mk", "fmt_pkg", "ftx_pkg", "ftx_ctx"], "video_stream": ["video___query", "video___stack", "video____stream", "radio___stick", "video\u064estream", "visual_stream", "visual_stack", "radio_iterator", "videopleiterator", "video_host", "video____stick", "visual_query", "video_stack", "video\u064estack", "video___iterator", "radio___stage", "video____stage", "videoplestage", "video2Stream", "radio_stick", "Video_path", "video_stage", "videoplestream", "video_iterator", "video_path", "video2form", "video___field", "Video_stream", "radio_stage", " video_form", "radio___iterator", "visual_field", "videoplestick", "video___stage", "video_query", " video_Stream", "video_stick", "video2stream", "Video_host", "radio___stream", "video___stream", "Video_Stream", "video_form", "video_Stream", "radio_stream", "video____iterator", "video\u064efield", "video\u064equery", "video_field", "video___stick"], "result": ["json", "name", "type", "database", "user", "ver", "sql", "ception", "test", "ret", "chain", "uu", "feature", "score", "unknown", "cur", "count", "instance", "none", "record", "table", "trace", "term", "list", "data", "reason", "division", "important", "function", "date", "error", "message", "goal", "comment", "created", "back", "rc", "relation", "this", "public", "success", "report", "cert", "tr", "folder", "power", "length", "ptr", "notice", "duration", "status", "currency", "proc", "r", "false", "results", "fac", "res", "create", "total", "answer", "obj", "Result", "err", "valid", "progress", "current", "description", "contact", "diff", "make", "complete", "def", "value", "true", "task", "RESULTS", "mark", "integer", "rar", "db", "successfully", "process", "number", "coord", "code", "event", "zero", "all", "new", "response", "final"], "i": ["m", "ci", "p", "z", "si", "n", "y", "it", "l", "ij", "ti", "mi", "b", "c", "r", "t", "li", "a", "index", "x", "ii", "pi", "I", "f", "v"], "j": ["js", "jj", "m", "json", "q", "p", "z", "aj", "jp", "n", "shift", "l", "ij", "b", "jc", "r", "pos", "t", "k", "g", "J", "ji", "ind", "jump", "kj", "v"], "start_ts": ["start_times", "startpyte", "art_ts", "art_points", "start_tile", "startpyts", "startxds", "startpytes", "st_ptr", "startxtes", "art_tes", "origin_te", "start67tile", "st_times", "startxpoints", "start_ms", "origin67tes", "start_points", "start67tes", "start_tes", "origin_tile", "origin_tes", "st_ts", "start_te", "start67te", "origin67te", "startpytile", "art_ds", "origin67tile", "st_ms", "start_ds", "start_ptr", "origin67ts", "startxts", "origin_ts", "start67ts"], "end_ts": [" end_points", "end_tes", " end_tes", "endmmtp", "endmmts", "endmmtile", " end_times", " end_tile", "end__times", "end_times", "end__tes", " end_tp", "end__ts", "end_tp", "endmmtimes", "end_points", "end_tile", "end_ms", "end__ms", " end_ms"]}}
{"project": "qemu", "commit_id": "5229f45bd98558af84d806a98032df3cb741c357", "target": 0, "func": "AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,\n\n                      uint8_t len, uint8_t *data)\n\n{\n\n    AUXReply ret = AUX_NACK;\n\n    I2CBus *i2c_bus = aux_get_i2c_bus(bus);\n\n    size_t i;\n\n    bool is_write = false;\n\n\n\n    DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address,\n\n            cmd, len);\n\n\n\n    switch (cmd) {\n\n    /*\n\n     * Forward the request on the AUX bus..\n\n     */\n\n    case WRITE_AUX:\n\n    case READ_AUX:\n\n        is_write = cmd == READ_AUX ? false : true;\n\n        for (i = 0; i < len; i++) {\n\n            if (!address_space_rw(&bus->aux_addr_space, address++,\n\n                                  MEMTXATTRS_UNSPECIFIED, data++, 1,\n\n                                  is_write)) {\n\n                ret = AUX_I2C_ACK;\n\n            } else {\n\n                ret = AUX_NACK;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    /*\n\n     * Classic I2C transactions..\n\n     */\n\n    case READ_I2C:\n\n    case WRITE_I2C:\n\n        is_write = cmd == READ_I2C ? false : true;\n\n        if (i2c_bus_busy(i2c_bus)) {\n\n            i2c_end_transfer(i2c_bus);\n\n        }\n\n\n\n        if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n            ret = AUX_I2C_NACK;\n\n            break;\n\n        }\n\n\n\n        ret = AUX_I2C_ACK;\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n", "idx": 22330, "substitutes": {"bus": ["ac", "ctx", "dev", "bridge", "us", "Bus", "bs", "BUS", "cast", "bc", "box", "handler", "mount", "user", "util", "conn", "usb", "chain", "b", "hand", "boot", "lock", "c", "sync", "aux", "proc", "lib", "config", "board", "host", "loop", "cat", "driver", "gate", "ux", "link", "store", "route", "handle", "bug", "base", "http", "local", "os", "connection", "way", "back", "block", "book", "hub"], "cmd": ["action", "cp", "ctx", "command", "pkg", "check", "cfg", "name", "seq", "type", "req", "id", "quit", "kt", "ctrl", "def", "request", "that", "prop", "ext", "force", "content", "bind", "offset", "kick", "good", "text", "mode", "send", "kind", "ctl", "config", "gen", "nt", "find", "act", "ct", "func", "auth", "method", "Command", "col", "cd", "msg", "txt", "cli", "iq", "count", "resp", "cur", "md", "job", "handle", "code", "ctr", "form", "crit", "cf", "op", "addr", "Cmd", "cmp", "cont", "cb", "cod", "comm"], "address": ["action", "command", "m", "description", "add", "Address", "start", "direction", "alias", "at", "memory", "id", "length", "distance", "port", "image", "path", "ptr", "ace", "padding", "request", "range", "offset", "each", "chain", "prefix", "exclusive", "location", "order", "point", "pointer", "ai", "shape", "size", "error", "message", "pc", "position", "ip", "record", "store", "route", "number", "a", "operation", "base", "interface", "context", "reference", "before", "index", "x", "attribute", "resource", "pi", "addr", "enable", "condition", "array", "block", "table", "trace"], "len": ["lf", "list", "num", "ls", "del", "sp", "full", "seq", "id", "L", "length", "loc", "ln", "ptr", "ld", "syn", "n", "bytes", "wid", "pl", "offset", "lim", "lon", "Len", "l", "fin", "lic", "fun", "limit", "nl", "lan", "no", "iter", "nt", "pos", "t", "size", "lis", "en", "li", "vec", "resp", "late", "el", "ll", "all", "mem", "h", "lp", "addr", "mid", "lang", "elt", "Length", "le", "val"], "data": ["command", "m", " payload", "list", "dat", "p", "name", "length", "bin", "d", "padding", "def", "mu", " buffer", "value", "n", " Data", "bytes", "offset", "partial", " DATA", "text", "empty", "nt", "pointer", "extra", "t", "format", "size", "res", "message", "buffer", "device", "buf", "next", "window", "a", "DATA", " dat", "str", "ata", "batch", "addr", "connection", "ad", "rel", "block", "Data", "table", "response"], "i2c_bus": ["i2c__bus", "i2c67bus", "i2gc___queue", "i2gc_bus", "i2c_box", "i2C_config", "i2e_boot", "i2c_config", "i2cm_board", "i2c_base", "i2c2box", "i2c___queue", "i2cpyboard", "i2c___client", "i2C_ack", "i2C_base", "i2c__base", "i2sc_bus", "i2c_cos", "i2con_bus", "i2c_board", "i2cmyhub", "i2cm_bar", "i2c67Bus", "i2gc___bus", "i2e_cos", "i2cpybar", "i2e_box", "i2c4bus", "i2c___config", "i2C_bus", "i2c__ack", "i2c_Bus", "i2c2boot", "i2c4client", "i2sc_boot", "i2sc_device", "i2c_bar", "i2c_device", "i2C_hub", "i2c2bus", "i2c_home", "i2cpybus", "i2C_home", "i2cmybus", "i2c_client", "i2C_client", "i2sc_box", "i2c___bus", "i2C_boot", "i2c67ack", "i2cpyboot", "i2cm_bus", "i2c_boot", "i2gc___config", "i2gc_client", "i2c4config", "i2C_Bus", "i2gc___client", "i2e_bus", "i2cmyBus", "i2cm_boot", "i2c__Bus", "i2c_controller", "i2c_ack", "i2con_boot", "i2con_controller", "i2con_box", "i2gc_queue", "i2c_queue", "i2c4boot", "i2gc_config", "i2c67base", "i2cmyhome", "i2c_hub", "i2c2controller"], "i": ["m", "me", "ci", "ix", "p", "sp", "type", " bi", "si", "zi", "multi", "n", "abi", "y", "it", "xi", "l", "init", "mi", "b", "qi", "s", "c", "info", "iu", "j", "di", "in", "point", "ai", "t", "uri", "ui", "phi", "gi", "li", "key", "ip", "sim", "cli", "is", "a", "out", "bi", "e", "ind", "index", "ii", "x", "pi", "I", "f", "ki", "v"]}}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,\n\n                                       const int16_t **lumSrc, int lumFilterSize,\n\n                                       const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                                       const int16_t **chrVSrc,\n\n                                       int chrFilterSize, const int16_t **alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    if (uDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 22361, "substitutes": {"c": ["ctx", "cp", "gc", "m", "this", "ci", "p", "ca", "v", "conf", "w", "d", "ctrl", "tc", "n", "cm", "nc", "cc", "C", "self", "co", "chain", "b", "s", "cs", "fc", "lc", "config", "ec", "t", "ce", "u", "dc", "cv", "con", "cam", "a", "e", "h", "cf", "f", "cont", "rc", "ct"], "lumFilter": ["limfilter", "limFilter", "lulSort", "lumaSort", "Limfilter", "lumfilter", "limSort", "lulfilter", "LimSort", "LimFil", "lumaFilter", "LumSort", "lulFil", "limFil", "lumaFil", "lulFilter", "lumSort", "lumafilter", "Lumfilter", "LumFil", "LimFilter", "LumFilter", "lumFil"], "lumSrc": ["lumSources", "lutSvc", "lutVSvc", "lutVSrc", "lumVsvc", "lutSources", "lumSvc", "lutSrc", "lumVSources", "lumVSrc", "lumVSvc", "lumVsRC", "lumVsources", "lutVSRC", "lumSRC", "lumVSRC", "lumVsrc", "lutSRC", "lutVSources"], "lumFilterSize": ["lamFilterSIZE", "lumStreamSIZE", "lumBlockLength", "lumBlockSIZE", "lamFilterSize", "lumBlockSize", "lumMaskStyle", "lumMaskSIZE", "lumStreamStyle", "lamFilterStyle", "lumFilterStyle", "lumFilterLength", "lumStreamSize", "lumBlockStyle", "lumStreamLength", "lamBlockLength", "lamFilterLength", "lumMaskSize", "lamBlockSIZE", "lamBlockSize", "lamBlockStyle", "lumMaskLength", "lumFilterSIZE"], "chrFilter": ["ChrSpec", "chrtSpec", "chrFil", "CharSpec", "charFilter", "chrtFil", "CharChannel", "ChrFil", "charFil", "CharFil", "chroFil", "charSpec", "ChrFilter", "chroSpec", "chrtChannel", "chroFilter", "chroChannel", "chrChannel", "CharFilter", "chrtFilter", "charChannel", "ChrChannel", "chrSpec"], "chrUSrc": ["chrUSr", "chrUSfx", "chrSRC", "charUSfx", "charSRC", "chrUSRC", "chrRSRC", "charSr", "chrSSr", "chrRSr", "charUSrc", "chrSr", "chrRSfx", "chrSSrc", "chrSSfx", "chrSSRC", "chrSrc", "charUSr", "chrSfx", "chrRSrc", "charSfx", "charSrc", "charUSRC"], "chrVSrc": ["chrMSock", "chrVSsrc", "chrFSRC", "chrMSrc", "charVsock", "charVsRC", "charVSsrc", "chrVSock", "charVSrc", "charVsrc", "charVssrc", "chrMSsrc", "chrVsrc", "chrFSock", "chrVSRC", "charVSock", "chrMSRC", "chrFSsrc", "chrFSrc", "chrVsRC", "chrVssrc", "chrVsock", "charVSRC"], "chrFilterSize": ["chrMaskSize", "chrsMaskMode", "chrSortSize", "chrsMaskSize", "chrSortStyle", "chrfilterSIZE", "chrsFilterSize", "chrMaskStyle", "chrfilterMode", "chrfilterSize", "chrsFilterSIZE", "chrSortSIZE", "chrfilterStyle", "chrsMaskStyle", "chrSortMode", "chrFilterMode", "chrFilterStyle", "chrMaskMode", "chrMaskSIZE", "chrsFilterStyle", "chrFilterSIZE", "chrsMaskSIZE", "chrsFilterMode"], "alpSrc": ["alpRsrc", "alpRsRC", "alpsSr", "alpPsr", "alpsSvc", "alpsSrc", "alpPsrc", "alpsRsRC", "alpSRC", "alpsRsr", "alpsRsrc", "alpRsr", "alpSr", "alpsSRC", "alpRsvc", "alpPsRC", "alpPsvc", "alpsRsvc", "alpSvc"], "dest": ["temp", "rest", "spec", "end", "data", "transform", "id", "loc", "Dest", "path", "port", "w", "d", "master", "trans", "wb", "src", "orig", "dist", "win", "iter", "origin", "cas", "shape", "est", "gate", "target", "ident", "desc", "source", "mem", "comb", "usr", "way", "pas", "st", "table", "v"], "uDest": ["uDist", "aAdd", "vTarget", "uTarget", "uSync", "uDesc", "uuSync", "aQueue", "nuSync", "usDesc", "uAdd", "ucNow", "ucDest", "vDist", "UDest", "uNow", "uuTarget", "vLoc", "usAdd", "uuDest", "nuNow", "usDest", "nuDesc", "uuQueue", "uuDesc", "uuLoc", "ucDesc", "ULoc", "uuAdd", "aDesc", "uuDist", "ucSync", "uQueue", "UDist", "uuNow", "usQueue", "nuDest", "UTarget", "uLoc"], "vDest": ["vdest", "bDest", "bDesc", "gDesc", "evDecl", "gDest", "vDecl", "cvDesc", "vNeg", "VNeg", "bEast", "evDest", "evRest", "bdest", " vNeg", "VRest", "evNeg", "VDecl", "vEast", "VDest", "vDesc", "cvDest", "vRest", " vRest", "cvEast", "gdest", " vDecl", "gEast", "cvdest"], "aDest": ["anTrans", "vdest", " aDesc", "nDesc", "aaTarget", "ADoc", "nTarget", "anDoc", "aQueue", "anDest", "ARest", "aRest", "aWorld", "aaDesc", "aaDest", "AQueue", "Adest", " aDoc", "ATrans", "AWorld", "aTarget", "ADest", "adest", " aTarget", "vWorld", " aWorld", " adest", "anQueue", "aDesc", "vRest", "nDest", " aTrans", "aTrans", "aDoc", " aRest", " aQueue"], "dstW": ["dsrcWin", " destWidth", "DsrcV", "dstWe", "destV", "udstV", " destBW", "dstWin", "dsrcWI", "destBW", "DstWin", "udstWe", "deltaV", "DsrcW", "dstH", "dputW", "udrendH", "drendW", "dputBW", "udrendW", "dpiWin", "drendH", "udstH", "drestH", " dstBW", "udstW", "dSTV", " dstWidth", " destW", "DstW", "DstWI", "deltaWin", "dsrcV", " dstV", "dstWidth", "dpiV", "dputV", "dputWidth", "dpiW", "destW", "dsrcW", "drendV", "destWidth", "drestWe", "dSTW", "DsrcWI", "dstBW", "DstV", "drestW", "destWe", "dstV", "drestV", "dpiWI", "DsrcWin", "udrendWe", "udrendV", "deltaWI", "deltaW", "dstWI", "drendWe", "dSTBW", "destH", " destV", "dSTWidth"], "chrDstW": ["chrDrcB", "chrDstrN", "chrLstS", "chrDstM", "chrDndS", "chrLSTH", "chrLSTW", "chrLSTC", "chrDSTN", "chrdstB", "chrDrcS", "chrdSTN", "chrDSTBW", "chrDSTC", "chrDrcM", "chrLSTBW", "chrDstrW", "chrLstN", "chrdSTM", "chrDstrH", "chrDrcH", "chrdSTB", "chrLstBW", "chrdstW", "chrDstrR", "chrLstW", "chrDestN", "chrLSTN", "chrLSTR", "chrDstS", "chrDndC", "chrLSTS", "chrdSTW", "chrDSTW", "chrDndW", "chrDSTH", "chrDrcBW", "chrLstH", "chrDrcW", "chrDrcC", "chrDestM", "chrDSTB", "chrDstBW", "chrdstM", "chrLstR", "chrLstC", "chrDstC", "chrDndBW", "chrDestB", "chrDSTS", "chrDrcR", "chrDSTM", "chrDstH", "chrDrcN", "chrDstB", "chrDstR", "chrDestW", "chrDstN", "chrdstN", "chrDSTR"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationInfo *qmp_query_migrate(Error **errp)\n\n{\n\n    MigrationInfo *info = g_malloc0(sizeof(*info));\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    switch (s->state) {\n\n    case MIG_STATE_NONE:\n\n        /* no migration has happened ever */\n\n        break;\n\n    case MIG_STATE_SETUP:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"setup\");\n\n        info->has_total_time = false;\n\n        break;\n\n    case MIG_STATE_ACTIVE:\n\n    case MIG_STATE_CANCELLING:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"active\");\n\n        info->has_total_time = true;\n\n        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)\n\n            - s->total_time;\n\n        info->has_expected_downtime = true;\n\n        info->expected_downtime = s->expected_downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = ram_bytes_remaining();\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->dirty_pages_rate = s->dirty_pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 22364, "substitutes": {"errp": [" erP", " erps", "errpid", " errpid", "erP", "errps", " erpid", " erp", "erpid", "errP", "erps", " errps", " errP", "erp"], "info": ["check", "json", " Info", "name", "type", "conf", "by", "user", "on", "test", "good", "address", "ip", "summary", "op", "pi", "io", "f", "table", "trace", "help", "command", "list", "try", "inner", "data", "one", "parse", "request", "cache", "it", "content", "doc", "admin", "jo", "config", "warning", "iter", "about", "detail", "error", "comment", "import", "local", "edit", "is", "INFO", "fo", "meta", "num", "success", "report", "state", "image", "debug", "notice", "information", "to", "py", "init", "status", "history", "item", "app", "version", "ui", "note", "obj", "row", "http", "time", "option", "exec", "always", "description", "start", "api", "alias", "entry", "id", "details", "pretty", "Info", "def", "ion", "value", "ti", "inf", "query", "i", "utils", "t", "auth", "update", "ref", "link", "job", "event", "now", "off", "interface", "index", "ready", "response"], "s": ["south", "rs", "bs", "params", "ims", "sym", "stats", "set", "series", "ies", "store", "its", "a", "os", "f", "ls", "z", "times", "vs", "ps", "sis", "ds", "b", "ts", "args", "less", "sing", "sf", "is", "v", "js", "dev", "gs", "m", "sets", "sl", "state", "bits", "ges", "parts", "sm", "ms", "ses", "ss", "aws", "g", "hs", "obj", "sts", "sys", "sports", "comm", "spec", "sq", "p", "details", "su", "w", "sb", "n", "y", "c", "single", "as", "sw", "i", "t", "ns", "changes", "sv", "xs", "h", "S", "ops", "response"]}}
{"project": "qemu", "commit_id": "b0ad5a455d7e5352d4c86ba945112011dbeadfb8", "target": 1, "func": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22365, "substitutes": {"bs": ["js", "gs", "ls", "bb", "irms", "aks", "rs", "bits", "bc", "cms", "blog", "bes", "sb", "vs", "bp", "ps", "bis", "fs", "acs", "ds", "b", "ms", "s", "cs", "ts", "ses", "ss", "ubis", "aus", "bles", "aos", "bh", "BS", "ubs", "ns", "cks", "pb", "ks", "its", "bps", "sts", "qs", "sys", "bos", "ats", "lbs", "als", "uts", "bas"], "bitnum": ["bitum", "intNum", " bitum", "boolum", "Bitmult", " bitNum", "intNUM", "boolno", "blockum", "Bitum", "bitenum", "bitno", "blocknum", "intum", "blockNum", " bitmult", "blockNUM", "bitnm", "boolnm", "blockenum", "intnum", " bitno", "BitNUM", "blockno", " bitNUM", " bitenum", "bitNum", " bitnm", "intenum", "bitmult", "blocknm", "bitNUM", "Bitnum", "boolnum", "intmult"], "bitmap": ["binap", "Bitset", "BITmaster", "wordopen", "bitap", "bitcache", "layrix", "bitrix", "wordap", " bitwise", "barcache", " bitset", "BITmaps", "bitsmap", "Bitmap", " bitcode", "bitlay", "shotwise", "gitap", "Bitmaps", "bitsmaster", "bandlay", "BITMap", "Bitmask", "bitscache", "bitcode", "beatmask", "BITmask", "byteset", "wordmap", "binmask", "bitmask", "gitmap", "barmap", "bytemap", "barcode", "laymap", " bitmaps", "beatdate", " bitmatch", "BITmap", "worddate", "latrix", "taskmap", "taskrix", "binmap", "bandmap", "beatap", "binlay", "taskmatch", " bitcache", "bitsmask", "bitmatch", "bitmaps", "beatopen", " bitrix", "bitwise", "bitopen", "gitopen", " bitmask", "BITcode", "byteMap", "latMap", "shotMap", " bitmaster", "beatlay", "bandap", "beatmap", "barmaps", "bandmask", "bitdate", "bitMap", "shotmap", "laymatch", "latmap", "gitdate", "bitmaster", "BitMap", "shotrix", "latwise", " bitMap", "bytemaps", "bitset", "BITcache", "Bitcode"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22369, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int voc_probe(AVProbeData *p)\n\n{\n\n    int version, check;\n\n\n\n    if (p->buf_size < 26)\n\n        return 0;\n\n    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))\n\n        return 0;\n\n    version = p->buf[22] | (p->buf[23] << 8);\n\n    check = p->buf[24] | (p->buf[25] << 8);\n\n    if (~version + 0x1234 != check)\n\n        return 10;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 22379, "substitutes": {"p": ["cp", "pkg", "post", "m", "tp", "q", "np", "pp", "o", "sp", "at", "power", "jp", "parse", "pm", "w", "d", "up", "bp", "pd", "cache", "ps", "y", "it", "l", "P", "b", "rep", "er", "wp", "c", "proc", "r", "vp", "pat", "j", "app", "pt", "t", "g", "pro", "pc", "pa", "dp", "pb", "ap", "ping", "buf", "pod", "php", "a", "pre", "op", "lp", "pi", "fp", "ad", "progress", "f", "pg", "v"], "version": ["action", "VERSION", "command", "serial", "data", "iso", "transform", "name", "type", "length", "power", "debug", "ver", "tag", "ion", "scale", "value", "release", "test", "status", "versions", "info", "feature", "lock", "order", "server", "vision", "size", "bolt", "format", "update", "patch", "Version", "mint", "hash", "number", "code", "time", "package", "view", "index", "major", "connection", "option", "x", "v"], "check": ["q", "add", "start", "control", "id", "ver", "value", "force", "test", "status", "bit", "max", "CHECK", "info", "core", "c", "fail", "score", "checked", "ok", "query", "find", "cmd", "search", "print", "match", "update", "key", "ck", "Check", "look", "rank", "read", "comment", "out", "code", "checks", "handle", "equal", "view", "op", "call", "valid", "cmp", "block", "help"]}}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 22381, "substitutes": {"f": ["ac", "lf", "fo", "af", "m", "ff", "uf", "q", "p", "o", "file", "full", "z", "fw", "conf", "w", "d", "um", "far", "fr", "ile", "y", "fd", "it", "fs", "l", "b", "fal", "c", "fc", "fn", "r", "j", "i", "t", "fac", "ft", "g", "fi", "rf", "xf", "window", "e", "F", "bf", "form", "sf", "h", "cf", "tf", "fb", "fp", "fm", "v", "fx"], "opaque": ["compaque", "Opent", "Opaque", "opent", "Oplay", "compent", "compbuffer", "opbuffer", "oplay", "popent", "popbuffer", "Opbuffer", "popaque", "complay", "poplay"], "version_id": ["record_ide", "program_t", "version_info", "versionationis", "version_Id", "dimensionTypeis", "versionalname", "program_bit", "versionalbit", "dimension_id", "versionalid", "version__info", "versionTypei", "programalbit", "dimensionTypeuid", "versionationname", "programalt", "versionTypeis", "versionalt", "version_ide", "program_name", "recordationid", "ver_id", "version_i", "program_id", "version__Id", "versionationid", "programalname", "version_ID", "ver_no", "versionationide", "dimension_is", "record_name", "versionationno", "ver_info", "dimensionTypeid", "version_bit", "ver_t", "recordationrid", "versionTypeid", "record_id", "version_t", "versionationrid", "versionationi", "version_uid", "ver_ID", "dimensionTypei", "ver_Id", "version_name", "versionTypeuid", "recordationide", "recordationname", "record_rid", "programalid", "version__ID", "dimension_uid", "versionationId", "versionationuid", "version_no", "version__id", "dimension_i", "versionationt", "version_is", "version_rid"], "addr": ["end", "np", "adr", "rs", "at", "points", "arch", "aff", "ret", "attr", "mac", "address", "dr", "order", "ip", "work", "a", "ress", "x", "hw", "ad", "ac", "gc", "arp", "ash", "inter", "nl", "pos", "map", "align", "mb", "hash", "ach", "ack", "rc", "add", "Address", "pad", "loc", "port", "ptr", "url", "offset", "init", "max", "r", "ord", "act", "lat", "obj", "hl", "mask", "alloc", "elt", "oad", "ix", "p", "start", "alias", "src", "access", "tx", "cmd", "i", "build", "size", "ref", "ident", "off", "eth", "mem", "mt"], "flags": ["alf", "acts", "sets", "comments", "ints", "FLAG", "bits", "posts", "details", "rs", "type", "conf", "times", "tags", "lag", "ants", "ptr", "links", "parts", "weights", "fr", "states", "types", "fd", "fs", "bugs", "limits", "cs", "nl", "grades", "ts", "flag", "cmd", "allows", "stats", "lines", "args", "olds", "uses", "orts", "goal", "members", "cons", "actions", "ags", "wcs", "checks", "options", "features", "ports", " Flags", "planes", "levels", "aps", "ats", "cf", "properties", "mask", "vals", "fp", "fields", "heads", "Flags", "locks"], "id": ["pid", "end", "p", "start", "data", "name", "bid", "ide", "type", "ids", "tag", "it", "fd", "init", "bit", "info", "line", "address", "Id", "tx", "iter", "kid", "i", "in", "map", "od", "key", "ip", "ident", "ref", "link", "hash", "md", "head", "a", "code", "sid", "ID", "aid", "mem", "index", "str", "h", "oid", "rid", "uid", "mid", "mask", "ad", "iden"], "length": ["command", "volume", "height", "rest", "description", "pad", "end", "family", "data", "sp", "name", "type", "SIZE", "ength", "loc", "path", "distance", "padding", "ptr", "duration", "value", "offset", "test", "L", "l", "capacity", "chain", "max", "limit", "history", "line", "root", "join", "ENGTH", "location", "shape", "loop", "size", "buffer", "position", "total", "count", "next", "head", "number", "operation", "last", "base", "piece", "time", "h", "index", "title", "display", "str", "sequence", "Length", "term"], "block": ["list", "BL", "pack", "data", "name", "type", "bc", "box", "image", "bin", "word", "unit", "field", "range", "blocks", "cl", "bit", "chain", "b", "prefix", "info", "line", "lock", "join", "header", "in", "map", "k", "bl", "set", "frame", "buffer", "key", "link", "hash", "snap", "group", "out", "obj", "row", "byte", "base", "record", "Block", "piece", "x", "blocking", "part", "model", "object", "container", "label"], "len": ["lf", "num", "sl", "ls", "seq", "fl", "L", "loc", "ln", "ld", "wid", "pl", "lim", "lon", "l", "Len", "fin", "tl", "nl", "lock", "lc", "lan", "no", "iter", "nt", "pos", "size", "bl", "en", "col", "li", "lt", "ref", "il", "count", "slice", "buf", "el", "ll", "hl", "mem", "lp", "wl", "lang", "elt", "coll", "label", "kl", "val"], "host": ["ha", "dev", "cert", "here", "slot", "path", "ghost", "console", "arch", "proxy", "master", "domain", "Host", "conn", "browser", "self", "ost", "hd", "chain", "sh", "hand", "root", "address", "boot", "wrapper", "iter", "node", "dr", "server", "home", "vr", "target", "ip", "client", "hash", "head", "handle", "null", "http", "context", "mem", "local", "h", "hard", "localhost", "index", "hw", "object", "container", "th", "pool", "hub", "hook", "bind"], "ch": ["cp", "wh", "high", "kh", "height", "och", "zh", "z", "bits", "Ch", "cha", "ih", "w", "arch", "br", "ph", "sc", "y", "cht", "ich", "ech", "cl", "ht", "chip", "sh", "c", "cs", "chan", "cmd", "i", "cho", "col", "cd", "sch", "CH", "ssh", "hash", "channel", "ach", "resh", "h", "x", "tch", "th", "v", "ct"]}}
{"project": "qemu", "commit_id": "111049a4ecefc9cf1ac75c773f4c5c165f27fe63", "target": 1, "func": "static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n", "idx": 22387, "substitutes": {"common": ["ctx", "current", "command", "m", "check", "basic", "public", "inner", "parent", "un", "name", "one", "conf", "specific", "low", "uch", "to", "util", "global", "san", "ordinary", "primary", "java", "com", "standard", "an", "core", "admin", "no", "processor", "some", "cmd", "onet", "unknown", "known", "normal", "shared", "server", "bolt", "set", "pro", "from", "non", "initial", "clean", "qualified", "cli", "summary", "other", "con", "general", "base", "local", "runner", " Common", "given", "new", "Common", "plain", "present", "comm"], "errp": ["errd", "errorP", "Erping", "riskpress", "erping", " errP", "rrps", "died", "dieps", "erP", "diepa", " errd", "errpress", "diep", "errorp", "errorpress", "rrpa", "errping", "errps", " errping", " errpress", "errper", "riskP", "rrp", "erp", "ErP", "rrd", " errper", "riskp", "errorper", "riskper", "errpa", "errP", " errpa", " errps", "Erp"], "state": ["action", "command", "this", "check", "list", "spec", "public", "start", "State", "body", "name", "type", "power", "port", "ace", "tag", "that", "unit", "states", "test", "component", "init", "status", "self", "result", "we", "style", "info", "task", "scope", "config", "STATE", "stats", "print", "version", " states", "set", "area", "message", "update", "where", "position", "see", "count", "store", "process", "out", "event", "instance", "job", "estate", "session", "all", "base", "change", "local", "rule", "policy", "monitor", "form", "resource", "runner", "private", "st", "index", "connection", "stat", "operator", "is", "trace", "un"], "bs": ["ctx", "js", "gs", "bed", "ls", "bb", "us", "rs", "bits", "las", "bc", "bes", "blog", "sb", "vs", "gb", "outs", "bp", "ps", "bis", "ab", "fs", "ds", "has", "b", "cs", "bm", "ts", "serv", "was", "aos", "bh", "ubs", "BS", "bg", "ns", "cks", "lb", "pb", "its", "bal", "socket", "bu", "bps", "obs", "bi", "sts", "sys", "bos", "os", "lbs", "vals", "bas", "is", "cb", "bo"], "backup": ["Backupid", "backp", "cleanout", " backshot", "Backone", "pickout", "backshot", "buckcp", "backout", "saveupid", "drout", "lookup", "Backout", "lookdown", "checkout", "Backap", "Backcp", "buckup", "buckp", "backcp", "saveup", "Backp", "drup", " backcp", "drone", "cleanone", "backupid", "backap", "checkdown", "cleanupid", "lookupid", "pickupid", "backdown", "checkup", "lookap", " backp", "cleanup", "backone", "Backshot", "lookout", "saveap", "pickup", "checkupid", "drupid", "Backup", "pickdown", "buckshot"], "local_err": ["local_iter", "local____err", "local_arr", "local____msg", "local____attr", "personal_error", "client_iter", "local_er", "local_buf", "local_msg", "local_r", "client____msg", "client____attr", "client____err", "client_msg", "personal_err", "personal_arr", "global_err", "local_attr", "global_msg", " local_er", "global_r", "local_error", "client____iter", "client_attr", "local_dr", "global_er", "client_err", " local_dr", "personal_er", "local____iter", " local_buf"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n", "idx": 22389, "substitutes": {"ctx": ["cp", "cfg", "gc", "ac", "pkg", "vc", "ca", "mk", "bc", "req", "kt", "jp", "ctrl", "tmp", "xc", "tc", "conn", "nc", "mc", "cc", "cm", "Context", "etc", "c", "kw", "tx", "tk", "cmd", "nt", "act", "txt", "ck", "dc", "cur", "obj", "ctr", "context", "xs", "sys", "cf", "rc", "hw", "wx", "cmp", " cx", "cb", "cv", "ct"]}}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n", "idx": 22392, "substitutes": {}}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n    ppc_slb_t *slb;\n\n    target_ulong pageaddr;\n\n    int segment_bits;\n\n\n\n    LOG_MMU(\"Check SLBs\\n\");\n\n    slb = slb_lookup(env, eaddr);\n\n    if (!slb) {\n\n        return -5;\n\n    }\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        segment_bits = 40;\n\n    } else {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        segment_bits = 28;\n\n    }\n\n\n\n    target_page_bits = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                  : (slb->vsid & SLB_VSID_KS));\n\n    ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n    pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n    } else {\n\n        hash = vsid ^ (pageaddr >> target_page_bits);\n\n    }\n\n    /* Only 5 bits of the page index are used in the AVPN */\n\n    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22399, "substitutes": {"env": ["dev", "vt", "viron", "exc", "te", "ev", "here", "shell", "conf", "pe", "ptr", "eng", "conn", "environment", "er", "proc", "doc", "config", "eh", "ec", "org", "cmd", "server", "net", "map", "set", "en", "ew", "et", "disk", "setup", "cv", "window", "code", "estate", "e", "context", "param", "rc", "hw", "Environment", "erd", "v"], "ctx": ["cp", "pkg", "kh", "inst", "np", "mk", "req", "conf", "loc", "kt", "jp", "ctrl", "tmp", "xc", "tc", "that", "iat", "cache", "conn", "sc", "Context", "cc", "co", "etc", "ork", "acl", "aux", "kw", "tk", "tx", "ctl", "cmd", "nt", "act", "cas", "func", "timeout", "jac", "unc", "msg", "ck", "dc", "std", "window", "obj", "cu", "context", "mem", "conv", "crit", "index", "x", "cf", "tz", "exec", "hw", " context", "alloc", "wx", "cmp", " cx", "cb", "cv", "ct"], "eaddr": ["decptr", "ddptr", "eadDR", "reamr", "adDR", "eddDR", "adder", "ewder", "ankder", "awdr", "ewDR", "ddpr", "eadptr", "ankdr", "earDR", "eadr", "eddptr", "reamhr", "oadptr", "eadder", "eadrd", "decrd", "ewayDr", "preadpr", "reamdr", "ellr", "oadhr", "eadpr", "earDr", "ewayDR", "ewstr", "preaddr", "dddr", "decpr", "ankDR", "eddr", "eadhr", "awDR", "ewaydr", "edddr", "eardr", "awDr", "preadptr", "adstr", "edDR", "oadr", "ewaysr", "preadrd", "ewdr", "awsr", "eadDr", "eadsr", "edr", "ankstr", "oaddr", "eadstr", "addr", "oadDR", "earsr", "decdr", "ellhr", "edptr", "elldr", "ddrd"], "rw": ["write", "rs", "req", "w", "rew", "src", " wr", "rn", "aw", "wire", "rt", " resp", "ry", "wr", "shr", " sr", "ew", "asm", " shr", "resp", "window", "ctr", "rl", "usr", "rd", "hw", "rc"], "type": ["ty", "tp", "p", "state", "name", "pe", "ver", "ptr", "tag", "typ", "Type", "types", "test", "style", "ype", "rt", "ry", "kind", "r", "t", "error", "TYPE", "buffer", "count", "time", "rule", "weight", "rel"], "hash": ["kh", "check", "height", "data", "inv", "hz", "id", "tr", "oh", "hat", "ash", "tag", "ah", "shift", "test", "has", "result", "rh", "sh", "html", "flash", "shr", "sum", "print", " h", "esh", "match", "key", "ssh", "Hash", "ref", "sha", "ch", "h", "str", "filter", "addr", "err", "array", "ashes"], "vsid": ["csID", "fsid", "vsname", "portsidem", "vsID", "gsident", "gside", "vsz", "jsider", "VSz", "nsid", "ksID", "postsID", "vsids", "vsigil", "lsolid", "jsid", "fsID", "postsId", "ksid", "kside", " vsoid", "VSID", "obsigil", "csz", "VSname", "vsident", "portsid", "valuesiter", "termsoid", "fsId", "lsidem", "lsident", "lsID", "VShid", "Vsid", "ksname", "vesidem", "lsid", "imsider", "hsidem", "hsiden", "VSigil", "valsidem", "portsiden", "hsId", " vsidem", " vside", "obsiden", "csident", "imsid", "VSidem", "psoid", "ksidem", "Vsidem", "uesiden", "valsoid", "rshid", "rsID", "uesid", "lsider", "vsolid", "psid", "valsid", "valsident", "changesoid", "csids", "psider", "vsidem", "vsoid", "portsID", "termsid", "csidem", "rsidem", "ksident", "vesname", "psolid", "vs_", "VSiden", "valsolid", "postsid", "gsid", "vside", "obshid", "imsID", "vsiden", "hsider", "obsid", "hsID", "v_", "Vsoid", "termsID", " vsids", "vshid", "valuesoid", "obsident", "VSident", "changesidem", "uesident", "valuesid", "postsidem", "vesid", "VSid", "gsID", "vsId", "hsident", "jsidem", "nsID", "hsid", "nsId", "valsId", " vsz", "valsID", "lsoid", " vsiter", "valuesidem", "psiden", "Vsiter", "jsID", "rsid", "portshid", "uesider", "termsidem", "fsidem", "portsident", "changesid", "vsider", "imsidem", "vsiter", "csid", "VSids", "changesID", "cside", "vesident", "VS_", "nsidem", "VSide", "imshid", "ls_", "vesID", "obsID", "hsigil", "VSId", "psident"], "pr": ["rer", "hr", "cr", "rot", "kr", "mr", "rs", "Pr", "tr", "ptr", "PR", "br", "fr", "typ", "ps", "pl", "rem", "ocr", "expr", "rep", "lr", "r", "serv", "rate", "po", "dr", "pt", "shr", "print", "wr", "spr", "prime", "res", "pro", "repl", "pc", "vr", "pol", "rev", "pri", "val", "prov", "por", "rr", "err", "rel", "pir"], "target_page_bits": ["target_page32bytes", "target_page_parts", "target_line_bytes", "target_page_keys", "target_page_bit", "target_page_words", "target_page32pieces", "target_age_bits", "target_node_its", "target_line_its", "target_node_bits", "target_node_details", "target_pagelykeys", "target_page32bits", "target_pagelyslot", "target_page__its", "target_line_bit", "target_node_points", "target_page_details", "target_page_slot", "target_age_keys", "target_page__bits", "target_page_bytes", "target_line_words", "target_page_points", "target_line_parts", "target_page_its", "target_page_pieces", "target_page__bytes", "target_page__words", "target_pagelybits", "target_age_slot", "target_line_bits"], "ret": ["reset", "alt", "Ret", "def", "pert", "rem", "rt", "lit", "nt", "flag", "net", "ft", "res", "ref", "rev", "re", "resp", "len", "ll", "mem", "nz", "elt", "RET", "rel", "mt", "val"], "ret2": ["Retpl", "RETpl", "RET0", "Ret2", "RET2", "ret0", "RET1", " retpl", "retpl", "ret1", " ret0", "Ret1", " ret1", "Ret0"], "slb": ["ssln", "slv", "islB", "evalB", "helv", "evalsb", "svB", "helb", "svob", "mlb", "spotsb", " slt", "spln", "sslh", "spll", " slB", "lsib", "tlb", "hlbr", "tln", "hlb", "islt", "lsh", " slh", "SLib", "sslbb", "slt", "sslt", "islob", "islb", " slv", "rlb", "evalb", "islbb", "splbr", "slob", "splib", "hlsb", "mlgb", "lB", " slib", "sslib", "mlbb", "lsB", "sslb", "spotB", "lp", "slc", "mlbe", "rlsb", "plb", "lssb", "slbd", "snbb", "mlib", "plB", "SLv", "rlbd", "splb", "splob", "sslv", "lsbb", "SLB", "slbb", "splbe", "plgb", "SLp", "slbe", "tlib", "evalbr", "svb", "splsb", "SLsb", "slib", "svl", "snb", "slB", " slc", "lsb", "slbr", "mlB", "snsb", "helbd", "helsb", "sln", "sslB", "SLbd", " slbb", "splgb", "spotb", "SLbe", " slp", "tlB", "slgb", "islv", "hlB", "splc", "splB", "snB", "plc", "lb", "rlv", "isll", "SLb", "slp", "slh", "islsb", "mlsb", "sll", "slsb", " slgb", "sslgb", "spotbb"], "pageaddr": ["memoryast", "pageord", "memoryadr", "ageoffset", " pageaddress", "memoryaddr", "portaddr", " pageord", "ageaddr", "rowoffset", "portadr", " pagemap", "serveraddr", "serveradd", " pageAddress", "rowptr", "pagestore", "pageadr", "nextstore", "nodeaddr", " pageadr", "ageptr", "phraseaddress", "memoryadd", "serveradr", "phrasemap", "pageAddress", "pagemap", "rowadd", "portord", "nextaddress", "phraseaddr", "nodeord", "agemap", "pageptr", " pageptr", " pageoffset", "nodeadr", "nextAddress", "pageast", "pageadd", "agestore", "pageaddress", "rowaddr", "ageAddress", "nextaddr", "serverast", " pagestore", "rowast", "pageoffset", "phraseptr", "rowadr", "ageaddress"], "segment_bits": ["segment32its", "segments_bits", "segment36bit", "segment16mask", "segment36bits", "segment_bit", "segment36its", "segment36points", "segment2bits", "segment_its", "selement_its", "selement_bits", "segment16its", "segment8bits", "segment_flags", "segment8jobs", "segment8its", "segment36bytes", "segment32bytes", "segments_bit", "segments_points", "sement_its", "selement16bytes", "sement_flags", "segments_jobs", "segment32mask", "segment16bytes", "sement2its", "segments_bytes", "sement_bytes", "segments_its", "sement2bytes", "segment_bytes", "selement16mask", "sement2bits", "selement16bits", "segment_mask", "selement_bytes", "segment2bytes", "segment32bits", "selement16its", "segment2its", "segment8bytes", "selement_mask", "segment36flags", "segment_points", "sement_bits", "segment_jobs", "segment2flags", "segment16bits"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int v9fs_receivefd(int sockfd, int *status)\n\n{\n\n    struct iovec iov;\n\n    struct msghdr msg;\n\n    struct cmsghdr *cmsg;\n\n    int retval, data, fd;\n\n    union MsgControl msg_control;\n\n\n\n    iov.iov_base = &data;\n\n    iov.iov_len = sizeof(data);\n\n\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = &msg_control;\n\n    msg.msg_controllen = sizeof(msg_control);\n\n\n\n    do {\n\n        retval = recvmsg(sockfd, &msg, 0);\n\n    } while (retval < 0 && errno == EINTR);\n\n    if (retval <= 0) {\n\n        return retval;\n\n    }\n\n    /*\n\n     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this\n\n     * request doesn't need ancillary data (fd) or an error occurred,\n\n     * data is set to negative errno value.\n\n     */\n\n    if (data != V9FS_FD_VALID) {\n\n        *status = data;\n\n        return 0;\n\n    }\n\n    /*\n\n     * File descriptor (fd) is sent in the ancillary data. Check if we\n\n     * indeed received it. One of the reasons to fail to receive it is if\n\n     * we exceeded the maximum number of file descriptors!\n\n     */\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n\n            cmsg->cmsg_level != SOL_SOCKET ||\n\n            cmsg->cmsg_type != SCM_RIGHTS) {\n\n            continue;\n\n        }\n\n        fd = *((int *)CMSG_DATA(cmsg));\n\n        *status = fd;\n\n        return 0;\n\n    }\n\n    *status = -ENFILE;  /* Ancillary data sent but not received */\n\n    return 0;\n\n}\n", "idx": 22413, "substitutes": {"sockfd": [" sockFD", "sockedFD", "sockdir", "sOCKfd", " sockfp", "srcfp", " sockedfp", "sinkfp", "sinkfd", " sockedFD", "sackfd", "sOCKFD", "insockld", "sockedld", "srcld", "insockedfd", "sockeddir", "insockfd", "srcfd", "sockfp", "srcFD", "insockfp", "insockedfp", "sockedfp", "sinkFD", "insockFD", "insockedFD", " sockeddir", " sockdir", "sockFD", " sockedfd", "sOCKfp", "sackFD", "sOCKld", "sackfp", "sockld", "insockedld", "sackdir", "sinkdir", "sockedfd"], "status": ["temp", "action", "check", "spec", "list", "comments", "description", "atus", "state", "id", "reason", "type", "details", "params", "flags", "console", "tree", "security", "service", "sc", "Status", "result", "prefix", "ser", "mode", "settings", "sync", "config", "speed", "date", "flag", "stats", "server", "format", "active", "version", "res", "error", "message", "stat", "wait", "desc", "comment", "STAT", "code", "options", "source", "context", "sex", "index", "sys", "condition", "call", "progress", "since", "response"], "iov": ["rin", "ilo", "pkg", "vector", "ior", "von", "inv", "np", "soc", "imp", "uj", "iw", "gov", "iour", "ibr", "mu", "iat", "typ", "iv", "phy", "ech", "ij", "verb", "iph", "ovi", "iu", "iao", "hero", "lu", "serv", "uv", "cmd", "org", "ir", "uart", "rage", "vision", "ocy", "john", "nom", "vr", "ivic", "voice", "rev", "igr", "iq", "cv", "ux", "vec", "resp", "nov", "voc", "isco", "conv", "iol", "ia", "vo", "ov", "liv", "vi", "io", "icon", "v", "comm"], "msg": ["cfg", "pkg", "command", "m", "body", "name", "reason", "seq", "req", "mat", "mn", "gm", "nm", "notice", "mu", "module", "mess", "cm", "mg", "mp", "man", "ms", "vol", "doc", "send", "og", "gr", "header", "tx", "j", "gen", "cmd", "Msg", "node", "go", "dr", "net", "mail", "res", "message", "g", "frame", "col", "game", "reg", "news", "txt", "ge", "desc", "client", "md", "out", "resp", "obj", "mem", "alg", "str", "sg", "gent", "addr", "call", "err", "cmp", "stat", "mt", "v", "comm"], "cmsg": [" cg", "ccmd", "cammsg", "cmn", "conmsg", "pcmsg", "lmsg", "cmessage", "mcdr", "Cmsg", "crmsg", "cdr", "xcmn", "dcmessage", "conog", "ccmsg", "acmessage", "crbody", "lcdr", "dcmd", "lcmd", "dcmsg", "lcmg", "uncog", "cog", "pcmy", "cdef", "xcmy", "lcmn", " cdr", "concmd", "cms", "camms", "ccmessage", "ncmessage", " cmg", "crmy", "cammn", "rcmy", "condef", "mcmsg", "lms", "cMsg", "cmg", "xccmd", "cg", "dcmg", "cccmd", "Cnode", "camcmd", " ccmd", "Cmn", "cnode", "dcmy", "rcmessage", "mmd", "dccmd", " cmd", "lcnode", "lcmessage", "dcmn", " cMsg", "acmn", "ccms", "uncmsg", "rccmd", "mcmd", "cbody", "mmsg", "lcMsg", " cmn", "mcMsg", " cmessage", "crcmd", "pccmd", "xcnode", " cdef", "lmn", "unccmd", "pcbody", "acmsg", "cmy", "ccmn", "ncmn", "xcmessage", "pcmessage", "cmd", "mmessage", "rcmsg", "uncdef", "lcmsg", "lcg", "xcmsg", "ncmsg", "Cmessage", "dcg", " cog", "dcbody"], "retval": ["RETVAL", "pretVal", " retvals", "RetVal", "RETval", "retVal", "RetVAL", "returnVal", "retvalue", "Retvalue", "pretv", "returnvals", "returnVAL", "pretval", "RETeval", "returneval", " retVAL", "intervalue", "intereval", "retVAL", "retv", "preteval", " retVal", "altvalue", "Reteval", "reteval", " retv", "interval", "returnval", "RETv", "RETVal", "altVal", "altval", " reteval", "interVAL", "Retval", "interVal", "retvals", "alteval", "RETvals"], "data": ["action", "dev", "command", "done", "dat", "p", "start", "file", "name", "reason", "type", "length", "d", "padding", "def", "mu", "to", "value", "n", "bytes", "dt", "init", "fin", "text", "mode", "fail", "no", "empty", "step", "timeout", "version", "format", "size", "reg", "area", "error", "res", "message", "buffer", "dl", "nd", "pos", "rev", "client", "resp", "buf", "window", "len", "device", "a", "zero", "all", "base", "DATA", "x", "str", "ata", "err", "valid", "block", "Data"], "fd": ["ctx", "lf", "pid", "ff", "dir", "done", "dat", "file", "id", "td", " fid", "fl", "port", "d", "ptr", "pd", "fr", "fe", "dt", "fs", "wid", "ds", "fin", "fn", "fc", "da", "pos", "db", "fi", "dl", "nd", "seek", "dd", "std", "ud", "FD", "sid", "bf", "addr", "rd", "fp", "sd", "f", "cb", "df"], "msg_control": ["msg_Control", " msg_ctrl", "msg_controller", " msg_management", " msg_Control", "message_Control", "msg_management", "message_controller", "msg_rel", "cmd_Control", "cmd_controller", "message_rel", "cmd_control", "message_ctrl", "msg_ctrl", "cmd_ctrl", "message_control", "msg_ctr", "message_ctr"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n", "idx": 22417, "substitutes": {"env": ["ctx", "ped", "dev", "cfg", "stage", "end", "viron", "data", "v", "forge", "state", "ev", "impl", "manager", "ve", "engine", "shell", "jp", "gov", "tmp", "esc", "vs", "conn", "ah", "nc", "vm", "environment", "ten", "er", "info", "proc", "doc", "worker", "config", "app", "enc", "ec", "org", "stack", "server", "ce", "db", "rb", "en", "ner", "sp", "et", "ew", "cur", "store", "window", "buf", "desc", "nv", "code", "obj", "e", "ind", "context", "sv", "h", "esp", "hw", "priv", "gear", "cv"], "mce": [" mace", "mCE", "lce", "cce", "Mce", "lces", "lCE", "cced", "Mcer", "mcer", "emcent", "Mced", "mces", "emCE", " mced", "lcent", "emces", "MCE", "mcent", "emce", "Mace", " mCE", " mcer", "ccer", "mace", " mcent", " mces", "cace", "cCE", "mced"], "flag": ["stage", "command", "ff", "start", "FLAG", "id", "Flag", "type", "image", "flags", "lag", "ld", "tag", "field", "offset", "status", "bit", "limit", "info", "line", "feature", "kind", "cmd", "cond", "set", "age", "count", "link", "group", "level", "sign", "bug", "arg", "sun", "option", "package", "policy", "attribute", "batch", "mask", "weight"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static AioHandler *find_aio_handler(AioContext *ctx, int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd)\n\n            if (!node->deleted)\n\n                return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22418, "substitutes": {"ctx": ["cfg", "pkg", "cp", "ac", "bc", "conf", "req", "kt", "loc", "xc", "tc", "anc", "conn", "cm", "sc", "cc", "cl", "co", "etc", "c", "kw", "wd", "tx", "nt", "cmd", "unc", "txt", "setup", "resp", "obj", "context", "conv", "xs", "crit", "cf", "hw", "alloc", "wx", "cmp", "pool", "cb", "cv", "ct"], "fd": ["fff", "pid", " fin", "ff", "lf", "dir", "done", "file", "td", "id", " fid", "ffff", "d", " ed", "ld", "ptr", "pd", "dt", "fs", "cod", "ds", "fin", "hd", "fn", "fc", "pos", "db", "fi", " td", "cd", "nd", "ed", "did", "dd", "stream", "FD", "buf", "len", " fil", "handle", "ind", "bf", "cf", "addr", " df", "fp", "cb", "fed", "sd", "f", " ff", " FD", "df"], "node": ["post", "nw", "m", "list", "missing", "data", "parent", "entry", "id", "handler", "seed", "name", "path", "tmp", "d", "field", "tree", "nn", "cache", "n", "content", "component", "self", "hd", "holder", "good", "result", "station", "attr", "anch", "c", "fn", "root", "edge", "item", "slave", "nt", "normal", "leaf", "t", "k", "nd", "key", "child", "msg", "cd", "dd", "adj", "link", "tip", "desc", "note", "event", "instance", "obj", "row", "e", "source", "local", "index", "new", "Node", "ode", "object", "f", "cell"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI4_R RRR_R\n\n#define RRI4_S RRR_S\n\n#define RRI4_T RRR_T\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RRI4_IMM4 ((b2) & 0xf)\n\n#else\n\n#define RRI4_IMM4 (((b2) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n    unsigned len = xtensa_op0_insn_len(OP0);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    switch (len) {\n\n    case 2:\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n        break;\n\n\n\n    case 3:\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n        break;\n\n\n\n    default:\n\n        RESERVED();\n\n    }\n\n    dc->next_pc = dc->pc + len;\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            if (gen_window_check1(dc, CALLX_S)) {\n\n                                gen_jump(dc, cpu_R[CALLX_S]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {\n\n                            break;\n\n                        }\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_window_check2(dc, RRR_T, RRR_S)) {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_jump(dc, cpu_SR[\n\n                                         dc->config->ndepc ? DEPC : EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            if (gen_check_privilege(dc)) {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_mov_i32(cpu_SR[PS],\n\n                                                cpu_SR[EPS2 + RRR_S - 2]);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_helper_simcall(cpu_env);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc) &&\n\n                        gen_window_check1(dc, RRR_T)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                        gen_helper_check_interrupts(cpu_env);\n\n                        gen_jumpi_check_loop_end(dc, 0);\n\n                    }\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_waiti(dc, RRR_S);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_check_privilege(dc)) {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        /* This can change tb->flags, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                if (gen_check_privilege(dc) &&\n\n                    gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        TCGv_i32 zero = tcg_const_i32(0);\n\n                        TCGv_i32 neg = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);\n\n                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],\n\n                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);\n\n                        tcg_temp_free(neg);\n\n                        tcg_temp_free(zero);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                                     32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                }\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                                     RRR_S | ((OP2 & 1) << 4));\n\n                }\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                }\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_X) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv lo = tcg_temp_new();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_temp_free(lo);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_R) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_W) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));\n\n\n\n                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,\n\n                            cpu_R[RRR_S], tmp1);\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_R[RRR_R], tmp, zero,\n\n                            cpu_R[RRR_S], cpu_R[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                if (gen_window_check1(dc, RRR_R)) {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st].name) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                if (gen_window_check1(dc, RRR_T)) {\n\n                    if (uregnames[RSR_SR].name) {\n\n                        gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                if (gen_window_check2(dc, RRR_S, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            if (!gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                if (gen_window_check1(dc, RRR_R) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                if (gen_window_check1(dc, RRR_S) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    if (gen_window_check1(dc, RRR_R) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    if (gen_window_check1(dc, RRR_S) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        if (gen_check_cpenable(dc, 0)) { \\\n\n            TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n            \\\n\n            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n            tcg_temp_free(bit); \\\n\n        } \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                if (gen_window_check1(dc, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_FR[RRR_R], tmp, zero,\n\n                            cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        if (gen_window_check1(dc, RRR_T)) {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n                if (shift) { \\\n\n                    gen_load_store_alignment(dc, shift, addr, false); \\\n\n                } \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n#define gen_dcache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                TCGv_i32 res = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                tcg_gen_qemu_ld8u(res, addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n                tcg_temp_free(res); \\\n\n            } \\\n\n        } while (0)\n\n\n\n#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)\n\n#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_dcache_hit_test8();\n\n                }\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n#undef gen_dcache_hit_test\n\n#undef gen_dcache_hit_test4\n\n#undef gen_dcache_hit_test8\n\n\n\n#define gen_icache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_movi_i32(cpu_pc, dc->pc); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                gen_helper_itlb_hit_test(cpu_env, addr); \\\n\n                tcg_temp_free(addr); \\\n\n            }\\\n\n        } while (0)\n\n\n\n#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)\n\n#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_icache_hit_test8();\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n#undef gen_icache_hit_test\n\n#undef gen_icache_hit_test4\n\n#undef gen_icache_hit_test8\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            if (gen_window_check1(dc, RRI8_T)) {\n\n                tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                                 RRI8_IMM8 | (RRI8_S << 8) |\n\n                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            }\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, true); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],\n\n                                 RRI8_IMM8_SE << 8);\n\n            }\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            if (gen_window_check1(dc, RRI8_S) &&\n\n                gen_check_cpenable(dc, 0)) {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (ld_offset && !gen_window_check1(dc, RRR_S)) {\n\n                break;\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 lo = tcg_temp_new_i32();\n\n                        TCGv_i32 hi = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_mul_i32(lo, m1, m2);\n\n                        tcg_gen_sari_i32(hi, lo, 31);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        } else {\n\n                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        }\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free_i32(lo);\n\n                        tcg_temp_free_i32(hi);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            if (gen_window_check1(dc, CALL_N << 2)) {\n\n                gen_callwi(dc, CALL_N,\n\n                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            if (gen_window_check1(dc, BRI12_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            if (gen_window_check1(dc, BRI8_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    /* This can change tb->flags, so exit tb */\n\n                    gen_jumpi_check_loop_end(dc, -1);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    if (gen_window_check1(dc, RRI8_S)) {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                if (gen_window_check1(dc, BRI8_S)) {\n\n                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],\n\n                                4 + BRI8_IMM8_SE);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                if (gen_window_check1(dc, RRI8_S)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, false); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {\n\n            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        }\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {\n\n            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],\n\n                             RRRN_T ? RRRN_T : -1);\n\n        }\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (!gen_window_check1(dc, RRRN_S)) {\n\n            break;\n\n        }\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 22421, "substitutes": {"env": ["dev", "ep", "viron", "te", "ev", "conf", "pe", "esc", "eng", "environment", "sh", "kw", "eh", "ec", "ef", "map", "en", "ew", "EN", "et", "de", "cur", "buf", "code", "ee", "hw", "cb"], "dc": ["gc", "oc", "ca", "vc", "bc", "xc", "DC", "tc", "nc", "sc", "disc", "cc", "mc", "cm", "dh", "c", "cs", "fc", "lc", "di", "ec", "da", "dm", "cd", "dd", "dp", "cca", "ct"]}}
{"project": "FFmpeg", "commit_id": "043800a96888f1a04732f12316ba477d8f098d3f", "target": 0, "func": "static int end_frame(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext    *ctx = inlink->dst;\n\n    FPSContext           *s = ctx->priv;\n\n    AVFilterLink   *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef  *buf = inlink->cur_buf;\n\n    int64_t delta;\n\n    int i, ret;\n\n\n\n    inlink->cur_buf = NULL;\n\n    s->frames_in++;\n\n    /* discard frames until we get the first timestamp */\n\n    if (s->pts == AV_NOPTS_VALUE) {\n\n        if (buf->pts != AV_NOPTS_VALUE) {\n\n            write_to_fifo(s->fifo, buf);\n\n            s->first_pts = s->pts = buf->pts;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n\n                   \"timestamp.\\n\");\n\n            avfilter_unref_buffer(buf);\n\n            s->drop++;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* now wait for the next timestamp */\n\n    if (buf->pts == AV_NOPTS_VALUE) {\n\n        return write_to_fifo(s->fifo, buf);\n\n    }\n\n\n\n    /* number of output frames */\n\n    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,\n\n                         outlink->time_base);\n\n\n\n    if (delta < 1) {\n\n        /* drop the frame and everything buffered except the first */\n\n        AVFilterBufferRef *tmp;\n\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n\n        s->drop += drop;\n\n\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n\n        flush_fifo(s->fifo);\n\n        ret = write_to_fifo(s->fifo, tmp);\n\n\n\n        avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n\n\n    /* can output >= 1 frames */\n\n    for (i = 0; i < delta; i++) {\n\n        AVFilterBufferRef *buf_out;\n\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n\n\n        /* duplicate the frame if needed */\n\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n\n            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\n\n            s->dup++;\n\n        }\n\n\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n\n                                    outlink->time_base) + s->frames_out;\n\n\n\n        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||\n\n            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||\n\n            (ret = ff_end_frame(outlink)) < 0) {\n\n            avfilter_unref_bufferp(&buf);\n\n            return ret;\n\n        }\n\n\n\n        s->frames_out++;\n\n    }\n\n    flush_fifo(s->fifo);\n\n\n\n    ret = write_to_fifo(s->fifo, buf);\n\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n\n\n    return ret;\n\n}\n", "idx": 22425, "substitutes": {"inlink": ["cinline", "innstream", "isinline", " inlet", " outline", " outhandle", "inslice", "intline", "INline", "innframe", "airlock", " inhandle", "INframe", "cinlock", "outplay", "dinline", "inplay", "inhandle", " inroute", "outline", "dinlink", "inlock", " inslice", "inroute", "instream", "airlink", "cinslice", "dinhandle", "isinplay", "isinlink", " outroute", "inlet", "innline", "incell", "innlink", "cinlink", " inlock", "INlink", "outlet", "intplay", "outstream", "inframe", "airline", "innlet", " inframe", "airslice", "INstream", "isincell", "intcell", "dinroute", "intlink", " instream", "outcell"], "ctx": ["cp", "cfg", "js", "gs", "gc", "pkg", "mx", "p", "np", "bs", "mom", "conf", "bo", "jp", "kt", "xc", "tc", "anc", "iat", "conn", "cm", "mc", "cc", "sc", "Context", "nc", "ds", "ij", "c", "cs", "ctl", "lc", "tx", "config", "kw", "vp", "wd", "cmd", "nt", "act", "timeout", "t", "k", "kb", "jac", "gz", "ns", "txt", "ck", "unc", "ux", "resp", "window", "cam", "wcs", "cu", "context", "conv", "tz", "sys", "cf", "wx", "cmp", "kl", "cb", "cv", "ct"], "s": ["pkg", "sp", "rs", "bs", "conf", "fs", "ims", "cs", "stats", "its", "ins", "store", "actions", "a", "sam", "os", "f", "ls", "es", "ids", "d", "vs", "ties", "ps", "ds", "l", "b", "ts", "serv", "args", "less", "socket", "ports", "is", "v", "js", "gs", "m", "bits", "eps", "sm", "ms", "ses", "ss", "aws", "g", "hs", "services", "sts", "http", "sys", "ats", "space", "stat", "sports", "comm", "spec", "sq", "p", "sb", "service", "n", "y", "c", "as", "tx", "sw", "utils", "t", "ns", "changes", "sv", "qs", "xs", "h", "sg", "S", "als"], "outlink": ["unlink", " outline", "outputroute", "skylink", "unLink", "outLink", " outbridge", "inbridge", "undisk", "outputLink", "skyline", "outbridge", "outline", "unroute", "skybridge", " outroute", "outdisk", " outdisk", " outLink", "outputdisk", "outputlink", "outroute"], "buf": ["pkg", "ox", "np", "bs", "bag", "bin", "tc", "good", "grab", "gz", "rb", "foo", "rev", "vec", "pb", "cur", "cam", "bf", "arr", "queue", "cb", "cv", "cp", "bed", "gc", "uf", "box", "ann", "xff", "wb", "cache", "BU", "b", "buff", "uv", "img", "bh", "Buff", "conv", "fb", "temp", "ff", "seq", "av", "br", "orig", "proc", "raw", "kw", "bl", "msg", "txt", "batch", "err", "fp", "alloc", "cap", "pool", "nm", "Buffer", "bytes", "tab", "vp", "bt", "cmd", "func", "db", "buffer", "ref", "mem", "fg", "cmp", "pg"], "delta": ["fdDelta", "dota", "diff", "Distant", "mota", "adelta", "sdynamic", " dta", "telta", "sdelta", "tota", "edistant", "nynamic", "sdiff", " delt", "danta", "dDelta", "fdanta", "edanta", "DDelta", "dta", "melta", "dynamic", "nta", "sdta", " danta", "edDelta", "nelt", "tIFF", " dIFF", "Danta", "fdelt", " dDelta", "edelta", "delt", "adelt", "sdelt", "fdelta", "tynamic", "melt", "distant", " dota", " distant", "mIFF", "adiff", "tta", "nelta", "Delta", " diff", "telt", "Delt", "adta", "dIFF"], "i": ["hi", "m", "me", "ci", "ix", "p", "us", "o", "id", "si", "multi", "zi", "n", "ei", "y", "it", "xi", "ims", "init", "ti", "mi", "qi", "info", "iu", "c", "j", "di", "in", "ai", "t", "im", " ii", "g", "u", "phi", "gi", "li", "ui", "ip", "sim", "cli", "a", "ini", "e", "ind", "bi", "index", "ii", "x", "pi", "batch", "I", "io", "f", "ki", "v"], "ret": ["reset", "try", "full", "alt", "Return", "tr", "Ret", "jp", "def", "reply", "it", "rem", "status", "result", "fun", " Ret", "rt", "true", "ry", "r", "no", "nt", "flag", "print", "t", "ft", "res", "lt", "txt", "ref", "re", "resp", "mb", "RT", "len", "ll", "best", "last", "rets", "after", "gt", "arr", "mem", "jump", "new", "rm", "elt", "RET", "rel", "back", "mt", "cont", "val"], "frames_in": ["Frames_IN", "framesixIN", "frames__In", "Frames_in", "Frames__in", "Frames__In", "Frames_ins", "frames_ins", "Frames__IN", "Frames__ins", "frames__ins", "frames__IN", "frames_IN", "framesixins", "framesixin", "Frames_In", "frames_In", "frames__in", "framesixIn"], "drop": ["reset", "close", " dropping", "zip", "rest", "pop", "trap", " dropped", "rop", "hide", "carry", "hold", "slot", "clip", "throw", "box", "port", "delete", "pass", "shift", "root", " Drop", "delay", "no", "trip", "host", "dr", "dropping", "step", "shape", "loop", "move", "error", "sample", "skip", "dl", "dp", "hop", "snap", "grow", "Drop", "pause", "crop", "kill", "stop", "batch", "drops", "dim", "dro", "down", "keep", "pool", "trace", "draw"], "tmp": ["temp", "pkg", "perm", "Temp", "uf", "zip", "tp", "old", "vt", "mm", "np", "sp", "cont", "tt", "ptr", "tar", "dirty", "orig", "tm", "test", "partial", "mp", "dust", "etc", "rt", "stuff", "proc", "tab", "buff", "tx", "vp", "html", "nt", "img", "t", "gz", "msg", "txt", "mint", "mb", "snap", "out", "window", "obj", "resp", "sam", "mem", "xy", "qq", "cmp", "table", "cb", "cv"], "buf_out": ["pageockout", " buf_Out", "buf_obj", "page_out", "bufockobj", "buf__err", "buf_net", "buff_net", "buf_in", "page_obj", "buf__dot", "buf__out", "bufockerr", "buf_dot", "buff_in", "buff_out", "bufockdot", "buf__obj", "pageockobj", "pageockdot", "buf_alt", "page_dot", "pageockerr", "buf_OUT", "bufockout", "page_err", " buf_r", "buff_OUT", " buf_alt", "buf_Out", "buf_r", "buf_err"]}}
{"project": "FFmpeg", "commit_id": "c0175fa92b7edd45a06e4ab16c8e83da0c94a9f6", "target": 1, "func": "static int roq_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    RoqDemuxContext *roq = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    unsigned int chunk_size;\n\n    unsigned int chunk_type;\n\n    unsigned int codebook_size;\n\n    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];\n\n    int packet_read = 0;\n\n    int64_t codebook_offset;\n\n\n\n    while (!packet_read) {\n\n\n\n        if (avio_feof(s->pb))\n\n            return AVERROR(EIO);\n\n\n\n        /* get the next chunk preamble */\n\n        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=\n\n            RoQ_CHUNK_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n\n\n        chunk_type = AV_RL16(&preamble[0]);\n\n        chunk_size = AV_RL32(&preamble[2]);\n\n        if(chunk_size > INT_MAX)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        chunk_size = ffio_limit(pb, chunk_size);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case RoQ_INFO:\n\n            if (roq->video_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);\n\n                roq->video_stream_index = st->index;\n\n                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;\n\n                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;\n\n                st->codecpar->codec_tag    = 0;  /* no fourcc */\n\n\n\n                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)\n\n                    return AVERROR(EIO);\n\n                st->codecpar->width  = roq->width  = AV_RL16(preamble);\n\n                st->codecpar->height = roq->height = AV_RL16(preamble + 2);\n\n                break;\n\n            }\n\n            /* don't care about this chunk anymore */\n\n            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);\n\n            break;\n\n\n\n        case RoQ_QUAD_CODEBOOK:\n\n            if (roq->video_stream_index < 0)\n\n                return AVERROR_INVALIDDATA;\n\n            /* packet needs to contain both this codebook and next VQ chunk */\n\n            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;\n\n            codebook_size = chunk_size;\n\n            avio_skip(pb, codebook_size);\n\n            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=\n\n                RoQ_CHUNK_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +\n\n                codebook_size;\n\n\n\n            if (chunk_size > INT_MAX)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            /* rewind */\n\n            avio_seek(pb, codebook_offset, SEEK_SET);\n\n\n\n            /* load up the packet */\n\n            ret= av_get_packet(pb, pkt, chunk_size);\n\n            if (ret != chunk_size)\n\n                return AVERROR(EIO);\n\n            pkt->stream_index = roq->video_stream_index;\n\n            pkt->pts = roq->video_pts++;\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case RoQ_SOUND_MONO:\n\n        case RoQ_SOUND_STEREO:\n\n            if (roq->audio_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);\n\n                roq->audio_stream_index = st->index;\n\n                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;\n\n                st->codecpar->codec_tag = 0;  /* no tag */\n\n                if (chunk_type == RoQ_SOUND_STEREO) {\n\n                    st->codecpar->channels       = 2;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n\n                } else {\n\n                    st->codecpar->channels       = 1;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n\n                }\n\n                roq->audio_channels    = st->codecpar->channels;\n\n                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;\n\n                st->codecpar->bits_per_coded_sample = 16;\n\n                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n\n                    st->codecpar->bits_per_coded_sample;\n\n                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;\n\n            }\n\n        case RoQ_QUAD_VQ:\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                if (roq->video_stream_index < 0)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* load up the packet */\n\n            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n\n                return AVERROR(EIO);\n\n            /* copy over preamble */\n\n            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n\n\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                pkt->stream_index = roq->video_stream_index;\n\n                pkt->pts = roq->video_pts++;\n\n            } else {\n\n                pkt->stream_index = roq->audio_stream_index;\n\n                pkt->pts = roq->audio_frame_count;\n\n                roq->audio_frame_count += (chunk_size / roq->audio_channels);\n\n            }\n\n\n\n            pkt->pos= avio_tell(pb);\n\n            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,\n\n                chunk_size);\n\n            if (ret != chunk_size)\n\n                ret = AVERROR(EIO);\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unknown RoQ chunk (%04X)\\n\", chunk_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22426, "substitutes": {"s": ["ctx", "js", "gs", "m", "spec", "south", "ls", "q", "p", "sq", "es", "sp", "rs", "z", "bs", "conf", "times", "w", "sb", "n", "ps", "sc", "fs", "ims", "ds", "sa", "b", "ms", "c", "cs", "ts", "ses", "ss", "i", "stats", "t", "aws", "less", "set", "ns", "ins", "its", "a", "hs", "e", "sts", "qs", "sys", "ats", "os", "S", "f", "v"], "pkt": ["pkg", " pqt", "spqt", " pkg", "cpkg", "spnt", "spkg", "pnt", "cpkt", " pnt", "spkt", "pqt", "cpnt", "cpqt"], "roq": [" roqt", "robqu", "troqt", "roz", "roqi", "hoql", "robQ", " roque", "raqu", "groqu", "raq", "raql", "groquest", "hoqu", "roque", "troz", "croz", "robz", "robqi", "hoq", "troquant", "roiq", "stroqi", "roquest", "roql", "troqu", " roQ", "troiq", "stroq", "croqt", "roQ", "rowque", "aroquant", "aroqi", "raquest", "croq", "aroq", "rowq", " roqi", "robq", " roqu", "aroqu", "robquant", "stroql", "groiq", "groq", "roqt", "troquest", "troq", "rowqt", "roqu", "raiq", "troqi", "roquant", "rowqi", "troque", "hoqi", "stroqu", "robqt", "croqi", "troQ", "raqi"], "pb": ["ctx", "cp", "pkg", "gc", "uf", "tp", "vt", "p", "np", "pp", "eb", "bb", "nb", "sp", "pr", "ub", "td", "jp", "pm", "tmp", "sb", "tc", "wb", "tg", "bp", "pan", "iat", "typ", "gb", "pl", "mp", "ob", "wp", "proc", "vp", "tk", "buff", "tap", "PB", "pt", "phys", "kb", "bj", "rb", "pc", "pa", "dp", "lb", "buf", "snap", "bps", "emb", "obj", "sys", "lp", "tf", "fb", "fp", "cb", "pool", "kl", "pg", "cv"], "chunk_size": ["chacket_size", "chunk_format", "chblock_len", "chunk_SIZE", "chunk_number", "chunkingnumber", "chunkingSIZE", "chunk_len", "chblock_type", "chunkPoffset", "chunk_status", "chunks_name", "chacketingnumber", "chunk_name", "chacketinglength", "chunkPSIZE", "chacketingSIZE", "chacket_number", "chunks_status", "chacket_length", "chblock_size", "chunks_len", "chunkPtime", "chunkPsize", "chunk_time", "chunk_offset", "chunkinglength", "chacketingsize", "chunkingsize", "chunk_length", "chacket_SIZE", "chunks_size"], "chunk_type": ["chunketysize", "chunk_types", "chdownloadetytype", "chunketyindex", "chanch_kind", "chunketytypes", "chdownload_size", "chdownloadetyindex", "chdownload_index", "chunk_state", "chunketytype", "chunk_index", "chdownloadetytypes", "chdownload_type", "chanch_class", "chanch_type", "chunk_tag", "chanch_types", "chdownloadetysize", "chdownload_types", "chunk_kind", "chunk_class"], "codebook_size": ["codebooks_address", "codebooks_offset", "codebooks_size", "codebooks_length", "codebook_length", "codebook_address"], "preamble": ["proble", "repreambles", "exparmbled", " preamle", "pumbles", "repreamBLE", "preambled", "repreamle", " preamBLE", "prombler", " parmbles", "reparmbles", "probbl", "preambler", "pumble", " preambl", "parmbler", "exparmble", "pambler", "preambles", "expreambler", "prambles", "prambled", "reparmbler", "preamBLE", " preambles", "preambl", "pambled", "pumle", " parmbled", "repreamble", "expreamble", "exparmbles", "pumbler", "parmbles", "pamble", "pramle", "pamBLE", "pemble", "exprambler", "prombles", "pramble", "pamle", "pemBLE", "reparmble", "pambles", "pramBLE", "repreambler", "parmbled", " parmBLE", "preamle", "expreambles", "prombled", "prambler", "exprambles", "parmble", "prambl", "reparmle", "parmbl", "pembles", "pembled", "probble", "expreamBLE", "exprambled", "expramble", "reparmBLE", "exparmBLE", " parmble", " preambled", "expreambled", "parmle", "probbled", " parmbl", " parmle", "promble", "parmBLE"], "codebook_offset": ["codeBook_index", "codebook__size", "codebook__offset", "codeBook_off", "codeBook_size", "codebook_off", "codeBook_offset", "codebook__index", "codebook__off", "codebook_index"], "st": ["stan", "ust", "ast", "rest", "mont", "sn", "inst", "sl", "add", "start", "sp", "z", "td", "ist", "ST", "tt", "sty", "tmp", "stable", "sc", "fr", "it", "sm", "ost", "rt", "sh", "St", "sw", "ts", "nt", "ss", "ut", "pt", "step", "ft", "sta", "set", "put", "nd", "est", "stat", "irst", "ck", "std", "et", "sts", "sv", "usr", "h", "str", "se", "stop", "ste", "art", "th", "mt", "ct"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,\n\n\t\t\t\t  int16_t *filter, int16_t *filterPos, int filterSize)\n\n{\n\n#ifdef HAVE_MMX\n\n\tassert(filterSize % 4 == 0 && filterSize>0);\n\n\tif(filterSize==4) // allways true for upscaling, sometimes for down too\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 4), %%mm1\\n\\t\"\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 4), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse if(filterSize==8)\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*4;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 16(%1, %%\"REG_BP\", 8), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 24(%1, %%\"REG_BP\", 8), %%mm5\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm4, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\t\t\t\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse\n\n\t{\n\n\t\tuint8_t *offset = src+filterSize;\n\n\t\tlong counter= -2*dstW;\n\n//\t\tfilter-= counter*filterSize/2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"mov %2, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%%\"REG_c\", %0), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%%\"REG_c\", %0), %%ebx\t\\n\\t\"\n\n\t\t\t\"mov %5, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm5, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%1), %%mm1\t\t\\n\\t\"\n\n\t\t\t\"movq (%1, %6), %%mm3\t\t\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_a\"), %%mm0\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_b\"), %%mm2\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm0, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"add $8, %1\t\t\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\" jb 2b\t\t\t\t\\n\\t\"\n\n\t\t\t\"add %6, %1\t\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm5, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"mov %3, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm4, (%%\"REG_a\", %0)\t\\n\\t\"\n\n\t\t\t\"add $4, %0\t\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t: \"+r\" (counter), \"+r\" (filter)\n\n\t\t\t: \"m\" (filterPos), \"m\" (dst), \"m\"(offset),\n\n\t\t\t  \"m\" (src), \"r\" ((long)filterSize*2)\n\n\t\t\t: \"%\"REG_b, \"%\"REG_a, \"%\"REG_c\n\n\t\t);\n\n\t}\n\n#else\n\n#ifdef HAVE_ALTIVEC\n\n\thScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<dstW; i++)\n\n\t{\n\n\t\tint j;\n\n\t\tint srcPos= filterPos[i];\n\n\t\tint val=0;\n\n//\t\tprintf(\"filterPos: %d\\n\", filterPos[i]);\n\n\t\tfor(j=0; j<filterSize; j++)\n\n\t\t{\n\n//\t\t\tprintf(\"filter: %d, src: %d\\n\", filter[i], src[srcPos + j]);\n\n\t\t\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n\t\t}\n\n//\t\tfilter += hFilterSize;\n\n\t\tdst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...\n\n//\t\tdst[i] = val>>7;\n\n\t}\n\n#endif\n\n#endif\n\n}\n", "idx": 22429, "substitutes": {"dst": ["idx", "adst", "ddsc", "pst", " dset", " dsrc", "dx", "Ddest", "idsc", "drc", "idsrc", "adrc", "dsst", "ddsrc", " dx", "prc", "pdest", "dsc", " drc", " ddest", "dsrc", "Dsrc", "dsdest", "addest", "dsset", "Dsc", "ddest", "Dx", "Dst", "dssrc", "dset", "idst", "Dset", "ddx", "px", "adx", "ddst"], "dstW": ["dctN", "dspV", "dsetN", "dsstV", "dsetR", "dsstW", "dsetW", "destV", "dsrcL", "dspL", "deltaR", "dsetL", "drcV", " dxSize", "dxW", "dblV", "dsstL", " dstSize", "dstSize", "dblN", "drcL", " dstN", "dsrcWC", " dxN", "dctW", "dctR", "dxN", " dctVW", " dstVW", "dspW", "dstVW", "dsrcV", "dblW", " dstV", "dsetWC", "drcWC", "dxV", "dstWC", "destW", "dsrcW", " dxW", "deltaVW", "drcW", "deltaN", " dxV", " dctR", "dstV", "dctVW", "dstR", "dblSize", "dspWC", "dstN", "dstL", "dxSize", " dctN", " dctW", "deltaW", "dsetV", "destN", "destSize", "dsstWC", " dstR", "dsetVW"], "src": ["sn", "inc", "start", "input", "rs", "loc", "sb", "trans", "sc", "dest", "ser", "lr", "s", "r", "sub", "stream", "cur", "ins", "source", "sr", "rl", "x", "sur", "rel", "st", "cb", "rc"], "srcW": [" srcA", "sourceA", "srcA", "stA", "sourceW", "stH", " srcH", "sourceH", "stN", "srcH", "srcN", " srcN", "sourceN", "stW"], "xInc": [" xINC", "xxInc", "rxinc", " xDec", "rxINC", " xinc", "rxDec", "rxInc", "xxINC", "xDec", "xxinc", "xINC", "xxDec", "xinc"], "filter": ["ff", "spec", "profile", "frequency", "sort", "file", "control", "fw", "tr", "length", "trans", "range", "scale", "test", "counter", "inter", "chain", "limit", "feature", "header", "iter", "fil", "trigger", "version", "shape", "map", "size", "reverse", "match", "frame", "buffer", "f", "ref", "stream", "count", "window", "source", "index", "tf", "batch", "fp", "block", "Filter", "table", "term"], "filterPos": ["filterTrans", "rangePos", "sortPos", "termPos", "rangePOS", "specTrans", " filterPo", "sortSize", "filterLoc", "termPOS", " filterLoc", "filterPo", "termPo", "sortTrans", "filterPOS", "rangePo", "rangeTrans", "sortPOS", "bufferLoc", "bufferPos", "bufferPOS", "bufferSize", "termTrans", "specPOS", " filterTrans", "specPos", " filterPOS", "sortLoc"], "filterSize": ["blockLimit", "FilterCount", "filterZ", " filterSIZE", "filterLimit", " filterLimit", "filZ", "filterLen", " filterZ", "filterSi", " filterCount", "filterCount", "FilterZ", "FilterSIZE", "filSi", " filterStyle", "FilterSize", "hashSize", "blockSize", "blockSIZE", "filSize", "hashSIZE", "FilterPos", "filSIZE", " filterSi", "filPos", "FilterLen", "blockStyle", "filLen", "filStyle", "filCount", "filLimit", "filterSIZE", "FilterSi", "filterStyle", "hashCount", " filterLen"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431, "substitutes": {"f": ["ac", "lf", "fo", "af", "m", "alf", "uf", "q", "p", "file", "fw", "w", "d", "fr", "fe", "fd", "fs", "l", "b", "c", "fal", "fc", "fn", "elf", "r", "fab", "ef", "t", "fac", "fi", "rf", "al", "xf", "e", "F", "bf", "form", "h", "sf", "cf", "tf", "fb", "of", "fee", "fp", "fm", "v", "df"], "ret": ["reset", "alt", "req", "Ret", "tmp", "def", "nil", "des", "reply", "red", "ext", "rem", "status", "bit", "result", "rt", "aux", "lit", "flag", "nt", "deg", "print", "res", "error", " RET", "cat", "txt", "ref", "re", "resp", "hash", "sec", "arg", "rets", "mem", "gt", "elt", "RET", "val"]}}
{"project": "FFmpeg", "commit_id": "d3b4b74c32cf302d36a4c4d2cce08027f0a22560", "target": 0, "func": "static int encode_picture_lossless(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    MJpegContext * const m = s->mjpeg_ctx;\n\n    AVFrame *pict = data;\n\n    const int width= s->width;\n\n    const int height= s->height;\n\n    AVFrame * const p= (AVFrame*)&s->current_picture;\n\n    const int predictor= avctx->prediction_method+1;\n\n\n\n    init_put_bits(&s->pb, buf, buf_size);\n\n\n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    p->key_frame= 1;\n\n\n\n    ff_mjpeg_encode_picture_header(s);\n\n\n\n    s->header_bits= put_bits_count(&s->pb);\n\n\n\n    if(avctx->pix_fmt == PIX_FMT_RGB32){\n\n        int x, y, i;\n\n        const int linesize= p->linesize[0];\n\n        uint16_t (*buffer)[4]= (void *) s->rd_scratchpad;\n\n        int left[3], top[3], topleft[3];\n\n\n\n        for(i=0; i<3; i++){\n\n            buffer[0][i]= 1 << (9 - 1);\n\n        }\n\n\n\n        for(y = 0; y < height; y++) {\n\n            const int modified_predictor= y ? predictor : 1;\n\n            uint8_t *ptr = p->data[0] + (linesize * y);\n\n\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < width*3*4){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            for(i=0; i<3; i++){\n\n                top[i]= left[i]= topleft[i]= buffer[0][i];\n\n            }\n\n            for(x = 0; x < width; x++) {\n\n                buffer[x][1] = ptr[4*x+0] - ptr[4*x+1] + 0x100;\n\n                buffer[x][2] = ptr[4*x+2] - ptr[4*x+1] + 0x100;\n\n                buffer[x][0] = (ptr[4*x+0] + 2*ptr[4*x+1] + ptr[4*x+2])>>2;\n\n\n\n                for(i=0;i<3;i++) {\n\n                    int pred, diff;\n\n\n\n                    PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                    topleft[i]= top[i];\n\n                    top[i]= buffer[x+1][i];\n\n\n\n                    left[i]= buffer[x][i];\n\n\n\n                    diff= ((left[i] - pred + 0x100)&0x1FF) - 0x100;\n\n\n\n                    if(i==0)\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                    else\n\n                        ff_mjpeg_encode_dc(s, diff, m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                }\n\n            }\n\n        }\n\n    }else{\n\n        int mb_x, mb_y, i;\n\n        const int mb_width  = (width  + s->mjpeg_hsample[0] - 1) / s->mjpeg_hsample[0];\n\n        const int mb_height = (height + s->mjpeg_vsample[0] - 1) / s->mjpeg_vsample[0];\n\n\n\n        for(mb_y = 0; mb_y < mb_height; mb_y++) {\n\n            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < mb_width * 4 * 3 * s->mjpeg_hsample[0] * s->mjpeg_vsample[0]){\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n            for(mb_x = 0; mb_x < mb_width; mb_x++) {\n\n                if(mb_x==0 || mb_y==0){\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n                                if(y==0 && mb_y==0){\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= 128;\n\n                                    }else{\n\n                                        pred= ptr[-1];\n\n                                    }\n\n                                }else{\n\n                                    if(x==0 && mb_x==0){\n\n                                        pred= ptr[-linesize];\n\n                                    }else{\n\n                                        PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n                                    }\n\n                                }\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n//printf(\"%d %d %d %d %8X\\n\", mb_x, mb_y, x, y, ptr);\n\n                                PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(s);\n\n    s->picture_number++;\n\n\n\n    flush_put_bits(&s->pb);\n\n    return pbBufPtr(&s->pb) - s->pb.buf;\n\n//    return (put_bits_count(&f->pb)+7)/8;\n\n}\n", "idx": 22436, "substitutes": {"avctx": ["afcmp", "Avcontext", " avreq", " avconn", "awcam", "awconn", " avcontext", "verctx", "avercontext", "afconn", "wavcontext", "verreq", "averctx", "avereq", "averbc", "avcmp", "Avctx", "avercmp", "avbc", "afcontext", "vercontext", "avconn", "avecam", "avercmd", "Avtx", "awcontext", "avecontext", "vercu", "avcu", " avcu", " avbc", "awcmp", "avertx", "wavctx", "awctx", "avecmp", "avercam", "avectx", "avpkg", "awcmd", "afctx", " avcmp", "avcontext", "avreq", "Avbc", "avcam", "wavtx", "wavpkg", "avecu", "avecmd", " avtx", "avcmd", "avtx", " avpkg", "averpkg"], "buf": ["ctx", "uf", "num", "bar", "bs", "nb", "bc", "box", "bin", "port", "tmp", "wb", "cache", "br", "src", "bytes", "BU", "b", "text", "limit", "buff", "cmd", "img", "bh", "rb", "msg", "ref", "vec", "bu", "window", "len", "mem", "bf", "queue", "str", "batch", "rc", "fb", "err", "cap", "block", "cb", "cv"], "buf_size": [" bu_size", "buf_source", "bufktSize", "bufktsize", "buf_num", " bu_num", "bufktsource", "buf_info", " buf_source", " buf_Size", "bufktinfo", "buf_Size", " bu_ize", "buf_ize", " buf_info"], "data": ["height", "json", "dat", "start", "pad", "type", "image", "bin", "length", "w", "d", "padding", "def", "mu", "value", "n", "cache", "content", "png", "offset", " DATA", "text", "r", "raw", "header", "empty", "img", "images", "video", "format", "map", "first", "txt", "f", "ref", "device", "window", "hash", "obj", "intel", "DATA", "form", "str", "ata", "batch", "label", "rel", "picture", "block", "Data", "table"], "s": ["sp", "bs", "rs", "conf", "sc", "fs", "ims", "settings", "cs", "stats", "ies", "its", "ins", "a", "ares", "os", "ctx", "ls", "es", "o", "d", "vs", "ps", "ds", "self", "b", "ess", "ts", "serv", "ports", "source", "conv", "is", "js", "gs", "state", "ms", "ses", "ss", "aws", "g", "hs", "sts", "sys", "ats", "comm", "spec", "sq", "details", "w", "sb", "n", "c", "as", "sw", "j", "t", "ns", "sv", "qs", "S", "ops", "sd"], "m": ["mm", "mx", "o", "mn", "gm", "d", "n", "cm", "mc", "vm", "tm", "l", "mp", "man", "b", "ms", "c", "bm", "r", "dm", "g", "mem", "M", "mt", "f"], "pict": ["ctx", "dat", "np", "Pic", "mat", "jp", "def", "br", "pl", "png", "feat", "ht", "Pict", "proc", "doc", "fig", "fn", "buff", "vp", "img", "Picture", "pt", "act", "res", "fi", "capt", "txt", "pen", "cam", "obj", "conv", "pic", "pain", "pai", "pres", "pas", "picture", "stat", "f"], "p": ["cp", "pkg", "perm", "tp", "np", "pp", "o", "par", "sp", "pr", "jp", "pm", "d", "bp", "ps", "it", "l", "P", "mp", "b", "rep", "c", "wp", "r", "vp", "j", "pt", "t", "pro", "pc", "pa", "ip", "pb", "pen", "ap", "ping", "php", "a", "pic", "op", "lp", "pi", "policy", "pg", "fp", "picture", "f", "pers"], "x": ["any", "xp", "check", "ox", "rx", "ix", "mx", "my", "o", "full", "z", "at", "xx", "ax", "yx", "dx", "xxx", "w", "xc", "scroll", "cross", "n", "inx", "on", "content", "xi", "l", "xt", "xa", "r", "tx", "j", "t", "k", "g", "u", "xes", "key", "ux", "xf", "lat", "el", "X", "e", "xy", "xs", "index", "wx", "px", "ex", "xxxx", "fx"], "y": ["iy", "any", "ty", "yl", "height", "try", "my", "ady", "z", "hot", "yx", "by", "ied", "ay", "ym", "yo", "n", "vy", "py", "l", "yk", "ye", "sky", "b", "ny", "kit", "ry", "yr", "Y", "yt", "j", "ys", "yy", "axy", "col", "key", "iny", "ies", "ey", "hy", "dy", "tiny", "ch", "xy", "index", "sys", "cy", "yi", "yer", "ya", "wy", "sy", "gy"], "i": ["multi", "by", "ei", "spin", "chain", "mi", "info", "\u0438", "uri", "phi", "ip", "iq", "ri", "ini", "ind", "ii", "pi", "io", "f", "ki", "im", "ity", "q", "zi", "it", "l", "b", "qi", "iu", "di", "in", "k", "u", " I", "wi", "is", "hi", "me", "ice", "us", "si", "xi", "status", "ni", "ai", "g", "ui", "li", "ci", "ix", "id", "ij", "ti", "c", "j", "t", "ie", "gi", "ic", "cli", "sim", "ji", "bi", "e", "index", "I", "ami"], "buffer": ["bridge", "tile", "memory", "database", "button", "reference", "queue", "binary", "block", "table", "command", "uf", "cache", "screen", "b", "buff", "pointer", "document", "message", "frame", "jpg", "position", "device", "comment", "byte", "xy", "vector", "program", "length", "image", "port", "scroll", "text", "history", "header", "stack", "page", "window", "obj", "batch", "sequence", "pool", "_", "pixel", "Buffer", "result", "board", "size", "context", "gray", "new", "picture"], "top": ["current", "above", "high", "height", "list", "tools", "tops", "TOP", "Top", "parent", "hot", "at", "up", "master", "scroll", "to", "offset", "l", "tail", "there", "root", "lower", "stack", "center", "pos", "first", "target", "position", "lat", "upper", "level", "best", "bot", "st", "middle", "below", "bottom", "table", "trace"], "topleft": ["Totheft", "toopt", "totheut", "tothept", "topleut", "tothelf", "stoplevel", "toovel", "tplevel", "tloevel", "toplefts", "Totheut", "stotheft", "stothelf", "stopleft", "toout", "tloeft", "Topleut", "toplevel", "tpleft", "tothefts", "tplefts", "Toplevel", "tloelf", "tloefts", "Tothept", "toplept", "Topleft", "totheft", "tplelf", "tpleut", "toplelf", "stothefts", "tothevel", "Tothevel", "Toplept", "stothevel", "stoplelf", "tooft", "stoplefts", "tplept"], "ptr": ["pointers", "rect", "tp", "end", "np", "grad", "pr", "pad", "tr", "td", "req", "loc", "tmp", "pert", "br", "ext", "iv", "offset", "ret", "rep", "dh", "address", "buff", "cut", "iter", "cmd", "deg", "dr", "pointer", "pt", "pos", "prime", "ref", "vec", "desc", "ind", "Ptr", "ctr", "xy", "arr", "inters", "addr", "err", "rel", "dep"], "linesize": ["setsization", "lineiz", "linesiz", "linesization", "lsize", "linesz", "setsize", "lineszie", " linesization", "linksize", "setszie", "linksz", "inesz", "lineization", "linesIZE", "linepace", "linsz", "linsize", "setsized", "valuesization", "linesized", " linespace", "valuesize", "lineize", "blocksize", "blocksized", "blockszie", "lsization", "linesizer", " linesiz", "inesizer", "inesIZE", "lsiz", "linksIZE", "linsIZE", "linsizer", "valueszie", "blocksization", "linksizer", "lspace", "linespace", "valuesized", "inesize"]}}
{"project": "FFmpeg", "commit_id": "934fe00680a1139cbc0950641655af5923dd7763", "target": 0, "func": "static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (o->format) {\n\n        if (!(file_iformat = av_find_input_format(o->format))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Unknown input format: '%s'\\n\", o->format);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n    if (o->nb_audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (o->nb_audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_channels[o->nb_audio_channels - 1].u.i);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (o->nb_frame_rates) {\n\n        av_dict_set(&format_opts, \"framerate\", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_sizes) {\n\n        av_dict_set(&format_opts, \"video_size\", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_pix_fmts)\n\n        av_dict_set(&format_opts, \"pixel_format\", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);\n\n\n\n    ic->video_codec_id   = video_codec_name ?\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;\n\n    ic->audio_codec_id   = audio_codec_name ?\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;\n\n    ic->subtitle_codec_id= subtitle_codec_name ?\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n    ic->interrupt_callback = int_cb;\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* open the input file with generic avformat function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    /* apply forced codec ids */\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        choose_decoder(o, ic, ic->streams[i]);\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        exit_program(1);\n\n    }\n\n\n\n    timestamp = o->start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (o->start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                   filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    add_input_streams(o, ic);\n\n\n\n    /* dump the file content */\n\n    av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;\n\n    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;\n\n\n\n    for (i = 0; i < o->nb_dump_attachment; i++) {\n\n        int j;\n\n\n\n        for (j = 0; j < ic->nb_streams; j++) {\n\n            AVStream *st = ic->streams[j];\n\n\n\n            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)\n\n                dump_attachment(st, o->dump_attachment[i].u.str);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    reset_options(o, 1);\n\n    return 0;\n\n}\n", "idx": 22459, "substitutes": {"o": ["oos", "so", "oc", "lo", "ve", "O", "ot", "on", "info", "ow", "ok", "other", "ro", "ao", "after", "x", "op", "os", "io", "f", "oin", "q", "one", "l", "co", "b", "oo", " t", "ec", "remote", "k", "u", "ed", "ate", "oid", "ov", "v", "fo", "m", "te", "or", "image", "to", "original", "er", "po", "onet", "owner", "g", "oa", "window", "obj", "options", "bo", "ta", "p", "w", "ion", "n", "y", "ob", "c", "sw", "go", "t", "out", "e", "oi", "h", "ooo", "ation"], "opt": ["ctx", "cp", "fo", "ff", "temp", "p", "params", "tmp", "prop", "it", "init", "attr", "info", "fn", "kw", "pot", "config", "cmd", "img", "Opt", "nom", "txt", "off", "out", "option", "op", "fp", "seek"], "filename": ["ename", "ERROR", "json", "program", "p", "np", "file", "name", "til", "path", "iov", "nm", "nil", "url", "src", "n", "typ", "orig", "rn", "dest", "mpeg", "etc", "result", "prefix", "ame", "files", "fi", "proc", "fn", "fig", "wav", "r", "username", "fil", "nu", "ren", "unknown", "format", "tif", "brace", "output", "nam", "jpg", "ption", "unc", "txt", "upload", "msg", "names", "Filename", "other", "ames", "out", "options", "source", "fle", "title", "kj", "unction", "fp", "bas", "f", "kl", "final"], "ic": ["ac", "ci", "oc", "vc", "ric", "ici", " nic", "ican", "bc", "icing", "aic", "ot", "IC", "tic", "mic", "tc", "iat", "icc", "mc", "cc", "iac", "lic", "wic", "ics", "irc", "c", "fc", "lc", "nic", "ec", "pc", "et", "ip", "cit", "ico", "voc", "pic", "pi", "ia", "onic", "ik", "eric", "rc", "ct"], "file_iformat": ["file_ibiat", "file_ikkiat", "file_iformats", "file_mudat", "file_ikkat", "file_ikkats", "file_ibrat", "file_mudrat", "file_uniciat", "file_iformiat", "file_ikkata", "file_mudiat", "file_unicats", "file_iformrat", "file_iformata", "file_instiat", "file_unicat", "file_unicata", "file_instata", "file_ibat", "file_mudata", "file_instat", "file_instats", "file_ibata", "file_ikkrat"], "err": [" error", "req", "fd", "rn", "test", "race", "result", "er", "attr", "proc", " resp", "load", "r", "fer", "order", "res", "error", "msg", "rank", "resp", "coord", "e", "usr", "rr", "Error", "fee", "stat", "cb"], "i": ["m", "ci", "ix", "p", "v", "id", "si", "d", "iat", "l", "ij", "mi", "b", "iu", "c", "di", "ir", "integer", "t", "u", "fi", "ui", "li", "ip", "cli", "il", "ini", "bi", "e", "oi", "index", "ii", "x", "pi", "str", "I", "ik", "io", "f", "im"], "ret": ["gc", "uf", "alt", "Ret", "jp", "status", "fun", "result", "no", "flag", "nt", "cmd", "res", "set", "fi", "txt", "il", "out", "mem", "sys", "new", "rel", "RET", "val"], "timestamp": ["typename", "timeetime", "basestamp", "timetime", "typetime", "typtime", "bastime", "timtime", "timename", "basename", "typestamp", "timeename", "basetime", "timeestamp"], "buf": ["pkg", "bs", "bag", "bin", "tmp", "prop", "good", "rb", "foo", "vec", "pb", "cur", "uffer", "arr", "queue", "aka", "block", "cb", "cv", "ctx", "bed", "uf", "data", "bar", "box", "wb", "cache", "b", "doc", "buff", "iter", "img", "stream", "Buff", "read", "conv", "usr", "fb", "kl", "temp", "ff", "seq", "req", "mu", "br", "blocks", "text", "proc", "raw", "empty", "msg", "txt", "boxes", "window", "str", "batch", "fp", "cap", "progress", "pool", "bc", "Buffer", "bytes", "result", "tab", "bt", "cmd", "func", "buffer", "wait", "pause", "mem"], "opts": ["opfs", "options", "prefs", "OPfs", " copfs", "prets", "pretions", "OPtions", "OPt", " copts", "OPts", " copt", " coptions", "pret"], "orig_nb_streams": ["orig_nb_streamd", "orig_nb_streamings", "orig_nb_inputers", "orig_nb_reams", "orig_nb_pathers", "orig_nb_inputings", "orig_nb_paths", "orig_nb_pathings", "orig_nb_inputs", "orig_nb_streamers", "orig_nb_reamd", "orig_nb_reamers", "orig_nb_pathd", "orig_nb_reamings", "orig_nb_inputd"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_efdctuidz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);\n\n}\n", "idx": 22462, "substitutes": {"val": ["dev", "Value", "q", "p", "data", "vt", "ival", "z", "unit", " Val", "value", "it", "ue", "bit", "b", "vol", "VAL", "tx", " v", "serv", " arg", " value", "uv", "pt", "in", "eval", "func", "Val", "ref", "vec", "al", "x", "cal", "vals", "als", "valid", " eval", "v"], "u": ["uf", "q", "p", "us", "ur", "o", "un", "you", "uj", "su", "d", "util", " nu", "up", "ue", "b", "gu", "uu", "iu", "c", "ou", "lu", "du", "uv", "nu", "i", "uc", "ut", "t", "tu", "g", "U", "ui", "upload", "ux", "ul", "ud", "bu", "ru", "au", "cu", " tu", " U", "uid", " su", "eu", "fu", "pu", " up", "f", "v", "bo"]}}
{"project": "qemu", "commit_id": "28213cb6a61a724e2cb1e3a76d2bb17aa0ce9b36", "target": 0, "func": "void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n", "idx": 22465, "substitutes": {"linker": ["locking", "linkier", "linkner", "linked", "lighter", "inking", "checker", "linkler", "loader", "lockr", "lightger", "checked", "inkier", "lighted", " linkler", "lightier", "layner", " linke", "tooler", "inkger", "layer", "loading", "linking", "locker", "checkier", "linkger", "laye", "inked", "loadger", "layler", " linkner", "linke", "inker", "loadr", "toolner", "inkr", "lockger", "toole", "linkr", "checkger", "tooller"], "file_name": ["fileamename", "fileameName", "fileNamename", "ile_name", "fileNamelength", "fileamepath", "file_Name", "fileNameaddress", " file_Name", "fileNameno", "file_length", "file_path", "file_no", "fileamelength", "ile_length", " file_path", "file_address", "fileNamepath", "ile_Name", " file_no", " file_address", "fileNameName", "ile_path"], "start": ["check", "get", "rest", "end", "p", "add", "sp", "started", "data", "name", "id", "length", "starting", "port", "trans", "range", "it", "offset", "shift", "init", "Start", "limit", "root", "address", "origin", "step", "pos", "t", "set", "from", "first", "skip", "position", "window", "len", "source", "base", "import", "time", "index", "stop", "part", "addr", "begin", "art", "space", "st", "use", "help"], "size": ["height", "spec", "num", "sent", "export", "end", "description", "data", "body", "name", "type", "SIZE", "si", "length", "small", "year", "range", "scale", "Size", "n", "bytes", "resolution", "offset", "shift", "capacity", "style", "max", "s", "send", "score", "storage", "empty", "timeout", "sum", "shape", "area", "message", "news", "count", "len", "number", "e", "time", "index", "ize", "space"], "checksum": ["csul", "checksame", " checksumb", "opensum", " checkssum", "csum", "checksul", "ksul", "cksub", "checksums", "hssum", "opensums", "ksub", "cksumb", "checksumb", "cssum", "cksum", "ksum", "cksame", "hsumb", "csub", "checkssum", " checksame", "checksub", "cksums", "opensame", "kssum", "cksul", "openssum", "hsums", "hsum", "ckssum", " checksums"], "entry": ["check", "ment", "needed", "ient", "RY", "info", "nt", "server", "search", "xml", "set", "output", "cue", "element", "rance", "look", "client", "instance", "pattern", "record", "attribute", "table", "cell", "command", "list", "try", "inner", "q", "data", "insert", "card", "enter", "component", "self", "inter", "escape", "print", "error", "see", "member", "csv", "desc", "comment", "ent", "import", "se", "part", "public", "export", "or", "image", "ptr", "ace", "field", "ries", "r", "aux", "ENT", "archive", "section", "entity", "row", "form", "connection", "way", "valid", "spec", "parent", "def", "service", "delete", "Entry", "existent", "rent", "result", "ry", "line", "query", "match", "out", "event", "job", "e", "base", "index", "pair", "response"], "file": ["action", "code", "File", "dir", "data", "full", "body", "name", "be", "type", "id", "image", "length", "port", "path", "filename", "user", "util", "field", "block", "range", "url", "cache", "ile", "force", "offset", "l", "info", "files", "line", "limit", "node", "format", "t", "db", "message", "buffer", "page", "key", "open", "target", "il", "disk", "link", "channel", "entity", "out", "handle", "comment", "e", "run", "source", "base", "byte", "angle", "form", "local", "issue", "time", "rule", "resource", "part", "model", "record", "io", "f", "table", "le"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->internal->thread_ctx;\n\n    FrameThreadContext *fctx;\n\n    AVFrame *dst, *tmp;\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                          avctx->thread_safe_callbacks                   ||\n\n                          (\n\n#if FF_API_GET_BUFFER\n\n                           !avctx->get_buffer &&\n\n#endif\n\n                           avctx->get_buffer2 == avcodec_default_get_buffer2);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    if (!f->f->buf[0])\n\n        return;\n\n\n\n    if (avctx->debug & FF_DEBUG_BUFFERS)\n\n        av_log(avctx, AV_LOG_DEBUG, \"thread_release_buffer called on pic %p\\n\", f);\n\n\n\n    av_buffer_unref(&f->progress);\n\n    f->owner    = NULL;\n\n\n\n    if (can_direct_free) {\n\n        av_frame_unref(f->f);\n\n        return;\n\n    }\n\n\n\n    fctx = p->parent;\n\n    pthread_mutex_lock(&fctx->buffer_mutex);\n\n\n\n    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))\n\n        goto fail;\n\n    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,\n\n                          (p->num_released_buffers + 1) *\n\n                          sizeof(*p->released_buffers));\n\n    if (!tmp)\n\n        goto fail;\n\n    p->released_buffers = tmp;\n\n\n\n    dst = &p->released_buffers[p->num_released_buffers];\n\n    av_frame_move_ref(dst, f->f);\n\n\n\n    p->num_released_buffers++;\n\n\n\nfail:\n\n    pthread_mutex_unlock(&fctx->buffer_mutex);\n\n}\n", "idx": 22503, "substitutes": {"avctx": ["vercp", "avekl", "avercp", "aftx", "wavcontext", "avcmp", "avetx", "avectx", "avcontext", " avtx", "avtx", "cfcontext", "verctx", "varkt", "avercmp", "avecp", "avca", "AVcp", "wavcp", "wavca", "navctx", "avcp", " avcmp", "afctx", "wavcu", "afjp", "auctx", "wavkl", "avtc", "awtx", "cfcfg", "avjp", "AVcontext", "averkt", "afcmp", "aucu", "varctx", "navjp", " avcontext", "afcu", "averctx", "avercu", "awca", "avkt", "afcontext", "AVca", "AVtx", "avertx", "awctx", "autc", "avcfg", "avertxt", "navkl", "navca", "aucontext", "AVtxt", "afkt", "wavjp", "avejp", "averca", "aveca", " avcfg", " avtc", "avkl", "avercontext", " avtxt", "vercontext", "avecontext", "vercu", "avcu", "afcp", " avcu", "wavctx", "varcmp", "avecmp", "AVctx", "awjp", "avecfg", "cfctx", "avertc", "cfcmp", "awcp", "avtxt"], "f": ["alf", "fo", "ff", "m", "lf", "uf", "q", "file", "z", "fx", "fw", "fl", "conf", "w", "d", "fr", "y", "fd", "fe", "fs", "fa", "l", "feat", "b", "info", "inf", "c", "fn", "fc", "feature", "elf", "kw", "fab", "j", "ef", "i", "t", "fac", "ft", "g", "fi", "frame", "u", "rf", "ref", "xf", "F", "e", "flow", "form", "bf", "sf", "h", "cf", "x", "tf", "fb", "of", "fp", "fm", "fu", "fed", "fen", "v", "df"], "p": ["ctx", "pkg", "cp", "perm", "m", "post", "tp", "pid", "np", "pp", "parent", "par", "sp", "at", "jp", "pm", "port", "pe", "d", "parse", "up", "bp", "ps", "l", "P", "mp", "rep", "wp", "c", "proc", "vp", "app", "j", "i", "t", "g", "pro", "pc", "pa", "patch", "dp", "pb", "ip", "ap", "ping", "process", "local", "h", "pre", "op", "lp", "pi", "part", "pg", "fp", "pers", "pool"], "fctx": [" fobj", "cfcontext", " fcmp", "cfjac", " fcontext", "vcontext", "vcfg", "fcontext", "fcmp", "pjac", "vobj", "fwcfg", "fobj", "tcontext", "ftree", "pctx", "vctx", "fwctx", "vjac", "tobj", "cftx", " ftx", "pcfg", "pcmp", "ptx", "fjac", "vtree", "tctx", "cfctx", "fwtree", "cfcfg", "pcontext", "fcfg", "vtx", "ptree", "cfcmp", "ftx", "ttx", "fwcontext"], "dst": ["dnd", "Dsts", "drest", "drsts", "pst", "dot", "Dest", "Ddest", "drnd", "dsot", "lst", "pest", "lsts", "dest", "dsst", " dsts", " dot", " dnd", "ldest", "pdest", " ddest", "dsdest", "Dnd", "ddest", "Dst", "drst", " dest", "lot", "dssts", "pnd", "dsts"], "tmp": ["temp", "cp", "jj", "ff", "m", "perm", "uf", "vv", "tp", "aaa", "vt", "np", "sp", "pp", "zip", "amps", "td", "emp", "tt", "jp", "gm", "ptr", "mut", "cache", "orig", "tm", "mp", "etc", "b", "attr", "proc", "buff", "vp", "j", "mmm", "uv", "nt", "timeout", "t", "MP", "nd", "tn", "txt", "pkg", "mint", "pb", "cv", "resp", "buf", "snap", "obj", "tf", "err", "qq", "cmp", "cb", "v"], "num_released_buffers": ["num_released__bufers", "num_released_Buffels", "num_released_buffmers", "num_released_Bufferers", "num_released_streamers", "num_released__bufings", "num_released__buffered", "num_released_integackers", "num_released_integered", "num_released_bufferers", "num_released_buffered", "num_released_Buffings", "num_released_rowsmers", "num_released_integers", "num_released__buffers", "num_released_itERS", "num_released_rowserers", "num_released_buffERS", "num_released_iters", "num_released_itered", "num_released_Buffmers", "num_released_bufferensions", "num_released_flushers", "num_released_bufferered", "num_released_Buffered", "num_released_Buffers", "num_released_bindackers", "num_released_bindered", "num_released_bufeners", "num_released_Buffeners", "num_released_buffackers", "num_released_bufferERS", "num_released_Buffackers", "num_released_streammers", "num_released_buffensions", "num_released__bufered", "num_released_buffels", "num_released_bufings", "num_released_buffings", "num_released__buffeners", "num_released_flushered", "num_released_streamered", "num_released_binders", "num_released_flusheners", "num_released_Buffensions", "num_released_BuffERS", "num_released_bufered", "num_released_bufers", "num_released_bindels", "num_released__bufeners", "num_released_rowsers", "num_released_buffeners", "num_released_itensions", "num_released__buffings", "num_released_rowsered", "num_released_streamerers", "num_released_integels", "num_released_flushings"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))\n\n{\n\n    while (queue->p_head)\n\n        free_func(ff_schro_queue_pop(queue));\n\n}\n", "idx": 22531, "substitutes": {"queue": ["command", "list", "q", "required", "file", "Q", "seq", "entry", "qa", "quit", "port", "priority", "Queue", "forced", "qu", "master", "quote", "component", "que", "ue", "ques", "prefix", "history", "line", "worker", "grid", "flag", "menu", "server", "archive", "message", "frame", "phrase", "buffer", "cue", "client", "store", "buf", "channel", "job", "event", "topic", "batch", "dq", "sequence", "block", "table"], "free_func": ["de_kw", "freeervar", "freeerfunc", " freeerobj", "de_unc", "freeerobj", " freeerunc", "free_kw", "de_f", " free_var", " free_unc", "freeerunc", "de_func", " free_obj", "free_f", " freeervar", "free_unc", "free_obj", "free_var", " freeerfunc"]}}
{"project": "qemu", "commit_id": "6b49809c597331803ea941eadda813e5bb4e8fe2", "target": 1, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n", "idx": 22534, "substitutes": {}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n", "idx": 22545, "substitutes": {"val": ["ctx", "num", "vt", "p", "add", "ival", "slot", "loc", "sol", " Val", "value", " tx", "test", "vol", " num", "VAL", "tx", " v", " arg", " value", "func", "eval", " update", "res", "cond", "Val", "AL", "pol", "ref", " slot", "al", "il", "bal", "el", " x", "index", "cal", "vals", " interval", "als", "valid", "fee", " eval", "v"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 22552, "substitutes": {"dc": ["ctx", "ac", "gc", "cr", "dir", "design", "oc", "ca", "mm", "dat", "vc", "conn", "params", "bc", "ga", "d", "DC", "def", "tc", "disc", "cm", "mc", "cc", "dt", "nc", "sc", "tm", "ds", "currency", "wp", "c", "cs", "fc", "doc", "du", "lc", "kw", "mac", "di", "ec", "cus", "da", "dr", "cmd", "dm", "db", "dl", "pc", "cd", "ic", "dd", "dp", "de", "desc", "draw", "coord", "cca", "cu", "rec", "dk", "exec", "dim", "ctl", "rc", "df"], "t0": ["time10", "vt3", "ktk", "T3", " tk", "tempoval", "kt1", "wt1", "T000", "T8", "wt8", "timeZero", " tZero", " toval", "tk", "timeoval", "kt000", "kt0", "t10", "T1", " T0", "vt0", "wtable", "t1", "T0", " t1", " t000", "t000", "t3", "Table", " T1", "time0", " t10", "vt1", " t3", "Tk", "wt0", "temp10", "tempZero", " table", "t8", " t8", "temp0", "table", "tZero", "toval"]}}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "AVInputFormat *av_find_input_format(const char *short_name)\n\n{\n\n    AVInputFormat *fmt = NULL;\n\n    while ((fmt = av_iformat_next(fmt)))\n\n        if (match_format(short_name, fmt->name))\n\n            return fmt;\n\n    return NULL;\n\n}\n", "idx": 22559, "substitutes": {"short_name": ["shortNamenames", "long_names", "long_value", "short_word", "shortNameword", "shortableName", "long_word", "short_Name", "short_value", "shortNamename", "long_Name", "short_names", "long_name", "shortablename", "shortNameName", "shortablevalue"], "fmt": ["ffmt", "fld", "aftm", "fabmt", "factm", "fabld", "ftm", "vmt", "flt", "vformat", "hmt", "fformat", " fpl", "facformat", " flt", "hlt", "tmt", " fmp", "pmt", " ftm", "mformat", "htm", "pmp", "fnt", "mmt", "mkt", " fld", "fmp", "faclt", " fkt", "tlt", "fftm", "plt", "afnt", "vld", "vkt", "hmp", "tnt", "fpl", "fflt", "hformat", "aflt", "facmt", "ppl", "ttm", " fformat", "fabformat", "hkt", "mtm", "fkt", " fnt", "fabkt", "ffformat", "afmt", "hpl"]}}
{"project": "FFmpeg", "commit_id": "b791a0831b0a027e7ba4eb6961cc0180472ac603", "target": 1, "func": "static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,\n\n                                      int mm_flags)\n\n{\n\n#if HAVE_SSE2_INLINE\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {\n\n        c->idct_put              = ff_idct_xvid_sse2_put;\n\n        c->idct_add              = ff_idct_xvid_sse2_add;\n\n        c->idct                  = ff_idct_xvid_sse2;\n\n        c->idct_permutation_type = FF_SSE2_IDCT_PERM;\n\n    }\n\n#endif /* HAVE_SSE2_INLINE */\n\n\n\n#if HAVE_SSE2_EXTERNAL\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_sse2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2;\n\n    if (mm_flags & AV_CPU_FLAG_ATOM) {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_int_sse2;\n\n    } else {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_sse2;\n\n    }\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_sse2;\n\n    } else if (!(mm_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        c->apply_window_int16 = ff_apply_window_int16_round_sse2;\n\n    }\n\n    c->bswap_buf = ff_bswap32_buf_sse2;\n\n#endif /* HAVE_SSE2_EXTERNAL */\n\n}\n", "idx": 22597, "substitutes": {"c": ["ctx", "cp", "ac", "gc", "m", "ci", "p", "ca", "o", "bc", "conf", "can", "d", "tc", "anc", "cache", "nc", "cm", "mc", "cc", "content", "C", "l", "co", "etc", "chain", "cs", "fc", "r", "lc", "config", "enc", "ec", "ce", "t", "set", "g", "pc", "unc", "dc", "cv", "con", "cam", "a", "e", "abc", "ch", "cu", "h", "cf", "rc", "call", "new", "err", "container", "coll", "cont", "v", "ct"], "avctx": [" avcas", "iverhistory", "avehw", "navcontext", "varctx", "avcb", "ivercas", " avcontext", "ivercontext", "avercontext", "avhw", "auhw", "averctx", "varcas", "auobj", "avclient", "avctrl", "varcontext", "avekw", "avobj", " avhelp", " avcb", "auclient", "avhistory", "averhelp", "avecontext", "AVhw", " avhistory", "avecb", "navctx", "aveclient", "avectx", "varhistory", "AVclient", "avcontext", "varhelp", "navcb", "auctx", " avctrl", "AVctx", "AVobj", "iverctx", "averctrl", "avcas", "avkw", "varctrl", "aveobj", " avkw", "navkw", "avhelp"], "mm_flags": [" mm2flags", "mmagicpackages", "mn_values", "mn_includes", "mm68type", "mm_packages", "ml_properties", "mm417packages", "mmagicflags", " mm_flag", "mletricproperties", "mletricstats", "mm417flags", "mm2type", "mn417packages", "mm417includes", "mmanystats", "mmetricpackages", "mm68flags", "mm_type", "mmanyproperties", "mm68sign", "mletricflags", " mm_type", "mm_values", "mm_members", "mmetricincludes", "mmetricmembers", "mn_packages", "ml_stats", " mm2type", "ml_flags", "mm2flags", "mm_sign", " mm2sign", "mm_includes", "mmetricvalues", "mletricmembers", "mm68flag", "mn417includes", "mn_flags", "mm417values", "mmanymembers", " mm2flag", "mm2sign", "ml_members", "mmetricproperties", "mm_flag", "mn417flags", "mmetricstats", "mmetricflags", " mm_sign", "mn417values", "mm_stats", "mmagicincludes", "mmagicvalues", "mm_properties", "mmanyflags", "mm2flag"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int au_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 24)\n\n        return 0;\n\n    if (p->buf[0] == '.' && p->buf[1] == 's' &&\n\n        p->buf[2] == 'n' && p->buf[3] == 'd')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 22601, "substitutes": {"p": ["pkg", "cp", "post", "m", "tp", "q", "np", "pp", "at", "power", "jp", "parse", "pm", "w", "d", "up", "bp", "cache", "ps", "press", "y", "it", "l", "P", "mp", "att", "b", "rep", "info", "wp", "c", "er", "r", "vp", "pat", "j", "app", "pt", "t", "g", "pro", "pc", "pa", "dp", "pb", "ip", "ap", "pod", "out", "a", "pre", "op", "lp", "part", "ad", "progress", "f", "v"]}}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n", "idx": 22615, "substitutes": {"opts": ["OPters", "operpt", " opents", " opTS", "iopTS", " coptes", "optents", "OPTs", "OPts", "opTs", " options", "optns", " copTS", "opars", " opTs", " opars", "optTs", "oppt", "optters", "OpTs", "opns", " oppt", "operts", "OPars", " coptions", "ioptes", "optts", " optes", " ops", "opTS", "Opts", "Ops", "Opters", "OPs", "iopts", " copts", "ioptions", "optes", "optars", " opns", "operns", "opents", "options", "optpt", "ops", "operents", "opters"], "machine": ["m", "me", "volume", "mo", "iso", "memory", "manager", "handler", "engine", "achine", "power", "smart", "user", "ghost", "managed", "module", "domain", "vm", "mc", "mobi", "chain", "mode", "mobile", "management", "human", "storage", "slave", "computer", "di", "node", "unknown", "company", "server", "normal", "owner", "network", "mouse", "frame", "OTHER", "metadata", "brain", "device", "mob", "money", "window", "session", "instance", "Machine", "mem", "interface", "agent", "monitor", "model", "way", "zone"], "filename": ["ename", "println", "json", "kan", "family", "file", "lua", "name", "til", "path", "nm", "nil", "journal", "src", "n", "fd", "rn", "fs", "png", "river", "ame", "prefix", "files", "fn", "wav", "username", "kl", "fil", "location", "ren", "directory", "mson", "fi", "buffer", "jpg", "txt", "SOURCE", "Filename", "subject", "ames", "source", "fle", "bf", "title", "fp", "bas", "f", "FIL"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,\n\n                        int *duration)\n\n{\n\n    int64_t out_pts = AV_NOPTS_VALUE;\n\n    int removed_samples = 0;\n\n\n\n#ifdef DEBUG\n\n    ff_af_queue_log_state(afq);\n\n#endif\n\n\n\n    /* get output pts from the next frame or generated pts */\n\n    if (afq->frame_queue) {\n\n        if (afq->frame_queue->pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->frame_queue->pts - afq->remaining_delay;\n\n    } else {\n\n        if (afq->next_pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->next_pts - afq->remaining_delay;\n\n    }\n\n    if (pts) {\n\n        if (out_pts != AV_NOPTS_VALUE)\n\n            *pts = ff_samples_to_time_base(afq->avctx, out_pts);\n\n        else\n\n            *pts = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    /* if the delay is larger than the packet duration, we use up delay samples\n\n       for the output packet and leave all frames in the queue */\n\n    if (afq->remaining_delay >= nb_samples) {\n\n        removed_samples      += nb_samples;\n\n        afq->remaining_delay -= nb_samples;\n\n    }\n\n    /* remove frames from the queue until we have enough to cover the\n\n       requested number of samples or until the queue is empty */\n\n    while (removed_samples < nb_samples && afq->frame_queue) {\n\n        removed_samples += afq->frame_queue->duration;\n\n        delete_next_frame(afq);\n\n    }\n\n    afq->remaining_samples -= removed_samples;\n\n\n\n    /* if there are no frames left and we have room for more samples, use\n\n       any remaining delay samples */\n\n    if (removed_samples < nb_samples && afq->remaining_samples > 0) {\n\n        int add_samples = FFMIN(afq->remaining_samples,\n\n                                nb_samples - removed_samples);\n\n        removed_samples        += add_samples;\n\n        afq->remaining_samples -= add_samples;\n\n    }\n\n    if (removed_samples > nb_samples)\n\n        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");\n\n    if (duration)\n\n        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);\n\n}\n", "idx": 22637, "substitutes": {"afq": ["aitquest", "awp", "afreq", "afqueue", " afcp", "alogq", "affq", "avqs", "famqt", "affz", "abw", "affv", "afay", "ajj", "tifquest", "afp", "aptq", "affqt", "famkg", "affrequ", "awqueue", "agg", "awck", "avquest", "aftkg", "affch", "affdq", "ajq", "alfq", "abqueue", "rafkg", "affque", "rafq", "abk", "ajqu", "affk", "affog", "ajdq", "abv", "afv", "abcdq", "affkg", "afiq", "affce", "affcl", "authkg", "famque", "awreq", "aftq", "abquire", "fareq", "abcl", "afcl", "awqt", "avqt", "afrequ", "affay", "tifay", "faqueue", "authq", "aptque", "abcq", "abch", " afg", "afdq", "tifrequ", "afce", "afch", "alogque", "efk", "awry", " afdq", "rafck", "avq", "aftquest", "faq", "aitquire", "affg", "afqt", "fach", "ajz", "afft", "awg", "affw", "alfk", "affry", "affp", "awque", "affj", "face", "agque", "awquest", "fag", "afw", "agck", "alogqt", "affquest", "alfquest", "ajw", "ajqueue", "aft", "ajrequ", "abj", "affck", "fary", "afry", "aptce", "ajay", "efdq", "ajqt", "awqq", "alfog", "efq", "aftce", "abquest", "abcp", "avreq", "awch", "affreq", "afz", "afqu", "avque", "aitq", "awdq", "afg", "abq", "afquest", "alfce", "agreq", "alogqu", "agqq", "agiq", "alfz", "ajquest", "aitcp", "afck", "abreq", "afj", "ajreq", "awq", " afqq", "abdq", "alfg", "famq", "ajque", " afquire", "alfck", "alfch", "affiq", "alfque", "agdq", "alfdq", "abry", "awv", "authque", " afquest", "afk", "afcp", "afqs", "afkg", "rafque", "famqu", "abt", "tifq", "afqq", " afk", "abp", "aptquest", " afog", "ajry", "ajce", "famck", "authce", "ajck", "agq", "afog", "avcl", "awqs", "affqs", "affqueue", "eft", "abcque", "afque", "ajkg", "abciq", "alfcl", "aftque", "afquire"], "nb_samples": ["nb_samp", "nb_damp", "nb_seacks", "nb_stones", "nb___samps", "nb_sicks", "nb_resultsiles", "nb_resamps", "nb_sples", "nb_usicks", "nb_Sources", "nb_nsamps", "nb_teststones", "nb___resances", "nb_restones", "nb_eamps", "nb_resamples", "nb_usamps", "nb_sinplays", "nb_seaces", "nb_isaces", "nb____sinamples", "nb____splays", "nb____sinples", "nb_isacks", "nb_usamples", "nb_siles", "nb___stones", "nb_nspaces", "nb___restones", "nb_Sems", "nb_seamp", "nb_testsamples", "nb____samples", "nb_svplays", "nb_insources", "nb_testsamps", "nb___samples", "nb_dources", "nb_Sourses", "nb____samps", "nb_sems", "nb_spaces", "nb_isamps", "nb_Sicks", "nb_saces", "nb_Slements", "nb_inslements", "nb_damples", "nb_Samples", "nb_sslements", "nb_Splays", "nb_seources", "nb_siblings", "nb_resances", "nb_sinamps", "nb_eems", "nb_ssamps", "nb_svamps", "nb_eamples", "nb_isamples", "nb_Sples", "nb_damps", "nb_insamps", "nb_Saces", "nb_resultsiblings", "nb_Sances", "nb_sourses", "nb_nsamples", "nb_sinamples", "nb_slements", "nb____sinamps", "nb___sances", "nb_insamples", "nb_Siblings", "nb___resamples", "nb_svples", "nb_isiles", "nb_resultsamples", "nb_usems", "nb_ssamples", "nb_Samps", "nb_ssources", "nb_seamps", "nb_svamples", "nb_sinples", "nb_isiblings", "nb_sources", "nb____sinplays", "nb____sples", "nb_Spaces", "nb_sances", "nb_fpaces", "nb_resultsamps", "nb_Sacks", "nb_Siles", "nb_testsances", "nb_nsourses", "nb_splays", "nb_sacks", "nb_famples", "nb_eicks", "nb_Stones", "nb_fourses", "nb_famps", "nb_Samp", "nb_samps", "nb___resamps", "nb_seamples"], "pts": ["pointxs", "upts", "ntS", "iptts", "apts", "otries", "iptxs", "ppions", "aptps", "reqs", "aptxs", "reqxs", "posts", "uptxs", "points", "otS", "iptes", "PTts", "ptes", "pointts", "ppxs", "pters", "monts", "uptions", "PTns", "poss", "pps", "pointries", "pointds", "PTds", "PTS", "PTries", "reqions", "ptxs", "ptns", "montns", "montS", "apters", "pointS", "ppds", "PTxs", "ptds", "ppts", "periodds", "ntns", "aptts", "posps", "ptps", "ppers", "nts", "ptts", "PTs", "ipters", "uptds", "periodxs", "ipts", "ppes", "aptes", "reqds", "ptions", "periods", "periodts", "ptS", "ptries", "posxs", "ots", "iptps"], "duration": ["relation", "volume", "dates", "description", "generation", "frequency", "depth", "memory", "distance", "length", "database", "span", "d", "padding", "years", "confidence", "resolution", "dt", "fd", "Duration", "amount", "status", "capacity", "uration", "delay", "date", "performance", "ts", "video", "timeout", "version", "quality", "document", "directory", "size", "dose", "t", "metadata", "position", "during", "window", "time", "urations", "portion", "properties", "recorded", "period", "dimension", "sequence", "latest", "runtime", "century"]}}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n", "idx": 22652, "substitutes": {"bs": ["js", "gs", "ls", "bb", "rs", "bc", "sb", "vs", "gb", "bp", "bis", "ps", "fs", "blocks", "ds", "b", "cs", "bm", "ts", "ib", "ubis", "aos", "bles", "bh", "ubs", "BS", "ns", "lb", "pb", "its", "bps", "obs", "bi", "bf", "sys", "os", "lbs", "bas"], "base": ["reset", "basic", "profile", "bb", "p", "bar", "start", "parent", "file", "id", "name", "state", "sp", "sb", "super", "master", "bp", "cache", "ps", "based", "bit", "bound", "b", "prefix", "pse", "max", "history", "root", "as", "origin", "server", "extra", "bare", "db", "buffer", "pa", "target", "bu", "mb", "Base", "ase", "bi", "source", "bot", "h", "sys", "se", "st", "back", "bottom", "bas", "f", "boot", "bo"], "base_id": ["base_ids", " base_name", "base_link", " base_link", "base_ip", "baseuulink", "buffer_type", "baseuui", "base_name", "base__id", "buffer_ip", "base_type", " base_i", "baseuuname", "base__ip", "base__name", "buffer_id", "buffer_name", "buffer_ids", "base__ids", "baseuuid", "base_i"], "speed": ["EED", "command", "height", "frequency", "start", "imp", "length", "power", "port", "priority", "xff", " Speed", "Speed", "scale", "status", " speeds", "peg", "spe", "score", "sw", "sum", "prof", "size", "peed", "fast", "buffer", "driver", " size", "stream", "rank", "pri", "count", "mph", "sex", "fps", "slow", "weight", "fee", "seek"], "cb": ["ctx", "cp", "cfg", "ff", "CB", "cor", "callback", "bb", "cn", "bc", "ctrl", "sb", "CBS", "cgi", "tc", "gb", "nc", "cc", "cod", "good", "b", "proc", "c", "fn", "fc", "cs", "obb", "func", "db", "rb", "cd", "ck", "pb", "lb", "job", "bf", "cf", "rc", "fb", "fp", "cv"], "opaque": ["opica", "opaques", "opacity", "optaque", "ipaques", "optois", "ipula", " Opacity", "opque", "popatile", " Opaques", "bitatile", " opacity", "ipacity", " Opica", "ipica", "ipque", "ipois", " Opaque", "opula", " opque", "bitaque", "popacity", "popula", "popaque", "optque", "optacity", "ipatile", "opois", "opatile", "ipaque", "bitacity", "bitula", " opaques", " opica", " opois"], "errp": [" erps", "ferpa", "errpo", "rrps", "errr", "sprpa", " erwp", "sprpo", "ferp", " errr", "errwp", "rrpa", " erp", "errps", "sprr", " erpa", "rrp", " errwp", " errpo", "errpa", "ferpo", " errpa", " errps", "ferr", "rrwp", "sprp"], "s": ["js", "gs", "m", "a", "so", "sl", "ls", "ssl", "sq", "p", "sp", "es", "rs", "start", "o", "details", "w", "sb", "sol", "vs", "syn", "ps", "n", "eps", "y", "fs", "ds", "l", "ms", "b", "sh", "cs", "c", "single", "r", "ts", "ses", "j", "ss", "i", "stats", "t", "aws", "less", "plays", "g", "ns", "ins", "store", "hs", "services", "sing", "sam", "e", "scripts", "sts", "sv", "qs", "local", "h", "se", "os", "S", "space", "f", "is", "sports", "comm"], "co": ["ctx", "io", "fo", "wo", "gc", "mo", "so", "cor", "ci", "oc", "ko", "ano", "sp", "o", "soc", "lo", "CO", "or", "tc", "flo", "nc", "cm", " Co", "cc", "oe", "cover", "coe", "com", "c", "cs", "aco", "po", "go", "Co", "cycle", "pc", "ck", "cur", "con", "coord", "cons", "ro", "cro", "ico", "cu", "cf", "op", "vo", "coll", "bo"]}}
{"project": "FFmpeg", "commit_id": "2711cb28f46463760f0326d806fe5ef9551ade2c", "target": 1, "func": "static double get_diff_limited_q(MpegEncContext *s, RateControlEntry *rce, double q){\n\n    RateControlContext *rcc= &s->rc_context;\n\n    AVCodecContext *a= s->avctx;\n\n    const int pict_type= rce->new_pict_type;\n\n    const double last_p_q    = rcc->last_qscale_for[P_TYPE];\n\n    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];\n\n\n\n    if     (pict_type==I_TYPE && (a->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))\n\n        q= last_p_q    *FFABS(a->i_quant_factor) + a->i_quant_offset;\n\n    else if(pict_type==B_TYPE && a->b_quant_factor>0.0)\n\n        q= last_non_b_q*    a->b_quant_factor  + a->b_quant_offset;\n\n\n\n\n    /* last qscale / qdiff stuff */\n\n    if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){\n\n        double last_q= rcc->last_qscale_for[pict_type];\n\n        const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;\n\n\n\n        if     (q > last_q + maxdiff) q= last_q + maxdiff;\n\n        else if(q < last_q - maxdiff) q= last_q - maxdiff;\n\n    }\n\n\n\n    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring\n\n\n\n    if(pict_type!=B_TYPE)\n\n        rcc->last_non_b_pict_type= pict_type;\n\n\n\n    return q;\n\n}", "idx": 22655, "substitutes": {"s": ["js", "gs", "m", "ls", "p", "sq", "es", "rs", "times", "w", "d", "sb", "ps", "n", "cc", "fs", "ds", "sa", "b", "c", "cs", "settings", "r", "as", "ses", "ss", "i", "aws", "set", "ns", "ins", "hs", "e", "sts", "sv", "h", "ats", "x", "os", "se", "sys", "S", "ex", "v"], "rce": [" rces", "prCE", "mCE", "prces", "prce", "RCE", "arces", " rCE", "prcle", "arCE", "mrces", "rcle", "arcle", "mce", "mrCE", "mces", "arce", "Rcle", "rCE", "mcle", "mrce", " rcle", "mrcle", "Rce", "Rces", "rces"], "q": ["pkg", "cp", "m", "check", "sq", "p", "pp", "qa", "qt", "Q", "z", "req", "quit", "eq", "w", "d", "qu", "question", "aq", "y", "it", "force", "shift", "ue", "l", "bit", "qi", "quick", "lock", "load", "requ", "query", "print", "quality", "t", "k", "g", "u", "quad", "f", "ip", "iq", "comment", "out", "e", "ll", "ch", "qs", "qv", "h", "queue", "x", "qual", "dq", " Q", "place", "weight", "qq", "quest", "quant", "charge"], "rcc": ["mcc", "rpc", "rco", "crce", "krcraft", "wck", " rtc", "crtc", "rtd", "rct", "recc", "rrcy", "radbo", "Rct", "srctl", "nrCC", "erce", "wacc", " rct", "srcraft", "rcca", "krac", "rcck", "wco", "ercca", "mpc", "errcc", "rardd", "rcacc", "wcc", " racc", "rccell", "rac", "mce", "Rcc", "nrcy", "eracc", "radcc", "radcell", "srcca", "errcci", " rac", "rrtd", "srac", "rcy", " rck", " rcci", "crck", "rctd", "mcca", "errcy", " rcell", "rcci", "crcc", "rbo", "krctl", "nrcc", "ercc", "rctl", "nrcci", " rco", "rccc", "rece", "rrcell", "rrcci", "sracc", "srce", "rrcc", "rarcc", "errctl", "rarcell", "erck", "rartd", "rtc", "radacc", "rdd", "rrctl", "krcc", " rcraft", " rCC", "Rcci", "rcdd", "rCC", "racc", "rck", "RCC", "reck", "rracc", "erpc", "nrct", "retc", "rrdd", " rctl", " rbo", "rrbo", "nrctl", "rcraft", "rcell", "srpc", "srcc", "srck", "rcco"], "a": ["ac", "any", "dev", "ast", "A", "acc", "p", "ca", "es", "am", "at", "aj", "or", "ga", "apa", "w", "ak", "common", "ea", "ab", "era", "aff", "aw", "att", "sa", "b", "ae", "aa", "an", "c", "access", "er", "as", "aux", "app", "angular", "img", "i", "da", "act", "ai", "t", "ar", "na", "area", "set", "sta", "ma", "element", "pa", "ed", "ache", "f", "al", "eas", "oa", "window", "el", "ao", "abc", "au", "all", "e", "h", "aka", "ee", "ata", "attribute", "ia", "ack"]}}
{"project": "FFmpeg", "commit_id": "67400f6b6219892ab7a555fb61ef979c857692d7", "target": 0, "func": "static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n\n    int64_t pos = avio_tell(pb);\n\n\n\n    if (!track) { /* no media --> data handler */\n\n        hdlr      = \"dhlr\";\n\n        hdlr_type = \"url \";\n\n        descr     = \"DataHandler\";\n\n    } else {\n\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n\n        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            hdlr_type = \"vide\";\n\n            descr     = \"VideoHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            hdlr_type = \"soun\";\n\n            descr     = \"SoundHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = \"sbtl\";\n\n            else                                      hdlr_type = \"text\";\n\n            descr = \"SubtitleHandler\";\n\n        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {\n\n            hdlr_type = \"hint\";\n\n            descr     = \"HintHandler\";\n\n        }\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"hdlr\");\n\n    avio_wb32(pb, 0); /* Version & flags */\n\n    avio_write(pb, hdlr, 4); /* handler */\n\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track || track->mode == MODE_MOV)\n\n        avio_w8(pb, strlen(descr)); /* pascal string */\n\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n\n    if (track && track->mode != MODE_MOV)\n\n        avio_w8(pb, 0); /* c string */\n\n    return update_size(pb, pos);\n\n}\n", "idx": 22662, "substitutes": {"pb": ["ctx", "cp", "pkg", "xp", "gc", "uf", "tp", "pack", "bb", "p", "np", "pp", "erb", "bs", "nb", "sp", "pr", "ub", "orp", "bc", "pad", "td", "jp", "pm", "tmp", "sb", "tc", "wb", "gb", "bp", "pan", "pl", "mp", "b", "stab", "wp", "proc", "tab", "vp", "tk", "PB", "pt", "func", "aus", "bh", "bj", "rb", "buffer", "pc", "patch", "amp", "asm", "lb", "dp", "mb", "buf", "resp", "emb", "lp", "fb", "fp", "cb", "px", "pool", "pg"], "track": ["pkg", "check", "train", "transform", "hold", "tc", "kick", "sound", "feature", "roll", "order", "set", "tn", "rank", "store", "record", "package", "tf", "call", "trace", "cp", "try", "tp", "jp", "parse", "tag", "range", "trak", "tm", "rack", "rt", "config", "find", "Track", "move", "upload", "comment", "jump", "save", "tracks", "seek", "ack", "require", "report", "add", "sort", "tr", "tt", "req", "send", "scan", "stack", "staff", "skip", "metadata", "txt", "ck", "tracking", "row", "param", "form", "rule", "sys", "batch", "claim", "th", "contact", "btn", "complete", "task", "sync", "tab", "tk", "cmd", "trip", "t", "match", "job", "rec", "index", "rr", "rm", "mt", "bind"], "hdlr": ["hdrl", "hydlly", "wdhl", "edlt", "hLR", "edLR", "mdler", "dhhr", "handler", "HDlr", "hdLR", "dhlr", "dhhl", "hrl", "hlr", "hlt", "handlr", "hydlr", "hydler", "hdlly", "wdrl", "hdurl", "hhr", "dhrl", "edrl", "wdlr", "mdLR", "handrl", "hdhl", "dhurl", "HDurl", "edlr", "hdhr", "hdler", "hydrl", "HDhr", "mdlt", "handlly", "hler", "hdlt", "HDler", "dhler", "mdlr", "mdhl", "wdler", "mdlly", "mdrl", "hurl"], "descr": ["DESerr", " descrb", "specn", "hdres", "escral", "escl", "Descur", "Descerr", "descral", "riptur", "DescR", "descur", "Desctr", "descriptionlr", " descrs", "descrb", "descsr", "Descrl", "descrs", "hdral", "reasonsr", "descrl", "descriptionbr", "descbr", "scrb", "specrs", "desur", "riptral", "desl", "descl", " descn", "scR", "desr", " descR", "escR", "Descrs", "descre", "desrl", "hdr", " descrem", "riptR", "riptr", "descriptionrt", "Descrb", "descres", "riptre", "descerr", " descbr", "descriptionsr", "DESr", "reasonr", "descrt", "descriptionr", " descl", "scl", " descrt", "descriptionres", "spectr", "specrt", "riptlr", "desctr", " desctr", "hdsr", "escrl", "Descrr", "esclr", "descR", " descerr", "desclr", "Descl", "specbr", "Descre", "Descr", " descres", "hdrem", "descn", "reasonrs", "specr", "reasonrem", "Descn", "hdR", "Desclr", " desclr", "descrem", "DESrr", "DESrs", "desR", "scr", "desre", "descrr", "descriptionrs", "deslr", "specsr", " descsr", "escr", " descrr", "hdrs"], "hdlr_type": ["hdrl_TYPE", "hdlr_types", "hdl_type", "hdlr_operator", "hdr_role", "hdrex_type", "hdlr___role", "hdlr_TYPE", "hdlr_Type", "hdlr_ver", "hdr_TYPE", "hdlr0type", "hdrl_role", "hdlr_name", "hdr_type", "hdr_result", "hdlr_file", "hddr_TYPE", "hdl_name", "hddr_style", "hdlr_role", "hdr_types", "hdlr_result", "hdlr0table", "hdlr_style", "hdl_tag", "hdr_table", "hdrex_operator", "hdrl_ver", "hdlr___TYPE", "hdlr_table", "hdlr___type", "hdlr___result", "hdrl_ype", "hdlr_pe", "hdrl_type", "hdrl_tag", "hdrl_name", "hdrex_pe", "hdl_role", "hdlr0Type", "hdrex_tag", "hddr_type", "hdlr_ype", "hdlr_tag", "hdrl_file", "hddr_name", "hdr_Type", "hdlr0types"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22683, "substitutes": {}}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693, "substitutes": {"file": ["File", "command", "check", "dir", "report", "bar", "full", "required", "name", "type", "word", "filename", "image", "path", "port", "user", "complete", "field", "forced", "ile", "chain", "files", "line", "address", "template", "format", "print", "message", "db", "buffer", "page", "key", "foo", "link", "channel", "entity", "event", "e", "null", "source", "base", "class", "local", "rule", "view", "resource", "given", "model", "enable", "fp", "valid", "block", "f", "table", "email", "le", "present"]}}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int srt_probe(AVProbeData *p)\n\n{\n\n    const unsigned char *ptr = p->buf;\n\n    int i, v, num = 0;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3;  /* skip UTF-8 BOM */\n\n\n\n    while (*ptr == '\\r' || *ptr == '\\n')\n\n        ptr++;\n\n    for (i=0; i<2; i++) {\n\n        if ((num == i || num + 1 == i)\n\n            && sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)\n\n            return AVPROBE_SCORE_MAX;\n\n        num = atoi(ptr);\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22702, "substitutes": {"p": ["cp", "pkg", "m", "tp", "q", "data", "pp", "o", "jp", "w", "d", "bp", "n", "P", "mp", "b", "s", "c", "r", "j", "t", "g", "pc", "pa", "dp", "pb", "ap", "buf", "a", "h", "fp", "f"], "ptr": ["pointers", "grad", "sp", "adr", "pend", " pointer", "fd", "assert", "address", "dr", "pt", "pc", "rev", "cur", "buf", "md", "grow", "ind", "Ptr", "arr", "inters", "dep", "ctx", "uf", "tp", "ps", "shift", "each", "inter", "buff", "ts", "iter", "pointer", "pos", "desc", "ctr", "js", "hr", "vector", "cert", "depth", "td", "pad", "tr", "req", "push", "loc", "length", "scroll", "pert", "fr", "br", "offset", "rep", "proc", "r", "deg", "obj", "hl", "fp", "alloc", "rel", "th", "heads", "prim", "ped", "pr", "src", "pl", "expr", "dh", "lr", "sh", "cmd", "tor", "prime", "buffer", "ref", "coord", "off", "eth", "cro", "index", "addr"], "i": ["hi", "m", "num", "ci", "ix", "o", "id", "si", "zi", "multi", "um", "n", "ei", "y", "it", "xi", "l", "ij", "ti", "mi", "qi", "iu", "c", "s", "j", "di", "in", "\u0438", "ai", "t", "im", " ni", "ie", "ki", " ii", "u", "ui", "fi", "ic", "li", "ip", "sim", "ish", "ini", "bi", "ind", "index", "ii", "x", "pi", "I", "f", "is"], "v": ["V", "m", "tv", "vv", "vt", "vc", "q", "ev", "w", "vs", "av", "va", "n", "vm", "y", "l", "b", "c", "j", "uv", "lv", "t", "k", "u", "g", "vr", "cv", "nv", "sv", "conv", "qv", "h", "x", "vi", "f"]}}
{"project": "qemu", "commit_id": "7faa8075d898ae56d2c533c530569bb25ab86eaf", "target": 1, "func": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n", "idx": 22705, "substitutes": {"s": ["js", "gs", "m", "south", "so", "spec", "ls", "p", "sq", "es", "sp", "rs", "state", "w", "d", "sb", "sports", "n", "bis", "ps", "fs", "ims", "ds", "self", "status", "b", "ms", "c", "cs", "sw", "ts", "j", "ses", "ss", "stats", "t", "aws", "set", "g", "ns", "hs", "e", "sts", "sv", "qs", "h", "ats", "se", "sys", "S", "st", "sd", "is", "pers", "v"], "dev": ["fo", "serial", "pub", "grad", "ve", "ev", "pad", "conf", "tech", "loc", "Dev", "d", "ver", "def", "eng", "des", "conn", "disc", "DEV", "test", "develop", "gu", "wd", "serv", "enc", "act", "devices", "dn", "res", "pro", "dem", "dd", "var", "de", "device", "buf", "desc", "pri", "cam", "adv", "mem", "hw", "priv", "ad", "vo", "boot", "sd", "v", "val"], "bus": ["dir", "bridge", "us", "bar", "Bus", "bs", "data", "BUS", "mount", "box", "bc", "loc", "user", "bill", "bur", "vol", "b", "chain", "proc", "lock", "root", "board", "host", "pos", "loop", "bolt", "phys", "driver", "buf", "local", "sys", "os", "way", "back", "block", "pool", "boot"], "qdev": ["quver", "qqev", "qqserv", "pver", "quev", "QDev", "pev", "qdiv", "hdev", "hev", "Qdev", "qDev", " qdiv", "qver", "qudev", "qqver", "qudevice", " qdata", "qdata", "quserv", "qbus", "pbus", "iqdevice", "qserv", "pserv", "Qev", " qev", "hbus", "iqdiv", "qudata", "qudiv", " qDev", "hDev", "qqdev", "iqdev", "Qdevice", "qev", "iqdata", " qbus", "pDev", "pdevice", " qdevice", "qdevice"], "next": ["current", "li", "sq", "data", "z", "seq", "path", "tmp", "ptr", "Next", "nn", "future", "chain", "proc", "nl", "gen", "node", "net", "network", "prev", "output", "first", "sub", "ner", "child", "ng", "txt", " NEXT", "ns", "link", "adj", "buf", "sec", "bi", "after", "new", "children", "sequence", "nr", "ne"], "pdev": ["ptDev", "ptdev", " pgu", "pidev", "pden", " pden", "ppdevice", "pkgdev", "pev", "ppgu", "pkgev", "ppDev", "Pdef", "Pev", "piev", "qdes", "ppdev", " pdes", "pdef", "ptgu", "Pdev", " pdevice", " pev", "Pden", "pkgdevice", " pdef", "pdes", "pkgdes", "pgu", " pDev", "ptdevice", "qev", "pidef", "piden", "pDev", "pdevice", "qdevice"], "pc": ["ac", "cp", "ctx", "p", "vc", "pp", "soc", "pr", "bc", "pm", "tc", "ps", "nc", "mc", "cc", "pl", "disc", "mp", "proc", "c", "cs", "fc", "lc", "psc", "pt", "pa", "dc", "pn", "pb", "pod", "PC", "cam", "pic", "lp", "pi", "px"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 22709, "substitutes": {"job": ["jj", "program", "manager", "image", "jp", "web", "gov", "band", "low", "project", "module", "Job", "com", "jobs", "ob", "task", "j", "cmd", "node", "org", "jam", "build", "map", "jar", "process", "work", "group", "obs", "row", "queue", "batch", "dq", "block", "pool", "hub", "cell"], "speed": ["EED", "command", "spec", "frequency", "start", "when", "wage", "length", "power", "port", "distance", "Speed", "scale", "species", "percent", "payment", "ly", "status", "capacity", " speeds", "spe", "gravity", "limit", "send", "score", "sw", "delay", "rate", "performance", "ss", "density", "gain", "sum", "shape", "size", "efficiency", "peed", "fast", "rank", "slice", "mph", "time", "shock", "fps", "slow", "weight", "seek", "sports"], "errp": [" errP", "hrphp", "ferp", " errphp", "errpe", "ferP", " erpb", "diep", "errpb", "hrP", "errphp", " erP", " erpe", " erp", " errpe", "dieP", " errpb", "ferphp", "hrp", "errP", "diepb", "diepe"], "s": ["js", "gs", "m", "sl", "ls", "q", "sq", "p", "sp", "rs", "bs", "d", "sb", "ps", "fs", "ds", "b", "c", "ess", "r", "ts", "j", "ss", "t", "g", "ns", "a", "sam", "sv", "sys", "h", "S", "f", "is", "v"]}}
{"project": "FFmpeg", "commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "target": 1, "func": "static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n", "idx": 22718, "substitutes": {"avctx": [" avconn", "evctx", " avcontext", "vcontext", "avcmp", "evcontext", "evconn", "avconn", "AVtx", " avcmd", "evcmp", "AVcmp", "AVconn", "vctx", " avcmp", "AVcmd", "avcontext", "AVctx", " avtx", "avcmd", "vcmd", "vtx", "avtx", "AVcontext"], "ctx": ["cfg", "cp", "pkg", "xp", "check", "command", "gc", "np", "parent", "req", "loc", "kt", "jp", "ctrl", "xc", "ann", "tc", "nc", "cm", "Context", "cc", "sc", "cl", "ork", "settings", "lib", "kw", "tx", "config", "lc", "cmd", "nt", "pt", "timeout", "comm", "act", "args", "jac", "txt", "ck", "desc", "cons", "window", "cam", "obj", "cu", "context", "conv", "crit", "cf", "hw", "vals", "cmp", "kl", "ctl", "cv", "ct"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 22741, "substitutes": {"path": ["pkg", "m", "dir", "p", "transform", "file", "Path", "name", "type", "filename", "mat", "loc", "w", "value", "n", "chain", "prefix", "PATH", "c", "fn", "ATH", "template", "cmd", "node", "pointer", "pt", "format", "txt", "f", "ref", "con", "out", "eth", "pattern", "mem", "context", "package", "str", "err", "th", "mt", "ath"], "un": ["UN", "m", "uf", "num", "old", "ur", "add", "mod", "su", "unk", "util", "unit", "um", "unt", "n", " UN", "uns", "san", "aw", "don", "fun", "uni", "vol", "an", "ou", "ran", "scan", "tun", "gun", "node", "unknown", "ut", "unn", "gn", "sum", "pos", "uc", "det", "u", "not", "en", "Un", "unc", "from", "open", "ul", "und", "mun", "il", "other", "con", " Un", "out", "run", "una", "sun", "kun", "local", "index", "une", "cal", "new", "bo"], "sock": [" Src", " socks", "jsocked", "gesock", "SOCK", "rsock", "soot", " sig", " sox", "isix", "jsock", "tix", "nsox", "sig", " skg", "tsrc", " soy", "socked", "getsox", "sinoot", "getsock", "getsOCK", "Sock", "sinocked", "Socked", "sinix", "rsix", "nsock", "nsix", "nsocked", "rsocks", "socks", "stsock", "isock", "tsocks", "isocks", "tsocked", "sinocks", "isoot", " sOCK", "rsocked", "stsig", "tock", "sinock", "sox", "skg", "gesocked", "stsrc", "nsrc", "jsix", " Socked", "src", "tsock", " Sock", "getsocked", " Sig", "gesOCK", " socked", "tocks", "jskg", "nsocks", "toot", "sOCK", "six", "stsocked", " six", "gesox", "Soy", "soy", " src"]}}
{"project": "qemu", "commit_id": "d9e0dfa2462e32cc5c6c49401ad7bff36453f75c", "target": 0, "func": "void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    Error *local_err = NULL;\n\n\n\n    memset(&bs->bl, 0, sizeof(bs->bl));\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* Default alignment based on whether driver has byte interface */\n\n    bs->request_alignment = drv->bdrv_co_preadv ? 1 : 512;\n\n\n\n    /* Take some limits from the children as a default */\n\n    if (bs->file) {\n\n        bdrv_refresh_limits(bs->file->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;\n\n        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;\n\n        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;\n\n        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;\n\n        bs->bl.max_iov = bs->file->bs->bl.max_iov;\n\n    } else {\n\n        bs->bl.min_mem_alignment = 512;\n\n        bs->bl.opt_mem_alignment = getpagesize();\n\n\n\n        /* Safe default since most protocols use readv()/writev()/etc */\n\n        bs->bl.max_iov = IOV_MAX;\n\n    }\n\n\n\n    if (bs->backing) {\n\n        bdrv_refresh_limits(bs->backing->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = MAX(bs->bl.opt_transfer,\n\n                                  bs->backing->bs->bl.opt_transfer);\n\n        bs->bl.max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                           bs->backing->bs->bl.max_transfer);\n\n        bs->bl.opt_mem_alignment =\n\n            MAX(bs->bl.opt_mem_alignment,\n\n                bs->backing->bs->bl.opt_mem_alignment);\n\n        bs->bl.min_mem_alignment =\n\n            MAX(bs->bl.min_mem_alignment,\n\n                bs->backing->bs->bl.min_mem_alignment);\n\n        bs->bl.max_iov =\n\n            MIN(bs->bl.max_iov,\n\n                bs->backing->bs->bl.max_iov);\n\n    }\n\n\n\n    /* Then let the driver override it */\n\n    if (drv->bdrv_refresh_limits) {\n\n        drv->bdrv_refresh_limits(bs, errp);\n\n    }\n\n}\n", "idx": 22752, "substitutes": {"bs": ["bb", "rs", "points", "fs", "bel", "els", "vers", "cs", "stats", "aus", "bles", "pb", "its", "ks", "ins", "actions", "bps", "bf", "os", "bsp", "uts", "cb", "bed", "cases", "ls", "aks", "es", "hz", "ads", "bes", "vs", "outs", "bp", "ps", "acs", "ds", "jobs", "bm", "ts", "abilities", "lets", "ubis", "bh", "ubs", "BS", "ils", "ports", "lbs", "bys", "js", "gs", "sels", "rots", "eb", "bing", "irms", "bits", "otes", "blog", "bis", "css", "blocks", "iffs", "ms", "ses", "aws", "bl", "boxes", "hs", "obj", "sts", "books", "sys", "ats", "bas", "bn", "tops", "banks", "bc", "sb", "blogs", "bytes", "ics", "as", "ib", "ys", "aos", "ns", "cks", "changes", "obs", "bi", "ables", "qs", "bos", "als", "nuts", "vals", "ops", "bec"], "errp": ["errorP", "nerp", "iterps", " errpy", "iterP", " errP", " errh", "scorepy", "nerP", "rerp", "rerh", "errorpb", "scoreP", "errpy", "iterpy", "errpb", "errorp", "rrpa", "errorpa", "errps", "nerpb", "nerpa", "scorep", "rrp", "iterp", "errh", "rerpa", " errpb", "errpa", "errP", " errpa", "scoreps", " errps", "rrh"], "drv": ["rdver", "drg", "hdver", "drvd", "drivd", " drV", "hdvc", "brv", "derv", "derp", "srv", "crv", "hdv", "rdv", "mrvc", "hrg", "srp", "drver", " drvc", "derver", "hdvd", "brvd", "hrV", "drp", "drivc", "mrg", "mrV", "drV", " drvd", "srver", "brver", "crsv", " drsv", "mrv", "drsv", " drg", "driver", "srg", "crV", "hrvc", "crvd", "rdp", "hrv", "driV", "derg", "drvc", "driv", "drisv", "brvc", "rdg"], "local_err": ["localFer", "unique_priv", "internal_err", "unique_hr", " local_cr", "localableerr", "unique\u064epriv", "local_hr", "local_notice", "local\u064epriv", "unique_css", "localederr", "localablenotice", "local_rr", "localFerr", "locallybr", "localableerror", " local_gz", "localewcss", "locallyhr", "local_gz", "local___notice", "local_er", "uniqueewpriv", "localablecss", "local_br", "local\u064ebr", "unique_error", "local\u064ehr", "local_cfg", " local_cfg", "locallypriv", "local_priv", "localablerr", "localFinv", " local_css", "localybr", "local_cr", "unique\u064ebr", " local_er", "local_error", "uniqueewerr", "localablepriv", "localedcss", "internal_rr", "localewerr", "local_css", "unique\u064eerr", "localFcr", " local_inv", "unique_err", "internal_notice", "localyerr", "localypriv", "localedcfg", "unique\u064ehr", "local\u064eerr", "locallyerr", "local___css", "internal_priv", "local___err", "local_inv", "uniqueewerror", " local_notice", "unique_br", "localewerror", "localednotice", "localyhr", "localewpriv", "uniqueewcss"]}}
{"project": "qemu", "commit_id": "8a5bb1f114c5959cf6b247a737394afb0c518b40", "target": 0, "func": "static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n\n                           BdrvCheckMode fix, bool *rebuild,\n\n                           void **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t i, size;\n\n    int ret;\n\n\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        uint64_t offset, cluster;\n\n        offset = s->refcount_table[i];\n\n        cluster = offset >> s->cluster_bits;\n\n\n\n        /* Refcount blocks are cluster aligned */\n\n        if (offset_into_cluster(s, offset)) {\n\n            fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \"\n\n                \"cluster aligned; refcount table entry corrupted\\n\", i);\n\n            res->corruptions++;\n\n            *rebuild = true;\n\n            continue;\n\n        }\n\n\n\n        if (cluster >= *nb_clusters) {\n\n            fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" : \"ERROR\", i);\n\n\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                int64_t new_nb_clusters;\n\n                Error *local_err = NULL;\n\n\n\n                if (offset > INT64_MAX - s->cluster_size) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                ret = bdrv_truncate(bs->file, offset + s->cluster_size,\n\n                                    &local_err);\n\n                if (ret < 0) {\n\n                    error_report_err(local_err);\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file->bs);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if (s->get_refcount(*refcount_table, cluster) != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%\" PRIu64 \"\\n\", i,\n\n                        s->get_refcount(*refcount_table, cluster));\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22759, "substitutes": {"bs": ["ctx", "js", "gs", "meta", "ls", "bb", "rs", "bits", "las", "bc", "ba", "sb", "vs", "bp", "br", "bis", "ps", "bytes", "fs", "ds", "bit", "b", "access", "cs", "as", "ts", "bitcoin", "ss", "ubis", "aos", "bles", "bh", "aws", "aus", "bl", "ubs", "BS", "ns", "lb", "pb", "its", "boxes", "ins", "bps", "hs", "obs", "bi", "obj", "base", "http", "qs", "bos", "os", "lbs", "ops", "ex", "bas", "is", "locks"], "res": ["der", "ox", "reset", "response", "rest", "rs", "pr", "details", "req", "resources", "ps", "resolution", "red", "rem", "rss", "result", "expr", "RES", "prefix", "ms", "gr", "r", "comm", "results", "reg", "rez", "rev", "re", "resp", "cons", "out", "Res", "ro", "ress", "resh", "rec", "usr", "ber", "resource", "rr", "pres", "vals", "rel", "rek", "progress", "rc", "val"], "fix": ["check", "get", "ix", " del", " format", "diff", "pack", "make", "add", " pack", "conf", " fixes", "Fix", "bin", "def", "correct", "dirty", "test", "init", "fixes", "bit", "prefix", " patch", "mix", " get", " clear", "fail", " def", "set", " FIX", "update", " edit", "patch", "replace", " fixing", "bug", "general", " prefix", "gem", "issue", "major", "call", " init", "mask", "commit", "FIX", " diff", "valid", " Fix", "edit", "block", "clear", "use"], "rebuild": ["regbuild", "regconstruct", "reconstruct", "robuilt", " rebuilding", " reuild", "Rebuild", "Rebuilt", "reguild", "reuild", " rebuilt", "Rebuilding", "rebuilt", "robuild", "roconstruct", "robuilding", " reburn", " reconstruct", "Reburn", "Reconstruct", "Reuild", "rebuilding", "regburn", "reburn"], "refcount_table": ["refcount_array", "refcount2data", "refcount2list", "refcount_db", "refcount_TABLE", "refCount_list", "refcount___list", "refcount2table", "refcount_data", "refcountttable", "refCount_data", "refcount_able", "refcounttdb", "refcache_list", "refcount_list", "refcounttarray", "refcount___TABLE", "refcache_TABLE", "refcounttmap", "refcache_able", "refcount___able", "refcache_table", "refcount2map", "refCount_table", "refcount_map", "refcount___table", "refCount_map"], "nb_clusters": ["nb_collanches", "nb_cluster", "nb_combodes", "nb_plusters", "nb_plodes", "nb_collroups", "nb_plroups", "nb_constures", "nb_CLanches", "nb_colliders", "nb_combroups", "nb_clures", "nb_clients", "nb2pluster", "nb_conusters", "nb_conroups", "nb_constroups", "nb_conanches", "nb_constuster", "nb2clusters", "nb_clroups", "nb_glroups", "nb_combuster", "nb_colusters", "nb_plures", "nb2clients", "nb_cliders", "nb_glients", "nb_coluster", "nb_clodes", "nb_CLusters", "nb_colients", "nb_colroups", "nb2clroups", "nb_colures", "nb_clanches", "nb_constusters", "nb_colodes", "nb2plusters", "nb_CLroups", "nb_pluster", "nb2plients", "nb_coniders", "nb_CLiders", "nb_combusters", "nb_collusters", "nb2plroups", "nb_glusters", "nb2cluster", "nb_gluster", "nb_plients"], "s": ["js", "gs", "spec", "ssl", "sl", "ls", "sq", "p", "es", "rs", "bits", "details", "times", "sb", "vs", "parts", "ps", "y", "fs", "ims", "ds", "b", "ms", "cs", "ess", "sw", "ts", "ses", "serv", "j", "ss", "stats", "aws", "less", "g", "ashes", "ns", "series", "ins", "its", "hs", "a", "sam", "sts", "sv", "qs", "xs", "sys", "ats", "h", "os", "http", "S", "als", "is", "comm"], "i": ["m", "ci", "ix", "p", "us", "o", "v", "id", "si", "multi", "zi", "ori", "n", "ei", "y", "it", "init", "xi", "ims", "ij", "l", "ti", "mi", "b", "info", "c", "iu", "qi", "ski", "j", "di", "ai", "t", "set", "uri", "ui", "phi", "ic", "li", "gi", "ip", "sim", "iq", "ri", "cli", "slice", "is", "ini", "bi", "ind", "e", "oi", "index", "ii", "x", "pi", "batch", "iri", "I", "ki", "im"], "size": ["height", "mini", "num", "export", "start", "sp", "body", "z", "name", "SIZE", "si", "length", "small", "padding", "range", "scale", "Size", "n", "resolution", "bytes", "capacity", "max", "large", "too", "send", "address", "storage", "empty", "sum", "shape", "extra", "set", "area", "g", "gz", "error", "sample", "news", "total", "count", "len", "number", "grow", "zero", "mem", "package", "sized", "ize", "new", "fee", "err", "dim", "space", "zone"], "ret": ["tmp", "ext", " Ret", "lit", "nt", "ft", "set", "rev", "resp", "ll", "arg", "after", "nz", "x", "RET", "prot", "f", "try", "Return", "Ret", "it", "dt", "att", "fun", "rt", "iter", "flag", "print", "net", " RET", "val", "hash", "len", "rets", "back", "reset", "vector", "alt", "tr", "ptr", "rem", "status", "rep", "limit", "r", "deg", "total", "re", "str", "ber", "err", "elt", "rel", "opt", "ter", "def", "far", "value", "result", "expr", "j", "cmd", "t", "det", "ref", "out", "number", "code", "zero", "mem", "gt", "rm", "mt", "response", "final"], "offset": ["volume", "reset", "start", "o", "tile", "iso", "alias", "memory", "id", "slot", "loc", "length", "lag", "padding", "range", "shift", "absolute", "Offset", "style", "prefix", "oint", "address", "top", "lower", "offs", "item", "location", "origin", "point", "pointer", "pos", "timeout", "set", "area", "error", "ui", "buffer", "key", "seek", "position", "ref", "total", "slice", "count", "balance", "window", "et", "off", "len", "link", "coord", "row", "zero", "base", "tz", "index", "oid", "addr", "oot", "block", "f", "table"], "cluster": ["colluster", "scluster", "collus", "slause", " clignment", "glard", "slust", "clclient", "chus", "gloser", "locard", "locoser", " clclient", "collignment", "sclust", "colloser", "gluster", "card", "sluster", "glause", "lard", "glorable", "choser", "cust", "locus", "chuster", "loser", "sclorable", "clust", "luster", "clus", "coser", "closer", "collclient", "slorable", "locuster", "lust", "glignment", " closer", "chard", "clard", "glclient", "collard", "sclause", "clignment", "glust", "clause", "custer", "clorable"], "corruptions": ["corconnectures", "corruptedions", "interconnectures", "corruptors", "corruptedurations", "corconnecturations", "interruptors", "interconnectors", "corrupturations", "interrupturations", "interruptions", "interconnecturations", "interruptures", "corruptures", "corruptedors", "corconnectors", "corruptedures", "interconnections", "corconnections"], "new_nb_clusters": ["new_nb2clients", "new_nb_cients", "new_nb_plusters", "new_nb_glusters", "new_nb_blroups", "new_nb_custer", "new_nb_cousters", "new_nb_pliants", "new_nb_custers", "new_nb_plients", "new_nb\u043dcliants", "new_nb2Clroups", "new_nb_coroups", "new_nb_comusters", "new_nb_gliants", "new_nb_clusients", "new_nb2Clients", "new_nb_Cluster", "new_nb_clususters", "new_nb\u043dclususters", "new_nb_cliants", "new_nb_glients", "new_nb_clusiants", "new_nb_plroups", "new_nb2clusters", "new_nb_Clusters", "new_nb_blusters", "new_nb_couster", "new_nb2Clusters", "new_nb2clroups", "new_nb_Clroups", "new_nb\u043dclients", "new_nb_clroups", "new_nb_Clients", "new_nb_clususter", "new_nb_comroups", "new_nb\u043dcluster", "new_nb_cluster", "new_nb_gluster", "new_nb_comients", "new_nb_pluster", "new_nb_clients", "new_nb\u043dclusiants", "new_nb_comuster", "new_nb_blients", "new_nb_glroups", "new_nb\u043dclusters", "new_nb\u043dclususter", "new_nb\u043dclusients", "new_nb_coients"], "local_err": ["localErvar", " local_usr", "local___dec", "local_dec", " local_rr", "labelErvar", "locallyrr", "localErerr", "label_str", "localErdec", "local_er", "local_later", "locallyusr", " local_er", " local_error", "local___str", "local____err", "locallyerr", "local_usr", "locallystr", "local_error", "local____error", " local_later", "local_r", "local___err", "labelErstr", "local_str", "labelErerr", " local_r", "local_var", "local___usr", "label_err", "local____later", "labelErdec", "local___er", "label_var", "local___rr", "localErstr", "label_dec", "local_rr", "locallydec", "locallyvar", "local____r", "local___var", "locallyer"], "check_errors": ["checkCounterrors", "check_fail", "check_failed", "read_errors", "read_failed", "checkptfail", "checkCountfailed", "checkptfailed", "check_error", "checkCounterror", "read_error", "read_fail", "checkpterrors", "checkpterror", "checkCountfail"], "corruptions_fixed": ["corruptions___total", "corruptures_added", "corruptions___fixed", "corruptions_checked", "corruptions_added", "corruptures_fixed", "corruptions___checked", "corruptions___added", "corruptions_total", "corruptures_total", "corruptures_checked"]}}
{"project": "qemu", "commit_id": "bb44619b06c0bef20b658ff532cf850c16362ae7", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    BlockIOLimit io_limits;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= BDRV_O_CACHE_WB;\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n\n                           qemu_opt_get_number(opts, \"bps\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n\n                           qemu_opt_get_number(opts, \"iops\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n\n\n\n    if (!do_check_io_limits(&io_limits, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = opts;\n\n    dinfo->refcount = 1;\n\n    dinfo->serial = serial;\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 22801, "substitutes": {"opts": ["popTs", " oprs", "oppls", "optals", "experms", " optfs", " copTs", "opttm", "atuts", "opms", " optm", " oppt", "popgt", "experals", " opgs", " optes", "opTS", " optts", " opals", "OPs", "iopts", " optrs", "popTS", "optrs", "props", "eduts", "edters", " optt", "OPls", "optuts", "OPt", " opt", " optsys", "prot", "opouts", "oppgt", "optm", "optsm", "oppts", "optcs", "OPts", "roups", "expergs", " copls", "iopcs", "experts", "edt", "argts", "att", "optts", "edts", "experfs", "opps", "argpt", "atts", "OPps", "argls", "optes", "opttes", "iopps", " opls", "opals", "poppt", "optt", "optds", "opls", " opps", "iopTS", "popts", "expertm", "iopt", " opsys", "optms", "routs", "experbs", " opouts", "opsm", "argTS", " ops", " opbs", "experrs", "popcs", " opsm", "oputs", "iops", "opcs", "iopouts", "optsys", "prots", "optpt", " opttes", "opt", "opters", "OPds", "optouts", "opsys", " opfs", "olybs", "olyts", "optTS", "opds", "opTs", " optouts", "atters", "opbs", "popls", "rououts", " optsm", "optters", "oppt", "opgt", "iopters", "optls", "opfs", "oppTs", "olyfs", " opds", " opms", " copts", "pros", "opgs", "optfs", "oprs", " optters", "olygs", " opters", "ops", " copgt", "routers", "popt", "experpt"], "block_default_type": ["block_block_type", "block_block_info", "block_default_Type", "block_default2type", "block_default_info", "block_block_Type", "block_default_types", "block_default2types", "block_default2Type", "block_default2info", "block_block_types"], "buf": ["pkg", "dev", "cp", "uf", "dir", "data", "seq", "bc", "box", "bin", "port", "tmp", "br", "Buffer", "bytes", "bus", "test", "ob", "b", "text", "buff", "raw", "iter", "cmd", "img", "rb", "buffer", "msg", "txt", "ref", "var", "read", "cur", "Buff", "out", "row", "mem", "queue", "rc", "batch", "err", "alloc", "cap", "block", "cb", "cv"], "file": ["action", "lf", "File", "dir", "data", "id", "name", "filename", "bin", "port", "user", "path", "loc", "image", "ile", "fd", "offset", "files", "line", "fil", "db", "fi", "buffer", "channel", "handle", "source", "base", "time", "local", "resource", "part", "fp", "io", "f"], "serial": ["dev", "volume", "zip", "json", "iso", "soc", "par", "id", "util", "security", "Serial", "ser", "history", "mobile", "root", "address", "sync", "final", "raw", "serv", "roll", "kid", "normal", "special", "random", "driver", "series", "ident", "device", "session", "socket", "ro", "sector", "phone", "sex", "sys", "local", "tty", "bus", "usb"], "mediastr": ["datastrat", "datostri", "datastr", "mediastrip", "mediastrat", "datostrip", "mediardr", "mediostri", "datostr", "datastrip", "datastri", "mediostrat", "mediawrat", "mediardri", "mediawrip", "mediastri", "mediardrat", "mediawri", "datostrat", "mediostrip", "mediostr", "mediawr", "mediardrip"], "type": ["ty", "TY", "check", "try", "tp", "pack", "family", "parent", "sort", "state", "start", "id", "name", "length", "port", "pe", "span", "repeat", "ver", "tag", "block", "typ", "Type", "y", "types", "test", "status", "role", "style", "ype", "info", "what", " t", "kind", "PE", "scope", "no", " TYPE", "t", "shape", "size", "TYPE", "pc", " Type", "total", "var", "count", "ping", "color", "tiny", "event", "level", "e", "all", "ico", "time", "rule", "op", "part", " family", " typ", "class", "thing", "trace"], "media": ["meta", "volume", "mo", "m", "mm", "family", "api", "memory", "name", "image", "library", " Media", "communication", "mag", "movie", "java", "style", "mode", "history", "mac", "storage", "relative", "medi", "medium", "format", "document", "area", "material", "ma", "metadata", "pro", "language", "Media", "http", "IA", "policy", "resource", "pi", "aka", "io"], "bus_id": ["bus_ref", "buswid", "bridge8id", "us_ids", "bus8number", "buswnumber", "buswaid", "bridge_id", "busxids", "bus_ids", "bridge_number", "bus8aid", "busxref", "us_id", "bridge8aid", "busogident", "bus__ref", "bridge8number", "bridge_aid", "bridge_ident", "us_ref", "bus_aid", "bus__info", "bus__ids", "bus_ident", "busogid", "busxid", "bus8id", "bus__id", "busxinfo", "bus_info", "us_info", "busognumber", "bus_number", "buswident", "bridge8ident", "bus8ident", "busogaid"], "unit_id": ["unit2ids", "unit2type", " unit_pid", "unit2info", "unit_type", "unit_bid", " unit_ids", " unit2id", " unit_type", " unit_bid", " unit2ids", "unit_pid", "unit2id", "unit_info", " unit_info", " unit2info", " unit2type", "unit_ids"], "cyls": ["cysels", " cyles", "sysels", "styls", "syles", "styps", "cyols", "styols", "cyles", "tycs", "cyps", "tysels", "cycs", "syls", "cryls", "syps", "cryles", "syols", " cyols", "crycs", "sycs", "crysels", " cyps", "tyls", "tyles", "styles"], "heads": ["sticks", "HEAD", "boards", "sections", "tops", "rs", "stocks", "bits", "modules", "times", "reads", "views", "headers", "tags", "hours", "outs", "links", "hops", "weights", "masters", "loads", "blocks", "helps", "phones", "limits", "cs", "terms", "mods", "rows", "relations", "olds", "offs", "its", "head", "uploads", "tails", "planes", "shots", "days", "locks"], "secs": ["secjs", "logs", "secns", "towns", " secjs", " secps", " secns", "seqs", "townns", "secrs", "seqrs", "seqis", "sectrs", " secrs", "sects", "sectps", "secps", "townjs", "secis", "logns", " secis", "logps", "logjs", "townps", "sectis", "seqps"], "translation": ["meta", "relation", "rot", "description", "generation", "direction", "transform", "Translation", "lation", "control", "tr", "library", "heading", "padding", "trans", "text", "versions", "mode", "history", "info", "selection", "creation", "location", "origin", "utils", "lations", "version", "normal", "usage", "position", "language", "comment", "late", "operation", "formation", "binding", "title", "resource", "lang", "FORMATION"], "drv": ["drvr", "srw", "srj", "drw", "crvr", "crw", "crv", " drw", "srvr", " drj", "srv", "drj", "crj", " drvr"], "max_devs": ["max_evs", "max_evds", "max_evts", "max_devts", "max_defs", "max_devpoints", "max_devds", "max_defpoints", "max_execs", "max_defds", "max_execds", "max_exects", "max_evpoints", "max_execpoints", "max_defts"], "index": ["num", "connect", "success", "write", "id", "loc", "insert", "length", "offset", "info", "lock", "address", "scan", "iter", "location", "order", "pos", "loop", "active", "size", "skip", "key", "open", "position", "link", "read", "count", "Index", "head", "number", "row", "ind", "x", "addr", "label", "val"], "on_read_error": ["on_write_start", "on_read_start", "on_write_err", "on_write_change", "on_read_err", "on_read_change"], "on_write_error": ["on_write_data", "on_write_start", "on_writ_err", "on_write_err", "on_writ_error", "on_writ_data", "on_writ_start"], "devaddr": ["devptr", "deviceaddress", "deviceaddr", "evaddress", "deviceptr", " devptr", "devname", "devicename", " devname", "evaddr", "devaddress", " devaddress", "evptr", "evname"], "dinfo": ["DInfo", "dinf", "Dinf", "bdinfo", "bdInfo", "Dinfo", "bdinf", "dInfo", " dInfo", " dinf"], "io_limits": ["IO_limits", "io_settings", "io_limit", "io_maps", "IO_maps", "IO_limit", "IO_settings"], "copy_on_read": ["copy_on_readable", "copy_on_write", "copy_on_Read", "copy_on_disk"], "ret": ["reset", "vector", "num", "rs", "Ret", "trans", "prop", "rt", "ry", "limit", "lit", "ts", "no", "nt", "flag", "pos", "res", "ref", "total", "rev", "count", "out", "len", "mem", "rel", "rc", "val"], "error": ["action", "ror", "relation", "command", "ERROR", "data", "p", "o", "danger", "status", "result", "er", "info", "r", "errors", "order", "comment", " err", "event", "instance", "option", "op", "Error", "err", "ack"]}}
{"project": "qemu", "commit_id": "0b2c1beea4358e40d1049b8ee019408ce96b37ce", "target": 1, "func": "static const char *keyval_parse_one(QDict *qdict, const char *params,\n\n                                    const char *implied_key,\n\n                                    Error **errp)\n\n{\n\n    const char *key, *key_end, *s;\n\n    size_t len;\n\n    char key_in_cur[128];\n\n    QDict *cur;\n\n    int ret;\n\n    QObject *next;\n\n    QString *val;\n\n\n\n    key = params;\n\n    len = strcspn(params, \"=,\");\n\n    if (implied_key && len && key[len] != '=') {\n\n        /* Desugar implied key */\n\n        key = implied_key;\n\n        len = strlen(implied_key);\n\n    }\n\n    key_end = key + len;\n\n\n\n    /*\n\n     * Loop over key fragments: @s points to current fragment, it\n\n     * applies to @cur.  @key_in_cur[] holds the previous fragment.\n\n     */\n\n    cur = qdict;\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n", "idx": 22815, "substitutes": {"qdict": [" qcontext", "qqtable", " qdir", "qualdd", "qudir", "qqdir", "qqdict", "qucontext", "qcontext", "qualdict", "qualtable", "qutable", "qqdd", "qdir", "qqcontext", "qtable", "qdd", " qdd", "qualdir", "qudict", " qtable"], "params": ["pins", "ctx", "js", "m", "spec", "json", "ls", "p", "missing", "parent", "par", "rs", "ams", "points", "name", "conf", "tags", "tmp", "padding", "vs", "parts", "value", "ps", "strings", "types", "css", "init", "result", "prefix", "values", "ms", "settings", "mas", "sym", "terms", "errors", "keys", "pos", "args", "phys", "k", "target", "names", "ks", "changes", "actions", "options", "param", "pi", "new", "vals", "pres", "v"], "implied_key": ["impliedIkey", "impliedingname", "implified_link", "implified_key", "impliedJbox", "implied_ip", "impliedjfield", "impllied_key", "implied_resource", "implied_hash", "impliedingkey", "implified_Key", "impllied_link", "implied___link", "implied___hash", "impliedingresource", "impliedJlink", "impliedjkey", "implied___type", "implied___code", "implified_hash", "impliedingtag", "imploted_ip", "impllied___key", "impliedJparent", "impllied_parent", "impliced_code", "impllied___link", "implied___key", "implied_code", "implied___field", "implicated_tag", "impllied___box", "impliedIKey", "implied___keys", "impliedjcode", "implified_tag", "implified_no", "impllied_box", "implied_box", "implified_resource", "imploted_version", "implified_keys", "implied_link", "implied_Key", "impliedjtype", "implied_type", "impliced_type", "implicated_resource", "impliedIresource", "implied_version", "implied_no", "implied_keys", "implied_name", "implied___parent", "implied_parent", "implied_field", "impliced_key", "implied_tag", "impllied___parent", "imploted_keys", "impliedIno", "implicated_name", "impliced_field", "imploted_key", "impliedJkey", "implied___box", "implicated_key"], "errp": ["derpid", "errorP", "errpid", "derr", "riskr", " errpoint", "derpb", "warnpp", "riskpoint", "errf", "derp", "errorpid", "ferpa", "tracer", "errorping", " errP", "errr", "ferpp", "errpp", " errnp", "errpoint", "errnp", "errorpb", "ferp", "rrP", " errr", "tracepa", "warnps", " errpp", "errpb", "rrpb", "errorp", "rrpa", "rrpid", "errping", "errorpa", "errps", "errorpoint", "dernp", " errping", "tracep", "riskpid", "rrf", "rrp", "warnp", "derf", "riskp", "errorr", " errpid", "errorf", "rrping", "tracenp", "derpa", "errpa", "errP", "warnpa", " errpa", " errps", "ferps"], "key": ["pkg", "json", "end", "sp", "name", "type", "by", "tmp", "ver", "ak", "chain", "sym", "set", "ip", "pri", "tiny", "a", "x", "table", "ke", "data", "one", "padding", "tag", "KEY", "cache", "ps", "shift", "l", "prefix", "iter", "pointer", "sum", "net", "k", "error", "tip", "hash", "is", "v", "m", "this", "te", "mk", "length", "port", "field", "offset", "sky", "max", "ms", "kind", "kw", "item", "keys", "ek", "skip", "var", "note", "obj", "row", "options", "param", "policy", "str", "title", "err", "p", "start", "id", "ams", "nil", "Key", "value", "n", "y", "token", "lock", "no", "query", "host", "i", "t", "size", "ns", "target", "ket", "ey", "link", "code", "e", "null", "base", "index", "sk", "pair"], "key_end": ["key_start", " key_END", "key2End", "KEY_in", "key_End", "KEY_start", "keyLenend", "key_END", " key_ends", "key_e", "key_ends", "key2END", "keyLenender", " key_e", "keyLenEND", " key_length", "key_len", " key_ender", "KEY_len", "key_length", "KEY_end", "key_ender", "key2start", " key_End", "KEY_End", " key_start", "KEY_END", "key_in", "key2end"], "s": ["south", "sp", "full", "rs", "bs", "fs", "ims", "cs", "sym", "stats", "ar", "ies", "rev", "ins", "its", "a", "x", "os", "ls", "es", "d", "vs", "ps", "ds", "l", "self", "b", "ts", "args", "less", "slice", "ars", "is", "v", "js", "gs", "m", "tes", "sl", "sort", "bits", "parts", "ms", "r", "ss", "g", "second", "hs", "sts", "sys", "str", "ats", "spec", "p", "sq", "start", "w", "sb", "n", "y", "bytes", "c", "as", "sw", "j", "i", "t", "size", "prev", "sub", "ns", "out", "e", "sv", "qs", "sr", "h", "xs", "S"], "len": ["lf", "rot", "del", "end", "sp", "gl", "ln", "ld", "els", "acl", "tail", "fn", "lib", "lit", "gen", "nt", "format", "dl", "rev", "vec", "ll", "bool", " l", "ls", "data", "syn", "den", "l", "fun", "nl", "iter", "pos", "en", "lt", "ils", "slice", " bl", "lp", "ele", "kl", "Length", "js", "sl", "alt", "seq", "length", "loc", "elta", "ilt", "lim", "lon", "offset", "limit", "tl", "lc", "lv", "ren", "res", "li", "msg", "il", "compl", "el", "hl", "rl", "str", "err", "elt", "valid", "rel", "le", "lvl", "L", "n", "bytes", "Len", "fin", "lic", "lan", "j", "t", "size", "repl", "ref", "mem", "gt", "lang", "dim", "cmp", "label"], "key_in_cur": ["key_in_Cur", "key_out_Cur", "key_in_cont", "key_in_pri", "key_in__rc", "key_out_current", "key_out_pri", "key_out_cont", "key_out_rc", "key_out_sur", "key_in2cur", "key_out_cur", "key_in2ser", "key_in_sur", "key_in__cur", "key_in_ser", "key_in2Cur", "key_out_ser", "key_in_current", "key_in__Cur", "key_in_buf", "key_out_buf", "key_in__sur", "key_in_rc"], "cur": ["ctx", "current", "gc", "cr", "car", "cor", "ur", "tr", "tmp", "ptr", "cache", "ph", "sc", " Cur", "dict", "co", "result", "ser", "c", "gr", "r", "serv", "iter", "cmd", "Cur", "dr", "ren", "prev", "col", "cat", "rev", "pri", "con", "buf", "obj", "row", "ctr", "ch", "cu", "comp", "rec", "usr", "sr", "sys", "rc", "new", "err", "sur", "coll", "cont", "pg", "cv", "ct"], "ret": ["js", "rest", "reset", "num", "ls", "sp", "alt", " alt", "Ret", "length", "tmp", "def", "red", "ext", "rem", "l", "Len", " Ret", "result", "fun", "tail", "rt", "lit", "ts", "iter", "j", "nt", "t", "res", "match", "repl", "en", " RET", "ner", "lt", "txt", "rev", "et", "re", "ref", "out", "ll", "rets", "gt", "sr", "arr", "str", "err", "elt", "RET", "rel", "ne", "cont"], "next": ["current", "dev", "js", "me", "try", "end", "p", "data", "big", "sche", "state", "z", "seq", "adj", "req", "tri", "jp", "gov", "tmp", "ver", "ptr", "Next", "def", "n", "fr", "ext", "future", "self", "good", "result", "info", "proc", "nl", "j", "iter", "nt", "net", "prev", "prime", "non", "ner", "nd", "target", "rev", "ng", "txt", "link", "other", "ns", "draw", "obj", "sec", "none", "gt", "rec", "sys", "new", "rel", "more", "ne", "v"], "val": ["ctx", "sl", "ls", "p", "alt", "sel", "vs", "value", "ps", "test", "attr", "values", "VAL", "tx", "serv", "eval", "args", "res", "Val", "msg", "txt", "var", "buf", "str", "vals", "als", "v"]}}
{"project": "FFmpeg", "commit_id": "79997def65fd2313b48a5f3c3a884c6149ae9b5d", "target": 0, "func": "static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)\n\n{\n\n    int16_t input[MDCT_SAMPLES];\n\n    int32_t output[AC3_MAX_COEFS];\n\n    float input1[MDCT_SAMPLES];\n\n    float output1[AC3_MAX_COEFS];\n\n    float s, a, err, e, emax;\n\n    int i, k, n;\n\n\n\n    for (i = 0; i < MDCT_SAMPLES; i++) {\n\n        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;\n\n        input1[i] = input[i];\n\n    }\n\n\n\n    mdct512(mdct, output, input);\n\n\n\n    /* do it by hand */\n\n    for (k = 0; k < AC3_MAX_COEFS; k++) {\n\n        s = 0;\n\n        for (n = 0; n < MDCT_SAMPLES; n++) {\n\n            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));\n\n            s += input1[n] * cos(a);\n\n        }\n\n        output1[k] = -2 * s / MDCT_SAMPLES;\n\n    }\n\n\n\n    err  = 0;\n\n    emax = 0;\n\n    for (i = 0; i < AC3_MAX_COEFS; i++) {\n\n        av_log(NULL, AV_LOG_DEBUG, \"%3d: %7d %7.0f\\n\", i, output[i], output1[i]);\n\n        e = output[i] - output1[i];\n\n        if (e > emax)\n\n            emax = e;\n\n        err += e * e;\n\n    }\n\n    av_log(NULL, AV_LOG_DEBUG, \"err2=%f emax=%f\\n\", err / AC3_MAX_COEFS, emax);\n\n}\n", "idx": 22826, "substitutes": {"mdct": [" mdcat", "mdcd", "madcat", "ndct", "cmdct", "ndcc", "madCT", "mcCT", "mdcc", "mdCT", "mdcat", "cmdCT", " mdcc", "cmdcc", "MDcat", "ndcd", "madcc", "mccd", "MDct", "cmdcd", "madct", "mccc", "mcct", "ndCT", "MDcc", "MDCT", " mdCT"], "lfg": [" lbgu", "lbge", "lfG", "ldge", "lbG", "lvgu", "llc", "lfgu", "dlc", "lvG", " lbG", "llge", "lfc", "dlge", "ldg", "lvge", "dlg", "llg", " lbge", "lbg", "dll", "lfge", " lbg", "ldc", "lll", "lbgu", "ldl", "lfl", "lvg"], "input": ["get", "inner", "q", "add", "data", "p", "seed", "accept", "image", "hidden", "w", "um", " inputs", "request", "Input", "audio", "feed", "bit", " Input", "text", "ou", "load", "address", "raw", "array", "empty", "config", "query", "in", "search", "error", "from", "buffer", "initial", "ip", "PUT", "read", "out", "row", "source", "before", "import", "interface", "local", "view", "index", "form", "issue", "context", "h"], "output": ["current", "list", "done", "generation", "success", "write", "four", "data", "v", "o", "dot", "file", "accept", "image", "hidden", "web", "console", "to", "cache", "result", "ou", "config", "Output", "print", "document", "network", "put", "message", "update", "buffer", "key", "target", "collection", "PUT", "total", "outer", "client", "other", "next", "out", "position", "source", "display", "queue", "batch", "new", "block", "table", "response"], "input1": ["image1", " input2", "input3", "Input0", "image2", " input4", "input2", "Input2", "output2", "output0", "Input1", "Input4", "Input3", " input3", " input0", "image3", "output4", "input0", "input4", "output3"], "output1": ["Output0", " output0", "Output2", "inputOne", "input3", "outputOne", "out0", "Output3", "out3", " outputOne", "Output1", "output2", "input2", "output0", "out1", " output3", "out2", "input0", " output2", "outOne", "output3"], "s": ["js", "m", "gs", "spec", "sl", "ls", "sq", "p", "es", "sp", "rs", " ts", "w", "d", "sb", "ps", "ds", "sa", "b", "ms", "c", "cs", "r", "ts", "ss", "stats", "t", "ar", "g", "ns", "ies", "its", "sts", "sv", "sr", "h", "ats", "se", "os", "x", "S", "sd", "is"], "a": ["ac", "m", "A", "p", "alpha", "o", "am", "at", "ga", "ba", "apa", "d", "va", "ea", "ab", "fa", "aff", "sa", "er", "ae", "aa", "an", "b", "c", "as", "r", "ai", "ar", "area", "g", "u", "ma", "pa", "ap", "ao", "au", "ach", "x", "ata", "pi", "ia"], "err": ["eff", "m", "cr", "der", "diff", "p", "mr", "exc", "rs", "ere", "ev", "conf", "req", "ell", "orr", "fr", "it", "rn", "oe", "rss", "er", "attr", "lr", "c", "r", "iter", "ec", "cmd", "errors", "ir", "extra", "ie", "res", "error", "erer", "gz", "ar", "msg", "txt", "ind", "Er", "h", "str", "arr", "rr", "rc", "Error", "fee", "rel", "elt", "f", "eor", "trace", "term", "v"], "e": ["m", "eg", "te", "eb", "es", "o", "ere", "ev", "p", "be", "eeee", "pe", "d", "ei", "oe", "ue", "er", "ae", "c", "xe", "r", "edge", "ec", "ef", "ce", "ie", "error", "g", "u", "E", "en", "ed", "element", "et", "ate", "ge", "el", "eur", "x", "ee", "se", "eu", "ele", "ex", "f", "east", "le", "v"], "emax": ["emAX", "esmax", "emox", "eminaxy", "lemaster", "esmAX", "EMax", "eemit", "emaster", "aleit", "mmax", "aleax", "emmax", " emaxy", " emox", " emaz", "emsax", "eminax", "max", "emake", "lemaz", "eemax", "esmaxy", "esmox", "maxy", "aleaster", "EMmax", "emsake", "emort", "lemmax", "emingood", "emmed", "omgood", "EMaz", "lemmed", "esmake", "esmmax", "aleAX", "eminmax", "lemake", "ommax", "emsaster", "esmaster", "eemAX", "omax", " emgood", " emmax", "lemax", "EMort", "omaxy", "mox", "emsmed", "esmmed", "emaz", "emgood", " emort", "emit", "eemaster", "esmit", "emaxy", "lemort"], "i": ["at", "name", "multi", "ei", "ims", "mi", "info", "dr", "\u0438", "uri", "phi", "ip", "ri", "ini", "ind", "ii", "x", "pi", "io", "ki", "im", "list", "o", " bi", "zi", "it", "qi", "iu", "iter", "di", "print", "remote", " I", "u", "wi", "is", "v", "hi", "m", "me", "this", "us", "si", "xi", "init", "ai", "g", "ui", "li", "iri", "batch", "ci", "ix", "p", "parent", "id", "y", "ij", "ti", "c", "j", " ii", "gi", "ic", "cli", "sim", "ji", "bi", "oi", "index", "h", "I", "ami"], "k": ["ke", "kh", "m", "num", "kan", "kr", "ko", "p", "q", "o", "mk", "ijk", "kt", "K", "unk", "ak", "ka", "uk", "km", "kick", "c", "kit", "kind", "isk", "ok", "kw", "tk", "j", "kl", "kid", "ek", "key", "ck", "ks", "kk", "ku", "kn", "sk", "kj", "ask", "wk", "ikk", "ik", "ki"], "n": ["m", "nw", "num", "sn", "kr", "p", "np", "nb", "o", "un", "z", "and", "cn", "name", "mn", "ln", "nm", "nn", "br", "on", "N", "y", "rn", "nc", "b", "c", "an", "fn", "r", "no", "j", "nt", "nu", "gn", "ni", "node", "net", "na", "dn", "en", "nd", "key", "ns", "ng", "pn", "note", "el", "ll", "all", "kn", "nan", "new", "nr", "ne", "v"]}}
{"project": "FFmpeg", "commit_id": "a66c6e28b543804f50df1c6083a204219b6b1daa", "target": 1, "func": "static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)\n\n{\n\n    // attempt to keep aspect during typical resolution switches\n\n    if (!sar.num)\n\n        sar = (AVRational){1, 1};\n\n\n\n    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});\n\n    return sar;\n\n}\n", "idx": 22833, "substitutes": {"old_w": ["old00win", "old_win", "new_W", "old_W", "old00h", "old00w", "old_wn", "old00sp", "old10h", "new_wn", "old10w", "old_sp", " old_sp", "old10win", " old_win", "old10sp"], "old_h": ["old48ht", "old48w", "store00w", "store00hw", "store00ht", "old_hw", "old00h", "old00w", "old___v", "store_w", "old_v", "store_ht", "old___h", "store00h", "new_hal", "store_hw", "old_ht", "store_h", "old_hal", "old00ht", "old00hw", "old___hal", "old48hw", "old___w", "new_v", "old48h"], "sar": ["usara", "sshar", "shar", "rsart", "sara", " scar", "msar", " saer", "nsear", "unsAR", "spar", "timesAR", "ssar", "sAR", "isaer", "sarian", " sara", "timesar", "unsaer", "sart", "rsarl", "tsars", "unsars", "nsar", "unsarian", " spar", "msarl", "unsar", "ispar", "getshar", "unshar", "sqara", "sqear", " sarp", "msart", "timespar", "sarp", "sarl", "tsarian", "unscar", "sspar", "msrar", "rsrar", "tsarp", "nscar", "saer", "srar", "seart", "usaris", "tsar", "getsaris", "rsar", "nsara", "ushar", "unspar", "sqcar", "searl", "ssAR", "getsara", "sqar", "usar", "iscar", " shar", " sarian", "unsarp", "serar", "isar", "sars", " saris", "getsar", "timeshar", " sear", "scar", "saris", " sars", "sear"], "new_w": ["cell_wd", "cell_wn", "new64h", "new_hw", "new_wd", "new_W", "new64wn", "new64W", " new_hw", "cell_W", "cell_w", " new_W", "new64hw", "new_wn", "new64wd", "new64w"], "new_h": [" new_ht", "old_zh", "new__ht", "new_height", "new64ht", "new00l", "new64h", "new_l", "new_ht", "new00h", " new_height", " new__ht", "old_l", "new__height", "new__h", "new_zh", "new64height", "new00zh", " new__height", "new00w", " new__h"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n", "idx": 22834, "substitutes": {"bus": ["dev", " Bus", "us", "Bus", "BUS", "mount", "box", "block", " board", "cc", "usb", "bit", " BUS", "chain", "proc", "lock", "tx", "config", "board", " device", " buses", "uses", "ck", "device", "bug", "book", "boot"], "devfn": ["testfn", "Devnm", "evn", "Devfn", "devfilename", "devicelen", "testFN", "devn", "testn", " devnm", " devfilename", "devlen", "Devfilename", "devnm", "evlen", "evnm", "devFN", "deviceFN", "devicefn", "devicen", "testlen", "evFN", "evfn", "evfilename"], "offset": ["ta", "OFF", "start", "o", "slot", "seed", "length", "loc", "padding", "shift", " offsets", "bit", "Offset", "style", "bound", "prefix", "attr", "info", "oint", "address", "location", "point", "timeout", "pos", "size", "error", "set", "optional", "position", "ref", "window", "off", "event", "zero", "tz", "index", "attribute", "oid", "addr", "block"]}}
{"project": "FFmpeg", "commit_id": "ee90119e9ee0e2c54f1017bbe1460bfcd50555d0", "target": 1, "func": "static int decode_block(BinkAudioContext *s, float **out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = out[ch];\n\n\n\n        if (s->version_b) {\n\n            if (get_bits_left(gb) < 64)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2float(get_bits_long(gb, 32)) * s->root;\n\n        } else {\n\n            if (get_bits_left(gb) < 58)\n\n                return AVERROR_INVALIDDATA;\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        if (get_bits_left(gb) < s->num_bands * 8)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            int value = get_bits(gb, 8);\n\n            quant[i]  = quant_table[FFMIN(value, 95)];\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else {\n\n                int v;\n\n                GET_BITS_SAFE(v, 1);\n\n                if (v) {\n\n                    GET_BITS_SAFE(v, 4);\n\n                    j = i + rle_length_tab[v] * 8;\n\n                } else {\n\n                    j = i + 8;\n\n                }\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            GET_BITS_SAFE(width, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    GET_BITS_SAFE(coeff, width);\n\n                    if (coeff) {\n\n                        int v;\n\n                        GET_BITS_SAFE(v, 1);\n\n                        if (v)\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        int j;\n\n        int count = s->overlap_len * s->channels;\n\n        if (!s->first) {\n\n            j = ch;\n\n            for (i = 0; i < s->overlap_len; i++, j += s->channels)\n\n                out[ch][i] = (s->previous[ch][i] * (count - j) +\n\n                                      out[ch][i] *          j) / count;\n\n        }\n\n        memcpy(s->previous[ch], &out[ch][s->frame_len - s->overlap_len],\n\n               s->overlap_len * sizeof(*s->previous[ch]));\n\n    }\n\n\n\n    s->first = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 22844, "substitutes": {"s": ["js", "gs", "m", "spec", "ls", "sq", "p", "es", "o", "rs", "bs", "bits", "rates", "sp", "details", "conf", "span", "sb", "sports", "parts", "sc", "ps", "n", "eps", "fs", "ims", "ds", "self", "ains", "b", "ms", "c", "cs", "settings", "er", "as", "sw", "ts", "ses", "sym", "ss", "in", "stats", "t", "aws", "less", "set", "g", "ns", "series", "ins", "a", "hs", "sam", "sts", "sv", "qs", "sys", "ats", "sg", "os", "se", "S", "als", "ops", "space", "ex", "is", "comm"], "out": ["m", "list", "p", "o", "at", "params", "Out", "ot", "w", "tmp", "up", "outs", "to", "block", "cache", "n", "y", "sky", "result", "b", "c", "raw", "in", "t", "res", "set", "g", "output", "buffer", "obj", "all", "OUT", "sys", "op", "os", "batch", "new", "chan", "io"], "use_dct": ["use_rCT", "use_duct", "use_rct", "use_Dbc", "use_dCT", "use_Dct", "use_dbc", "use_puct", "use_fdct", "use_rpt", "use_fdbc", "use_pCT", "use_rbt", "use_dpt", "use_DCT", "use_dbt", "use_pbt", "use_fdCT", "use_fduct", "use_pbc", "use_ppt", "use_Duct", "use_pct"], "ch": ["cp", "high", "kh", "height", "chron", "och", "ca", "zh", "chn", "z", "mk", "Ch", "ot", "cha", "ih", "chart", "ay", "br", "ph", "sc", "y", "cht", "ich", "ech", "ht", "chip", "b", "sh", "c", "cs", "atch", "ble", "bt", "chrom", "g", "cho", "col", "cd", "sch", "ek", "CH", "count", "channel", "code", "hl", "th", "ach", "h", "x", " Ch", "batch", "tch", "sk", "chan", "cb", "ct"], "i": ["multi", "ori", "ei", "mi", "info", "ir", "dr", "phi", "ip", "iq", "ri", "ini", "ind", "ii", "x", "pi", "f", "ki", "im", "try", "o", "z", "zi", "it", "l", "b", "qi", "iu", "iter", "di", "in", "slice", "ik", "is", "hi", "m", "me", "si", "xi", "init", "status", "ai", "g", "ui", "li", "ci", "ix", "p", "api", "value", "n", "y", "ij", "ti", "c", "t", "ie", "size", "gi", "ic", "key", "cli", "ji", "bi", "e", "index", "h", "I", "ami", "ia"], "j": ["jj", "js", "south", "m", "json", "try", "p", "o", "z", "ja", "uj", "aj", "si", "jp", "je", "w", "br", "fr", "n", "y", "it", "dj", "l", "ij", "b", "jc", "max", "c", "r", "jl", "t", "g", "J", "job", "ji", "bi", "e", "row", "h", "x", "jump", "pi", "kj", "f"], "k": ["ke", "kh", "m", "kan", "ko", "p", "o", "z", "mk", "ijk", "w", "unk", "K", "ka", "ak", "km", "n", "c", "kind", "r", "kw", "kid", "u", "ek", "key", "ck", "ks", "kk", "x", "sk", "ikk", "ik"], "q": ["m", "p", "sq", "Q", "z", "qt", "qa", " g", " f", "o", " quad", "w", " qu", "qu", "n", " req", " sq", "ue", "qi", "c", "requ", "query", "t", "g", "u", " qual", " p", "iq", " flux", "qs", "qv", "h", "x", "dq", " Q", " z", "weight", "qq", "f", " query"], "quant": ["ty", "uint", "hold", "util", "specific", "important", "Quant", "qu", "percent", "pick", "press", "dict", "good", "mot", "quick", "mix", "requ", "buff", "deep", "config", "nt", "stats", "integer", "material", "frac", "random", "quad", "patch", "cat", "series", "mint", "total", "var", "count", "complex", "ind", "comp", "quart", "qual", "private", "qq", "mult", "quiet", "final"], "coeff": ["COeff", "COff", "COef", " coef", "Coefficient", " coff", "Coff", "Coef", "coef", "coff", " coefficient", "coefficient", "Coeff", "COefficient"], "gb": ["ctx", "cfg", "gc", "gs", "rect", "uf", "eg", "aaa", "bb", "eb", "nb", "bs", "hog", "gg", "yg", "gm", "sb", "tg", "gd", "huge", "wb", "py", "Gb", "phy", "global", "tm", "hd", "b", "large", "gpu", " GB", "GB", "lib", "storage", "gnu", "bm", "html", "gh", "uv", "deg", "ubis", "gif", "db", "kb", "rb", "g", "bg", "vg", "goo", "jpg", "ruby", "pb", "mb", "gp", "bf", "gt", "xy", "fg", "rg", "fb", "pg", "hw", "hub", "cb", "cv"], "coeffs": ["coffes", "coefficientls", "coefficiths", "COeffs", "coeffics", "coefs", "coeffS", "coefficientjs", "Coeff_", "COefficientsjs", "coefficientsends", "coefficientsiths", "coeffances", "coffjs", "coaccs", "coef_", "coefficS", " coffes", "coefficls", "cocolls", "coeffe", "coefS", "cocels", " coeffends", "coaccls", "coffitions", "Coeffs", " coeffls", "coefances", "cocelitions", "COefficientss", "coffts", "COeffiths", " coeffts", "coefficient_", "coffS", "coeffends", "COefs", "COefficientse", "COefances", " coffls", "COeffances", " coffs", "coff_", "COefficientses", "coeffiths", "coeff_", "coefficances", " coffts", " coeffitions", "Coeffes", "coefficientsts", "coeffls", "coefficientes", "coffends", "COefes", "coefficientsls", "coefficientsitions", "coeffice", "COeffjs", "coeffes", "COefS", "cocelts", " coffjs", "coffls", "coffs", " coeffjs", "Coffes", "coefficientses", "coeffjs", "coeffts", "coaccjs", "coefficients", "coefficientse", "Coffs", " coffitions", "COeffls", "cocole", "coefficientsjs", "coeffices", "coffances", "cocols", "COefficientsls", "cocoliths", "Coff_", "coefficientss", "COeffe", "coceljs", "COefficientsiths", "coaccends", "coeffitions", " coffends", "COeffes", "COeffS", " coeffes", "coefes"], "v": ["V", "m", "vector", "vv", "volume", "tv", "vt", "p", "vc", "z", "ve", "ev", "vd", "w", "ver", "vs", "av", "va", "n", "value", "y", "vm", "it", "iv", "l", "b", "vol", "c", "vp", "lv", "uv", "version", "t", "g", "u", "vert", "rev", "var", "cv", "nv", "sv", "conv", "qv", "h", "x", "vi", "f", "val"]}}
{"project": "qemu", "commit_id": "4cb88c3c378ae8c86c0ba53619caf6924f72239c", "target": 1, "func": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 22875, "substitutes": {"cpu": ["ctx", "cp", "ilo", "gc", "pkg", "reset", "tp", "us", "np", "linux", "hz", "lo", "cn", "CPU", "pixel", "copy", "chip", "cum", "uu", "proc", "c", "core", "gpu", "thread", "processor", "nic", "node", "ce", "prof", "frame", "pc", "cat", "ck", "device", "process", "row", "pause", "cu", "gp", "comp", "hw", "clock", "alloc", "cmp", "pu", "pool", "cow", "ct"], "scc": ["scci", "scs", " sbc", "Sck", "tsbc", "jsct", "tsCC", " scs", " scci", "sck", "sCC", "tscci", "sbc", "sct", "Suc", "suc", "Scc", "tscc", "jsCC", "Scs", "SCC", "jscc", "jscs", " sck", " suc", " sct", "Sct", " sCC"]}}
{"project": "qemu", "commit_id": "ab03b63d7a9c7978d51e56c191f0b86888d121dc", "target": 1, "func": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n", "idx": 22876, "substitutes": {"s": ["js", "gs", "ls", "p", "es", "rs", "state", "sb", "ps", "n", "fs", "ds", "ms", "sh", "cs", "r", "ts", "ses", "ss", "ys", "t", "ns", "ies", "ins", "its", "ers", "hs", "sts", "sv", "h", "ats", "S", "is", "v"], "vs": ["vc", "bs", "rs", "ver", " ss", "gets", "fs", "ims", "vers", "cs", "stats", "lines", "ies", "ins", "its", "ks", "wcs", "ii", "fps", "words", "ls", "vt", "alls", "es", "posts", "ads", "views", "docs", "lists", "outs", "ps", "vm", "Rs", "ds", "Vs", "serv", "ts", "atts", "ils", "ports", "lbs", "ov", "v", "js", "gs", "ows", "irms", "bits", "ev", "vd", "otes", "eps", "ms", "terms", "ves", "ss", "uds", "news", "var", "hs", "obj", "ears", "sts", " VS", "vv", "inv", "flags", "blogs", "ires", "values", "vp", "VS", "vr", "ns", "changes", "obs", "sv", "qs", "xs", "vals", "ents", "ops"], "err": ["kr", "mr", "hz", "rs", "state", "ev", "id", "here", "pr", "or", "ver", "ptr", "br", "ah", "conn", "y", "fr", "oe", "test", "n", "er", "attr", "lr", "c", "r", "ok", "iter", "ec", "i", "dr", "ir", "res", "error", "gz", "ner", "msg", "txt", "rez", "rev", "count", "resp", "eas", "buf", "out", "code", "coord", "off", "e", "ch", "Er", "sys", "usr", "str", "h", "rr", "arr", "nz", "fee", "elt", "Error", "nr", "cmp", "eor", "trace", "rc"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906, "substitutes": {"info": ["check", "name", "conf", "by", "user", "conn", "force", "good", "ok", "Inf", "where", "ip", "summary", "os", "pi", "io", "f", "trace", "help", "command", "list", "try", "data", "ist", "request", "it", "warn", "content", "doc", "admin", "warning", "config", "iter", "about", "sum", "error", "tip", "comment", "is", "INFO", "fo", "dev", "num", "success", "report", "add", "state", "req", "debug", "notice", "information", "py", "init", "history", "version", "txt", "note", "http", "time", "exec", "always", "current", "start", "entry", "id", "details", "Info", "def", "ion", "inf", "sync", "query", "i", "auth", "update", "link", "job", "event", "now", "mem", "interface", "index"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931, "substitutes": {"ram_size": ["ram_name", "ram_SIZE", "cpu_SIZE", "ram_addr", "cpu_name", "cpu_addr", "cpu_size"], "do_init": [" fe_out", " cpu_init", " cpu1init", " cpu_size", " fe_size", " fe_init", " cpu1size", " fe_cmd", " cpu1cmd", " cpu_cmd", " cpu_out", " cpu1out"], "cpu_model": ["cpu_models", "gpu_link", "CPU_Model", "CPU_type", "CPU_models", "cpu2model", "cpu_type", "gpu_Model", "cpu_link", "gpu_label", "CPU_model", "cpu2label", "cpu_Model", "cpu_label", "cpu2Model", "gpu_model", "cpu2link"], "sysclk": ["sysCLke", "syschck", "sysClk", " sysclks", "sysCLks", " sysClk", "sysclke", " sysCldk", "syschdk", "sysCLk", " sysclck", "sysClke", "sysclck", "syschk", " sysClke", "sysCLdk", "syscldk", "sysclks", " syscldk", "sysClck", "syschke", "sysCldk", "sysCLck", " sysclke", "sysClks", " sysClck"], "cpu": ["ctx", "cp", "pkg", "gc", "pid", "tp", " CPU", "p", "np", " cp", "linux", "hog", "cn", "jp", "CPU", "cache", "conn", "aq", "vm", "exe", "phy", "component", "nc", "coin", "loader", "chip", "cum", "ork", "result", "proc", "c", "core", "gpu", "aco", "processor", "computer", "bench", "node", "nu", "cmd", "ce", "prof", "pc", " pc", "ck", "cli", "goal", "php", "process", "cam", "instance", "obj", "null", "cu", "mem", "CP", "cal", "rc", "python", "pai", "clock", "hw", "px", "pu", "stat", "alloc", "pool", "cv"], "env": ["equ", "inst", "end", "viron", "np", "ve", "shell", "eng", "conn", "ei", "sc", "environment", "worker", "eh", "enc", "org", "server", "et", "pb", "buf", "aka", "hw", "eve", "erd", "cb", "cv", "term", "ctx", "mn", "vs", "cache", "den", "era", "doc", "bean", "scope", "config", "ec", "uv", "en", "ew", "desc", "eas", "ent", "priv", "v", "menu", "js", "dev", "state", "ev", "here", "engine", "console", "ptr", "nc", "ea", "init", "ten", "ue", "er", "proc", "app", "window", "next", "obj", "esp", "err", "kh", "eg", "start", "entry", "esc", "ah", "win", "ob", "door", "vp", "cmd", "ef", "db", "buffer", "disk", "nv", "event", "e", "context", "mem", "sv", "eu", "Environment"], "irqs": ["irtuds", "irqi", "irvals", "mirqi", "pirqs", "mirews", " irqi", " irfy", "mirq", " irq", "irqa", "irtfy", "irq", "irews", "piruds", "mirqs", "irigs", "iriigs", "rinuds", "iorqs", "irtigs", " irfts", "nirques", "irivals", "nirqi", "nirqs", " irews", "rinfts", "iruds", "irify", "irfy", "irfts", "irques", "irtqs", "rinques", "irtqi", "pirques", " irques", "iorqi", "mirfts", "rinqi", "iriqs", "rinqs", "nirqa", "iorqa", "irtvals", " irvals", "rinews", "pirqi", "iorques", "pirqa", "pirews", "mirques", "rinq", " irigs", "irtews"]}}
{"project": "FFmpeg", "commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "target": 1, "func": "static void create_default_qtables(uint8_t *qtables, uint8_t q)\n\n{\n\n    int factor = q;\n\n    int i;\n\n\n\n    factor = av_clip(q, 1, 99);\n\n\n\n    if (q < 50)\n\n        q = 5000 / factor;\n\n    else\n\n        q = 200 - factor * 2;\n\n\n\n    for (i = 0; i < 128; i++) {\n\n        int val = (default_quantizers[i] * q + 50) / 100;\n\n\n\n        /* Limit the quantizers to 1 <= q <= 255. */\n\n        val = av_clip(val, 1, 255);\n\n        qtables[i] = val;\n\n    }\n\n}\n", "idx": 22944, "substitutes": {"qtables": ["qtigs", "vtives", "vtables", "vtues", "qtiers", "vtries", "qtues", "txtries", "qtives", "txtives", "ktables", "txtues", "qqries", "ktigs", "qqiers", "qqigs", "qqables", "eques", "vtiers", "qtries", "ktries", "eqries", "eqables", "vtigs", "ktiers", "txtables", "eqives"], "q": ["m", "sq", "p", "frequency", "Q", "qt", "z", "qa", "fx", "type", "quit", " eq", "length", "eq", "w", "d", " qu", "quarter", "qu", " quality", "question", "n", "aq", "y", " req", " sq", "it", "que", "ue", "qi", "c", "r", "query", "quer", " queries", "print", "t", "quality", "k", "u", "g", " k", " qual", " p", "quad", "factor", "f", "iq", "count", "work", " quer", "ch", "qs", "qv", "x", " quant", "qual", "dq", " Q", "queue", " z", "qq", "quant", " query", "v", " queue"], "i": ["ta", "hi", "m", "me", " ti", "ci", "ix", "us", "z", "id", " bi", "multi", "zi", "si", "n", "ei", "y", "it", "xi", "init", "l", "status", "ij", "ti", "mi", "chain", "qi", "iu", "s", "info", "j", "iter", "di", "in", "\u0438", "ai", "t", "im", "print", " I", "uri", "ui", "phi", "gi", "li", "ic", "fi", " j", "ip", "sim", "ri", "client", "ji", "ini", "bi", " x", "ind", "index", "x", "ii", "pi", "asi", "I", "yi", "ik", "ki", "v", "val"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_close(AudioFrameQueue *afq)\n\n{\n\n    /* remove/free any remaining frames */\n\n    while (afq->frame_queue)\n\n        delete_next_frame(afq);\n\n    memset(afq, 0, sizeof(*afq));\n\n}\n", "idx": 22949, "substitutes": {"afq": ["afck", "rafdq", "afreq", "alfqu", " afck", "afqueue", "auxiq", "avqu", "affm", "lfck", "affql", "apq", "arpue", "affiq", "lfq", "auxq", " afue", "lfql", "alfdq", "auxqs", "affck", "auxqu", "afdq", "afue", "lfreq", "arpqs", "afql", "ajql", "afqs", "auxdq", "auxqq", "afm", "apqu", " afql", "avqueue", "arpiq", "ajue", "arpq", "afqq", "apue", "afqu", "apqueue", "alfq", "ajq", "affue", "affreq", "ajm", " afreq", "avq", "rafqq", "rafq", " afqu", "affque", " afqueue", "auxque", "affqs", "arpql", "alfqq", "arpque", "afque", "afiq", "affq", "rafqu", "avue", "arpm"]}}
{"project": "FFmpeg", "commit_id": "81cc7d0bd1eab0aa782ff8dd49e087025a42cdee", "target": 1, "func": "static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n\n{\n\n    int i;\n\n    int32_t *dst = (int32_t *) _dst;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n\n}\n", "idx": 22955, "substitutes": {"_dst": [" _fsrc", "_Dsts", "_fdest", "_fsrc", "_Ddest", "_fbr", " _fst", "_dsts", " _fbr", "_rbr", "_rst", "_Dst", "_Dot", "_rist", "_dbr", "_dot", "_dist", " _dsrc", "_dsist", "_dsst", "_dsrc", " _fist", "_dssrc", "_dsbr", "_rsrc", "_ddest", "_fot", " _dbr", "_fsts", " _dist", "_fst", "_fist"], "i": ["multi", " mi", "ims", "chain", "mi", " wi", "ski", "\u0438", " my", "uri", "phi", "ri", "ini", "ind", "x", "ii", "pi", "f", "ki", "im", " pi", " bi", "zi", "jp", "it", "b", "qi", "iu", "di", " I", "wi", " ni", "is", "v", "hi", "m", "me", "us", "si", "init", "xi", "ms", "ai", "fi", "ui", " multi", "li", " err", "batch", " ti", "ci", "p", "ix", " iter", " index", "id", "span", "y", "ij", "ti", "j", " ii", "gi", "ic", "sim", "ji", "e", "bi", "oi", "index", "asi", "I", "ex", "ogi"], "dst": ["dpt", "Dsts", " dST", "Ddest", "Dpt", "DST", " dust", " dnt", "dbr", "dist", "dspt", "dsst", "dust", " dsts", "dsbr", "dast", "jdest", "Dist", " dpt", " dist", "daist", "Dust", "Dbr", " ddest", "dsdest", "Dnt", "jst", " dbr", "ddest", "Dst", "dST", "jnt", "jsts", "dnt", "daust", "daST", "dsts"]}}
{"project": "FFmpeg", "commit_id": "1f80742f49a9a4e846c9f099387881abc87150b2", "target": 1, "func": "static void fill_coding_method_array(sb_int8_array tone_level_idx,\n\n                                     sb_int8_array tone_level_idx_temp,\n\n                                     sb_int8_array coding_method,\n\n                                     int nb_channels,\n\n                                     int c, int superblocktype_2_3,\n\n                                     int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n}\n", "idx": 22956, "substitutes": {"tone_level_idx": ["tone_level_aidx", "tone_level_idsg", "tone_level_idsn", "tone_level_uidg", "tone_level_ipn", "tone_level_idsu", "tone_level_uidu", "tone_level_ipg", "tone_level_intn", "tone_level_idg", "tone_level_idexes", "tone_levelptaidg", "tone_level_Idn", "tone_level_idsx", "tone_levelptidx", "tone_level__idp", "tone_level_idn", "tone_level_idxes", "tone_level_idp", "tone_level_idsxs", "tone_level_idu", "tone_level__idsg", "tone_level_idxs", "tone_level_iden", "tone_levelptidg", "tone_level_Idb", "tone_level_idsxes", "tone_level_Idx", "tone_level_idsch", "tone_level_idsp", "tone_level_uidx", "tone_level_intx", "tone_level__idsx", "tone_level__idg", "tone_level_idb", "tone_levelptidch", "tone_level_idexs", "tone_level_aidv", "tone_level_Idg", "tone_levelptidv", "tone_level__idu", "tone_level__idsu", "tone_level_aidch", "tone_level_idr", "tone_level_ipx", "tone_level__idxes", "tone_level_ider", "tone_level_idex", "tone_level_idsr", "tone_level_idv", "tone_level_intg", "tone_level_idep", "tone_levelptaidv", "tone_level_aidg", "tone_level_Idxs", "tone_level__idx", "tone_level__idxs", "tone_level_intxs", "tone_level_idsv", "tone_level_ipb", "tone_levelptaidx", "tone_levelptaidch", "tone_level__idsxs", "tone_level_idch", "tone_level_uidxs"], "tone_level_idx_temp": ["tone_level_idg_temp", "tone_level_idx2tem", "tone_level_idx__result", "tone_level_idx2current", "tone_level_idn_buffer", "tone_level_idg_result", "tone_level_idx2temp", "tone_level_idx__tem", "tone_level_idx2result", "tone_level_idn_tem", "tone_level_idx2tmp", "tone_level_idx2buffer", "tone_level_idx2Temp", "tone_level_idx_buffer", "tone_level_idn_Temp", "tone_level_idg_tmp", "tone_level_idn_temp", "tone_level_idx_tmp", "tone_level_idx_result", "tone_level_idn_current", "tone_level_idn_tmp", "tone_level_idx_tem", "tone_level_idx_current", "tone_level_idg_tem", "tone_level_idx_Temp", "tone_level_idx__tmp", "tone_level_idx__temp"], "coding_method": ["coder_table", "coder_method", "coder_data", "coding_table", "coding_map", "coder_map", "coding_data"], "nb_channels": ["nb_cannels", "nb_chunks", "nb_compannels", "nb_compans", "nb_Channels", "nb_chanannels", "nb_vertannels", "nb_chans", "nb_vertans", "nb_vertunks", "nb_champles", "nb_Chans", "nb_Chunks", "nb_camples", "nb_Champles", "nb_chanans", "nb_chanunks", "nb_cans", "nb_compamples"], "c": ["ac", "cp", "m", "p", "ca", "d", "cache", "n", "cm", "sc", "cc", "C", "l", "b", "cs", "fc", "lc", "config", "t", "count", "cv", "h", "rc", "f", "cb", "v", "ct"], "superblocktype_2_3": ["superblocktype_2_2", "superblocktype_2_15", "superblocktype_2p3", "superblocktype_2p15", "superblocktype_1_4", "superblocktype_3_7", "superblocktype_3_2", "superblocktype_2x7", "superblocktype_2_7", "superblocktype_2p1", "superblocktype_1_1", "superblocktype_3_3", "superblocktype_2p4", "superblocktype_2_1", "superblocktype_2_4", "superblocktype_2x3", "superblocktype_1_3", "superblocktype_2x2", "superblocktype_3_1", "superblocktype_1_15", "superblocktype_2x1"], "cm_table_select": ["cm_type_select", "cm_table_selection", "cm_type_selection", "cm_table2select", "cm_table2selection", "cm_table2table", "cm_table2opt", "cm_table_opt", "cm_table_table", "cm_type_opt", "cm_type_table"], "ch": ["cor", "vc", "Ch", "chi", "cha", "ot", "arch", "sc", "conn", "cht", "cs", "chrom", "CH", "et", "count", "work", "x", "hw", "chan", "cell", "cb", "ac", "cp", "q", "zh", "ih", "gb", "qu", "range", "ht", "att", "b", "bh", "sch", "che", "ach", " Ch", "m", "cr", "eb", "chart", "br", "ph", "ich", "ech", "mot", "er", "history", "gr", "atch", "channel", "hl", "tch", "th", "ct", "kh", "chron", "chn", "och", "ur", "uch", "ah", "y", "sh", "hand", "he", "bt", "gh", "i", "cho", "cd", "chat", "h", "sk"], "sb": ["jj", "ebin", "bb", "sp", "bs", "SB", "shell", "esm", "sc", "dB", "sa", "server", "sit", "rb", "pb", "sth", "bps", "sam", "bf", "cb", "gc", "erb", "nb", "esi", "jp", "gb", "wb", "bp", "shop", "dt", "b", "buff", "serv", "ben", "osp", "bh", "bj", "sch", "abb", "sid", "hh", "sf", "se", "fb", "usb", "gs", "sn", "ssl", "eb", "ja", "ub", "si", "bis", "sm", "meg", "orb", "kb", "sbm", "hs", "sys", "stat", "bn", "ha", "kh", "bc", "su", "gov", "nm", "src", "typ", "ij", "ob", "arb", "dh", "stab", "s", "sh", "sw", "ib", "bt", "db", "bg", "lb", "zb", "ji", "bi", "bot", "sv", "sr", "ibl", "sg", "sat", "sd"], "j": ["jj", "js", "m", "json", "so", "eg", "q", "p", "sp", "z", "ja", "uj", "pr", "aj", "at", "jp", "ot", "je", "ion", "br", "n", "fr", "y", "it", "jas", "oj", "dj", "l", "ij", "att", "ret", "jc", "b", "jet", "er", "jo", "ib", "kid", "i", "jl", "pt", "db", "bj", "g", "ng", "J", "adj", "job", "ji", "ju", "obj", "bi", "ind", "jit", "str", "jump", "kj", "ia", "ik", "v", "bo"], "tmp": ["temp", "cp", "jj", "perm", "Temp", "m", "pkg", "vv", "tp", "aaa", "mm", "trap", "np", "sp", "p", "mk", "td", "pad", "EMP", "emp", "tt", "gm", "tc", "cache", "copy", "prop", "src", "test", "appy", "tm", "yet", "mp", "etc", "mitt", "result", "attr", "prefix", "uu", "proc", "buff", "pot", "mmm", "cmd", "timeout", "pos", "t", "prime", "MP", "tn", "msg", "amp", "txt", "mint", "obj", "angle", "xy", "pre", "option", "tf", "qq", "cmp", "sup", "v"], "acc": ["ac", "temp", "dev", "eff", "perm", "inc", "alpha", "ca", "mom", "conf", "ag", "ann", "tc", "AC", "cache", "iff", "sc", "cc", "aff", "aw", "att", "attr", "aa", "ACC", "sum", "fac", "txt", "adj", "Acc", "angle", "rec", "op", "tf", "fee", "cmp", "ack", "cell"], "esp_40": ["espxconv", "fp_temp", "fp_unit", "esp_temp", "espx40", "esp_conv", "esp_unit", "espxunit", "fp_40", "espxtemp", "fp_conv"], "comp": ["ctx", "cp", "perm", "diff", "prep", "mod", "conf", "cache", "component", "com", "attr", "proc", "fc", "app", "cmd", "img", "cond", "butt", "ip", "comment", "change", "omp", "op", "Comp", "cmp", "sup", "cell"], "add1": ["added2", " add001", "app1", "drawOnce", "Add4", "saveOnce", "appOnce", "save001", "AddOne", "app4", "draw4", "ADD2", "add7", "Add2", " add7", "addOnce", "added001", "added4", "draw1", "draw001", "sum2", "dd1", "save1", " addOne", "Add7", "dd2", "sum4", "save4", "added1", "addOne", "Add001", "sum1", "ADD1", "app001", "Add1", "add001", "ADD7", "ddOne"], "add2": ["make4", "makeSecond", "Add6", "attach2", "attach1", " add6", "Add4", "addSecond", "Add2", "apply6", "Add02", "dd4", "new2", "newSecond", "dd3", "create2", "makeTwo", "add02", "dd1", "add6", "apply1", "attach6", "apply2", "dd6", "attach4", "dd2", "make2", "Add3", " add02", "new4", "apply02", "createSecond", "Add1", "create4", "newTwo", "createTwo", "addTwo"], "add3": ["attach03", "Add03", "add43", "eff3", "attach2", "append3", "add512", "append1", "append4", "createthree", "Add4", "attach1", " add6", "post1", "sum03", "added03", "post03", "plus003", "append03", "create3", "Add2", "plus3", "attachThree", "sum43", " addThree", "attach3", "post3", "addedThree", "added3", " add03", "effthree", "add6", "attach6", "attach4", "create003", "add03", "sum3", "addthree", "Add3", "addThree", "post43", "plusthree", "create512", "sum1", "add003", "append2", "eff003", "attach43", "Add1", "added6", "eff512", "plus512"], "add4": ["add04", "add14", "attach2", "update94", "Add22", "attach1", "Add4", "adder45", "added5", "add45", "adder16", "add5", "ext1", "ext5", "dd16", "plusNo", "Add2", "adder3", "build14", "addNo", "Add5", "dd4", "update4", "load4", "build4", "attach429", "build429", "add32", "added32", "plus45", "added4", "dd3", "Add04", "adder2", "load22", "update45", "ext32", "add94", "updateNo", "Add32", "adder4", "attach4", "dd2", " add429", "add22", "add16", " add14", "attach04", "added1", "adder94", " add22", "adderNo", "add429", "attach14", "load1", "ext4", " add04", "build1", "Add1", " add16", "plus4", "plus94"], "multres": ["divret", "diffret", "diffres", "diffrem", "subRes", "_res", "_rem", "_Res", "subrem", "divres", "divRes", "_ret", "diffRes", "subres", "subret", "divrem"]}}
{"project": "FFmpeg", "commit_id": "9ec39937f9c7f28a2279a19f71f290d8161eb52f", "target": 1, "func": "static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,\n\n                        int width, int height, int stride, Transform *t)\n\n{\n\n    int x, y;\n\n    IntMotionVector mv = {0, 0};\n\n    int counts[128][128];\n\n    int count_max_value = 0;\n\n    int contrast;\n\n\n\n    int pos;\n\n    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * deshake->blocksize));\n\n    int center_x = 0, center_y = 0;\n\n    double p_x, p_y;\n\n\n\n    // Reset counts to zero\n\n    for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n        for (y = 0; y < deshake->ry * 2 + 1; y++) {\n\n            counts[x][y] = 0;\n\n        }\n\n    }\n\n\n\n    pos = 0;\n\n    // Find motion for every block and store the motion vector in the counts\n\n    for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) {\n\n        // We use a width of 16 here to match the libavcodec sad functions\n\n        for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) {\n\n            // If the contrast is too low, just skip this block as it probably\n\n            // won't be very useful to us.\n\n            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);\n\n            if (contrast > deshake->contrast) {\n\n                //av_log(NULL, AV_LOG_ERROR, \"%d\\n\", contrast);\n\n                find_block_motion(deshake, src1, src2, x, y, stride, &mv);\n\n                if (mv.x != -1 && mv.y != -1) {\n\n                    counts[mv.x + deshake->rx][mv.y + deshake->ry] += 1;\n\n                    if (x > deshake->rx && y > deshake->ry)\n\n                        angles[pos++] = block_angle(x, y, 0, 0, &mv);\n\n\n\n                    center_x += mv.x;\n\n                    center_y += mv.y;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pos = FFMAX(1, pos);\n\n\n\n    center_x /= pos;\n\n    center_y /= pos;\n\n\n\n    t->angle = clean_mean(angles, pos);\n\n    if (t->angle < 0.001)\n\n        t->angle = 0;\n\n\n\n    // Find the most common motion vector in the frame and use it as the gmv\n\n    for (y = deshake->ry * 2; y >= 0; y--) {\n\n        for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n            //av_log(NULL, AV_LOG_ERROR, \"%5d \", counts[x][y]);\n\n            if (counts[x][y] > count_max_value) {\n\n                t->vector.x = x - deshake->rx;\n\n                t->vector.y = y - deshake->ry;\n\n                count_max_value = counts[x][y];\n\n            }\n\n        }\n\n        //av_log(NULL, AV_LOG_ERROR, \"\\n\");\n\n    }\n\n\n\n    p_x = (center_x - width / 2);\n\n    p_y = (center_y - height / 2);\n\n    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;\n\n    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;\n\n\n\n    // Clamp max shift & rotation?\n\n    t->vector.x = av_clipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2);\n\n    t->vector.y = av_clipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2);\n\n    t->angle = av_clipf(t->angle, -0.1, 0.1);\n\n\n\n    //av_log(NULL, AV_LOG_ERROR, \"%d x %d\\n\", avg->x, avg->y);\n\n    av_free(angles);\n\n}\n", "idx": 22959, "substitutes": {"deshake": ["doothale", "deware", "dashak", "deshcake", "dellyale", "dreshalk", "dreshcake", "deshoke", "dreshask", "meshak", " dleshade", "dishair", "deshak", "dahake", " dewaker", "dreshak", "fdreshoke", "weshark", " dreshalk", "seshark", "deshalk", "dreshale", "dewade", "desmark", "desmare", "dashaker", "deworkak", "sdeshare", "dideshake", "dateshrake", "sewak", "deworkake", "ondeshake", "dewuke", "dleshase", "dethoke", "fdeshare", "desmalk", "dellyapp", "dseshcake", "weshake", " dreshask", "dewapp", "ondishark", " deshare", "dewache", "dellake", " deshaker", "seshapp", "desmak", "dleshak", "datesmake", "datesmank", "dahair", "seshak", "deshask", "sdesmare", "dulfade", " dewair", "dashare", "dellyake", " deware", "dellade", "dethuke", "dalshake", "dateshank", "harshuke", "dalityaker", "dsreshcake", "darshask", "deshase", "datesmrake", " dleshalk", "dalshask", "dalshaze", "meshark", "dalityare", "weshaze", "dewair", "dishank", "dshalk", "deshade", "didalityaker", " dreshak", "dishark", "dethask", "deshaker", "meware", "deshank", "daeshake", "dellak", "dewaze", "dreshark", "harshask", " deshase", "dewask", "dewcake", " deshade", "heshare", "ondishake", "desmcake", "meshake", " deshak", "dishare", "dulfaker", "dishak", "dseshak", "weshak", "dismade", " deshark", "mewake", "dsreshak", "dellyak", "dateshalk", "meshare", " deshaze", "deworkcake", "dhlake", "fdreshak", "harshare", "sdesmache", "dahak", "deshair", "dhlark", "dulfark", "dreshank", "dalityak", "seshake", "desmrake", "dshair", " dleshake", "didalityare", "deshare", "dreshoke", " dewak", "didalityake", " dreshaze", "dshare", "doothapp", "fdeshoke", "fdeshake", "heshuke", "daeshale", "wreshake", "dethare", "dethak", "dalshak", "dishcake", "sewark", "desmapp", "dalityake", "sdesmcake", "dethalk", " dreshare", "darshake", "dewark", "dashake", " deshalk", "dellaze", "heshask", "darshuke", " dewake", "darshare", "ondeshare", "desmank", "dhlare", "deshale", "daeshapp", "dahark", "dismake", "dethake", "daoothak", "dleshark", "desmache", "dreshrake", "dleshade", "darshak", "deshapp", "dleshake", "fdeshak", "darshoke", "daoothapp", "dismalk", "deshache", "mewak", "dreshase", "dahare", "doothak", "dewake", "ondeshark", "sdeshake", "desmake", "ondeshair", "wreshak", "dreshade", "sdeshache", "dreshake", "dishake", "deshuke", "deshrake", "ondishare", "dateshake", "darshcake", "fdreshare", "dideshask", "dshank", " dewark", "dalshalk", " dreshade", "dhlak", "daeshak", "ondishair", "dethaker", "dleshapp", "dseshake", "dshark", "dewak", "fdreshake", "harshake", "sdeshcake", "dshake", " deshair", "deworkank", " deshask", "deshark", "dreshaze", "dreshare", "dulfake", "dismase", " dreshake", "dsreshank", "didalityask", "dalityaze", "dreshapp", "dleshalk", "deshaze", "daoothake", "daoothale", "datesmalk", "sdesmake", "dalityark", "dleshaker", "dewaker", "dsreshake", "dideshare", " dleshase", "wreshaze", "wreshark", "sewake", "dshrake", "heshake", "sewapp", "dalityask", "dseshank", "dideshaker", "mewark", "dalshare", "doothake", "dalshade", "darshache"], "src1": ["source1", " src0", "src0", " src3", "rc0", "rc1", "rc3", "source0", "source2", "source3", "rc2", "src3"], "src2": ["source1", " src4", " src0", "src0", " src3", "rc0", "rc1", "rc4", "rc3", "source0", "source4", "source2", "source3", "src4", "rc2", "src3"], "height": ["Height", "stroke", "ty", "volume", "ows", "depth", "radius", "length", "w", "padding", "scroll", "range", "resolution", "feed", "ht", "capacity", "style", "sky", "gravity", "history", "hei", "he", "ow", "density", "rows", "shape", "size", "pace", "buffer", "count", "window", "lat", "hang", "row", "ch", "angle", "flow", "h", "bottom", "hub", "val"], "stride": ["charride", "strend", " strend", "strategy", "distension", "STRage", "striide", "slride", "strice", "slide", " strides", "strride", " strride", "charage", "STRension", "striice", "STRride", "STRategy", "STRides", "STRice", "strides", "charension", "striides", "charide", "strage", "distage", "distide", " strategy", "striride", "distride", " strice", "strension", "STRide", "slend", "slategy", "STRend"], "t": ["ta", "m", "tv", "tp", " T", "p", "vt", "o", "at", "td", "translation", "tr", "tt", "type", "ot", "tc", "tree", "tg", "ant", "n", "it", "dt", "tm", "l", "status", "text", "wt", "tl", "c", "r", "tk", "ts", "T", "pt", "tu", "g", "txt", "target", "total", "e", "title", "tf", "st", "f", "table", "trace", "term", "v", "ct"], "x": ["xp", "check", "ox", "rx", "at", "ex", "yx", "by", "on", "xa", "dr", "xml", " xx", "X", "wx", "px", "f", "im", "any", "ty", "mx", "q", "z", "ax", "xxx", "l", "att", "ware", "xes", "xy", "xxxx", "v", "fx", "m", "xx", "dx", "xc", "xi", "lon", "lex", "r", "act", "g", "ux", "al", "xf", "lat", "el", "ct", "ix", "xd", "p", "w", "n", "inx", "xe", "xt", "tx", "sw", "j", "zx", "i", "key", "e", "sex", "xs", "index"], "y": ["iy", "hot", "fy", "ot", "by", "on", "ly", "ye", "yr", "yt", "yy", "yn", "axy", "ies", "ip", "a", "ch", "yi", "ya", "any", "ity", "ty", "try", "o", "z", "year", "vy", "l", "b", "ny", "Y", "asy", "story", "col", "hy", "xy", "yer", "wy", "sy", "v", "m", "yl", "my", "ady", "xx", "or", "ay", "ym", "py", "sky", "zy", "g", "uy", "lat", "entity", "sys", "ery", "oy", "p", "aily", "yo", "ry", "c", "j", "ys", "i", "key", "ey", "hey", "e", "h", "cy", "gy"], "counts": ["Countps", " countps", " countries", "countls", "Counts", "counters", "countries", "counterps", "countids", "contals", "ountls", "Countries", " countids", "Countls", "countps", "ountries", "ounted", "Counted", "countstats", "countments", "contments", "counterstats", " countls", "ountids", "ountals", "countals", "countered", " countals", "ountps", "contids", " countments", "counted", "conts", "Countstats", "ountments", "ountstats", "ounts"], "contrast": ["conteff", "contact", "disterence", "contract", "compact", "condact", " contract", "disteff", "condness", "distract", "condride", "sturb", "conderence", "distrast", "conterence", " contness", "compride", "stact", "contrib", "conrast", "conact", "strast", "constness", "compurb", "contness", "stract", "constride", "conride", "condrast", " conterence", " contride", "distact", "distrib", "steff", "conurb", "constrast", "onterence", "ontrib", "ontrast", "distride", "conturb", "condrib", "contride", "consterence", " conteff", "comprast", "ontact"], "pos": ["min", "pid", "post", " position", "rot", "spec", "num", "p", "start", "pp", "o", "Pos", "sp", "slot", "yes", "conf", "loc", "port", "Position", "tmp", "up", "def", "n", "ps", "prop", "it", "offset", "init", "l", "win", "vol", "limit", "proc", "top", "no", "po", "POS", "axis", "point", "pt", "neg", "origin", "size", "cond", "pro", "col", "pc", "position", "ref", "pose", "len", "out", "row", "ind", "index", "os", "pi", " POS", "pres", "px", " Pos", "val"], "angles": ["assets", "balls", "rots", "ints", "bits", "rates", "points", "params", "ads", "objects", "amps", "atters", "views", "anges", "aches", "bars", "vs", "outs", "bytes", "types", "ians", "rings", "blocks", "ims", "inches", "values", "files", "s", "mas", "angular", "images", "units", "faces", "errors", "lines", "rows", "maps", "bles", "chains", "phi", "ays", "ations", "ions", "boxes", "actions", "rices", "angle", "xs", "ates", "vals", "aces", "bys", "pages", "heads", "forms"], "p_x": ["p_tx", "p2x", "l_x", "p___tx", "l_tx", "l_w", "p_w", "p2w", "p2tx", "l_y", "p___y", "p___x", "p2y", "p___w"], "p_y": ["p_ry", " p___y", " p_ry", " p___by", "pointxy", " p___xy", "p___xy", "p___ry", "pointy", " p___ry", "pointby", "p___y", "p_by", " p_xy", "p_xy", "pointry", "p___by", " p_by"]}}
{"project": "FFmpeg", "commit_id": "984f50deb2d48f6844d65e10991b996a6d29e87c", "target": 1, "func": "static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt)\n\n{\n\n    DiracContext *s     = avctx->priv_data;\n\n    AVFrame *picture    = data;\n\n    uint8_t *buf        = pkt->data;\n\n    int buf_size        = pkt->size;\n\n    int i, data_unit_size, buf_idx = 0;\n\n    int ret;\n\n\n\n    /* release unused frames */\n\n    for (i = 0; i < MAX_FRAMES; i++)\n\n        if (s->all_frames[i].avframe->data[0] && !s->all_frames[i].avframe->reference) {\n\n            av_frame_unref(s->all_frames[i].avframe);\n\n            memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));\n\n        }\n\n\n\n    s->current_picture = NULL;\n\n    *got_frame = 0;\n\n\n\n    /* end of stream, so flush delayed pics */\n\n    if (buf_size == 0)\n\n        return get_delayed_pic(s, (AVFrame *)data, got_frame);\n\n\n\n    for (;;) {\n\n        /*[DIRAC_STD] Here starts the code from parse_info() defined in 9.6\n\n          [DIRAC_STD] PARSE_INFO_PREFIX = \"BBCD\" as defined in ISO/IEC 646\n\n          BBCD start code search */\n\n        for (; buf_idx + DATA_UNIT_HEADER_SIZE < buf_size; buf_idx++) {\n\n            if (buf[buf_idx  ] == 'B' && buf[buf_idx+1] == 'B' &&\n\n                buf[buf_idx+2] == 'C' && buf[buf_idx+3] == 'D')\n\n                break;\n\n        }\n\n        /* BBCD found or end of data */\n\n        if (buf_idx + DATA_UNIT_HEADER_SIZE >= buf_size)\n\n            break;\n\n\n\n        data_unit_size = AV_RB32(buf+buf_idx+5);\n\n        if (buf_idx + data_unit_size > buf_size || !data_unit_size) {\n\n            if(buf_idx + data_unit_size > buf_size)\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Data unit with size %d is larger than input buffer, discarding\\n\",\n\n                   data_unit_size);\n\n            buf_idx += 4;\n\n            continue;\n\n        }\n\n        /* [DIRAC_STD] dirac_decode_data_unit makes reference to the while defined in 9.3 inside the function parse_sequence() */\n\n        if (dirac_decode_data_unit(avctx, buf+buf_idx, data_unit_size))\n\n        {\n\n            av_log(s->avctx, AV_LOG_ERROR,\"Error in dirac_decode_data_unit\\n\");\n\n            return -1;\n\n        }\n\n        buf_idx += data_unit_size;\n\n    }\n\n\n\n    if (!s->current_picture)\n\n        return buf_size;\n\n\n\n    if (s->current_picture->avframe->display_picture_number > s->frame_number) {\n\n        DiracFrame *delayed_frame = remove_frame(s->delay_frames, s->frame_number);\n\n\n\n        s->current_picture->avframe->reference |= DELAYED_PIC_REF;\n\n\n\n        if (add_frame(s->delay_frames, MAX_DELAY, s->current_picture)) {\n\n            int min_num = s->delay_frames[0]->avframe->display_picture_number;\n\n            /* Too many delayed frames, so we display the frame with the lowest pts */\n\n            av_log(avctx, AV_LOG_ERROR, \"Delay frame overflow\\n\");\n\n\n\n            for (i = 1; s->delay_frames[i]; i++)\n\n                if (s->delay_frames[i]->avframe->display_picture_number < min_num)\n\n                    min_num = s->delay_frames[i]->avframe->display_picture_number;\n\n\n\n            delayed_frame = remove_frame(s->delay_frames, min_num);\n\n            add_frame(s->delay_frames, MAX_DELAY, s->current_picture);\n\n        }\n\n\n\n        if (delayed_frame) {\n\n            delayed_frame->avframe->reference ^= DELAYED_PIC_REF;\n\n            if((ret=av_frame_ref(data, delayed_frame->avframe)) < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    } else if (s->current_picture->avframe->display_picture_number == s->frame_number) {\n\n        /* The right frame at the right time :-) */\n\n        if((ret=av_frame_ref(data, s->current_picture->avframe)) < 0)\n\n            return ret;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    if (*got_frame)\n\n        s->frame_number = picture->display_picture_number + 1;\n\n\n\n    return buf_idx;\n\n}\n", "idx": 22966, "substitutes": {"avctx": ["avetc", "avsys", " avconn", "avcb", "averreq", " avtc", "savreq", " avcontext", "avesys", "savctx", "vcontext", "avercontext", "afconn", "avereq", "averctx", "aversys", "vconn", "avepool", "navpool", "avekb", " avcb", "afcontext", "avconn", " avkb", "apconn", "avecontext", "avertx", "avecb", "navctx", "averpool", "avecli", "avetx", "vctx", "savcli", "avectx", "apctx", "afctx", "avcontext", "avkb", "avreq", "averkb", "navtx", "avtc", "navtc", "avcli", "avercli", " avtx", "savsys", "aptx", "vtx", "apcontext", "avertc", "aveconn", "afcb", "avtx", "avpool"], "data": ["funding", "family", "name", "type", "bin", "png", "info", "join", "video", "format", "extra", "actions", "a", "none", "DATA", "package", "record", "pic", "block", "Data", "table", "action", "d", "padding", "important", "cache", " DATA", "root", "img", "map", "whatever", "message", "frame", "piece", "present", "this", "bits", "pad", "image", "length", "mu", "to", "url", "original", "text", "raw", "empty", "Picture", "metadata", "window", "snap", "policy", "batch", "fp", "share", "rel", "sequence", "dat", "p", "input", "id", "photo", "password", "def", "value", "bytes", "no", "quality", "size", "buffer", "media", "ata", "new"], "got_frame": ["got_msg", "fetched___frame", "got___frames", "fetched___msg", "kept_fb", "gotlyframe", "got___msg", "got_fb", "gotNewoffset", "kept_error", "got___time", "got_time", "got___Frame", "got___next", "fetched_Frame", "gotNewframe", "gotlyFrame", "gotlymsg", "got_Frame", "fetched___time", "gotlytime", "got_error", "gotNewnext", "fetched___Frame", "fetched_msg", "gotNewframes", "kept_frame", "fetched_frame", "got_next", " got_frames", "kept_frames", "got___offset", "fetched_time", "got_offset", " got_offset", " got_next", "got_frames", "got___frame"], "pkt": ["proacket", "opdu", "macket", "cppt", "pppt", "prock", "pdu", " packet", "mkt", "opck", " ppt", "opkt", "cpacket", "opacket", "ppt", "ppacket", "cpkt", "produ", "ppdu", "cpdu", "mdu", "mck", "ppkt", "prokt", "packet", "cpck", " pdu", " pck", "pck"], "s": ["pkg", "comments", "rs", "bs", "events", "sc", "aunts", "fs", "ims", "sa", "cs", "stats", "set", "ins", "its", "actions", "a", "sam", "ares", "os", "ctx", "list", "ls", "d", "vs", "ps", "ds", "ess", "ts", "less", "these", "ports", "local", "is", "v", "js", "gs", "ssl", "sl", "parts", "states", "ms", "ses", "ss", "aws", "g", "hs", "services", "scripts", "sts", "sys", "ats", "sports", "comm", "spec", "p", "sq", "details", "w", "sb", "service", "c", "as", "sw", "t", "ns", "changes", "sv", "qs", "h", "S", "als", "ex"], "picture": ["pid", "profile", "family", "p", "file", "id", "image", "photo", "pict", "camera", "png", "P", "style", "info", "feature", "root", "Picture", "img", "video", "document", "frame", "fi", "piece", "record", "pic", "media", "policy", "fp"], "buf": ["ctx", "pkg", "ff", "uf", "pack", "p", "np", "v", "seq", "pad", "cast", "bc", "box", "tmp", "ptr", "def", "br", "cache", "Buffer", "bytes", "prop", "lim", "ob", "b", "text", "proc", "doc", "buff", "iter", "cmd", "img", "func", "map", "bl", "db", "rb", "buffer", "env", "msg", "txt", "ref", "vec", "Buff", "window", "cam", "desc", "cur", "emb", "mem", "conv", "arr", "queue", "aka", "fb", "err", "cap", "pool", "cb", "cv"], "i": ["m", "me", "list", "json", " ti", "ci", "ix", "p", "my", "id", "details", "mount", "si", "zi", "multi", " mi", "n", "y", "it", "xi", "ims", "ij", "ti", "mi", "qi", "info", "iu", "c", "j", "di", "point", "\u0438", "ai", "t", "im", "remote", " ii", "fi", "ui", "gi", "ic", "li", "uri", "phi", " j", "ip", "sim", "iq", "ri", "cli", "ji", "ini", "bi", "e", " m", "ind", "conv", "oi", "index", "x", "ii", "pi", "batch", "asi", "I", "ami", "ex", "io", "f", "ki", "v"], "data_unit_size": ["data_unit\u05bcSIZE", "data_unit_error", "data_unit2size", "data_unit2string", "data_unit\u05bcsize", "data_unitingSIZE", "data_unitingsize", "data_unit_from", "data_unit__size", "data_unitingfrom", "data_unit_name", "data_unit2Size", "data_unit\u05bcerror", "data_unitingSize", "data_unit_type", "data_Unit_Size", "data_block_size", "data_unit2type", "data_unit\u05bccount", "data_Unit_size", "data_unit_string", "data_unit_Size", "data_unit__SIZE", "data_unit_count", "data_block_Size", "data_unit__vector", "data_Unit_name", "data_unit_length", "data_unit__Size", "data_unit_SIZE", "data_block_type", "data_unit_vector"], "ret": [" ref", " out", " ar", "Ret", "__", " r", " bi", "si", " mi", "mi", " resp", "ry", " num", " ptr", " new", "j", " af", "fi", " res", "il", "len", "mem", " status", " count", "RET", "val"], "buf_idx": ["bufptdirox", "buf_indexxs", "buf_atn", "buf_idez", "buf_ate", "buf_idz", "buf_ide", "buf_idsx", "buf_IDfx", "buf_Idx", "buf_midox", "bufptidxs", "buf_idsex", "buf_idsw", "buf_idex", "buf_Idz", "buf_indx", "buf_logxs", "buf_keyx", "buf_handlex", "bufptdix", "buf_handlety", "buf_inex", "buf_storexs", "buf_intern", "buf_ix", "buf_ideox", "bufptiddx", "buf_dirox", "buf_idv", "buf_index", "buf_logx", "buf_IDdx", "buf_storen", "buf_iterz", "buf_indexz", "buf_idsic", "buf_odox", "buf_idw", "buf_indix", "buf_ordix", "buf_storenex", "buf_idrox", "buf_intere", "buf_idexp", "buf_iternex", "buf_didx", "buf_keyty", "buf_IDw", "bufptidx", "buf_idenex", "buf_iterox", "buf_idax", "buf_indax", "buf_iterx", "buf_in", "buf_IDox", "buf_iex", "buf_odnex", "buf_indfx", "bufptdidx", "buf_odw", "buf_IDnex", "buf_idxs", "buf_idix", "buf_storex", "buf_logdx", "buf_iterv", "buf_idn", "buf_Idex", "buf_logrox", "buf_outxt", "buf_iterfx", "buf_keyix", "buf_ideix", "buf_IDix", "buf_iterdx", "buf_inddx", "buf_ordx", "buf_idnex", "buf_IDx", "buf_indv", "buf_iz", "buf_ixs", "buf_Idn", "bufptidrox", "buf_ideex", "buf_idsix", "buf_indn", "buf_dix", "buf_midx", "buf_atxp", "buf_midix", "buf_handleix", "buf_indexdx", "buf_IDxs", "buf_indz", "buf_IDrox", "buf_idee", "buf_interx", "buf_outx", "buf_iden", "buf_idty", "buf_iterex", "buf_idxt", "buf_ordex", "buf_iddx", "buf_idsxt", "buf_indxs", "buf_indexx", "buf_idew", "buf_iterix", "buf_keyox", "buf_midty", "buf_interxp", "buf_ordox", "buf_idic", "buf_dixs", "buf_iax", "buf_indexax", "buf_indnex", "buf_idfx", "buf_idox", "buf_idsv", "buf_outic", "buf_handleox", "buf_outw", "buf_odx", "buf_idxp", "buf_atx", "bufptdixs"]}}
{"project": "qemu", "commit_id": "7372c2b926200db295412efbb53f93773b7f1754", "target": 1, "func": "static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,\n\n                   int opsize, TCGv val, TCGv *addrp, ea_what what)\n\n{\n\n    TCGv reg;\n\n    TCGv result;\n\n    uint32_t offset;\n\n\n\n    switch ((insn >> 3) & 7) {\n\n    case 0: /* Data register direct.  */\n\n        reg = DREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            gen_partset_reg(opsize, reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 1: /* Address register direct.  */\n\n        reg = AREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            tcg_gen_mov_i32(reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 2: /* Indirect register */\n\n        reg = AREG(insn, 0);\n\n        return gen_ldst(s, opsize, reg, val, what);\n\n    case 3: /* Indirect postincrement.  */\n\n        reg = AREG(insn, 0);\n\n        result = gen_ldst(s, opsize, reg, val, what);\n\n        /* ??? This is not exception safe.  The instruction may still\n\n           fault after this point.  */\n\n        if (what == EA_STORE || !addrp)\n\n            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));\n\n        return result;\n\n    case 4: /* Indirect predecrememnt.  */\n\n        {\n\n            TCGv tmp;\n\n            if (addrp && what == EA_STORE) {\n\n                tmp = *addrp;\n\n            } else {\n\n                tmp = gen_lea(env, s, insn, opsize);\n\n                if (IS_NULL_QREG(tmp))\n\n                    return tmp;\n\n                if (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n", "idx": 22969, "substitutes": {"env": ["ctx", "vt", "viron", "exc", "ev", "conf", "w", "esc", "ptr", "sb", "vs", "sc", "conn", "environment", "init", "ds", "er", "scope", "sw", "config", "ec", "ss", "ens", "server", "map", "en", "et", "setup", "window", "buf", "con", "nv", "obj", "e", "context", "h", "rc", "hw", "st", "erd", "v"], "s": ["ctx", "js", "gs", "m", "ssl", "ls", "q", "p", "sq", "sp", "es", "rs", "conf", "sb", "vs", "n", "ps", "sc", "src", "ims", "ds", "b", "er", "c", "ms", "r", "ts", "serv", "ses", "ss", "stats", "t", "aws", "args", "g", "en", "ns", "ins", "its", "a", "obj", "e", "sts", "sv", "sys", "sg", "os", "S", "is", "v"], "insn": ["outsgn", "linsln", "linsne", "esm", "inson", "linesn", "rsnr", "insm", "opsc", "opsz", "obson", "risn", "insin", "opsgn", "insyn", "kinsl", "insne", "insz", "rsN", "inssn", " insne", "opspan", "linsnr", "insns", " insm", "rsn", "opsln", "rsln", "linsns", "inspan", "linsk", "obsn", "opsnr", "linsyn", " insz", "insN", "obsen", "esne", "kinsn", " inssn", "insnia", "csns", "csen", "insk", "outsen", "linsen", "linsnia", "rissn", "rssn", "rsk", "rsize", "outson", "insl", "insln", "ysize", "opssn", "linsc", "esn", " insN", "INSsn", "opsin", "linson", "outssn", "INSz", "mssn", "ysn", "linesl", "msn", "obsns", "rison", "csn", "linsl", "opsen", " insize", "opsn", "linssn", "insgn", "insen", "rsc", "opsN", "insnr", "insc", "linesyn", "outsize", "INSin", "opsk", "INSn", "linesnia", " insin", "msne", "linsgn", "ysne", "esize", "linsize", "risne", "mson", "linsn", "rson", "kinsyn", "INSpan", "INSN", "kinsnia", "insize", "outspan", "ysm", "INSen", "cson", "rsz", "rsgn", "outsn"], "opsize": [" opsizer", " opsiz", " opseng", "oopsIZE", " topsize", "timesizer", "offseng", "timesization", "OPSsize", "psiz", "oopsize", "opseng", "upsize", "opize", "psizer", "insization", "psization", "artsiz", "OPSizer", "artsization", "bitsized", "bitsizer", "opsiz", "opization", "bysization", "oopsiz", "bitsization", " opsized", "opersizer", "inssize", "opsized", "insiz", "offsize", "bitsIZE", "artsizer", "bysize", "openg", "opsization", "rsize", "offsizer", "topsization", "rsIZE", "oopsizer", "rsization", " topsized", "topsIZE", "upsiz", "OPSIZE", "OPSization", "outsiz", "topsize", "bysIZE", "opiz", "OPSize", "timesize", "opsIZE", "outsization", "OPSiz", " topsiz", "topsizer", "rsizer", " opsization", "upsization", "outsize", " topsizer", "rssize", "psize", "bitsiz", "outsIZE", "opersization", "upssize", "opsizer", "bitsize", "rsiz", "artsize", "bysizer", "oopssize", "opersize", "opizer", "insizer", "opssize", "insize", "opersiz", "timesiz", "offsization", "oopsization"], "val": ["vt", "data", "grad", "ival", "sel", "conf", "loc", "util", "def", "value", "typ", "test", "ret", "expr", "vol", "values", "doc", "lib", "VAL", "tx", "serv", "item", "func", "eval", "res", "cond", "Val", "cho", "key", "pol", "ref", "vec", "var", "al", "resp", "buf", "rol", "bal", "obj", "el", "arg", "mem", "local", "x", "cal", "addr", "urg", "vals", "err", "valid", "rel", "stat", "v"], "addrp": [" addrr", " addrpc", " addrpid", "arrpa", "addrpre", " addrps", "alignps", "ptrpid", "addrjp", "addrpc", "arppc", " addrpa", " addrpy", "arrpy", "arrlp", " addrjp", "addrr", "addrlp", "alignup", "addrpa", "arplp", "dirlp", "hostlp", "alignr", "dirpre", "addrpid", "aliasp", "addrpar", "oadps", "ptrps", "hostpre", "addrps", "arppre", "adpar", "oadjp", "addrP", "aliasps", " addrlp", "adp", "arrpre", "ptrpa", "ptrr", "ptrp", "alignpar", "addressp", "ptrm", "arpp", " addrpre", " addrm", "aliaspid", "arrpc", "ptrpar", " addresspc", " addresspa", "alignpid", "hostp", "addrm", "oadup", "hostpc", "oadp", "addressP", "dirp", "addressps", "dirpy", " addressp", "aliasP", "addrup", "adm", "addresspid", "alignp", "alignjp", "addrpy", "alignpa", " addrup", "adpa", "ptrP", "arrp", "alignm"], "what": ["wh", "why", "spec", "something", "nothing", "make", "wat", "when", "here", "type", "such", "because", "w", "hat", "have", "which", "tag", "important", "also", "that", "typ", " why", "test", "warn", "things", "aw", "feat", "good", "fun", "WH", "stuff", "doc", "kind", "wrong", "who", "enough", "act", "format", "WHO", "WHAT", " who", "whatever", "forth", "wash", "from", "where", "need", "having", "did", "want", "goal", "msg", "hop", "everything", "hod", " which", "work", "wcs", "wal", "how", "What", " WHAT", "yeah", " how", "were", "thing", "meaning"], "reg": ["memory", "eng", "disc", "conn", "ret", "org", "dr", "order", "rank", "resp", "buf", "sam", "arg", "leg", "ress", "arr", "cod", "gc", "gro", "data", "mod", "tag", "trans", "cache", "region", "ser", "serv", "net", "map", "adj", "jump", "urg", "Reg", "rc", "state", "req", "loc", "roy", "ptr", "br", "orig", "red", "rem", "rep", "bor", "gr", "r", "grid", "res", "cond", "g", "REG", "msg", "re", "var", "ru", "obj", "row", "form", "sys", "err", "stat", "eg", "dat", "def", "value", "lr", "ig", "go", "rar", "db", "key", "ref", "rol", "out", "code", "mem", "rec", "rr", "addr", "pg"], "result": ["relation", "current", "same", "response", "public", "json", "success", "profile", "p", "data", "sp", "make", "cont", "description", "report", "pr", "complete", "def", "cache", "value", "rn", "test", "status", "successful", "ret", "proc", "r", "function", "func", "results", "res", "message", "output", "match", "buffer", "first", "msg", "total", "cur", "resp", "other", "next", "process", "coord", "comment", "diff", "row", "out", "comb", "rule", "comp", "rc", "new", "Result", "err", "valid", "cmp", "pair", "table", "term", "v", "final"], "offset": ["start", "sp", "slot", "loc", "ptr", "field", "cache", "shift", "Offset", "address", "top", "flag", "point", "pointer", "pos", "extra", "size", "error", "ref", "var", "count", "coord", "off", "obj", "base", "index", "addr", "seek"], "tmp": ["pkg", "acc", "np", "sp", "tc", "copy", "ret", "attr", "nt", "extra", "rap", "gz", "cur", "resp", "buf", "ind", "table", "term", "cv", "ctx", "cp", "try", "tp", "vt", "emp", "jp", "cache", "partial", "mp", "prefix", "rt", "buff", "uv", "img", "amp", "mint", " np", "xy", "v", "temp", "perm", "mk", "tt", "loc", "ptr", "orig", "appy", "empty", "uff", "txt", "var", "snap", "obj", "comp", " sp", "err", "old", "p", "src", "tar", "etc", "top", "vp", " prev", "t", "prev", "out", "null", "mem", "addr", "new", "cmp"]}}
{"project": "FFmpeg", "commit_id": "1330a0f31f373f3b9f1ea53d48b94edc47759b76", "target": 1, "func": "static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->bit_rate > 0) {\n\n        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n\n\n    if (avctx->rc_max_rate > 0)\n\n        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;\n\n\n\n    if (ctx->rc < 0) {\n\n        if (ctx->flags & NVENC_ONE_PASS)\n\n            ctx->twopass = 0;\n\n        if (ctx->flags & NVENC_TWO_PASSES)\n\n            ctx->twopass = 1;\n\n\n\n        if (ctx->twopass < 0)\n\n            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;\n\n\n\n        if (ctx->cbr) {\n\n            if (ctx->twopass) {\n\n                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;\n\n            } else {\n\n                ctx->rc = NV_ENC_PARAMS_RC_CBR;\n\n            }\n\n        } else if (avctx->global_quality > 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;\n\n        } else if (ctx->twopass) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;\n\n        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;\n\n        }\n\n    }\n\n\n\n    if (ctx->flags & NVENC_LOSSLESS) {\n\n        set_lossless(avctx);\n\n    } else if (ctx->rc > 0) {\n\n        nvenc_override_rate_control(avctx);\n\n    } else {\n\n        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;\n\n        set_vbr(avctx);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n}\n", "idx": 22970, "substitutes": {"avctx": ["Avcontext", "avsys", "avekl", "avfp", "avdocument", "iamctx", "varkw", " avconn", "avcmp", "averfp", "camctx", "wavcmd", "varcf", "varinit", "avhistory", "varpool", "avetx", "avectx", "avcontext", "varmsg", "devtx", "avecmd", "avcas", " avtx", " avcrit", "devctx", "averxy", "avtx", "avpool", "avertimeout", "ovinit", "averdocument", "avergc", " avkl", "iamcu", "avebatch", "aversys", "avehistory", "avca", "avercmd", "ajsys", "vartimeout", "wavca", "iamcontext", " avhistory", "ajctx", "navctx", "averpool", " avmsg", " avcmp", "avinit", "savtimeout", "averkb", "Avcmp", "devkb", "avkw", "averbatch", "avepkg", "ajxy", " avtimeout", " avpkg", "AVcontext", "ajhistory", "avercf", "averkl", "varctx", "ovcf", "iamtx", "avmsg", "camhistory", "averhistory", " avcontext", "savctx", "averctx", "avconn", "navgc", "Avtx", "AVtx", "ovctx", "avertx", "averconn", " avbatch", "averinit", "navtx", "camsys", "avermsg", "avcf", "varfp", "aveconn", "averca", "aveca", " avcas", " avdocument", "navcontext", "avkl", "devcas", "avercontext", "avercrit", "Avctx", "navcas", "devcontext", "avcrit", "averkw", "vartx", "avecontext", " avcu", "avcu", "camxy", "savpool", "avecrit", "wavctx", "AVcmp", "avtimeout", "wavconn", "vardocument", " avfp", "avpkg", "avbatch", "avkb", "savkw", "AVctx", "navkb", "wavtx", "wavpkg", "AVcu", "devgc", "avcmd", "ovkw", "avxy", "avgc"], "ctx": ["pkg", "xp", "check", "inst", "fw", "kt", "tmp", "tc", "iat", "conn", "iac", "nt", "gz", "dl", "unc", "pb", "resp", "work", "ind", "tz", "crit", "hw", "wx", "px", "cb", "cv", "cp", "ac", "gc", "qt", "yes", "jp", "ctrl", "ann", "cc", "tm", "cl", "co", "ht", "prefix", "rt", "doc", "config", "cas", "desc", "cu", "conv", "kl", "mk", "td", "req", "loc", "xc", "ka", "cm", "wp", "proc", "history", "aux", "kw", "act", "timeout", "jac", "msg", "txt", "ck", "std", "sys", "exec", "ctl", "comm", "ct", "cfg", "ca", "parent", "bc", "ppo", "def", "mc", "etc", "expr", "tx", "tk", "cmd", "utils", "func", "kk", "context", "gt", "xs", "index", "cf", "addr", "cmp", "pg"]}}
{"project": "FFmpeg", "commit_id": "8370e426e42f2e4b9d14a1fb8107ecfe5163ce7f", "target": 1, "func": "static av_cold int vp3_decode_end(AVCodecContext *avctx)\n\n{\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if (avctx->is_copy && !s->current_frame.data[0])\n\n        return 0;\n\n\n\n    av_free(s->superblock_coding);\n\n    av_free(s->all_fragments);\n\n    av_free(s->coded_fragment_list[0]);\n\n    av_free(s->dct_tokens_base);\n\n    av_free(s->superblock_fragments);\n\n    av_free(s->macroblock_coding);\n\n    av_free(s->motion_val[0]);\n\n    av_free(s->motion_val[1]);\n\n    av_free(s->edge_emu_buffer);\n\n\n\n    if (avctx->is_copy) return 0;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        free_vlc(&s->dc_vlc[i]);\n\n        free_vlc(&s->ac_vlc_1[i]);\n\n        free_vlc(&s->ac_vlc_2[i]);\n\n        free_vlc(&s->ac_vlc_3[i]);\n\n        free_vlc(&s->ac_vlc_4[i]);\n\n    }\n\n\n\n    free_vlc(&s->superblock_run_length_vlc);\n\n    free_vlc(&s->fragment_run_length_vlc);\n\n    free_vlc(&s->mode_code_vlc);\n\n    free_vlc(&s->motion_vector_vlc);\n\n\n\n    /* release all frames */\n\n    if (s->golden_frame.data[0])\n\n        ff_thread_release_buffer(avctx, &s->golden_frame);\n\n    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)\n\n        ff_thread_release_buffer(avctx, &s->last_frame);\n\n    /* no need to release the current_frame since it will always be pointing\n\n     * to the same frame as either the golden or last frame */\n\n\n\n    return 0;\n\n}\n", "idx": 22976, "substitutes": {"avctx": ["jamcm", "avecf", "navcu", "avercf", "navcontext", "navpkg", " avcontext", " avcm", "wavcontext", "avcmp", "averctx", "jamcontext", " avpkg", "navcp", "jamcu", "avecp", "averkw", " avcmd", "avecontext", "jamctx", " avcu", "avcu", "wavcm", "avcm", "cvcontext", "navctx", "wavctx", "AVcmp", "navcf", "avecmp", "avetx", "avectx", "avpkg", " avcp", "avcp", " avcmp", "AVcmd", "avcontext", "wavcu", " avcf", "AVctx", "avecm", "avecu", "cvcf", "avecmd", "avkw", " avtx", "avcf", "avcmd", "cvtx", "cvctx", " avkw", "avtx", "navcm", "AVcontext", "navkw", "averpkg"], "s": ["comments", "full", "rs", "bs", "events", "conf", "ants", "sc", "aunts", "fs", "ims", "cs", "stats", "ies", "ins", "its", "actions", "os", "ls", "views", "d", "vs", "ps", "ds", "ess", "ts", "args", "less", "ports", "aps", "is", "v", "js", "gs", "tes", "sl", "bits", "des", "parts", "scl", "ms", "ses", "ss", "results", "aws", "ers", "hs", "services", "ears", "sts", "sys", "ats", "pers", "sports", "comm", "spec", "sq", "details", "sb", "y", "has", "c", "tests", "grades", "as", "sw", "erences", "ns", "changes", "sv", "qs", "h", "S", "als", "sd"], "i": [" li", "multi", " mi", "ims", "chain", "mi", "info", "ski", "\u0438", "phi", "ip", "iq", "ri", " x", "ind", " c", "ii", "x", "pi", "io", "ki", " pi", "q", "z", " bi", "zi", "cgi", "it", "gu", "qi", "iu", "di", "in", "print", " k", " j", "tim", " count", "is", "v", "hi", "m", "me", "si", " si", "to", "xi", "init", "status", " ki", "ai", "g", "ui", "li", " n", " m", "batch", " ti", "ci", "ix", "id", "y", "ij", "ti", "c", " v", "j", "t", " ii", "gi", "ic", "cli", "sim", "ji", "bi", "index", "asi", "I", "ami", "ex"]}}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}", "idx": 22980, "substitutes": {"vs": ["js", "gs", "vv", "ls", "vt", "vc", "inv", "irms", "es", "rs", "bs", "vd", "otes", "videos", "views", "docs", "lists", "blogs", "ps", "vm", "pps", "ires", "css", "fs", "ims", "ds", "vl", "ms", "values", "vers", "s", "cs", "vp", "Vs", "VS", "ts", "serv", "terms", "ss", "ys", "keys", "stats", "lines", "uds", "args", "plays", "atts", "vr", "ns", "news", "var", "ins", "its", "verts", "ks", "changes", "wcs", "services", "hs", "obs", "ports", "sts", "sv", "qs", "qv", "fps", "lbs", "vals", "words", "ops", "caps", "pages", "v"]}}
{"project": "qemu", "commit_id": "43c5d8f8001eb467abf091c3e2a8aca3d1e5b522", "target": 0, "func": "void qemu_opts_print(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    if (desc[0].name == NULL) {\n\n        QTAILQ_FOREACH(opt, &opts->head, next) {\n\n            printf(\"%s=\\\"%s\\\" \", opt->name, opt->str);\n\n        }\n\n        return;\n\n    }\n\n    for (; desc && desc->name; desc++) {\n\n        const char *value;\n\n        QemuOpt *opt = qemu_opt_find(opts, desc->name);\n\n\n\n        value = opt ? opt->str : desc->def_value_str;\n\n        if (!value) {\n\n            continue;\n\n        }\n\n        if (desc->type == QEMU_OPT_STRING) {\n\n            printf(\"%s='%s' \", desc->name, value);\n\n        } else if ((desc->type == QEMU_OPT_SIZE ||\n\n                    desc->type == QEMU_OPT_NUMBER) && opt) {\n\n            printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint);\n\n        } else {\n\n            printf(\"%s=%s \", desc->name, value);\n\n        }\n\n    }\n\n}\n", "idx": 22994, "substitutes": {"opts": ["OPds", "ips", "vets", " oprs", "alms", "itms", " opTS", "optTS", "opds", "optcs", "otters", "OPts", " opcs", "ipTS", "optms", "OPrs", "opms", "itcs", "alts", "vers", "otts", "optts", " ops", "opTS", "itTS", "OPTS", " opds", " opms", "OPs", "otcs", "veTS", "ipts", "ipt", "opcs", "oprs", "alters", "OPt", " opters", "itts", "alcs", "ops", "veds", "otms", "opters"], "opt": ["pkg", "eff", "tv", "ox", "json", "oc", "sp", "name", "slot", "tmp", "prop", "ext", "attr", "info", "decl", "ok", "lit", "org", "oss", "pt", "nom", "buf", "none", "arg", "optim", "crit", "op", "block", "term", "rop", "qt", "tag", "it", "dest", "bit", "rt", "iter", "img", "Opt", "cat", "lt", "adj", "tip", "xy", "usr", "fo", "num", "success", "alt", "tr", "req", "that", "init", "max", "kw", "timeout", "bl", "open", "txt", "var", "obj", "option", "OP", "err", "stat", "parent", "pr", "esc", "anon", "def", "typ", "feat", "etc", "expr", "tab", "j", "cmd", "t", "cho", "off", "out", "coord", "mem", "alg", "gt", "opted", "cmp", "val"], "desc": ["dir", "oc", "name", "disc", "sc", "ext", "test", "good", "info", "decl", "deep", "enc", "nt", "org", "dr", "cur", "resp", "buf", "md", "sec", "ind", "crit", "sup", "dep", "ctx", "der", "eq", "d", "dest", "ds", "ser", "asc", "doc", "ec", "img", "pos", "Desc", "col", "comment", "rib", "usr", "priv", "save", "cont", "rc", "dev", "sort", "seq", "req", "loc", "ptr", "des", "anc", "dict", "proc", "deg", "bl", "msg", "txt", "obj", "row", "comp", "sys", "str", "err", "rel", " Desc", "description", "diff", "bc", "gov", "esc", "def", "typ", "dist", "feat", "tab", "cmd", "reg", "sub", "cd", "mem", "rec", "dim", "cmp"], "value": ["json", "name", "type", "unit", "expression", "test", "address", "format", "output", "instance", "attribute", "example", "trace", "term", "property", "data", "tag", "widget", "range", "content", "hello", "function", "message", "sample", "initial", "see", "hash", "comment", "group", "byte", "save", "v", "dev", "state", "word", "length", "image", "port", "field", "ue", "status", "text", "max", "version", "total", "var", "option", "native", "valid", "Value", "description", "start", "id", "password", "w", "result", "values", "true", "vp", "size", "key", "VALUE", "null", "sv", "index", "new", "label", "val"]}}
{"project": "qemu", "commit_id": "e3da9921ebc554fad3224a9fdda9a7425ffd9ef7", "target": 0, "func": "static uint32_t nvic_readl(nvic_state *s, uint32_t offset)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t val;\n\n    int irq;\n\n\n\n    switch (offset) {\n\n    case 4: /* Interrupt Control Type.  */\n\n        return (s->num_irq / 32) - 1;\n\n    case 0x10: /* SysTick Control and Status.  */\n\n        val = s->systick.control;\n\n        s->systick.control &= ~SYSTICK_COUNTFLAG;\n\n        return val;\n\n    case 0x14: /* SysTick Reload Value.  */\n\n        return s->systick.reload;\n\n    case 0x18: /* SysTick Current Value.  */\n\n        {\n\n            int64_t t;\n\n            if ((s->systick.control & SYSTICK_ENABLE) == 0)\n\n                return 0;\n\n            t = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n            if (t >= s->systick.tick)\n\n                return 0;\n\n            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;\n\n            /* The interrupt in triggered when the timer reaches zero.\n\n               However the counter is not reloaded until the next clock\n\n               tick.  This is a hack to return zero during the first tick.  */\n\n            if (val > s->systick.reload)\n\n                val = 0;\n\n            return val;\n\n        }\n\n    case 0x1c: /* SysTick Calibration Value.  */\n\n        return 10000;\n\n    case 0xd00: /* CPUID Base.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.cp15.c0_cpuid;\n\n    case 0xd04: /* Interrupt Control State.  */\n\n        /* VECTACTIVE */\n\n        val = s->gic.running_irq[0];\n\n        if (val == 1023) {\n\n            val = 0;\n\n        } else if (val >= 32) {\n\n            val -= 16;\n\n        }\n\n        /* RETTOBASE */\n\n        if (s->gic.running_irq[0] == 1023\n\n                || s->gic.last_active[s->gic.running_irq[0]][0] == 1023) {\n\n            val |= (1 << 11);\n\n        }\n\n        /* VECTPENDING */\n\n        if (s->gic.current_pending[0] != 1023)\n\n            val |= (s->gic.current_pending[0] << 12);\n\n        /* ISRPENDING */\n\n        for (irq = 32; irq < s->num_irq; irq++) {\n\n            if (s->gic.irq_state[irq].pending) {\n\n                val |= (1 << 22);\n\n                break;\n\n            }\n\n        }\n\n        /* PENDSTSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending)\n\n            val |= (1 << 26);\n\n        /* PENDSVSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending)\n\n            val |= (1 << 28);\n\n        /* NMIPENDSET */\n\n        if (s->gic.irq_state[ARMV7M_EXCP_NMI].pending)\n\n            val |= (1 << 31);\n\n        return val;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu = ARM_CPU(current_cpu);\n\n        return cpu->env.v7m.vecbase;\n\n    case 0xd0c: /* Application Interrupt/Reset Control.  */\n\n        return 0xfa05000;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement SLEEPONEXIT.  */\n\n        return 0;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* TODO: Implement Configuration Control bits.  */\n\n        return 0;\n\n    case 0xd24: /* System Handler Status.  */\n\n        val = 0;\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].active) val |= (1 << 0);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].active) val |= (1 << 1);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].active) val |= (1 << 3);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].active) val |= (1 << 7);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_DEBUG].active) val |= (1 << 8);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].active) val |= (1 << 10);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].active) val |= (1 << 11);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].pending) val |= (1 << 12);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].pending) val |= (1 << 13);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].pending) val |= (1 << 14);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_SVC].pending) val |= (1 << 15);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_MEM].enabled) val |= (1 << 16);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_BUS].enabled) val |= (1 << 17);\n\n        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled) val |= (1 << 18);\n\n        return val;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        /* TODO: Implement Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Configurable Fault Status unimplemented\\n\");\n\n        return 0;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n    case 0xd30: /* Debug Fault Status.  */\n\n    case 0xd34: /* Mem Manage Address.  */\n\n    case 0xd38: /* Bus Fault Address.  */\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 23016, "substitutes": {"s": ["south", "rs", "bs", "events", "params", "conf", "ants", "gets", "fs", "ims", "settings", "cs", "stats", "set", "series", "ies", "its", "store", "ins", "actions", "a", "x", "os", "ls", "es", "o", "z", "times", "views", "vs", "ps", "sis", "ds", "l", "self", "b", "ts", "serv", "args", "less", "ports", "is", "v", "js", "gs", "m", "sl", "bits", "parts", "states", "ms", "history", "r", "ses", "ss", "results", "aws", "g", "hs", "services", "sts", "http", "sys", "ats", "comm", "spec", "p", "details", "sb", "service", "n", "y", "c", "as", "grades", "sw", "j", "cmd", "i", "utils", "plays", "ns", "sim", "changes", "e", "sv", "qs", "xs", "h", "S", "als", "ops"], "offset": ["start", "o", "tile", "id", "pad", "slot", "type", "padding", "priority", "scroll", "range", "shift", "l", "bit", "Offset", "style", "address", "location", "flag", "onet", "point", "pointer", "timeout", "pos", "origin", "size", "error", "set", "from", "key", "offs", "ref", "slice", "align", "off", "len", "row", "tz", "index", "oid", "mt", "trace", "zone"], "cpu": ["ctx", "cp", "gc", "num", " CPU", "mx", "np", " cp", "parent", "linux", "p", "o", "memory", "slot", "CPU", "util", "conn", "vm", "n", "chip", "proc", "c", "core", "gpu", "thread", "processor", "onet", "i", "net", "pc", "goal", "process", "a", "cu", "local", "CP", "sys", " c", "os", "hw", "pai", "clock", "alloc", "pu", "pool", "ct"], "val": ["hold", "slot", "type", "iat", "prop", "test", " lac", "ret", " vel", "what", "lib", "pt", "resp", "bal", " aval", "buf", "crit", "arr", "x", "pal", "cal", "fine", "bool", "call", " oval", "trace", "vt", "data", "hz", "ival", "util", "it", "l", "vol", "fail", "pret", "serv", " arg", "find", "pos", "Val", "pol", "len", " ret", " eval", "v", "dev", "num", "sl", "aval", "alt", "state", "ev", "td", "tl", "point", "eval", "res", "var", "al", "el", "obj", "ee", "err", "elt", "valid", "rel", " valid", "le", "Value", "p", "pr", "def", "value", "pl", " validate", "values", "VAL", "tx", " v", " value", "func", "cho", "key", "ref", "ul", "rol", "zero", "all", "base", "mem", "index", " el", "new", " interval", "vals", "label"], "irq": ["irqi", "nirq", "drqi", "iriqi", "ibrq", " irqi", "irech", "irwx", "ibrqi", "ireqi", " mirq", "ironque", "drj", "nirqu", "iraqi", "iriquest", "arq", "nirj", " irque", " irqu", "nirque", "iriq", "nirquest", "arque", "fireq", " irch", "irquery", "nirqi", "nirquery", "arqi", "drque", " irwx", "drq", "ironwx", " irquest", "iraquest", "firequery", "arj", "firequ", "irequ", "iriquery", "irch", "ibrque", "ireq", "iraqu", " irquery", "irqu", "irj", "firequest", "ironq", "irquest", " mirch", "irque", "iraquery", "ibrwx", "ironqi", "iraq", " mirqi", " mirqu"], "t": ["ta", "ty", "tv", "tp", "vt", "p", "z", "at", "td", "tr", "tt", "ot", "tick", "w", "d", "ptr", "tc", "tg", "typ", "n", "y", "dt", "it", "tm", "l", "ti", "b", "c", "rt", "tl", "ts", "j", "i", "T", "pt", "tu", "k", "g", "txt", "mint", "total", "time", "tz", "h", "x", "f", "v", "ct"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int gxf_write_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    GXFContext *gxf = s->priv_data;\n\n    GXFStreamContext *vsc = NULL;\n\n    uint8_t tracks[255] = {0};\n\n    int i, media_info = 0;\n\n\n\n    if (!pb->seekable) {\n\n        av_log(s, AV_LOG_ERROR, \"gxf muxer does not support streamed output, patch welcome\");\n\n        return -1;\n\n    }\n\n\n\n    gxf->flags |= 0x00080000; /* material is simple clip */\n\n    for (i = 0; i < s->nb_streams; ++i) {\n\n        AVStream *st = s->streams[i];\n\n        GXFStreamContext *sc = av_mallocz(sizeof(*sc));\n\n        if (!sc)\n\n            return AVERROR(ENOMEM);\n\n        st->priv_data = sc;\n\n\n\n        sc->media_type = ff_codec_get_tag(gxf_media_types, st->codecpar->codec_id);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (st->codecpar->codec_id != AV_CODEC_ID_PCM_S16LE) {\n\n                av_log(s, AV_LOG_ERROR, \"only 16 BIT PCM LE allowed for now\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->sample_rate != 48000) {\n\n                av_log(s, AV_LOG_ERROR, \"only 48000hz sampling rate is allowed\\n\");\n\n                return -1;\n\n            }\n\n            if (st->codecpar->channels != 1) {\n\n                av_log(s, AV_LOG_ERROR, \"only mono tracks are allowed\\n\");\n\n                return -1;\n\n            }\n\n            sc->track_type = 2;\n\n            sc->sample_rate = st->codecpar->sample_rate;\n\n            avpriv_set_pts_info(st, 64, 1, sc->sample_rate);\n\n            sc->sample_size = 16;\n\n            sc->frame_rate_index = -2;\n\n            sc->lines_index = -2;\n\n            sc->fields = -2;\n\n            gxf->audio_tracks++;\n\n            gxf->flags |= 0x04000000; /* audio is 16 bit pcm */\n\n            media_info = 'A';\n\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (i != 0) {\n\n                av_log(s, AV_LOG_ERROR, \"video stream must be the first track\\n\");\n\n                return -1;\n\n            }\n\n            /* FIXME check from time_base ? */\n\n            if (st->codecpar->height == 480 || st->codecpar->height == 512) { /* NTSC or NTSC+VBI */\n\n                sc->frame_rate_index = 5;\n\n                sc->sample_rate = 60;\n\n                gxf->flags |= 0x00000080;\n\n                gxf->time_base = (AVRational){ 1001, 60000 };\n\n            } else if (st->codecpar->height == 576 || st->codecpar->height == 608) { /* PAL or PAL+VBI */\n\n                sc->frame_rate_index = 6;\n\n                sc->media_type++;\n\n                sc->sample_rate = 50;\n\n                gxf->flags |= 0x00000040;\n\n                gxf->time_base = (AVRational){ 1, 50 };\n\n            } else {\n\n                av_log(s, AV_LOG_ERROR, \"unsupported video resolution, \"\n\n                       \"gxf muxer only accepts PAL or NTSC resolutions currently\\n\");\n\n                return -1;\n\n            }\n\n            avpriv_set_pts_info(st, 64, gxf->time_base.num, gxf->time_base.den);\n\n            if (gxf_find_lines_index(st) < 0)\n\n                sc->lines_index = -1;\n\n            sc->sample_size = st->codecpar->bit_rate;\n\n            sc->fields = 2; /* interlaced */\n\n\n\n            vsc = sc;\n\n\n\n            switch (st->codecpar->codec_id) {\n\n            case AV_CODEC_ID_MJPEG:\n\n                sc->track_type = 1;\n\n                gxf->flags |= 0x00004000;\n\n                media_info = 'J';\n\n                break;\n\n            case AV_CODEC_ID_MPEG1VIDEO:\n\n                sc->track_type = 9;\n\n                gxf->mpeg_tracks++;\n\n                media_info = 'L';\n\n                break;\n\n            case AV_CODEC_ID_MPEG2VIDEO:\n\n                sc->first_gop_closed = -1;\n\n                sc->track_type = 4;\n\n                gxf->mpeg_tracks++;\n\n                gxf->flags |= 0x00008000;\n\n                media_info = 'M';\n\n                break;\n\n            case AV_CODEC_ID_DVVIDEO:\n\n                if (st->codecpar->format == AV_PIX_FMT_YUV422P) {\n\n                    sc->media_type += 2;\n\n                    sc->track_type = 6;\n\n                    gxf->flags |= 0x00002000;\n\n                    media_info = 'E';\n\n                } else {\n\n                    sc->track_type = 5;\n\n                    gxf->flags |= 0x00001000;\n\n                    media_info = 'D';\n\n                }\n\n                break;\n\n            default:\n\n                av_log(s, AV_LOG_ERROR, \"video codec not supported\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n        /* FIXME first 10 audio tracks are 0 to 9 next 22 are A to V */\n\n        sc->media_info = media_info<<8 | ('0'+tracks[media_info]++);\n\n        sc->order = s->nb_streams - st->index;\n\n    }\n\n\n\n    if (ff_audio_interleave_init(s, GXF_samples_per_frame, (AVRational){ 1, 48000 }) < 0)\n\n        return -1;\n\n\n\n    gxf_init_timecode_track(&gxf->timecode_track, vsc);\n\n    gxf->flags |= 0x200000; // time code track is non-drop frame\n\n\n\n    gxf_write_map_packet(s, 0);\n\n    gxf_write_flt_packet(s);\n\n    gxf_write_umf_packet(s);\n\n\n\n    gxf->packet_count = 3;\n\n\n\n    avio_flush(pb);\n\n    return 0;\n\n}\n", "idx": 23049, "substitutes": {"s": ["ctx", "js", "gs", "m", "south", "ssl", "ast", "ls", "p", "sq", "sp", "es", "bs", "rs", "us", "conf", "times", "sb", "sql", "n", "src", "ps", "fs", "ds", "scl", "b", "ms", "c", "cs", "as", "sw", "ses", "ts", "ss", "stats", "t", "aws", "aus", "g", "ns", "its", "a", "hs", "obj", "sts", "sv", "qs", "xs", "sys", "ats", "sg", "os", "S", "is", "v", "comm"], "pb": ["ctx", "cp", "pkg", "uf", "tp", "vt", "p", "np", "pp", "sp", "bs", "soc", "ub", "jp", "sb", "tc", "tg", "bp", "cm", "typ", "ab", "pl", "mp", "ob", "b", "proc", "bm", "vp", "tx", "ts", "ib", "buff", "PB", "pt", "t", "bh", "phys", "bj", "rb", "pc", "pa", "xb", "cv", "buf", "gp", "lp", "fp", "cb", "pg", "v"], "gxf": ["gfc", "gfx", " gxb", "mxf", "ggxf", "gaxf", "sgfe", "sgxf", "ccf", "cfc", "cfx", "rgcf", "gxc", "Gxf", "rgfx", " gfx", "rgxc", "Gxc", "gf", "gafx", "gaf", " gfe", "jcf", "sgfx", "mxc", "Gfx", "cxf", "jxf", "sgf", "gxb", "ggcf", "rgxf", " gfc", "gfe", "Gxb", "gcf", "ggxb", "Gcf", "gafe", "mfx", "mcf", " gf", " gcf", "jfx", " gxc", "jfc", "ggxc"], "vsc": ["jbc", "Vmc", "avbc", "Vsc", "jSC", "VSC", "vmc", "jmc", "jsc", "avmc", "Vbc", "avSC", "vbc", "avsc", "vSC"], "tracks": ["js", "bands", "sets", "ints", "amps", "track", "objects", "length", "flags", "tags", "asks", "icks", "src", "bytes", "types", "files", "items", "acks", "rows", "metadata", "amples", "stream", " track", "frames", "obs", "sys", "fields", "seek"], "i": ["m", "me", " ti", "ci", "ix", "p", "o", "name", "id", "mount", "si", " bi", "multi", "zi", " mi", "n", "ei", "y", "it", "xi", "ims", "ij", "ti", "mi", "qi", "b", "c", "iu", "u", "j", "di", "in", "ai", "t", "im", "ie", "k", " ii", " I", "g", "phi", "ui", "li", "gi", "ic", " j", "ip", "sim", "ri", "ini", "bi", "ind", "oi", "index", "x", "ii", "pi", "batch", "I", "ki", "v"], "st": ["ctx", "ust", "ast", "rest", "sn", "sl", "inst", "so", "p", "start", "sp", "z", "td", "ist", "tr", "ST", "tt", "sty", "must", "sb", "stable", "src", "fr", "it", "sm", "cl", "status", "ost", "sa", "sh", "St", "rt", "storage", "sw", "ts", "nt", "ss", "stack", "ut", "pt", "step", "t", "ft", "net", "sta", "set", "nd", "est", "stat", "stream", "irst", "std", "store", "obj", "sts", "sv", "usr", "str", "se", "ste", "th", "mt", "ct"], "sc": ["ctx", "ac", "gc", "cr", "ci", "sp", "isc", "bc", "Sc", "esc", "cgi", "tc", "anc", "nc", "mc", "cc", "disc", "cl", "scl", "sac", "asc", "c", "cs", "fc", "mac", "lc", "SC", "sw", "scope", "scan", "enc", "ec", "psc", "go", "uc", " Sc", "arc", "func", "capt", "pc", "sch", "dc", "sche", "desc", "cam", "sec", "usc", "sic", "ch", "cu", "sv", "osc", "rc", "tch", " subsc", "cmp", "scrib", "cont", "ctl", "cv"], "audio_tracks": ["audio_fields", "audio____runs", "audio___fields", "music_reads", "audio___reads", "audio___runs", "audio____reads", "music___reads", "audio_reads", "audio_runs", "music_runs", "music___fields", "audio____fields", "music___tracks", "music___runs", "music_fields", "audio____tracks", "music_tracks", "audio___tracks"], "media_type": ["media_info", "media_source", "mediaetytime", "meta_time", "meta_type", "meta_source", "mediaetysource", "meta_info", "mediaetytype", "mediaetyinfo", "media_time"]}}
{"project": "qemu", "commit_id": "2f464b5a32b414adb545acc6d94b5c35c7d258ba", "target": 0, "func": "static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)\n\n{\n\n    VGACommonState *vga = &qxl->vga;\n\n    int i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            qemu_free_displaysurface(vga->ds);\n\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n\n                                            qxl->guest_primary.surface.height,\n\n                                            qxl->guest_primary.bits_pp,\n\n                                            qxl->guest_primary.abs_stride,\n\n                                            qxl->guest_primary.data);\n\n        } else {\n\n            qemu_resize_displaysurface(vga->ds,\n\n                    qxl->guest_primary.surface.width,\n\n                    qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_resize(vga->ds);\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->ds,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n", "idx": 23050, "substitutes": {"qxl": [" qxla", "flowxxlay", "eqxlt", "queryxel", "flowxlay", "qplexls", "qlexlb", "qxyhl", "qwla", "qrxel", "qxpfl", "qxL", "iqxel", "qxala", "qxilit", "iqrxel", "qzzli", "questionxxl", "qxyli", "qxlit", "qqxls", "eqfxli", "qpxlt", "eqwxla", "qxilb", "qxmlsl", "qxxli", "qxlt", "queryuxhl", "qryla", "qexls", " qlexl", "queryxls", "qzzll", "qxxl", "qttli", "corexcla", " qlexfl", " qlexel", "qlexfl", "qtxlt", "qinxla", "quxml", "qxcll", "qxml", "qxyfl", "qxyL", "qxlan", "qeyurl", "qxcln", "questionxlb", "contextlexlb", "queryxlan", "questionxlc", "qxyla", "qqrxl", " qrxel", " qxel", "qdxlay", "qlexel", "iqrxli", "qxlb", "qrxla", "qdxla", " qxhl", "quxli", "quuxl", "corexlb", " q_", "qwxg", "qrxls", "qxxla", "qxeel", "qxlist", " qxfl", "qrxl", "qworkfl", "qrxll", "qexel", "qaxlb", "qlexll", "flowxla", "qwli", "quxsl", "contextxlb", "qttla", "queryxfl", "qwxla", "qzzl", "questionwxl", "qnewsli", " qrxli", "qxpml", "qworklb", "qqrxls", "queryxln", "flowxxla", "q_", "qwxel", "qxlc", "qxmlel", "requxl", "qxili", "qxifl", "quxmlel", "qxsl", "qwxhl", " qxL", "qxxlc", "qxylist", "qryli", "qwxl", "iqxli", "qxplit", "quuxll", "qxiel", "qxiurl", "quxfl", "questionxxli", "requplexl", "eqxg", "qxlp", "queryxl", "queryxyls", "qtxls", "queryxplan", "iqrxla", "qxpl", "qlexli", "qxcli", "quxmlls", "qexfl", "qaxL", "contextxl", "qxmllan", "qxxll", "sqmxml", "qexli", "qrxlt", "eqwxl", "eqxxlt", "qpxl", "qdxsl", "qpxsl", "corexclp", "qfxli", "qtrylay", "corexlp", "corexll", "flowxela", "qxmlfl", "queryxxsl", "quxhl", "qwxli", "qxyel", "flowxli", "queryxxli", "qxurl", "eqfxel", "corexcln", "qtryli", "corexil", "qxxsl", "eqxli", "qworkll", "qxil", "qxxlay", "qxilan", "contextxli", "qpayls", "qctla", " qrxL", "queryxsl", "quxL", "flowxelt", "qlexL", "contextxL", "queryxyfl", "qexL", "qmxlt", "corexla", "qplexl", "quxls", "questionxli", "queryuxli", "qxxel", "qxplan", "eqfxl", "qfxhl", "qfxfl", "queryxxel", "eqxxfl", "qxla", "qexln", "qxyls", "requplexlist", "eqxsl", "qpxfl", "qrxlb", "qplexlist", "qxdel", "quxmlL", "qfxla", "qtxl", "qxal", "qoxlp", "eqxla", "qxhl", "queryuxl", "qrxlist", "qxelt", "qmxel", "corexcl", "qxfl", " qlexli", "qxmlL", "qtryl", "contextlexli", "qxxfl", "queryuxel", "qmxla", "qxxlb", "qxln", "qzzlt", "qdxl", "qxill", "qpayll", "qq_", "qxdli", "qwg", "qexhl", "eqxfl", "questionxla", "qnewsln", "qplexL", "qxalc", "quuxlt", "eqwxg", "qworkl", "eqxxl", "qxpsl", "qxdla", "questpayll", "qxli", "qxmll", "qinxlp", "qtxml", "qtryla", "questpayel", "qeyl", "qeylb", "corexl", "qinxln", "flowxel", "questionxl", "flowxeli", "qpayl", "queryxyl", "qwl", "qxcl", "qxisl", " qrxla", "requxlist", "corexfl", "queryfxli", "quxmlsl", "eqxel", " qrxhl", "qctl", "queryuxln", "qxclt", "corexln", "requplexL", "qqxl", "flowxxl", "queryfxl", "eqwxli", "qoxln", "qfxls", "questionxxlc", "questpayl", "requxls", "sqxla", "qxlay", "flowxxli", "qmxhl", "qxag", "sqmxl", "questxll", "queryxyhl", "qxmllit", "qxyl", "questxl", "qrxhl", "sq_", "eqxl", "qxpel", "iqxla", "qrxL", "qxela", "qmxml", "quxln", "questionwxurl", "qxcla", "requxL", "queryxpl", "corexill", "qlexls", "qxehl", "qrxli", "queryxlt", "sqxl", "queryxpel", "eqxxsl", "queryfxel", "qxll", "qctml", "queryuxls", "qttl", "contextlexl", "qexl", "qxmlls", "quxel", "iqxl", "qqrxlt", "qfxl", "quxl", "qxg", "qxclp", "contextlexL", "questionwxlb", "qdxli", "quxmll", "qaxli", "qqxlt", "quxmllit", "queryxhl", "queryxpfl", "flowxl", "sqmxla", "quuxli", "qxmlml", "qximl", "qoxl", "queryuxlt", "qxxlt", "sqxml", "qrylc", "questionwxli", "flowxlt", "qtxla", "qmxl", "quxll", "corexifl", "qxdl", "quxlt", "qxali", "qxls", "qfxel", "questxls", "queryxli", " qxli", "qlexl", "quxmlml", "corexilb", "queryxxl", "qryl", "qinxl", "qpayel", "questxel", "quxlit", "qeyli", "qdxel", "qnewsls", "qnewsl", "qoxla", "qaxl", "eqfxla", " qrxl", "qwxlb", "questionxxla", "qttel", "qxeli", "queryfxhl", "qttlt", "qxel", "questpayls", "iqrxl", "requplexls", "qfxlt", "questionxurl", "qwxurl"], "vga": ["vgd", "vgo", "vcca", "qcca", "vegar", " vgp", "vmba", "vrgas", "avgas", "devanta", "qega", "vgp", " vanta", " vca", "versiongd", "wirecca", "invga", "vanta", "versioncca", " vgo", "qga", "avga", "avja", "wirega", " vba", "veanta", "vgas", "versionga", "vca", "devgas", "veca", "venda", "invgp", "vega", "vja", "vrga", "vrca", "vmgp", "ggas", "avna", "qna", " vcca", "Vgas", "vna", "vrenda", "vmgo", " vega", "Vma", "vma", "vgar", "gga", "vema", "gja", " vgd", "veenda", "versiongas", "vba", "Vca", " vma", "invba", " venda", "wireega", "vegas", "vmga", "devgar", " vgar", "qgas", "qma", "qja", "devga", "Vga", " vgas", "qgd", "gna", "wirema", "invgo"], "i": [" li", "multi", " mi", "ei", "ims", "chain", "mi", "info", " wi", " p", "ip", "ri", "instance", "ini", "ind", "record", "ii", "x", "pi", "yi", "f", "ki", "im", " pi", " l", "o", "zi", "it", "l", "qi", "iu", "di", "in", " I", "u", " j", " ni", "is", "v", "hi", "m", "me", "us", "si", " si", "xi", "status", "init", "er", "item", " ki", "ai", "fi", "ui", "li", " multi", " m", "batch", " ti", "ci", "ix", "p", "start", " iter", " index", "id", "span", "n", "y", "ij", "ti", "c", "j", " ii", "gi", "key", "sim", "ji", "e", "bi", "oi", "index", "I", "ami"]}}
{"project": "qemu", "commit_id": "47c16ed56aa6bc4037bdb7b61f049097993cd244", "target": 0, "func": "static void page_init(void)\n\n{\n\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n\n       TARGET_PAGE_SIZE */\n\n#ifdef _WIN32\n\n    {\n\n        SYSTEM_INFO system_info;\n\n\n\n        GetSystemInfo(&system_info);\n\n        qemu_real_host_page_size = system_info.dwPageSize;\n\n    }\n\n#else\n\n    qemu_real_host_page_size = getpagesize();\n\n#endif\n\n    if (qemu_host_page_size == 0) {\n\n        qemu_host_page_size = qemu_real_host_page_size;\n\n    }\n\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n\n    }\n\n    qemu_host_page_mask = ~(qemu_host_page_size - 1);\n\n\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n", "idx": 23052, "substitutes": {"system_info": ["System_info", "sys_data", "sys_fo", "sys_info", " system_INFO", "System_data", "system2details", "system2INFO", "system_id", "system_fo", "system2data", "system_INFO", "sys_id", " system_details", "System_information", "system2info", "system_details", "system_data", " system_data", "System_fo", "system_information"], "freep": ["freec", "faxp", "sweek", "feap", "feeap", "treep", "Frexp", " freek", "faeps", "swepe", "frepe", "treeps", " freEP", " frepe", "feek", "Freeps", " freeps", "Freek", "Freep", "sweep", "FreEP", "feEP", "feep", "freap", "mediep", "freek", "medipe", "fayp", "freEP", "Freap", "faek", "mediek", "freeps", "freyp", "feec", "sweec", "fepe", " freyp", "feeeps", "feyp", "faq", " freap", "treq", "feeps", "feeep", "mediec", "feepe", "freq", "Freq", "faep", "trexp"], "i": ["hi", "m", "me", " ti", "ci", "ix", "uri", "us", "id", "si", "multi", "zi", " di", "ei", "y", "it", "xi", "init", "status", "ti", "mi", "chain", "info", "qi", "c", "iu", "j", "di", "\u0438", "ma", "ai", "t", " ii", " I", "ui", "gi", "phi", "li", "ic", "series", " j", "cli", "sim", "ip", "iq", "ri", "ji", "ini", "bi", "ind", "oi", "index", "ii", "x", "pi", "batch", "I", "is"], "cnt": ["nnt", "ncnt", "Cnc", "Ccount", " csec", "ncount", "nccount", "cnc", "csec", " cnc", " ccount", "nct", "Count", "Csec", " cct", "cNT", " cNT", "CNT", "ctNT", "ctnt", "ncNT", "count", "ccount", "Cct", "Cnt", "nNT", "ctount", "ncsec", " count", "cct", "ctnc"], "startaddr": [" startpkg", "artpkg", "startref", "endaddress", " starthash", " startadd", "startadd", "startpkg", "startoa", "firstpkg", "endobj", "beginptr", " startobj", "firstoa", " startaddress", "firstptr", "firstadr", "Startptr", "firstaddr", "beginref", "Startaddr", "beginhash", "beginadr", "endadr", "Startobj", "Startadd", "startptr", "endptr", " startref", "artptr", " startptr", "startobj", "beginaddress", "firstaddress", "artadr", "startadr", "beginaddr", "endadd", "artoa", "starthash", "Startaddress", "firsthash", "artaddress", " startadr", "firstref", "artaddr", " startoa", "startaddress"], "endaddr": ["startdir", "sendaddr", "stopdr", "stopaddress", "starthop", "sendaddress", "appendaddr", "verthop", "endaddress", " endattr", "endedaddress", "sendadd", "startdr", "vertptr", "endedobj", "maxadr", "endhop", "startadd", "stopaddr", " endaddress", "closeptr", "endobj", "closeaddr", "maxattr", "vertaddr", " endadd", "finptr", "endattr", " endoffset", "appendadr", "enddir", " endptr", "closeattr", "stopoffset", "endedaddr", "finaddress", "sendptr", "endadr", "enddr", "startptr", " enddr", "endptr", "startobj", " endobj", " enddir", " endhop", "vertaddress", "closeaddress", "startoffset", "appendattr", "startadr", "endadd", "maxaddr", "endoffset", "findir", "finaddr", "stopptr", "startattr", "startaddress"], "f": ["lf", "fo", "m", "q", "p", "o", "file", "z", "fw", "w", "d", "fr", "fe", "fd", "fs", "fa", "l", "b", "c", "fal", "fc", "r", "elf", "t", "g", "fi", "rf", "xf", "F", "e", "h", "x", "cf", "tf", "fb", "fp", "fm", "v"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n", "idx": 23066, "substitutes": {"host_port": [" host_PORT", " host_pid", " host_file", " host_ports", "host_ports", "host_file", "host_PORT", "host_pid"], "errp": ["errpun", "errm", "errpo", "rrps", "errr", "Erps", "rrpun", "orderpo", "ererpo", "ererpun", "orderping", "rrr", " errr", "rrpo", "Err", "ererping", "ererp", " errm", "rrm", "orderpun", "Erm", "errping", "errps", "rrp", "orderp", "rrping", " errps", "Erp"], "iaddr": ["icoord", "siadd", "xiaddr", "Iattr", "biaddr", " ihost", " iadr", "incoord", "iiaddr", "ipart", "sivar", "Iaddr", "sicoord", "Iadd", "xicoord", " iadd", "ipptr", "sihost", "iiarp", "diarp", "ivar", "Ihost", "xiurl", "iadd", "diadr", "ipadr", "xivar", "ihost", "sadr", "iarp", " ipart", "iiadr", "iptr", "biptr", "inaddr", "iurl", "invar", "iattr", "biadr", "inurl", " iattr", "siurl", "siaddr", "siattr", "sadd", "diaddr", "dipart", "sptr", "iadr", "ipadd", "biadd", " iarp", "ipaddr", "iipart"], "saddr": ["sdist", " sadd", "osdist", "nsadr", "jsadd", " sdist", "osadd", " saddress", " sadr", "Sptr", "tsadr", "tsadd", "jsaddr", "tsarp", "Sadd", "nsaddress", "Sdist", "sadr", "psaddress", "nsadd", "Sarp", " sptr", "ssaddr", "ssadr", "osadr", "Sadr", "psaddr", "jsptr", "jsaddress", "psadr", "sadd", "osaddr", "sptr", "psadd", "Saddr", "ssarp", "tsaddr", "ssadd", "Saddress", "saddress", "sarp", "nsaddr"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    qemu_opts_del(s->socket_opts);\n\n    nbd_client_session_close(&s->client);\n\n}\n", "idx": 23074, "substitutes": {"bs": ["js", "gs", "bing", "bits", "bc", "bes", "sb", "bp", "bis", "bytes", "fs", "acs", "ims", "ds", "b", "iss", "ts", "ss", "aus", "aos", "bh", "bl", "ubs", "BS", "ns", "cks", "ils", "its", "bps", "hs", "bi", "obs", "bos", "ats", "lbs", "als"], "s": ["js", "gs", "sl", "ls", "sq", "p", "sp", "rs", "sb", "n", "ps", "y", "sis", "ds", "self", "b", "c", "ess", "cs", "ts", "j", "ses", "ss", "i", "t", "aws", "ns", "its", "hs", "a", "ares", "sv", "qs", "sys", "ats", "h", "os", "S", "als", "is", "v", "comm"]}}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076, "substitutes": {"d": ["dos", "m", "dat", "p", "o", "z", "w", "n", "y", "fd", "ds", "l", "b", "s", "c", "r", "j", "di", "da", "dr", "t", "dm", "dn", "g", "ed", "dc", "dd", "md", "e", "h", "x", "D", "ad", "sd", "f", "v"], "drc": ["dnRC", "mdror", " dready", "bdroc", "Dirc", "bdrec", "drec", "Drs", "bdrc", "zirc", "aderb", "bdrs", "bdRC", "aderoc", "modrc", "edRC", " drent", "zrc", " durch", "sdRC", " dhr", "daroc", "bdror", "diurch", " dirc", "adrec", "edrc", "bdrog", "darec", "adroc", "DRC", "modsrc", "modroc", " dsrc", "modRC", "drog", " drb", "darh", "mdrs", "lrec", "dnurch", "mdrc", "daready", " drs", "drect", "dirent", " dRC", "dhr", "dsrc", " drh", "darc", " droc", "froc", "drt", "sdhr", "mdsrc", "drh", "zRC", "dRC", "drent", "lrc", "Drc", "dahr", " dror", "lirc", " drt", "adrc", "lRC", "dasrc", "mrt", "edrs", "edrog", "Drect", "edrec", "dirc", "durch", "dready", "mroc", "Drec", "edroc", "adeRC", "firc", "zrec", "adrb", "daRC", "bdrect", "aderc", "bdsrc", "frt", "frc", "diRC", " drect", "dror", "adirc", "mirc", " drec", "sdready", "dnrc", "Drh", "dnrent", "adRC", " drog", "sdrc", "drs", "mrc", "droc", "drb"], "drck": ["hrkw", "drcheck", "derck", "drkw", "dercker", "drcker", "mrck", " drkk", "hrke", "drleck", "drkk", "hrck", "derk", "Drck", "drke", "Drk", "drk", " drcheck", "mrcker", "hrcker", "derkk", " drk", " drcker", "mrcheck", "mrleck", "derkw", " drleck", " drke", "dercheck", "derleck", "Drcker", " drkw", "derke", "Drkk"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,\n\n                          target_ulong len, int type)\n\n{\n\n    struct kvm_sw_breakpoint *bp;\n\n    CPUState *env;\n\n    int err;\n\n\n\n    if (type == GDB_BREAKPOINT_SW) {\n\n        bp = kvm_find_sw_breakpoint(current_env, addr);\n\n        if (!bp)\n\n            return -ENOENT;\n\n\n\n        if (bp->use_count > 1) {\n\n            bp->use_count--;\n\n            return 0;\n\n        }\n\n\n\n        err = kvm_arch_remove_sw_breakpoint(current_env, bp);\n\n        if (err)\n\n            return err;\n\n\n\n        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);\n\n        qemu_free(bp);\n\n    } else {\n\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n\n        if (err)\n\n            return err;\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        err = kvm_update_guest_debug(env, 0);\n\n        if (err)\n\n            return err;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23088, "substitutes": {"current_env": ["current__env", "current__conn", "current_eng", "current_org", " current_cv", "current_en", "current2en", "current__dev", "current_environment", "current__eng", "current2conn", " current_en", "currently_conn", "current2org", "reported_shell", "current_dev", "current__org", "reported_environment", "current__environment", "current_shell", "current__en", "current_cv", "currently_en", " current_eng", "reported_env", "current2env", "reported_dev", "currently_org", "currently_env", "current_conn", "current__shell"], "addr": ["pkg", "ix", "arp", "add", "start", "adr", "Address", "rs", "alias", "at", "id", "pad", "loc", "path", "ptr", "arch", "ace", "url", "src", "offset", "inter", "expr", "attr", "rt", "address", "mac", "pat", "cmd", "host", "dr", "act", "pos", "map", "ar", "ip", "ref", "asm", "align", "off", "a", "handle", "arg", "arr", "hw", "art", "ad", "rel", "ack", "rc"], "len": ["lf", "spec", " length", "lvl", "seq", "id", "length", "loc", "ln", "ptr", "ann", "bytes", "lim", "offset", "lon", "Len", "l", "fin", "fun", "nl", "lib", "fn", "lan", "pos", "args", "size", "lis", "en", "vec", "link", "eth", "el", "ll", "mem", "sys", "lp", "lang", "elt", "rel", "label", "val"], "type": ["action", "ty", "tp", "family", "p", "like", "state", "name", "id", "length", "year", "port", "pe", "ver", "mt", "tag", "unit", "range", "typ", "Type", "types", " ty", "test", "inter", "role", "style", "ype", "rt", "what", "kind", "address", "template", "t", "size", "error", "TYPE", "key", " Type", "count", "ping", "link", "time", "rule", "index", "part", "weight", " typ", "class"], "bp": ["cp", "pkg", "gs", "circle", "xp", "tp", "bb", "p", "np", "sp", "pp", "bs", "arp", "mk", "kr", "btn", "eb", "bc", "jp", "blog", "ptr", "sb", "br", "ps", "phy", "wordpress", "BP", "b", "arb", "pse", "wp", "bm", "vp", "bt", "PB", "bh", "kb", "bj", "pc", "pa", "bg", "hp", "asm", "pb", "adj", "dp", "ap", "php", "mb", "snap", "lb", "bps", "gp", "bf", "vc", "esp", "lp", "batch", "lbs", "pg", "bd", "fp", "bsp", "pas", "cb", "bn"], "env": ["ctx", "dev", "stage", "kh", "ep", "eg", "vt", "end", "np", "alias", "state", "ev", "ve", "qt", "here", "engine", "pe", "eq", "ptr", "eng", "vs", "conn", "ah", "nc", "timer", "environment", "ext", "er", "door", "doc", "worker", "vp", "tx", "eh", "iter", "enc", "edge", "ec", "uv", "ef", "node", "gn", "server", "org", "act", "kg", "en", "vr", "ner", "ng", "open", "et", "ew", "cv", "window", "next", "buf", "nv", "obj", "e", "el", "context", "usr", "ee", "priv", "eve", "gear", "peer", "v"], "err": ["aaa", "kr", "cer", "conf", "virt", "conn", "test", "attr", "score", "eh", "errors", "order", "dr", "gz", "erer", "rb", "count", "resp", "buf", "none", "arr", "ler", "die", "peer", "erd", "trace", "cb", "term", "any", "der", "try", "inner", "it", "rn", "warn", "iter", "later", "error", "eas", "irm", "usr", "norm", "Error", "priv", "eor", "cr", "mr", "ere", "here", "or", "req", "notice", "ptr", "br", "fr", "timer", "er", "orm", "r", "raw", "act", "drm", "res", "msg", "txt", "obj", "Er", "str", "ger", "fee", "elt", "cfg", "pr", "ter", "nil", "result", "lr", "ry", "i", "rar", "ner", "cli", "off", "late", "out", "e", "rr", "plain"], "use_count": ["use_Count", "user_Count", "use_max", "user_count", "use__Count", "use_table", "user_max", "user_counter", "use__count", "use__max", "usage_table", "use__counter", "usage_count", "use_counter", "usage_counter"]}}
{"project": "qemu", "commit_id": "fea7d77d3ea287d3b1878648f3049fc6bb4fd57b", "target": 0, "func": "void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)\n\n{\n\n    int relation;\n\n\n\n    set_float_exception_flags(0, &env->fp_status);\n\n    relation = float64_compare(t0, t1, &env->fp_status);\n\n    if (unlikely(relation == float_relation_unordered)) {\n\n        update_fpscr(env, GETPC());\n\n    } else {\n\n        env->sr_t = (relation == float_relation_greater);\n\n    }\n\n}\n", "idx": 23104, "substitutes": {"env": ["ctx", "dev", "vv", "em", "equ", "end", "te", "forge", "v", "ev", "manager", "engine", "shell", "bc", "gov", "esc", "console", "vs", "ah", "vm", "sc", "conn", "environment", "er", "worker", "sw", "eh", "app", "di", "ec", "ef", "En", "server", "set", "db", "rb", "en", " environment", "EN", "ew", "desc", " en", "window", "buf", "nv", "el", "e", "hl", "obj", "context", "sv", "cf", "exec", "walker", "hw", "err", "ov", "erd", "cb", "cv"], "t0": ["ttZero", "t25", "v50", "st0", "dtZero", "v0", "st00", "str0", "dt1", "st50", "p0", "v00", "p1", "v000", "tt0", "str00", "st000", "p25", "tt25", "t000", "str50", "dt0", "dt25", "pZero", "tt1", "t00", "str000", "t50", "tZero"], "t1": [" t001", "tt2", " tone", "w0", "T2", "w1", "tt0", "T1", "tt001", "T0", "wone", "t2", "w2", "tt1", "tone", " t2", "T001", "Tone", "t001"], "relation": [" relationship", " performance", " probability", "associated", " relate", " rate", "family", "direction", " factor", "lation", " distance", "type", "degree", "library", "related", " record", " motion", " proportion", "duration", " fraction", "definition", "release", "future", "test", " percentage", "status", " cor", "notation", "role", "result", "nor", "director", "bor", "equality", "address", "r", "relative", "flag", " condition", "order", " accuracy", " correlation", "normal", "quality", "relations", " correl", "origin", "reverse", " similarity", " ratio", "NR", " related", "ner", "position", " rating", "balance", " role", "flow", "reference", "portion", " comparison", "condition", "ler", "norm", "rr", " association", "err", "rel", "behavior", "sequence", "trace", "response", " cross"]}}
{"project": "qemu", "commit_id": "f0536bb848ad6eb2709a7dc675f261bd160c751b", "target": 0, "func": "static int img_info(int argc, char **argv)\n\n{\n\n    int c;\n\n    OutputFormat output_format = OFORMAT_HUMAN;\n\n    const char *filename, *fmt, *output;\n\n    BlockDriverState *bs;\n\n    ImageInfo *info;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:h\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        }\n\n    }\n\n    if (optind >= argc) {\n\n        help();\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n\n    if (!bs) {\n\n        return 1;\n\n    }\n\n\n\n    info = g_new0(ImageInfo, 1);\n\n    collect_image_info(bs, info, filename, fmt);\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_info(info);\n\n        dump_snapshots(bs);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        collect_snapshots(bs, info);\n\n        dump_json_image_info(info);\n\n        break;\n\n    }\n\n\n\n    qapi_free_ImageInfo(info);\n\n    bdrv_delete(bs);\n\n    return 0;\n\n}\n", "idx": 23105, "substitutes": {"argc": ["Argc", "Argcs", "argsc", "argscs", "argcs", "Argce", " argce", " argct", "Argct", "argsv", "argsct", "argsl", "argce", "arrv", "arrc", "arrl", " argl", "argct", "argumentc", "argsce", "argumentce", " argcs", "arrcs", "argumentl", "argumentv", "argl"], "argv": [" argV", "Argc", "cmdm", "argsc", "argp", "argsf", "cmdv", "argsp", " argvs", "argsv", " argf", "usev", " argp", "cmdc", " argm", "argsm", "argV", "usevs", "argsx", "cmdf", "ArgV", "argsvs", "usec", "usep", "argm", "argf", "Argv", "argsV", " argx", "argx", "Argx", "argvs"], "c": ["ac", "cp", "gc", "m", "ci", "p", "z", "bc", "conf", "d", "xc", "tc", "cache", "sc", "nc", "n", "cc", "cm", "mc", "C", "l", "com", "cs", "fc", "lc", "config", " ec", "\u00e7", "ec", "uc", "t", "ce", "k", "cd", "pc", "unc", "dc", "f", "count", "cur", "con", "code", "e", "abc", "cu", "h", "cf", "category", "rc", " count", "cmp", "arc", " tc", "cb", "cod", "ct"], "filename": ["ename", "println", "json", "kan", "family", "input", "file", "lua", "name", "til", "path", "ln", "nm", "tmp", "nil", "url", "src", "original", "fs", "png", "ame", "prefix", "fn", "username", "fil", "location", "origin", "format", "directory", "buffer", "jpg", "unc", "txt", "Filename", "csv", "buf", "subject", "ames", "source", "fle", "bf", "title", "binary", "fp", "f", "kl", "FN"], "fmt": ["ftm", "flt", "cformat", "confformat", "hmt", "fformat", "Flt", "tprintf", "ctm", "tMT", " flt", "hlt", "tmt", "cMT", "htm", " ftm", " ffm", "cmt", "confMT", "confmt", "formmt", " fMT", "Ftm", "tformat", "lformat", "formformat", "Fformat", "formprintf", "FMT", "Fprintf", "lmt", "hformat", "formfm", "conffm", " fformat", "ltm", "ffm", "fMT", "lprintf", "Fmt", "tfm"], "output": ["println", "json", "write", "file", "name", "type", "unit", "tail", "ou", "username", "render", "apache", "origin", "ut", "Output", "format", "client", "none", "binary", "echo", "io", "icon", "generation", "data", "o", "hidden", "generated", "region", "prefix", "config", "print", "remote", "directory", "error", "message", "position", "csv", "source", "success", "export", "enabled", "secure", "image", "console", "module", "offset", "status", "text", "network", "OU", "open", "outer", "options", "option", "display", "connection", "fp", "ilo", "STDOUT", "four", "input", "path", " Output", "result", "style", "only", "ignore", "update", "buffer", "key", "target", "out", "null", "response"], "bs": ["js", "gs", "bed", "ls", "bb", "eb", "rs", "bits", "details", "bc", "bo", "sb", "vs", "gb", "bp", "bis", "ps", "fs", "ds", "b", "cs", "bm", "ts", "bt", "ss", "stats", "ubis", "aos", "bh", "bl", "BS", "ubs", "bg", "ns", "cks", "pb", "its", "bps", "obj", "obs", "bi", "bf", "sys", "bos", "os", "lbs", "bd", "bas", "cb", "bn"], "info": ["INFO", "fo", "meta", "dev", "list", "json", "try", "ci", " Info", "data", " data", "o", "iso", "id", "ist", "details", "conf", "si", "image", "fw", " INFO", "entry", "Info", "by", "user", "def", " inf", "information", " mi", "cache", "type", "it", "ext", "init", "status", "ti", "mi", "inf", "history", "doc", "no", "iter", "about", "i", "stats", " fi", "error", "fi", "ui", "txt", "summary", "note", "out", "off", "is", "obj", "now", "http", "mem", "index", "ii", "sys", "os", "pi", " details", "ami", " about", "stat", "io", "f", "ki"], "long_options": [" long2flags", " long_values", " long_objects", "longlyflags", " long2items", "long___flags", "longlyitems", "long2options", "longlyoptions", "long_option", "long___objects", " long_flags", " long_items", "long_items", "long___option", "long_flags", " long2options", "long2items", "long2flags", "long2values", "longlyvalues", "long_objects", " long_option", "long_values", "long___options", " long2values"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 23108, "substitutes": {"resolver": ["resolve", "solution", "provolution", "wolver", "persolve", "resolder", "persolution", " resolve", "wolve", "solver", "rolution", "resolution", "rolve", "rumer", "serolder", "serolver", "provolve", "solve", "persolver", "provolver", "rolver", "wolution", "perserver", " resolution", "wumer", "server", " resumer", "serolve", "serolution", " resolder", "resumer", "reserver", "solder", "proverver"], "addr": ["ac", "pkg", "ast", "old", "ix", "arp", "add", "Address", "inv", "adr", "rs", "alt", "alias", "name", "pad", "aj", "at", "ag", "ptr", "ace", "ash", "mt", "conn", "ext", "has", "expr", "attr", "prefix", "address", "r", "tx", "ord", "cmd", "host", "dr", "act", "pos", "map", "res", "ns", "news", "older", "ip", "ref", "align", "hash", "oa", "lat", "a", "obj", "ress", "adv", "gt", "arr", "rr", "err", "elt", "ad", "block", "ack"], "naddrs": ["nattrs", "nfindRS", "npadls", "nadrs", "nadras", "nadren", "nlengthrs", "nappps", " naddras", " nadras", "nfindrs", "nbuildrs", " nadren", "nlengthls", " nadris", " nattrs", "nbuildRS", "npayras", "nadris", " nadRS", "naddls", " naddls", "npadps", "naddRS", "naddners", "naddras", " nadls", "naddps", " naddris", "npayls", " nattners", "npayren", "nadRS", " naddps", "nappners", " nattls", "nadls", "nfindris", "nbuildris", " nadrs", "nattners", "npadners", "naddren", " naddners", "nlengthras", "nattps", "nfindls", "napprs", "npadrs", "npayrs", "nattls", " nattps", "nlengthren", " naddren", "nappls", "naddris", " naddRS", "nbuildls"], "addrs": [" paddners", "addributes", "addres", " addributes", " adths", " addrd", "addrd", "condributes", "adresses", " addresses", "attrd", "condrs", " adrs", " adners", " paddths", "addths", "adrs", "attresses", " paddributes", "adres", "attrs", "addners", " paddr", "attres", " addres", " paddrs", "addresses", "adrd", " addners", " adr", " addths", "condr"], "errp": ["rerjp", "nerp", "errbp", "lerpa", "lerp", "errorpc", "rerpc", " errpc", "rrps", "errjp", "rerper", "rerp", "errorjp", "rrjp", "lerbp", " errbp", "rrper", "errorp", "errps", "errper", "errpc", "nerpa", "rrp", "nerbp", " errper", "errorper", "errpa", " errpa", " errps", "nerps", "errorps", "rrpc", "lerps"]}}
{"project": "qemu", "commit_id": "d85f4222b4681da7ebf8a90b26e085a68fa2c55a", "target": 0, "func": "static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                         int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int ret = 0, n;\n\n    uint64_t cluster_offset;\n\n    struct iovec hd_iov;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *buf;\n\n    void *orig_buf;\n\n    Error *err = NULL;\n\n\n\n    if (qiov->niov > 1) {\n\n        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);\n\n        if (buf == NULL) {\n\n            return -ENOMEM;\n\n        }\n\n    } else {\n\n        orig_buf = NULL;\n\n        buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors != 0) {\n\n        /* prepare next request */\n\n        cluster_offset = get_cluster_offset(bs, sector_num << 9,\n\n                                                 0, 0, 0, 0);\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n = s->cluster_sectors - index_in_cluster;\n\n        if (n > nb_sectors) {\n\n            n = nb_sectors;\n\n        }\n\n\n\n        if (!cluster_offset) {\n\n            if (bs->backing) {\n\n                /* read from the base image */\n\n                hd_iov.iov_base = (void *)buf;\n\n                hd_iov.iov_len = n * 512;\n\n                qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n                qemu_co_mutex_unlock(&s->lock);\n\n                ret = bdrv_co_readv(bs->backing, sector_num, n, &hd_qiov);\n\n                qemu_co_mutex_lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->cipher);\n\n                if (encrypt_sectors(s, sector_num, buf,\n\n                                    n, false, &err) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    error_free(err);\n\n    ret = -EIO;\n\n    goto done;\n\n}\n", "idx": 23116, "substitutes": {"bs": ["js", "gs", "ls", "bb", "bing", "hz", "rs", "bits", "bc", "bes", "blog", "sb", "vs", "outs", "bp", "bis", "ps", "fs", "ds", "b", "ms", "cs", "bm", "ts", "bt", "ubis", "aos", "aus", "bh", "bl", "ubs", "BS", "ns", "pb", "lb", "its", "boxes", "asis", "hs", "bps", "obs", "bi", "sts", "sys", "bos", "os", "lbs", "fps", "bas", "locks"], "sector_num": ["section_num", "sector_index", "sector_len", "sector2index", " sector2num", " sector2number", " sector_len", "section_con", "sector__index", "section_number", "sector_id", "sector_mon", " sector_index", "sector2cal", " sector_number", "sector2num", " sector2cal", "sector_sum", " sector_mon", "sector_number", "section_id", " sector_cal", "sector_con", "section_sum", "sector_cal", "sector2number", "sector__number", "sector__num", "sector__cal", " sector2index"], "nb_sectors": ["nb_spevers", "nb_comctors", "nb_pellers", "nb_severs", "nb_speors", "nb_vevers", "nb_peonents", "nb_speonents", "nb_veitors", "nb_comllers", "nb_vectors", "nb_vellers", "nb_spellers", "nb_specs", "nb_peors", "nb_sctors", "nb_seonents", "nb_peters", "nb_seitors", "nb_secs", "nb_sors", "nb_spectors", "nb_sllers", "nb_seters", "nb_seectors", "nb_veors", "nb_vecs", "nb_svers", "nb_pevers", "nb_comors", "nb_seeors", "nb_speitors", "nb_comonents", "nb_seors", "nb_seevers", "nb_veters", "nb_pectors", "nb_seeters", "nb_sellers"], "qiov": ["qiour", "Qveh", " qiev", "qiev", "questiour", "qtiov", "questiov", "sqiv", "sqiov", "quconv", "questconv", "dqiev", "questionnov", "qconv", " qveh", "dqconv", "questioniour", "quiev", "qveh", "quiv", "quiov", "quveh", " qnov", " qconv", "questioniov", "questnov", "dqiov", "qiv", "qnov", "qtovi", "dqovi", "questionconv", "Qiev", "Qiv", "qtconv", "quovi", "qtiev", "qovi", " qiour", "Qiov", "sqveh", "sqiev", "dqveh"], "s": ["js", "gs", "sn", "ls", "p", "sq", "sp", "es", "rs", "conf", "sb", "vs", "service", "ps", "eps", "y", "fs", "ims", "ds", "self", "ains", "b", "ms", "c", "cs", "settings", "sw", "ts", "ses", "j", "ss", "i", "abilities", "stats", "t", "less", "ns", "ins", "its", "changes", "actions", "store", "hs", "sam", "sts", "sv", "sys", "ats", "os", "S", "als", "space", "is"], "index_in_cluster": ["index_in_glust", "index_in_plusters", "index_in_ploser", "index_in_scuster", "index_in_clust", "index_in_chuster", "index_in_plust", "index_in_chust", "index_in_Cluster", "index_in_scusters", "index_in_gloser", "index_in_Clusters", "index_in_glusters", "index_in_Clust", "index_in_closer", "index_in_scust", "index_in_chusters", "index_in_Closer", "index_in_gluster", "index_in_clusters", "index_in_pluster", "index_in_scoser"], "n": ["m", "num", "sn", "p", "np", "nb", "un", "o", "cn", "mn", "ln", "nm", "d", "w", "nn", "nc", "N", "y", "rn", "l", "nor", " N", "b", "c", "nl", "r", "j", "nt", "nu", "i", "ni", "t", "na", "size", "dn", "g", "en", "nd", "non", "ns", "ng", "note", "len", "number", "ll", "e", "nan", "h", "norm", "nr", "ne", "v"], "cluster_offset": ["cluster_prefix", "cluster_op", "cluster_flag", "cluster_Offset", "cluster_num", "cluster___Offset", "cluster___pos", "cluster___loc", "clusters_Offset", "clust_off", "clust_flag", "clust_offset", "clue_off", "clusters_pos", "cluster_off", "cluster_pos", "clue_Offset", "cluster_loc", "clue_pos", "clusters_loc", "clust_Offset", "clastic_num", "cluster___offset", "clastic_offset", "clusters_offset", "clue_offset", "clastic_Offset", "clust_prefix", "clust_op"], "hd_iov": ["HD_rolet", "HD_iov", "wd_iv", "hd___ovi", "hd___iv", "hd___voice", "hd___iour", "hd__iour", "hd_iour", "hd__iov", "dh_ij", "dh_iv", "wd_iov", "hd_ovi", "hd_voice", "wd_ovi", "HD_veh", "HD_iv", "dh_voice", "hd_veh", "dh_iov", "hd__iv", "hd___iov", "hd___liv", "hd__rolet", "hd__ij", "hd_rolet", "wd_liv", "hd__veh", "hd__voice", "hd_ij", "hd_liv", "hd_iv", "dh_iour"], "hd_qiov": ["hd_dqiov", "hd_hiev", "hd_iqovi", "hd_qiop", "hd_quiov", "hd_quiour", "hd_qiv", "hd_sqrolet", "hd_quickiop", "hd_sqiv", "hd_sqiop", "hd_qiour", "hd_iqigroup", "hd_sqiov", "hd_qovi", "hd_dqiv", "hd_quiev", "hd_iqiov", "hd_dqrolet", "hd_quigroup", "hd_quickovi", "hd_dqiop", "hd_quickiov", "hd_hiour", "hd_hiov", "hd_qiev", "hd_quickigroup", "hd_quiop", "hd_iqiop", "hd_qurolet", "hd_qrolet", "hd_quiv", "hd_qigroup", "hd_quovi", "hd_hiop"], "buf": ["ctx", "cp", "pkg", "temp", "uf", "pack", "data", "np", "v", "seq", "bc", "box", "bin", "port", "tmp", "xff", "mu", "br", "cache", "Buffer", "bytes", "orig", "lim", "BU", "result", "b", "broad", "doc", "buff", "raw", "cmd", "img", "pos", "map", "fac", "db", "bl", "rb", "buffer", "bg", "msg", "txt", "ref", "pb", "vec", "Buff", "window", "mb", "late", "cam", "emb", "obj", "mem", "queue", "aka", "norm", "batch", "alloc", "cap", "block", "cb", "cv"], "orig_buf": ["orig_vec", " orig_loc", "orig___buff", "orig___uf", " orig_buff", "orig_loc", " orig_uf", "original_vec", "original_buffer", "original_buf", "orig_bytes", "orig___bytes", " orig_buffer", "orig___buffer", "orig_uf", "orig___buf", "orig___loc", "orig_buffer", "original_bytes", "orig_buff", "orig___vec"], "err": ["cr", "der", "kr", "mr", "exc", "ev", "er", "gr", "r", "iter", "ec", "order", "ar", "res", "error", "msg", "txt", "e", "ch", "arr", "Er", "usr", "sys", "str", "rr", "Error", "cb", "rc"]}}
{"project": "FFmpeg", "commit_id": "9a0f60a0f89a7a71839dfa9def5a26f2037aed62", "target": 0, "func": "static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n\n{\n\n    int hours, minutes, seconds;\n\n\n\n    if (!show_bits(gb, 23)) {\n\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hours   = get_bits(gb, 5);\n\n    minutes = get_bits(gb, 6);\n\n    skip_bits1(gb);\n\n    seconds = get_bits(gb, 6);\n\n\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n\n\n    skip_bits1(gb);\n\n    skip_bits1(gb);\n\n\n\n    return 0;\n\n}\n", "idx": 23123, "substitutes": {"s": ["js", "gs", "m", "sn", "so", "ls", "sl", "p", "sq", "es", "rs", "bs", "w", "sb", "ps", "fs", "ds", "ms", "b", "c", "cs", "ses", "ts", "ss", "i", "stats", "aws", "set", "ns", "hs", "e", "sts", "sv", "h", "ats", "sg", "se", "os", "S", "st", "sd", "is"], "gb": [" rgb", "cfg", "ctx", "gc", "gs", "rect", "eg", "bb", "eb", "bs", "bits", "vd", "yg", "gg", "ga", "gm", "sb", "tg", "gd", "wb", "gio", "vm", "Gb", "bytes", "cz", "py", "google", "hd", "GB", "fc", "gnu", "buff", "ib", "html", "gh", "bt", "img", "gif", "gz", "kb", "g", "db", "rb", "vg", "bg", "goo", "pc", "dd", "pb", "csv", "mb", "ch", "bf", "gt", "xy", "rl", "rg", "sg", "sv", "fb", "pg", "bd", "px", "io", "hub", "cb", "cv", "gy"], "hours": ["arms", "dates", "facts", "rooms", "opens", "agers", "workers", "ints", "itudes", "events", "ours", " hrs", "modules", "times", "views", "headers", "ages", "years", "hops", "pps", "hm", "blocks", "inches", "ures", "jobs", "phones", "holes", "items", "ouses", "images", "lines", "utes", "rows", "projects", "mins", "shows", "places", "lights", "its", "members", "hs", "Hours", "frames", "rices", "reports", "hour", "h", "archives", "nuts", "days", "tracks", "heads", "months"], "minutes": ["tenute", "Minues", "minsodes", "muted", "minsute", "minodes", "Minuted", "modes", "mutes", "mateters", "tenodes", "Minute", "mues", "minents", "minsues", "tenutes", "matute", "minute", "minsuted", "minues", "Mineters", "mineters", "Minutes", "minuted", "matutes", "tenues", "mute", "Minents", "minseters", "matents", "minsutes", "minsents"], "seconds": ["gs", "south", "scenes", "tes", "sections", "steps", "sets", "dates", "bs", "nets", "feet", "videos", "times", "classes", "bes", "views", "resources", "years", "gets", "duration", "bis", "states", "bytes", "minimum", "fixes", "values", "tests", "months", "ses", "poses", "terms", "units", "beans", "billion", "erences", "utes", "rows", "timeout", "uses", "second", "places", "runs", "missions", "ions", "actions", "services", "pieces", "frames", "obs", "sec", "uploads", "reports", "ones", "words", "flows", "forms"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_restart(FTPContext *s, int64_t pos)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    const int rest_codes[] = {350, 0};\n\n\n\n    snprintf(command, sizeof(command), \"REST %\"PRId64\"\\r\\n\", pos);\n\n    if (!ftp_send_command(s, command, rest_codes, NULL))\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n}\n", "idx": 23136, "substitutes": {"s": ["js", "gs", "m", "ssl", "q", "p", "sq", "rs", "w", "n", "ps", "fs", "ds", "b", "c", "cs", "ess", "r", "ts", "ses", "ss", "t", "aws", "ns", "session", "socket", "a", "e", "sts", "sv", "h", "S", "f", "is"], "pos": ["pid", " position", "rot", "spec", "num", "p", "o", "Pos", "at", "length", "loc", "port", "Position", "tmp", "to", "on", "offset", " pose", "top", "po", "POS", "pt", "size", "res", "pro", "pc", "position", "pose", "resp", "out", "len", "base", " len", "index", "op", "os", " POS", " Pos"], "command": ["description", "input", "word", "power", "length", "password", "paste", "communication", "execute", "request", "value", "delete", "result", "chain", "text", "prefix", "mode", "history", "send", "raw", "slave", "empty", "query", "template", "cmd", "config", "directory", "error", "message", "Command", "argument", "buffer", "frame", "key", "controller", "initial", "create", "comment", "channel", "event", "code", "pattern", "package", "form", "attribute", "example", "call", "sequence", "clear", "response", "menu"], "rest_codes": [" rest2code", " rest_code", "rest2names", " rest_lines", "rest_lines", " rest_files", "rest_code", " rest2codes", "rest_names", "rest2code", " rest2names", "rest2codes", " rest_names", "rest_files"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n\n{\n\n    BlockDriverState *bs = child->bs;\n\n\n\n    /* Perform I/O through a temporary buffer so that users who scribble over\n\n     * their read buffer while the operation is in progress do not end up\n\n     * modifying the image file.  This is critical for zero-copy guest I/O\n\n     * where anything might happen inside guest memory.\n\n     */\n\n    void *bounce_buffer;\n\n\n\n    BlockDriver *drv = bs->drv;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    int64_t cluster_offset;\n\n    unsigned int cluster_bytes;\n\n    size_t skip_bytes;\n\n    int ret;\n\n\n\n    /* FIXME We cannot require callers to have write permissions when all they\n\n     * are doing is a read request. If we did things right, write permissions\n\n     * would be obtained anyway, but internally by the copy-on-read code. As\n\n     * long as it is implemented here rather than in a separate filter driver,\n\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n\n     * it could request permissions. Therefore we have to bypass the permission\n\n     * system for the moment. */\n\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n\n\n\n    /* Cover entire cluster so no additional backing file I/O is required when\n\n     * allocating cluster in the image file.\n\n     */\n\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n\n                                   cluster_offset, cluster_bytes);\n\n\n\n    iov.iov_len = cluster_bytes;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,\n\n                             &bounce_qiov, 0);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n\n    if (drv->bdrv_co_pwrite_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        /* FIXME: Should we (perhaps conditionally) be setting\n\n         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n\n         * that still correctly reads as zero? */\n\n        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,\n\n                                  &bounce_qiov, 0);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = offset - cluster_offset;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n", "idx": 23140, "substitutes": {"child": ["ac", "q", "add", "my", "parent", "id", "shell", "port", "unk", "sb", "cache", "brother", "cl", "b", "task", "c", "root", "j", "node", "server", "key", "sim", "count", "client", "job", "handle", "ind", "ch", "base", "ach", "h", "x", "Child", "batch", "children", "block", "v"], "offset": ["ff", "start", "o", "file", "id", "slot", "length", "image", "padding", "ptr", "block", "to", "i", " offsets", "shift", "Offset", "prefix", "root", "address", "location", "origin", "pointer", "timeout", "pos", "owner", "extra", "size", "encrypted", "set", "error", "t", "buffer", "key", "offs", "position", "ref", "et", "total", "count", "off", "out", "handle", "row", "base", "index", "oid", "os", "batch", "addr", "oot", "fp", "seek", "table", "oss"], "bytes": ["latest", "pointers", "ips", "sets", "tes", "comments", "steps", "ows", "es", "bits", "memory", "times", "reads", "classes", "outs", "parts", "eps", "fs", "loads", "blocks", "les", "sofar", "values", "files", "s", "seconds", "ries", "settings", "abytes", "items", "errors", "keys", "rows", "Bytes", "size", "offs", "ies", "izes", "total", "its", "len", "out", "bps", "pieces", "options", "byte", "ites", "os", "elt", "pages"], "qiov": ["dqiv", "qqovi", "dqiol", "eqiol", "qvoice", "ffiov", "eqiv", "eqiov", "qqiov", "auxiol", "qqiv", "qiol", "quiov", "qqiol", "ffvoice", "auxnov", "dqiov", "qiv", "qnov", "dqovi", "quvoice", "ffiol", "ffnov", "auxvoice", "qunov", "quiol", "qovi", "eqovi", "auxiov"], "bs": ["ctx", "js", "gs", "bed", "ls", "bb", "bas", "hz", "rs", "bits", "bc", "bo", "bes", "blog", "sb", "vs", "outs", "bp", "br", "bis", "ps", "css", "fs", "ds", "b", "s", "kit", "cs", "bm", "as", "ts", "bt", "ys", "ubis", "aos", "aus", "bh", "bl", "ubs", "BS", "ns", "pb", "its", "boxes", "bps", "obs", "bi", "base", "bf", "qs", "sys", "bos", "os", "lbs", "fps", "bus", "cb", "bn"], "bounce_buffer": ["benge_buffer", "bounced_frame", "bouncing_command", "bounce67buffer", "bounce\u043dbuffer", "bouncelcache", "benge67initial", "bounce\u043dbuf", "bounce67command", "bounce_initial", "bounce_cache", "bounce\u043dBuffer", "bounce_buff", "bounce\u043dframe", "bounce_buf", "bounce67Buffer", "bounce_frame", "bounce_command", "bounced_index", "bounced_buff", "bouncing_Buffer", "bounce_header", "bouncelBuffer", "bounceableheader", "bounced_cache", "bounce_index", "bounceableBuffer", "bounced_buffer", "bounced_buf", "benge67Buffer", "bounce_Buffer", "bounce67initial", "benge67buffer", "bouncelindex", "bouncelbuffer", "benge_Buffer", "bouncing_buffer", "bounced_Buffer", "bounced_header", "benge_initial", "bounceablebuffer"], "drv": ["hrw", "vrvr", "DRvg", "drvd", " drV", "drivd", "drvg", "DRw", "srv", "ptrvg", "srvs", "DRvr", "drc", "src", "drw", " drw", "dric", "hrV", "drV", "vrvg", "vrV", "ptrvr", " drvd", "drvr", "drvs", "srvd", " drc", "dru", "vrv", "ptrV", "hru", "DRv", " drvs", "hrv", "ptrv", "drivs", "DRu", "driv", " dru", "DRV"], "iov": ["ird", "tv", "rio", "ei", "river", "nih", "ichael", "ovi", " supporters", "vers", "ouk", "chrom", " vib", "vec", "iq", " fav", "Iv", " volley", "cv", " imb", "uj", "iw", "ih", "veh", "iva", "iv", "rov", "hovah", "iph", "rolet", "iu", "serv", " vers", " mus", "nov", "conv", "iol", "dyl", "rek", "von", "kov", "vector", "imp", "ech", "aux", "drm", " rav", "news", "voice", "ux", "voc", "qv", "vo", "liv", "inv", "ovo", " bio", "nil", "iour", "ibr", "minecraft", "ij", " vom", " multimedia", "vp", " repertoire", "ever", "vr", "isco", " mor", "iop", "dq", " civ"], "bounce_qiov": ["bounce_qiol", "bounce_quiour", "bounce_qiour", "bounce_giop", "bounce_diov", "bounce_qnov", "bounce2qiop", "bounce_Qiev", "bounce_eqiov", "bounce_qqiop", "bounce_diop", "bounce_qqiov", "bounce_eqiop", "bounce_diour", "bounce_kiop", "bounce_qij", "bounce_eqibl", "bounce_qqiol", "bounce2qqiop", "bounce_qiev", "bounce_kiov", "bounce_Qij", "bounce_giour", "bounce_Qiop", "bounce_quiov", "bounce_piev", "bounce_qunov", "bounce2qqiour", "bounce_eqiour", "bounce_piop", "bounce_piov", "bounce_qiop", "bounce_Qiov", "bounce_kiev", "bounce_kij", "bounce_giol", "bounce2qiour", "bounce_qqiev", "bounce_qibl", "bounce2qqiov", "bounce_knov", "bounce_gibl", "bounce2qqnov", "bounce_qqiour", "bounce_qqij", "bounce_giev", "bounce_quiop", "bounce_giov", "bounce_qqnov", "bounce2qiov", "bounce_dibl", "bounce2qnov", "bounce_kiour", "bounce_piol"], "cluster_offset": ["clusterptoffset", "clering_area", "clusterptoffer", "cluster_index", "clusterfuloffset", "cluster_Offset", "clclus_slice", "clusterptarea", "clust_type", "cluster_count", "clering_offset", "clusterityindex", "cluster_area", "cluster_parent", "cluster_offer", "clody_parent", "clusterfulopen", "clclus_offset", "clust_offset", "clinical_open", "cluster_open", "clody_off", "clinical_left", "clust_bytes", "cluster_left", "clinical_offset", "clusterityoffset", "clusterptoutput", "clering_offer", "cluster_off", "clusterfulleft", "clinicalfulopen", "clinicalfulposition", "clinicalfulleft", "clust_Offset", "clering_output", "clclus_bytes", "cluster_type", "clusterfuloff", "clusterfulposition", "clinicalfuloffset", "clclus_Offset", "clusteritytype", "clust_index", "clust_count", "clody_left", "cluster_output", "clinical_position", "clody_offset", "cluster_position", "clusterfulparent", "cluster_slice"], "cluster_bytes": ["clust2errors", "cluster2size", "clluster_parts", "cluster_parts", "cluster_blocks", "clust2seconds", "cluster2Bytes", "cluster_steps", "clust_size", "clluster_bytes", "clancer2blocks", "cllusterablesteps", "clancer2bytes", "clust_items", "clluster_size", "cluster5bytes", "cluster9names", "cluster_bps", "cluster_size", "clust_codes", "cluster_seconds", "cluster5steps", "clust_errors", "clust_len", "clancer_bytes", "clust_tes", "cluster2len", "clancer2errors", "clust2len", "cllusterablesize", "clust_bytes", "cluster2errors", "cluster_Bytes", "clust_bps", "cluster_errors", "clust_names", "cluster9files", "clusterablebytes", "clusterableparts", "cluster5size", "clust_files", "clust_Bytes", "cluster2seconds", "clluster_steps", "cluster_items", "cluster_len", "clancer_errors", "cllusterableparts", "cluster2bytes", "cluster5parts", "cluster_codes", "cllusterablebytes", "cluster_files", "clancer_blocks", "clusterablesize", "clust_seconds", "clusterablesteps", "cluster2blocks", "cluster9items", "cluster_tes", "clust2bytes", "cluster2tes", "clancer_seconds", "clancer2seconds", "cluster9bytes", "cluster_names"], "skip_bytes": ["skip_seconds", "skip_tes", "skip___bytes", "skipvalbytes", " skip_Bytes", "skip_bits", "skipvalseconds", "skip_Bytes", " skip_seconds", " skip_bits", "skip_changes", "skip___reads", "skip_reads", "skipvalchanges", " skip_tes", " skip_changes", "skipvalbits", "skip___Bytes", "skip___tes", " skip_reads"], "ret": ["get", "del", "reply", "ext", " Ret", "nt", "ft", "set", "rev", "resp", "ll", "arg", "after", "arr", "nz", "tf", "RET", "try", "Return", "Ret", "dt", "att", "fun", "rt", "iter", "flag", "print", "net", "en", " RET", "val", "len", "rets", "usr", "jump", "back", "ert", "reset", "num", "cert", "alt", "tr", "url", "rem", "status", "er", "deg", "res", "re", "err", "elt", "progress", "ter", "complete", "def", "nil", "value", "result", "no", "cmd", "t", "reg", "ref", "out", "code", "mem", "gt", "addr", "rm", "mt", "response", "final"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n", "idx": 23145, "substitutes": {"s": ["js", "m", "gs", "p", "sq", "sp", "rs", "state", "sb", "n", "ps", "fs", "ds", "sa", "b", "c", "cs", "r", "ts", "ses", "ss", "i", "t", "ns", "a", "e", "sts", "sv", "sys", "os", "S", "st", "f", "is", "v"], "type": ["ty", "m", "tp", "q", "p", "sp", "file", "at", "name", "id", "length", "pe", "ver", "ptr", "tag", "ay", "typ", "Type", "y", "types", "oe", "test", " ty", "pl", "style", "ype", "info", "kind", " TYPE", "t", "method", "size", "set", "TYPE", "where", "key", " Type", "ref", "var", "ping", "time", "new", " typ", "v", "ct"], "ret": ["reset", "try", "del", "cert", "alt", " alt", "at", "Return", "ter", "tr", "Ret", "def", "reply", "ext", "status", "inter", "att", "l", " Ret", "fun", "rt", "ry", "xt", "j", "nt", "flag", "deg", "cmd", "print", "t", "ft", "det", "res", "not", " RET", "cat", "tn", "rev", "re", "resp", "desc", "over", "len", "out", "code", "ll", "rets", "gt", "nz", "arr", "str", "usr", "rm", "elt", "RET", "back", "mt", "ne", "cont", "val"], "arg": ["ac", "Arg", "arp", "p", "ass", "pp", "par", "ax", "aj", "loc", "ag", "tag", "pl", "sa", " Arg", "doc", "r", "j", "ig", "cmd", "flag", "act", "agg", "args", "ar", "t", "reg", "g", "ma", "argument", "msg", "ref", "var", "a", "au", "mem", "param", "arr", "op", "cal", "ad", "v", "val"], "ap": ["ac", "af", "ep", "ape", "arp", "p", "np", "sp", " cp", "api", "am", "ait", "pp", "ax", "aj", "apt", "ag", "apa", "aph", "ak", "av", "ab", "mp", "att", " rep", "tap", " nap", " heap", "app", "map", "ar", " tap", "ma", " av", "pa", " pc", "amp", "ip", "al", " cap", "snap", " sap", "a", " app", "aps", " mp", " ip", " sp", "AP", "ad", "cap", "v"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;\n\n    int shift;\n\n    uint64_t count;\n\n    uint32_t value;\n\n    int lt_i;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        value = s->reg_mct_cfg;\n\n        break;\n\n\n\n    case G_CNT_L: case G_CNT_U:\n\n        shift = 8 * (offset & 0x4);\n\n        count = exynos4210_gfrc_get_count(&s->g_timer);\n\n        value = UINT32_MAX & (count >> shift);\n\n        DPRINTF(\"read FRC=0x%llx\\n\", count);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        value = s->g_timer.reg.cnt_wstat;\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);\n\n    break;\n\n\n\n    case G_TCON:\n\n        value = s->g_timer.reg.tcon;\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        value = s->g_timer.reg.int_cstat;\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n        value = s->g_timer.reg.int_enb;\n\n        break;\n\n        break;\n\n    case G_WSTAT:\n\n        value = s->g_timer.reg.wstat;\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:\n\n    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n        value = s->l_timer[lt_i].reg.cnt[index];\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n", "idx": 23155, "substitutes": {"opaque": ["iopaque", "opaques", "iopaques", "oplaque", "iopface", "opque", " opface", "oplface", "iopque", "opca", "opface", " opca", "iopca", "opent", "popaques", "popent", " opque", "popaque", "oplca", "oplaques", "popque", " opent", " opaques", "iopent"], "offset": ["ocation", "command", "eta", "reset", "ix", "end", "start", "data", "o", "sp", "alias", "id", "pad", "slot", "type", "entry", "length", "padding", "mt", "scroll", "range", "amount", "Offset", "bound", "style", "prefix", "address", "header", "delay", "location", "origin", "point", "pointer", "axis", "pos", "timeout", "format", "extra", "set", "area", "error", "message", "buffer", "key", "position", "ref", "outer", "slice", "window", "len", "off", "handle", "row", "operation", "base", "tz", "reference", "attribute", "oid", "batch", "addr", "clock", "alloc", "object", "block"], "size": ["num", "start", "sp", "z", "name", "type", "SIZE", "length", "Size", "n", "amount", "c", "address", "sum", "set", "message", "len", "code", "e", "mem", "h", "ize", "weight", "fee"], "s": ["js", "gs", "m", "spec", "ssl", "sn", "sl", "ls", "p", "sq", "es", "o", "bs", "rs", "bits", "params", "details", "conf", "times", "sb", "vs", "n", "ps", "y", "bis", "states", "fs", "sis", "ds", "ims", "ms", "as", "sw", "ts", "ses", "serv", "app", "ss", "stats", "t", "aws", "less", "g", "ns", "ies", "ins", "store", "changes", "its", "hs", "sam", "sts", "sv", "qs", "h", "os", "S", "is", "comm"], "index": ["connect", "num", "ix", "start", "sort", "alias", "id", "loc", "length", "port", "request", "ion", "n", "info", "lock", "address", "iter", "find", "i", "order", "axis", "point", "pos", "loop", "pointer", "error", "page", "key", "open", "position", "slice", "route", "Index", "head", "code", "instance", "row", "ind", "handle", "base", "context", "interface", "condition", "x", "val"], "shift": ["wrap", "diff", "pop", "sq", "start", "pack", "transform", "sort", "hold", "push", "pad", "length", "distance", "zone", "scale", "aw", "sh", "hift", "lock", "load", "send", "join", "delay", "flag", "order", "timeout", "sum", "pos", "shr", "step", "set", "reverse", "strip", "skip", "sub", "patch", "position", "ssh", " Shift", "slice", "align", "hash", "snap", "off", "handle", "time", "Shift", "ize", "mask", "share", "save", "sup", "seek", "sleep"], "count": ["ctx", "current", "list", "num", "nb", "z", "id", "length", "common", "cache", "n", "amount", "status", "counter", "currency", "result", "max", "info", "limit", "c", "Count", "found", "core", "nt", "flag", "act", "sum", "match", "page", "key", "total", "val", "len", "number", "code", "ctr", "base", "last", "OUNT", "array", "ount", "table", "more", "ct"], "value": ["get", "json", "file", "name", "memory", "type", "unit", "expression", "feature", "unknown", "format", "output", "child", "summary", "reference", "package", "attribute", "condition", "python", "block", "trace", "command", "try", "property", "data", "tag", "hello", "root", "function", "message", "position", "see", "comment", "byte", "save", "v", "vector", "success", "state", "length", "image", "port", "priority", "field", "domain", "ue", "status", "text", "location", "version", "total", "session", "rule", "sequence", "Value", "description", "start", "password", "scale", "result", "style", "values", "buffer", "key", "VALUE", "process", "number", "code", "weight", "commit", "label", "val"], "lt_i": ["elt_p", "lt_ci", "lt__i", "elt_ij", "lt0ij", "lt0i", "lt_ij", "lt0p", "elt_ci", "lt__ci", "lt__p", "lt_p", "lt0ci", "elt_i", "lt__ij"]}}
{"project": "FFmpeg", "commit_id": "bb146bb57bea6647f9c080aa4f9323a3a789ad22", "target": 0, "func": "theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)\n\n{\n\n    struct ogg *ogg = ctx->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n    struct theora_params *thp = os->private;\n\n    uint64_t iframe = gp >> thp->gpshift;\n\n    uint64_t pframe = gp & thp->gpmask;\n\n\n\n    if (thp->version < 0x030201)\n\n        iframe++;\n\n\n\n    if(!pframe)\n\n        os->pflags |= AV_PKT_FLAG_KEY;\n\n\n\n    if (dts)\n\n        *dts = iframe + pframe;\n\n\n\n    return iframe + pframe;\n\n}\n", "idx": 23159, "substitutes": {"ogg": ["gs", "ott", "eg", "bb", "oc", "eb", "pp", "orp", "deb", "gg", "ga", "tt", "ot", "gov", "audio", "ech", "mpeg", "rss", "pdf", "ob", "android", "meg", "orm", "irc", "og", "ok", "embed", "oga", "config", "readable", "ib", "org", "owl", "obb", "oss", "iot", "ogs", "archive", "alert", "aud", "msg", "stream", "ood", "eas", "ink", "article", "obs", "voc", "gp", "bool", "ogl", "oid", "ov", "ik", "ogi", "usb", "pg"], "os": ["dos", "oos", "ott", "ows", "oc", "o", "OS", "bs", "rs", "soc", "oz", "ot", "ros", "Os", "oS", "ps", "ds", "ost", "ob", "ms", "osi", "oids", "cs", "s", "og", "ok", "ow", "ts", "ss", "ys", "oss", "pos", "aos", "res", "oses", "ns", "oa", "socket", "obs", "sys", "bos", "oid", "ops", "io", "is"], "thp": ["Tho", "thapl", "othg", "thop", "thaps", "THo", "ethop", "ethp", "othm", "thg", " thpl", "shm", "othp", "thap", "ethpl", "sht", " thop", "etht", " thps", "shp", "THp", "thm", "Thm", "ethm", " thm", "tht", "thpl", "ithm", "othcp", "otho", "Thp", "thps", "ethps", "tho", "thcp", " tht", "ithp", "ethcp", "THm", "ithcp", "ithg", "thaop", "ethg"], "iframe": ["xp", "hi", "pid", "height", "zip", "hz", "iso", "soc", "z", "id", "xxx", "zi", "iam", "image", "igm", "ih", "plot", "proxy", "scroll", "ei", "browser", "emi", "movie", "rss", "asia", "large", "iu", "osi", "show", "vp", "embed", "hid", "html", "empty", " fps", "tx", "i", "flash", "timeout", "tif", "loop", "gif", "gz", " timeframe", "fi", "frame", "phi", "ui", "alert", "foo", "wi", "eye", "rame", "slice", "window", "cam", "frames", "pic", "ii", "fps", "oid", "tf", "fb", "hw", "fp", "peer", "is"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void av_build_index_raw(AVFormatContext *s)\n\n{\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    st = s->streams[0];\n\n    av_read_frame_flush(s);\n\n    url_fseek(&s->pb, s->data_offset, SEEK_SET);\n\n\n\n    for(;;) {\n\n        ret = av_read_frame(s, pkt);\n\n        if (ret < 0)\n\n            break;\n\n        if (pkt->stream_index == 0 && st->parser &&\n\n            (pkt->flags & PKT_FLAG_KEY)) {\n\n            add_index_entry(st, st->parser->frame_offset, pkt->dts, \n\n                            AVINDEX_KEYFRAME);\n\n        }\n\n        av_free_packet(pkt);\n\n    }\n\n}\n", "idx": 23161, "substitutes": {"s": ["ctx", "js", "gs", "m", "spec", "ls", "sq", "p", "sp", "es", "bs", "rs", "w", "sb", "vs", "n", "ps", "fs", "ds", "b", "c", "cs", "r", "serv", "ts", "j", "ss", "stats", "t", "aws", "less", "g", "ns", "ins", "its", "a", "source", "sts", "conv", "qs", "sv", "h", "ats", "sg", "os", "se", "sys", "S", "f", "v", "comm"], "pkt1": ["packet2", " pet2", " pkt2", "pet3", "pftId", "pet0", "cpacketId", "pcmd3", "cpacket1", "pcmdName", "pet2", "packetId", "packet3", "packet0", " pkt0", "pftName", "cpacketName", "pqt3", "pft3", "cpktName", " pet3", "pcmd1", "cpacket3", "pkt2", " pet1", "pktId", "pft1", "cpkt3", " pet0", " pkt3", "cpktId", "pkt0", "pqt2", "cpkt1", "pcmdId", "packet1", "pqt1", "pkt3", "pet1", "pktName", "pqt0", "packetName"], "pkt": ["racket", " pkat", "tpet", "tpact", "rkt", " pcmd", "preet", "preacket", "npnt", "npacket", "pact", "ppcmd", "pet", "tpkt", " pet", "prekat", "pct", "ppnt", " packet", "Packet", "perkt", "perct", "rcmd", "Pct", "Pet", "tpacket", "peracket", "Pact", "rnt", "prekt", "pmsg", " pact", "ppmsg", "Pmsg", "pkat", "ppacket", "pcmd", " pct", "prent", "peret", "npkat", "ppkt", "premsg", "precmd", "packet", "pnt", " pnt", "ppet", "npkt", "Pnt", "Pkt"], "ret": ["cert", "alt", "ter", "tr", " ar", "Ret", " fut", "def", "rem", "status", "inter", "att", " Ret", "fun", " resp", "ry", "rt", " t", "r", "j", "iter", "nt", "deg", "flag", "cmd", "t", "ft", "res", "round", " res", " RET", "cat", "ref", "re", "resp", "out", "arg", "ctr", "rets", "conv", " val", "nz", "gt", "usr", "arr", "elt", "RET", "back", "mt", "f", "cont", "val"], "st": ["stage", "ust", "rest", "sn", "sl", "inst", "p", "start", "sp", "state", "ist", "tr", "ST", "sty", "tt", "must", "d", "util", "ld", "stable", "sc", "fr", "l", "ost", "sh", "St", "decl", "r", "sw", "ts", "nt", "ut", "pt", "step", "t", "ft", "sta", "set", "nd", "est", "stat", "stream", "std", "sts", "sv", "usr", "h", "str", "se", "stop", "ste", "art", "th", "mt", "v", "ct"]}}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static FWCfgState *bochs_bios_init(void)\n\n{\n\n    FWCfgState *fw_cfg;\n\n    uint8_t *smbios_tables, *smbios_anchor;\n\n    size_t smbios_tables_len, smbios_anchor_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:\n\n     *\n\n     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug\n\n     * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC\n\n     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the\n\n     * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS\n\n     * may see\".\n\n     *\n\n     * So, this means we must not use max_cpus, here, but the maximum possible\n\n     * APIC ID value, plus one.\n\n     *\n\n     * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is\n\n     *     the APIC ID, not the \"CPU index\"\n\n     */\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,\n\n                     acpi_tables, acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);\n\n    if (smbios_tables) {\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_tables, smbios_tables_len);\n\n    }\n\n\n\n    smbios_get_tables(&smbios_tables, &smbios_tables_len,\n\n                      &smbios_anchor, &smbios_anchor_len);\n\n    if (smbios_anchor) {\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-tables\",\n\n                        smbios_tables, smbios_tables_len);\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-anchor\",\n\n                        smbios_anchor, smbios_anchor_len);\n\n    }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 23163, "substitutes": {"fw_cfg": ["fwdbini", "fw__conf", "fw___fg", "fwJfg", "w__conf", "sw_cmd", "fw___cert", "fw_note", "fw_log", "xfptnote", "fwmycfg", "hw_config", "wk_config", "fw__cfg", "fwMconf", "xfptfg", "sw_conf", "w_cert", "fw_cmd", "fw___properties", "fwtconfig", "xf_orig", "fw_sg", "hw_orig", "fwJcfg", "fw_jobs", "fwMcfg", "wk_bg", "fw_conf", "fwmyconf", "xfptorig", "fwmysg", "fwtfab", "fwptcfg", "fw_fg", "hw_fg", "fwmygc", "fwlsg", "fwptlog", "w_sg", "fw_cgi", "w_properties", "wk_fee", "w__gc", "fwlorig", "fw_comm", "fwJjobs", "w_conf", "fwptjobs", "fwdbcfg", "w_cfg", "fw___bg", "fw_fee", "fwlfg", "fw__cmd", "fwdbproperties", "fw__fg", "fw__gc", "hw_cfg", "sw_cfg", "fw___ini", "w_gc", "xf_fab", "fwtcfg", "wk_cfg", "xf_note", "fw_fab", "hw_jobs", "fw___orig", "fw___note", "fwptconfig", "fwptfg", "fwtfg", "fw___cgi", "fwMsg", "fw_gc", "fwlcfg", "w__sg", "hw_cgi", "fw_bg", "xfptcfg", "fw_orig", "fwMgc", "fwtorig", "fw___comm", "fwptcgi", "hw_log", "wk_cgi", "hw_fab", "fwptfab", "sw_fg", "fwptnote", "xfptfab", "fw_ini", "fwdbcert", "fw_cert", "fwptorig", "fw_config", "fwtcomm", "w_ini", "hw_sg", "w__cfg", "wk_comm", "xf_cfg", "fw_properties", "fwJcgi", "fw___cfg", "fwtfee", "xf_fg", "fw__sg"], "smbios_tables": ["smbios_transasks", "smbios_tales", "smbios_sables", "smbios_tableables", "smbios_baps", "smbios_dtiers", "smbios_Tabases", "smbios_sors", "smbios_transales", "smbios_nales", "smbios_nables", "smbios_taps", "smbios_Tries", "smbios_Taps", "smbios__tasks", "smbios_entors", "smbios__nabases", "smbios_entries", "smbios_dtables", "smbios_Torders", "smbios__tales", "smbios_Talks", "smbios_srees", "smbios_entalks", "smbios__nales", "smbios_tasks", "smbios_Titles", "smbios_tiers", "smbios_sitles", "smbios_trees", "smbios_tenalks", "smbios_dtries", "smbios_borders", "smbios_entiers", "smbios_tries", "smbios_brees", "smbios_taves", "smbios_transabases", "smbios_bables", "smbios_Tiers", "smbios_entaps", "smbios_dtitles", "smbios_Taves", "smbios__nables", "smbios_tableaves", "smbios_Trees", "smbios_entrees", "smbios_entable", "smbios_entitles", "smbios__tables", "smbios_tors", "smbios_Tasks", "smbios_Tales", "smbios_Tables", "smbios_tableries", "smbios_titles", "smbios_nasks", "smbios_table", "smbios_entables", "smbios_tenable", "smbios_Table", "smbios_Tors", "smbios_torders", "smbios_transables", "smbios_tablerees", "smbios__tabases", "smbios_entorders", "smbios_tenables", "smbios__nasks", "smbios_talks", "smbios_tabases", "smbios_tenries", "smbios_nabases", "smbios_entaves"], "smbios_anchor": ["smbios_chestpor", "smbios_apho", "smbios_anchori", "smbios_chestori", "smbios_accessOR", "smbios_chory", "smbios_chestory", "smbios_chestored", "smbios_chors", "smbios_chestors", "smbios_anchore", "smbios_chore", "smbios_mentor", "smbios_aphor", "smbios_anchory", "smbios_mentore", "smbios_anchors", "smbios_chori", "smbios_entOR", "smbios_entpor", "smbios_factOR", "smbios_factor", "smbios_aphors", "smbios_chestore", "smbios_accessors", "smbios_mentors", "smbios_anchored", "smbios_ancho", "smbios_chestOR", "smbios_aphored", "smbios_entors", "smbios_chestor", "smbios_mentory", "smbios_accessor", "smbios_accessori", "smbios_anchOR", "smbios_factpor", "smbios_cho", "smbios_chesto", "smbios_chored", "smbios_chOR", "smbios_anchpor", "smbios_entor", "smbios_chor", "smbios_factors"], "smbios_tables_len": ["smbios_tasks_str", "smbios_tables_Len", "smbios_tasks_len", "smbios_tries_len", "smbios_tasks_en", "smbios_trees_Len", "smbios_tables2en", "smbios_tables2Len", "smbios_trees_size", "smbios_tries_size", "smbios_tables_size", "smbios_tries_en", "smbios_tries_Len", "smbios_tables_gen", "smbios_tables_length", "smbios_tables2len", "smbios_trees_base", "smbios_tables_str", "smbios_tables_base", "smbios_tasks_Len", "smbios_tables_coll", "smbios_tables_en", "smbios_tables2str", "smbios_trees_len", "smbios_trees_length", "smbios_tries_gen", "smbios_trees_coll"], "smbios_anchor_len": ["smbios_anchor__len", "smbios_anchor_size", "smbios_anchors_ls", "smbios_ancher_pos", "smbios_anchor__en", "smbios_anchors_pos", "smbios_anchor_en", "smbios_anchor_ls", "smbios_anchors_len", "smbios_anchor_Len", "smbios_ancher_en", "smbios_anchor__Len", "smbios_anchors_num", "smbios_ancher_Len", "smbios_ancher_len", "smbios_anchor__pos", "smbios_anchor_num", "smbios_anchor_pos", "smbios_anchors_Len", "smbios_anchors_size"], "numa_fw_cfg": ["numa_fw_fg", "numa_fw2cfg", "numa_hw_config", "numa_hw_cfg", "numa_hw_conf", "numa_fw_config", "numa_fw2fg", "numa_hw_fg", "numa_fw2config", "numa_fw2conf", "numa_fw_conf"], "i": ["m", "ci", "p", "z", "si", "y", "l", "ij", "mi", "b", "c", "r", "t", " ii", "gi", "li", "ip", "a", "bi", "ii", "x", "pi", "I", "ia", "ik", "io", "v"], "j": ["jj", "js", "m", "q", "p", "z", "uj", "aj", "jp", "d", "n", "l", "ij", "b", "jc", "c", "r", "ni", "k", "g", "jac", "J", "job", "ji", "jump", "kj", "v"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n    case PSW_ASC_HOME:\n\n        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == 2) {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 23174, "substitutes": {"env": ["ctx", "dev", "equ", "vt", "viron", "te", "forge", "inv", "state", "ev", "qt", "manager", "here", "engine", "esm", "conf", "entry", "w", "esc", "eng", "vs", "den", "conn", "ah", "ei", "enter", "environment", "vm", "era", "self", "er", "worker", "vp", "config", "ec", "org", "cmd", "server", "net", "network", "set", "en", "ner", "open", " environment", "et", "ew", "cv", "window", "buf", "event", "code", "obj", "e", "context", "param", "kernel", "h", "policy", "end", "operator", "Environment", "erd", "v"], "vaddr": ["nvaddr", "radr", " vobj", "hptr", "vaddress", "Vadd", "waddr", "wadr", "mobj", "vtptr", "vadd", " vadd", "wptr", "rattr", "wattr", "Vadr", "nvattr", "wobj", "vobj", "Vattr", "hreq", "hadd", "vadr", "rptr", " vadr", "vptr", "radd", "hadr", "nvaddress", " vreq", "vtreq", "Vaddr", "vtattr", "haddress", "vtadr", "haddr", "mptr", "raddress", "vreq", "vattr", "nvptr", "maddr", "maddress", "waddress", "wadd", " vaddress", " vattr", "vtaddress", " vptr", "mattr", "madr", "vtaddr"], "rw": ["wn", "xp", "wh", "wo", "nw", "RW", "writ", "iw", "fw", "dx", "w", "rew", "wb", "tw", "wa", " wr", "ww", "aw", "rss", "rh", "rt", "wp", "wind", "r", "ow", "sw", "kw", "wd", "wr", "shr", " w", "rb", "rf", "ng", "ew", "ru", "buf", "writer", "wcs", "row", "wal", "au", "usr", "rd", "hw", "weight", "wx", "nr", "rc"], "asc": ["ac", "acc", "ra", "alpha", " pas", " acc", "asa", "alias", "sort", "soc", "amps", "arp", " win", "esc", "up", "tc", " sc", "anc", "sc", " ap", " ps", "acs", " esc", " lac", "acl", "admin", "fc", "as", "sw", " ac", " rc", " arg", "ec", "uc", "ASC", "rar", " exc", "auc", "ar", " inc", "pc", " pc", "unc", "asm", " alpha", "desc", "pac", "arg", " Asc", " agg", "aps", "title", " ASC", " enc", "rc", "addr", "pg", "cmp", " tc", " addr", "ras", " desc"], "raddr": ["vopen", "Rptr", "radr", "rcaddress", "rargs", "rloc", "vaddress", "Radr", "Raddr", "waddr", "wadr", "vadd", "paddr", "rattr", " rattr", "wptr", "padd", "rradd", "rcaddr", "vadr", " ropen", " rargs", "paddress", "rptr", " raddress", "rropen", "rrargs", "vptr", "radd", " radd", "Radd", " rptr", "pptr", "laddress", "mptr", " rloc", "raddress", "vloc", "rraddr", " radr", "vattr", "maddr", "maddress", "ladd", "ropen", "laddr", "waddress", "wadd", "rcptr", "mattr", "rraddress", "padr", "rcloc", "vargs"], "flags": ["alf", "dates", "comments", "events", "amps", "rules", "ants", "links", "fd", "types", "fs", "bugs", "acl", "settings", "stats", "xml", "lines", "cons", "actions", "wcs", "frames", "intel", "fps", "words", "pages", "f", "acts", "workers", "posts", "ads", "lag", "mates", "ps", "acs", "helps", "ts", "pants", "flag", "args", "atts", "goal", "ags", "ports", "citizens", "aps", "finals", "locks", "opens", "bits", "tags", "headers", "weights", "states", "inks", "ms", "products", "limits", "terms", "uart", "fac", "cond", "options", "ats", "mask", "pres", "fp", "fee", "fields", "heads", "Flags", "styles", "rights", "details", "feat", "phones", "packages", "utils", "func", "affles", "doms", "fits", "plugins", "features", "properties", "vals", "ents", "caps"], "sk": ["ke", "Sk", "sn", "kr", "sp", "mk", "kt", "sy", "unk", "ka", "uk", "km", "sc", "kick", "sky", "craft", "spe", "cs", "ski", "alk", "ok", "sw", "kw", "tk", "kl", "kid", "ank", "k", "ek", "sch", "ck", "kk", "ks", "SK", "ark", "kn", "dk", "se", "mask", "ask", "wk", "ik", "seek", "ki"]}}
{"project": "FFmpeg", "commit_id": "dbc1163b203b175d246b7454c32ac176f84006d1", "target": 0, "func": "static inline int decode_ac_coeffs(GetBitContext *gb, int16_t *out,\n\n                                   int blocks_per_slice,\n\n                                   int plane_size_factor,\n\n                                   const uint8_t *scan)\n\n{\n\n    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;\n\n    int max_coeffs, bits_left;\n\n\n\n    /* set initial prediction values */\n\n    run   = 4;\n\n    level = 2;\n\n\n\n    max_coeffs = blocks_per_slice << 6;\n\n    block_mask = blocks_per_slice - 1;\n\n\n\n    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {\n\n        run_cb_index = ff_prores_run_to_cb_index[FFMIN(run, 15)];\n\n        lev_cb_index = ff_prores_lev_to_cb_index[FFMIN(level, 9)];\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return 0;\n\n\n\n        run = decode_vlc_codeword(gb, ff_prores_ac_codebook[run_cb_index]);\n\n        if (run < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        level = decode_vlc_codeword(gb, ff_prores_ac_codebook[lev_cb_index]) + 1;\n\n        if (level < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        pos += run + 1;\n\n        if (pos >= max_coeffs)\n\n            break;\n\n\n\n        sign = get_sbits(gb, 1);\n\n        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =\n\n            (level ^ sign) - sign;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23184, "substitutes": {"gb": ["ctx", "cfg", "gc", "gs", "uf", "ogg", "eg", "bb", "nb", "bs", "hog", "ub", "bc", "gg", "yg", "gm", "sb", "cgi", "tg", "gd", "Gb", "phy", "google", "arb", "GB", "bm", "storage", "buff", "bt", "img", "gif", "kb", "db", "rb", "g", "bg", "vg", "pc", "pb", "lb", "csv", "mb", "buf", "ch", "gp", "bf", "gt", "gem", "rg", "sg", "hub", "fb", "pg", "gin", "cb", "cv", "bn"], "out": ["list", "p", "o", "file", "at", "Out", "conf", "bin", "can", "w", "up", "outs", "n", "it", "result", "b", "c", "ou", "serv", "in", "net", "map", "set", "output", "buffer", "clean", "buf", "all", "ch", "OUT", "os", "new", "mask", "block", "pool", "table", "v"], "blocks_per_slice": ["blocks_perJslice", "blocks_per2scale", "blocks_PER_scale", "blocks_PER_series", "blocks_PER_tile", "blocks_current__section", "blocks_each_ice", "blocks_current__series", "blocks_per_sample", "blocks_PER_sample", "blocks_current_series", "blocks_per_scale", "blocks_eachJcell", "blocks_per_section", "blocks_current_section", "blocks_perJcell", "blocks_each_slice", "blocks_per_cell", "blocks_perJice", "blocks_per__series", "blocks_eachJice", "blocks_each_cell", "blocks_PER_slice", "blocks_current__slice", "blocks_eachJslice", "blocks_per2slice", "blocks_per__slice", "blocks_per__section", "blocks_current_slice", "blocks_per_ice", "blocks_per2series", "blocks_per_tile", "blocks_per_series"], "plane_size_factor": ["plane_size_floor", "plane_sizeityfactor", "plane_sizeulofactor", "plane_sizeulofact", "plane_size_digit", "plane_sizeulofloor", "plane_size_fact", "plane_sizeitydigit"], "scan": ["check", "spec", "pack", "bank", "conf", "parse", "pixel", "can", "range", "pan", "sc", "scale", "pass", "warn", "sky", "spe", "Scan", "sync", "score", "query", "gain", "black", "map", "set", "buffer", "skip", "gate", "plan", "slice", "read", "reach", "cam", "row", "sys", "miss", "mask"], "pos": ["rot", "oc", "bs", "at", "conf", "sol", "pass", "POS", "neg", "pt", "oss", "pro", "pc", "resp", "ind", "x", "os", "pi", "px", "pid", "o", "Pos", "yes", "up", "tag", "trans", "range", "ps", "doc", "in", "loss", "col", " rot", "position", "len", " Pos", " position", "num", "add", "loc", "length", "port", "Position", "offset", "po", "point", "cond", "pose", "lat", "row", "pres", "err", "spec", "p", "start", "body", "id", "path", "def", "n", "pl", "no", "i", "size", "coord", "off", "index", "response", "val"], "block_mask": ["blockLweight", "lock_map", "block_limit", "blocklymask", "blockLindex", "block_map", "blocklyweight", "block_filter", "blocklymap", " block_limit", "block_flag", " block_sign", "lock_mask", "lock_index", "lock_weight", "block_sign", "blocklyindex", "block_weight", "blockLmask", "block_index", " block_map", "blockLmap", " block_flag", " block_filter"], "run": ["rog", "rot", "dir", "ra", "family", "depth", "name", "type", "length", "plot", "unit", "block", "range", "n", "rain", "pass", "role", "fun", "rown", "task", "line", "r", "ran", "roll", "rate", "cmd", "go", "order", "build", "step", "loop", "work", "reg", "round", "frame", "rank", "Run", "runs", "ru", "re", "play", "group", "rol", "len", "ro", "row", "running", "con", "job", "record", "rec", "index", "une", "rc", "rd", "rid", "runner", "rm", "call", "circ", "pair", "un"], "level": ["high", "lo", "depth", "state", "lvl", "id", "length", "loc", "pe", "half", "priority", "low", "field", "block", "ld", "scale", "ps", "sc", "pass", "lev", "pl", "test", "Level", "vel", "l", "role", "co", "vol", "limit", "tail", "thread", "score", "scope", "lc", "roll", "po", "lv", "stack", "version", "loop", "print", "size", "cond", "round", "layer", "col", "where", "key", "goal", "pri", "count", "group", "len", "rol", "compl", "row", "color", "local", "levels", "index", "wl", "call", "coll", "label", "cell", "le", "val"], "sign": ["spec", "pack", "diff", "inc", "ass", "sp", "sort", "depth", "z", "mod", "id", "length", "sb", "Sign", "ann", "scale", "sc", "turn", "value", "pass", "shift", "sh", "s", "lock", "score", "sw", "speed", "ig", "ss", "sum", "shape", "prime", "sect", "ign", "round", "sch", "rank", "pen", "align", "vis", "comment", "code", "SIGN", "ind", " SIGN", "index", "x", "se", "qual", "spect", "S", "mask", "dig", "err", "save", "space", "sd"], "run_cb_index": ["run_cb_node", "run_cbrser", "run_rb_loc", "run_cb__id", "run_cb_ser", "run_cbacindex", "run_rb_ser", "run_rb_Index", "run_cbzind", "run_cb__index", "run_cb_ind", "run_cbzser", "run_cb_loc", "run_cbrnode", "run_cbrind", "run_cb_id", "run_cb_Index", "run_cb__Index", "run_cbacref", "run_cbznode", "run_rb_ref", "run_rb_ind", "run_rb_id", "run_cbzindex", "run_rb_node", "run_cbacIndex", "run_cbrindex", "run_cbacid", "run_rb_index", "run_cb_ref", "run_cb__loc"], "lev_cb_index": ["lev_cbixIndex", "lev_cb_id", "lev_rb_mix", "lev_callback_index", "lev_cb_position", "lev_cb_mix", "lev_cbkIndex", "lev_cboeindex", "lev_callback_Index", "lev_cbixmix", "lev_rb_index", "lev_cboevalue", "lev_cbixindex", "lev_cb_Index", "lev_cb_value", "lev_cboeIndex", "lev_rb_Index", "lev_cb_out", "lev_callback_value", "lev_cb_size", "lev_cbkout", "lev_rb_out", "lev_cboesize", "lev_cbkindex", "lev_callback_size", "lev_cbkmix", "lev_cbixout", "lev_rb_id", "lev_rb_position"], "max_coeffs": ["max_COefs", "max_coeffps", "max_coffes", "max_COefficientses", "max_coefficientS", "max_COefS", "max_coefances", "max_coeffes", "max_coefls", "max_COeffS", "max_COeffes", "max_coffances", "max_coefficientses", "max_coefes", "max_COeffs", "max_coefs", "max_COefps", "max_coefps", "max_coeffls", "max_coeffances", "max_coefficients", "max_coefficientsS", "max_COefficientss", "max_COeffps", "max_coffs", "max_coefficientes", "max_COefes", "max_coefficientls", "max_coefficientss", "max_coffls", "max_coeffS", "max_coefficientances", "max_COefficientsS", "max_coefficientsps", "max_coefficientps", "max_coefS"], "bits_left": ["bits55left", "bits_wrong", "bits64lt", "bits2right", "bytes_right", "bits_list", "bits64inner", " bits_only", "ports__left", "bytes_last", "bits2lt", "bits2wrong", "ports_wrong", "bits_right", "bits67lf", "bits64low", "bits_only", "rots64le", " bits_cont", "its_right", " bits2left", "rots_low", "bits__wrong", " bits_wrong", "its_exp", "rots_le", "bits55right", "bits__loaded", "its_allowed", "bits_loaded", "bits_lf", "bitsmmtop", "bits_lt", "its_lf", "ports__loaded", "bits64left", "ports__wrong", "bitsonl", "bits64top", "bits_le", "bits55allowed", "bits64le", "bitsonleft", "rots64left", "its_low", "bits64right", "its_left", "bitsmmleft", "rots64low", "bits_low", "bits_top", " bits_top", "ports_left", "bits2inner", "bits_inner", "bitsonright", "bits2left", "bits2list", "bits55low", "bitsonlast", "bits_exp", "bits67right", "bits2cont", "bits67exp", "bits_l", "rots_left", "bitsmmonly", "ports_loaded", "bytes_l", "bytes_inner", "bits_allowed", "bits_last", "bits2low", "bits_cont", " bits2wrong", "bytes_low", "bits67left", "bytes_left", "bits64only", "bits__left", " bits2cont", "bytes_list", "bytes_lt"]}}
{"project": "qemu", "commit_id": "faab207f115cf9738f110cb088ab35a4b7aef73a", "target": 1, "func": "static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}", "idx": 23186, "substitutes": {"ctx": ["cp", "pkg", "gc", "ca", "np", "ksh", "mk", "cn", "bc", "req", "loc", "jp", "xc", "tc", "anc", "nc", "conn", "cm", "cc", "Context", "sc", "cl", "lex", "fc", "kw", "tx", "nt", "cas", "bh", "txt", "care", "setup", "wcs", "cu", "context", "mem", "conv", "xs", "x", "cf", "hw", "wx", "cmp", "px", " cx", "cb", "cv", "ct"], "fs_path": [" fs_mon", " fs_Path", "fs_ref", " fs_entry", "fs_desc", " fs_ref", "fs_Path", "fs_mon", " fs_desc", "fs_context", "fs_entry", " fs_context"], "fs": ["ls", "rs", "bs", "fw", "vs", "ps", "Fs", "fd", "irs", "ds", "ms", "files", "s", "cs", "fc", "ts", "ss", "oss", "stats", "aos", "aws", "ns", "FS", "obs", "sys", "sf", "cf", "fps", "os", "f", "df"], "dirfd": [" dirid", "folderfd", "idFD", "filefd", "directoryid", "dirFD", "dird", "dirds", " dirds", "dirid", "idfd", "iddf", " dirdf", " dird", "dfd", "dFD", "folderdir", "directoryfd", " dirFD", "fileFD", "Dircond", "Dird", "filedf", "folderid", "Dirfd", "dd", "dirdf", "folderds", "filed", "directorycond", "filecond", "dds", "DirFD", "Dirds", "dirdir", "directoryds", "directoryd", "dircond", "idd", "directorydir", " dirdir", "directoryFD"], "stream": ["Stream", "dir", "list", "sl", "ssl", "spec", "export", "data", "table", "transform", "file", "depth", "hold", "tr", "mount", "iterator", "length", "port", "path", "store", "console", "tree", "fd", "test", "feed", "status", "present", "pool", "pair", "sync", "wrapper", "sw", "stack", "find", "host", "dr", "server", "loop", "encrypted", "pipe", "buffer", "driver", "clean", "reader", "open", "poll", "child", "pod", "window", "socket", "REAM", "channel", "handle", "sign", "row", "read", "next", "zip", "context", "record", " upstream", "form", "local", "str", "ready", "resource", "progress", "f", "cont", "draw"]}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, ac3_id;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd = (ctx->oformat == &mpeg1vcd_mux);\n\n    s->is_mpeg2 = (ctx->oformat == &mpeg2vob_mux);\n\n    \n\n    if (s->is_vcd)\n\n        s->packet_size = 2324; /* VCD packet size */\n\n    else\n\n        s->packet_size = 2048;\n\n        \n\n    /* startcode(4) + length(2) + flags(1) */\n\n    s->packet_data_max_size = s->packet_size - 7;\n\n    if (s->is_mpeg2)\n\n        s->packet_data_max_size -= 2;\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n    mpa_id = AUDIO_ID;\n\n    ac3_id = 0x80;\n\n    mpv_id = VIDEO_ID;\n\n    s->scr_stream_index = -1;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        switch(st->codec.codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if (st->codec.codec_id == CODEC_ID_AC3)\n\n                stream->id = ac3_id++;\n\n            else\n\n                stream->id = mpa_id++;\n\n            stream->max_buffer_size = 4 * 1024; \n\n            s->audio_bound++;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            /* by default, video is used for the SCR computation */\n\n            if (s->scr_stream_index == -1)\n\n                s->scr_stream_index = i;\n\n            stream->id = mpv_id++;\n\n            stream->max_buffer_size = 46 * 1024; \n\n            s->video_bound++;\n\n            break;\n\n        default:\n\n            av_abort();\n\n        }\n\n    }\n\n    /* if no SCR, use first stream (audio) */\n\n    if (s->scr_stream_index == -1)\n\n        s->scr_stream_index = 0;\n\n\n\n    /* we increase slightly the bitrate to take into account the\n\n       headers. XXX: compute it exactly */\n\n    bitrate = 2000;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        bitrate += st->codec.bit_rate;\n\n    }\n\n    s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n    \n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n       s->pack_header_freq = 1;\n\n    \n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* every 40 packets, this is my invention */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n    \n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        stream = ctx->streams[i]->priv_data;\n\n        stream->buffer_ptr = 0;\n\n        stream->packet_number = 0;\n\n        stream->start_pts = AV_NOPTS_VALUE;\n\n        stream->start_dts = AV_NOPTS_VALUE;\n\n    }\n\n    s->last_scr = 0;\n\n    return 0;\n\n fail:\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        av_free(ctx->streams[i]->priv_data);\n\n    }\n\n    return -ENOMEM;\n\n}\n", "idx": 23193, "substitutes": {"ctx": ["cp", "cfg", "pkg", "xp", "np", "bc", "req", "ppo", "kt", "jp", "conf", "tmp", "xc", "tc", "anc", "that", "qu", "nc", "cm", "mc", "cc", "sc", "conn", "Context", "ij", "etc", "com", "history", "c", "fn", "fc", "aux", "kw", "tx", "config", "kl", "cmd", "nt", "org", "act", "comm", "aus", "kb", "jac", "pc", "txt", "ck", "std", "care", "setup", "resp", "desc", "wcs", "abc", "context", "conv", "sys", "aka", "cf", "addr", "hw", "ia", "wx", "cmp", "px", "cb", "cont", " cx", "ctl", "cv", "ct"], "s": ["south", "so", "bs", "rs", "ants", "fs", "ims", "settings", "cs", "stats", "ar", "set", "https", "ies", "ins", "its", "actions", "sam", "os", "f", "ls", "es", "vs", "ps", "ds", "l", "b", "ess", "ts", "args", "less", "ports", "se", "is", "v", "js", "gs", "m", "sets", "tes", "ssl", "sl", "us", "parts", "eps", "sm", "status", "ms", "ses", "ss", "results", "aws", "g", "ers", "hs", "services", "obj", "scripts", "sts", "sys", "ats", "pers", "sports", "spec", "sq", "details", "sb", "n", "y", "has", "c", "tests", "as", "j", "utils", "ns", "changes", "sv", "qs", "xs", "h", "sg", "S", "als", "ops"], "bitrate": [" bitRate", "bitspeed", "Bitspeed", "brate", "rotrate", "binfrequency", "bitRate", "Bitrate", "bRate", "Bitrates", "rotrates", "brates", "binRate", "rotspeed", "binrate", "bitrates", "bitfrequency", " bitspeed", " bitrates", " bitfrequency", "binrates", "bfrequency"], "i": ["hi", "m", "me", "try", "ci", "ix", "p", "id", "multi", "zi", "si", "to", "n", "ei", "y", "it", "xi", "ims", "ij", "l", "ti", "mi", "qi", "b", "gu", "c", "iu", "chain", "iter", "j", "di", "in", "go", "dr", "ai", "t", "im", "ie", "g", "fi", "gi", "phi", "ui", "li", "ic", "cli", "ip", "sim", "ri", "ji", "ini", "e", "ind", "bi", "conv", "oi", "index", "ii", "x", "h", "pi", "batch", "I", "f", "is", "v"], "mpa_id": ["mp3_magic", "mp3ameno", "mp3_no", "mpaoxno", "mpa_magic", "mpan_ID", "mpan_mid", "mpaamemagic", "mpa___ide", "mpan_id", "mpa___source", "mpn_file", "mpa_mid", "mp3_id", "mpa_value", "mpaoxvalue", "mpa_no", "mpaoxmagic", "mpaameid", "mpa___id", "mpa_source", "mp3ameid", "mpa_file", "mpaamevalue", "mpa_ID", "mpaoxid", "mpan_vid", "mpn_ide", "mp3amemagic", "mpa___file", "mpa___mid", "mpn_id", "mpn_source", "mpa___vid", "mpa_vid", "mpaameno", "mp3_value", "mp3amevalue", "mpa_ide", "mpa___ID"], "mpv_id": ["mpi___id", "mpd_ip", "mpu_ide", "mpd_i", "mpv___name", "mpv_init", "mpv_ids", "mpu_id", "mpv___data", "mpi_vid", "mpvoxdata", "mpd_name", "mpv_in", "mpi___init", "mpi_data", "mpi_id", "mpv___ip", "mpvoxid", "mpd_id", "mpv___vid", "mpi_init", "mpv_ide", "mpvoxvid", "mpvoeid", "mpv____in", "mpv____ids", "mpu_ids", "mpv____id", "mpi___data", "mpv_data", "mpv_ip", "mpvoedata", "mpv_name", "mpv_vid", "mpv___i", "mpu_in", "mpvoxinit", "mpv___init", "mpvoevid", "mpv____ide", "mpv___id", "mpvoeinit", "mpv_i", "mpi___vid"], "ac3_id": ["ac32id", "ac3_mid", "ac3___h", "ac3___id", "ac3_n", "ac2_ids", "ac3___name", "acrav_n", "acd_id", "ac32ID", "acd_oid", "ac32oid", "ac2_mid", "ac3_ID", "acrav___n", "ac3_name", "ac2_id", "ac3___n", "acd_ID", "acrav___name", "ac3_ids", "ac2_ID", "acrav_id", "ac3_oid", "acrav___id", "ac3_h", "acrav___h", "acrav_name", "acrav_h"], "st": ["stage", "ast", "rest", "so", "sl", "sn", "inst", "start", "sp", "z", "td", "ist", "tr", "ST", "tt", "w", "tmp", "stable", "sc", "src", "it", "sm", "ost", "sh", "St", "rt", "storage", "sw", "tx", "ts", "nt", "stack", "ut", "pt", "step", "t", "sta", "nd", "est", "stat", "irst", "std", "sth", "store", "desc", "sam", "th", "sts", "sv", "form", "h", "str", "se", "os", "ste", "art", "mt", "cont", "v", "ct"], "stream": ["lo", "transform", "sc", "test", "chain", "info", "ream", "roll", "dr", "video", "dd", "pod", "store", "head", "instance", "record", "package", "filter", "table", "stage", "Stream", "inner", "data", "iv", "feed", "wrapper", "loop", "message", "pipe", "upload", "socket", "writer", "source", "cont", "download", "present", "draw", "v", "ssl", "sl", "ev", "tr", "length", "iterator", "port", "console", "field", "status", "load", "readable", "stack", "version", "metadata", "reader", "driver", "window", "channel", "REAM", "row", "http", "time", "form", "view", "str", "sequence", "pool", "spec", "body", "mount", "ST", "path", "service", "src", "style", "sw", "host", "t", "buffer", "poll", "out", "context", "steam", "response"], "audio_bound": ["audiollBound", "meta_range", "meta_bound", "audioCountbound", "meta_min", "video_end", "audioCountend", "audio_range", "audioptmin", "audio___min", "audio_end", "audioptbinding", "audioCountBound", "audiollvisible", "audio_min", "audio_visible", "video_Bound", "audiollbound", "audioptbound", "metaptrange", "audio___range", "audio___binding", "meta_binding", "metaptmin", "video_visible", "metaptbinding", "audiollend", "audio_Bound", "audioCountvisible", "audioptrange", "metaptbound", "audio_binding", "audio___bound"], "video_bound": ["photoptbound", "video___required", "video___bound", "video___scope", "video_required", "video_limit", "videoptbound", "video_range", "photoptrequired", "stream_allowed", "videoptscope", "photoptlimit", "photo_bound", "video32limit", "video_scope", "streammrange", "videomrange", "video32scope", "streammbound", "videombound", "video32bound", "videoptlimit", "streammallowed", "stream_range", "video32required", "video_allowed", "photo_required", "photo_scope", "photo_limit", "stream_index", "photoptscope", "videomindex", "streammindex", "videomallowed", "stream_bound", "video_index", "videoptrequired", "video___limit"]}}
{"project": "FFmpeg", "commit_id": "d7da4d47a6841444f12bf56dfe4230d3e4af8646", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n    int ret;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n    mxf->edit_units_per_packet = 1;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!url_feof(s->pb)) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n\n\n            if (!mxf->current_partition) {\n\n                av_log(mxf->fc, AV_LOG_ERROR, \"found essence prior to first PartitionPack\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            if (!mxf->current_partition->essence_offset) {\n\n                /* for OP1a we compute essence_offset\n\n                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)\n\n                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset\n\n                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)\n\n                 */\n\n                int64_t op1a_essence_offset =\n\n                    round_to_kag(mxf->current_partition->this_partition +\n\n                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n\n\n\n                if (mxf->op == OPAtom) {\n\n                    /* point essence_offset to the actual data\n\n                    * OPAtom has all the essence in one big KLV\n\n                    */\n\n                    mxf->current_partition->essence_offset = avio_tell(s->pb);\n\n                    mxf->current_partition->essence_length = klv.length;\n\n                } else {\n\n                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */\n\n                    mxf->current_partition->essence_offset = op1a_essence_offset;\n\n                }\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else if (mxf->parsing_backward)\n\n                continue;\n\n            /* we're still parsing forward. proceed to parsing this partition pack */\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n\n\n                    /* only seek forward, else this can loop for a long time */\n\n                    if (avio_tell(s->pb) > next) {\n\n                        av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n\n                               klv.offset);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    /* we need to do this before computing the index tables\n\n     * to be able to fill in zero IndexDurations with st->duration */\n\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n\n        return ret;\n\n\n\n    if (mxf->nb_index_tables > 1) {\n\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    mxf_handle_small_eubc(s);\n\n\n\n    return 0;\n\n}\n", "idx": 23206, "substitutes": {"s": ["js", "gs", "m", "south", "ssl", "spec", "ls", "sq", "p", "es", "us", "rs", "bs", "z", "details", "conf", "sb", "sql", "vs", "sports", "ps", "bis", "fs", "ims", "ds", "self", "scl", "b", "ms", "c", "cs", "as", "sw", "ts", "ses", "ss", "i", "stats", "t", "aws", "less", "g", "https", "ns", "ins", "changes", "its", "webkit", "hs", "source", "simple", "sts", "http", "qs", "sv", "sys", "x", "sg", "os", "ats", "h", "S", "ex", "is", "v"], "mxf": ["esmcf", "modcolm", " mftime", "mmfif", "meanfa", "esmxc", "meancf", "munxf", "mlf", " mlf", " mafe", "mxc", "appfif", "Mxf", "nxf", "amfw", " mxe", "mmfw", "esmxf", "Mlf", "Mafe", "cmxf", "mftime", "munfo", "mfa", "mifif", "muncf", "mccf", "Mphp", "munphp", "lemiffe", "rmfa", "cmxff", "kxf", "mphp", "miftime", "manxf", "mxff", "manfo", "gmcolm", "kiffe", "mfs", " mfo", "lemxf", "mafe", "modxff", "mfo", "mcf", " mcolm", "rmcf", "appfa", "amxf", "rmxc", "modulexe", "gmxf", "modulexff", " mfif", "mmxf", "rmfif", "modulecf", "modxf", " mcf", "manfif", "cmcf", "ncf", "appxf", "miffe", " mxc", "lemfif", "lemphp", "amcf", " miffe", "mxe", "kcf", "esmxff", "meanxc", "cmxc", "mcfs", "modlf", "mcolm", "lemcf", "manfw", " mphp", "mmfo", "rmxf", "Mxe", "moduleafe", "modulexf", "modulefif", "Mxff", "meanxf", "modulefa", "Mcf", "kphp", "gmxff", " mfs", "amfs", "Mxc", "Mfo", " mxff", "mixf", "rmxff", "mfif", "mcxf", " mfa", "gmcf", "modcf", "micf", "appxff", "lemftime", "nxc", "mfw", "mcfw", "nfa", " mfw"], "klv": ["arklr", "keylv", "unkserv", "ckvv", " kls", "kvv", "kelvl", "kval", "arklv", "Kll", "iklv", "uklv", "arklu", "klif", "klr", "keyvP", "mklad", "arklev", " kvv", "kelad", "kelf", "kll", "keylad", " klu", "ktll", "ckvl", "Klv", "okls", "KLV", " klr", "cklr", "ikserv", "kelv", "ktvl", " klif", "mklv", "mkvP", " kdd", "arklvl", "eklif", "kwd", "ekls", "kevP", "keylu", "oklv", " kll", " klvl", "aklv", "kvon", "arklf", "kLV", "kserv", "kelu", "klad", "oklf", "kewd", "oklif", "eklv", "klvl", "cklev", "akvv", "kdd", "ckll", " kLV", "kvl", "akll", "eklf", "iklev", "unkwd", "ukwd", "ukval", "arkdd", "kevon", "ikLV", "ktlf", "kevv", "akvl", "unkval", "unkvon", " klf", "klev", "kvP", "ckLV", "unklev", "arkvv", "Klf", " klev", "klf", "cklv", "keval", "ckserv", "kls", "unklv", "mklu", "ktLV", "unkLV", "ktlv", "kedd", "ktvv", "klu", "kelev", "ukvon", "arkLV"], "ret": [" fin", "reset", "alt", "rs", " alt", "Ret", " continued", "rew", "rem", "fin", "result", " resp", "ry", "rt", " fmt", "nt", "ft", " RET", "rev", "re", "ral", "resp", "mem", "RET", "val"], "metadata": ["meta", "m", "eta", "json", "data", "adata", "details", "multi", "tmp", "ka", "definition", "ATA", "primary", "info", "settings", "kw", "xml", "dm", "message", "met", "msg", "csv", "md", " m", "ata", "properties", "cmp", "mt"]}}
{"project": "qemu", "commit_id": "25d943b95703ae45567395db4156b25052ee54c4", "target": 1, "func": "get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23213, "substitutes": {"retval": [" retvals", "RetVal", "RETval", "retVal", "retvalue", "Retvalue", " retpol", "RETvalue", " retvalue", " retVal", "retpol", "altpol", "Retpol", "Retvals", "RETVal", "altVal", "altval", "altvals", "Retval", "retvals", "RETvals"], "msg": ["pkg", "name", "tmp", "mg", "ext", "good", "gz", "resp", "buf", "md", "arg", "ch", "arr", "ctx", "data", "mod", "reason", "mn", "trans", "vol", "doc", "og", "html", "img", "args", "error", "message", "desc", "mb", "mid", "gs", "m", "pub", "seq", "req", "notice", "ptr", "tg", "mu", "module", "mess", "text", "ms", "send", "raw", "Msg", "res", "g", "txt", "obj", "title", "str", "mask", "err", "cfg", "body", "gm", "nm", "bytes", "tx", "cmd", "go", "t", "mail", "buffer", "bg", "ref", "out", "event", "mem", "sg", "addr", "mt"], "flags": ["acts", "comments", "FLAG", "posts", "bits", "modules", "points", "type", "details", "ints", "times", "tags", "lag", "ants", "module", "weights", "states", "types", "fs", "offset", "status", "ensions", "prefix", "ms", "mode", "s", "settings", "limits", "kind", "grades", "ts", "flag", "errors", "keys", "utils", "args", "actions", "ags", "frames", "options", "features", "ports", "reports", "levels", "properties", "mask", "weight", "fields", "heads", "Flags", "locks"], "nchars": ["Nchararts", "ncolas", "ncaparts", "nchats", "nscheales", "nchants", "nschears", "Ncharords", " nChashes", "nchunks", "nshales", "ncpunks", "nthats", " nchas", " nchales", "nuarchants", "nschearts", "nChars", "nChats", "ncharts", " nChars", "narchards", "nuarchards", "nuarchars", "nmessars", "Nchars", "ncharars", "ncharords", "NchARS", "nchARS", "nchararts", "ncolants", "Nchords", " nChas", " nCharts", "nCharts", "nchaps", "nscheents", "nsharts", " nchats", "ncolARS", " nchARS", "nshents", "ncharaps", "ncolars", "nChas", " nchaps", "ncapARS", "nChashes", "nthars", " nchents", "nuchARS", "ncpARS", " ncharats", " nChunks", "ncolards", " ncharARS", "nchords", " nChents", "ncharas", "nchents", " nChARS", " ncharts", "ncharats", "ncpars", "nuarchARS", "nchas", "nchales", "nChales", " ncharars", " nchararts", "nmessashes", "nChents", "nshars", " nchashes", "nmessARS", " nChaps", "Ncharts", " nchunks", "ncapords", "narchars", "ncharants", "nuchards", "ncapars", "nchashes", "nthARS", "nChaps", "ncharARS", "ncharards", "ncolaps", "nmessunks", "Ncharars", "nuchars", "nChARS", "nchards", "narchARS", "NcharARS", " nChales", "ntharts", "nChords", "nChunks", "nuchants", "ncpashes", "narchants"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n", "idx": 23237, "substitutes": {"r": ["m", "cr", "rect", "q", "p", "mr", "kr", "ur", "rs", "pr", "tr", "br", "fr", "red", "rn", "rem", "l", "role", "er", "attr", "rh", "rt", "rus", "dr", "ren", "rar", "ar", "res", "R", "g", "rb", "repl", "vr", "rev", "re", "ro", "e", "rec", "rl", "rg", "sr", "rr", "rd", "rm", "err", "rel", "nr", "pair", "rc"], "r_next": ["rc__secondary", "r2next", "rc_next", " r_path", "vr_obj", "r___next", "r___env", "r__path", "r__secondary", "r2member", " r__data", " r_data", " r__path", "rc__next", "r_Next", " r_Next", "vr_prev", "r___obj", "r_env", "vr_next", "r__member", " r__Next", "rc_secondary", "rc__prev", "r__prev", "r_obj", "r2prev", "rc__member", "r_data", "r_secondary", "rc_prev", "r__data", "r__next", "r2secondary", " r__next", "r_member", "r___prev", "rc_member", "r_path", "vr_env", "r__Next", "r_prev"], "h": ["ha", "ity", "hi", "kh", "m", "hr", "hz", "zh", "hold", "rendered", "oh", "ih", "w", "d", "ho", "ph", "ah", "y", "hm", "it", "pl", " ph", "His", "each", "has", "ht", "hd", "rh", "history", "sh", " dh", "he", " inh", "j", "orth", "html", "gh", "go", "i", "host", " hang", "loop", "bh", "H", "k", "g", "phi", "hp", " hash", "hash", " clen", "head", "window", "hh", "hs", "his", "hl", "hal", "ch", "ach", "x", "th", "ish", "pers"]}}
{"project": "qemu", "commit_id": "e1123a3b40a1a9a625a29c8ed4debb7e206ea690", "target": 0, "func": "static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,\n\n                                    int nb_sectors)\n\n{\n\n    int64_t cluster_num, nb_clusters;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return;\n\n    }\n\n    cluster_num = sector_num / iscsilun->cluster_sectors;\n\n    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                               iscsilun->cluster_sectors) - cluster_num;\n\n    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);\n\n}\n", "idx": 23244, "substitutes": {"iscsilun": ["iscseverean", "ircsinun", "ischematicrun", "iconssilume", "iscstatesune", "isksilon", "iscsinun", "micsilun", "micsilum", "iscsoluna", "iscsilune", "iscspellogun", "techsevereun", "techsilun", "techsilan", "iscsilogun", "iscsieun", "ircsiluna", "iconsstatesune", "isksilung", "iscstatusund", "iscspelluno", "iscsentuch", "iscisoluno", "iscsqlun", "iscisologun", "iscsentogun", "iconsstatesund", "micsentuno", "iscinelume", "techsevereession", "iscisolum", "iconssilun", "iscSilession", "iscstatesund", "techsilund", "iscsinung", "iscstatusession", "iscsinon", "micsentogun", "iscinelune", "iscSilan", "iscsiluna", "ischematicon", "iscsilan", "isksqlung", "iscsentum", "iconsstatesume", "iscsiluch", "iscsqluch", "iscsolon", "techseverean", "ircsinrun", "ircsinuna", "iscisolun", "iscstatusan", "iconsstatesun", "iscsevereession", "iscsevereund", "ircsilrun", "iscsqlung", "iconssilune", "iscstatesun", "isksqlun", "iscstatusun", "iscspellum", "iscsinrun", "ircsilun", "iscinelun", "iscsinuna", "iscSilun", "iscsieune", "ischematicun", "iscsilession", "iscsilrun", "micsiluno", "iscinelund", "iscsilon", "techsevereund", "ircsinon", "iscsolrun", "iscsolun", "isksilun", "iscSilund", "ircsilon", "isksiluch", "micsentum", "iscspellun", "iscsieume", "iscsiluno", "iscsilume", "iscsilung", "isksqluch", "iscsieund", "iscsqlon", "micsilogun", "iscsentung", "iscsevereun", "techsilession", "micsentun", "iscsenton", "ischematicuna", "isksqlon", "iscsentuno", "iscstatesume", "iscsinuch", "iscsentun", "iconssilund", "iscsilum", "iscsilund"], "sector_num": ["sector_mu", "sectoripmon", "sector_n", "ector_num", "sector_span", "era_span", "sector_mult", "device_mult", "device_num", "sectoripmu", "era_Num", "ector_n", "sectoripnum", "sector_mon", "device_mon", "sector_nom", "ector_mon", "sectoripn", "era_num", "sector_Num", "device_nom", "sector_cal", "ector_mu", "era_cal"], "nb_sectors": ["nb_pselements", "nb_syonents", "nb_SEgments", "nb_speors", "nb_segments", "nb_syors", "nb_psectors", "nb_vegments", "nb_vectors", "nb_selements", "nb_SEctors", "nb_specs", "nb_veonents", "nb_seonents", "nb_sygments", "nb_secs", "nb_pseors", "nb_spectors", "nb_spelements", "nb_syctors", "nb_veors", "nb_SEors", "nb_vecs", "nb_SEonents", "nb_psecs", "nb_seors", "nb_velements"], "cluster_num": ["cluster____fac", "clusterIDnum", "cluster__index", "cluster_index", "clutter_index", "clorable_num", "clust_num", "cluster_NUM", "clutter__index", "clorable_NUM", "cluster____nom", "cluster__num", "cluster_div", "clusterAreanum", "clust_no", "clusterIDindex", "clusterArean", "cluster_fac", "clust_n", "clusterAreanu", "cluster____Num", "clutter__div", "clusterIDdiv", "cluster_nom", "cluster_nu", "clusterAreaNUM", "clutter_num", "cluster_n", "clutter__num", "cluster_no", "clust_nom", "clust_fac", "clutter_div", "clorable_n", "cluster__div", "clust_Num", "clorable_nu", "cluster_Num", "cluster____num"], "nb_clusters": ["nb_cluster", "nb_brikers", "nb_occusters", "nb_pluster", "nb_clocations", "nb_allocations", "nb_clows", "nb_plusters", "nb_allusters", "nb2clusters", "nb_occanches", "nb_clashes", "nb2clows", "nb2plores", "nb_brocations", "nb_chusters", "nb_sluster", "nb_slusters", "nb_clikers", "nb_occashes", "nb_cients", "nb_planches", "nb_allients", "nb_Clores", "nb_Clusters", "nb_brients", "nb_plows", "nb_clanches", "nb_brusters", "nb_Cluster", "nb_cikers", "nb2cluster", "nb_slores", "nb_occuster", "nb_custers", "nb_chanches", "nb_chuster", "nb_Clows", "nb2clores", "nb_plores", "nb_slows", "nb_cocations", "nb_clients", "nb2plusters", "nb_clores", "nb_chashes", "nb2pluster", "nb_allikers", "nb2plows", "nb_plashes"]}}
{"project": "qemu", "commit_id": "e511b4d783c47a32420da802104cfb0eb974b22f", "target": 0, "func": "int cpu_exec(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n#endif\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    uintptr_t next_tb;\n\n    SyncClocks sc;\n\n\n\n    /* This must be volatile so it is not trashed by longjmp() */\n\n    volatile bool have_tb_lock = false;\n\n\n\n    if (cpu->halted) {\n\n        if (!cpu_has_work(cpu)) {\n\n            return EXCP_HALTED;\n\n        }\n\n\n\n        cpu->halted = 0;\n\n    }\n\n\n\n    current_cpu = cpu;\n\n\n\n    /* As long as current_cpu is null, up to the assignment just above,\n\n     * requests by other threads to exit the execution loop are expected to\n\n     * be issued using the exit_request global. We must make sure that our\n\n     * evaluation of the global value is performed past the current_cpu\n\n     * value transition point, which requires a memory barrier as well as\n\n     * an instruction scheduling constraint on modern architectures.  */\n\n    smp_mb();\n\n\n\n    if (unlikely(exit_request)) {\n\n        cpu->exit_request = 1;\n\n    }\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n    cpu->exception_index = -1;\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (sigsetjmp(cpu->jmp_env, 0) == 0) {\n\n            /* if an exception is pending, we execute it here */\n\n            if (cpu->exception_index >= 0) {\n\n                if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = cpu->exception_index;\n\n                    if (ret == EXCP_DEBUG) {\n\n                        cpu_handle_debug_exception(env);\n\n                    }\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    cc->do_interrupt(cpu);\n\n#endif\n\n                    ret = cpu->exception_index;\n\n                    break;\n\n#else\n\n                    cc->do_interrupt(cpu);\n\n                    cpu->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = cpu->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(cpu->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~CPU_INTERRUPT_SSTEP_MASK;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        cpu->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        cpu->halted = 1;\n\n                        cpu->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                        cpu_svm_check_intercept_param(env, SVM_EXIT_INIT, 0);\n\n                        do_cpu_init(x86_cpu);\n\n                        cpu->exception_index = EXCP_HALTED;\n\n                        cpu_loop_exit(cpu);\n\n                    }\n\n#else\n\n                    if (interrupt_request & CPU_INTERRUPT_RESET) {\n\n                        cpu_reset(cpu);\n\n                    }\n\n#endif\n\n                    /* The target hook has 3 exit conditions:\n\n                       False when the interrupt isn't processed,\n\n                       True when it is, and we should restart on a new TB,\n\n                       and via longjmp via cpu_loop_exit.  */\n\n                    if (cc->cpu_exec_interrupt(cpu, interrupt_request)) {\n\n                        next_tb = 0;\n\n                    }\n\n                    /* Don't use the cached interrupt_request value,\n\n                       do_interrupt may have updated the EXITTB flag. */\n\n                    if (cpu->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        cpu->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(cpu->exit_request)) {\n\n                    cpu->exit_request = 0;\n\n                    cpu->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit(cpu);\n\n                }\n\n                spin_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = true;\n\n                tb = tb_find_fast(env);\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tcg_ctx.tb_ctx.tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tcg_ctx.tb_ctx.tb_invalidated_flag = 0;\n\n                }\n\n                if (qemu_loglevel_mask(CPU_LOG_EXEC)) {\n\n                    qemu_log(\"Trace %p [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));\n\n                }\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~TB_EXIT_MASK),\n\n                                next_tb & TB_EXIT_MASK, tb);\n\n                }\n\n                have_tb_lock = false;\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                cpu->current_tb = tb;\n\n                barrier();\n\n                if (likely(!cpu->exit_request)) {\n\n                    trace_exec_tb(tb, tb->pc);\n\n                    tc_ptr = tb->tc_ptr;\n\n                    /* execute the generated code */\n\n                    next_tb = cpu_tb_exec(cpu, tc_ptr);\n\n                    switch (next_tb & TB_EXIT_MASK) {\n\n                    case TB_EXIT_REQUESTED:\n\n                        /* Something asked us to stop executing\n\n                         * chained TBs; just continue round the main\n\n                         * loop. Whatever requested the exit will also\n\n                         * have set something else (eg exit_request or\n\n                         * interrupt_request) which we will handle\n\n                         * next time around the loop.\n\n                         */\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        next_tb = 0;\n\n                        break;\n\n                    case TB_EXIT_ICOUNT_EXPIRED:\n\n                    {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(next_tb & ~TB_EXIT_MASK);\n\n                        insns_left = cpu->icount_decr.u32;\n\n                        if (cpu->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            cpu->icount_extra += insns_left;\n\n                            if (cpu->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = cpu->icount_extra;\n\n                            }\n\n                            cpu->icount_extra -= insns_left;\n\n                            cpu->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(env, insns_left, tb);\n\n                                align_clocks(&sc, cpu);\n\n                            }\n\n                            cpu->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit(cpu);\n\n                        }\n\n                        break;\n\n                    }\n\n                    default:\n\n                        break;\n\n                    }\n\n                }\n\n                cpu->current_tb = NULL;\n\n                /* Try to align the host and virtual clocks\n\n                   if the guest is in advance */\n\n                align_clocks(&sc, cpu);\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        } else {\n\n            /* Reload env after longjmp - the compiler may have smashed all\n\n             * local variables as longjmp is marked 'noreturn'. */\n\n            cpu = current_cpu;\n\n            env = cpu->env_ptr;\n\n            cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n            x86_cpu = X86_CPU(cpu);\n\n#endif\n\n            if (have_tb_lock) {\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = false;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n    return ret;\n\n}\n", "idx": 23245, "substitutes": {"env": ["ctx", "dev", "vt", "viron", "v", "ve", "ev", "here", "conf", "eng", "vs", "conn", "vm", "environment", "init", "site", "er", "proc", "bean", "vp", "serv", "config", "enc", "ec", "node", "cmd", "org", "erc", "server", "net", "en", "et", "ew", "window", "con", "nv", "e", "context", "esp", "rc", "hw", "cap", "erd", "cb", "cv"], "cpu": ["pkg", "np", "pp", "name", "conn", "copy", "environment", "coin", "cum", "uu", "cs", "mac", "worker", "bench", "nu", "apache", "server", "phys", "pc", "ip", "client", "cam", "instance", "none", "rpm", "hw", "python", "docker", "cv", "ctx", "cp", "gc", "tp", "mx", "hz", "jp", "CPU", "util", "cache", "vm", "component", "race", "core", "bean", "ec", "pie", "frame", "en", "goal", "device", "socket", "cu", "local", "kernel", "clock", "reset", "num", "profile", " CPU", "program", "linux", "cn", "ka", "nc", "currency", "proc", "thread", "aux", "node", "network", "ck", "total", "window", "comp", "sys", "policy", "exec", "alloc", "pu", "stat", "pool", "ct", "bo", "physical", "ilo", "library", "pixel", "que", "gpu", "c", "processor", "computer", "cmd", "utils", "prof", "ruby", "cli", "php", "process", "mem", "nan", "cf", "runner", "cmp", "boot"], "cc": ["ctx", "cp", "ac", "gc", "ssl", "acc", "ci", "CC", "bc", "ctrl", "xc", "tc", "icc", "nc", "mc", "css", "conn", "cache", "cl", "co", "c", "cs", "fc", "lc", "ec", "uc", "func", "pc", "cci", "dc", "ck", "cv", "ucc", "cu", "cf", "cb", "cmp", "cell", "ctl", "rc", "ct"], "x86_cpu": ["x86_cp", "x85_pu", "x85_cp", "x85_comp", "x86_comp", "x86_pu", "x85_cpu"], "ret": ["reset", "success", "ert", "alt", "ter", "tr", "Ret", "vet", "def", "url", "rem", "status", "inter", "result", " Ret", "rt", "nt", "flag", "t", "ft", "det", "res", "net", " RET", "cat", "rev", "std", "re", "ref", "resp", "hash", "len", "eth", "ll", "arg", "out", "rets", "mem", "gt", "nz", "sys", "str", "err", "elt", "rm", "RET", "prot", "back", "mt", "cont", "val"], "interrupt_request": ["interrupt_Request", "interrupted_required", "interruptablerequest", "interrupt_index", "interruptTherequest", "interruptableRequest", "interrupt__index", "interrupt2response", "interrupt___match", "intercept___mask", "interrupt2request", "interruptationquery", "interrupt_event", "interrupterrequest", "interpress_req", "interruptablepair", "interruptablereq", "interrupt_flag", "interrupt_query", "intercept_flag", "interrupted_request", "intercept___match", "interruption_type", "interpress_request", "interruptederpair", "interrupt_required", "intercept___flag", "intercept_match", "interrupt___req", "interruptingreq", "intercept___request", "interrupt___Request", "interruption_response", "interruption2request", "interrupt_question", "interruptationresponse", "intercept_mask", "interruptingevent", "interrupt___flag", "interrupt_type", "interrupt__response", "interruption_query", "interruption_index", "interrupt___request", "interrupt_pair", "interrupterrequired", "interruption__index", "interrupt_complete", "interrupt__question", "interrupted_pair", "interrupt_mask", "interruption2response", "interrupt2type", "interruptablecomplete", "interrupt___mask", "interruptThemask", "interruption_question", "interrupt__request", "interruption__request", "intercept_request", "interruptederrequired", "interruptationrequest", "interruptingrequest", "interrupt_req", "interrupt___complete", "interruption2type", "interruption2query", "interruption__question", "interruption_request", "interrupt2query", "interrupt_response", "interruption__response", "interruptederrequest", "interrupt_match", "interruptThematch", "interruptationtype", "interrupterpair", "interruptablerequired", "interruptTheflag", "interpress_event"], "tb": ["ptt", "ptbar", "rtt", "tbar", "rtbe", " tbe", "ptbe", " tbar", "ptb", "rtbar", " tt", "tt", "tbe", "rtb"], "tc_ptr": ["TC_addr", "tc__ptr", "tc__pointer", "TC_ptr", "tc_addr", "tc__addr", "tc_tr", "TC__addr", "TC__tr", "tc__tr", "TC__ptr", "TC_pointer", "TC__pointer", "tc_pointer", "TC_tr"], "next_tb": ["next2tbe", "next_mbr", "next2mbe", "next_tbl", "next_tbe", "next_outbr", "next_cbl", "next_mb", "next_cbr", "next_lbr", "next_outbe", "next2tbr", "next2mbl", "next_outbl", "next_mbl", "next_tsb", "next2mb", "next_tbr", "next_lbe", "next_lb", "next2tbl", "next_tsbr", "next_cbe", "next_mbe", "next2mbr", "next_tsbe", "next_tsbl", "next_outb", "next_cb", "next_lbl", "next2tb"], "sc": ["ctx", "gc", "sq", "sp", "isc", "bc", "Sc", "esc", "sb", " ss", "tc", "mc", "cl", "scl", " esc", "sh", "c", "cs", "sync", "fc", "SC", "lc", "sw", " ec", "ss", "ec", "uc", "pc", "sch", "dc", "pb", "ch", "sv", "osc", "sys", "cmp", "sd", "rc", "ct"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247, "substitutes": {"str": ["rest", "Str", "spec", "list", "vc", "sp", "input", "seq", "pr", "tr", "name", "length", "ptr", "service", "br", "fr", "ext", "expr", "chain", "text", "prefix", "vol", "s", "c", "cs", "gr", "r", "enc", "i", "dr", "pos", "t", "STR", "buffer", "msg", "ns", "txt", "cur", "window", "buf", "len", "out", "source", "ctr", "arr", "sys", "stri", "index", "new", "err", "bsp", "st"], "endptr": ["Endptr", "estaddr", "endedpt", "ENDptr", "estpointer", "Endpointer", "ndptr", "ndpointer", "ENDaddr", " endpt", "ENDPtr", "endPtr", "endpointer", "EndPtr", "endedaddr", "estpt", " endPtr", "endedptr", "ndproc", "Endaddr", "endaddr", "endproc", "endedproc", "estptr", "endpt", " endpointer", " endproc", "endedpointer", "ENDpointer", " endaddr"], "res": ["js", "rest", "p", "rs", "pr", "RS", "des", "ps", "resolution", "ires", "red", "rem", "status", "result", "ret", "ser", "RES", "ms", "vol", "cs", "gr", "r", "ts", "i", "results", "reg", "rez", "rev", "sim", "re", "resp", "cons", "Res", "obj", "ress", "resh", "ber", "os", "err", " result", "pres", "vals", "rel", "pers", "rc"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 23250, "substitutes": {"ysrc": ["ysource", "myssrc", "iesr", "nsusc", "iesrc", "esource", "ysr", "ysusc", "sysrc", "iesusc", "sysr", "mysusc", "iessrc", "iesource", "mysrc", "sysusc", "nssrc", "esrc", "nsr", "syssrc", "essrc", "esusc", "mysource", "nsrc", "yssrc"], "usrc": [" usurg", "usource", "usesource", "umsirc", "ussrc", "umsurg", "Ussrc", "usessrc", "Usrc", "usurg", " ussrc", "umsrc", "osirc", " usource", "osurg", "usirc", " usirc", "Usource", "usesrc", "ossrc", "umssrc", "osrc"], "vsrc": ["fstr", "vstr", " vst", "wrs", "pst", " vsource", "fsrc", "wsrc", "vrc", "src", "frc", "vrs", " vrc", "wrc", "psrc", "prc", "fst", "srs", "ssrc", "vsource", "ssource", " vrs", "wsource", "vst", " vstr", "pstr"], "dst": ["diddest", "dnd", "vdest", "drest", "fdest", "dsnd", " dput", "ftt", "lst", "didnd", "dsst", "lrest", "dput", "dstt", "ldest", "vrest", "fst", "didtt", "vput", " ddest", "dsdest", "ddest", "dtt", "didst", "fnd", "vst", " drest", "lput"], "height": ["Height", "stroke", "ty", "volume", "wh", "hi", "ows", "family", "zh", "hz", "depth", "radius", " heights", "HH", "length", "ih", "w", "headers", "resolution", "y", "dist", "ht", "inches", "gravity", "history", "hei", "he", "yt", "html", "density", "gh", "uh", "build", "shape", "rows", "size", "count", "window", "hang", "h", "cy", "dim", "th", "gy"], "lumStride": ["limStr", "lumStrr", "limStrr", "lomStride", "lumstr", "lumStr", "limStrate", "lumSTride", "lumstrate", "lumSTide", "lomStrride", "lomStr", "lumLrid", "lumstide", "lomStrid", "lumstride", "lumLide", "lumSTr", "lumSTrate", "limStide", "lumLride", "lumStrid", "lumstrid", "lumStrate", "lumStrrate", "lumStrride", "lumLr", "lomStide", "lomStrrid", "limStrride", "lumStide", "limStrrate", "lomStrr", "limStride", "lumStrrid"], "chromStride": ["chromSTrid", "romStrrid", "chromSlride", "chromSlide", "romStr", "chromStrange", "chromStrr", "chromSTride", "chromSpide", "chromstride", "romStride", "romStrange", "chromStrid", "chromSlrid", "chromstide", "chromStr", "romStrid", "chromSTrange", "chromSpr", "chromStrride", "romStrr", "romStrride", "chromStrrange", "chromSpride", "romStide", "romStrrip", "chromStide", "chromStrrid", "chromStrrip", "chromStrip", "chromstr", "chromstrip", "chromSprip", "romStrrange", "romStrip", "chromSlrange", "chromSTide"], "dstStride": ["destStrr", "destStrip", "dststride", "dndStrride", "dstStno", "dststno", "dndStrr", "dndStno", "dstStrr", "dstStr", "dstRestr", "dstStide", "dstStrip", "dndStide", "dststide", "dndStride", "destStride", "dstRestno", "destStrride", "destStrrip", "dstStrride", "dndStr", "dndStrno", "dstStrno", "dstStrrip", "dststrip", "destStr", "dstRestide", "dstRestride", "dstRestrip", "dststr", "destStide"]}}
{"project": "FFmpeg", "commit_id": "b7d9b4a1f1fcd01084ccbec6f7ef32c853681833", "target": 1, "func": "int ff_h263_decode_mb(MpegEncContext *s,\n                      int16_t block[6][64])\n{\n    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;\n    int16_t *mot_val;\n    const int xy= s->mb_x + s->mb_y * s->mb_stride;\n    int cbpb = 0, pb_mv_count = 0;\n    av_assert2(!s->h263_pred);\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n        do{\n            if (get_bits1(&s->gb)) {\n                /* skip mb */\n                s->mb_intra = 0;\n                for(i=0;i<6;i++)\n                    s->block_last_index[i] = -1;\n                s->mv_dir = MV_DIR_FORWARD;\n                s->mv_type = MV_TYPE_16X16;\n                s->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;\n                s->mv[0][0][0] = 0;\n                s->mv[0][0][1] = 0;\n                s->mb_skipped = !(s->obmc | s->loop_filter);\n                goto end;\n            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 20);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 8;\n        s->mb_intra = ((cbpc & 4) != 0);\n        if (s->mb_intra) goto intra;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n            cbpy ^= 0xF;\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        s->mv_dir = MV_DIR_FORWARD;\n        if ((cbpc & 16) == 0) {\n            s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n            /* 16x16 motion prediction */\n            s->mv_type = MV_TYPE_16X16;\n            ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n            if (s->umvplus)\n               mx = h263p_decode_umotion(s, pred_x);\n            else\n               mx = ff_h263_decode_motion(s, pred_x, 1);\n            if (mx >= 0xffff)\n            if (s->umvplus)\n               my = h263p_decode_umotion(s, pred_y);\n            else\n               my = ff_h263_decode_motion(s, pred_y, 1);\n            if (my >= 0xffff)\n            s->mv[0][0][0] = mx;\n            s->mv[0][0][1] = my;\n            if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n               skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n        } else {\n            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;\n            s->mv_type = MV_TYPE_8X8;\n            for(i=0;i<4;i++) {\n                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                s->mv[0][i][0] = mx;\n                s->mv[0][i][1] = my;\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                  skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                mot_val[0] = mx;\n                mot_val[1] = my;\n    } else if(s->pict_type==AV_PICTURE_TYPE_B) {\n        int mb_type;\n        const int stride= s->b8_stride;\n        int16_t *mot_val0 = s->current_picture.motion_val[0][2 * (s->mb_x + s->mb_y * stride)];\n        int16_t *mot_val1 = s->current_picture.motion_val[1][2 * (s->mb_x + s->mb_y * stride)];\n//        const int mv_xy= s->mb_x + 1 + s->mb_y * s->mb_stride;\n        //FIXME ugly\n        mot_val0[0       ]= mot_val0[2       ]= mot_val0[0+2*stride]= mot_val0[2+2*stride]=\n        mot_val0[1       ]= mot_val0[3       ]= mot_val0[1+2*stride]= mot_val0[3+2*stride]=\n        mot_val1[0       ]= mot_val1[2       ]= mot_val1[0+2*stride]= mot_val1[2+2*stride]=\n        mot_val1[1       ]= mot_val1[3       ]= mot_val1[1+2*stride]= mot_val1[3+2*stride]= 0;\n        do{\n            mb_type= get_vlc2(&s->gb, h263_mbtype_b_vlc.table, H263_MBTYPE_B_VLC_BITS, 2);\n            if (mb_type < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b mb_type damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            mb_type= h263_mb_type_b_map[ mb_type ];\n        }while(!mb_type);\n        s->mb_intra = IS_INTRA(mb_type);\n        if(HAS_CBP(mb_type)){\n            s->bdsp.clear_blocks(s->block[0]);\n            cbpc = get_vlc2(&s->gb, cbpc_b_vlc.table, CBPC_B_VLC_BITS, 1);\n            if(s->mb_intra){\n                dquant = IS_QUANT(mb_type);\n                goto intra;\n            cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n            if (cbpy < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n                cbpy ^= 0xF;\n            cbp = (cbpc & 3) | (cbpy << 2);\n        }else\n            cbp=0;\n        av_assert2(!s->mb_intra);\n        if(IS_QUANT(mb_type)){\n            h263_decode_dquant(s);\n        if(IS_DIRECT(mb_type)){\n            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;\n            mb_type |= set_direct_mv(s);\n        }else{\n            s->mv_dir = 0;\n            s->mv_type= MV_TYPE_16X16;\n//FIXME UMV\n            if(USES_LIST(mb_type, 0)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                s->mv_dir = MV_DIR_FORWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n            if(USES_LIST(mb_type, 1)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 1, &pred_x, &pred_y);\n                s->mv_dir |= MV_DIR_BACKWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[1][0][0] = mx;\n                s->mv[1][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n        s->current_picture.mb_type[xy] = mb_type;\n    } else { /* I-Frame */\n        do{\n            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"I cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 8);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 4;\n        s->mb_intra = 1;\nintra:\n        s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n        if (s->h263_aic) {\n            s->ac_pred = get_bits1(&s->gb);\n            if(s->ac_pred){\n                s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;\n                s->h263_aic_dir = get_bits1(&s->gb);\n        }else\n            s->ac_pred = 0;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(cbpy<0){\n            av_log(s->avctx, AV_LOG_ERROR, \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        pb_mv_count += !!s->pb_frame;\n    while(pb_mv_count--){\n        ff_h263_decode_motion(s, 0, 1);\n        ff_h263_decode_motion(s, 0, 1);\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (h263_decode_block(s, block[i], i, cbp&32) < 0)\n            return -1;\n        cbp+=cbp;\n    if(s->pb_frame && h263_skip_b_part(s, cbpb) < 0)\n        return -1;\n    if(s->obmc && !s->mb_intra){\n        if(s->pict_type == AV_PICTURE_TYPE_P && s->mb_x+1<s->mb_width && s->mb_num_left != 1)\n            preview_obmc(s);\nend:\n        /* per-MB end of slice check */\n    {\n        int v= show_bits(&s->gb, 16);\n        if (get_bits_left(&s->gb) < 16) {\n            v >>= 16 - get_bits_left(&s->gb);\n        if(v==0)\n            return SLICE_END;\n    return SLICE_OK;", "idx": 23256, "substitutes": {"s": ["south", "comments", "rs", "bs", "events", "ants", "gets", "fs", "ims", "test", "settings", "cs", "stats", "set", "ins", "its", "store", "a", "sam", "os", "words", "ls", "es", "views", "vs", "ps", "ds", "self", "ts", "serv", "less", "ags", "ports", "se", "save", "is", "v", "js", "gs", "sets", "tes", "ows", "parts", "bis", "eps", "states", "status", "ms", "an", "ses", "ss", "results", "aws", "news", "re", "ions", "ers", "hs", "services", "ears", "sts", "sys", "ats", "stat", "pers", "sports", "comm", "orders", "spec", "p", "sq", "details", "w", "sb", "n", "has", "c", "as", "sw", "t", "ns", "changes", "sv", "qs", "h", "sg", "S", "als", "ops"], "block": ["check", "pack", "profile", "type", "word", "image", "bin", "pixel", "box", "band", "field", "value", "blocks", "bit", "chain", "line", "lock", "raw", "config", "flag", "img", "point", "map", " frame", "pipe", "frame", "buffer", "key", "ref", "link", "window", "channel", "out", "code", "obj", "row", "base", "byte", "record", "Block", "arr", " bl", "object", "label", "icon"], "cbpc": ["sbpc", "cbcp", "nbproc", "ebpr", "cbpr", "cbpic", "cvcp", "fbpc", "nbfc", "erbpn", "rbpc", "rbproc", "sbproc", "bcpc", "erbcc", "cvpx", "cvcc", "cvproc", "cbpn", "nbbc", "cbfc", "bccp", "erbcp", "bcpr", "fbcp", "nbcp", "erbpc", "rbcp", "nbcc", "ebcp", "ebpc", "bcpn", "nbpc", "cvfc", "erbfc", "fbpic", "erbproc", "sbfc", "cbpx", "erbpr", "cbproc", "rbpic", "erbpx", "rbbc", "cvpic", "ebpn", "cvpc", "fbfc", "sbbc", "rbpx", "cbcc", "rbcc", "rbfc", "cbbc"], "cbpy": ["erbpm", "erbpr", "cbpo", "erbpo", "cvpm", "rbpo", "cbpr", "cvpr", "cbpm", "rbpy", "cvpy", "rbpm", "erbpy", "cvpo", "rbpr"], "i": ["hi", "m", "me", "ci", "ix", "p", "id", "si", "multi", "zi", "span", "ei", "n", "y", "it", "xi", "ij", "status", "init", "l", "ti", "mi", "gu", "qi", "iu", "info", "j", "di", "in", "ir", "go", "ai", "g", "fi", "gi", "phi", "ic", "li", "ui", "ip", "sim", "cli", "is", "ji", "ini", "bi", "ind", "oi", "index", "ii", "x", "pi", "I", "ia", "f", "ki", "im"], "cbp": ["pbf", "cbf", "cvp", "gbf", "cvf", "gbpy", "pbpc", "cvpc", "gbp", "cvpy", "gbpc", "pbp", "pbpy"], "pred_x": ["pred00ex", " pred_ex", " pred00xi", " pred_xi", " pred00x", "pred__xi", "pred__ex", "pred00xi", "pred__y", "pred_ex", "pred__x", "pred00x", "pred_xi", " pred00ex", " pred00y", "pred00y"], "pred_y": ["ref_y", "ref_cy", "pred_cy", "ref_py", "ref_x", "pred_py"], "mx": ["xp", "ox", "tp", "mm", "mr", "mk", "yx", "mn", "xc", "mic", "mu", "vm", "mc", "tm", "mp", "mi", "ms", "mac", "tx", "zx", "dm", "ma", "ml", "xs", "wx", "px", "mt", "fx"], "my": ["ty", "ky", "mm", "yx", "fy", "mn", "gm", "nm", "ym", "mys", "yo", "py", "mc", "mi", "ny", "ms", "sym", "ys", "yy", "md", "ml", "sys", "cy", "mid", "mon", "mt", "gy"], "dquant": ["DQuant", "Dquant", "domquant", " dint", "domqu", "jquant", "dint", "dQuant", " dQuant", "dqu", "jvalid", " dvalid", "jint", "domQuant", "lqu", "limp", "domimp", "dvalid", "lQuant", "jQuant", "dimp", "lquant", "Dvalid", "Dint", " dimp", " dqu"], "mot_val": ["ref2val", "mot_Val", "mot2val", "motvcal", "mot2value", "mot_value", "ref2Val", "ref2cal", "ref_val", "motvVal", "ref2value", "mot_cal", "ref_value", "ref_Val", "motvvalue", "motvval", "ref_cal", "mot2Val", "mot2cal"], "mb_type": ["emb_index", "emb_tag", "emb_size", "mb_size", "mb_tag", "mb_index", "emb_type"], "pb_mv_count": ["pb_mV_index", "pb_mv__found", "pb_mx2found", "pb_mv2found", "pb_mv2counter", "pb_mx_counter", "pb_mvxfound", "pb_mv_index", "pb_mv2Count", "pb_mvxsum", "pb_mv__counter", "pb_mV2index", "pb_mx2count", "pb_mV_found", "pb_mv2index", "pb_mV2sum", "pb_mv_Count", "pb_mvxcount", "pb_mv_counter", "pb_mvxindex", "pb_mV_count", "pb_mx2counter", "pb_mV2found", "pb_mv__count", "pb_mV2count", "pb_mv_found", "pb_mx_count", "pb_mx_found", "pb_mV_sum", "pb_mv2sum", "pb_mx2Count", "pb_mv__Count", "pb_mv_sum", "pb_mx_Count", "pb_mv2count"]}}
{"project": "FFmpeg", "commit_id": "92fabca427ff2d8fffa4bd4f09839d8d3822ef31", "target": 0, "func": "static void DEF(put, pixels16_x2)(uint8_t *block, const uint8_t *pixels, ptrdiff_t line_size, int h)\n\n{\n\n    MOVQ_BFE(mm6);\n\n    __asm__ volatile(\n\n        \"lea        (%3, %3), %%\"REG_a\" \\n\\t\"\n\n        \".p2align 3                     \\n\\t\"\n\n        \"1:                             \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"subl   $4, %0                  \\n\\t\"\n\n        \"jnz    1b                      \\n\\t\"\n\n        :\"+g\"(h), \"+S\"(pixels), \"+D\"(block)\n\n        :\"r\"((x86_reg)line_size)\n\n        :REG_a, \"memory\");\n\n}\n", "idx": 23259, "substitutes": {"block": ["cp", "volume", "pack", "mm", "p", "name", "type", "word", "image", "length", "field", "blocks", "cl", "bit", "chain", "line", "lock", "proc", "header", "board", "map", "size", "frame", "buffer", "pc", "ck", "ip", "pen", "device", "hash", "PC", "row", "byte", "mem", "Block", "view", "mask", "object", "label", "kl"], "pixels": ["piles", "spiles", "ipiles", " piles", "apix", "pixel", "Pix", " pixel", " pix", "apixels", "Piles", "ipix", "apixel", "pix", "Pixels", "Pixel", "ipixel", "spixel", "apiles", "spix", "ipixels", "spixels"], "line_size": ["line_count", "line1size", "Line_length", "line_length", "block_count", "line_SIZE", "Line_ize", "line_scale", "Line_size", "line1scale", "line_ize", "block_scale", "block_size", "Line_SIZE", "line1count"], "h": ["kh", "height", "m", "end", "p", " H", "hold", "oh", "hidden", "ih", "w", "d", "ptr", "y", "it", "ht", "history", "c", "he", "header", " inh", "uh", "t", "bh", "H", "k", "hash", "head", "handle", "hs", "hl", "oid", "th", "f", "help", "v"]}}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n", "idx": 23274, "substitutes": {"idstr": ["keyStr", "vidchar", " iddr", "pidSTR", "pidp", "pidfr", " idst", "pidstring", "idbr", "vidstr", "pidstr", "keyfr", "idstring", "sidbr", "ridstr", "hbr", "ridbr", "hstr", "pidst", "oidstr", "cmdstring", "keystr", " idp", " idbr", "oidStr", "ridSTR", "pidStr", "cmdfr", "refstring", "cmdstr", "cmdSTR", "hstring", "idStr", "oidst", "refp", "sidSTR", " idstring", "hchar", "refdr", "pidchar", "keystring", "keySTR", " idSTR", "pidbr", "idp", "oidstring", "piddr", "refstr", "sidstr", "vidbr", " idfr", "idst", "ridst", " idStr", "idSTR", "iddr", "idchar", "sidst", "idfr", "vidstring"], "instance_id": ["instance__url", "instanceitydata", "instance__n", "node_url", "ance_n", "instancelemain", "instance_state", "instance8info", "ances8source", "instance_Id", "ances8id", "instance__ID", "instance_data", "instance_pid", "ance_ids", "commanditystate", "instance_ID", "instance_n", "instance__ids", "ances_id", "ances_source", "ance_info", "instanceityname", "instanceleid", "node_pid", "instance8ad", "instance_ide", "ance_pid", "instance_oid", "instance_info", "ances8ad", "instance__pid", " instance_main", "commandityoid", "commandityid", "Instance_Id", "node_oid", "ance_ID", "instanceitystate", "instanceNamead", "ances_ad", " instance_Id", "instance8id", "command_oid", "instance_ad", "Instance_id", "instance__oid", "ances_info", "Instance_ids", "instance_source", " instance_ID", "instance__id", " instance_data", "instanceitymain", "instance8source", "ances8info", "instance_main", "ance_Id", "instanceledata", "instance_name", "ance_id", "instance_url", " instance_name", "instanceityid", "instanceityoid", "instance__Id", "instanceNameid", " instance_str", " instance_pid", "instanceNameinfo", "command_id", "instance__info", "node_id", "instancelename", "command_state", "Instance_ide", "instance_ids", "instance_str", "instanceNamesource"], "version_id": ["versionabledb", "version___id", "version_name", "versiondbid", "versioningname", "section_with", "section_db", "version_with", "version_info", "version_dir", "mission_info", "sequence_name", "version___with", "versioningdir", "version_Id", "versioningid", "versionaldir", "version_db", "sequence_id", "versionalname", "sequence_str", "section_no", "missiondbId", "versiondbinfo", "versiondbId", "versionableno", "missiondbstate", "missiondbid", "versionalstr", "versionableid", "versiondbstate", "mission_Id", "section_id", "sequence_dir", "mission_state", "versionalid", "mission_id", "version_no", "missiondbinfo", "versionablewith", "versioningstr", "version___no", "version_str", "version_state", "version___db"], "save_state": ["saveiststate", "save_event", "save_stat", "savealstate", "savelyevent", "copylyevent", "saveopstate", "savelyinit", "signlyinit", "sign_scope", "savealfunction", "save___stat", "save_policy", "saveopstat", "sign_point", "savealstates", "savelyscope", "save_states", "savelyfunction", "saveistpoint", "signlypoint", "load_policy", "copy_event", "saveoppolicy", "save_scope", "save_init", "sign_state", "copylyfunction", "save_function", "saveophistory", "savelystate", "saveistinit", "copy_function", "save___policy", "signlyscope", "signlystate", "save_point", "save___history", "copylystates", "load_history", "savealevent", "sign_init", "savelypoint", "copy_state", "load_stat", "copy_states", "save_history", "save___state", "saveistscope", "savelystates", "copylystate"], "load_state": ["load_storage", "checkfulpolicy", " load_private", "loadingtype", "load_data", "loadlypolicy", " load_type", "loadtstate", "loadfulinfo", "check_info", "load_type", "loadingpolicy", "loadfulstate", "load_lock", "checkfulspace", " load_lock", "loadlyprivate", "check_space", "check_state", "load_policy", "check_policy", " load_data", "loadportstate", " load_policy", "loadingstate", "load_info", "loadtlock", "loadlystate", "loadportdata", "checkfulinfo", "loadportstorage", "load_space", "loadlytype", "loadfulspace", "loadfulpolicy", "loadportlock", "checkfulstate", "loadtdata", "loadingprivate", "loadtstorage", " load_storage", "load_private"], "opaque": ["opaques", "Opaque", "paques", "opacity", "patile", "ipaques", "ipity", " opacity", "oppacity", "ipacity", "Opascript", "opsolete", "opity", "oppaques", "Opacity", "ipsolete", "paque", "operaque", " opascript", "operity", "pacity", "ipatile", "pity", "ipascript", " opsolete", "oppatile", "opatile", "opascript", "ipaque", "Opsolete", "operaques", "operatile", "oppaque"], "se": ["so", "sp", "ve", "sel", "pe", "isse", "sa", "ae", "Se", "sed", "server", "set", "sche", "de", "ge", "store", "ade", "sec", "ode", "sle", "ke", "cle", "es", "ide", "parse", "SE", "esse", "are", "we", "ser", "ene", "ess", "ense", "see", "sem", "ele", "me", "ree", "ape", "sl", "te", "ice", "sea", "ede", "si", "ace", "des", "ane", "lex", "send", "ses", "ese", "ine", "al", "session", "el", "ase", "th", "le", "ose", "entry", "su", "sb", "spe", "sh", "ce", "ie", "est", "e", "sv", "she", "sd", "ne", "ze"], "pse": ["sp", "ve", "pe", "press", "sa", "ae", "reme", "pt", "phys", "pa", "pri", "ge", "alse", "ress", "pic", "trace", "cp", "ffe", "der", "tp", "esi", "jp", "parse", "gre", "isi", "paste", "bes", "proxy", "bp", "ps", "mp", "pret", "pipe", "pol", "gp", "ppe", "pas", "ele", "me", "te", "ja", "seq", "req", "pm", "pex", "ptr", "ace", "ph", "fr", "py", "proc", "lex", "PE", "perse", "po", "pose", "next", "ase", "ste", "pres", "p", "ose", "pr", "meet", "phe", "expr", "peg", "spe", "PS", "pty", "prof", "spr", "prime", "asi", "ne"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277, "substitutes": {"klass": [" klasses", " kls", "kklasses", "skclass", "sklass", " kube", "iklass", "ikcl", "Klasses", "kls", "ikclass", "Kube", "ikls", "kklass", " kclass", "kkls", "kkube", " kcl", "skls", "Kls", "klasses", "kclass", "skcl", "kube", "Klass", "kcl"], "data": ["json", "dat", "state", "name", "id", "bin", "w", "d", "rew", "def", "mu", "module", " sd", "value", " Data", "init", " DATA", "result", "attr", "di", "da", "res", "key", "DATA", "ata", "new", "Data"], "dc": ["ac", "cp", "gc", "cr", "design", "oc", "ca", "adr", "bc", "ga", "d", "DC", "tc", "nc", "cm", "mc", "disc", "cc", "sc", "iac", "currency", "c", "fc", "mac", "lc", "nic", "di", "ec", "cmd", "erc", "dr", "uc", "ct", "da", "dm", "cd", "pc", "cci", "dd", "dp", "ip", "controller", "desc", "cat", "cca", "cu", "comp", "cf", "draw", "df"]}}
{"project": "FFmpeg", "commit_id": "042ef4b720f5d3321d9b7eeeb2067c671d5aeefd", "target": 1, "func": "static int decode_mb_cavlc(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;\n\n    int partition_count;\n\n    unsigned int mb_type, cbp;\n\n    int dct8x8_allowed= h->pps.transform_8x8_mode;\n\n\n\n    s->dsp.clear_blocks(h->mb); //FIXME avoid if already clear (move after skip handlong?\n\n\n\n    tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, s->mb_x, s->mb_y);\n\n    cbp = 0; /* avoid warning. FIXME: find a solution without slowing\n\n                down the code */\n\n    if(h->slice_type != I_TYPE && h->slice_type != SI_TYPE){\n\n        if(s->mb_skip_run==-1)\n\n            s->mb_skip_run= get_ue_golomb(&s->gb);\n\n\n\n        if (s->mb_skip_run--) {\n\n            if(FRAME_MBAFF && (s->mb_y&1) == 0){\n\n                if(s->mb_skip_run==0)\n\n                    h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n                else\n\n                    predict_field_decoding_flag(h);\n\n            }\n\n            decode_mb_skip(h);\n\n            return 0;\n\n        }\n\n    }\n\n    if(FRAME_MBAFF){\n\n        if( (s->mb_y&1) == 0 )\n\n            h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);\n\n    }else\n\n        h->mb_field_decoding_flag= (s->picture_structure!=PICT_FRAME);\n\n\n\n    h->prev_mb_skipped= 0;\n\n\n\n    mb_type= get_ue_golomb(&s->gb);\n\n    if(h->slice_type == B_TYPE){\n\n        if(mb_type < 23){\n\n            partition_count= b_mb_type_info[mb_type].partition_count;\n\n            mb_type=         b_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 23;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else if(h->slice_type == P_TYPE /*|| h->slice_type == SP_TYPE */){\n\n        if(mb_type < 5){\n\n            partition_count= p_mb_type_info[mb_type].partition_count;\n\n            mb_type=         p_mb_type_info[mb_type].type;\n\n        }else{\n\n            mb_type -= 5;\n\n            goto decode_intra_mb;\n\n        }\n\n    }else{\n\n       assert(h->slice_type == I_TYPE);\n\ndecode_intra_mb:\n\n        if(mb_type > 25){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"mb_type %d in %c slice too large at %d %d\\n\", mb_type, av_get_pict_type_char(h->slice_type), s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n        partition_count=0;\n\n        cbp= i_mb_type_info[mb_type].cbp;\n\n        h->intra16x16_pred_mode= i_mb_type_info[mb_type].pred_mode;\n\n        mb_type= i_mb_type_info[mb_type].type;\n\n    }\n\n\n\n    if(MB_FIELD)\n\n        mb_type |= MB_TYPE_INTERLACED;\n\n\n\n    h->slice_table[ mb_xy ]= h->slice_num;\n\n\n\n    if(IS_INTRA_PCM(mb_type)){\n\n        unsigned int x, y;\n\n\n\n        // We assume these blocks are very rare so we do not optimize it.\n\n        align_get_bits(&s->gb);\n\n\n\n        // The pixels are stored in the same order as levels in h->mb array.\n\n        for(y=0; y<16; y++){\n\n            const int index= 4*(y&3) + 32*((y>>2)&1) + 128*(y>>3);\n\n            for(x=0; x<16; x++){\n\n                tprintf(s->avctx, \"LUMA ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*((x>>2)&1) + 64*(x>>3)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA U ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n        for(y=0; y<8; y++){\n\n            const int index= 256 + 64 + 4*(y&3) + 32*(y>>2);\n\n            for(x=0; x<8; x++){\n\n                tprintf(s->avctx, \"CHROMA V ICPM LEVEL (%3d)\\n\", show_bits(&s->gb, 8));\n\n                h->mb[index + (x&3) + 16*(x>>2)]= get_bits(&s->gb, 8);\n\n            }\n\n        }\n\n\n\n        // In deblocking, the quantizer is 0\n\n        s->current_picture.qscale_table[mb_xy]= 0;\n\n        h->chroma_qp = get_chroma_qp(h->pps.chroma_qp_index_offset, 0);\n\n        // All coeffs are present\n\n        memset(h->non_zero_count[mb_xy], 16, 16);\n\n\n\n        s->current_picture.mb_type[mb_xy]= mb_type;\n\n        return 0;\n\n    }\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] <<= 1;\n\n        h->ref_count[1] <<= 1;\n\n    }\n\n\n\n    fill_caches(h, mb_type, 0);\n\n\n\n    //mb_pred\n\n    if(IS_INTRA(mb_type)){\n\n            int pred_mode;\n\n//            init_top_left_availability(h);\n\n            if(IS_INTRA4x4(mb_type)){\n\n                int i;\n\n                int di = 1;\n\n                if(dct8x8_allowed && get_bits1(&s->gb)){\n\n                    mb_type |= MB_TYPE_8x8DCT;\n\n                    di = 4;\n\n                }\n\n\n\n//                fill_intra4x4_pred_table(h);\n\n                for(i=0; i<16; i+=di){\n\n                    int mode= pred_intra_mode(h, i);\n\n\n\n                    if(!get_bits1(&s->gb)){\n\n                        const int rem_mode= get_bits(&s->gb, 3);\n\n                        mode = rem_mode + (rem_mode >= mode);\n\n                    }\n\n\n\n                    if(di==4)\n\n                        fill_rectangle( &h->intra4x4_pred_mode_cache[ scan8[i] ], 2, 2, 8, mode, 1 );\n\n                    else\n\n                        h->intra4x4_pred_mode_cache[ scan8[i] ] = mode;\n\n                }\n\n                write_back_intra_pred_mode(h);\n\n                if( check_intra4x4_pred_mode(h) < 0)\n\n                    return -1;\n\n            }else{\n\n                h->intra16x16_pred_mode= check_intra_pred_mode(h, h->intra16x16_pred_mode);\n\n                if(h->intra16x16_pred_mode < 0)\n\n                    return -1;\n\n            }\n\n\n\n            pred_mode= check_intra_pred_mode(h, get_ue_golomb(&s->gb));\n\n            if(pred_mode < 0)\n\n                return -1;\n\n            h->chroma_pred_mode= pred_mode;\n\n    }else if(partition_count==4){\n\n        int i, j, sub_partition_count[4], list, ref[2][4];\n\n\n\n        if(h->slice_type == B_TYPE){\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=13){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"B sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= b_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      b_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n            if(   IS_DIRECT(h->sub_mb_type[0]) || IS_DIRECT(h->sub_mb_type[1])\n\n               || IS_DIRECT(h->sub_mb_type[2]) || IS_DIRECT(h->sub_mb_type[3])) {\n\n                pred_direct_motion(h, &mb_type);\n\n                h->ref_cache[0][scan8[4]] =\n\n                h->ref_cache[1][scan8[4]] =\n\n                h->ref_cache[0][scan8[12]] =\n\n                h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;\n\n            }\n\n        }else{\n\n            assert(h->slice_type == P_TYPE || h->slice_type == SP_TYPE); //FIXME SP correct ?\n\n            for(i=0; i<4; i++){\n\n                h->sub_mb_type[i]= get_ue_golomb(&s->gb);\n\n                if(h->sub_mb_type[i] >=4){\n\n                    av_log(h->s.avctx, AV_LOG_ERROR, \"P sub_mb_type %u out of range at %d %d\\n\", h->sub_mb_type[i], s->mb_x, s->mb_y);\n\n                    return -1;\n\n                }\n\n                sub_partition_count[i]= p_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;\n\n                h->sub_mb_type[i]=      p_sub_mb_type_info[ h->sub_mb_type[i] ].type;\n\n            }\n\n        }\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            int ref_count= IS_REF0(mb_type) ? 1 : h->ref_count[list];\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) continue;\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    unsigned int tmp = get_te0_golomb(&s->gb, ref_count); //FIXME init to 0 before and skip?\n\n                    if(tmp>=ref_count){\n\n                        av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", tmp);\n\n                        return -1;\n\n                    }\n\n                    ref[list][i]= tmp;\n\n                }else{\n\n                 //FIXME\n\n                    ref[list][i] = -1;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(dct8x8_allowed)\n\n            dct8x8_allowed = get_dct8x8_allowed(h);\n\n\n\n        for(list=0; list<h->list_count; list++){\n\n            for(i=0; i<4; i++){\n\n                if(IS_DIRECT(h->sub_mb_type[i])) {\n\n                    h->ref_cache[list][ scan8[4*i] ] = h->ref_cache[list][ scan8[4*i]+1 ];\n\n                    continue;\n\n                }\n\n                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ]=\n\n                h->ref_cache[list][ scan8[4*i]+8 ]=h->ref_cache[list][ scan8[4*i]+9 ]= ref[list][i];\n\n\n\n                if(IS_DIR(h->sub_mb_type[i], 0, list)){\n\n                    const int sub_mb_type= h->sub_mb_type[i];\n\n                    const int block_width= (sub_mb_type & (MB_TYPE_16x16|MB_TYPE_16x8)) ? 2 : 1;\n\n                    for(j=0; j<sub_partition_count[i]; j++){\n\n                        int mx, my;\n\n                        const int index= 4*i + block_width*j;\n\n                        int16_t (* mv_cache)[2]= &h->mv_cache[list][ scan8[index] ];\n\n                        pred_motion(h, index, block_width, list, h->ref_cache[list][ scan8[index] ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        if(IS_SUB_8X8(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]=\n\n                            mv_cache[ 8 ][0]= mv_cache[ 9 ][0]= mx;\n\n                            mv_cache[ 1 ][1]=\n\n                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;\n\n                        }else if(IS_SUB_8X4(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]= mx;\n\n                            mv_cache[ 1 ][1]= my;\n\n                        }else if(IS_SUB_4X8(sub_mb_type)){\n\n                            mv_cache[ 8 ][0]= mx;\n\n                            mv_cache[ 8 ][1]= my;\n\n                        }\n\n                        mv_cache[ 0 ][0]= mx;\n\n                        mv_cache[ 0 ][1]= my;\n\n                    }\n\n                }else{\n\n                    uint32_t *p= (uint32_t *)&h->mv_cache[list][ scan8[4*i] ][0];\n\n                    p[0] = p[1]=\n\n                    p[8] = p[9]= 0;\n\n                }\n\n            }\n\n        }\n\n    }else if(IS_DIRECT(mb_type)){\n\n        pred_direct_motion(h, &mb_type);\n\n        dct8x8_allowed &= h->sps.direct_8x8_inference_flag;\n\n    }else{\n\n        int list, mx, my, i;\n\n         //FIXME we should set ref_idx_l? to 0 if we use that later ...\n\n        if(IS_16X16(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, 0, list)){\n\n                        val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                        if(val >= h->ref_count[list]){\n\n                            av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                            return -1;\n\n                        }\n\n                    }else\n\n                        val= LIST_NOT_USED&0xFF;\n\n                    fill_rectangle(&h->ref_cache[list][ scan8[0] ], 4, 4, 8, val, 1);\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                unsigned int val;\n\n                if(IS_DIR(mb_type, 0, list)){\n\n                    pred_motion(h, 0, 4, list, h->ref_cache[list][ scan8[0] ], &mx, &my);\n\n                    mx += get_se_golomb(&s->gb);\n\n                    my += get_se_golomb(&s->gb);\n\n                    tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                    val= pack16to32(mx,my);\n\n                }else\n\n                    val=0;\n\n                fill_rectangle(h->mv_cache[list][ scan8[0] ], 4, 4, 8, val, 4);\n\n            }\n\n        }\n\n        else if(IS_16X8(mb_type)){\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_16x8_motion(h, 8*i, list, h->ref_cache[list][scan8[0] + 16*i], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 4);\n\n                }\n\n            }\n\n        }else{\n\n            assert(IS_8X16(mb_type));\n\n            for(list=0; list<h->list_count; list++){\n\n                    for(i=0; i<2; i++){\n\n                        unsigned int val;\n\n                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize\n\n                            val= get_te0_golomb(&s->gb, h->ref_count[list]);\n\n                            if(val >= h->ref_count[list]){\n\n                                av_log(h->s.avctx, AV_LOG_ERROR, \"ref %u overflow\\n\", val);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            val= LIST_NOT_USED&0xFF;\n\n                        fill_rectangle(&h->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 1);\n\n                    }\n\n            }\n\n            for(list=0; list<h->list_count; list++){\n\n                for(i=0; i<2; i++){\n\n                    unsigned int val;\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        pred_8x16_motion(h, i*4, list, h->ref_cache[list][ scan8[0] + 2*i ], &mx, &my);\n\n                        mx += get_se_golomb(&s->gb);\n\n                        my += get_se_golomb(&s->gb);\n\n                        tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        val= pack16to32(mx,my);\n\n                    }else\n\n                        val=0;\n\n                    fill_rectangle(h->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 4);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if(IS_INTER(mb_type))\n\n        write_back_motion(h, mb_type);\n\n\n\n    if(!IS_INTRA16x16(mb_type)){\n\n        cbp= get_ue_golomb(&s->gb);\n\n        if(cbp > 47){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"cbp too large (%u) at %d %d\\n\", cbp, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        if(IS_INTRA4x4(mb_type))\n\n            cbp= golomb_to_intra4x4_cbp[cbp];\n\n        else\n\n            cbp= golomb_to_inter_cbp[cbp];\n\n    }\n\n    h->cbp = cbp;\n\n\n\n    if(dct8x8_allowed && (cbp&15) && !IS_INTRA(mb_type)){\n\n        if(get_bits1(&s->gb))\n\n            mb_type |= MB_TYPE_8x8DCT;\n\n    }\n\n    s->current_picture.mb_type[mb_xy]= mb_type;\n\n\n\n    if(cbp || IS_INTRA16x16(mb_type)){\n\n        int i8x8, i4x4, chroma_idx;\n\n        int chroma_qp, dquant;\n\n        GetBitContext *gb= IS_INTRA(mb_type) ? h->intra_gb_ptr : h->inter_gb_ptr;\n\n        const uint8_t *scan, *scan8x8, *dc_scan;\n\n\n\n//        fill_non_zero_count_cache(h);\n\n\n\n        if(IS_INTERLACED(mb_type)){\n\n            scan8x8= s->qscale ? h->field_scan8x8_cavlc : h->field_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->field_scan : h->field_scan_q0;\n\n            dc_scan= luma_dc_field_scan;\n\n        }else{\n\n            scan8x8= s->qscale ? h->zigzag_scan8x8_cavlc : h->zigzag_scan8x8_cavlc_q0;\n\n            scan= s->qscale ? h->zigzag_scan : h->zigzag_scan_q0;\n\n            dc_scan= luma_dc_zigzag_scan;\n\n        }\n\n\n\n        dquant= get_se_golomb(&s->gb);\n\n\n\n        if( dquant > 25 || dquant < -26 ){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"dquant out of range (%d) at %d %d\\n\", dquant, s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n\n\n        s->qscale += dquant;\n\n        if(((unsigned)s->qscale) > 51){\n\n            if(s->qscale<0) s->qscale+= 52;\n\n            else            s->qscale-= 52;\n\n        }\n\n\n\n        h->chroma_qp= chroma_qp= get_chroma_qp(h->pps.chroma_qp_index_offset, s->qscale);\n\n        if(IS_INTRA16x16(mb_type)){\n\n            if( decode_residual(h, h->intra_gb_ptr, h->mb, LUMA_DC_BLOCK_INDEX, dc_scan, h->dequant4_coeff[0][s->qscale], 16) < 0){\n\n                return -1; //FIXME continue if partitioned and other return -1 too\n\n            }\n\n\n\n            assert((cbp&15) == 0 || (cbp&15) == 15);\n\n\n\n            if(cbp&15){\n\n                for(i8x8=0; i8x8<4; i8x8++){\n\n                    for(i4x4=0; i4x4<4; i4x4++){\n\n                        const int index= i4x4 + 4*i8x8;\n\n                        if( decode_residual(h, h->intra_gb_ptr, h->mb + 16*index, index, scan + 1, h->dequant4_coeff[0][s->qscale], 15) < 0 ){\n\n                            return -1;\n\n                        }\n\n                    }\n\n                }\n\n            }else{\n\n                fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);\n\n            }\n\n        }else{\n\n            for(i8x8=0; i8x8<4; i8x8++){\n\n                if(cbp & (1<<i8x8)){\n\n                    if(IS_8x8DCT(mb_type)){\n\n                        DCTELEM *buf = &h->mb[64*i8x8];\n\n                        uint8_t *nnz;\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            if( decode_residual(h, gb, buf, i4x4+4*i8x8, scan8x8+16*i4x4,\n\n                                                h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 16) <0 )\n\n                                return -1;\n\n                        }\n\n                        nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                        nnz[0] += nnz[1] + nnz[8] + nnz[9];\n\n                    }else{\n\n                        for(i4x4=0; i4x4<4; i4x4++){\n\n                            const int index= i4x4 + 4*i8x8;\n\n\n\n                            if( decode_residual(h, gb, h->mb + 16*index, index, scan, h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale], 16) <0 ){\n\n                                return -1;\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    uint8_t * const nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];\n\n                    nnz[0] = nnz[1] = nnz[8] = nnz[9] = 0;\n\n                }\n\n            }\n\n        }\n\n\n\n        if(cbp&0x30){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++)\n\n                if( decode_residual(h, gb, h->mb + 256 + 16*4*chroma_idx, CHROMA_DC_BLOCK_INDEX, chroma_dc_scan, NULL, 4) < 0){\n\n                    return -1;\n\n                }\n\n        }\n\n\n\n        if(cbp&0x20){\n\n            for(chroma_idx=0; chroma_idx<2; chroma_idx++){\n\n                const uint32_t *qmul = h->dequant4_coeff[chroma_idx+1+(IS_INTRA( mb_type ) ? 0:3)][chroma_qp];\n\n                for(i4x4=0; i4x4<4; i4x4++){\n\n                    const int index= 16 + 4*chroma_idx + i4x4;\n\n                    if( decode_residual(h, gb, h->mb + 16*index, index, scan + 1, qmul, 15) < 0){\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }else{\n\n            uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n            nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n            nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n        }\n\n    }else{\n\n        uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);\n\n        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n        nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n    }\n\n    s->current_picture.qscale_table[mb_xy]= s->qscale;\n\n    write_back_non_zero_count(h);\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] >>= 1;\n\n        h->ref_count[1] >>= 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23299, "substitutes": {"h": ["ctx", "hi", "m", "kh", "this", "hr", "zh", "o", "hz", "here", "HH", "oh", "ih", "w", "ash", "cache", "ah", "ph", "hm", "l", "self", "ht", "hd", "has", "b", "dh", "rh", "c", "sh", "history", "he", "r", "header", "eh", "html", "host", "uh", "dr", "enh", "t", "bh", "H", "hp", "her", "ssh", "hash", "hs", "hh", "hl", "his", "hal", "ch", "http", "handle", "obj", "hw", "err", "th", "ish", "help", "v"], "s": ["south", "sp", "bs", "rs", "conf", "gets", "fs", "ims", "cs", "stats", "set", "its", "a", "sam", "os", "f", "ls", "es", "o", "vs", "ps", "ds", "b", "ts", "serv", "args", "his", "conv", "se", "is", "v", "js", "dev", "gs", "m", "ssl", "sl", "state", "bits", "parts", "bis", "sm", "status", "ms", "ses", "ss", "g", "hs", "obj", "sts", "http", "sys", "ats", "str", "comm", "spec", "sq", "details", "w", "sb", "n", "has", "sh", "c", "tests", "as", "sw", "ys", "utils", "t", "ns", "changes", "e", "sv", "qs", "S", "als", "ops"], "partition_count": ["partitionationtype", "partitions_length", "partitionationcount", "partition2cache", "partitionationtable", "partitionablelength", "partition_cache", "partition2type", "partition_table", "partitionablecount", "partition_type", "partitions_count", "partition2count", "partition_length", "partition_counter", "partitionablecounter", "partitions_counter", "partitionationlength"], "mb_type": ["MB_Type", "mbPrelation", "nb_level", "nbetyrole", "mb__type", "mb__code", "mob_type", "mbetylevel", "mb_model", "mb_style", "bb_number", "emb_class", "mb_count", "mb_types", "mbPlength", "mb__block", "mb_typ", "nb_style", "mbxtypes", "nbetylevel", "emb_type", "emb_types", "mb_code", "MB_types", "mb_number", "MB_type", "mb_total", "mbPtype", "mbTypelevel", "nb_code", "nb_block", "mbPmodel", "mb_level", "mb_role", "bb_level", "nbetytype", "nb_model", "mbTypetotal", "mbxclass", "nb_role", "mb__style", "mbetyrel", "nb_rel", "mb_relation", "mbetytype", "nb_relation", "mob_count", "mb_length", "mbetyrole", "nb_length", "mb_time", "MB_time", "mbTypetype", "mob_Type", "mbTypenumber", "mb_block", "mb_class", "mb_rel", "nbetyrel", "mbxtype", "mbxcount", "emb_count", "mob_typ", "nb_type", "bb_type", "mb_Type", "bb_total"], "cbp": ["bbpc", "CBpc", "cvP", "bbpos", "bbp", "cbP", "cbpos", "cbg", "cbv", "CBv", "cbpc", "CBp", "bbg", "cvpos", "cvp", "bbv", "CBP", "wbg", "CBpos", "wbP", "cvpc", "bbP", "wbv", "wbp", "CBg"], "mb_skip_run": ["mb_no_step", "mb_skip___skip", "mb_skipocrun", "mb_no_load", "mb_save_run", "mb_sp_ref", "mb_skip___pre", "mb_skip_load", "mb_no_pre", "mb_sp_run", "mb_skipocout", "mb_skip_runs", "mb_no_run", "mb_skip___step", "mb_skip_un", "mb_skip_ref", "mb_skip___ref", "mb_skip_skip", "mb_skip_pre", "mb_sp_un", "mb_skipoccheck", "mb_save_runs", "mb_skip___un", "mb_no_check", "mb_save_task", "mb_skip___load", "mb_skip_step", "mb_no_runs", "mb_sp_skip", "mb_skip_check", "mb_skip_ran", "mb_skipocruns", "mb_skip___run", "mb_save_ran", "mb_skip_task", "mb_skip_out", "mb_no_out"], "gb": ["cfg", "gc", "gs", "gam", "gallery", "eg", "vt", "eb", "nb", "gl", "gg", "yg", "ga", "gm", "sb", "gd", "Gb", " GB", "GB", "storage", "deg", "img", "gif", "gz", "db", "g", "rb", "kb", "bg", "vg", "mb", "imag", "emb", "gt", "xy", "fg", "rg", "hub", "gom", "gy"]}}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, \n\n                              uint32_t address, uint32_t val, int len)\n\n{\n\n    int can_write, i;\n\n    uint32_t end, addr;\n\n\n\n    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || \n\n                     (address >= 0x30 && address < 0x34))) {\n\n        PCIIORegion *r;\n\n        int reg;\n\n\n\n        if ( address >= 0x30 ) {\n\n            reg = PCI_ROM_SLOT;\n\n        }else{\n\n            reg = (address - 0x10) >> 2;\n\n        }\n\n        r = &d->io_regions[reg];\n\n        if (r->size == 0)\n\n            goto default_config;\n\n        /* compute the stored value */\n\n        if (reg == PCI_ROM_SLOT) {\n\n            /* keep ROM enable bit */\n\n            val &= (~(r->size - 1)) | 1;\n\n        } else {\n\n            val &= ~(r->size - 1);\n\n            val |= r->type;\n\n        }\n\n        *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n", "idx": 23307, "substitutes": {"d": ["dos", "dev", "m", "done", "dat", "p", "data", "dx", "dL", "ld", "gd", "pd", "n", "dt", "fd", "ds", "l", "b", "dh", "c", "du", "j", "di", "da", "dr", "dm", "dn", "db", "g", "dl", "nd", "dc", "dd", "de", "device", "md", "e", "D", "dq", "bd", "ad", "sd", "v"], "address": ["adr", "at", "memory", "type", "chain", "order", "ip", " Address", "store", "work", "record", "reference", "attribute", "x", "enable", "ad", "array", "block", "table", "trace", "command", "distance", "padding", "range", "each", "race", "prefix", "hello", "config", "date", "pointer", "shape", "message", "position", "align", "device", "vector", "add", "Address", "here", "length", "image", "port", "ptr", "ace", "ay", "domain", "offset", "activity", "application", "relative", "empty", "location", "point", "act", "network", "route", "always", "description", "alias", "service", "value", "result", "size", "buffer", "gate", "target", "link", "number", "operation", "base", "interface", "context", "index"], "val": ["Value", "rx", "vt", "p", "aval", "data", "ival", "pr", "type", "loc", "def", "tag", "range", "value", "pl", "test", "l", "bit", "ret", "values", "vol", "VAL", "tx", "serv", " value", "pt", "eval", "pos", "res", "bl", "Val", "col", "key", "pol", "ref", "vec", "var", "al", "buf", "rol", "bal", "el", "mem", "arr", "rl", "x", "cal", "vals", "err", "rel", "valid", "v"], "len": ["lf", "ity", " l", "list", "ls", " length", "z", "seq", "L", "fl", "length", "ln", "ld", "ail", "syn", "n", "bytes", "lim", "lon", "Len", "l", "fin", "tl", "line", "nl", "c", "lib", "lan", "pos", "size", "bl", "en", "li", "vec", "count", "el", "ll", "hl", "mem", "h", "lp", "elt", "cap", "kl", "Length", "v"], "can_write": ["canopwrite", "canfultransfer", "cache_store", "can8write", "can8see", "canbleread", "Can_writ", "canopsee", "can_transfer", "willenwriter", "can2link", " can_create", "canenwrite", "canenread", "canifyexit", "can2write", "canlyapply", "canifywrite", " can_see", "can_store", "cacheopsee", "can_link", " can_read", "will_read", "canfulcreate", "cache_writer", " can_exit", "can_read", "cacheopwriter", "annot_writer", "can8store", "will_writer", "canblewrit", "canlyexit", "can_writer", "canifysee", "canifyapply", "Can_write", "annot_write", "canblewrite", "annot_writ", "canfulsee", "canlysee", "can_writ", "canlywrite", "canentransfer", "canblelink", "willentransfer", "can_see", "canfulread", "can2writ", " can_apply", "canenwriter", "Can_link", "canopwriter", "can_exit", "can8writer", "canfulwrite", "Can_read", "cache_see", "cacheopstore", "can_create", "will_write", "canfulwriter", "can_apply", "annot_see", "willenread", "willenwrite", "cache_write", "cacheopwrite", "canopstore", "can2read", "will_transfer"], "i": ["m", "me", "try", "ix", "ci", "p", "start", "id", "multi", "zi", "si", "port", "complete", "n", "y", "it", "ims", "xi", "l", "init", "status", "ti", "b", "mi", "qi", "iu", "c", "j", "iter", "di", "in", "ir", "ai", "im", "ki", "k", "u", "gi", "phi", "ui", "li", "ic", "ip", "cli", "sim", "ini", "e", "ind", "tim", "index", "ii", "x", "pi", "batch", "I", "ex", "progress", "is", "v"], "end": [" rid", " coff", " ref", "ival", " vend", " endpoint", " Val", " act", " serv", "serv", " start", " pos", " rend", "Val", "ref", "bal", " aval", "code", " rem", " pend", " rest", " count", "valid", " tag", " begin", "v"], "addr": ["ctx", "pkg", "ix", "arp", "add", "grad", "adr", "p", "alt", "sp", "np", "Address", "pad", "loc", "ptr", "ace", "offset", "ret", "attr", "prefix", "pat", "ord", "tx", "iter", "cmd", "host", "dr", "order", "act", "pos", "map", "res", "gate", "dd", "ref", "ip", "align", "a", "obj", "handle", "code", "ress", "mem", "arr", "index", "err", "ad", "rel"], "r": ["m", "cr", "rx", "kr", "p", "mr", "rs", "w", "range", "br", "n", "rw", "rn", "rem", "l", "er", "attr", "lr", "rt", "c", "rh", "j", "dr", "rar", "t", "ar", "res", "R", "g", "rb", "repl", "arr", "vr", "re", "ro", "rec", "h", "rg", "rl", "sr", "rr", "rc", "rd", "usr", "rm", "err", "rel", "nr", "v"], "reg": ["gc", "gro", "rest", "eg", "state", "mod", "pr", "loc", "rom", "tag", "br", "rem", "region", "ret", "rep", "rt", "gr", "serv", "org", "dr", "rar", "ar", "res", "g", "col", "REG", "key", "rank", "ref", "var", "re", "rol", "row", "leg", "mem", "rec", "index", "rg", "sr", "arr", "rr", "urg", "rm", "greg", "Reg", "cell", "pg", "rc"]}}
{"project": "FFmpeg", "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "target": 1, "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23309, "substitutes": {"avctx": ["savcontext", " avcc", "avctl", "AVcc", "savctl", "AVctl", " avctl", "avcontext", " avcontext", "avcc", "savctx", "AVctx", "AVcontext", "savcc"], "s": ["rs", "bs", "events", "params", "conf", "ants", "gets", "fs", "ims", "cs", "stats", "search", "set", "ies", "its", "ins", "a", "os", "ls", "es", "d", "vs", "ps", "ds", "l", "b", "ts", "serv", "args", "less", "ports", "is", "js", "gs", "m", "sl", "bits", "ches", "parts", "bis", "status", "ms", "r", "ss", "results", "aws", "g", "hs", "obj", "sts", "sys", "ats", "sports", "comm", "spec", "p", "details", "w", "sb", "n", "c", "sync", "as", "sw", "t", "ns", "changes", "sv", "qs", "h", "sg", "S", "als", "ops", "ex"], "length": ["always", "ilo", " l", "height", "vector", "end", " lengths", "p", "full", "L", "be", "type", "ength", "SIZE", "loc", "distance", "padding", "maximum", "ptr", "duration", "amount", "l", "component", "capacity", "offset", "text", "available", "history", "c", "sh", "idth", "ENGTH", "load", "deep", "no", "expected", "location", "shape", "loop", "size", "t", "message", "buffer", "position", "total", "count", "php", "len", "number", "head", " Length", "all", "before", " len", "angle", "form", "h", "enth", "sequence", "block", "f", "Length"], "v": ["V", "m", "tv", "vv", "vt", "p", "vc", "q", "o", "ve", "at", "ev", "gm", "w", "d", "um", "vs", "av", "qu", "value", "n", "vm", "y", "it", "iv", "va", "l", "wire", "b", "c", "r", "vp", "j", "uv", "lv", "t", "g", "u", " ov", "buffer", "var", "cv", "nv", "sv", " sv", "qv", "conv", "x", "h", "pi", "ov", "vi", "f", "val"], "i": ["at", "name", "multi", "ori", "ei", "ims", "chain", "mi", "info", "ir", "\u0438", "uri", "phi", "ip", "ri", "client", "ini", "ind", "ii", "x", "pi", "f", "ki", "im", "list", "try", "q", "o", "zi", "it", "qi", "iu", "iter", "di", "in", "print", "remote", "is", "hi", "me", "m", "us", "si", "init", "xi", "sky", "er", "PI", "point", "ni", "ai", "res", "g", "fi", "ui", "page", "li", "rel", "progress", "ci", "ix", "p", "id", "span", "y", "ij", "ti", "j", "ie", "gi", "ic", "key", "cli", "sim", "ji", "bi", "e", "oi", "index", "I", "ami", "ex", "eric"]}}
{"project": "FFmpeg", "commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n", "idx": 23323, "substitutes": {"s": ["comments", "so", "rs", "bs", "events", "conf", "ants", "fs", "ims", "settings", "cs", "sym", "stats", "ar", "set", "ins", "a", "os", "f", "same", "ls", "es", "z", "times", "bes", "ps", "ds", "l", "self", "ts", "less", "ags", "source", "se", "is", "v", "js", "gs", "parts", "bis", "status", "er", "ms", "an", "ses", "ss", "aws", "hs", "sts", "sys", "ats", "sports", "comm", "spec", "sq", "p", "details", "w", "sb", "service", "n", "y", "has", "c", "as", "sw", "t", "ns", "changes", "sv", "qs", "h", "als", "ops", "ex"], "crc": ["ctRC", "Crs", "acsum", " crand", "acRC", "ccc", "crib", "Crand", "cRC", "ccrs", " crs", "csum", "curred", " cRC", "crs", "accc", "crand", "ctsum", " ccc", "currs", " csum", "ccrc", "ccred", "compred", "rcrand", "rcrc", "Crc", "comprs", "comprc", "acrc", "cred", "rcrs", "currib", "currc", "ctcc", "rcRC", "ctrc", "ccrib", "comprib", "CRC"], "S": ["V", "SS", "A", "CS", "Source", " T", "G", "Q", "SB", "O", "L", "SAM", "SER", "TS", "String", "RS", "SEC", "Size", "N", "C", "IS", "P", "SP", "B", "Sample", "SL", "JS", "Si", "SH", "T", "NS", "set", "R", "H", "U", "BS", "BIT", " B", "J", "SU", "STAT", "SI", "F", "X", "DS", "M", "Session", "D", " C", "SR", "I", "SF", "RAW", "SA", "US"], "bit": ["V", "at", "slot", "bin", "sc", "test", "ret", " bits", "set", "ip", "its", "bug", "X", "ch", "condition", "bool", "binary", "x", "op", "block", "f", "character", "be", "tag", "it", "l", "hit", "b", "B", "flag", "in", "print", "cat", "position", "byte", "IT", " tag", "back", "AT", "SA", "G", "state", "bits", "or", "word", "Bit", "image", "port", "field", "offset", "status", "P", "limit", "point", "g", "virtual", "mask", "bo", "p", "id", "ST", "ion", "value", "result", "single", "bt", "board", "i", "t", "BIT", "match", "out", "null", "base", "index", "I"]}}
{"project": "qemu", "commit_id": "fc40787abcf8452b8f50d92b7a13243a12972c7a", "target": 1, "func": "target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n", "idx": 23339, "substitutes": {"env": ["equ", "end", "viron", "sp", "conf", "eng", "conn", "sc", "environment", "worker", "org", "server", "buf", "queue", "hw", "gear", "erd", "cv", "ctx", "rod", "vt", "erb", "manager", "vs", "vm", "enter", "dt", "dest", "ec", "net", "map", "en", "ew", "desc", "priv", "cont", "rc", "v", "dev", "te", "ev", "here", "req", "ptr", "init", "er", "act", "msg", "window", "obj", "estate", "ee", "err", "kh", "_", "w", "ah", "vp", "sw", "cmd", "func", "db", "buffer", "disk", "event", "e", "context", "sv", "h", "operator"], "arg1": ["matchav", "stage001", "match2", "match001", "par1", "app1", "param2", "calized", "commandone", "doc1", "param100", "command001", " argid", "paramized", "exp1", "arg01", "Arg01", "agg2", "agg0", "prop2", "target2", "group11", "date001", "cal100", "tag1", "dateone", "pg1", "match15", "date01", "stage01", "param1", "prop3", "prop61", " arg01", "date2", "match01", "arg51", "commandized", "cmdone", "group9", "command100", "prop9", "pgav", "docone", "argOne", "group001", "matchid", "cmd1", "agg51", "command9", "param01", "Arg1", "agg11", "ag2", " arg001", "exp001", "parized", "arg001", "doc001", " arg61", "pg01", "arg3", "propone", "date15", "ag91", "command61", "app001", "args1", "parid", "arg11", "propav", "group01", "date1", "Arg51", "args2", " argone", "groupav", "ag001", " arg15", "aggone", "match11", "Arg001", "match1", "prop001", "aggav", "commandav", "matchized", "param91", "expone", "arg61", "var1", "group1", " argized", "cmd001", "stage1", "varone", "tag001", "tag0", "agg01", "command1", "appone", "agg1", " argOne", "par001", "arg9", "ag1", "argsOne", "target1", "arg0", "param51", "prop1", "matchone", "param001", "argized", "arg100", "prop91", "argav", "target01", "cal001", "tag2", "command3", "var001", "prop0", "groupone", "argid", "agg001", " arg3", "args01", "arg15", "var01", "cal1", "pg001", "arg91", "argone", "targetOne"], "arg2": ["param102", "iter5", "match2", "iter6", "arglet", "param2", "propTwo", "itemTwo", "val02", "arp7", "cmd5", "item2", "argTwo", "group2", "agg2", "stage42", "prop2", "group02", "act2", " arg0", "tag1", "actTwo", "argtwo", "argument1", "dr102", "agg10", "agg6", "ld02", "date2", "event2", "iter102", "flag1", "prop02", "event42", "date7", "cmd8", "ldTwo", "arg8", "dateTwo", "arg6", " arg5", "docTwo", "Arg1", "match02", "match102", "param10", "stagelet", "val8", "arptwo", "op02", "actlet", "tagTwo", "arg7", "arg3", "date02", "arp2", "stage2", "tag02", "cmd2", "method2", "arp02", "exp2", "iter02", "flag02", "opTwo", "item02", "flag2", "cmd02", "val5", "agg02", "arg02", "arg102", "param02", "agg5", "agg7", "exp42", "groupTwo", "agg4", "act42", "act02", "methodlet", "arg5", "dr2", "dr02", "stage1", "argument2", "argument0", "tag0", "val2", "param6", "ld2", "agg1", "argument4", "flag4", "exp02", "doc2", "arg4", "doc02", "op102", "arg42", "arg0", "param8", "eventTwo", "method42", "Arg3", "agg102", "op2", "cmd10", "iter2", "Arg2", "argument5", "expTwo", "tag2", "arg10", "agg8", "drTwo", "argument8", "Arg5", "matchTwo", "argument02", " arg3", "datetwo", "tag5", "tag3", "aggtwo"], "mem_idx": ["mem_endx", "mem_midxs", "mem_identx", "mem_intxy", "mem_idz", "memockidentx", "mem_ridxc", "mem_idl", "mem_ridx", "mem_midxy", "mem_pyxc", "mem2idz", "mem_IdIndex", "mem_lockxi", "mem_dirix", "mem_idex", "mem_idsxc", "mem_idf", "mem_pidex", "mem8idix", "mem2Idz", "mem2Idex", "mem_Idz", "mem_idsex", "mem_lockex", "mem2idx", "mem_dct", "mem_idxi", "mem_intz", "mem_indexx", "mem8idx", "mem_idxc", "mem2Idx", "mem_tryex", "mem_idxy", "mem_idxs", "mem_tryxs", "mem8dirxi", "mem_midix", "mem_idfx", "mem_midxi", "mem_pyix", "mem_midz", "memockidz", "mem_dx", "mem_ridIndex", "mem_tagx", "mem8idxi", "mem_idIndex", "memockidentz", "memockidentf", "mem_tagz", "mem_identf", "mem2idxc", "mem_idsx", "mem_identz", "mem_endp", "mem8dirix", "mem_ridz", "mem_pidct", "mem_idct", "mem_lockix", "memockidf", "mem_iterct", "mem_idj", "mem_tagix", "mem_tryx", "mem_pyz", "mem_endfx", "mem_dl", "mem_iterex", "mem_tryct", "mem2idex", "mem_dirx", "mem_midp", "mem_dirxi", "mem_dj", "mem_endxs", "mem_tagxc", "memockidentxy", "mem_identxy", "mem_indexct", "mem_iterxs", "mem_indexl", "mem_iterj", "mem_pidxs", "mem_Idxc", "mem_idep", "mem8direx", "mem_idp", "mem_iterl", "mem_idsz", "mem_midx", "mem_midex", "mem_iterx", "mem_Idx", "mem_lockx", "mem_direx", "mem_indexj", "mem_idix", "mem8idex", "mem_midfx", "mem_midf", "mem_Idex", "mem8dirx", "mem_pidx", "mem_idefx", "mem_intf", "mem_intx", "mem_idexs", "mem_pyx", "memockidx", "mem2Idxc", "memockidxy"], "tmp": ["pkg", "aaa", "np", "sp", "tc", "copy", "good", "attr", "lib", "pot", "nt", "utm", "gz", "yy", "MP", "tn", "pb", "resp", "lambda", "op", "tf", "sup", "term", "ctx", "cp", "zip", "tp", "mm", "nb", "important", "up", "gb", "cache", "dt", "mp", "b", "buff", "html", "uv", "img", "tif", "encrypted", "amp", "csv", "mb", " np", "xy", "fb", "v", "temp", "js", "perm", "m", "trap", "mk", "td", "tt", "ptr", "tg", "appy", "wp", "proc", "aux", "mmm", "timeout", "uff", "msg", "txt", "var", "obj", "vv", "p", "gm", "pretty", "tar", "verb", "etc", "ob", " resp", "stuff", "tab", "bt", "t", "bolt", "db", "now", "gt", " mp", "rm", "qq", "cmp"]}}
{"project": "FFmpeg", "commit_id": "289520fd97395ffd5bf933ac80487e858bc4039d", "target": 0, "func": "static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n        int v = get_bits(&s->gb, 8);\n\n        if (v == 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\");\n\n            return -1;\n\n        }\n\n        if (intra && i == 0 && v != 8) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix specifies invalid DC quantizer %d, ignoring\\n\", v);\n\n            v = 8; // needed by pink.mpg / issue1046\n\n        }\n\n        matrix0[j] = v;\n\n        if (matrix1)\n\n            matrix1[j] = v;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23344, "substitutes": {"s": ["js", "gs", "m", "south", "ls", "q", "p", "sq", "rs", "bs", "conf", "d", "sb", "vs", "n", "ps", "fs", "acs", "ims", "ds", "l", "ains", "ms", "b", "c", "cs", "settings", "sw", "ts", "ses", "j", "serv", "ss", "stats", "aws", "ns", "asm", "ins", "hs", "a", "e", "sam", "sts", "sv", "qs", "h", "ats", "sg", "se", "os", "sys", "S", "is", "comm"], "matrix0": ["matrix08", "metrix00", "matmat0", "matment00", "matrix180", "contrix3", "matgment180", "contgment0", "metform0", "matric2", "metform10", "matrix3", "contgment08", "matgment3", "matment0", "metrix0", "matgment08", "matform2", "matmat08", "metform00", "matment2", "matction0", "matform00", "contgment180", "matgment0", "contrix0", "metrix10", "metrix2", "matction3", "metform2", "matrix00", "matrix2", "matform10", "matmat3", "matrix10", "contrix180", "matment10", "matform0", "matmat180", "matction08", "matric10", "contrix08", "matric00", "contgment3", "matction180", "matric0"], "matrix1": ["matMatrix1", "matvectorInf", "trice0", "matMatrixable", "matvectorOne", "catrix01", "matric01", "matric2", "trice01", "userixOne", "trice1", "matMatrix01", "trix0", "matrices0", "matrices100", "trix1", "matrixOne", "matvector1", "matrice0", "matrice01", "matMatrixInf", "catricOne", "matempt01", "matrice100", "catrix1", "matrices1", "catrixOne", "useMatrixOne", "useMatrixable", "matMatrix2", "catrix2", "matrices2", "trix100", "trix01", "matempt1", "matricOne", "trice100", "matric1", "matrices01", "matrixInf", "catric01", "matrix2", "matrice1", "matrix01", "catric2", "matrixable", "useMatrix1", "matempt0", "userixable", "matvectorable", "userixInf", "matempt100", "matrix100", "catric1", "userix1", "matricesOne", "useMatrixInf", "matMatrixOne"], "intra": ["ortras", "ntra", "ntri", "interran", "ortrait", "Intran", "pretRA", "intri", "intRA", "Intra", "ntrait", "Inttra", "interRA", "ortra", "intras", "contri", "ortri", "intertra", "contrait", "intran", "prettra", "contra", "interra", "pretran", "inttra", "pretra", "ntras", "IntRA", "contras", "intrait"], "i": ["hi", "m", "me", " ti", "ci", "ix", "p", "v", "o", "at", "id", "name", "si", "zi", "multi", "n", "y", "it", "ims", "xi", "init", "ij", "l", "ti", "mi", "qi", "info", "gu", "c", "iu", "b", "j", "di", "in", "ai", "print", "t", "k", "u", "fi", "gi", "phi", "ui", "li", "ic", " j", "ip", "sim", "out", "is", "ini", "bi", "ind", "ji", "index", "ii", "x", "pi", "I", "ia", "ex", "f", "ki", "im"]}}
{"project": "qemu", "commit_id": "dc8764f06155a7b3e635e02281b747a9e292127e", "target": 1, "func": "static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n", "idx": 23354, "substitutes": {"sig": ["sg", "Sig", "Sg", " sg", "ssg", "sigs", "ssigs", " sigs", "Sigs", "ssig"], "status": ["current", "pid", "check", "sp", "atus", "state", "name", "id", "exist", "n", "wa", "sc", "fs", "Status", "result", "expr", "s", "c", "serv", "flag", "i", "error", "g", "output", "wait", "msg", "stat", "resp", "out", "STAT", "code", "handle", "compl", "index", "str", "x", "exec", "ex", "progress", "val"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)\n\n{\n\n    int current_offset = s->pixel_ptr - dst->data[0];\n\n    int motion_offset = current_offset + delta_y * dst->linesize[0]\n\n                       + delta_x * (1 + s->is_16bpp);\n\n    if (motion_offset < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset < 0 (%d)\\n\", motion_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (motion_offset > s->upper_motion_limit_offset) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset above limit (%d >= %d)\\n\",\n\n            motion_offset, s->upper_motion_limit_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (src->data[0] == NULL) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,\n\n                                            dst->linesize[0], 8);\n\n    return 0;\n\n}\n", "idx": 23361, "substitutes": {"s": ["js", "gs", "south", "spec", "so", "ls", "eds", "sq", "p", "us", "es", "rs", "bs", "z", "details", "conf", "w", "sb", "ants", "vs", "sports", "sc", "ps", "bis", "fs", "sis", "ds", "ims", "self", "ains", "ms", "c", "cs", "as", "sw", "ts", "ses", "ss", "i", "stats", "t", "aws", "less", "set", "g", "https", "ns", "series", "ies", "ins", "its", "changes", "hs", "a", "services", "source", "sts", "sv", "qs", "sys", "ats", "h", "os", "S", "als", "ops", "is", "v", "comm"], "src": ["wn", "gs", "sn", "sl", "inst", "ur", "sq", "input", "rs", "via", "sel", "supp", "sb", "syn", "sc", "rn", "iv", "dest", "ser", "b", "rt", "proc", "r", "vp", "in", "img", "g", "sub", "vr", "std", "ins", "webkit", "obs", "source", "th", "http", "conv", "sv", "sr", "rl", "sys", "usr", "hw", "st", "rc"], "dst": ["dnd", "Dsts", "rst", "rest", "lest", "dsnd", "Dest", "Ddest", "rnd", "Dlt", "lst", "lsts", "dest", "dsst", " dsts", " dnd", "ldest", "llt", "dlt", " ddest", "dsdest", "Dnd", "dslt", "ddest", "rsts", "Dst", " dest", "dssts", "dsest", "dsts"], "delta_x": ["delt_xy", "delta_ex", "delta_r", "delta___r", "delta___x", "delt_x", "delt_y", "delta___X", "delta___ex", "delta_xy", "dota_ex", "dota_x", "dota_X", "delta_X", "dota_r"], "delta_y": ["dota_Y", "delta___yo", "dota_b", "delta2Y", "delta2xy", "delta_xy", "divot___yo", "delta_ym", "delta___Y", "delta2b", "divot___ym", "delta___y", "divot_y", "delta_yo", "delta___ym", "delta2y", "divot___y", "delta_b", "divot_ym", "dota_xy", "dota_y", "delta_Y", "divot___Y", "divot_Y", "divot_yo"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n", "idx": 23371, "substitutes": {"dev": ["spec", "ev", "pad", "Dev", "w", "Device", "ver", "d", "def", "vs", "des", "av", "DEV", "conn", "test", "ds", "att", "proc", "doc", "hid", "serv", "scan", "cmd", "go", "dm", "pro", "env", "dem", "watch", "de", "device", "cam", "mem", "sys", "hw", "ad", "devices", "sd"], "s": ["rs", "bs", "params", "conf", "sol", "gets", "fs", "sa", "cs", "stats", "set", "ins", "its", "ls", "es", "o", "ads", "bes", "vs", "ps", "ds", "b", "ts", "serv", "args", "less", "ags", "ports", "conv", "se", "is", "v", "js", "gs", "sl", "steps", "state", "bits", "des", "bis", "states", "ms", "r", "ses", "ss", "aws", "hs", "sts", "sys", "ats", "stat", "pers", "sports", "comm", "spec", "sq", "p", "details", "sb", "n", "c", "sync", "tests", "sw", "j", "cmd", "t", "ns", "changes", "sv", "qs", "h", "S", "als", "ops", "sd"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n", "idx": 23374, "substitutes": {}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        /* Do nothing, write notifier decided to fail this request */\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;", "idx": 23386, "substitutes": {"child": ["ac", "lf", "this", "q", "add", "parent", "shell", "bc", "w", "request", "cache", "fr", "sc", "cow", "cc", "bit", "b", "task", "s", "c", "root", "lib", "buff", "config", "j", "nt", "pt", "pty", "bl", "sub", "key", "sim", "client", "count", "store", "desc", "job", "resp", "handle", "comment", "ind", "ch", "ach", "base", "local", "h", "Child", "batch", "children", "th", "block", "cell", "v"], "req": ["ctx", "pkg", "rx", "q", "sq", "required", "qt", "seq", "pr", "jp", "ire", "request", "fr", "ps", "rw", "ext", "rem", "dist", "test", "expr", "attr", "proc", "rt", "requ", "r", "tx", "aux", "j", "cmd", "res", "reg", "grab", "pro", "msg", "ref", "resp", "desc", "md", "job", "wcs", "sec", "obj", "ind", "ch", "mem", "http", "comp", "Requ", "crit", "queue", "usr", "rec", "dq", "rr", "urg", "err", "qq", "wx", "quest", "rel", "require", "comm"], "offset": ["reset", "end", "start", "iso", "tile", "alias", "slot", "SIZE", "length", "loc", "padding", "execute", "scroll", "block", "range", "layout", " offsets", "shift", "Offset", "prefix", "oint", "address", "iter", "location", "origin", "point", "order", "timeout", "pos", "pointer", "size", "set", "error", "buffer", "offs", "position", "et", "total", "slice", "store", "off", "handle", "base", "byte", "aligned", "local", "index", "attribute", "os", "oid", "addr", "seek", "trace"], "bytes": ["pointers", "gs", "ips", "sets", "tes", "steps", "es", "bits", "memory", "points", "SIZE", " strides", "times", "reads", "classes", "length", "gets", "outs", "parts", " offsets", "loads", "blocks", "fixes", "values", "files", "versions", "seconds", "ries", "abytes", "grades", " slices", " sizes", "items", "units", "errors", "allows", "faces", "keys", "lines", "Bytes", "rows", "size", "maps", "bles", "offs", "ies", "izes", "total", " reads", "its", "actions", "len", "bps", " blocks", "pieces", "frames", "byte", "ones", "words", "ops", " bases", "pages"], "align": ["rot", "num", "transform", "alias", "hold", "pad", "length", "half", "lag", "padding", "block", "range", "scale", "aug", "layout", "shift", "aff", "margin", "attr", " aligned", "lock", "address", "config", "flag", "order", " alignment", "format", "shape", "size", "area", "ignore", "ign", "grade", "match", "rank", "adjust", "adj", "al", "count", "compl", "work", "len", "sign", "hal", "equal", "mem", "angle", "aligned", "cal", "addr", "batch", "mask", "dim", "pair", "attach", "label"], "qiov": ["qiour", " qovi", " qiev", "qiop", "iqiour", "qiev", "sqovi", "sqiov", " qiop", "sqvector", "quconv", "sqiop", " qvector", "qconv", "iqiop", "qvector", "qumpeg", " qveh", "qmpeg", " qmpeg", "quvector", "iqovi", "sqconv", "quiev", "qveh", "quiour", "quiov", "quveh", "dqiop", "dqiour", " qconv", "sqmpeg", "dqiov", "quiop", "dqovi", "iqiov", "quovi", "sqiour", "qovi", " qiour", "sqveh", "sqiev"], "flags": ["comments", "FLAG", "bits", "rates", "xx", "type", "fl", "Flag", "tags", "lag", "ants", "weights", "ps", "magic", "types", "status", "ms", "settings", "limits", "terms", "flag", "allows", "utils", "stats", "args", "atts", "fts", "actions", "ags", "bps", "sign", "options", "features", "checks", "friendly", "reports", "bool", "fps", "properties", "mask", "ops", "fields", "heads", "Flags", "locks"], "bs": ["ctx", "js", "gs", "ls", "bb", "hz", "rs", "bits", "bc", "box", "bo", "bes", "blog", "sb", "vs", "outs", "bp", "bis", "ps", "fs", "ds", "b", "cs", "bm", "ts", "ib", "aos", "bolt", "bh", "bl", "BS", "ubs", "ns", "pb", "its", "socket", "bps", "obs", "base", "bf", "sys", "bos", "os", "lbs", "bd", "bus", "bec", "boot", "cb", "bn"], "drv": ["vrvr", "drvd", " drV", " drva", "derv", "drva", "srv", "srvs", "drj", "rdV", "rdv", " drb", " drvr", "hrV", "derb", "srva", "drV", "darv", "vrb", " drvd", "darvs", "drvr", "drvs", "vrvd", "dervr", "drm", "hrj", "srvd", "vrv", "drb", " drvs", "hrv", "hrm", "darvd", " drj", "dervd", "rdj", "darva", "rdm", " drm"], "waited": ["watisted", "watitted", "awaitted", "awaits", "Waisted", "Waitted", "awitted", "awaiter", "waitable", "waisted", "awaisted", "watiter", "awited", "Waiter", "Waitable", "awiter", "wits", "Waits", "watitable", "awaitable", "watited", "awaired", "wited", "waired", "watired", "awaited", "witer", "waits", "awired", "waiter", "waitted", "Waited", "witted"], "ret": ["reset", "done", "sent", "data", "alt", "Return", "ter", "tr", "Ret", "tech", "tmp", "fit", "selected", "it", "rem", "result", " Ret", "rt", "found", "pret", "lit", "nt", "flag", "print", "t", "ft", "res", "reg", "set", "lt", "rev", "ref", "re", "il", "resp", "out", "len", "ll", "mem", "rets", "gt", "arr", "local", "err", "elt", "RET", "sat", "mt", "cont", "val"], "max_transfer": ["max2download", "max_trans", " max_write", "maxusertransfer", " max2transfer", " max_download", "maximum_transform", " max_trans", "max2transfer", "max2Transfer", " max2download", "max_transform", "maximum_response", "maxuserresponse", "maxusersend", " max2Transfer", "max_download", " max_Transfer", "max_response", "max_write", "maxusertransform", "max_send", "maximum_send", "max_Transfer", "maximum_transfer"]}}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393, "substitutes": {"bs": ["js", "gs", "ls", "bb", "rs", "bits", "bc", "blog", "bes", "sb", "vs", "outs", "bp", "bis", "ps", "fs", "ds", "b", "ms", "cs", "bm", "iss", "ts", "ss", "ubis", "aos", "aus", "ubs", "BS", "ns", "pb", "lb", "its", "boxes", "hs", "bps", "obs", "sts", "sys", "bos", "ats", "os", "lbs"], "sector_num": ["ector_num", "sector0mon", "sectorNamemaster", "ser_loc", " sector_master", "sectorNamenom", "sector_master", "ser_num", "ser_number", "sector_loc", "ector_nam", "sector_mon", "ector_number", "sector_nam", "sector0loc", "sectoritynum", "sector_nom", "ector_mon", "ser_mon", "sectoritymaster", " sector_mon", "sector0num", " sector_nom", "sector_number", "sectoritynom", "sectorNamenum", "sector0number", "sectorNamemon", "sectoritymon", "sectoritynam", "sectoritynumber"], "buf": ["ctx", "uf", "num", "data", "nb", "bar", "np", "bits", "seq", "pad", "bc", "length", "bin", "tmp", "padding", "xff", "bp", "br", "Buffer", "bytes", "rw", "lim", "blocks", "BU", "b", "max", "proc", "doc", "buff", "raw", "cmd", "img", "db", "rb", "buffer", "msg", "vec", "pb", "read", "window", "off", "len", "cur", "Buff", "late", "h", "queue", "aka", "batch", "fb", "err", "cap", "block", "cv"], "nb_sectors": ["nb_pselements", "nb_SEgments", "nb_pellers", "nb_segments", "nb_psectors", "nb_vegs", "nb_vegments", "nb_seivers", "nb_vectors", "nb_vellers", "nb_leors", "nb_selements", "nb_lellers", "nb_SElements", "nb_eors", "nb_SEctors", "nb_peors", "nb_legs", "nb_mectors", "nb_meors", "nb_pseors", "nb_segs", "nb_psegments", "nb_eivers", "nb_lectors", "nb_veors", "nb_pegs", "nb_veivers", "nb_egments", "nb_ectors", "nb_SEors", "nb_meivers", "nb_seors", "nb_velements", "nb_pectors", "nb_megments", "nb_sellers"], "cb": ["ctx", "cp", "cfg", "CB", "callback", "erb", "eb", "nb", "bc", "conf", "ctrl", "sb", "tc", "gb", "wb", "bp", "nc", "conn", "dt", "cc", "etc", "fun", "b", "c", "fn", "fc", "cmd", "obb", "func", "db", "kb", "rb", "cd", "abb", "dc", "ck", "cli", "lb", "pb", "unc", "bf", "cf", "fb", "cv"], "opaque": ["iopaque", "hopaque", " opacement", "opcode", "iopcode", " opula", "potque", "opacity", "potent", "uppoch", "ompacity", "ipula", "operque", "hopent", "OPaque", "uppaque", "ompaque", "operula", "hopque", "OPus", "opsent", "opque", "epacement", "iopus", "iopque", "opsque", "OPque", "obaque", "epula", "epoch", "ompula", "ipacity", "opsacement", "operacity", "epaque", "ipque", "obcode", "potacement", "uppacement", "operaque", "opent", "opula", "obque", "opus", "OPcode", "ompque", "hopacement", "opsaque", "opacement", "potaque", "opoch", " opoch", "ipaque", "obus", "uppula"], "acb": ["ackib", "iacb", "iacnb", "accbb", "aubc", "Acbl", "abcb", "ackfb", "pacbb", "acbb", "acca", "acbar", "acl", "accp", "Acn", "acwb", "micbd", " cacwb", "aconB", " acw", " cacbc", "aicg", "acfb", "abcbd", "abor", "accbc", "auwb", "ascB", "accwb", "acafb", "abob", "accb", "aicb", "aicob", "abf", "facb", "acab", "acib", "accnb", "micob", "aconp", "pacib", "ainl", "ascpb", "acp", "pacfb", "abcob", "acob", "acor", "abbd", "Acbd", "ackb", "acnb", " acp", "ocB", " acl", "abb", " cacbr", "aconbar", "acba", "accbd", "aclwb", "acbc", "micbl", "ocb", "facob", " acbar", "aconb", "acg", "iacgb", "ocba", "accgb", "acpb", "ascb", "ainbe", "acw", "accba", "accB", "Acnb", "acbl", " acpb", "Acgb", "aclbe", "aconw", "aconbb", "aclb", " acB", "pacb", " acbe", "acbr", "acbd", "aconbd", " acwb", "accn", "acB", "facor", "acgb", "aconpb", "micb", " cacb", "ainwb", "acbe", "ocbb", "aub", "aicor", "acn", "acabb", "facg", "accf", "acaib", "aba", "Acb", "accbr", "accw", "ackbb", "aconba", "acona", "aubr", "aconf", "ainb", "iacn", "acll", "ascbar", "abg", "acf", "abcbl", "aca", "Acob"], "s": ["js", "gs", "ls", "sq", "p", "es", "rs", "bits", "sb", "vs", "ps", "n", "fs", "ds", "cs", "ts", "ses", "ss", "stats", "g", "ns", "ins", "its", "hs", "sts", "http", "xs", "sys", "ats", "os", "S", "als", "is"], "bh": ["ha", "hi", "kh", "hr", "ssl", "zh", "hz", "fw", "oh", "ih", "mu", "bp", "br", "ph", "ah", "bis", "phy", "ht", "b", "dh", "rh", "sh", "hap", "lr", "bm", " inh", "hun", "orth", "bt", "gh", "oth", "uh", "eh", "shr", "igh", "bl", "sbm", "phi", "hp", "thro", "lb", "bol", "hs", "hh", "hal", "ith", "hl", "bf", "rl", "h", "hw", "bec", "hub", "bo"]}}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n", "idx": 23405, "substitutes": {"child": ["close", "q", "parent", "entry", "handler", "shell", "brother", "test", "b", "c", "root", "j", "node", "i", "kid", "col", "pc", "create", "sim", "client", "count", "window", "job", "handle", "row", "ind", "ch", "ach", "h", "x", "Child", "children", "block", "f", "cell", "v"], "sector_num": ["sector_index", "sectoretymon", "sector___num", "sector___nr", "sectoretynumber", "sectoretyindex", "sectoretynum", "sector___index", "sector___number", "sector_mon", " sector_index", " sector_number", " sector_mon", "sector_number", "sector_nr", " sector_nr"], "nb_sectors": ["nb_spevers", "nb_seeivers", "nb_perseors", "nb_neivers", "nb_serers", "nb_persecs", "nb_persectors", "nb_speors", "nb_severs", "nb_vevers", "nb_verers", "nb_nectors", "nb_nerers", "nb_seearers", "nb_seivers", "nb_speivers", "nb_vesputers", "nb_vectors", "nb_vellers", "nb_spellers", "nb_speputers", "nb_sellers", "nb_spearers", "nb_specs", "nb_searers", "nb_perserers", "nb_secs", "nb_nellers", "nb_vescs", "nb_spectors", "nb_vesctors", "nb_necs", "nb_seectors", "nb_veors", "nb_vecs", "nb_seputers", "nb_vesors", "nb_seeors", "nb_seors", "nb_nearers", "nb_neors", "nb_nevers", "nb_veputers"], "qiov": ["qiour", " quiov", "iqiour", "qiev", "sqovi", "sqiov", "iqrov", "ckiour", " qurov", "ckiev", " quiour", "iqiva", "Qiour", "ckovi", " qiva", "qrov", "qiva", " quiva", "iqiov", "Qiev", " qrov", "Qovi", "ckiov", "sqiour", "qovi", " qiour", "Qiov", "sqiev"], "flags": ["alf", "acts", "comments", "FLAG", "posts", "bits", "rates", " winds", "details", "ads", "tags", " futures", "lag", "alities", " signs", "weights", "bugs", "phones", "files", "settings", "limits", " fps", "flag", "cmd", " lands", "utils", "faces", "tif", " heads", "cond", " concerns", " interests", "atts", " styles", "members", "xf", "fits", " feats", "ags", "options", " Flags", "fps", " quirks", "ents", " seeks", "heads", "Flags", "locks"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void sigchld_handler(int signal)\n\n{\n\n    qemu_bh_schedule(sigchld_bh);\n\n}\n", "idx": 23411, "substitutes": {"signal": [" signaler", " signals", "Signal", " signalal", "signals", "Signaler", "signaler", "Signals", " signalals", " signalaler"]}}
{"project": "FFmpeg", "commit_id": "b3f9f7a33337e9b64e6044b0010e2722fa0b2f9c", "target": 0, "func": "static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)\n\n{\n\n    MpegTSFilter *tss;\n\n    PESContext *pes;\n\n\n\n    /* if no pid found, then add a pid context */\n\n    pes = av_mallocz(sizeof(PESContext));\n\n    if (!pes)\n\n        return 0;\n\n    pes->ts = ts;\n\n    pes->stream = ts->stream;\n\n    pes->pid = pid;\n\n    pes->pcr_pid = pcr_pid;\n\n    pes->stream_type = stream_type;\n\n    pes->state = MPEGTS_SKIP;\n\n    pes->pts = AV_NOPTS_VALUE;\n\n    pes->dts = AV_NOPTS_VALUE;\n\n    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);\n\n    if (!tss) {\n\n        av_free(pes);\n\n        return 0;\n\n    }\n\n    return pes;\n\n}\n", "idx": 23425, "substitutes": {"ts": ["ctx", "js", "tv", "tes", "tp", "ls", "te", "bs", "rs", "tis", "td", "tr", "tt", "kt", "times", "TS", "tc", "ps", "tar", "tm", "fs", "ims", "ds", "ms", "wt", "s", "cs", "tx", "ss", "stats", "pt", "t", "utt", "pc", "ns", "mint", "mos", "Ts", "tim", "sts", "tz", "sys", "ats", "aps", "uts", "mt"], "pid": ["temp", "pkg", "perm", "p", "pp", "mk", "pr", "id", "bid", "type", "port", "pe", "path", "pd", "pan", "ps", "pard", "fd", "wid", "phy", "png", "pse", "proc", "pin", " PID", "po", "pt", "pty", "pos", "phys", "pipe", "db", "pc", "pa", "key", "pen", "pri", "ping", "sid", "process", "ppa", "pic", "por", "oid", "pi", "uid", " tid", "part", "pai", "PK", "mid", "vid", "pg"], "pcr_pid": ["pcr_pa", "pcr_pi", "pcr_ps", "pcr_pos", "pcr_port", "pcm_id", "pcm_sid", "ptr_pi", "ptr_pos", "ptr_pc", "pcr_id", "ptr_pid", "ptr_pa", "pcm_ps", "pcr_pc", "pcm_pid", "ptr_port", "pcr_sid"], "stream_type": ["stream_color", "stream3comment", "stream_types", "stream_Type", "stream_key", "port_types", "port_name", "stream3type", " stream_handle", " stream_ype", " stream_Type", "stream_name", " stream_types", "stream_comment", "port_type", " stream_comment", "stream_ype", "port_color", " stream_key", "stream3types", "stream3ype", "stream_handle"], "tss": ["tst", "TSS", "pst", "piss", "pcss", "wtss", "mcss", " tSS", " trss", "Tiss", "pse", " tse", "mse", "Tss", " tcss", "prss", "tiss", "tSS", "wtSS", "trss", "wtrss", "pSS", "mrss", " tiss", "pss", "wtiss", "tse", "mss", " tst", "wtst", "Trss", "tcss"], "pes": ["ples", "ips", "amps", "params", "las", "phis", "pe", "pps", "types", "ques", "packs", "aus", "phys", "projects", "ins", "oples", "ees", "ites", "mes", "Types", "photos", " pas", "es", "posts", "kes", "ces", "vs", "lists", "ps", "pet", "pse", "mas", " pets", "lets", "cas", "maps", "xes", "eas", "pots", "ames", "ports", "aps", "pas", "locks", "pins", "ape", " pops", "ges", " peas", "pex", "eps", "plings", "odes", "lex", "PE", "ses", "ves", "ducers", "pha", "ers", "GES", " cups", "men", "pres", "ists", "pers", "ped", "mits", "Ps", " ps", "pl", "phones", "inces", "edes", "plates", "anes", "plugins", "makes", "elines", "qs", "ettes", "xs", "vals"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void mpeg_motion_internal(MpegEncContext *s,\n\n                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                 int field_based, int bottom_field, int field_select,\n\n                 uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                 int motion_x, int motion_y, int h, int is_mpeg12, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int dxy, uvdxy, mx, my, src_x, src_y,\n\n        uvsrc_x, uvsrc_y, v_edge_pos;\n\n    emuedge_linesize_type uvlinesize, linesize;\n\n\n\n#if 0\n\nif(s->quarter_sample)\n\n{\n\n    motion_x>>=1;\n\n    motion_y>>=1;\n\n}\n\n#endif\n\n\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    src_x = s->mb_x* 16               + (motion_x >> 1);\n\n    src_y =(   mb_y<<(4-field_based)) + (motion_y >> 1);\n\n\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n\n        if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){\n\n            mx = (motion_x>>1)|(motion_x&1);\n\n            my = motion_y >>1;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        }else{\n\n            uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n\n            uvsrc_x = src_x>>1;\n\n            uvsrc_y = src_y>>1;\n\n        }\n\n    }else if(!is_mpeg12 && s->out_format == FMT_H261){//even chroma mv's are full pel in H261\n\n        mx = motion_x / 4;\n\n        my = motion_y / 4;\n\n        uvdxy = 0;\n\n        uvsrc_x = s->mb_x*8 + mx;\n\n        uvsrc_y =    mb_y*8 + my;\n\n    } else {\n\n        if(s->chroma_y_shift){\n\n            mx = motion_x / 2;\n\n            my = motion_y / 2;\n\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n\n        } else {\n\n            if(s->chroma_x_shift){\n\n            //Chroma422\n\n                mx = motion_x / 2;\n\n                uvdxy = ((motion_y & 1) << 1) | (mx & 1);\n\n                uvsrc_x = s->mb_x* 8           + (mx >> 1);\n\n                uvsrc_y = src_y;\n\n            } else {\n\n            //Chroma444\n\n                uvdxy = dxy;\n\n                uvsrc_x = src_x;\n\n                uvsrc_y = src_y;\n\n            }\n\n        }\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if(   (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0)\n\n       || (unsigned)src_y > FFMAX(   v_edge_pos - (motion_y&1) - h , 0)){\n\n            if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n               s->codec_id == AV_CODEC_ID_MPEG1VIDEO){\n\n                av_log(s->avctx,AV_LOG_DEBUG,\n\n                        \"MPEG motion vector out of boundary (%d %d)\\n\", src_x, src_y);\n\n                return;\n\n            }\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize,\n\n                                17, 17+field_based,\n\n                                src_x, src_y<<field_based,\n\n                                s->h_edge_pos, s->v_edge_pos);\n\n            ptr_y = s->edge_emu_buffer;\n\n            if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n                uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize;\n\n                s->vdsp.emulated_edge_mc(uvbuf ,\n\n                                    ptr_cb, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                s->vdsp.emulated_edge_mc(uvbuf+16,\n\n                                    ptr_cr, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                ptr_cb= uvbuf;\n\n                ptr_cr= uvbuf+16;\n\n            }\n\n    }\n\n\n\n    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data\n\n        dest_y += s->linesize;\n\n        dest_cb+= s->uvlinesize;\n\n        dest_cr+= s->uvlinesize;\n\n    }\n\n\n\n    if(field_select){\n\n        ptr_y += s->linesize;\n\n        ptr_cb+= s->uvlinesize;\n\n        ptr_cr+= s->uvlinesize;\n\n    }\n\n\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n\n\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n\n    }\n\n    if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n\n         s->out_format == FMT_H261){\n\n        ff_h261_loop_filter(s);\n\n    }\n\n}\n", "idx": 23429, "substitutes": {"s": ["ctx", "js", "m", "gs", "spec", "ls", "q", "p", "sq", "es", "rs", "z", "bs", "details", "conf", "times", "w", "d", "sb", "vs", "sports", "n", "ps", "sc", "fs", "ims", "ds", "b", "ms", "c", "cs", "er", "r", "as", "sw", "ts", "ses", "ss", "i", "stats", "t", "aws", "less", "set", "g", "https", "ns", "sim", "ins", "its", "changes", "webkit", "hs", "e", "source", "sts", "sv", "qs", "http", "sys", "se", "os", "ats", "S", "ex", "is", "v", "comm"], "dest_y": ["src_yy", "dest_yy", "src_xy", "dest_Y", "src_Y", "dest_xy"], "dest_cb": ["dest_ca", "dest___rb", "dest___cb", "src_cm", "src_cb", "dest___ca", "dest_rb", "dest___cm", "dest_cm", "src_rb", "src_ca"], "dest_cr": ["dest2r", "dest_cd", "src_cr", "dest2rx", "src_cd", "src_rx", "dest2cd", "dest_rx", "dest2cr", "src_r", "dest_r"], "field_based": ["FIELD_linked", "FIELD_checked", "rule_relative", "fieldableBased", "fieldvallisted", "fieldlyrelative", "field_backed", "Field_basic", "field_listed", "field08base", "fieldvalspecified", "field08linked", "fieldlerelative", "field_specified", "field____base", "field_bid", "rulevalrelative", "FIELD_backed", "field_linked", "field_bas", "field8base", "field2relative", "field____based", "field_relative", "field08based", "field2based", "fieldlyspecified", "field2basic", "rulevalspecified", "fieldlylisted", "fieldvalbased", "FIELD_bas", "FIELD_bid", "Field_based", "FIELD_used", "field8backed", "field____relative", "FIELD_base", "fieldvalrelative", "FIELD_fed", "field____basic", "rule_specified", "field8linked", "FIELD_bent", "field_Based", "fieldlybased", "fieldlebased", "fieldablechecked", "fieldablebas", "Field_relative", "field_used", "fieldlespecified", "field_basic", "fieldablebased", "fieldlebas", "field_checked", "field8based", "Field_base", "field_base", "fieldlelisted", "fieldleBased", "rule_based", "field_bent", "field08backed", "rulevallisted", "fieldlechecked", "FIELD_Based", "field_fed", "FIELD_based", "field2base", "rulevalbased", "rule_listed"], "bottom_field": ["orderletfield", "bottomletweight", "bottomwaterweight", "orderletmargin", "bottomlevelformat", "order_format", "orderletformat", "orderletweight", "bottomletformat", "bottom_weight", "bottomlevelweight", "order_weight", "bottomletmargin", "bottomletfield", "bottomwaterfield", "order_field", "bottomwaterformat", "bottomlevelfield", "order_margin", "bottomlevelmargin", "bottomwatermargin", "bottom_margin", "bottom_format"], "field_select": ["Field_select", "fieldityselected", "Field_selection", "fieldityselect", "fieldityselection", "field_selected", "Field_selected", "fielditysupported", "field_supported", "field_selection", "Field_supported"], "ref_picture": ["refgcamera", "img_image", "img_picture", "refgrimage", "refgrcamera", "refgrpic", "img_camera", "ref_pic", "refgimage", "ref_image", "refgrpicture", "refgpic", "ref_camera", "img_pic", "refgpicture"], "pix_op": ["pix___oper", "pix2info", "pix___info", "pixels2op", "pix_oper", "pixels2comp", "pixels_oper", "pix___op", "pix___comp", "pixels2oper", "pix_comp", "pix_info", "pix2comp", "pix2op", "pixels_comp", "pixels2info", "pixels_op", "pix2oper", "pixels_info"], "motion_x": ["prop_X", "motion_w", "motion___xi", "movie___x", "motion03ax", "motion03x", "motion___ex", "vision09x", "music_xd", "motion03y", "motion09x", "music09el", " motion_z", "motion___x", "movie___xi", "prop_rx", "vision_ex", "movie_ax", "vision_x", "motion09ex", "motionTimexml", "movie___y", "motionTimerx", "loss_y", "motion____x", "motion09xf", "vision09ex", "music_el", "motion____y", "music09xd", "motionTimex", "motion09xd", "motion____xx", "motion_X", "loss_num", "prop_x", "Motion_xi", "motion_xi", "movie_x", "loss_x", "motionTimeX", "motion_num", "propTimexml", "motion_xf", "vision09xf", "loss_xx", "propTimeX", "motion___y", "motion09y", " motion_w", "motion_ax", "vision_y", "motion03xi", "motion_rx", "propTimerx", "motion09el", "motion____num", "music_x", "prop_xml", "movie___ax", "music09y", "music09x", "music_y", "vision09y", "vision_xf", "motion_xd", "Motion_ex", "movie_y", "motion___ax", "motion_z", "Motion_x", "movie_xi", "motion_ex", "motion_xml", "motion_el", "propTimex", "Motion_y", "motion_xx"], "motion_y": ["motion_Y", "motion_p", "motion00Y", "mission_x", "motion00ey", " motion_ny", "mission08z", "motion08y", "position_yy", "detail00ey", "mission_y", "motion00cy", "movie_yy", "motion_ny", "mission_z", "position_y", "detail_y", "motion10yy", "motion10y", "position_sy", " motion_cy", "movie_x", "movie_sy", "motion______y", "mission08y", "motion00y", "motion08z", "motion00z", "mission08x", "position_ny", "detail_entity", "motion______ny", "motion_sy", " motion_yy", "detail00z", "motion______yy", " motion_entity", "motion_yy", "motion08p", "mission08p", "mission_p", "motion10ny", "motion______x", "motion_entity", "detail00entity", "motion00entity", "movie_y", "detail_ey", "motion_z", "motion10sy", "detail00y", "detail_z", " motion_Y", "motion_ey", "motion08x", "motion_cy"], "h": ["m", "height", "kh", "q", "p", "hz", "z", "oh", "ih", "w", "it", "l", "b", "c", "i", "t", "bh", "H", "k", "hash", "hh", "hs", "e", "ch", "hw", "f", "v"], "is_mpeg12": ["is__peg12", "is_mp12", "is_cam11", "is__peg2", "is_video8", "is__mpeg8", "is_peg8", "is__mpeg2", "is__mpeg12", "is_peg2", "is_cam2", "is_mpeg23", "is_video2", "is_video12", "is_mpeg8", "is_peg12", "is_mp8", "is_mpeg11", "is_mpeg2", "is_peg11", "is_video11", "is_peg23", "is_mp2", "is_cam23", "is_video23", "is_cam12", "is__peg8"], "mb_y": ["mb______cy", "mboey", "src64cy", "mb64yl", "mb08ym", "mb_py", "mb_sy", "MB_ym", "MB_ye", "src_cy", "MB_py", "mb_ym", "mb08yy", "mb_yl", "mb______yl", "mb8py", "MB8yy", "src64sy", "mb64sy", "mb______y", "mb00sy", "mb8yy", "src64y", "mb64cy", "mb_ye", "mb64y", "mb08ye", "mb8y", "mboxy", "mb_yy", "mb00yl", "mboepy", "MB_y", "MB8py", "src_sy", "mb______sy", "MB8y", "mb08y", "mb_cy", "MB_yy", "mboxpy", "mb8Y", "src_yl", "mb00cy", "mboxyy", "mboxY", "mboeyy", "mb_Y", "MB8Y", "mb00y", "src64yl", "MB_Y", "mboeY"], "ptr_y": ["ptr_ye", "ptr00y", "ptr_yy", "dest_yy", "ptr00xy", "ptr_xy", "dest_ye", "dest_xy", "ptr00ye", "ptr00yy"], "ptr_cb": ["ptr_rb", "dest_cgi", "ptr48cb", "ptr___cb", "ptr___cy", "ptr_cgi", "ptr48cy", "ptr_cy", "ptr48cgi", "ptr___rb", "dest_rb", "ptr___cgi", "ptr48rb", "dest_cy"], "ptr_cr": ["ptr_cd", "ptr55col", "ptr55ctr", "ptr_ctr", "ptr55cd", "dest_cd", "ptr_col", "ptr__cr", "ptr__col", "dest_ctr", "ptr__ctr", "dest_col", "ptr__cd", "ptr55cr"], "dxy": ["pdbits", "bdux", " dbits", "Doxy", "Dxy", "pdxf", "odwx", "fdxy", "sdxy", "pdoxy", "dux", "DXY", "bdwy", "bdoxy", "dwx", "sdoxy", "fdxf", "dXY", "odxy", " doxy", "fdoxy", "sdwy", " dxf", "odoxy", "bdXY", " dXY", "sdwx", "odwy", "pdxy", "doxy", "fdbits", " dux", "dwy", "bdxy", "dxf", "Dux", "bdwx", "dbits"], "uvdxy": ["uvdhxx", "uvdsaxy", "uvddj", "uvdiffaxy", "uvdhaxy", "nvdgb", "nvdbits", "uvdgb", "uvdtbits", "uvddgb", "uvdxx", "uvdhbits", "uuhdgb", "uvdhgb", "uvhdgb", "uvdddj", "uvddxy", "uvdiffXY", "uvdwy", "nvdhbits", "uvdXY", "uuhdcho", "uvdhXY", "uvdhwy", "uvhdcho", "uudxy", "uvmdcho", "uvdhxy", "ukdiffXY", "uvdbits", "ukdiffxy", "ukdxx", "nvdhgb", "uvdsxx", "ukdXY", "uudwy", "uvdcho", "uuhdxy", "uvdhdj", "uvdtxy", "nvdhxy", "uudcho", "uvdhcho", "uvdiffxy", "ukdiffxx", "uvdaxy", "ukdiffaxy", "nvddj", "uvhdxy", "uvmdgb", "uvmdxy", "uvdtdj", "uvddbits", "uvdsxy", "uvdsXY", "uvmdwy", "uuhdwy", "uvhdwy", "uvdiffxx", "nvdhdj", "uudgb", "uvdtgb", "nvdxy", "ukdaxy", "ukdxy"], "mx": ["m", "mo", "ox", "rx", "ias", "mm", "mr", "hz", "mie", "mk", "xx", "yx", "mn", "pm", "mic", "mys", "vm", "y", "py", "mc", "tm", "mp", "mi", "ms", "tx", "mmm", "axis", "mouse", "yy", "ux", "mint", "mis", "ey", "mb", "md", "ml", "MY", "xy", "nz", "xs", "x", "yz", "wx", "px", "wm", "mt", "MX"], "my": ["js", "ty", "m", "me", "ox", "MI", "mm", "mie", "mk", "xx", "yx", "fy", "mn", "pm", "mic", "mys", "y", "vy", "py", "mc", "mg", "mp", "mi", "ny", "ms", "mmm", "ys", "mouse", "yy", "mis", "mb", "md", "ml", "MY", "ram", "mem", "xy", "My", "x", "mon", "mid", "cy", "ami", "mt", "gy"], "src_x": ["source_xy", "src_dx", "mat", "def", "_", "source_ex", "src_ex", "src_xy", "source_x", "img", "func", "source_y", "jpg", "ref", "cam", "xy", "source_dx", "new"], "src_y": ["rc_ym", "source_Y", "src__yy", "rc_y", "rc_yy", "rc_x", "source_ys", "src__ym", "src_yy", "src_ym", "src__y", "source_ym", "source_y", "src_Y", "src__x", "src_ys"], "uvsrc_x": ["uvdest_php", "uvdest_X", "uvsource_z", "uvdest_x", "uvsource_x", "uvsrc_wx", "uvsrc_X", "uvsource_y", "uvsrc_xi", "uvsrc_z", "uvsrc___x", "uvsrc___dx", "uvsrc_dx", "uvsource_xi", "uvdest_y", "uvrc_x", "uvsrc___y", "uvsrc_php", "uvrc_wx", "uvsrc___wx", "uvrc_dx", "uvrc_y"], "uvsrc_y": ["uvsrc__py", "uvsyn_y", "uvsrc__x", "uvdest_x", "uvdest__x", "uvsrc__y", "uvsrc_n", "uvdest__yy", "uvdest__n", "uvsrc_yy", "uvsyn_py", "uvsrc__n", "uvsyn_x", "uvdest_y", "uvdest__y", "uvsrc_py", "uvsrc__a", "uvsyn_a", "uvsrc__yy", "uvsrc_a", "uvdest_n", "uvdest_yy"], "v_edge_pos": ["v_ge_Pos", "v_node_position", "v_ge_loc", "v_ge_pos", "v_edge_position", "v_edge_Pos", "v_ge_position", "v_node_Pos", "v_edge_loc", "v_node_loc", "v_node_pos"], "uvlinesize": ["uvineszie", "uvlinign", "uintlineszie", "uvinesensor", "uintineszie", "uvlinesign", " ovlinign", "uvlinszie", "uvlinzie", "uvlinksensor", "uvlinesiz", "uvlinscale", " ovlinescale", "uvbytesiz", "uvlinksize", "uvfieldsize", "uvlinesensor", "uvinesize", "uvfieldsign", " ovlinize", "uvlinkszie", "uvlinize", "uintlinesensor", "uintlinesiz", "uvlinsign", " ovlinzie", " ovlinesize", "uvlinksiz", "uvbytesize", "uvfieldszie", " ovlinesign", "uvbyteszie", "uintlinesize", "uvlineszie", "uvlincale", "uintinesensor", "uvfieldscale", "uintinesize", "uvbytesensor", "uvlinescale", "uvlinsize", "uintinesiz", "uvinesiz", " ovlineszie", " ovlincale"], "linesize": ["pagesize", "linesiz", "inesizes", " linesze", "boardsization", "codesiz", "linesization", "framesizes", "linesze", "codessize", " linesization", " linesizes", "inessize", "boardsizer", "elinesiz", "framesization", "linesIZE", "elinesize", "linessize", "platesization", "codesizer", "framesIZE", "inesization", " linesIZE", "boardsize", "linesizes", "elinesizes", "pagesiz", "linesizer", "pagesizer", " linesiz", "platessize", "inesizer", "platesizer", "elinesze", "framesize", "platesize", "boardssize", "boxesize", "codesize", "pagessize", "inesiz", "boxesizes", "inesze", "boxesization", "inesize", "boxesIZE"]}}
{"project": "qemu", "commit_id": "79afc36d91be7550affbe7db227b4552451da41d", "target": 0, "func": "static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n", "idx": 23455, "substitutes": {"cpu": ["cp", "pkg", "gc", "ilo", "tp", "hz", "linux", "jp", "CPU", "util", "mu", "conn", "copy", "vm", "phy", "xi", "cum", "uu", "proc", "c", "core", "gpu", "mac", "aux", "thread", "processor", "node", "net", "prof", "phys", "pc", "met", "cat", "ck", "process", "cu", "gp", "comp", "kernel", "hw", "clock", "pai", "alloc", "pu", "ct"], "config_change": [" config_conf", " config_edit", "conf_add", "config08change", "configogalter", "conf_alter", "config2check", "configletchange", "config2change", "config08check", " config2change", "config_conf", "configogchange", " config2conf", "conf_change", " config_check", "config_check", " config2edit", "config_add", "configogadd", "config08conf", "config2edit", "configletadjust", "configletedit", "config_adjust", "config2conf", " config2check", " config_adjust", "config_edit", "config08edit", "config_alter"], "token": ["oken", "temp", "TO", "serial", "json", "state", "at", "seed", "length", "password", "util", "tag", "tree", "typ", "fd", "amount", "status", "ti", "strength", "wt", "lock", "ok", "scan", "tk", "template", " key", "node", "KEN", " random", "auth", "t", "round", "secret", "tn", "key", "msg", "txt", "total", "session", "sid", "number", "channel", "event", "time", "Token", "local", "policy", "rule", "index", "batch", "tty", "stick"]}}
{"project": "FFmpeg", "commit_id": "dde0af2df1caffb9e33855c08fc691dbbbbc72b3", "target": 0, "func": "static int vble_unpack(VBLEContext *ctx, GetBitContext *gb)\n\n{\n\n    int i;\n\n    static const uint8_t LUT[256] = {\n\n        8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n    };\n\n\n\n    /* Read all the lengths in first */\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* At most we need to read 9 bits total to get indices up to 8 */\n\n        int val = show_bits(gb, 8);\n\n\n\n        // read reverse unary\n\n        if (val) {\n\n            val = LUT[val];\n\n            skip_bits(gb, val + 1);\n\n            ctx->len[i] = val;\n\n        } else {\n\n            skip_bits(gb, 8);\n\n            if (!get_bits1(gb))\n\n                return -1;\n\n            ctx->len[i] = 8;\n\n        }\n\n    }\n\n\n\n    /* For any values that have length 0 */\n\n    memset(ctx->val, 0, ctx->size);\n\n\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* Check we have enough bits left */\n\n        if (get_bits_left(gb) < ctx->len[i])\n\n            return -1;\n\n\n\n        /* get_bits can't take a length of 0 */\n\n        if (ctx->len[i])\n\n            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23465, "substitutes": {"ctx": ["cp", "pkg", "ca", "conf", "bc", "ctrl", "xc", "tc", "conn", "nc", "mc", "cc", "fc", "bm", "kw", "tx", "cmd", "ref", "cv", "setup", "obj", "context", "conv", "cf", " context", "cmp", " cx", "rc", "ct"], "gb": ["cfg", "gc", "gs", "eg", "bc", "gm", "sb", "uk", "vm", "gpu", "GB", "lib", "storage", "ig", "img", "kb", "db", "g", "vg", "bg", "mb", "BG", "bf", "gt", "fg", "rg", "sg", "cb", "cv"], "i": ["m", " l", "p", " e", " bi", " offset", "b", " t", " b", " v", "j", "t", " I", " ii", "li", " d", " j", " n", " m", "bi", " c", "ii", "M", "pi", "I", " M", "v", " pi"], "LUT": ["BLUB", "BLUN", "HUT", "LUB", " Lut", "BLut", "Hut", " LUN", "Lut", "HUB", "BLUT", "LUN", " LUB", "HUN"]}}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "int ffurl_alloc(URLContext **puc, const char *filename, int flags,\n\n                const AVIOInterruptCB *int_cb)\n\n{\n\n    URLProtocol *up = NULL;\n\n    char proto_str[128], proto_nested[128], *ptr;\n\n    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n\n\n\n    if (filename[proto_len] != ':' || is_dos_path(filename))\n\n        strcpy(proto_str, \"file\");\n\n    else\n\n        av_strlcpy(proto_str, filename,\n\n                   FFMIN(proto_len + 1, sizeof(proto_str)));\n\n\n\n    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n\n    if ((ptr = strchr(proto_nested, '+')))\n\n        *ptr = '\\0';\n\n\n\n    while (up = ffurl_protocol_next(up)) {\n\n        if (!strcmp(proto_str, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n\n            !strcmp(proto_nested, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n    }\n\n    *puc = NULL;\n\n    return AVERROR_PROTOCOL_NOT_FOUND;\n\n}\n", "idx": 23470, "substitutes": {"puc": ["punc", " punc", "cunc", "hoc", "ccu", " pud", "huc", "nuu", " puu", "poc", "vcu", "pcon", "hunc", "vuc", "cbc", "cuu", "mcon", "hud", "coc", "pcu", " poc", "cuc", "huu", "vud", "hcu", "pbc", "nunc", " pcon", "nuc", "noc", "pud", " pcu", " pbc", "ccon", "munc", "vuu", "puu", "muc", "mbc"], "filename": ["ename", "dir", "json", "tp", "family", "file", "lua", "wikipedia", "via", "name", "microsoft", "til", "path", "length", "nm", "folder", "nil", "journal", "wit", "src", "strings", "n", "fd", "river", "fs", "original", "png", "mpeg", "prefix", "ame", "files", "fn", "utf", "wav", "username", "fil", "location", "cmd", "origin", "ren", "directory", "uri", "jpg", "txt", "position", "names", "Filename", "subject", "buf", "ames", "wcs", "source", "fle", "title", "aka", "binary", "kj", "fp", "f", "FIL"], "flags": ["pins", "acts", "hips", "comments", "FLAG", "ints", "bits", "posts", "amps", "xxx", "tags", "lag", "ants", "endif", "links", "ods", "weights", "includes", "parts", "states", "types", "fs", "bugs", "status", "ensions", "aints", "limits", "groups", "terms", "flag", "licts", "utils", "func", "faces", "tif", "args", "stats", " concerns", "cond", "uses", "atts", "members", "doms", "fts", "ags", "actions", "frames", "options", "features", "ports", " Flags", "issues", "wcs", "planes", "levels", "cf", "fps", "properties", "caps", "fields", "heads", "Flags", "locks", "rights"], "int_cb": ["int_abb", "int11conn", "int___cb", "int__conn", "int_erb", "int11callback", "int10obb", "int10pb", "int10cb", "int_obb", "int___conv", "int_conv", "int__erb", "int_conn", "int11cb", "int10callback", "int11erb", " int_conv", " int_pb", " int_obb", "int__cb", "int___callback", "int___abb", " int_conn", "int__callback", " int_abb", " int_erb", "int_callback", " int_callback", "int_pb"], "up": ["uph", "cp", " u", "pkg", "high", "uf", "ra", "p", " ups", "rup", "ub", "upp", "own", "ex", "sup", "jp", "user", "um", "low", "ups", "ps", " Up", "pper", " down", "mp", "wp", "ou", "UP", "du", "ow", "vp", "uv", "cap", "uc", "in", "through", "home", "u", "upload", "U", "dem", "ump", "ul", "ip", "ud", "ux", "over", "ap", "prom", "uper", "upper", "upid", "out", "plus", "all", "au", "flow", "upt", "omp", "pre", "ouch", "op", "local", "adv", "down", " UP", "cmp", "Up", " upl", "prov"], "proto_str": ["propo_char", "proto__str", "proto_dr", "proto__dr", "protu_tree", "proto_def", "proto___string", "protu_arr", "propo2char", "proto_tree", "propo2str", "proto2string", "proto2char", "propo_string", "proto_del", "proto__string", "proTo_str", "proto_arr", "proto_ctr", "proto2ctr", "propo2ctr", "proto___str", "proto_string", "proto_char", "proto___div", "protu_str", "proto_r", "proTo_string", "proto__div", "proTo_r", "proTo_arr", "proto_div", "proto2str", "propo_ctr", "propo_str", "proto__br", "protu_del", "propo2string", "proto_br"], "proto_nested": ["proto_ngested", "proto_Nesting", "proto_pashed", "proto_norached", "proto_tored", "proto2norest", "proto_nanEST", "proto_pest", "proto_Nained", "proto_nanesting", "proto2norained", "proto_ngesting", "proto_test", "proto_tested", "proto_tumbered", "proto_nanest", "proto_cnesting", "proto_Nest", "proto_nesting", "proto2noresting", "proto_enesting", "proto_NEST", "proto_norested", "proto_testing", "proto2nained", "proto_neest", "proto_noresting", "proto_norest", "proto_tEST", "proto_cashed", "proto_nashed", "proto_cnained", "proto_ngest", "proto_cnest", "proto_enest", "proto_nest", "proto_tached", "proto_Nested", "proto_pested", "proto_nanested", "proto_nached", "proto_neashed", "proto_numbered", "proto_cnested", "proto_nained", "proto2nest", "proto_pached", "proto_cested", "proto_cest", "proto_nored", "proto2nesting", "proto2nested", "proto_ngored", "proto2norested", "proto_pumbered", "proto_norumbered", "proto_nEST", "proto_norained", "proto_enored", "proto_enested", "proto_neested"], "ptr": ["pointers", "tp", "p", "adr", "pr", "pad", "tr", "loc", "jp", "bp", "br", "src", "ps", "fr", "offset", "dest", "attr", "rep", "lr", "proc", "address", "r", "ts", "iter", "dr", "pt", "pointer", "pos", "t", "prime", "bl", "buffer", "vr", "ref", "cur", "buf", "next", "len", "Ptr", "ctr", "mem", "arr", "str", "inters", "addr", "fp", "alloc", "rel", "th"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n", "idx": 23491, "substitutes": {"bs": ["js", "gs", "acts", "ls", "bb", "rs", "ths", "bc", "bes", "sb", "vs", "gb", "bp", "bis", "fs", "ds", "ms", "cs", "bm", "ts", "ses", "ss", "aus", "aos", "ubs", "BS", "bg", "ns", "cks", "bn", "its", "ks", "bps", "bi", "obs", "sts", "qs", "xs", "bos", "ats", "lbs", "ashes"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n", "idx": 23495, "substitutes": {"opaque": ["opena", "opacity", "ospacted", "opacted", "openque", "opque", "openaque", " opacity", "obaque", "ropacted", " opacted", "openacity", "obacity", "ospaque", "obque", "ropaque", "ropesh", " opque", "ospesh", "opa", " opa", "opesh", " opesh", "oba"], "addr": ["ctx", "ix", "add", "adr", "rs", "name", "pad", "tr", "id", "loc", "ptr", "ace", "tag", "src", " address", "offset", "attr", "dh", "prefix", "rt", "address", "tx", "ord", "cmd", "host", "dr", "act", "pos", "map", "ar", "res", "align", "hash", "coord", "eth", "arg", "ress", "arr", "x", "err", "alloc", "ad", "mt", "ack", "v"], "val": ["ctx", "Value", "num", "vt", "add", "data", "p", "ival", "alt", "slot", "unit", "value", "prop", "it", "test", "bit", "ret", "vol", "VAL", "tx", " v", "serv", "lit", " arg", " value", "pt", "pos", "eval", "res", "reg", "Val", "key", "txt", "ref", "vec", " buf", "resp", "buf", "len", "arg", "au", "mem", "arr", "index", "x", "xy", "cal", "vals", "fee", "err", "valid", " eval", "v"], "size": ["num", "data", "z", "name", "type", "SIZE", "length", "unit", "Size", "n", "offset", "l", "address", "act", "args", "area", "count", "len", "e", "mem", "h", "ize", "weight", "fee", "cap", "v"], "s": ["js", "gs", "m", "comments", "spec", "sl", "ls", "sq", "p", "es", "rs", "bs", "params", "details", "w", "sb", "sol", "vs", "parts", "ps", "bis", "eps", "fs", "sm", "ds", "self", "sa", "ms", "b", "c", "settings", "sync", "an", "r", "sw", "ts", "ses", "serv", "ss", "i", "stats", "t", "g", "ns", "ies", "its", "client", "changes", "socket", "hs", "services", "sam", "source", "sts", "sv", "qs", "sys", "ats", "h", "os", "S", "als", "stat", "is", "pers"]}}
{"project": "qemu", "commit_id": "b16595275bc9b9ce6a36bfb0344d514ab77e6b98", "target": 0, "func": "MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t switched_level;\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        /*\n\n         * We only need to sync timer states with user-space interrupt\n\n         * controllers, so return early and save cycles if we don't.\n\n         */\n\n        return MEMTXATTRS_UNSPECIFIED;\n\n    }\n\n\n\n    cpu = ARM_CPU(cs);\n\n\n\n    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */\n\n    if (run->s.regs.device_irq_level != cpu->device_irq_level) {\n\n        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_VTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;\n\n        }\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_PTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;\n\n        }\n\n\n\n        /* XXX PMU IRQ is missing */\n\n\n\n        if (switched_level) {\n\n            qemu_log_mask(LOG_UNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\",\n\n                          __func__, switched_level);\n\n        }\n\n\n\n        /* We also mark unknown levels as processed to not waste cycles */\n\n        cpu->device_irq_level = run->s.regs.device_irq_level;\n\n        qemu_mutex_unlock_iothread();\n\n    }\n\n\n\n    return MEMTXATTRS_UNSPECIFIED;\n\n}\n", "idx": 23504, "substitutes": {"cs": ["js", "CS", "gc", "cp", "acts", "ls", "rs", "bs", "ps", "sc", "uns", "cc", "css", "fs", "acs", "ds", "ms", "s", "c", "ts", "cus", "ys", "acks", "cas", "ce", "pc", "ns", "ck", "ks", "ins", "wcs", "sys", "cf", "sk", "caps", "rc"], "run": ["check", "get", "ra", "add", "report", "train", "write", "end", "ve", "name", "unit", "execute", "range", "rain", "pass", "fun", "load", "ran", "raw", "scan", "r", "roll", "render", "in", "go", "build", "step", "set", "update", "skip", "Run", "runs", "ru", "re", "play", "process", "work", "con", "read", "ro", "row", "draw", "running", "out", "flow", "gem", "runner", "call", "exec", "rc", "rm", "begin", "boot", "use", "un"], "cpu": ["ctx", "cp", "pkg", "gc", "this", "reset", " CPU", "p", "np", "hz", "linux", "cn", "CPU", "pixel", "util", "anc", "cache", "conn", "copy", "mc", "aq", "phy", "component", "currency", "lib", "chip", "cum", "proc", "c", "core", "mac", "gpu", "aco", "lc", "processor", "computer", "los", "aux", "bench", "cmd", "uc", "utils", "prof", "phys", "pc", "cat", "ck", "client", "device", "process", "cam", "cu", "mem", "flow", "upt", "rpm", "sys", "kernel", "cf", "lp", "runner", "hw", "clock", "alloc", "cmp", "pu", "px", "boot", "cow", "cv", "comm"], "switched_level": ["switch_level", "switched_point", "switched67level", "switched67point", "switched67base", "switched_local", "switchedlypoint", "switched_color", "switchededzero", "switched00level", "switched2condition", "swressed_zero", "switches_status", "switched00color", "switched8limit", "switched_base", "switchededlevel", "switched_prop", "switched_data", "switchedElevel", "swicted_vel", "swaved_lvl", "swressed_color", "swictedEprop", "swicted_prop", "swressed_equal", "swpped_point", "switched_equal", "switched_allowed", "swpped_data", "switched_state", "switchedLEpoint", "switched_mask", "swictedElevel", "switchedlylevel", "switchedEvel", "swppedLEpoint", "switched2level", "switched8local", "switched67data", "switchededstatus", "switcheditymode", "switchedingstatus", "switched_info", "switcher_level", "switched8level", "switchedlybase", "switch_local", "switch_limit", "swppedLEdata", "switched00zero", "swppedLElevel", "switched_lvl", "switches_level", "switched_status", "switchedEprop", "switch8limit", "switches_lvl", "switched2limit", "swppedLEbase", "switchedingallowed", "swicted_level", "switchedityinfo", "switchedLElevel", "swpped_base", "switcheditylevel", "switch_condition", "switched_log", "switched_limit", "switchedinglog", "switchedinglevel", "switcher_mode", "switched2local", "switched_vel", "switchedLEbase", "switcher_mask", "swicted_style", "switched_style", "swpped_level", "switchedEstyle", "swictedEstyle", "switchedlydata", "switch8local", "switched_condition", "swictedEvel", "switchededequal", "switch8level", "switched_zero", "switched00equal", "switchededlock", "switcher_info", "swressed_level", "swaved_lock", "switches_state", "swaved_level", "switcheditymask", "switched_mode", "switched_lock", "switchededcolor", "switchededstate", "swaved_equal", "switched8condition", "switchededlvl", "switch8condition", "switchedLEdata"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_trailer(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int res = 0;\n\n    int i, j, n, nb_frames;\n\n    int64_t file_size;\n\n\n\n    if (pb->seekable) {\n\n        if (avi->riff_id == 1) {\n\n            ff_end_tag(pb, avi->movi_list);\n\n            res = avi_write_idx1(s);\n\n            ff_end_tag(pb, avi->riff_start);\n\n        } else {\n\n            avi_write_ix(s);\n\n            ff_end_tag(pb, avi->movi_list);\n\n            ff_end_tag(pb, avi->riff_start);\n\n\n\n            file_size = avio_tell(pb);\n\n            avio_seek(pb, avi->odml_list - 8, SEEK_SET);\n\n            ffio_wfourcc(pb, \"LIST\"); /* Making this AVI OpenDML one */\n\n            avio_skip(pb, 16);\n\n\n\n            for (n = nb_frames = 0; n < s->nb_streams; n++) {\n\n                AVCodecParameters *par = s->streams[n]->codecpar;\n\n                AVIStream *avist       = s->streams[n]->priv_data;\n\n\n\n                if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                    if (nb_frames < avist->packet_count)\n\n                        nb_frames = avist->packet_count;\n\n                } else {\n\n                    if (par->codec_id == AV_CODEC_ID_MP2 ||\n\n                        par->codec_id == AV_CODEC_ID_MP3)\n\n                        nb_frames += avist->packet_count;\n\n                }\n\n            }\n\n            avio_wl32(pb, nb_frames);\n\n            avio_seek(pb, file_size, SEEK_SET);\n\n\n\n            avi_write_counters(s, avi->riff_id);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVIStream *avist = s->streams[i]->priv_data;\n\n        for (j = 0; j < avist->indexes.ents_allocated / AVI_INDEX_CLUSTER_SIZE; j++)\n\n            av_free(avist->indexes.cluster[j]);\n\n        av_freep(&avist->indexes.cluster);\n\n        avist->indexes.ents_allocated = avist->indexes.entry = 0;\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 23508, "substitutes": {"s": ["ast", "sp", "rs", "bs", "conf", "sc", "fs", "ims", "sa", "cs", "stats", "aus", "rb", "ins", "its", "a", "sam", "os", "ls", "es", "times", "vs", "ps", "sis", "ds", "b", "ts", "less", "ags", "aps", "is", "v", "js", "gs", "m", "this", "bis", "eps", "scl", "ms", "r", "ses", "ss", "aws", "g", "hs", "sts", "http", "sys", "ats", "sports", "comm", "spec", "p", "sq", "w", "sb", "ab", "c", "as", "vp", "sw", "ns", "e", "sv", "qs", "h", "sg", "S"], "avi": ["avan", "ta", "AV", "ave", "aaa", "ra", "gra", "ano", "aaaa", "am", "nas", "VI", "ja", "wikipedia", "mie", "gg", "eni", "av", "pan", "bis", "ab", "iv", "audio", "verb", "feat", "ti", "mi", "sa", "iga", "peg", "xa", "vp", "oga", "tap", "liga", "jam", "video", "ai", "annot", "gif", "format", "opus", "jac", "ui", " av", "ma", "abba", "adi", "wi", "pheus", "opa", "webkit", "mis", "eas", "afi", "cam", "sav", "wiki", "au", "audi", "conv", "oi", "media", "ats", "pi", "pai", "ia", "ami", "liv", "vi", "v"], "pb": ["ctx", "pkg", "cp", "pel", "uf", "tp", "pub", "p", "np", "pp", "eb", "bs", "sp", "soc", "td", "ub", "erb", "jp", "pm", "tmp", "sb", "um", "tc", "wb", "bp", "pan", "typ", "cm", "py", "ab", "pl", "bis", "mp", "ob", "b", "stab", "wp", "proc", "vp", "tk", "buff", "PB", "pt", "func", "bj", "rb", "pc", "pa", "patch", "dp", "lb", "buf", "oa", "snap", "fts", "bps", "gp", "conv", "sys", "lp", "pi", "tf", "fb", "fp", "cb", "px", "mt", "pool", "pg", "cv"], "i": ["hi", "m", "me", "ci", "ix", "p", "us", "o", "id", "si", "zi", "multi", "ei", "y", "it", "xi", "ij", "ti", "b", "mi", "chain", "iu", "c", "r", "di", "in", "ni", "ai", "im", "ie", " ii", "g", "ui", "gi", "ic", "li", "ip", "sim", "iq", "instance", "ini", "bi", "e", "ind", "oi", "index", "x", "ii", "pi", "batch", "I", "ami", "ia", "ex", "is", "v"], "j": ["js", "jj", "m", "json", "try", "q", "p", "o", "z", "ja", "uj", "pr", "aj", "ev", "jp", "d", "br", "jas", "oj", "dj", "l", "ij", "att", "b", "jc", "c", "jo", "kid", "jl", "ni", "pos", "pt", "k", "g", "bj", "li", "ng", " J", "J", "sim", "adj", "job", "ji", "bi", "ind", "index", "x", "jump", "ii", "jit", "kj", "err", "nr", "v", "bo"], "n": ["wn", "m", "nw", "num", "sn", "p", "np", "nb", "un", "o", "z", "cn", "name", "mn", "ln", "nm", "nos", "d", "ann", "nn", "syn", "on", "N", "y", "nie", "nc", "l", "nor", "c", "nl", "an", "fn", "no", "nt", "nu", "ren", "gn", "ni", "node", "t", "na", "dn", "g", "yn", "en", "nd", "ns", "ng", "names", "count", "note", "len", "number", "el", "hn", "nan", "new", "nr", "ne", "v"], "nb_frames": ["nb67items", "no_users", "cb_bytes", "nb_weights", "nb67vals", "nb_faces", " neb____fram", "nob_bytes", "node_errors", "nbxfaces", "nb_users", "no_files", " neb_fram", "cb_frame", " neb____frames", "nb___faces", "no____files", "nb_headers", "nob___bytes", "nb____users", "no____frames", "nbxweights", "nb67frames", " neb_frames", "nob_fram", "nbwfiles", "bn_frames", "nob_frames", "bn_pages", "nb____fram", "node_frames", "node_rows", "bn_photos", "nb___pages", "nbxfiles", "nb_rows", "no_phones", "nob___fram", "cb_cells", "nb__bytes", "nb____frames", "nob_headers", " neb____vals", "nb__frame", "nb___headers", "nb67fram", "nbuffyframes", "nbuffyfram", "nbxphotos", "nb___fram", "nb_items", "nbxusers", "nb__frames", "nb_frame", "nbwframes", "nbwphones", " neb____items", "nb_bytes", "no____phones", "nbxrows", "nb_phones", "bn_faces", "nb_errors", "nbwusers", " neb_vals", "nbxpages", "nb_pages", "nb_photos", "no_frames", "nb___frames", "nbxframes", "no____users", "nb___bytes", "nb_fram", "nb____items", " neb_items", "nb_vals", "nob___frames", "nb___photos", "node_weights", "nob___headers", "nb_files", "nb____phones", "nbuffyheaders", "nbxerrors", "cb_frames", "nb____files", "nb_cells", "nbuffybytes", "nb____vals", "nb__cells", "nbxphones"], "file_size": ["filelexdata", "file_SIZE", "filelogsent", " file_Size", "filelogname", "fileseqsize", "file_set", "file128settings", "filelexsize", "file128Size", "file128size", "file_name", "filelexsettings", "file128data", "file_sent", " file_length", "file_length", "file_settings", " file_SIZE", " file_settings", "fileseqsent", "file2Size", "file2length", "filelexSize", "file_data", "fileseqset", " file_data", "filelogset", "filelogsize", "file2SIZE", " file_sent", "fileseqname", "file_Size", "file2size", " file_set", " file_name"], "par": ["pkg", "cp", "dev", "car", "arp", "mm", "p", "pp", "pub", "prep", "pr", "req", "jp", "parse", "per", "arch", "def", "ps", "kar", "pard", "tar", "pass", "rem", "mp", "Par", "rep", "proc", "tx", "pat", "dr", "rar", "ar", "war", "pro", "pa", "pol", "plan", "var", "pri", "cam", "param", "rec", "arr", "pre", "pal", "pi", "part", "pres", "star", "pas", "har", "rel"], "avist": [" aviz", "Avister", "avistor", "awists", "aveift", "ajisted", "averict", "savIST", "averoint", "ajict", "ajost", "ovistant", "ajist", "averist", "avists", "ajest", "ajIST", "aveict", "averisted", "ajoint", "ajiz", "avister", "averistor", "vanists", "avict", "aveist", "savift", "awis", "avistant", "avisted", "aveIST", "aviz", " avis", "avIST", "vaniz", "Avist", "awist", "avost", "avest", "oviz", "Avift", "saviz", "averift", " avisted", "savistant", "ajistor", "aveistor", "averost", "ajistant", "vanis", " avift", "avoint", "savister", "ovist", "savist", "awiz", "avift", "aveoint", "aveister", "AvIST", " avists", "vanist", "ovIST", "avis", " avest", "averest", "aveost", " avict", " avistor"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23516, "substitutes": {"opaque": ["opaques", "Opaque", "opacity", "ipaques", "Opvoid", "opvoid", "oplaque", "OPaque", "opque", "OPque", "Opque", "obaque", "obacity", "ipque", "OPacity", "obque", " opque", "oplacity", " opvoid", "oplque", "Opaques", "ipvoid", "ipaque", " opaques"], "addr": ["ctx", "ix", "add", "Address", "adr", "data", "at", "id", "pad", "name", "loc", "ptr", "ay", "src", " address", "offset", "self", "attr", "dh", "prefix", "address", "r", "tx", "ord", "cmd", "host", "dr", "act", "pos", "reg", "ong", "ref", "var", "align", "store", "hash", "adj", "work", "coord", "now", "obj", "handle", "sha", "eth", "row", "mem", "arr", "index", "x", "hw", "err", "alloc", "ad", "block"], "size": ["ity", "m", "num", "sn", "sent", "sp", "body", "z", "type", "SIZE", "length", "small", "scale", "Size", "n", "offset", "l", "capacity", "style", "s", "sh", "send", "address", "empty", "sum", "shape", "message", "align", "count", "number", "len", "code", "e", "grow", "ize", "fee", "space", "iz", "zone"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n\n    s->cas = 0;\n\n}\n", "idx": 23540, "substitutes": {"opaque": [" Opos", "Opulence", " opoid", "Opaque", "opulence", " opulence", "OPaque", " Oplation", "opque", "opsque", "OPos", "OPque", "Opque", " Opque", "plation", "OPlation", "opos", "pos", "paque", "opoid", "Opoid", " Opaque", " opque", "pque", "opsoid", "opsaque", "oplation", "opsulence"], "addr": ["pkg", "ix", "arp", "add", "Address", "adr", "rs", "alt", "id", "pad", "loc", "ag", "ptr", "ace", "ay", "url", "src", " address", "inter", "attr", "address", "tx", "ord", "cmd", "host", "dr", "act", "db", "ref", "align", "store", "hash", "hl", "arr", "rr", "ad", "rel", "ack", "fx"], "val": ["ctx", "Value", "aval", "vt", "grad", "ival", "alt", "seq", "sol", "value", "it", "test", "bit", "ret", "b", "vol", "VAL", "lit", "tx", "serv", " value", "cas", "reg", "cond", "res", "Val", "pol", "ul", "ref", "al", "resp", "buf", "bal", "len", "mem", "qual", "cal", "vals", "als", "valid", "v"], "d": ["dos", "m", "del", "p", "dat", "o", "z", "dx", "ld", "des", "pd", "n", "dj", "ds", "b", "dh", "c", "r", "du", "j", "di", "da", "dr", "i", "t", "dm", "dn", "g", "dc", "dd", "did", "de", "a", "ind", "D", "dq", "ad", "sd", "v"], "s": ["js", "gs", "q", "sq", "p", "es", "bs", "rs", "ps", "fs", "sis", "ds", "b", "ess", "cs", "as", "ts", "ses", "ss", "t", "ns", "ies", "ins", "hs", "sam", "sts", "sv", "qs", "ats", "os", "S", "is"]}}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n", "idx": 23555, "substitutes": {"dev": ["ac", "spec", " devs", "data", "ev", "pad", "tr", "Dev", "w", "Device", "ver", "d", "def", "ptr", "des", "DEV", "conn", "test", "ds", "att", "serv", "nt", "dm", "env", "dd", "de", "device", "md", "cam", "out", "ach", "mem", "os", "hw", "priv", "ad", "devices", "sd", "v"], "errp": ["errpat", "errorping", "rrpat", " errP", "Erpb", "rrP", "rrper", "errpb", "rrpb", "errorp", "errping", "noticeper", "errper", "noticep", "rrp", "ErP", "rrping", "noticeping", "noticepat", "errorper", " errpb", "errorpat", "errP", "Erp"], "fs": ["js", "gs", "ls", "ows", "es", "bs", "rs", "fw", "vs", "fr", "Fs", "ps", "irs", "fd", "ims", "ds", "ms", "ics", "s", "files", "cs", "fc", "ts", "oss", "res", "ns", "FS", "ks", "fits", "hs", "bf", "qs", "sys", "ats", "cf", "fps", "f"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)\n\n{\n\n    InputStream  *ist = s->opaque;\n\n    DXVA2Context *ctx = ist->hwaccel_ctx;\n\n\n\n    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);\n\n}\n", "idx": 23560, "substitutes": {"s": ["js", "gs", "ls", "p", "sq", "sp", "rs", "w", "d", "sb", "n", "ps", "src", "fs", "ds", "b", "c", "cs", "as", "ss", "i", "t", "set", "ns", "ins", "a", "e", "sts", "sv", "sys", "h", "os", "S", "f", "is", "v"], "frame": [" Frame", "face", "spec", "scene", "profile", "iframe", "file", "state", "seq", "word", "image", "def", "fr", "fe", "force", "feat", "bit", "info", "Frame", "fram", "feature", "show", "fc", "ence", "raw", "point", "video", "ce", "sample", "fi", "ref", "rame", " fr", "window", "ime", "frames", "bf", "form", "sf", "cf", "fb", "AME", "sequence", "block", "f"], "flags": [" whence", " footprint", "ff", " mask", "FLAG", "bits", "Flag", " options", "ffff", " flag", "fs", " bits", "kind", "flag", "faces", "args", " af", " usage", " fu", "count", " features", "ags", "features", " Flags", " fs", "fee", "fields", "Flags"], "ist": ["xp", "ust", "ast", "ird", "ism", "inst", "isc", "alist", "ot", "ih", "isi", "ush", "imet", "ift", "IS", "pect", "ost", "ista", "osi", "oci", "ess", "wp", "xt", "iss", "pt", "IST", "bh", "erd", "ic", "est", "irst", "et", "iste", "its", "ik", "ith", "ind", "sys", "spect", "art", "aci", "ert", "st", "ists", "is"], "ctx": ["cp", "pkg", "gc", "cfg", "vc", "np", "mk", "bc", "loc", "kt", "jp", "ctrl", "ka", "tc", "nc", "wid", "cc", "kw", "tx", "cmd", "nt", "pt", "act", "jac", "ns", "ck", "voc", "ctr", "cu", "context", "crit", "sys", "xs", "cf", "hw", "wx", "cmp", " cx", "cv", "ct"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "void ff_h264_idct8_add_c(uint8_t *dst, DCTELEM *block, int stride){\n\n    int i;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    block[0] += 32;\n\n\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[0+i*8] + block[4+i*8];\n\n        const int a2 =  block[0+i*8] - block[4+i*8];\n\n        const int a4 = (block[2+i*8]>>1) - block[6+i*8];\n\n        const int a6 = (block[6+i*8]>>1) + block[2+i*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[3+i*8] + block[5+i*8] - block[7+i*8] - (block[7+i*8]>>1);\n\n        const int a3 =  block[1+i*8] + block[7+i*8] - block[3+i*8] - (block[3+i*8]>>1);\n\n        const int a5 = -block[1+i*8] + block[7+i*8] + block[5+i*8] + (block[5+i*8]>>1);\n\n        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        block[0+i*8] = b0 + b7;\n\n        block[7+i*8] = b0 - b7;\n\n        block[1+i*8] = b2 + b5;\n\n        block[6+i*8] = b2 - b5;\n\n        block[2+i*8] = b4 + b3;\n\n        block[5+i*8] = b4 - b3;\n\n        block[3+i*8] = b6 + b1;\n\n        block[4+i*8] = b6 - b1;\n\n    }\n\n    for( i = 0; i < 8; i++ )\n\n    {\n\n        const int a0 =  block[i+0*8] + block[i+4*8];\n\n        const int a2 =  block[i+0*8] - block[i+4*8];\n\n        const int a4 = (block[i+2*8]>>1) - block[i+6*8];\n\n        const int a6 = (block[i+6*8]>>1) + block[i+2*8];\n\n\n\n        const int b0 = a0 + a6;\n\n        const int b2 = a2 + a4;\n\n        const int b4 = a2 - a4;\n\n        const int b6 = a0 - a6;\n\n\n\n        const int a1 = -block[i+3*8] + block[i+5*8] - block[i+7*8] - (block[i+7*8]>>1);\n\n        const int a3 =  block[i+1*8] + block[i+7*8] - block[i+3*8] - (block[i+3*8]>>1);\n\n        const int a5 = -block[i+1*8] + block[i+7*8] + block[i+5*8] + (block[i+5*8]>>1);\n\n        const int a7 =  block[i+3*8] + block[i+5*8] + block[i+1*8] + (block[i+1*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b7) >> 6) ];\n\n        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b2 + b5) >> 6) ];\n\n        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b4 + b3) >> 6) ];\n\n        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b6 + b1) >> 6) ];\n\n        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b6 - b1) >> 6) ];\n\n        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b4 - b3) >> 6) ];\n\n        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b2 - b5) >> 6) ];\n\n        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b7) >> 6) ];\n\n    }\n\n}\n", "idx": 23576, "substitutes": {"dst": [" dstr", " dfr", "rfr", "Dst", "rstr", "rst", "dstr", "Dfr", "rbl", " dbl", "Dstr", "dfr", "dbl", "Dbl"], "block": ["check", "pack", "file", "type", "bin", "user", "unit", "chain", "join", "lib", "layer", "ip", "client", "other", "buf", "work", "none", "ch", "record", "Block", "condition", "blocking", "filter", "array", "table", "use", "list", "manager", "box", "tag", "range", "cache", "cl", "bit", "co", "b", "core", "config", "loop", "map", "frame", "stream", "device", "hash", "group", "byte", "part", "model", "object", "BL", "public", "profile", "secure", "word", "image", "module", "plugin", "blocks", "proc", "history", "load", "point", "version", "network", "archive", "bl", "page", "random", "open", "ck", "window", "channel", "snap", "row", "http", "view", "rule", "mask", "valid", "space", "bus", "bo", "spec", "p", "control", "rock", "bc", "clip", "library", "pixel", "def", "line", "lock", "sync", "board", "method", "buffer", "link", "out", "event", "zero", "base", "commit", "label"], "stride": [" strride", "Strride", "strides", "stide", "strize", "Strize", "Stride", "strride", "stize", "Strides", " strides", "stides", " strize"], "i": ["at", "multi", " mi", "ei", "ims", "mi", "info", "\u0438", "set", "series", "ip", "ri", "ini", "ind", "ii", "x", "pi", "io", "ki", "im", "try", "q", "o", " bi", "zi", "it", "qi", "iu", "di", "in", "print", " I", "u", " j", "conv", "is", "v", "hi", "m", "me", "this", "us", "or", "si", "port", "xi", "init", "status", "er", "r", "ai", "g", "ui", "li", " multi", " m", "time", "batch", "sequence", "vi", " ti", "ci", "ix", "p", "id", "y", "mc", "ij", "ti", "s", "j", "t", "ie", " ii", "gi", "ic", "key", "cli", "sim", "ji", "bi", "oi", "index", "I", "ia", "ex"], "cm": ["cp", "m", "cr", "mm", "ca", "mr", "conf", "mn", "nm", "um", "tc", "km", "module", "rem", "cl", "com", "fc", "bm", "lc", "cd", "dc", "ck", "asm", "cv", "mb", "cf", "fm", "cont", "im"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n", "idx": 23587, "substitutes": {"val": ["ctx", "V", "sl", "vt", "p", "data", " data", "z", "pr", "sel", " VAL", "def", "sol", " Val", "value", "it", "test", "l", "ret", "lib", "VAL", "tx", " v", "serv", " arg", " value", "pt", "eval", "t", "pos", "reg", "Val", " _", "ref", "var", "al", "len", "mem", "sv", "index", "x", "ee", "cal", "vals", "err", "elt", "valid", " eval", "v"]}}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "void tlb_set_page(CPUArchState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    section = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n           \" prot=%x idx=%d pd=0x%08lx\\n\",\n\n           vaddr, paddr, prot, mmu_idx, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    if (memory_region_is_ram(section->mr) ||\n\n        memory_region_is_romd(section->mr)) {\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)\n\n        + memory_region_section_addr(section, paddr);\n\n    } else {\n\n        addend = 0;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,\n\n                                            &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && !cpu_physical_memory_is_dirty(\n\n                           section->mr->ram_addr\n\n                           + memory_region_section_addr(section, paddr))) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 23622, "substitutes": {"env": ["ctx", "dev", "equ", "vt", "viron", "v", "ve", "ev", "manager", "here", "shell", "pe", "esc", "eng", "vs", "pee", "den", "ah", "vm", "ei", "conn", "environment", "enter", "global", "era", "test", "er", "door", "vp", "ec", "org", "ef", "node", "server", "net", "network", "en", "ner", " environment", "her", "et", "ew", "see", "window", "nv", "obj", "e", "context", "hw", "operator", "Environment", "email", "cv"], "vaddr": ["madd", "lptr", "pnow", "whost", " vhost", "vaddress", "mip", "hptr", "veadr", "veaddr", " vip", "vip", "waddr", "vpaddr", "faddr", "wadr", "vadd", " vadd", "fadd", "wptr", "ladr", "Vadr", "vcaddress", "padd", "fhost", "veptr", "Vaddress", "vpaddress", "vadr", "vpip", "vpadd", " vnow", "Vhost", " vadr", "pip", "vehost", "vcnow", " vdr", "vptr", "hadr", "Vaddr", "vnow", "vcadd", "hhost", "pptr", "haddr", "laddress", "maddr", "maddress", "laddr", " vaddress", "waddress", "mdr", "pdr", "vcaddr", "paddress", "madr", "phost", "faddress", "padr", "vdr", "vhost"], "paddr": ["madd", " paddress", "vaddress", "Paddr", "vpaddr", " pptr", " padr", "vadd", "Paddress", "padd", "vadr", "vpaddress", "vpadd", "mattr", " pattr", "vptr", "pptr", "mptr", "vattr", "maddr", "Padr", "maddress", "Pptr", "vpptr", "pattr", "mdr", "pdr", " padd", "paddress", "Padd", "padr", "vdr", " pdr"], "prot": ["pkg", "command", "rot", "height", "chron", "tp", "response", "vector", "zh", "type", "tr", "flags", "port", "ptr", "def", "pd", "typ", "prop", "ext", "phy", "dt", " PROT", "ht", "status", "style", "ret", "mode", " proto", "top", "pat", "header", "flag", "cmd", "ef", "format", "version", "method", "tif", "pro", "col", "pc", "ocol", "pb", "prototype", "protection", "ref", "ping", "php", "eth", "handle", "pattern", "xy", "tz", "policy", "tf", " protocol", "period", "Prot", "stat", "io", "opt"], "mmu_idx": ["mmu_basedx", "mmu__idy", "mmu__idv", "mmu_idsx", "mmu_Idv", "mmu_indv", "mmu_basedj", "mmu_idj", "mmu_idsy", "mmu_idn", "mmu_idsn", "mmu__idsn", "mmu_indexn", "mmu_idey", "mmu_ipv", "mmu_basedy", "mmu_Idx", "mmu_indx", "mmu_indexx", "mmu_ipx", "mmu__idn", "mmu_iden", "mmu_ipn", "mmu__idx", "mmu_indn", "mmu_idv", "mmu_Idy", "mmu_idy", "mmu_idsv", "mmu__idsv", "mmu_indexxs", "mmu_Idn", "mmu_idexs", "mmu__idsy", "mmu_indy", "mmu__idsx", "mmu_idxs", "mmu_idev", "mmu_idex", "mmu_indexy", "mmu_basedv", "mmu_ipy", "mmu_Idj"], "size": ["height", "sn", "num", "p", "data", "sp", "np", "body", "z", "start", "name", "SIZE", "length", "power", "small", "zone", "scale", "Size", "cache", "capacity", "style", "max", "too", "sh", "send", "storage", "sw", "timeout", "sum", "shape", "pos", "city", "area", "message", "set", "buffer", "page", "news", "total", "count", "number", "len", "mem", "sv", "time", "ize", "pi", "fee", "space", "cap", "use", "sy"], "section": ["action", "sections", "description", "profile", "parent", "ment", "rup", "state", "established", "entry", "mod", "setting", "image", "port", "division", "sb", "tag", "master", "journal", "service", "definition", "environment", "component", "test", "site", "region", "man", "prefix", "mode", "feature", "tab", "selection", "header", "j", "org", "server", "version", "net", "area", "sect", "page", "element", "establishment", "ner", "position", "second", "key", "member", "session", "window", "group", "comment", "job", "channel", "sec", "sector", "row", "instance", "context", "side", "option", "portion", "usr", "se", "connection", "Section", "part", "example", "container", "block", "table"], "index": ["ity", "height", "connect", "num", "ice", "success", "ix", " error", "inc", "IND", "alias", "id", "si", "insert", "loc", "port", "length", "ion", "offset", "test", "capacity", "iter", "location", "find", "i", "order", "point", "axis", "pos", "loop", "active", "timeout", "set", "server", "page", "key", "open", "position", "count", "select", "route", "Index", "number", "code", "instance", "row", "ind", "zero", "interface", "condition", "option", "x", "ize", "connection", "addr", "ex"], "address": ["command", "vector", "description", "end", "add", "Address", "p", "adr", "start", "alias", "memory", "entry", "length", "distance", "port", "path", "password", "image", "ptr", "padding", "ace", "range", "service", "value", "definition", "offset", "region", "result", "location", "node", "order", "point", "pointer", "version", "shape", "network", "area", "message", "error", "buffer", "page", "position", "ref", " Address", "device", "ip", "comment", "number", "route", "code", "a", "interface", "context", "reference", "attribute", "resource", "connection", "addr", "array", "pair", "block", "table", "email"], "code_address": ["code___record", "code_reference", " code_position", "code_record", "code__position", "code___address", "code___addr", " code_record", "code___offset", "code__address", "code__location", "code_location", "code_addr", "code_offset", " code_Address", "code__offset", " code_reference", " code_addr", "code_position", " code_location", " code_offset", "code_Address"], "addend": ["ordending", "Addent", "addender", "addrfrom", "ordended", "addedension", "addends", " addent", "addrend", "addfrom", "Addended", "addedfrom", "adEnd", "attachends", "addent", "attachending", "addedended", "addension", "sumended", "AddEnd", "addstart", "addedender", " addfrom", " addended", "sumender", "attachend", "addending", "Addstart", "ordends", "ordend", " addension", "sumend", "addrended", "addended", " addends", "adend", "addedent", "addEnd", "adstart", " addending", "Addend", "adended", " addstart", "addedend", " addender", "attachended", " addEnd", "sumension"], "te": ["ta", "ke", "fo", "me", "ffe", "tp", "ete", "le", "tile", "ve", "ere", "ter", "be", "ale", "je", "pe", "ige", "lete", "delete", "oe", "test", "ue", "ye", "we", "ti", "ame", "ae", "ene", "xe", "tre", "ote", "ts", "ante", "ute", "t", "ce", "ie", "ite", "Te", "ine", "see", "ate", "de", "ette", "ge", "tle", "note", "ade", "e", "che", "se", "TE", "ste", "ode", "ele", "itte", "ne", "aste", "ome"], "iotlb": ["ioticlb", "pitlab", "youtlb", "mintlr", "ioslr", "iotlr", "pitlas", "otilr", "ttlab", "iotlbs", "ytlbs", "ytlb", "youtlbs", "ioslbs", "ytlab", "OTlb", "ietlb", "OTlr", "minterb", "OTlbs", "ioslab", "tterb", "ttlbs", "OTlab", "iotlas", "ietlbs", "yterb", "ioterb", "youtlas", "otibl", "mintlbs", "ioslb", "otilb", "otilab", "ioticbl", "ioticlab", "iotbl", "ytbl", "mintlab", "youtlab", "ietlab", "pitlb", "ytlr", "iotlab", "ioticlr", "ietlas", "mintlb", "pitlbs", "ttlb"]}}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)\n\n{\n\n    RTL8139State *s = opaque;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            s->phys[addr - MAC0] = val;\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            /* reserved */\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            s->mult[addr - MAR0] = val;\n\n            break;\n\n        case ChipCmd:\n\n            rtl8139_ChipCmd_write(s, val);\n\n            break;\n\n        case Cfg9346:\n\n            rtl8139_Cfg9346_write(s, val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n", "idx": 23626, "substitutes": {"opaque": ["iopaque", "opaques", "Opaque", "opacity", "ropaco", " opaco", "opaco", "OPaque", "Opac", "OPaques", "OPac", " opacity", "opac", "oplay", "ioplay", "OPacity", "Opacity", "opent", " oplay", "ropaque", "ropent", "Opaques", " opac", "iopaco", " opent", "roplay", " opaques", "iopent"], "addr": ["pkg", "grad", "adr", "sp", "rs", "aj", "ret", "attr", "address", "mac", "dr", "order", "phys", "rev", "md", "work", "a", "arr", "x", "ad", "ctx", "ac", "arp", "z", "ash", "tag", " address", "inter", "att", "b", "prefix", "pos", "map", "align", "hash", "urg", "ack", "v", "dev", "add", "Address", "alt", "state", "pad", "req", "loc", "ptr", "url", "offset", "r", "ord", "act", "res", "msg", "var", "lat", "mask", "err", "alloc", "elt", "ix", "alias", "id", "src", "tx", "cmd", "host", "db", "ref", "off", "coord", "eth", "mem", "index", "mt"], "val": ["alpha", "grad", "sel", "ver", "unit", "ext", "test", "ret", " vel", "lib", "lit", "pt", " update", "resp", "buf", "bal", " aval", "ind", "arg", "crit", "x", "bool", "pal", "cal", "ctx", "vt", "data", "hz", "ival", "mod", "util", " tx", "it", "b", "vol", "mix", "fail", "serv", " arg", "Val", "pol", "xy", "local", " bl", "urg", " eval", "v", "dev", "num", "aval", " data", "alt", "vet", " ty", "gold", "lex", "item", "act", "eval", "res", "cond", "bl", "msg", "txt", "var", "al", " cal", "el", "obj", "str", "err", "elt", "valid", "rel", "stat", "bo", "Value", "p", "def", "value", "VAL", "tx", " v", " value", "reg", "cho", "key", "ref", "ul", "rol", "mem", "new", "vals", "gal"], "s": ["js", "gs", "m", "spec", "ssl", "sl", "ls", "sq", "p", "es", "o", "rs", "z", "bs", "params", "sp", "state", "w", "d", "sb", "vs", "service", "ps", "n", "y", "bis", "fs", "sm", "ds", "l", "b", "an", "cs", "r", "as", "sw", "ses", "ts", "j", "serv", "ss", "i", "stats", "t", "set", "g", "ns", "its", "store", "socket", "a", "hs", "sam", "obj", "services", "sts", "sv", "qs", "sys", "h", "se", "os", "S", "als", "ex", "is", "v", "comm"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,\n\n                                    const int filter_p1, const int filter_q1,\n\n                                    const int alpha, const int beta,\n\n                                    const int lim_p0q0, const int lim_q1,\n\n                                    const int lim_p1)\n\n{\n\n    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,\n\n                          alpha, beta, lim_p0q0, lim_q1, lim_p1);\n\n}\n", "idx": 23627, "substitutes": {"src": ["inst", "sn", "sq", "np", "input", "rs", "impl", "sel", "bc", "req", "tmp", "ptr", "sb", "copy", "sc", "dest", "each", "ser", "s", "load", "scan", "img", "bh", "sub", "txt", "cur", "ins", "ipl", "source", "ctr", "usr", "h", "sr", "rl", "sys", "sur", "st", "gin", "rc"], "stride": ["strend", " strend", "Strve", "strade", "trride", "strride", "Struse", "strime", "struse", " strride", "tride", "strve", "Strade", "divade", " strade", "trend", "STRime", "Stride", "divuse", "divide", " strve", "STRride", "divve", " struse", " strime", "STRide", "trime", "STRend"], "filter_p1": ["filter_p8", "filter_p0", "filter_m8", "filter_p3", "filter_P0", "filter_q2", "filter_P1", "filter_q8", "filter_m0", "filter_q0", "filter_m1", "filter_p2", "filter_m3", "filter_P3", "filter_P2", "filter_m2"], "filter_q1": ["filter_dq2", "filter_p0", "filter_dqi", "filter_qq2", "filter_eqi", "filter_dq1", "filter_q2", "filter_qOne", "filter_Q1", "filter_QOne", "filter_eq2", "filter_Q0", "filter_eq1", "filter_q0", "filter_qqOne", "filter_dq0", "filter_qq0", "filter_pOne", "filter_pi", "filter_qq1", "filter_eq0", "filter_p2", "filter_Q2", "filter_qi"], "alpha": ["ac", "hi", "success", "ra", "inc", "p", " gamma", "alias", "diff", "power", "anti", "aff", " \u03b1", "attr", "asc", "acl", "mix", "la", "da", "extra", "fac", "error", "ma", "al", "a", "alph", "adv", "filter", "weight", " Alpha", "capital", "rc", "Alpha"], "beta": ["ta", "gam", "eta", "grad", "nb", "bs", "secondary", "bc", "mu", "confidence", "gradient", "bis", "blue", "dB", "dust", "b", "lr", "mega", "Beta", "boost", "normal", "phi", "vert", "two", "late", "bet", "igma", "bi", "bot", "bps", "lambda", "xy", "ii", "binary", "fine", "fee", "\u03b2", "term"], "lim_p0q0": ["lim_p1dq2", "lim_p0dq0", "lim_p0qq1", "lim_p1p2", "lim_p0f7", "lim_p1q1", "lim_p1p7", "lim_p0qu0", "lim_p0dq2", "lim_p1q0", "lim_p0qq0", "lim_p0f2", "lim_p1dq1", "lim_p0p0", "lim_p0f0", "lim_p0qq7", "lim_p0f1", "lim_p0dq1", "lim_p0p7", "lim_p0p1", "lim_p1p0", "lim_p0qu2", "lim_p0q7", "lim_p1dq0", "lim_p0p2", "lim_p1p1", "lim_p0q2", "lim_p0qq2", "lim_p1q2", "lim_p1q7", "lim_p0q1", "lim_p0qu1"], "lim_q1": ["lim_Q2", "lim_ueone", "lim_Qone", "lim_qq01", "lim_Q0", "lim_q01", "lim_dq3", "lim_qq1", "lim_Q01", "lim2dq0", "lim_Q1", "lim_q2", "lim_ue2", "lim2dq2", "lim_dq2", "lim_p3", "lim_qone", "lim_q0", "lim2dq1", "lim_p2", "lim_ue1", "lim_qq2", "lim2q3", "lim2q2", "lim_q3", "lim_dq1", "lim_dq0", "lim_p0", "lim2q1", "lim_Q3", "lim_qqone", "lim2q0", "lim_ue01", "lim2dq3"], "lim_p1": ["lim_p8", "lim_m2", "lim_m1", "lim_t0", "lim_v8", "lim_P2", "lim_q2", "lim_P1", "lim_t2", "lim_q8", "lim_p2", "lim_P0", "lim_m8", "lim_t1", "lim_p0", "lim_m0", "lim_v1", "lim_v2"]}}
{"project": "FFmpeg", "commit_id": "3ca5df36a50e3ffd3b24734725bf545617a627a8", "target": 1, "func": "static int decode_subframe(WmallDecodeCtx *s)\n\n{\n\n    int offset        = s->samples_per_frame;\n\n    int subframe_len  = s->samples_per_frame;\n\n    int total_samples = s->samples_per_frame * s->num_channels;\n\n    int i, j, rawpcm_tile, padding_zeroes, res;\n\n\n\n    s->subframe_offset = get_bits_count(&s->gb);\n\n\n\n    /* reset channel context and find the next block offset and size\n\n        == the next block of the channel with the smallest number of\n\n        decoded samples */\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        if (offset > s->channel[i].decoded_samples) {\n\n            offset = s->channel[i].decoded_samples;\n\n            subframe_len =\n\n                s->channel[i].subframe_len[s->channel[i].cur_subframe];\n\n        }\n\n    }\n\n\n\n    /* get a list of all channels that contain the estimated block */\n\n    s->channels_for_cur_subframe = 0;\n\n    for (i = 0; i < s->num_channels; i++) {\n\n        const int cur_subframe = s->channel[i].cur_subframe;\n\n        /* subtract already processed samples */\n\n        total_samples -= s->channel[i].decoded_samples;\n\n\n\n        /* and count if there are multiple subframes that match our profile */\n\n        if (offset == s->channel[i].decoded_samples &&\n\n            subframe_len == s->channel[i].subframe_len[cur_subframe]) {\n\n            total_samples -= s->channel[i].subframe_len[cur_subframe];\n\n            s->channel[i].decoded_samples +=\n\n                s->channel[i].subframe_len[cur_subframe];\n\n            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;\n\n            ++s->channels_for_cur_subframe;\n\n        }\n\n    }\n\n\n\n    /* check if the frame will be complete after processing the\n\n        estimated block */\n\n    if (!total_samples)\n\n        s->parsed_all_subframes = 1;\n\n\n\n\n\n    s->seekable_tile = get_bits1(&s->gb);\n\n    if (s->seekable_tile) {\n\n        clear_codec_buffers(s);\n\n\n\n        s->do_arith_coding    = get_bits1(&s->gb);\n\n        if (s->do_arith_coding) {\n\n            avpriv_request_sample(s->avctx, \"Arithmetic coding\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        s->do_ac_filter       = get_bits1(&s->gb);\n\n        s->do_inter_ch_decorr = get_bits1(&s->gb);\n\n        s->do_mclms           = get_bits1(&s->gb);\n\n\n\n        if (s->do_ac_filter)\n\n            decode_ac_filter(s);\n\n\n\n        if (s->do_mclms)\n\n            decode_mclms(s);\n\n\n\n        if ((res = decode_cdlms(s)) < 0)\n\n            return res;\n\n        s->movave_scaling = get_bits(&s->gb, 3);\n\n        s->quant_stepsize = get_bits(&s->gb, 8) + 1;\n\n\n\n        reset_codec(s);\n\n    } else if (!s->cdlms[0][0].order) {\n\n        av_log(s->avctx, AV_LOG_DEBUG,\n\n               \"Waiting for seekable tile\\n\");\n\n        s->frame.nb_samples = 0;\n\n        return -1;\n\n    }\n\n\n\n    rawpcm_tile = get_bits1(&s->gb);\n\n\n\n    for (i = 0; i < s->num_channels; i++)\n\n        s->is_channel_coded[i] = 1;\n\n\n\n    if (!rawpcm_tile) {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            s->is_channel_coded[i] = get_bits1(&s->gb);\n\n\n\n        if (s->bV3RTM) {\n\n            // LPC\n\n            s->do_lpc = get_bits1(&s->gb);\n\n            if (s->do_lpc) {\n\n                decode_lpc(s);\n\n                avpriv_request_sample(s->avctx, \"Expect wrong output since \"\n\n                                      \"inverse LPC filter\");\n\n            }\n\n        } else\n\n            s->do_lpc = 0;\n\n    }\n\n\n\n\n\n    if (get_bits1(&s->gb))\n\n        padding_zeroes = get_bits(&s->gb, 5);\n\n    else\n\n        padding_zeroes = 0;\n\n\n\n    if (rawpcm_tile) {\n\n        int bits = s->bits_per_sample - padding_zeroes;\n\n        if (bits <= 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Invalid number of padding bits in raw PCM tile\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        av_dlog(s->avctx, \"RAWPCM %d bits per sample. \"\n\n                \"total %d bits, remain=%d\\n\", bits,\n\n                bits * s->num_channels * subframe_len, get_bits_count(&s->gb));\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_coeffs[i][j] = get_sbits(&s->gb, bits);\n\n    } else {\n\n        for (i = 0; i < s->num_channels; i++)\n\n            if (s->is_channel_coded[i]) {\n\n                decode_channel_residues(s, i, subframe_len);\n\n                if (s->seekable_tile)\n\n                    use_high_update_speed(s, i);\n\n                else\n\n                    use_normal_update_speed(s, i);\n\n                revert_cdlms(s, i, 0, subframe_len);\n\n            } else {\n\n                memset(s->channel_residues[i], 0, sizeof(**s->channel_residues) * subframe_len);\n\n            }\n\n    }\n\n    if (s->do_mclms)\n\n        revert_mclms(s, subframe_len);\n\n    if (s->do_inter_ch_decorr)\n\n        revert_inter_ch_decorr(s, subframe_len);\n\n    if (s->do_ac_filter)\n\n        revert_acfilter(s, subframe_len);\n\n\n\n    /* Dequantize */\n\n    if (s->quant_stepsize != 1)\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_residues[i][j] *= s->quant_stepsize;\n\n\n\n    /* Write to proper output buffer depending on bit-depth */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        int subframe_len = s->channel[c].subframe_len[s->channel[c].cur_subframe];\n\n\n\n        for (j = 0; j < subframe_len; j++) {\n\n            if (s->bits_per_sample == 16) {\n\n                *s->samples_16[c]++ = (int16_t) s->channel_residues[c][j] << padding_zeroes;\n\n            } else {\n\n                *s->samples_32[c]++ = s->channel_residues[c][j] << padding_zeroes;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handled one subframe */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ++s->channel[c].cur_subframe;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23636, "substitutes": {"s": ["comments", "rs", "bs", "events", "params", "conf", "ants", "gets", "fs", "ims", "settings", "cs", "stats", "set", "ies", "ins", "its", "ords", "a", "os", "ls", "es", "times", "ids", "bes", "vs", "ps", "ds", "self", "b", "ts", "serv", "args", "less", "ports", "is", "v", "js", "gs", "m", "tes", "ows", "bits", "parts", "bis", "states", "status", "ains", "ms", "r", "ses", "ss", "results", "aws", "g", "ers", "hs", "services", "obj", "sts", "sys", "ats", "comm", "sq", "details", "w", "sb", "y", "has", "tests", "as", "sw", "ns", "changes", "sv", "qs", "xs", "h", "S", "als", "ops", "ex"], "i": ["rest", "json", "name", "multi", "ori", "ei", "ims", "chain", "mi", "info", "\u0438", "uri", "phi", "series", "ip", "iq", "ri", "ini", "ind", "ii", "x", "pi", "io", "f", "ki", "im", "list", "q", "o", "zi", "it", "b", "qi", "iu", "di", "in", "remote", "u", " I", "slice", "v", "menu", "hi", "m", "me", "si", "to", "xi", "init", "status", "history", "item", "point", "ai", "g", "ui", "li", "iri", "batch", "progress", "ci", "ix", "p", "parent", "id", "n", "y", "ij", "ti", "ie", "gi", "ic", "key", "cli", "sim", "ji", "e", "bi", "oi", "index", "h", "I", "ami", "ex"], "j": ["jj", "js", "q", "p", "z", "ja", "uj", "aj", "jp", "n", "dj", "l", "ij", "jc", "b", "jl", "k", "g", "jac", "J", "ji", "index", "ii", "jump", "kj", "v"], "rawpcm_tile": ["rawpcm_format", "rawpdu_tile", "rawpcm_seed", "rawpdu_id", "rawpcm_id", "rawpdu_seed", "rawpdu_format"], "padding_zeroes": ["padding_erones", "padding_zerones", "padding_zereros", "padding_neros", "padding_zos", "padding_zones", "padding_ereros", "padding_zeros", "padding_eros", "padding_eroes", "padding_noes", "padding_zoes", "padding_nones", "padding_nos"], "res": ["reset", "rest", "rs", "bits", "req", "resolution", "bytes", "result", "ms", "RES", "tx", "format", "pos", "rows", "key", "resp", "Res", "ress", "mem", "conv", "os", "vals", "pres", "rel", "progress", "response", "val"], "channels_for_cur_subframe": ["channels_for_cur_subframes", "channels_for_cur_popframe", "channels_for_cur_SubFrame", "channels_for_cur_fullframe", "channels_for_cur_subFrame", "channels_for_cur_topFrame", "channels_for_cur_fullframes", "channels_for_cur_popFrame", "channels_for_cur_Subchannel", "channels_for_cur_broadframe", "channels_for_cur_popframes", "channels_for_cur_topchannel", "channels_for_cur_popchannel", "channels_for_cur_subchannel", "channels_for_cur_topframe", "channels_for_cur_Subframes", "channels_for_cur_Subframe", "channels_for_cur_broadFrame", "channels_for_cur_fullFrame", "channels_for_cur_broadframes"], "channel": ["command", "chron", "character", "chn", "player", "pixel", "panel", "can", "console", "band", "unit", "column", "camera", "module", "domain", "service", "disc", "browser", "component", "bit", "chip", "annels", "config", "node", "video", "server", "version", "remote", "net", "button", "pipe", "message", "cho", "frame", "cue", "Channel", "variable", "voice", "chat", "member", "client", "store", "color", "entity", "actor", "cam", "byte", "ch", "attribute", "queue", "connection", "batch", "mon", "call", "container", "tube", "chan", "block", "course"], "cur_subframe": ["cur_conFrame", "cur_initialframe", "cur_conframe", "cur_subversion", "cur_initialdraw", "cur_shortframe", "cur_subFrame", "cur_descFrame", "cur_Subdraw", "cur_Subvideo", "cur_popFrame", "cur_deepframe", "cur_superFrame", "cur_deepfram", "cur_Subhole", "cur_searchframe", "cur_subdraw", "cur_superversion", "cur_subface", "cur_Subframe", "cur_snapframe", "cur_substream", "cur_modframe", "cur_Subset", "cur_Subversion", "cur_subrender", "cur_Subrender", "cur_searchrender", "cur_snapface", "cur_descvideo", "cur_popchannel", "cur_shortset", "cur_subserver", "cur_Subchannel", "cur_searchFrame", "cur_superchannel", "cur_modFrame", "cur_subfram", "cur_deepserver", "cur_subset", "cur_searchfram", "cur_deepvideo", "cur_initialhole", "cur_popframe", "cur_shortFrame", "cur_subchannel", "cur_subvideo", "cur_popversion", "cur_descframe", "cur_Subfram", "cur_superframe", "cur_subhole", "cur_conset", "cur_Substream", "cur_Subserver", "cur_deepFrame", "cur_constream", "cur_snapFrame", "cur_shortstream", "cur_SubFrame", "cur_descserver", "cur_modface", "cur_initialFrame", "cur_Subface", "cur_deeprender"]}}
{"project": "FFmpeg", "commit_id": "1bab6f852c7ca433285d19f65c701885fa69cc57", "target": 1, "func": "static void RENAME(yuv2rgb565_1)(SwsContext *c, const int16_t *buf0,\n\n                                 const int16_t *ubuf[2], const int16_t *bguf[2],\n\n                                 const int16_t *abuf0, uint8_t *dest,\n\n                                 int dstW, int uvalpha, int y)\n\n{\n\n    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];\n\n    const int16_t *buf1= buf0; //FIXME needed for RGB1/BGR1\n\n\n\n    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1b(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}\n", "idx": 23643, "substitutes": {"c": ["ctx", "cp", "ac", "m", "ci", "p", "ca", "v", "bc", "tc", "cache", "n", "cm", "mc", "cc", "C", "co", "b", "s", "cs", "fc", "lc", "ec", "t", "k", "g", "dc", "con", "cam", "e", "h", "rc", "f", "cont", "cv", "ct"], "buf0": ["uf3", "buffer1", "buff3", "buffer0", "buf5", "uf1", "cv5", "uf5", "buf3", "cv1", "buff1", "uf0", "buffer2", "buff0", "buf2", "buffer5", "cv0", "buff2", "uf2", "buffer3", "cv2"], "ubuf": ["rubuff", "udbuf", "ufbuf", "obump", "ubbuf", "obuf", "ubbf", "ufuff", "obbuf", "ufbuff", "udbuff", "rubuf", "umbuff", "obuff", "ubbuff", "abuf", "ufff", "umuf", "abuff", "umbuf", "ubuff", "uduf", "umuff", "abbuf", "ubff", "ubump", "abff", "ufuf", "ufbf", "udbf", "umbf", "rubump", "umump", "umff", "rubbuf"], "bguf": ["wbuff", "cbbuf", "dbuff", "cbuf", "dbpu", "bgpu", "cbuff", "cbpu", "wbbuf", "dbbuf", "wbpu", "dbuf", "bguff", "wbuf", "bgbuf"], "abuf0": ["ubbuf1", "abbuf4", "ubbuf4", "abuffer4", "abuf8", "ubbuf0", "abbuf1", "abuff1", "abuf1", "abuff8", "abbuf8", "abuffer0", "ubuf8", "abuff4", "abuff0", "abuffer8", "abbuf0", "abuffer1", "ubbuf8", "ubuf4", "abuf4"], "dest": ["temp", "cp", "end", "sp", "parent", "Dest", "port", "w", "ptr", "master", "trans", "wb", "src", "orig", "dist", "self", "win", "result", "iter", "cmd", "img", "origin", "cas", "output", "est", "target", "txt", "dc", "ref", "them", "desc", "buf", "window", "out", "source", "mem", "comb", "usr", "st"], "dstW": ["ddestWidth", "DestWidth", "DstPos", "ddestW", "DestP", "dblWidth", "ddestPos", "DstW", "dstP", "dblW", "dstWidth", "ddestP", "destW", "dstPos", "destWidth", "DstWidth", "destPos", "dblP", "destP", "DestW", "DestPos", "dblPos", "DstP"], "uvalpha": ["Uvalph", "Uvalphy", "uVALph", "uavalph", "UVALphy", "UVALph", " uvalmph", "upolpha", "uavalphy", "UVALpha", "uvalspha", "Uvalpha", "uvalphy", "uavalphi", " uvalphi", "Uvalphi", "uvalph", "uvalmph", "uVALphy", "UVALphi", "uvalsph", "upolphi", "uvalsmph", "uvalsphy", "uVALphi", "uVALpha", "upolph", "uvalsphi", "uavalpha", " uvalph", "uvalphi", "upolmph"], "y": ["iy", "ty", "oy", "p", "z", "ym", "ay", "yp", "py", "vy", "ly", "b", "ny", "ry", "Y", "i", "t", "yd", "yy", "iny", "ies", "dy", "ch", "xy", "x", "yi", "sy", "gy"], "ubuf0": ["ubbuf1", "abbuf2", "ubbuff5", "ubuf00", "ubuff00", "ubull1", "ubuff1", "ubuf5", "abbuf00", "ubbuf0", "abbuf1", "ubull6", "abuf1", "ubbuf5", "abbuf5", "ubuff0", "ubull2", "ubbuff1", "ubuff5", "abuf2", "ublf0", "ublf1", "abbuf6", "abuf5", "ubbuf2", "ubbuf00", "ubbuff00", "abbuf0", "ubuf6", "abuf00", "ubbuf6", "abuf6", "ublf2", "ublf6", "ubull0", "ubuf2", "ubbuff0"], "ubuf1": ["ubbuf1", "abbuf2", "ublf3", "ublu5", "ublu2", "ublu0", "ubuff1", "ubuf5", "ubbuf0", "abbuf1", "abuf1", "ubbuf5", "abbuf5", "ubuff0", "abuff1", "ubbuf3", "abuff2", "ublu1", "ubuf3", "abuff3", "abuff0", "abuf2", "ubuff5", "ublf0", "ublf1", "abuf5", "ubbuf2", "ubuff3", "abbuf0", "ubuff2", "ublf2", "abuf3", "ubuf2"], "buf1": ["uf3", "buffer1", "uf0", "buf3", "buff3", "buff2", "buffer2", "buff0", "buffer0", "uf2", "buff1", "buffer3", "uf1", "buf2"]}}
{"project": "qemu", "commit_id": "82e59a676c01b3df3b53998d428d0a64a55f2439", "target": 1, "func": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n", "idx": 23656, "substitutes": {"mon": ["min", "pid", "mont", "ox", "mx", "mm", "wat", "manager", "mons", "mn", "mut", "util", "unit", "dom", "ann", "mic", "master", "mu", "den", "timer", "MON", "mot", "man", "mi", "an", "lock", "admin", "bean", "onet", "monkey", "dm", "Mon", "met", "mun", "member", "coord", "mate", "monitor", "meter", "eor", "pers"], "qdict": [" qdir", "sqmap", "sqsum", "qrect", "qsum", "qcompl", "querdict", " qsession", "quersession", "qbody", "qsession", "qmap", "qdef", "qstr", " qdef", "sqrect", "iqrect", "sqdef", " qbody", "sqbody", "dqdir", "dqmap", " qsum", "iqbody", "dqdict", "qdir", "sqsession", "iqcompl", "dqdef", " qrect", " qcompl", " qstr", "quersum", "sqdict", "sqdir", "sqstr", "sqcompl", "iqdict", "querstr", " qmap"], "size": ["height", "sn", "sp", "ose", "state", "name", "type", "SIZE", "length", "small", "span", "scale", "Size", "needed", "capacity", "style", "max", "ms", "mode", "c", "send", "address", "empty", " sizes", "sym", "sum", "shape", "area", "message", "set", "count", "len", "code", "grow", "zero", "index", "ize", "dim", " Size", "space", "st", "sy"], "chardev": ["chardel", "edgedev", "chartel", "edgedel", "chidev", "ardev", "chiddev", "chardEv", "chartev", "vardev", "asserdev", "vardv", "chartEv", "asserEv", "arddev", "asserev", "edgedv", "charddev", "chartv", "vardEv", "edgedEv", "chidEv", "vardel", "ardEv", "chardv"], "data": ["done", "json", "dat", "missing", "file", "body", "supported", "name", "image", "length", "bin", "d", "rew", "def", "trans", "des", "value", "cache", "bytes", "it", "feed", "partial", " DATA", "result", "text", "raw", "empty", "step", "extra", "t", "format", "message", "sample", "buffer", "reader", "read", "len", "none", "source", "mem", "DATA", "form", "str", "ata", "batch", "rel", "Data", "table"], "errp": ["arrpb", "errpol", "corpb", "errm", "arrpol", " errpc", "errr", "errjp", "privpol", "corjp", "corp", "rrjp", "rrr", " errr", "privping", "arrps", " errm", "privp", "errpb", " erjp", "arrping", "arrm", "errping", " erp", "rrpc", " errpol", "errps", " errping", "errpc", "rrp", " err", "privps", "arrjp", " errpb", "arrp", " errps", "corm", " erpc", " errjp"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int do_bit_allocation(AC3DecodeContext *ctx, int flags)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i, snroffst = 0;\n\n\n\n    if (!flags) /* bit allocation is not required */\n\n        return 0;\n\n\n\n    if (ab->flags & AC3_AB_SNROFFSTE) { /* check whether snroffsts are zero */\n\n        snroffst += ab->csnroffst;\n\n        if (ab->flags & AC3_AB_CPLINU)\n\n            snroffst += ab->cplfsnroffst;\n\n        for (i = 0; i < ctx->bsi.nfchans; i++)\n\n            snroffst += ab->fsnroffst[i];\n\n        if (ctx->bsi.flags & AC3_BSI_LFEON)\n\n            snroffst += ab->lfefsnroffst;\n\n        if (!snroffst) {\n\n            memset(ab->cplbap, 0, sizeof (ab->cplbap));\n\n            for (i = 0; i < ctx->bsi.nfchans; i++)\n\n                memset(ab->bap[i], 0, sizeof (ab->bap[i]));\n\n            memset(ab->lfebap, 0, sizeof (ab->lfebap));\n\n\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    /* perform bit allocation */\n\n    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))\n\n        if (_do_bit_allocation(ctx, 5))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (flags & (1 << i))\n\n            if (_do_bit_allocation(ctx, i))\n\n                return -1;\n\n    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))\n\n        if (_do_bit_allocation(ctx, 6))\n\n            return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 23668, "substitutes": {"ctx": ["pkg", "xp", "vc", "np", "conf", "kt", "tmp", "tc", "iat", "sc", "conn", "nt", "pt", "gz", "dl", "pb", "resp", "buf", "cam", "wcs", "tz", "aka", "hw", "wx", "px", "cb", "cv", "cp", "gc", "jp", "unk", "cc", "tm", "cl", "rt", "support", "kl", "js", "mk", "via", "req", "loc", "xc", "ka", "anc", "nc", "proc", "history", "aux", "kw", "wd", "act", "kb", "jac", "msg", "txt", "ck", "obj", "abc", "sys", " cx", "ctl", "ct", "cfg", "kh", "bc", "ppo", "def", "typ", "mc", "ij", "etc", "tx", "tk", "cmd", "func", "handle", "pause", "context", "cf", "addr", "kj", "ia", "qq", "cmp", "mt"], "flags": ["comments", "FLAG", "amps", "modules", "points", "ants", "links", "types", "fs", "bugs", "settings", "stats", "actions", "wcs", "frames", "fps", "words", "acts", "posts", "ids", "lag", "vs", "marks", "lists", "ties", "ps", "lands", "ts", "flag", "faces", "args", "atts", "members", "ags", "ports", "reports", "aps", "lbs", "finals", "days", "locks", "pins", "gs", "bits", "rates", "requires", "tags", "weights", "eps", "status", "ms", "products", "limits", "groups", "terms", "cond", "olds", "options", "ats", "forces", "mask", "fields", "heads", "Flags", "styles", "rights", "tops", "details", "files", "grades", "packages", "allows", "fts", "plugins", "doms", "features", "planes", "levels", "cf", "properties", "vals", "ents"], "ab": ["ac", "af", "Ab", "ast", "bb", "eb", "bank", "nb", "bs", "am", "ub", "iam", "ag", "ash", " AB", "um", "av", "ace", "typ", "abi", "abl", "abe", "att", "lab", "ob", "aba", "b", "stab", "tab", "fab", "ib", "app", "hab", "grab", "bl", "rb", "abin", "abb", "pb", "ap", "ief", "a", "AB", "emb", "abc", "hal", "jab", "rab", "aka", "fb", "bart", "amb", "val"], "i": ["json", "multi", "by", " mi", "ei", "ims", "chain", "mi", "ski", "\u0438", "uri", "phi", "ip", "ri", "ini", "ind", "ico", "ii", "x", "pi", "io", "ki", "im", " pi", "any", "q", "o", " bi", "zi", "d", "cgi", "it", "l", "gu", "qi", "b", "iu", "di", "in", "k", "u", " j", "wi", " ni", "is", "v", "hi", "m", "me", "this", "my", "us", "si", " si", "xi", "er", "r", "PI", "point", "ai", "ui", "li", " Xi", " ti", "ci", "ix", "p", "id", "span", "n", "y", "mc", "ij", "ti", "s", "c", "j", "go", "t", "ie", " ii", "gi", "ic", "key", "cli", "sim", "ji", "bi", "e", "oi", "index", "eu", "I", "ex"]}}
{"project": "qemu", "commit_id": "761731b1805f6ef64eb615e5b82a0801db3cde78", "target": 0, "func": "void qmp_drive_backup(const char *device, const char *target,\n\n                      bool has_format, const char *format,\n\n                      enum MirrorSyncMode sync,\n\n                      bool has_mode, enum NewImageMode mode,\n\n                      bool has_speed, int64_t speed,\n\n                      bool has_on_source_error, BlockdevOnError on_source_error,\n\n                      bool has_on_target_error, BlockdevOnError on_target_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *target_bs;\n\n    BlockDriverState *source = NULL;\n\n    BlockDriver *drv = NULL;\n\n    Error *local_err = NULL;\n\n    int flags;\n\n    int64_t size;\n\n    int ret;\n\n\n\n    if (!has_speed) {\n\n        speed = 0;\n\n    }\n\n    if (!has_on_source_error) {\n\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_on_target_error) {\n\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n    if (!has_mode) {\n\n        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n\n    }\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (!bdrv_is_inserted(bs)) {\n\n        error_set(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n\n        return;\n\n    }\n\n\n\n    if (!has_format) {\n\n        format = mode == NEW_IMAGE_MODE_EXISTING ? NULL : bs->drv->format_name;\n\n    }\n\n    if (format) {\n\n        drv = bdrv_find_format(format);\n\n        if (!drv) {\n\n            error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n", "idx": 23680, "substitutes": {"device": ["dev", "product", "command", "volume", "spec", "serial", "family", "direction", "name", "engine", "image", "path", "port", "database", "Device", "unit", "project", "module", "DEV", "component", "test", "nexus", "feature", "address", "scope", "template", "location", "server", "directory", "remote", "network", "buffer", "controller", "driver", "drive", "disk", "pod", "window", "DE", "handle", "interface", "display", "connection", "model", "dimension", "sequence", "block"], "target": ["spec", "direction", "parent", "transform", "file", "type", "image", "path", "port", "src", "dest", "root", "address", "Target", "template", "location", "origin", "host", "t", "version", "buffer", "window", "handle", "base", "table"], "has_format": ["has_export", "has_options", "has67unit", "has___style", "has___format", " has__export", "has__export", "has___options", " has__name", "has__name", "has67name", "hat_style", "has_name", "has_unit", " has__format", "hat_format", "has__unit", "hat_options", " has_export", " has__unit", "has_style", "has__format", "has___module", " has_name", "has_module", " has_unit", "has67export", "has67format", "hat_module"], "format": ["temp", "command", "spec", "transform", "file", "alt", "at", "name", "api", "type", "filename", "mat", "port", "path", "former", "unit", "tag", "module", "ant", "scale", "it", "layout", "test", "status", "feat", "att", "capacity", "style", "region", "prefix", "text", "fn", "address", "feature", "config", "template", "origin", "act", "version", "flat", "tif", "error", "message", "output", "MAT", "Format", "pattern", "form", "title", "option", "filter", "fp", "mt", "f", "term"], "sync": ["m", "connect", "so", "spec", "write", "np", "scroll", "syn", "scale", "service", "dirty", "status", "style", "settings", "lock", "cs", "scope", "scan", "sym", "rate", "stats", "trigger", "remote", "directory", "disable", "loop", "set", "buffer", " synchronization", "driver", "disk", "poll", "link", "ync", "sys", "enable", "Sync", "use"], "has_mode": ["has_profile", "does_mode", "Has_module", "has___mode", "Has_mode", "has67profile", "Has_format", "does_profile", "has___format", "has___force", "hasTheformat", "hasThemode", "hasThememory", "has___profile", "does_format", "has_force", "does___force", "does___format", "has_memory", "Has_memory", "does_force", "has67mode", "has_module", "hasThemodule", "does___mode", "has67format", "has67force", "does___profile"], "mode": ["stage", "command", "m", "me", "spec", "direction", "transform", "depth", "MODE", "name", "id", "type", "mod", "image", "module", "scale", "layout", "test", "status", "role", "style", "settings", "lock", "scope", "template", "flag", "only", "trigger", "version", "move", "directory", "error", "set", "message", "match", "metadata", "usage", "network", "driver", "position", "options", "time", "option", "policy", "Mode", "enable", "model", "theme", "mt", "use"], "has_speed": ["has_transform", "has42wait", "has_weight", "haspleengine", "factsEtransform", "facts_mode", "factsEmode", "hasEtransform", "has42weight", "hasThemode", "have_weight", "factsEspeed", "hasEengine", "hasplemode", "has_direction", "haspletransform", "hasTheengine", "facts_speed", "hasEspeed", "have_speed", "has_engine", "have_wait", "facts_transform", "hasThespeed", "has42direction", "have_direction", "factsEengine", "has_wait", "hasThetransform", "has42speed", "facts_engine", "hasplespeed", "hasEmode"], "speed": ["command", "spec", "frequency", "start", "transform", "state", "type", "seed", "engine", "length", "port", "power", "scroll", "Speed", "scale", "service", "offset", "status", "capacity", "limit", "access", "send", "score", "address", "sw", "delay", "rate", "performance", "timeout", "efficiency", "error", "peed", "buffer", "skip", "driver", "count", "read", "interface", "sex", "index", "ize", "slow", "weight", "seek"], "has_on_source_error": ["has_on_src_ror", "has_on_source_ror", "has_on_source_Error", "has_on_source__ror", "has_on_src__error", "has_on_src__ror", "has_on_src_err", "has_on_source__error", "has_on_source__err", "has_on_src_error", "has_on_src__err", "has_on_source_err", "has_on_source_success"], "on_source_error": ["on_source00request", "on_source00error", "on_image_error", "on_image00error", "on_src_error", "on_image_request", "on_src_err", "on_sourcelyresult", "on_image_err", "on_source_request", "on_sourcelyerr", "on_image00request", "on_source_err", "on_source_result", "on_image00err", "on_src_result", "on_source00err", "on_sourcelyerror"], "has_on_target_error": ["has_on_source_owner", "has_on_target_owner", "has_on_target_success", "has_on_source_err", "has_on_target_err", "has_on_source_success"], "on_target_error": ["on_target__owner", "on_target_owner", "on_target__err", "on_Target_err", "on_Target_error", "on_target__error", "on_target___ror", "on_target_complete", "on_target__ror", "on_source_err", "on_target___complete", "on_target_err", "on_target___err", "on_source_complete", "on_Target_owner", "on_source_ror", "on_target___error", "on_target_ror", "on_Target_ror"], "errp": ["rrpp", "drpg", "errpun", "rcpoint", "rrpr", "derp", "eorpc", "warnr", "ererpa", "warnpe", " errP", "errr", "eorpin", "ererpr", "errpp", "errpoint", "drP", "erP", "derpin", "drp", "rrP", " errr", "testpp", "errpe", " errpg", "ererp", "testp", "errpre", " errpr", "rrpa", "erpg", " erpun", "eorp", "drr", " erp", "rcp", "errpc", " errpe", "errpin", "rcpre", "errpg", "rrp", "testpre", "errpr", "erp", "warnp", "rrpoint", "testpoint", "rrpre", "derpun", "errpa", "rcpp", "errP", "err", " errpa", " erpin", "ererP", "eorpun", " erpc", "erpe", "derpc", "warnP"], "bs": ["js", "gs", "bed", "ls", "bb", "eb", "bing", "hz", "rs", "bits", "bc", "box", "bes", "sb", "vs", "outs", "bp", "ps", "bis", "bytes", "fs", "ds", "b", "s", "settings", "cs", "bm", "ts", "ss", "ys", "ubis", "uds", "aos", "bles", "bh", "res", "bl", "BS", "ubs", "ns", "cks", "pb", "its", "boxes", "socket", "bps", "hs", "obs", "bi", "sys", "bos", "fps", "lbs", "bas", "cb", "bn"], "target_bs": [" target_ds", " target_sb", " target_BS", "target_ds", "target_BS", "target_sb"], "source": ["volume", "Source", "sn", "inner", "start", "sp", "input", "file", "parent", "ource", "id", "data", "si", "image", "port", "master", "proxy", "service", "src", "copy", "dest", "status", "site", "ser", "s", "join", "slave", "origin", "i", "server", "remote", "pipe", "from", "SOURCE", "stream", "select", "instance", "interface", "local", "peer", "resource", "object", "table"], "drv": ["rdw", "crv", "DRk", " drva", "drva", "srv", "srvs", "rdV", "rdv", "trv", " drf", "trva", " drvr", "srp", "trk", "drve", "drw", "rdf", " drw", "crvr", "srV", "DRva", "srvr", "drp", " drve", "drV", "drk", "crp", "drvr", "drvs", "srw", "trvs", "drm", "rdve", "rdvr", " drk", "rdvs", "drf", "srve", "crV", "DRvs", "DRv", "srm", "rdp", " drvs", "rdm", "srf", " drm"], "local_err": ["local2arr", "remote2err", "local2err", "remote_error", "remote_msg", "remote2error", "remote2msg", "local_msg", "local_error", "localewmsg", "local2msg", "localewerr", "remote_arr", "local_arr", "localewerror", "localewarr", "remote_err", "remote2arr", "local2error"], "flags": ["FLAG", "bits", "times", "tags", "links", "ps", "states", "types", "fd", "fs", "status", "ms", "settings", "cs", "ts", "flag", "faces", "stats", "utils", "tif", "args", "relations", "names", "actions", "ags", "frames", "options", "features", "ports", "fps", "properties", "mask", "weight", "ops", "fields", "heads", "Flags", "locks"], "size": ["sn", "start", "body", "z", "name", "type", "SIZE", "length", "scale", "Size", "bytes", "offset", "max", "send", "empty", "timeout", "sum", "izes", "count", "read", "ram", "mem", "time", "ize", "sd"], "ret": ["num", "success", "rs", "params", "Ret", "port", " quiet", "status", " total", " resp", "limit", "no", " number", " mem", "match", " RET", "read", "len", "mem", " status", "sys", " returns", "RET", "val"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write(void *opaque, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    MaltaFPGAState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfffff);\n\n\n\n    switch (saddr) {\n\n\n\n    /* SWITCH Register */\n\n    case 0x00200:\n\n        break;\n\n\n\n    /* JMPRS Register */\n\n    case 0x00210:\n\n        break;\n\n\n\n    /* LEDBAR Register */\n\n    case 0x00408:\n\n        s->leds = val & 0xff;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIWORD Register */\n\n    case 0x00410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23688, "substitutes": {"opaque": ["iopaque", "opaques", "iplay", "paques", "opacity", "ipaques", "iopace", "popatile", " opacity", "oplay", "ipacity", "oaque", "paque", " oplay", "oacity", "oace", "iopacity", "popacity", "popaque", "pacity", "play", "popace", "opace", "iopatile", "opatile", "ipaque", " opaques", "oatile"], "addr": ["ctx", "height", " ref", "ix", "add", "Address", "adr", "start", "rs", "alt", "id", "pad", " dst", "loc", "ptr", "src", " address", "wid", "rn", "offset", "l", "inter", "attr", "ser", "address", "r", "ord", "cmd", "host", "act", "pos", "res", "gate", "ref", "hop", " mac", "align", "hash", " err", "work", "sha", "a", "obj", "mem", "arr", "index", "x", "rc", "hw", "err", "alloc", "ad", "cb", "ack", "v"], "val": ["ve", "sel", "conf", " needle", "sol", "prop", "test", "ret", " vel", "pt", " update", "resp", "bal", " aval", "buf", "arg", "arr", "x", "pal", "cal", "ctx", "vt", "data", "ival", "util", " tx", "vol", "fail", "serv", " arg", "Val", "pol", "hash", "len", "xy", " ret", " eval", "v", "dev", "num", "aval", "alt", " msg", "lex", "item", "eval", "res", "bl", "msg", "txt", "var", "al", "el", "obj", "err", "elt", "valid", "rel", " valid", "stat", "Value", "p", "pr", "def", "value", "pl", "true", " resp", "VAL", "tx", " v", " value", "t", "cho", "key", "ref", "ul", "rol", "mem", "index", "vals", "label"], "size": ["num", "data", "sp", " length", "z", "name", "type", "SIZE", "length", "ffff", "d", "Size", "n", "offset", "l", "c", "address", "count", "align", "len", "code", "e", "mem", " len", "h", "ize", "cap"], "s": ["js", "gs", "m", "spec", "ssl", "sl", "ls", "sn", "sq", "p", "sp", "es", "rs", "bs", "params", "sb", "vs", "des", "service", "ps", "bis", "n", "y", "fs", "sm", "ds", "sis", "ims", "ms", "an", "cs", "sw", "ses", "ts", "serv", "ss", "stats", "t", "set", "ns", "its", "changes", "ins", "hs", "obj", "sam", "services", "source", "sts", "sv", "qs", "sys", "ats", "se", "os", "h", "S", "ops", "st", "is", "pers", "comm"], "saddr": [" scoord", "wsaddr", "Ssrc", "svcoord", " saddress", "dsaddr", "wsrc", "dsalign", "waddr", "rscoord", "rsnode", "srd", "wsptr", "svnode", " srd", "svaddress", "dsaddress", " sptr", "snode", "svptr", "dsptr", "snow", " ssrc", "ssrc", "svalign", "rsaddress", "wsnow", " snow", "rsaddr", " snode", "wsrd", "sptr", "waddress", "svaddr", "Saddr", "salign", "Saddress", "scoord", "saddress"]}}
{"project": "FFmpeg", "commit_id": "94bb1ce882a12b6d7a1fa32715a68121b39ee838", "target": 0, "func": "static int revert_channel_correlation(ALSDecContext *ctx, ALSBlockData *bd,\n\n                                       ALSChannelData **cd, int *reverted,\n\n                                       unsigned int offset, int c)\n\n{\n\n    ALSChannelData *ch = cd[c];\n\n    unsigned int   dep = 0;\n\n    unsigned int channels = ctx->avctx->channels;\n\n\n\n    if (reverted[c])\n\n        return 0;\n\n\n\n    reverted[c] = 1;\n\n\n\n    while (dep < channels && !ch[dep].stop_flag) {\n\n        revert_channel_correlation(ctx, bd, cd, reverted, offset,\n\n                                   ch[dep].master_channel);\n\n\n\n        dep++;\n\n    }\n\n\n\n    if (dep == channels) {\n\n        av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel correlation!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bd->const_block = ctx->const_block + c;\n\n    bd->shift_lsbs  = ctx->shift_lsbs + c;\n\n    bd->opt_order   = ctx->opt_order + c;\n\n    bd->store_prev_samples = ctx->store_prev_samples + c;\n\n    bd->use_ltp     = ctx->use_ltp + c;\n\n    bd->ltp_lag     = ctx->ltp_lag + c;\n\n    bd->ltp_gain    = ctx->ltp_gain[c];\n\n    bd->lpc_cof     = ctx->lpc_cof[c];\n\n    bd->quant_cof   = ctx->quant_cof[c];\n\n    bd->raw_samples = ctx->raw_samples[c] + offset;\n\n\n\n    dep = 0;\n\n    while (!ch[dep].stop_flag) {\n\n        unsigned int smp;\n\n        unsigned int begin = 1;\n\n        unsigned int end   = bd->block_length - 1;\n\n        int64_t y;\n\n        int32_t *master = ctx->raw_samples[ch[dep].master_channel] + offset;\n\n\n\n        if (ch[dep].time_diff_flag) {\n\n            int t = ch[dep].time_diff_index;\n\n\n\n            if (ch[dep].time_diff_sign) {\n\n                t      = -t;\n\n                begin -= t;\n\n            } else {\n\n                end   -= t;\n\n            }\n\n\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1    ]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp        ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1    ]) +\n\n                     MUL64(ch[dep].weighting[3], master[smp - 1 + t]) +\n\n                     MUL64(ch[dep].weighting[4], master[smp     + t]) +\n\n                     MUL64(ch[dep].weighting[5], master[smp + 1 + t]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        } else {\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp    ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        }\n\n\n\n        dep++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23692, "substitutes": {"ctx": ["pkg", "xp", "np", "grad", "params", "conf", "kt", "tc", "iat", "conn", "sc", "pc", "care", "resp", "work", "tz", "crit", "rpm", "x", "hw", "px", "course", "cv", "cp", "gc", "command", "mom", "jp", "util", "ann", "cc", "tm", "prefix", "rt", "pat", "config", "cas", "shape", "bh", "setup", "cu", "conv", "kl", "this", "cn", "req", "loc", "xc", "anc", "nc", "cm", "Context", "history", "aux", "kw", "wd", "act", "timeout", "working", "jac", "txt", "ck", "std", "obj", "sys", " cx", "ctl", "ct", "bo", "cfg", "comm", "kh", "ca", "bc", "mc", "etc", "fc", "tx", "tk", "cmd", "utils", "func", "handle", "context", "cf", "addr", "ia", "cmp", "pg", "val"], "bd": ["cdn", "js", "dev", "bed", "edd", "bb", "add", "ard", "bar", "bs", "vd", "bid", "bc", "deb", "bo", "ba", "box", "d", "sb", "ld", "band", "def", "gb", "gd", "pd", "bp", "br", "disc", "des", "dt", "fd", "bel", "ds", "hd", "b", "dh", "bm", "dis", "ben", "bt", "board", "di", "da", "ded", "bh", "disabled", "cond", "db", "bl", "kb", "dl", "ed", "lt", "od", "dd", "bn", "pb", "nd", "ond", "dc", "md", "note", "bot", "bf", "lay", "ad", "th", "sd", "BD", "cb", "bind"], "cd": ["cp", "cr", "xd", "ca", "dial", "td", "vd", "deb", "CD", "d", "ld", "dom", "gb", "pd", "cm", "cc", "cz", "cl", "ds", "hd", "ands", "cs", "ecd", "cmd", "kb", "od", "nd", "dc", "dd", "did", "ck", "dem", "de", "md", "cand", "cf", "ad", "sd", "cb", "cod", "ct"], "reverted": ["recved", "areverted", "referred", "crevert", "recvert", " revert", "convert", "resferred", "conferred", "crejected", "REferred", "reved", "recstructed", "resvert", "rechanged", "REverted", "roved", "areverting", "roverted", "revved", "roverting", "converted", "resved", "restructed", "reschanged", "revverted", "REved", "revert", "rovert", "areved", "arevert", "rejected", "creferred", " rechanged", " reved", "revstructed", "resverting", "conjected", "revferred", "reverting", "resverted", "resjected", "recchanged", "REstructed", "creverted", "recverted", "recferred"], "offset": [" whence", "cp", "rot", "end", "frequency", "start", "q", "o", "id", "image", "adjusted", "lag", "unk", "padding", "mt", "scroll", "forced", "unit", "cm", "needed", " offsets", "shift", "aff", "Offset", "bound", "attr", "oint", "address", "no", "online", "location", "origin", "point", "pointer", "order", "pos", "ut", "timeout", "size", "set", "error", "output", "ed", "unc", "amp", "position", "ref", "et", "hop", "seek", "align", "channel", "off", "coord", "out", "base", "crop", "conv", "index", "time", "attribute", "oid", "batch", "addr", "fp", "block", "f"], "c": ["ac", "cp", "gc", "m", "cr", "spec", "ci", "q", "p", "vc", "ca", "o", "cn", "bc", "conf", "d", "tc", "anc", "cache", "n", "cm", "mc", "cc", "sc", "nc", "C", "l", "co", "com", "chain", "b", "cs", "fc", "r", "lc", "config", "ec", "i", "uc", "t", "ce", "k", "g", "col", "pc", "cat", "unc", "dc", "count", "cv", "con", "a", "e", "abc", "cu", "conv", "h", "x", "category", "cf", "rc", " C", " count", "cmp", "arc", "f", "cont", "cb", "v", "ct"], "ch": ["cp", "wh", "cr", "cor", "chn", "vc", "zh", "Ch", "ches", "conf", "cha", "arch", "chart", "qu", "br", "sc", "cm", "cht", "cz", "ech", "ich", "cl", "ht", "sky", "chip", "att", "chain", "proc", "cs", "sh", "gr", "cmd", "comm", "cho", "col", "sch", "pol", "CH", "channel", "code", "spl", "th", "ach", "che", "cand", "tch", "chan", "cb", "v", "ct"], "dep": ["pkg", "dir", "del", "pp", "gl", "depend", "pe", "ld", "vel", "decl", "deep", "dr", "dl", "dc", "dd", "de", "pri", "resp", "md", "ind", "op", "im", "cp", "ep", "inc", "deb", "d", "yp", "inter", "pat", "iter", "dp", "tip", "desc", "dig", "pas", "dev", "hr", "depth", "imp", "push", "req", "dx", "loc", "debug", "ptr", "rem", "deg", "dem", "lip", "hl", "rel", "df", "comm", "eg", "p", "id", "supp", "gov", "def", "pl", "dist", "DEP", "Dep", "dependent", "cmd", "det", "db", "ref", "coord", "rec", "index", "dq", "dim", "cmp"], "smp": ["nsamp", "hscmp", "spm", "cspm", "lspl", "ospm", " smm", "nspm", " samp", "hspl", "gsmp", "scmp", "nscp", "gsmt", "Samp", "csmt", "scp", "gspm", " scp", "spar", " scmp", "lscmp", "Scmp", "atscmp", "ismp", "osmt", " spar", " spl", "atsamp", "samp", "osmp", "atsmp", "Smp", "Smm", "smm", "lsmp", "cspar", "spl", "hspar", "isamp", "gspar", "ispm", "nsmp", "ospar", " spm", "smt", "csmp", "hsmp", "iscp", "atsmm", "lspar"], "y": ["iy", "m", "ty", "oy", "my", "z", "ier", "type", "fy", "ym", "ay", "py", " ty", "vy", "ly", "ye", "sky", "b", "ny", "ry", "Y", "j", "ys", "i", "t", "yy", "iny", "ies", "ey", "xy", "sys", "x", "cy", "yi", "ia", "yer", "ya", "sy", "gy"], "master": ["mad", "m", "my", "parent", "manager", "secondary", "aster", "tmp", "field", "masters", "primary", "counter", "er", "max", "worker", "top", "slave", "node", "origin", "map", "target", "base", "mem", "pre", "mid", "peer", "table", "Master"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_hpet(GArray *table_data, GArray *linker)\n\n{\n\n    Acpi20Hpet *hpet;\n\n\n\n    hpet = acpi_data_push(table_data, sizeof(*hpet));\n\n    /* Note timer_block_id value must be kept in sync with value advertised by\n\n     * emulated hpet\n\n     */\n\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n\n    hpet->addr.address = cpu_to_le64(HPET_BASE);\n\n    build_header(linker, table_data,\n\n                 (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL);\n\n}\n", "idx": 23696, "substitutes": {"hpet": ["hspit", "hanpet", "ihpret", "ohped", "ehPet", "exppret", "Hped", "hspel", "hanett", "ihvet", "Hpet", "harpit", "harpet", "hpret", "bhpet", "HPet", "ehpet", "ihpit", "hopel", "hvet", "hett", " hpel", "cpret", "ehvet", " hvet", "ihett", "bhpret", "harpel", "ehett", "bhpel", "hpit", "exppet", "harett", "cett", "ohett", " hped", "Hett", " hett", "expett", "hanpel", "hPet", "Hvet", "hsvet", " hPet", "expPet", "ohpret", "ohvet", "Hpret", " hpit", "ihpet", "hanpret", "hspet", " hpret", "cvet", "hsett", "hoett", "cpet", "bhett", "hopet", "ihPet", "hopit", "hped", "hpel", "ohpet"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_1r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;\n\n    }\n\n}\n", "idx": 23704, "substitutes": {"samples": ["sounds", "alsplays", " socks", "jsamples", "ariffs", "says", "alsimens", " sprints", "namps", "commamps", "sples", "assamples", "commimens", " samps", "assources", "sizes", "sicks", " sactions", "simens", "mamples", "siffs", " simens", "jsources", "socks", "timesamps", "timesiffs", "mizes", "portsinks", " sourses", "aramps", "commamples", " sicks", "Serences", "arerences", " sources", "mamps", "alsactions", "commactions", "portsamps", "Samples", "assples", "aramples", "timeserences", " sinks", "Sources", "hources", "commples", "portsprints", "Sourses", "sourses", "nizes", "jsounds", "Sinks", "portsamples", "serences", "Samps", "jsamps", " splays", "Sprints", "hamples", "sinks", "assicks", "alsamples", "splays", "sactions", "Socks", "commourses", "sprints", "sources", "commplays", "Siffs", "namples", "assocks", " sizes", "samps", "nays", " says", " sounds", "Sicks", "mays", "hamps", "Sples", " sples", "assamps", "timesamples", "hounds"], "i": [" im", "name", " li", "multi", " mi", "ei", "ims", "chain", "mi", "ir", "\u0438", " my", "uri", "phi", "ip", "iq", "ri", "ini", "ind", "x", "ii", "pi", "io", "ki", "im", " pi", " bi", "zi", "esi", " it", "it", " axis", "qi", "iu", "iter", "di", "in", "print", " I", " me", " j", " ni", "is", "me", "m", "this", "us", "si", " di", "to", "init", "xi", " ki", " key", "ai", "g", "fi", "ui", " multi", "li", " err", "iri", "batch", " ti", "ix", "ci", " iter", " index", "id", "y", "ij", "ti", "j", " ii", "gi", "ic", "key", "cli", "sim", "ji", "bi", "oi", "index", "asi", "I", "ami", " is"]}}
{"project": "FFmpeg", "commit_id": "cd1047f3911fa0d34c86f470537f343d23c8b956", "target": 0, "func": "static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    const AVPixFmtDescriptor *desc;\n\n    mfxSession session = NULL;\n\n    int iopattern = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n    int frame_width  = avctx->coded_width;\n\n    int frame_height = avctx->coded_height;\n\n    int ret;\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!desc)\n\n        return AVERROR_BUG;\n\n\n\n    if (!q->async_fifo) {\n\n        q->async_fifo = av_fifo_alloc((1 + q->async_depth) *\n\n                                      (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*)));\n\n        if (!q->async_fifo)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_QSV && avctx->hwaccel_context) {\n\n        AVQSVContext *user_ctx = avctx->hwaccel_context;\n\n        session           = user_ctx->session;\n\n        iopattern         = user_ctx->iopattern;\n\n        q->ext_buffers    = user_ctx->ext_buffers;\n\n        q->nb_ext_buffers = user_ctx->nb_ext_buffers;\n\n    }\n\n\n\n    if (avctx->hw_frames_ctx) {\n\n        AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;\n\n\n\n        if (!iopattern) {\n\n            if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)\n\n                iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY;\n\n            else if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)\n\n                iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;\n\n        }\n\n\n\n        frame_width  = frames_hwctx->surfaces[0].Info.Width;\n\n        frame_height = frames_hwctx->surfaces[0].Info.Height;\n\n    }\n\n\n\n    if (!iopattern)\n\n        iopattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;\n\n    q->iopattern = iopattern;\n\n\n\n    ret = qsv_init_session(avctx, q, session, avctx->hw_frames_ctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;\n\n    param.mfx.FrameInfo.FourCC         = q->fourcc;\n\n    param.mfx.FrameInfo.Width          = frame_width;\n\n    param.mfx.FrameInfo.Height         = frame_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0)\n\n        return ff_qsv_print_error(avctx, ret,\n\n                                  \"Error initializing the MFX video decoder\");\n\n\n\n    q->frame_info = param.mfx.FrameInfo;\n\n\n\n    return 0;\n\n}\n", "idx": 23714, "substitutes": {"avctx": ["avsys", "avesc", "avercp", "avcb", "aftx", "avconf", "avcmp", " avcb", "avekt", "AVcfg", " avmom", "avectx", "aveconf", "vjac", "avcontext", "avmom", "devtx", "avecmd", " avtx", "devctx", "avtx", "averpkg", "avct", "aversys", "avercmp", "AVpkg", "AVsc", "avercmd", "ajsys", "avecb", "ajctx", "navctx", "avcp", "afctx", " avcmp", "AVjac", "navcb", "avjac", "avsc", "ajctl", "averjac", "avepkg", "avectl", "AVcontext", "AVconf", "afcmd", "ajcfg", "AVctl", " avcontext", " avjac", "averctx", " avkt", "avkt", "afcontext", " avct", "AVtx", "devcp", "avertx", "devsys", "avcfg", "vkt", "navtx", "aversc", "ajcp", "navcontext", "vcontext", "avercontext", "navmom", "devcontext", " avcmd", "avecontext", "devct", "afjac", "AVcmp", "navct", "ajtx", "vctx", "avpkg", "AVcmd", "AVctx", "avejac", "avecfg", "avctl", "ajconf", "avemom", "avcmd"], "q": ["ctx", "pkg", "m", "sq", "p", "required", "Q", "qt", "qa", "z", "req", "quit", "conf", "eq", "w", "ctrl", "d", "qu", "conn", "aq", "needed", "it", "ue", "l", "qi", "quick", "c", "lock", "requ", "kw", "j", "query", "t", "k", "g", "msg", "ck", "f", "iq", "comment", "ch", "qs", "crit", "h", "queue", "x", "dq", "qq", "quest", "quant", "pg", "v", "comm"], "desc": ["meta", "dev", "pkg", "dir", "description", "req", "conf", "esc", "ptr", "d", "def", "des", "gd", "disc", "sc", "conn", "ext", "dist", "ds", "etc", "asc", "doc", "decl", "enc", "cmd", "ec", "dr", "Desc", "msg", "dc", "txt", "vec", "buf", "cam", "sec", "DES", "mem", "rec", "bd", "err", "cmp", "dep"], "ret": ["alt", "par", "sel", "req", "Ret", "def", "status", "result", " resp", "rt", "ry", "proc", "flag", "tif", "res", "ref", "re", "resp", "out", "len", "mem", "sys", "RET", "back", "val"], "user_ctx": [" user_na", " user_ca", " user_obj", "user____jac", "user_obj", "User_pkg", "User_ctx", "User_loc", "user____ctx", "user_tx", " user_pkg", "user_nt", "User_tx", "student_pkg", "user_jac", "user_na", " user_sys", "user_pkg", "user_cmp", " user_cmp", "student_nt", "user____nt", " user_ct", " user_tx", "user____pkg", "student_ctx", "student_jac", "user_ct", "user_ca", "user_sys", "user_loc"], "frames_ctx": ["frames_comp", "frames___ctx", "frames2hw", "frames___ck", "frames____ctx", "lights___ck", "frames2src", "frames___comp", "lights_comp", " frames2crit", "frames_hw", " frames2src", "frames_crit", "lights___conv", "frames_conv", "frames2crit", "frames_ck", "frames____conv", "lights___comp", "lights_conv", "frames____ck", " frames_crit", "frames_src", " frames_src", " frames_hw", "lights_ck", "lights___ctx", "lights_ctx", "frames2ctx", "frames____comp", "frames___conv", " frames2hw", " frames2ctx"], "frames_hwctx": ["frames_iwctx", "frames_dllobj", "frames_windctx", "frames_nwtx", "frames_hwaddr", "frames_iwheight", "frames_fwheight", "frames_fwaddr", "frames_htobj", "frames_htctx", "frames_iwcmp", "frames_hmctx", "frames_httx", "frames_htcfg", "frames_dllctx", "frames_dllpkg", "frames_htaddr", "frames_nwctx", "frames_iwkg", "frames_nwcfg", "frames_hwpkg", "frames_iwaddr", "frames_dllheight", "frames_htpkg", "frames_iwpkg", "frames_hwobj", "frames_hwheight", "frames_nwobj", "frames_windkg", "frames_hwkg", "frames_windsys", "frames_hwsys", "frames_fwctx", "frames_fwcfg", "frames_fwtx", "frames_windcmp", "frames_hmcmp", "frames_iwobj", "frames_hmkg", "frames_hwtx", "frames_iwsys", "frames_hwcmp", "frames_fwobj", "frames_hmsys", "frames_fwpkg", "frames_hwcfg"]}}
{"project": "qemu", "commit_id": "b6ce27a593ab39ac28baebc3045901925046bebd", "target": 0, "func": "static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,\n\n                                         VirtIOPCIRegion *region,\n\n                                         struct virtio_pci_cap *cap)\n\n{\n\n    memory_region_add_subregion(&proxy->modern_bar,\n\n                                region->offset,\n\n                                &region->mr);\n\n\n\n    cap->cfg_type = region->type;\n\n    cap->offset = cpu_to_le32(region->offset);\n\n    cap->length = cpu_to_le32(memory_region_size(&region->mr));\n\n    virtio_pci_add_mem_cap(proxy, cap);\n\n}\n", "idx": 23744, "substitutes": {"proxy": ["connect", "profile", "callback", "manager", "engine", "library", "port", "web", "Proxy", "super", "project", "module", "domain", "service", "conn", "cache", "request", "force", "phy", "browser", "mi", "pse", "core", "pin", "embed", "slave", "host", "clone", "server", "shadow", "remote", "map", "cas", "pc", "gate", "driver", "client", "php", "ping", "socket", "device", "link", "window", "roxy", "gp", "reference", "boss", "native", "virtual", "connection", "pool"], "region": ["relation", "command", "gc", "memory", "slot", "esi", "port", "roy", "division", "span", "unit", "tag", "widget", "range", "ion", "module", "domain", "definition", "role", "prefix", "address", "storage", "scope", "grid", "item", "script", "angular", "location", "Region", "contin", "rar", "format", "remote", "city", "reg", "area", "shape", "res", "REG", "regulation", "section", "ge", "desc", "snap", "window", "group", "session", "gru", "record", "local", "rule", "reference", "resource", "batch", "dimension", "dim", "block", "country", "zone"], "cap": ["ac", "cfg", "cp", "CAP", "acc", "ape", "pub", "ca", "pp", "cn", "cast", "bc", "ctrl", "rip", "tc", "pan", "copy", "sc", "ab", "Cap", "cod", "pl", "cl", "com", "cum", "rep", "acl", "c", "sh", "fab", "cmd", "act", "ct", "map", "fac", "capt", "lip", "ck", "ap", "snap", "cam", "sam", "pay", "ch", "aps", "cf", " caps", "cmp", "caps", "ipp", "claim", "trace", "cv", "comm"]}}
{"project": "qemu", "commit_id": "d044be3714db9c3750c430a2bb1be74beee6fd27", "target": 0, "func": "static void mixer_reset (AC97LinkState *s)\n\n{\n\n    uint8_t active[LAST_INDEX];\n\n\n\n    dolog (\"mixer_reset\\n\");\n\n    memset (s->mixer_data, 0, sizeof (s->mixer_data));\n\n    memset (active, 0, sizeof (active));\n\n    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */\n\n    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);\n\n    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);\n\n\n\n    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);\n\n    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);\n\n    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);\n\n    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);\n\n    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n\n    mixer_store (s, AC97_General_Purpose         , 0x0000);\n\n    mixer_store (s, AC97_3D_Control              , 0x0000);\n\n    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n\n\n\n    /*\n\n     * Sigmatel 9700 (STAC9700)\n\n     */\n\n    mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n\n    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n\n\n\n    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n\n    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n\n    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n\n    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n\n    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n\n\n\n    record_select (s, 0);\n\n    set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n\n    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n\n    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n\n\n\n    reset_voices (s, active);\n\n}\n", "idx": 23747, "substitutes": {"s": ["south", "full", "rs", "bs", "sql", "sol", "fs", "ims", "settings", "cs", "stats", "ins", "its", "a", "os", "f", "ls", "q", "z", "ties", "ps", "ds", "l", "b", "ts", "less", "reports", "local", "is", "locks", "v", "js", "gs", "m", "sets", "tes", "ssl", "sl", "us", "bits", "states", "status", "ms", "r", "ses", "ss", "aws", "res", "g", "hs", "sts", "sys", "sports", "comm", "spec", "p", "sq", "details", "w", "sb", "n", "y", "c", "sync", "as", "sw", "j", "i", "t", "ns", "changes", "sv", "qs", "xs", "h", "S"], "active": ["current", "js", " busy", " current", "data", "playing", "full", "memory", "seq", " events", "activated", "sol", "selected", "stable", " interactive", "visible", " activate", "primary", "status", "available", "quick", "registered", "used", "tx", "items", "shared", "act", "initialized", "disabled", "res", " Active", "activate", " idle", "actions", "pressed", "a", "Active", "running", " reactive", "all", " activated", " indexed", " status", "h", "live", " inactive", "valid", "locks", " dynamic", " all", "actively"]}}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23751, "substitutes": {"bs": ["ctx", "js", "gs", "ls", "bb", "rs", "bits", "bc", "bes", "sb", "vs", "gb", "bp", "bis", "ps", "bytes", "fs", "ds", "b", "ms", "s", "cs", "iss", "ts", "ses", "ss", "stats", "ubis", "aos", "bles", "bh", "ubs", "BS", "ns", "cks", "pb", "its", "ks", "bps", "obs", "bi", "bf", "sys", "bos", "os", "lbs", "uts", "bas", "cb", "bn"], "offset": ["command", "reset", "end", "start", "data", "o", "alias", "alt", "entry", "pad", "length", "loc", "mt", "util", "iat", "original", " offsets", "amount", "shift", "Offset", "bound", "prefix", "offer", "address", "origin", "point", "pointer", "pos", "size", "set", "error", "skip", "key", "seek", "offs", "ref", "position", "et", "store", "slice", "off", "len", "coord", "base", "bf", "local", "index", "oid", "part", "addr", "block"], "count": ["ctx", "current", "latest", "check", "num", "try", "start", "nb", "depth", "cast", "conf", "type", "length", "cache", "n", "nc", "cc", "force", "amount", "counter", "b", "max", "limit", "c", "Count", "found", "no", "nt", "cmd", "sum", "size", "cond", "message", "child", "total", "desc", "buf", "comment", "len", "number", "now", "cur", "code", "ctr", "index", "batch", "part", "ount", "cont"], "co": ["ror", "fo", "PO", "gro", "mo", "oc", "ko", "ano", "o", "soc", "lo", "CO", "coll", "can", "xc", "ho", "flo", "cc", "cover", "com", "coe", "c", "oo", "fc", "aco", "redo", "po", "go", "Co", "cycle", "cho", "col", "pc", "con", "coord", "ro", "ico", "cu", "circ", "vo", "io", "bo"], "aio_context": ["aoop_iterator", "aio___ctx", "aoop_address", "aio___document", "aio_address", "aio___address", "aio___container", "aoop___address", "aio___iterator", "aoop___context", "aoop___document", "aoop___iterator", "aio___context", "aio_ctx", "aio_document", "aoop_document", "aio_iterator", "aoop_context", "aio_container"]}}
{"project": "qemu", "commit_id": "f9f46db444a2dfc2ebf1f9f7d4b42163ab33187d", "target": 0, "func": "void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n", "idx": 23758, "substitutes": {"env": ["ctx", "pkg", "dev", "rod", "vv", "vt", "viron", "forge", "inv", "ra", "ve", "ev", "end", "req", "esc", "ptr", "def", "vs", "den", "ah", "conn", "enter", "environment", "era", "expr", "attr", "er", "info", "vp", "serv", "cmd", "org", "ef", " ens", "En", "server", "net", "home", "db", "en", "msg", " environment", "txt", "EN", "cv", "desc", " en", "buf", "window", "nv", "obj", "estate", "e", "context", "usr", "ee", "hw", "err", "ov", "gear", "erd", "v"], "addr": ["pkg", "oc", "grad", "adr", "at", "aj", "attr", "address", "dr", "ar", "phys", "gz", "rank", "et", "ip", "ind", "adv", "arr", "hw", "ad", "ctx", "arp", "mt", "tag", "trans", " address", "inter", "rt", "iter", "pos", "map", "adj", "align", "hash", "usr", "urg", "ack", "rc", "add", "alt", "pad", "loc", "ag", "ptr", "url", "offset", "r", "ord", "act", "msg", "var", "obj", "row", "atom", "oad", "ix", "inv", "alias", "src", "expr", "tx", "cmd", "host", "db", "gate", "ref", "coord", "eth", "handle", "mem", "index", "rr"], "val": ["ctx", "dev", "Value", "vt", "aval", "data", "grad", "ival", "alpha", "loc", "util", "def", "value", "it", "test", "ret", "b", "vol", "lib", "fail", "final", "VAL", "tx", " v", "serv", " arg", " value", "func", "eval", "reg", "res", "Val", "msg", "pol", "ref", "vec", "var", "al", "resp", "buf", " aval", "bal", "len", "rol", "el", "hal", "arg", "mem", "arr", "cal", "urg", "vals", "elt", "err", "valid", "rel", "stat", " eval", "v"]}}
{"project": "FFmpeg", "commit_id": "5705dc527687fd84d94c934169b6bd753459744f", "target": 1, "func": "int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)\n\n{\n\n    int64_t scaled_dim;\n\n\n\n    if (!sar.den)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!sar.num || sar.num == sar.den)\n\n        return 0;\n\n\n\n    if (sar.num < sar.den)\n\n        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);\n\n    else\n\n        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);\n\n\n\n    if (scaled_dim > 0)\n\n        return 0;\n\n\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 23762, "substitutes": {"w": ["wh", "nw", "iw", "fw", "d", "wb", "tw", "n", "wa", "rw", "ww", "aw", "W", "l", "we", "wt", "wp", "r", "kw", "wd", "NW", "wr", "wi", "ew", "window", "a", "wal", "x", "wl", "hw", "wx", "v"], "h": ["ha", "high", "hi", "hr", "height", "m", "kh", "p", "z", "oh", "ih", "d", "ho", "n", "ah", "y", "ht", "hd", "b", "rh", "dh", "s", "sh", "he", "r", "bh", "H", "g", "hh", "hl", "hal", "ch", "x", "hw", "th", "ish", "v"], "sar": ["rsAR", "rsear", "scara", "servcar", "rsars", "ps\u00e9r", "servara", "sara", " scar", "scear", "Sara", "spar", "rsare", " sare", "sAR", "qs\u00e9r", "servear", "sarian", " sara", "isars", "rsara", " sart", " Spar", "qsaver", "isear", "sart", "psara", "desaver", "sqarian", "sccar", "tscar", "qsare", "psar", "isare", " SAR", " spar", "rspar", "scars", "qsar", "qspar", "tspar", "sarp", "pscar", "servpar", "s\u00e9r", "sqare", "rsrar", "Sar", "tsarp", " esAR", "srar", "desare", "Spar", "qsear", "psart", "scart", "tsar", "sare", " Sar", "rsar", "sqaver", "Sear", "pspar", "sqar", "saver", "desarian", " esrar", "isar", " s\u00e9r", "Scar", "psarp", "desar", "servar", "sars", " esar", "psear", " sear", " Srar", "qsarian", "scar", " sars", "sear", " espar"], "scaled_dim": ["scaled2num", "scaled_di", "scaled2Dim", "scaling_dim", "scale_num", "scale_dim", "scaling_Dim", "scale_dimension", "scaled_member", "scaled2dimension", "scaled5dimension", "scaled_Dim", "scaled2dir", "scaled_num", "scaled5dim", "scaled_axis", "scaled_scale", "scaled_dir", "scaling5scale", "scaled2member", "scale_dir", "scale2dim", "scaled_dimension", "scaling_dimension", "scale_member", "scale2num", "scaled2dim", "scaling_scale", "scaling5Dim", "scaled2di", "scaled5scale", "scale_di", "scale2dir", "scale_Dim", "scaling5dimension", "scaled_val", "scaling5dim", "scale2di", "scaled2scale", "scaled5Dim"]}}
{"project": "FFmpeg", "commit_id": "ba47d519e537299179d20b9a599c5824589a3f7a", "target": 1, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n    OPEN_READER(re, &s->gb);\n\n    count /= 2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n}\n", "idx": 23769, "substitutes": {"s": ["js", "gs", "m", "tes", "comments", "ls", "p", "sq", "es", "rs", "bs", "events", "details", "conf", "times", "sb", "ants", "vs", "parts", "n", "ps", "bis", "aunts", "fs", "ims", "ds", "status", "ains", "b", "ms", "c", "ess", "an", "cs", "r", "as", "sw", "ts", "ses", "serv", "ss", "stats", "erences", "t", "aws", "less", "g", "sample", "ns", "series", "re", "ins", "its", "changes", "hs", "sam", "sts", "sv", "qs", "sys", "h", "se", "ats", "S", "als", "is", "v", "comm"], "count": ["current", "gc", "check", "list", "num", "try", "nb", "body", "z", "type", "cast", "conf", "length", "scroll", "cache", "n", "cc", "force", "amount", "l", "counter", "result", "b", "max", "limit", "c", "Count", "found", "empty", "nt", "find", "sum", "t", "size", "cond", "match", "buffer", "total", "re", "read", "len", "number", "code", "now", "zero", "ind", "th", "ch", "ctr", "all", "h", "x", "index", "cf", "ount", "cont", "more", "ct"], "i": ["multi", "ori", "sql", "ei", "ims", "chain", "mi", "uni", "ski", "\u0438", "uri", "phi", "series", "ip", "ri", "client", "iq", "ini", "ind", "ii", "x", "pi", "docker", "ki", "im", " bi", "zi", "it", "qi", "iu", "iter", "di", "in", "print", " I", " j", "v", "m", "me", "this", "si", "xi", "init", "status", "ms", "PI", "point", "ni", "ai", "g", "ui", "page", "li", "batch", "MI", "ci", "ix", "p", "span", "n", "y", "ij", "ti", "token", "c", "j", "t", " ii", "gi", "ic", "cli", "sim", "ji", "bi", "e", "oi", "I", "ami", "ish"]}}
{"project": "qemu", "commit_id": "52c91dac6bd891656f297dab76da51fc8bc61309", "target": 1, "func": "static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n", "idx": 23771, "substitutes": {"mr": ["hr", "m", "kr", "mx", "adr", "rs", "mn", "RM", "pm", "km", "br", "cm", "mc", "Mr", "rn", "mi", "ms", "lr", "er", "bm", "r", "dr", "shr", "drm", "rar", "mor", "vr", "ns", "mb", "ml", "irm", "rpm", "sr", "MR", "rr", "rm", "nr", "wm", "mt"]}}
{"project": "qemu", "commit_id": "be18b2b53ebbf2eb3f00e7890d0b9ff8b58d22bf", "target": 1, "func": "int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, target_ulong eaddr,\n\n                                int rwx, int mmu_idx)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    CPUPPCState *env = &cpu->env;\n\n    ppc_slb_t *slb;\n\n    hwaddr pte_offset;\n\n    ppc_hash_pte64_t pte;\n\n    int pp_prot, amr_prot, prot;\n\n    uint64_t new_pte1;\n\n    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};\n\n    hwaddr raddr;\n\n\n\n    assert((rwx == 0) || (rwx == 1) || (rwx == 2));\n\n\n\n    /* 1. Handle real mode accesses */\n\n    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {\n\n        /* Translation is off */\n\n        /* In real mode the top 4 effective address bits are ignored */\n\n        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;\n\n        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,\n\n                     TARGET_PAGE_SIZE);\n\n        return 0;\n\n    }\n\n\n\n    /* 2. Translation is on, so look up the SLB */\n\n    slb = slb_lookup(cpu, eaddr);\n\n\n\n    if (!slb) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISEG;\n\n            env->error_code = 0;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSEG;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    /* 3. Check for segment level no-execute violation */\n\n    if ((rwx == 2) && (slb->vsid & SLB_VSID_N)) {\n\n        cs->exception_index = POWERPC_EXCP_ISI;\n\n        env->error_code = 0x10000000;\n\n        return 1;\n\n    }\n\n\n\n    /* 4. Locate the PTE in the hash table */\n\n    pte_offset = ppc_hash64_htab_lookup(cpu, slb, eaddr, &pte);\n\n    if (pte_offset == -1) {\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x40000000;\n\n        } else {\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (rwx == 1) {\n\n                env->spr[SPR_DSISR] = 0x42000000;\n\n            } else {\n\n                env->spr[SPR_DSISR] = 0x40000000;\n\n            }\n\n        }\n\n        return 1;\n\n    }\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n                \"found PTE at offset %08\" HWADDR_PRIx \"\\n\", pte_offset);\n\n\n\n    /* 5. Check access permissions */\n\n\n\n    pp_prot = ppc_hash64_pte_prot(cpu, slb, pte);\n\n    amr_prot = ppc_hash64_amr_prot(cpu, pte);\n\n    prot = pp_prot & amr_prot;\n\n\n\n    if ((need_prot[rwx] & ~prot) != 0) {\n\n        /* Access right violation */\n\n        qemu_log_mask(CPU_LOG_MMU, \"PTE access rejected\\n\");\n\n        if (rwx == 2) {\n\n            cs->exception_index = POWERPC_EXCP_ISI;\n\n            env->error_code = 0x08000000;\n\n        } else {\n\n            target_ulong dsisr = 0;\n\n\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            env->spr[SPR_DSISR] = dsisr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, slb->sps->page_shift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, TARGET_PAGE_SIZE);\n\n\n\n    return 0;\n\n}\n", "idx": 23779, "substitutes": {"cpu": ["ctx", "cp", "gc", "tp", "p", "np", "hz", "linux", "cn", "jp", "CPU", "arch", "mu", "conn", "nc", "sc", "cc", "aq", "uda", "vm", "ork", "proc", "c", "core", "gpu", "thread", "aco", "mac", "processor", "gnu", "nic", "cmd", "nu", "onet", "ec", "bench", "apache", "phys", "pc", "ck", "cli", "process", "cu", "context", "mem", "upt", "rpm", "sys", "kernel", "exec", "hw", "pai", "clock", "pu", "stat", "ctl", "ct"], "eaddr": ["eadDR", " adDR", "eddDR", " edrr", "eddhr", " adtr", "eader", "eadptr", "oadfr", "winddr", "windder", "embeddro", " edDR", "eadr", "eaddro", "eddptr", "eadder", "oadptr", " elDR", "eadfr", " adrr", "rawDR", "ellr", "oadhr", "egder", "oadstr", "winder", "eddstr", "oadder", "eddr", "eadhr", "egr", "edder", "oaddro", "oader", "eadrr", "embedder", " elrr", "edddr", "rawder", "ellfr", "ellhr", " edtr", "edDR", "oadr", "egdr", "egdro", " eltr", "oadDR", "oaddr", "eadtr", "rawstr", "eadstr", "windr", "edr", "eddfr", " eddr", "eddder", "rawdr", "embedr", " eldr", "elldr", "edptr", "embeddr", " addr"], "rwx": ["wxc", "wrz", "wrf", "norx", "norX", "wxy", "rufx", "winex", "rwld", "randx", "wxax", "rwax", "rollx", "wrax", "wrix", "norix", "rwxf", "winew", "wxX", "rwxp", "rwy", "fwv", "fwix", "wxix", "wxpx", "randpx", "winez", "rackx", "wxp", "wheX", "rwix", "wxfx", "owx", "rackz", "fwx", "wwld", "wrc", "rewf", "fwf", "rux", "fwX", "rwpx", "rewX", "rolly", "wheix", "RWz", "wxv", "rwc", "rwX", "ruv", "wrp", "rww", "wxz", "RWxt", "wwf", "RWx", "wrpx", "rollX", "kwix", "wrxt", "norxf", "wwix", "oww", "rwxt", "owp", "rwf", "wry", "rackax", "randz", "fwxp", "whexf", "wxw", "fwfx", "wrld", "rewix", "randix", "wxxt", "kwpx", "wxxp", "wxld", "wrx", "wwx", "wxx", "wrX", "RWw", "wxf", "rollxt", "rwv", "owc", "whex", "rewx", "rwp", "kwz", "kwx", "rwz", "rackpx", "winext", "wrw", "rewxf", "rwfx", "ruxp"], "mmu_idx": ["mmu_indX", "mmu_Idv", "mmu_indv", "mmu_Idz", "mmu_indz", "mmu_bidX", "mmu_midz", "mmu_Idx", "mmu_midX", "mmu_idX", "mmu_indx", "mmu_midv", "mmu_bidx", "mmu_idv", "mmu_midy", "mmu_Idy", "mmu_idy", "mmu_idz", "mmu_bidz", "mmu_IdX", "mmu_bidy", "mmu_midx"], "cs": ["ctx", "cp", "CS", "js", "ci", "ls", "ix", "conn", "rs", "bs", "cn", "yes", "cms", "ces", "vs", "tc", "sc", "ps", "icks", "cc", "css", "fs", "acs", "ds", "nc", "uns", "ics", "proc", "c", "s", "ts", "Cs", "cus", "ec", "ys", "cmd", "cas", "ce", "pc", "ns", "ck", "cks", "csv", "ks", "cons", "wcs", "hs", "checks", "sts", "qs", "sys", "cf", "caps", "cm", "cv"], "env": ["ctx", "dev", "der", "equ", "spec", "em", "export", "end", "viron", "inv", "v", "state", "ev", "entry", "eni", "here", "conf", "esm", "editor", "engine", "manager", "shell", "esc", "eng", "vs", "den", "conn", "ei", "ah", "ext", "environment", "vm", "era", "er", "proc", "doc", "worker", "scope", "tx", "eh", "config", "enc", "ec", "ef", "ens", "ce", "en", "ner", "et", "ew", "except", "subject", "eas", "buf", "window", "nv", "head", "next", "e", "ent", "desc", "event", "context", "agent", "policy", "eu", "err", "priv", "cap", "Environment", "term", "cv"], "slb": ["kelg", "mlbar", "kelbb", "slv", "islB", "slbd", "selmb", "islb", "sslp", " slg", "selbe", "slB", "islg", "SLbar", " slv", "kelb", "slmb", "ellbar", "islp", "mlb", " slbe", "Slbb", "Sla", "selb", "SLbb", " slbb", "splb", "sslv", "sslbar", " slbar", " slp", "Slb", "SLg", "mlbd", "slbb", "ellbe", "slg", "ellb", "Slp", " sla", "selB", "islbe", "kelbar", "islv", "sla", "ssla", "islmb", "splB", "sslb", "splbe", "sslg", " slbd", "ellbd", "slbe", "SLb", "splmb", "slp", "slbar", "mlbe", "sslbb"], "pte_offset": ["pte_origin", "pte_address", "ptee_offset", "pte_index", "pte_id", "ptee_Offset", "pte_Offset", "ptee_location", "ptee_index", "ptE_Offset", "ptE_offset", "pte_location", "ptee_address", "ptE_origin", "ptee_id"], "pte": ["epted", "ptb", "ptyel", "eptes", "ptes", "aptee", "cte", "ptel", "pted", "ptyb", "ptee", " ptel", "ptye", " ptb", "eptee", "apte", "ctb", "aptes", "ptyee", "epte", "ctel", "cted", " ptee", "ctee", "ctes", "apted"], "pp_prot": ["pp__prot", "op_type", "pp_tp", "op__tp", "op__pro", "op_tp", "pp__pro", "pp__type", "pp_pro", "op__type", "pp_type", "op__prot", "op_prot", "op_pro", "pp__tp"], "amr_prot": ["amp_phy", "amp_rot", "amr_pc", "amr_rot", "amp_pc", "amp_prot", "amr_phy"], "prot": ["crypt", "inet", "rot", "chron", "uf", "reset", "platform", "port", "ptr", "def", " protocols", "typ", "prop", "phy", " proto", "version", "tif", "pro", "col", "msg", "ocol", "pb", "prototype", "eth", "policy", "tf", "Prot"], "new_pte1": ["new_ptpe8", "new_minte1", "new_ptpe0", "new_minte64", "new_minte0", "new_mintxe1", "new_ptes64", "new_ptxe0", "new_ptxe64", "new_ptes8", "new_pte64", "new_ptpe1", "new_ptes1", "new_mintxe64", "new_ptpe64", "new_pte8", "new_ptxe8", "new_mintxe8", "new_ptes0", "new_minte8", "new_mintxe0", "new_pte0", "new_ptxe1"], "need_prot": ["pg_types", "pg_prot", "ppLtypes", "pp2stat", "pp2prot", "pp_stat", "pp2types", "pg_stat", "pp_types", "ppLstat", "pg_rot", "ppLrot", "ppLprot", "pp_rot", "pp2rot"], "raddr": ["rAddress", "Rptr", "Raddress", "hptr", "Raddr", "rroa", "waddr", "hhash", "woa", "rradd", "rptr", " raddress", " rhash", "radd", " radd", "haddress", " rptr", " roa", "haddr", "mptr", "RAddress", "raddress", "Rhash", "rraddr", "maddr", "maddress", " rAddress", "waddress", "wadd", "roa", "mAddress", "rraddress", "rhash"]}}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    uint8_t const *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin = AV_RL16(buf+ 4);\n\n    ymin = AV_RL16(buf+ 6);\n\n    xmax = AV_RL16(buf+ 8);\n\n    ymax = AV_RL16(buf+10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf+66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes<<8) + bits_per_pixel) {\n\n        case 0x0308:\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            break;\n\n        case 0x0108:\n\n        case 0x0104:\n\n        case 0x0102:\n\n        case 0x0101:\n\n        case 0x0401:\n\n        case 0x0301:\n\n        case 0x0201:\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                ptr[3*x  ] = scanline[x                    ];\n\n                ptr[3*x+1] = scanline[x+ bytes_per_line    ];\n\n                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        for (y=0; y<h; y++, ptr+=stride) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto end;\n\n        }\n\n\n\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n\n        GetBitContext s;\n\n\n\n        for (y=0; y<h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n\n\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n\n\n    } else {    /* planar, 4, 8 or 16 colors */\n\n        int i;\n\n\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                int m = 0x80 >> (x&7), v = 0;\n\n                for (i=nplanes - 1; i>=0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n\n    } else if (bits_per_pixel * nplanes == 1) {\n\n        AV_WN32A(p->data[1]  , 0xFF000000);\n\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart+16;\n\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n", "idx": 23786, "substitutes": {"avctx": ["airjp", "afctl", " avconn", "AVctl", "aftx", "vrctx", "awconn", " avcontext", "vrconf", "afcu", "afconn", "avconf", "averctx", "avercu", "afcpu", "averobj", "afconf", "averctl", "avcpu", "avobj", "AVpkg", "averconf", "avercpu", "wavctl", "afcontext", "avconn", "afpkg", "avecp", "awcontext", "AVcp", "avecontext", "vrcontext", "aircu", "avcu", "afcp", "awctx", "wavctx", "avertx", "airobj", "avetx", "avectx", "aveconf", "avpkg", "wavcpu", "avcp", "afctx", "avcontext", "afjp", "AVctx", "wavtx", "airctx", "vrtx", "avctl", "awtx", " avtx", " avconf", "avjp", "averjp", "avepkg", "afobj", "avtx", "AVcontext", "AVconf", "averpkg"], "data": ["action", "dat", "input", "file", "family", "bits", "name", "pad", "type", "image", "bin", "length", "d", "padding", "def", "to", "value", "bytes", "text", "info", "root", "raw", "empty", "video", "t", "map", "size", "area", "message", "frame", "pipe", "buffer", "first", "reader", "device", "read", "window", "next", "a", "obj", "DATA", "record", "package", "ata", "batch", "rel", "share", "block", "Data", "table"], "data_size": ["data__offset", " data_SIZE", "data__length", "data_length", "data__SIZE", "data_SIZE", "data_offset", " data_offset", " data_length", "data__size"], "avpkt": [" avcpck", "avpft", "avwpet", " avcpet", "avpct", "avpix", "abnpqt", "AVpft", "avpackkt", " avpck", "avwpkt", "avjpix", "AVpix", "avpet", " avcpkt", "avpvt", "avpackix", "avwpct", "avpackacket", "AVcpix", "abpct", "avnpct", "avjpacket", "avopacket", "avcpft", "AVcpft", "avopkt", "avPqt", "avnpkt", "AVcpkt", "avopet", "avwpvt", "avcpkt", "avcpacket", "avpck", "avPct", "avpacket", "abpvt", "abpkt", "avcpck", " avpet", "AVcpacket", " avpacket", "avnpvt", "avjpft", "avnpqt", "avcpet", "avwpacket", "avopck", "AVpkt", "avwpck", "avcpix", "avpackft", "avPvt", "AVpacket", "avjpkt", "avpqt", " avcpacket", "abnpvt", "abnpct", "avwpqt", "avPkt", "abpqt", "abnpkt"], "buf": ["pkg", "pack", "bs", "cast", "bag", "tmp", "prop", "front", "rb", "vec", "pb", "cur", "bu", "cam", "queue", "aka", "cb", "cv", "ctx", "cp", "uf", "list", "box", "xff", "cache", "b", "doc", "used", "buff", "iter", "uv", "img", "pos", "map", "bh", "Buff", "desc", "emb", "conv", "fb", "ff", "seq", "pad", "tr", "req", "port", "br", "orig", "init", "r", "raw", "deg", "fac", "bl", "msg", "txt", "var", "batch", "err", "alloc", "cap", "pool", "packed", "dat", "nm", "Buffer", "bytes", "result", "vp", "cmd", "func", "burst", "db", "buffer", "ref", "coord", "late", "mem", "pg"], "s": ["js", "gs", "ls", "sq", "es", "sp", "rs", "sb", "ps", "n", "fs", "acs", "ds", "ms", "b", "c", "cs", "as", "sw", "ts", "ss", "stats", "t", "ns", "socket", "a", "e", "sts", "sv", "sys", "ats", "os", "S", "space", "is"], "picture": ["panic", "profile", "family", "file", "image", "pict", "photo", "important", "camera", "screen", "audio", "png", "status", "style", "info", "feature", "conference", "query", "Picture", "img", "video", "frame", "pa", "pen", "summary", "friendly", "piece", "context", "pic", "media", "policy", "finals", "share", "stat", "icon"], "p": ["cp", "pkg", "m", "np", "pp", "o", "par", "jp", "d", "n", "ps", "P", "rep", "c", "r", "j", "t", "pc", "pa", "pb", "ap", "a", "pic", "op", "fp", "f"], "compressed": ["suppression", "Complied", "compapped", " compapped", "complied", "ompression", "Compression", "Compapped", "ompressed", "suppressed", "compress", "ompress", "omplied", " compression", "suppress", "compression", "supplied", "Compressed", "Compress", " compress", "ompapped"], "xmin": ["dxmin", "dxmax", "dxmins", "wmins", "exmin", "xxstat", "xymax", " xmins", "xstart", "xtmin", "xymin", "yfirst", "xfirst", " xfirst", "xxmin", "ixmin", "xtstart", "ymins", "oxfirst", "ixfirst", "oxmins", "xstat", "wfirst", "ixmax", "exfirst", "exstart", "xystart", "xtmax", "ixstat", "exmax", "wmax", "oxmin", "xxmins", "xtfirst", "xmins", "oxmax", "ixmins", "xxmax", "xyfirst", " xstat", "wmin", "dxfirst"], "ymin": ["mymax", "myminute", "cymax", " yMin", "ynmin", "Ymax", "yymax", "ystart", "Ymin", "cymin", "mystart", "mymin", "yymin", "Yminute", " ystart", "symin", " ydir", "yyminute", "yndir", "YMin", "ymins", "ynmax", "sydir", "cyMin", "mymins", "myMin", "ydir", "symax", "symins", "yminute", "yMin", " ymins", "xMin", "xmins", "yystart", " yminute", "cyminute", "ynmins"], "xmax": ["wMax", "xax", "xend", "wax", "xMax", "yMax", "xyend", "ixMAX", "Xmin", "ixlast", "exmin", "rxlast", " xMax", "xymax", "xymin", "zxmin", " xlast", "exend", "Xlast", "XMax", " xMAX", " xend", "exax", "rxmin", " xax", "yMAX", "ixmax", "zxmax", "xlast", "zxMax", "exmax", "yax", "Xmax", "wmax", "xyax", "rxMax", "zxlast", "rxmax", "rxMAX", "xMAX", "wMAX"], "ymax": ["nmas", "ymmari", "ypake", "ymake", "ypody", "nmax", "ymari", "yanast", "nyajor", "ypaze", "yrimax", "yanax", "ymast", "ymmast", "ymag", "iyake", "yrimas", "iyager", "ypax", "hmake", "ymaj", "ymager", "nyax", "nmari", "iyax", "ymmajor", "nyast", "ymmake", "hmaze", "ymmaj", "yanager", "ypag", "nmaj", "ymode", "ymody", "hmag", "ymmaze", "ymaze", "yrimaj", "ymmas", "yrimari", "ymmag", "yanajor", "ypager", "ymas", "yanode", "ymmax", "yanake", "iyody", "ymmode", "ymajor", "nyode", "yanody", "hmax"], "w": ["wn", "wh", "m", "nw", "height", "q", "z", "fw", "iw", "d", "wb", "tw", "n", "wa", "rw", "wid", "ww", "l", "W", "b", "wt", "wp", "c", "r", "kw", "wd", "sw", "wr", "size", "g", "wi", "ew", "window", "work", "cam", "row", "hw", "wx", "ex", "v"], "h": ["ha", "hi", "high", "m", "height", "hr", "wh", "kh", "q", "hz", "oh", "ih", "ho", "n", "ph", "hm", "l", "ht", "hd", "b", "max", "he", "html", "bh", "k", "H", "en", "hash", "hh", "hs", "hal", "ch", "f", "v"], "bits_per_pixel": ["bits_PER_byte", "bits_per_image", "bits_per__pixel", "bits_per_byte", "bits_PER_word", "bits_per2channel", "bits_PER_cell", "bits_PER_image", "bits_per2pixel", "bits_per2page", "bits_per_channel", "bits_PER_channel", "bits_per__image", "bits_per_page", "bits_PER_pixel", "bits_per_word", "bits_PER_color", "bits_per_color", "bits_per_cell", "bits_per__page", "bits_PER_page"], "bytes_per_line": ["bytes_for_pixel", "bytes_permissionLine", "bytes_PER_pixel", "bytes_PER_line", "bytes_PER_section", "bytes_PER_page", "bytes_for_Line", "bytes_per_block", "bytes_per_page", "bytes_per_pixel", "bytes_PER_Line", "bytes_for_line", "bytes_permissionpixel", "bytes_permissionline", "bytes_PER_block", "bytes_per_Line", "bytes_per_section", "bytes_permissionsection"], "nplanes": ["onblocks", "nanes", "nspages", "cnlines", "onframes", "cnpacks", "unblocks", "nlines", "nbpacks", "nnframes", "nnpacks", "cnpages", "numplanes", "unmaps", "nsplanes", "unpages", "cnblocks", " nframes", "cnframes", "nnplanes", "nnlines", "numpages", "nframes", "nbplanes", "manes", "mlines", "onplanes", "cnplanes", "npages", "nsblocks", "lframes", "nmaps", "lpages", "npacks", "unplanes", "cnanes", "cnmaps", " nlines", "numblocks", " npages", "nblocks", "lplanes", "nsframes", "mplanes", "unframes", "mpages", "onpages", "nbframes", "numframes", "nsmaps", "nblines", " nanes"], "stride": ["drage", "drope", "strides", "shrage", "shride", "drides", "shrides", "dride", "glides", "shrope", "glide", "strage", "strope", "glage", "glope"], "y": ["iy", "m", "height", "z", "ym", "n", "py", "vy", "b", "ny", "Y", "j", "t", "yy", "col", "key", "ey", "hy", "dy", "ch", "xy", "cy", "sy", "gy"], "x": ["xp", "m", "height", "ox", "rx", "ix", "z", "yx", "dx", "xc", "n", "xi", "l", "max", "X", "xy", "xs", "wx", "px", "ex", "f"], "bytes_per_scanline": ["bytes_per_readcell", "bytes_per_Scancell", "bytes_per_scanlines", "bytes_per_scancell", "bytes_per_Scanline", "bytes_per_ScanLine", "bytes_per_checkline", "bytes_per_readLine", "bytes_per_checkLine", "bytes_per_scanblock", "bytes_per_Scanlines", "bytes_per_checkblock", "bytes_per_Scanblock", "bytes_per_scanLine", "bytes_per_readline", "bytes_per_checklines"], "ptr": ["pointers", "cp", "ctx", "np", "pad", "tr", "progress", "tmp", "br", "src", "copy", "attr", "buff", "cmd", "dr", "pointer", "map", "buffer", "ref", "pen", "cur", "desc", "ctr", "addr", "alloc", "fp", "cmp", "cap", "rc"], "bufstart": ["bufferoffset", "bufstop", "bufferstart", "bufferstop", "blockoffset", "bufend", "blockend", "bufferend", "blockstop", "bufoffset", " bufstop", " bufoffset", "blockstart", " bufend"], "scanline": [" scanlines", "readLine", "rowLine", "scanlines", "rowlines", " scanLine", "scanLine", "readline", "rowline", "readlines"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809, "substitutes": {"list": ["spec", "p", "name", "ist", "L", "word", "def", "lists", "n", "pl", "l", "info", "s", "List", "single", "top", "listed", "flag", "LIST", "print", "flat", "map", "xml", "set", "from", "lt", "other", "out", "lat", "level", "all", "base", "local", "x", "st", "batch", "pair", "is", "v"], "qdict": ["queryword", "qqtable", "eqdb", "qpath", "sqmap", " qmap", "qlist", "quallist", "sqtree", "sqword", "qqdict", "qcompl", "qualmap", "qdb", "sqlist", "qqpath", "querypath", "eqtree", "qmap", "qualdict", "sqdata", "qqcompl", "eqcompl", " qdata", "qdata", "qqword", "sqtable", "qtable", "qword", " qlist", "eqdict", "qqtree", "querytable", "sqpath", "querydict", "sqdb", "qualdata", "sqdict", "qqdb", "sqcompl", "qtree"], "opts": [" opps", " oprs", "prcs", "optcs", "optgs", "iopte", "OPts", "OPuts", " opcs", "optps", "pts", "ps", "OPgs", " optte", "iopcs", "OPrs", "oppt", "opms", "prts", "prms", " optpt", " oppt", "optts", " opte", " ops", "pt", " optts", "ioppt", " opms", "OPs", "iopts", "opps", "opte", "OPps", "optrs", "iopms", "opgs", "ioputs", "oputs", "opcs", "iops", "oprs", "optuts", "pcs", " oputs", "iopgs", "ops", " opt", "prpt", "optt", "opt"]}}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n", "idx": 23816, "substitutes": {"ch": ["ctx", "cp", "wh", "kh", "chron", "chn", "och", "q", "kr", "zh", "vc", "z", "Ch", "ih", "arch", "qu", "range", "sc", "conn", "y", "cht", "cm", "ich", "ech", "cl", "ht", "sky", "mot", "com", "sh", "c", "cs", "ow", "sw", "j", "serv", "gh", "cmd", "i", "ct", "chrom", "ched", "k", "cho", "sch", "ck", "CH", "cur", "channel", "hl", "th", "ach", "cand", "form", "ctr", "h", "tch", "hw", "chy", "chan", "cont", "cb", "comm"], "current": ["ctx", "command", "this", "choice", "m", "p", "parent", "state", "aj", "selected", "range", "value", "on", "content", "primary", "self", "present", "currently", "we", "result", "history", "c", "root", "serv", "config", "cmd", "i", "Current", "active", "t", "remote", "set", "initial", "reported", "target", "cur", "client", "next", "now", "general", "ach", "context", "local", "h", "new", "ex", "cont", "v", "bo"], "br": ["hr", "bra", "bridge", "bro", "sp", "bs", "pr", "tr", "bc", "bo", "Br", "bp", "fr", "browser", "bus", "chain", "b", "prefix", "anch", "bm", "r", "serv", "BR", "j", "bt", "cmd", "dr", "brace", "bolt", "bh", "bl", "bg", "bal", "buf", "bol", "next", "ctr", "bf", "str", "ber", "jump", "batch", "rid", "bre", "bsp", "rel", "stat", "block", "bn"], "sel_mask": ["selMmap", "sel_key", "sell67set", "sel5lock", "seltmagic", "sell_mask", "sel67map", "seltmask", "el_lock", "el_map", "sl_ask", "sl_lock", "selMask", "sell67window", "sell_set", "el_ask", "el_mask", "el_mk", "sel___mask", "sel5value", "sel_ask", "sel_map", "sel67mask", "sel_magic", "sel___mk", "sell_map", "sl_mask", "sel5ask", "sel_window", "sell67mask", "el_key", "seltlock", "sel5mask", "seltkey", "el_magic", "sel___ask", "sel67window", "sel_mk", "sell67map", "selMmask", "sel___map", "selMmk", "sel_set", "sel67set", "sl_value", "sel_lock", "sell_window"], "sel_value": ["sell_value", "selvalvalue", "sel10value", "selvalresult", "el_val", "selvalval", "sel___value", "el_position", "sel_map", "el_result", "sel10map", "el_value", "sel_index", "sell_map", "sel_field", "sel___position", "sel_val", "selvalfield", "sel___index", "sell_widget", "el_index", "el_field", "sel10widget", "sell_val", "sel_position", "sel___val", "sel10val", "sel_widget", "sel_result"], "status": ["check", "spec", "chron", "ssl", "success", "sp", "atus", "state", "sel", "progress", "details", "flags", "sb", "priority", "sol", "syn", "sc", "Status", "currently", "result", "ser", "info", "score", "sw", "sym", "serv", "flag", "stats", "version", "active", "res", "uses", "msg", "summary", "vis", "resp", "comment", "compl", "STAT", "code", "sex", "index", "str", "st", "pres", "rel", "ex", "stat"], "cond": ["check", "respond", "state", "hold", "bc", "or", "bo", "conf", "mat", "req", "Condition", "def", "Cond", "red", "bind", "bit", "bound", "fun", "lock", "rupt", "cmd", " condition", "act", "func", "pos", "ond", " Cond", "pri", "resp", "con", "compl", "pred", "sec", "zero", "ind", "condition", "crit", "comp", "bool", "pres", "stick", "cmp", "ex", "wx", "cont", "cod", "ct"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n\n                               Jpeg2000Component *comp,\n\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n\n{\n\n    int i, j;\n\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n\n        int *src = t1->data[j];\n\n        if (band->i_stepsize == 16384) {\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = src[i] / 2;\n\n        } else {\n\n            // This should be VERY uncommon\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;\n\n        }\n\n    }\n\n}\n", "idx": 23854, "substitutes": {"x": ["m", "height", "ox", "rx", "ix", "q", "p", "z", "at", "xx", "dx", "w", "on", "xi", "l", "ij", "c", "xt", "r", "tx", "in", "step", "t", "g", " xx", "X", "e", "xy", "xs", "index", "h", "px", "ex", "v"], "y": ["iy", "ery", "m", "height", "oy", "my", "p", "z", "ym", "py", "vy", "ye", "sky", "b", "ny", "ry", "Y", "asy", "yt", "ys", "t", "yy", "uy", "axy", "iny", "ies", "ey", "hy", "dy", "ch", "xy", "h", "cy", "yi", "wy", "sy", "v", "gy"], "cblk": ["cplank", "acBLck", "cbcunk", "rplck", "CBLk", "ctblak", "CBLkin", "rplak", "cdlck", "Cblkin", "ctblck", "cblck", "ctbleke", "cBLak", "rblak", "cBlk", "cBLk", "cbrk", "rblank", "cbrck", " cplunk", "cBLck", "cplk", "rplk", "acBLk", "cbrak", "ctbleck", "cbleke", " cblunk", "acblck", "cbleak", "ctblk", "ctblke", "cbrke", "cblek", " cplak", "cbcck", "cplunk", "CBLck", " cplck", "rplank", "cablkin", "cBlak", "cdlak", "cablk", "cblunk", " cblck", "cplck", "cbck", " cblak", "cBLkin", "cbleck", "ctbleak", "acblk", "cBlck", "cblak", "cblkin", "acblak", "acBLak", "CBLak", "Cblck", "cdlank", "rblck", "cblke", "cdlk", "rblk", "cablak", "Cblk", "cplak", "Cblak", "cblank", "cbcak", " cplk", "ctblek", "cablck"], "comp": ["ctx", "cp", "ac", "p", "pp", "par", "prep", "mod", "conf", "sc", "prop", "cc", "component", "co", "mp", "etc", "com", "rep", "proc", "c", "lib", "lc", "buff", "app", "cmd", "stack", "prof", "cond", "pro", "col", "sim", "con", "coord", "compl", "sec", "ch", "conv", "omp", "crit", "op", "Comp", "cmp", "cont", "cell", "rc", "comm"], "t1": ["T3", "tt3", "t6", " t6", "p0", "tt2", "p1", "T2", "T1", "p3", "T0", "t3", "T6", "t2", "p2", "tt1", " t3", "tt6", " t2", "t0", " t0"], "band": ["bands", "product", "stage", "bridge", "bank", "bar", " Band", "power", "brand", "bin", "word", "library", "unk", "plot", "beam", "dom", "field", "range", "plugin", "bright", "bit", "bound", "b", "light", "plug", "Band", "grain", "road", "net", "burst", "disk", "channel", "group", "rad", "piece", "cand", "nob", "amber", "display", "binary", "filter", "part", "bd", "bart", "back", "block", "ack", "rend"], "i": ["m", "me", "try", "ci", "ix", "p", "id", "si", "zi", "multi", "w", "um", "ei", "it", "xi", "l", "ij", "init", "status", "ims", "chain", "mi", "b", "er", "qi", "c", "iu", "ti", "info", "iter", "di", "in", "dr", "\u0438", "ai", "print", "im", "ie", "ki", "remote", "uri", "u", "gi", "ui", "phi", "li", "ic", "wi", "ip", "cli", "ri", "sim", "ini", "bi", "ind", "oi", "ii", "pi", "batch", "I", "ia", "ami", "ik", "io", "is", "v"], "j": ["jj", "js", "m", "json", "try", "ix", "q", "p", "o", "z", "ja", "uj", "ax", "aj", "pr", "jp", "n", "fr", "it", "dj", "l", "ij", "b", "jc", "c", "jo", "jl", "t", "ie", "k", "g", "bj", "u", "jac", "msg", "J", "sim", "job", "ji", "el", "obj", "ind", "ch", "jit", "jump", "h", "index", "kj", "v", "bo"], "datap": ["dateap", "dataapa", " datapa", "datapa", "metap", "metaps", "octAP", "dataps", "metab", "octmap", "Dataps", "dataab", "dateapa", "datAP", "dateaps", "dataAP", "datab", "Datmap", "datamap", "octap", "Datap", "dataaps", " datab", " dataps", "octaps", "DatAP", "dataap", "datmap"], "src": ["rest", "sn", "sl", "inst", "sq", "data", "rs", "impl", "cont", "secure", "req", "loc", "image", "supp", "tmp", "sb", "url", "sc", "iv", "split", "dest", "ser", "s", "sync", "fc", "r", "lib", "scan", "stack", "img", "sub", "txt", "stream", "slice", "sec", "usc", "ind", "source", "sr", "sys", "rl", "str", "view", "usr", "sur", "st", "rc"]}}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n", "idx": 23855, "substitutes": {"s": ["js", "gs", "m", "spec", "sl", "ls", "sq", "p", "sp", "es", "rs", "bs", "state", "d", "sb", "vs", "gets", "n", "ps", "bis", "fs", "ds", "sa", "ms", "c", "cs", "an", "ses", "ts", "ss", "i", "stats", "t", "ans", "less", "set", "g", "ns", "ins", "its", "hs", "sam", "e", "sts", "sv", "qs", "h", "ats", "se", "os", "S", "als", "st", "is", "comm"], "sockaddr": ["ysockedlen", " sipaddress", " sockorder", "sockhash", "sockaddress", "sinkptr", "socksaddress", "psockaddr", " sipaddr", "scklen", "psckadd", "psockptr", " siphash", "sockorder", "sixaddr", "sockshash", "sckadd", "psockadd", "ysocklen", "ysockedname", "ysockaddr", "sixname", "ysockedptr", "sockedaddr", "sipaddress", "sockadd", "sckptr", "sinkhash", "sockedname", "sockedlen", "ysockname", "siphash", "socksorder", "sOCKptr", "sinklen", "socksaddr", "sinkorder", "sixlen", "ysockptr", "sinkaddress", " sockhash", "sixptr", "sockname", "sipaddr", "ysockedaddr", "siporder", "sckaddr", " siporder", "sockptr", "sixadd", "psckptr", "psocklen", "sockedptr", "socklen", "sOCKaddr", "sOCKadd", "sockedadd", "pscklen", "psckaddr", "sinkname", "sinkaddr", " sockaddress"], "len": ["lf", "ls", "seq", "L", "fl", "length", "loc", "ln", "ld", "n", "bytes", "wid", "lon", "l", "Len", "fin", "lic", "ds", "vol", "doc", "nl", "lib", "fn", "lan", "enc", "pos", "size", "en", "li", "lt", "ref", "vec", "il", "buf", "compl", "el", "ll", "mem", "h", "lp", "err", "elt", "mil", "coll", "kl", "val"], "fd": ["lf", "dir", " f", " fid", "ln", "ld", "fs", "fn", "dl", "nd", "dc", "dd", "ud", "buf", "ind", "tty", "f", "cb", "ctx", "pid", " fin", " fa", "fl", "d", "pd", "den", "dt", "ds", "l", "hd", "fun", "tif", "pos", " td", " d", "stream", "fb", " df", "dig", "fm", " ff", " dur", "ff", "td", "port", "ptr", "fr", "dra", "fi", "dy", "window", "fee", "fp", "elt", "fed", "df", "dat", "ffff", "gd", "fe", "fa", "fin", "fc", "du", "db", "buffer", "cd", "FD", "handle", "cf", "sd"]}}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static int vaapi_encode_h265_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferHEVC  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferHEVC   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH265Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH265MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        // general_profile_space == 0.\n\n        vseq->general_profile_idc = 1; // Main profile (ctx->codec_profile?)\n\n        vseq->general_tier_flag = 0;\n\n\n\n        vseq->general_level_idc = avctx->level * 3;\n\n\n\n        vseq->intra_period = 0;\n\n        vseq->intra_idr_period = 0;\n\n        vseq->ip_period = 0;\n\n\n\n        vseq->pic_width_in_luma_samples  = ctx->aligned_width;\n\n        vseq->pic_height_in_luma_samples = ctx->aligned_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1; // 4:2:0.\n\n        vseq->seq_fields.bits.separate_colour_plane_flag = 0;\n\n        vseq->seq_fields.bits.bit_depth_luma_minus8 = 0; // 8-bit luma.\n\n        vseq->seq_fields.bits.bit_depth_chroma_minus8 = 0; // 8-bit chroma.\n\n        // Other misc flags all zero.\n\n\n\n        // These have to come from the capabilities of the encoder.  We have\n\n        // no way to query it, so just hardcode ones which worked for me...\n\n        // CTB size from 8x8 to 32x32.\n\n        vseq->log2_min_luma_coding_block_size_minus3 = 0;\n\n        vseq->log2_diff_max_min_luma_coding_block_size = 2;\n\n        // Transform size from 4x4 to 32x32.\n\n        vseq->log2_min_transform_block_size_minus2 = 0;\n\n        vseq->log2_diff_max_min_transform_block_size = 3;\n\n        // Full transform hierarchy allowed (2-5).\n\n        vseq->max_transform_hierarchy_depth_inter = 3;\n\n        vseq->max_transform_hierarchy_depth_intra = 3;\n\n\n\n        vseq->vui_parameters_present_flag = 0;\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->vui_num_units_in_tick = avctx->framerate.num;\n\n            vseq->vui_time_scale        = avctx->framerate.den;\n\n        } else {\n\n            vseq->vui_num_units_in_tick = avctx->time_base.num;\n\n            vseq->vui_time_scale        = avctx->time_base.den;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->decoded_curr_pic.picture_id = VA_INVALID_ID;\n\n        vpic->decoded_curr_pic.flags      = VA_PICTURE_HEVC_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->reference_frames); i++) {\n\n            vpic->reference_frames[i].picture_id = VA_INVALID_ID;\n\n            vpic->reference_frames[i].flags      = VA_PICTURE_HEVC_INVALID;\n\n        }\n\n\n\n        vpic->collocated_ref_pic_index = 0xff;\n\n\n\n        vpic->last_picture = 0;\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n\n\n        vpic->diff_cu_qp_delta_depth = 0;\n\n        vpic->pps_cb_qp_offset = 0;\n\n        vpic->pps_cr_qp_offset = 0;\n\n\n\n        // tiles_enabled_flag == 0, so ignore num_tile_(rows|columns)_minus1.\n\n\n\n        vpic->log2_parallel_merge_level_minus2 = 0;\n\n\n\n        // No limit on size.\n\n        vpic->ctu_max_bitsize_allowed = 0;\n\n\n\n        vpic->num_ref_idx_l0_default_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_default_active_minus1 = 0;\n\n\n\n        vpic->slice_pic_parameter_set_id = 0;\n\n\n\n        vpic->pic_fields.bits.screen_content_flag = 0;\n\n        vpic->pic_fields.bits.enable_gpu_weighted_prediction = 0;\n\n\n\n        // Per-CU QP changes are required for non-constant-QP modes.\n\n        vpic->pic_fields.bits.cu_qp_delta_enabled_flag =\n\n            ctx->va_rc_mode != VA_RC_CQP;\n\n    }\n\n\n\n    {\n\n        mseq->video_parameter_set_id = 5;\n\n        mseq->seq_parameter_set_id = 5;\n\n\n\n        mseq->vps_max_layers_minus1 = 0;\n\n        mseq->vps_max_sub_layers_minus1 = 0;\n\n        mseq->vps_temporal_id_nesting_flag = 1;\n\n        mseq->sps_max_sub_layers_minus1 = 0;\n\n        mseq->sps_temporal_id_nesting_flag = 1;\n\n\n\n        for (i = 0; i < 32; i++) {\n\n            mseq->general_profile_compatibility_flag[i] =\n\n                (i == vseq->general_profile_idc);\n\n        }\n\n\n\n        mseq->general_progressive_source_flag    = 1;\n\n        mseq->general_interlaced_source_flag     = 0;\n\n        mseq->general_non_packed_constraint_flag = 0;\n\n        mseq->general_frame_only_constraint_flag = 1;\n\n        mseq->general_inbld_flag = 0;\n\n\n\n        mseq->log2_max_pic_order_cnt_lsb_minus4 = 8;\n\n        mseq->vps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->vps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->vps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->vps_max_latency_increase_plus1[0]   = 0;\n\n        mseq->sps_sub_layer_ordering_info_present_flag = 0;\n\n        mseq->sps_max_dec_pic_buffering_minus1[0] = 1;\n\n        mseq->sps_max_num_reorder_pics[0]         = ctx->b_per_p;\n\n        mseq->sps_max_latency_increase_plus1[0]   = 0;\n\n\n\n        mseq->vps_timing_info_present_flag = 1;\n\n        mseq->vps_num_units_in_tick = avctx->time_base.num;\n\n        mseq->vps_time_scale        = avctx->time_base.den;\n\n        mseq->vps_poc_proportional_to_timing_flag = 1;\n\n        mseq->vps_num_ticks_poc_diff_minus1 = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            mseq->conformance_window_flag = 1;\n\n            mseq->conf_win_left_offset   = 0;\n\n            mseq->conf_win_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            mseq->conf_win_top_offset    = 0;\n\n            mseq->conf_win_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            mseq->conformance_window_flag = 0;\n\n        }\n\n\n\n        mseq->num_short_term_ref_pic_sets = 0;\n\n        // STRPSs should ideally be here rather than repeated in each slice.\n\n\n\n        mseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            mseq->aspect_ratio_info_present_flag = 1;\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                mseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                mseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                mseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                mseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (1) {\n\n            // Should this be conditional on some of these being set?\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format = 5; // Unspecified.\n\n            mseq->video_full_range_flag = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            mseq->colour_primaries = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coeffs = avctx->colorspace;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 23870, "substitutes": {"avctx": ["navcu", "Avcontext", "varhandle", "varcmd", "vhandle", "navcontext", "varctx", "devhw", "navjp", "vrctx", "Avfunc", " avcontext", "vrhw", "vcontext", " avfunc", "avhw", "avcmp", "averctx", "navcam", "avercu", "Avctx", "varcontext", "vcmp", "AVcp", "vartx", "AVtx", "Avtx", "avecam", "navfunc", "avcu", "navctx", "devcmd", "AVcmp", "AVhandle", "avfunc", "ravcp", "vctx", "avercam", "avectx", " avcp", "ravcontext", "avcp", " avcmp", "avcontext", "avcam", "ravtx", "AVctx", "vrtx", "navtx", "ravctx", "avecu", "devtx", " avtx", "averjp", "avjp", "avcmd", "vtx", "varhw", "devctx", "avhandle", "vrcmd", "avtx", "avejp", "AVcontext"], "ctx": ["cp", "cfg", "pkg", "xp", "perm", "grad", "np", "mk", "conf", "bc", "loc", "req", "jp", "ppo", "ctrl", "tmp", "xc", "tc", "that", "parents", "iat", "conn", "nc", "mc", "cc", "co", "scl", "etc", "prefix", "rt", "wp", "aux", "kw", "tx", "config", "aco", "ctl", "cmd", "org", "act", "comm", "func", "working", "phys", "kb", "jac", "dc", "txt", "ck", "pb", "offic", "setup", "resp", "obj", "abc", "cu", "context", "conv", "rpm", "xs", "cf", "addr", "hw", "wx", "cmp", "px", "cb", "cv", "ct"], "vseq": ["vvsequ", "wstruct", "vardesc", "vexpr", " vsequ", "invzip", "vareval", " vserv", "vvpkg", "varzip", "invsequence", "vfle", "vmjob", "invsequ", "vmstr", "vervec", " vfle", "gstruct", " vsim", "vysequ", " vcomp", "varjob", "vcomp", "svpkg", " vtest", " vzip", "convserv", "vertest", "vezip", "invvec", "vpkg", "yzip", "svzip", "invstruct", "varprot", "gstr", "convzip", "varbuf", "vserv", "nvsequ", " vsequence", "invsim", "verseq", "gzip", "svsequ", "vmsg", "veval", "svvec", "Vclip", "vyclip", "vstr", "avsequence", "gsequence", "evzip", "ysequence", "vsequ", "vesim", "vmdesc", "avseq", "verpkg", "convseq", "evseq", " vjob", "wseq", "nvprot", "varseq", "vjob", "vref", "varsyn", "vdesc", "gsequ", " vstruct", " vprot", "veref", "invseq", "vyseq", "varsim", "versim", "vevec", "varfle", "convpkg", " vmsg", "evsequ", " vstr", "vesequ", "gexpr", "svref", "invbuf", "conveval", "Vsequence", "nvsyn", "Veval", " veval", "convsequ", "veseq", "vvvec", "geval", "vzip", "Vsequ", "gseq", "vstruct", " vbuf", "nvseq", "Vcomp", "vmzip", "invserv", "Vmsg", "evstruct", "gvec", "invfle", " vexpr", "vvstruct", "vprot", "wsequence", "ysequ", "convsequence", " vsyn", "verzip", "svseq", "yseq", " vdesc", " vpkg", "vbuf", "avsequ", " vref", "invtest", "Vseq", "vsim", "convtest", "gdesc", "vmmsg", "avzip", "nvstruct", "avref", " vclip", "vmsequence", "vycomp", "avsim", "vsequence", "vvec", "wsequ", "vvsequence", "Vzip", " vvec", "evdesc", "vmsequ", "varref", "varsequ", "Vexpr", "vmexpr", "vsyn", "vvseq", "vmseq", "vvzip", "convexpr", "nvzip", "vclip", "veeval", "vtest"], "vpic": ["vzip", "uvctx", "vctx", "uvpic", " vctx", "avpic", "uvzip", " vpse", "avpse", "uvpse", "vpse", "avzip", " vzip"], "priv": ["cfg", "dev", "cp", "pkg", "pub", "sp", "soc", "pr", "conf", "loc", "Pri", "gov", "conn", "prop", "proc", "Priv", "tx", "serv", "prof", "phys", "pro", "env", "stat", "riv", "rev", "pb", "pri", "eas", "cam", "sec", "mem", "pi", "private", "alloc", "pres", "cmp", "caps", "cap", "rc"], "mseq": [" msequ", "gseq", "gvec", "mvec", "gsequence", " vsequ", " msequence", " vsequence", " vvec", "gsequ", "msequ", " mvec", "msequence"], "i": ["m", "p", "v", "o", "z", "id", " bi", "n", "y", "it", "l", "ij", "b", "c", "r", "j", "in", "t", " ii", "li", "a", "e", "ii", "x", "I", "ia", "io", "im"]}}
{"project": "FFmpeg", "commit_id": "0780ad9c688cc8272daa7780d3f112a9f55208ca", "target": 0, "func": "static void rdft_calc_c(RDFTContext *s, FFTSample *data)\n\n{\n\n    int i, i1, i2;\n\n    FFTComplex ev, od;\n\n    const int n = 1 << s->nbits;\n\n    const float k1 = 0.5;\n\n    const float k2 = 0.5 - s->inverse;\n\n    const FFTSample *tcos = s->tcos;\n\n    const FFTSample *tsin = s->tsin;\n\n\n\n    if (!s->inverse) {\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n    /* i=0 is a special case because of packing, the DC term is real, so we\n\n       are going to throw the N/2 term (also real) in with it. */\n\n    ev.re = data[0];\n\n    data[0] = ev.re+data[1];\n\n    data[1] = ev.re-data[1];\n\n    for (i = 1; i < (n>>2); i++) {\n\n        i1 = 2*i;\n\n        i2 = n-i1;\n\n        /* Separate even and odd FFTs */\n\n        ev.re =  k1*(data[i1  ]+data[i2  ]);\n\n        od.im = -k2*(data[i1  ]-data[i2  ]);\n\n        ev.im =  k1*(data[i1+1]-data[i2+1]);\n\n        od.re =  k2*(data[i1+1]+data[i2+1]);\n\n        /* Apply twiddle factors to the odd FFT and add to the even FFT */\n\n        data[i1  ] =  ev.re + od.re*tcos[i] - od.im*tsin[i];\n\n        data[i1+1] =  ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n        data[i2  ] =  ev.re - od.re*tcos[i] + od.im*tsin[i];\n\n        data[i2+1] = -ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n    }\n\n    data[2*i+1]=s->sign_convention*data[2*i+1];\n\n    if (s->inverse) {\n\n        data[0] *= k1;\n\n        data[1] *= k1;\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n}\n", "idx": 23872, "substitutes": {"s": ["so", "sp", "rs", "bs", "params", "conf", "ants", "fs", "ims", "settings", "cs", "stats", "ar", "set", "ins", "its", "a", "os", "st", "f", "ls", "es", "ps", "ds", "l", "b", "ts", "args", "less", "conv", "se", "is", "js", "gs", "sets", "state", "parts", "ains", "r", "ses", "app", "ss", "aws", "g", "hs", "sts", "sys", "ats", "styles", "comm", "spec", "p", "sq", "w", "sb", "n", "y", "c", "sh", "as", "sw", "t", "ns", "sim", "e", "sv", "qs", "h", "sg", "S", "als", "ops"], "data": ["family", "full", "file", "params", "name", "bin", "rew", "test", "aw", "good", "chain", "info", "settings", "join", "nt", "images", "errors", "video", "step", "extra", "format", "button", "set", "output", "series", "actions", "a", "DATA", "x", "filter", "ad", "array", "block", "f", "Data", "table", "use", "help", "trace", "clear", "list", "o", "times", "d", "range", "cache", "it", "content", "component", "ds", "att", "users", "date", "args", "map", "error", "message", "first", "position", "members", "device", "val", "hash", "group", "apps", "xy", "save", "v", "dev", "m", "this", "done", "num", "add", "image", "des", "to", "blocks", "text", "history", "raw", "empty", "keys", "version", "results", "res", "ma", "al", "window", "next", "route", "time", "form", "str", "valid", "rel", "bus", "ta", "dat", "p", "input", "entry", "mat", "w", "def", "value", "n", "bytes", "result", "values", "no", "query", "da", "t", "size", "update", "ns", "off", "number", "code", "e", "zero", "all", "rec", "ata", "new", "vals", "final"], "i": ["hi", "m", "me", " ti", "ci", "p", "ix", "id", " bi", "si", "zi", "multi", "n", "bis", "y", "it", "ei", "xi", "ims", "ij", "status", "ti", "mi", "qi", "chain", "iu", "j", "iter", "di", "go", "\u0438", "ni", "ai", "im", "ki", " ii", "g", "ui", "phi", "ic", "li", "gi", "u", " j", "ip", "sim", "cli", "ri", "ji", "ini", "bi", "ind", "source", "oi", "index", "ii", "x", "pi", "iri", "batch", "I", "ami", "ite", "vi", "io", "is", "v"], "i1": ["di1", "li0", "i15", " i3", "ii01", "uione", "ipOne", "pione", "ip1", "ipone", "riOne", "lione", "i3", "key01", "itone", "pi3", "iione", "rione", "I3", " i0", "ione", "li3", " i01", "ui30", "liOne", "li1", "mi81", "i30", "pi0", "mi0", "it1", "ic1", "ic30", "li2", "di001", "ri2", "iri001", "i0", "piOne", "pi1", "key81", " ione", "i001", "I1", "pi2", "ip01", "iOne", "iri81", " i81", "ui1", " iOne", "mi1", "it30", "ri1", "key1", "I01", "ui15", "I2", "ic15", "key001", "i81", "ii1", "iri01", "di81", "mione", "li81", "it15", "di01", "iiOne", "ri0", "i01", "icone", "pi01", "ri01", "iri1"], "i2": ["is14", "vi012", "ri102", "ilet", "xi02", "u2", "ipTwo", "iriTwo", "mi14", "iri2", "uitwo", "is012", "ip42", "milo", "pi02", " i20", "bi14", "ritwo", "mi2", "ziTwo", " itwo", "ri42", "i02", "rito", "i102", "zi102", "i14", "li02", "islet", "li5", "zi14", "ui2", "mi02", "bilet", "iB", "li2", "isto", "iri42", "ri2", "xi42", "u14", "pi20", "pi1", "ui42", "vi42", "zi42", "pi2", "vito", "zitwo", "i20", "u1", "vi2", "mi42", "zi2", "bi2", "i012", "iTwo", "xilo", "itwo", "ie20", "xi2", "lilo", "uiTwo", "mi1", "i42", "ui102", "ri012", "uiB", "li42", " i5", " i02", "ilo", "ie2", "litwo", " i14", "isTwo", "ie1", "biTwo", "iriB", "ito", "zilet", "xitwo", "ie02", "i5", "xi5", "ipB", "is42", "is2", "ip2"], "ev": ["eff", "tv", "vc", "ve", "ver", "eng", " rev", " vel", "ok", "enc", " ov", " av", " estim", "rev", " vol", "eve", "cod", "ep", " env", " Ev", " eg", "ell", "vs", "iv", "vol", "Ev", "ec", "uv", "env", "ed", "ew", "adj", "eas", "nov", "ent", "erg", "ov", "ele", "v", "EV", "dev", "eb", "vd", "req", "av", "rem", "er", "erv", "lv", "eval", "ek", "el", " sv", "ee", " eve", "err", "vo", " ve", " ke", "ogg", " devs", "eg", " vec", "Dev", "ob", " v", "ef", "vision", "vr", " dev", "nv", "event", "e", "rav", "eur", "sv", "rec", " tv", " EV"], "od": ["rod", "az", "dev", "ick", "ast", "ox", "oad", "edd", "oy", "ard", "and", "o", "mod", "td", "vd", "or", "odd", "ot", "oh", "d", "ell", "ld", "ods", "cod", "co", "ost", "hd", "good", "ob", "odi", "lad", "ok", "ow", "ord", "yt", "node", "ded", "yd", "ond", "odic", "ed", "nd", "cd", "dd", "ud", "ood", "pod", "amd", "md", "off", "obj", "ent", "OD", "oly", "rec", "idd", "ad", "ov", "ode", "sd"], "tcos": ["nmas", "dtrices", "maccus", " tcin", " trices", "tdos", "ncus", "tcons", "tycons", "dtcus", "pcos", "mmas", "ndos", "tcas", "trices", "rcin", "Tcin", "rkos", "tkos", "Tcos", "dtcos", " tcons", "Tkos", "tcin", "tscos", "maccos", "tycin", "mcus", "tscas", "tycos", "pcin", "tscin", "tsrices", "dtcoins", "mdos", "prices", " tdos", "tscons", " tcus", "rrices", "mcos", "mackos", " tcas", "rcoins", "macrices", "tmas", "rcus", "tcus", "ncos", " tcoins", "tscus", "tcoins", "pcus", "Tcus", "maccin", "rcos", "maccons", "tycas", " tmas"], "tsin": ["thsoin", "timesin", "fsine", "stsine", "ttinn", "thsin", "tsinc", "tsis", "tersar", "timesout", "fsins", "atsins", "tesis", "watersins", "etsine", "watersin", "timesoin", "tsins", "tesoin", "atsinc", "omscin", "fsoin", "etsin", "thsar", "thsn", "stsins", "typesoin", "tersine", "thsins", "tisinn", "atsinn", "tsout", "omsinc", "ttin", "thsinc", "tsn", "stsin", "csin", "tesout", "atsin", "omsin", "thsinn", "fsin", "typesin", "thsine", "tscin", "tsinn", "omsine", "watersoin", "tisin", "tesin", "watersine", "tersinn", "tisins", "csins", "timesis", "etsar", "tsoin", "csn", "tsar", "etsinn", "atscin", "typesout", "typesis", "atsine", "tisinc", "stsn", "ttinc", "tsine", "stsoin", "csoin", "ttins", "thscin", "tersin"]}}
{"project": "FFmpeg", "commit_id": "aca490777f9da2a71b537874ed4e16105bb3df02", "target": 0, "func": "static av_cold int g726_init(AVCodecContext * avctx)\n\n{\n\n    AVG726Context* c = (AVG726Context*)avctx->priv_data;\n\n    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;\n\n\n\n    if (\n\n        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&\n\n         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n    if(index>3){\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of bits %d\\n\", index+2);\n\n        return -1;\n\n    }\n\n    g726_reset(&c->c, index);\n\n    c->code_size = c->c.tbls->bits;\n\n    c->bit_buffer = 0;\n\n    c->bits_left = 0;\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23877, "substitutes": {"avctx": ["avsys", "ajca", "avekl", "avercp", " avconn", "aftx", "abctx", "avcmp", "camctx", "avanctx", "avanreq", "afpkg", "avhistory", " weavectx", "avekt", "wavcmp", "aitctx", "avpx", "avmk", "avetx", "avectx", "avcontext", "awcfg", "aftxt", "avetxt", "ivertx", "iverctx", "avecmd", " avtx", " weavemk", "iverdyl", "avtx", "ajdyl", "afrh", "wavhistory", "averpkg", " avkl", "ajkw", "avanpx", " avreq", "avrh", "ajjac", "verctx", "abkl", "wavcfg", "aversys", "iverrh", "avercmp", " avpx", "avdj", "avecp", "awdyl", "avca", "avehistory", "avercmd", "iverdj", "ajctx", "ajdj", " avsys", "ajkl", "avcp", "afctx", " avcmp", "iverkt", "avjac", "afaddr", "ivercmd", "avkw", "avepkg", "avjp", "ajjp", " avpkg", "averkt", "wavjac", "averkl", "ajcfg", "averhistory", "avesys", " avcontext", "ajpx", "ivercontext", "averctx", "avercu", " avkt", "abtx", "avkt", "afcontext", "avconn", "aitcontext", " avaddr", "avertx", "awctx", "afkl", "avcfg", "awjac", "iverkw", "averconn", "avdyl", "avreq", "afhistory", "ajmk", "avaddr", "ivermk", "avecu", "avercfg", "verrh", " weavecmd", "wavjp", "avejp", "camcontext", "averca", "aitcp", "aveca", "camcmp", "ajreq", "ajkt", "avkl", "ajcmd", "afconn", "avercontext", "camcp", "averaddr", " avtxt", "avantx", "vercontext", "averkw", " avcmd", "avecontext", " avcu", "avcu", "afcp", "vertx", "wavctx", "aitcmp", "avecmp", "iverjac", "ajtx", "avpkg", " avcp", "ivercfg", " avca", "abpkg", "avejac", "wavtx", "wavpkg", "avecfg", "afca", "wavkt", " weavedj", "avcmd", "avtxt"], "c": ["ctx", "cp", "ac", "gc", "m", "cor", "ci", "p", "ca", "z", "cn", "bc", "conf", "ctrl", "d", "xc", "w", "tc", "cache", "n", "cm", "mc", "cc", "nc", "C", "l", "co", "etc", "com", "chain", "b", "cs", "fc", "lib", "r", "lc", "cpp", "ec", "toc", "i", "t", "ce", "k", "g", "u", "ic", "pc", "unc", "dc", "cv", "cur", "con", "cam", "a", "e", "abc", "ch", "cu", "h", "cf", "rc", "f", "cont", "cb", "v", "ct"]}}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888, "substitutes": {"addr": ["pkg", "add", "Address", "adr", "np", "at", "mk", "pad", "help", "loc", "ptr", "ash", "src", "rn", "init", "inter", "address", "aux", "cmd", "point", "pointer", "act", "pos", "env", "gate", "amp", "ref", "asm", "align", "store", "off", "work", "obj", "hl", "mem", "alloc", "seek", "ack", "rc"], "size": ["south", "sp", "name", "type", "needed", "capacity", "address", "score", "sym", "expected", "speed", "step", "format", "set", "count", "sized", "ize", "term", "sent", "z", "SIZE", "padding", "cache", "Size", "shift", "gravity", "scope", "sum", "args", "shape", "pos", "error", "message", "sample", "member", "len", "perm", "done", "sn", "num", "si", "length", "small", "ptr", "notice", "scroll", "status", "max", "limit", "send", "empty", "timeout", "g", "news", "time", "fee", "space", "height", "start", "body", "scale", "n", "value", "amount", "style", "result", "sh", "s", "storage", "sw", "prime", "number", "code", "zero", "e", "index", "new", "weight"], "offset": ["reset", "end", "start", "sp", "o", "id", "pad", "slot", "type", "SIZE", "loc", "length", "ptr", "padding", "scroll", "range", "url", "needed", "shift", "amount", "Offset", "result", "style", "attr", "prefix", "address", "top", "expected", "location", "flag", "origin", "point", "pointer", "timeout", "pos", "sum", "extra", "set", "error", "optional", "initialized", "position", "ref", "slice", "count", "align", "window", "next", "off", "row", "zero", "before", "time", "index", "attribute", "op", "bool", "mask", "seek"], "p": ["ctx", "pkg", "cp", "pid", "m", "post", "perm", "tp", "q", "np", "pp", "sp", "pad", "jp", "ptr", "d", "bp", "ps", "ph", "pl", "P", "mp", "wp", "c", "proc", "vp", "point", "pos", "t", "g", "pro", "pc", "pa", "ip", "pb", "ap", "ping", "pre", "lp", "pi", "part", "fp", "f", "pers", "v"], "tmp": ["pkg", "np", "sp", "__", "unit", "tc", " ind", "opp", "copy", "test", "ret", "attr", "nt", "nom", "tn", "resp", "buf", "sam", "op", " tid", "term", "ctx", "cp", "uf", "tp", "vt", "emp", "jp", "cache", " leftover", "inter", "mp", "rt", " t", " ptr", "buff", "uv", "img", "pos", "amp", "slice", " np", "xy", "cont", "v", "temp", "perm", "m", " ref", "mk", " dst", "tt", "loc", "ptr", "orig", " pts", "timeout", " _", "txt", "msg", "var", "snap", "obj", "crop", " cached", " pad", " sp", "err", "elt", "src", "tar", "etc", "result", "stuff", "vp", "j", " prev", "t", "prime", " amp", "out", " temp", " mp", " ignored", "rm", "cmp"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n", "idx": 23895, "substitutes": {"v": ["V", "m", "vv", "tv", "vt", "p", "vc", "inv", "q", "ve", "ev", "z", "w", "d", "ver", "vs", "av", "vm", "l", "verb", "b", "c", "r", "vp", "j", "uv", "lv", "i", "t", "g", "u", "env", "vr", "cv", "vis", "e", "sv", "conv", "view", "h", "x", "call", "ov", "vi", "f"], "errp": ["errorpad", "erm", "errorP", "fxp", "errorpc", "fxpad", "errm", " errP", " errpc", "rrps", "fxpa", "errr", "errorpre", " errpre", "rrr", "rrP", " errr", "erps", " errm", "rrm", " errpad", "errpre", "errorp", "errorpa", "rrpc", "errps", "errpc", "rrp", "erp", "rrpre", "fxps", "errpa", "errP", "err", " errpa", " errps", "errorps", "errpad"]}}
{"project": "qemu", "commit_id": "894e02804c862c6940b43a0a488164655d3fb3f0", "target": 1, "func": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23899, "substitutes": {"client": ["current", "close", "connect", "public", "check", "contact", "p", "api", "at", "entry", "manager", "req", "web", "util", "ace", "common", "master", "cache", "conn", "plugin", "force", "component", "cl", "co", "google", "self", "chain", "prefix", "friend", "c", "core", "lib", "admin", "lock", "application", "config", "app", "template", "cmd", "nt", "server", "net", "remote", "ce", "pc", "patch", "open", "qualified", "collection", "cli", "controller", "store", "con", "channel", "window", "cur", "code", "obj", "pattern", "row", "http", "local", "form", "connection", "call", "Client", "ad", "cell", "cod"], "fatal": ["cfailed", "affating", "refalf", "ofatal", "refatal", "referential", "ofailed", "affalf", "refating", "fattery", "fault", "failed", "fortattery", "ofault", "fortault", "ferential", "fortailed", "fating", "afferential", "cfating", "cfalf", "fortatal", "falf", "affatal", "cfattery", "cfault", "ofattery", "cferential", "cfatal"], "errp": ["errorP", "derps", "erm", "derp", "errm", " errP", "Erpb", " errvp", "rarvp", "rarP", "rarlp", "derP", "erP", "diepa", "errpe", "rrP", "rrvp", " errm", "diep", "errpb", "rrlp", "derpe", "rarp", "errorp", "errps", "errorm", "errlp", " errpe", " errlp", "rrp", "erp", " errpb", "errpa", "errP", "diepb", " errpa", " errps", "Erp", "errorps", "errorpe", "errvp", "Erpa"], "ret": ["reset", "get", "cert", "alt", "ter", "tr", "Ret", "tmp", "def", "backed", "ext", "rem", "status", "att", "result", " Ret", "rt", "r", "pret", "lit", "pat", "flag", "nt", "sat", "print", "t", "det", "res", "reg", "cat", "rev", "ref", "re", "back", "mb", "resp", "out", "len", "ll", "arg", "rets", "mem", "gt", "arr", "str", "addr", "elt", "RET", "pas", "mt", "cont", "val"]}}
{"project": "qemu", "commit_id": "57be80f948cdbb75ef00fd8345845d83010d8af1", "target": 1, "func": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n", "idx": 23912, "substitutes": {"node_path": ["odeNamepath", "odeNamename", " node_stat", "nodeNamepath", "node___path", "node_log", "ode_name", "source_prop", "node___Path", "node_prop", "source_route", " node_name", "source_name", "node_route", "odeNamelog", "nodeletname", "sourceletroute", "node_name", " node_Path", "nodeptpath", "node_stat", "nodeletpath", "nodeptname", "sourceletpath", "nodeNamelog", "nodeNamename", "node_Path", "odeNamealias", "nodeptalias", "sourceletprop", "ode_alias", "nodeptlog", "nodeletroute", "node___stat", "nodeletprop", "sourceletname", "node___name", "nodeNamealias", "source_path", "node_alias", "ode_path", "ode_log"], "prop": ["ctx", "cfg", "pid", "pkg", "property", "p", "pr", "name", "conf", "tag", "def", "ps", "Prop", "typ", "test", "feat", " props", "etc", "com", "attr", "proc", "kind", "lit", "cmd", "pro", "col", "key", "msg", "pri", "desc", "pred", "obj", "sec", "str", "op", "priv", "rel", "label", "term"], "val": ["ctx", "vt", "p", "data", "pr", "name", "sel", "loc", "def", "value", "values", "vol", "r", "VAL", "tx", "item", "serv", "pt", "eval", "res", "reg", "Val", "msg", "ref", "al", "buf", "out", "obj", "arg", "mem", "str", "pal", "vals", "als", "err", "valid", "stat", "v"], "len": ["lf", " l", "ls", "end", "p", "del", " length", "seq", "L", "type", "fl", "length", "bin", "loc", "ln", "ld", "ell", "ann", "syn", "n", "elta", "wid", "pl", "lim", "lon", "Len", "l", "ob", "fun", "nl", "lib", "fn", "lan", "lit", "nt", "t", "size", "lis", "gz", "repl", "en", "dl", "ref", "vec", "var", "resp", " clen", "compl", "lif", "el", "ll", "arg", "au", "mem", "bf", "str", "lp", " bl", "err", " Len", "elt", "cmp"], "path": ["pkg", "dir", "json", "full", "transform", "file", "name", "conn", "walk", "chain", "nt", "pt", "format", "pro", "pc", "pattern", "ind", "x", "ath", "ctx", "cp", "pid", "list", "zip", "inner", "data", "l", "prefix", "PATH", "root", "config", "pointer", "col", "en", "binding", "local", "priv", "m", "cert", "Path", "loc", "length", "port", "anc", "url", "text", "history", "raw", "empty", "node", "patch", "route", "str", "th", "stat", "spec", "p", "parent", "id", "pr", "mount", "w", "n", "pl", "win", "c", "lock", "cmd", "host", "t", "key", "ref", "out", "base", "mem", "context", "h", "index"], "f": ["ac", "af", "fo", "ff", "lf", "alf", "uf", "p", "o", "file", "z", "full", "fl", "w", "d", "far", "fr", "fe", "fd", "fs", "fa", "l", "b", "c", "raf", "fc", "fn", "r", "elf", "fab", "j", "ef", "t", "fac", "u", "fi", "g", "buffer", "rf", "open", "a", "F", "e", "bf", "form", "h", "sf", "cf", "tf", "fb", "fp", "fm", "v", "df"], "ret": ["try", "num", "del", "alt", "rs", "ter", "Return", "tr", "Ret", "def", "dt", "ext", "rem", "status", "Len", "fin", "att", "result", " Ret", "l", "rt", "ort", "tail", "ry", "lib", "lit", "nt", "flag", "cmd", "deg", "print", "t", "ft", "net", "res", "set", "not", " RET", "cat", "lt", "en", "ruby", "rev", "re", "summary", "resp", "desc", "mb", "out", "ll", "arg", "mem", "rets", "gt", "nz", "usr", "str", "err", "elt", "RET", "pas", "mt", "cont"], "pathlen": ["Pathen", "Pathlen", "pathlength", "Pathln", "Pathstr", "Pathlength", "athLen", "lengthLen", " pathLen", "pathstr", "pathLen", "pathld", "pathen", "athstr", "PATHlength", "lengthlen", "athld", "athln", " pathld", "lengthen", "pathln", " pathln", "PATHLen", "PathLen", " pathen", "athlen", "athlength", "PATHstr", "PATHlen", " pathlength", "Pathld", "lengthlength"]}}
{"project": "qemu", "commit_id": "5c32be5baf41aec4f4675d2bf24f9948756abf3c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,\n\n                            TCGMemOpIdx oi, bool is_64)\n\n{\n\n    TCGMemOp memop = get_memop(oi);\n\n#ifdef CONFIG_SOFTMMU\n\n    unsigned memi = get_mmuidx(oi);\n\n    TCGReg addrz, param;\n\n    tcg_insn_unit *func;\n\n    tcg_insn_unit *label_ptr;\n\n\n\n    addrz = tcg_out_tlb_load(s, addr, memi, memop,\n\n                             offsetof(CPUTLBEntry, addr_read));\n\n\n\n    /* The fast path is exactly one insn.  Thus we can perform the\n\n       entire TLB Hit in the (annulled) delay slot of the branch\n\n       over the TLB Miss case.  */\n\n\n\n    /* beq,a,pt %[xi]cc, label0 */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT\n\n                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n\n\n    /* We use the helpers to extend SB and SW data, leaving the case\n\n       of SL needing explicit extending below.  */\n\n    if ((memop & MO_SSIZE) == MO_SL) {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    } else {\n\n        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];\n\n    }\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    /* Recall that all of the helpers return 64-bit results.\n\n       Which complicates things for sparcv8plus.  */\n\n    if (SPARC64) {\n\n        /* We let the helper sign-extend SB and SW, but leave SL for here.  */\n\n        if (is_64 && (memop & MO_SSIZE) == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n", "idx": 23916, "substitutes": {"s": ["ctx", "js", "m", "gs", "spec", "ssl", "ls", "q", "p", "es", "o", "rs", "z", "state", "ix", "us", "w", "d", "sb", "n", "y", "ims", "ds", "self", "sm", "b", "c", "an", "cs", "r", "as", "sw", "ts", "ses", "j", "ss", "in", "i", "stats", "t", "set", "g", "ns", "socket", "out", "a", "e", "source", "sts", "sv", "qs", "h", "x", "sg", "os", "sys", "S", "ex", "is", "v", "comm"], "data": ["ctx", "m", "dat", "o", "name", "id", "image", "w", "d", "ptr", "def", "mu", "cache", "ds", "ret", "address", "r", "tx", "no", "da", "dr", "pointer", "map", " mem", "reg", "size", "ip", "device", "window", "a", "obj", "mem", "DATA", "rec", "str", "x", "ata", "ad", "rel", "bus", "Data"], "addr": ["ctx", "ac", "m", "add", "Address", "adr", "alias", "start", "at", "id", "pad", "loc", "ag", "ptr", "url", "src", "n", " address", "offset", "attr", "nl", "address", "r", "tx", "ord", "dr", "act", "pos", "map", "res", "error", "amp", "ref", "ip", "align", "link", "oa", "coord", "a", "obj", "mem", "x", "ata", "rc", " ip", "hw", "err", "ad", "mt", "v"], "oi": ["ctx", "imei", "ta", "ilo", "hi", "eta", "obi", "oin", "oc", "rio", "ano", "o", "iso", "mx", " mic", "eni", " bi", " os", "udi", "si", "ori", "tmp", "mic", "ei", "bis", "typ", "offset", "xi", "ovi", "ti", "mi", "attr", "osi", "uti", "odi", "obo", "ok", " ki", "i", "pointer", " ii", " ov", "ui", "phi", "opa", "ip", "oa", "ini", "ati", "obj", "ico", "ois", "xy", "oid", "pi", "iri", " tid", "asi", "ami", "fp", " iso", "eric", "cb"], "is_64": ["isU64", "isi_148", "isU5", " is_48", " is_32", "is_32", "is_48", "isi_864", "isU32", "is_5", "isU48", "isi_64", " is_5", "is_148", "is_864"], "addrz": ["ptryz", " addrzo", " addrj", "addrld", " addrld", "ptrld", "addrj", "locze", " addrze", "clonez", "acez", " addressz", " addrzh", "addrzo", "urlzh", "locld", "clonezo", "addrze", "addrzh", " addresszi", " addressj", "acej", "acezi", "locyz", "urlz", "clonezh", "addrzi", "urlzo", "locz", " addrzi", " addryz", "ptrz", "ptrze", "addryz"], "param": ["ctx", "min", "pid", "perm", "m", "command", "cp", "num", "mm", "p", "par", "mod", "params", "name", "tmp", "common", "tag", "field", "um", "value", "imm", "prop", "offset", "init", "cpu", "attr", "proc", "arm", "admin", "sym", "pointer", "pos", "fac", "error", "aram", "col", "rank", "position", "ref", "pri", "var", "member", "comment", "Param", "prom", "coord", "row", "arg", "mem", "index", "attribute", "pi", "part", "cal", "pai", "weight", "dim", "pas", "meter", "label", "im"], "func": ["ctx", "callback", "Function", "imp", "fw", "cast", "must", "util", "FUN", "cc", "fd", "expr", "fun", "attr", "result", "proc", "access", "fn", "fc", "mac", "aux", "wrapper", "kw", "function", "lc", "cmd", "act", "args", "method", "fac", "cond", "unc", "var", "amd", "con", "conv", "comp", "lambda", "package", "cf", "call", "exec", "f", "cb", "rc", "val"], "label_ptr": ["label_obj", "lab_addr", "label_pointer", " label_obj", "label_Ptr", "label2ptr", "lab_pointer", " label_pointer", "label2Ptr", " label_addr", "lab_Ptr", "label2addr", "lab_ptr", "label_addr", "label2pointer"]}}
{"project": "qemu", "commit_id": "e36c87667aa2204a3f19efe7bbcb6eb41f098e40", "target": 1, "func": "opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n", "idx": 23918, "substitutes": {}}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_host_open(USBHostDevice *s, libusb_device *dev)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    int bus_num = libusb_get_bus_number(dev);\n\n    int addr    = libusb_get_device_address(dev);\n\n    int rc;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (s->dh != NULL) {\n\n        goto fail;\n\n    }\n\n    rc = libusb_open(dev, &s->dh);\n\n    if (rc != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->dev     = dev;\n\n    s->bus_num = bus_num;\n\n    s->addr    = addr;\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    libusb_get_device_descriptor(dev, &s->ddesc);\n\n    usb_host_get_port(s->dev, s->port, sizeof(s->port));\n\n\n\n    usb_ep_init(udev);\n\n    usb_host_ep_update(s);\n\n\n\n    udev->speed     = speed_map[libusb_get_device_speed(dev)];\n\n    usb_host_speed_compat(s);\n\n\n\n    if (s->ddesc.iProduct) {\n\n        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,\n\n                                           (unsigned char *)udev->product_desc,\n\n                                           sizeof(udev->product_desc));\n\n    } else {\n\n        snprintf(udev->product_desc, sizeof(udev->product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    }\n\n\n\n    rc = usb_device_attach(udev);\n\n    if (rc) {\n\n        goto fail;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (s->dh != NULL) {\n\n        libusb_close(s->dh);\n\n        s->dh = NULL;\n\n        s->dev = NULL;\n\n    }\n\n    return -1;\n\n}\n", "idx": 23922, "substitutes": {"s": ["rest", "so", "rs", "bs", "params", "conf", "fs", "ims", "sa", "settings", "cs", "stats", "search", "set", "https", "its", "ins", "store", "a", "sam", "os", "f", "ls", "es", "bes", "vs", "ps", "ds", "self", "l", "b", "ts", "serv", "args", "less", "ports", "source", "se", "save", "is", "v", "js", "gs", "m", "us", "state", "parts", "states", "ms", "an", "r", "ses", "ss", "aws", "g", "hs", "services", "sts", "http", "sys", "ats", "sports", "comm", "spec", "sq", "p", "details", "w", "sb", "n", "has", "c", "tests", "as", "sw", "j", "mods", "i", "t", "ns", "changes", "sv", "qs", "h", "properties", "S", "als", "ops", "sd"], "dev": ["end", "del", "ve", "name", "conf", "ver", "eng", "conn", "test", "enc", "nt", "dd", "de", "buf", "md", "cam", "adv", "hw", "ad", "data", "d", "den", "iv", "ds", "att", "hd", "doc", "hid", "di", "remote", "env", "device", "desc", "priv", "usb", "v", "js", "pub", "ev", "pad", "req", "ptr", "des", "av", "er", "raw", "wd", "dis", "app", "g", "dem", "window", "obj", "sys", "vo", "spec", "p", "api", "Dev", "w", "def", "DEV", "n", "dh", "sw", " device", "cmd", "go", "host", "t", "det", "dn", "db", "cho", "eth", "handle", "mem", "h", "addr", "sd", "val"], "udev": ["urdev", "duend", "ddele", "audv", "uidov", "udele", "uderv", "ddove", "uiddev", "uidend", "ubov", "duel", "uidoc", "uidew", "uuv", "udov", "ubv", "ubel", "ubef", "auddev", "udove", "uboc", "uudev", "uuov", "udew", "udel", "uuew", "uuef", "ubew", "vdev", "vddev", "ubev", "uberv", "uiderv", "vdv", "uuev", "uidel", "ubdev", "audele", "uuver", "ubove", "uidev", "udoc", "vdiv", "uddev", "uidef", "ubend", "udef", "urdiv", "urddev", "udend", "dddev", "ddev", "urdv", "ddv", "uidv", "ddef", "duev", "uuove", "uidiv", "audev", "uuerv", "dudev", "ddoc", "udv", "ubiv", "uidele", "ddver", "udiv", "uidver", "udver"], "rc": ["ac", "rin", "gc", "asc", "cr", "rx", "cor", "success", "oc", "inc", "ko", "isc", "rs", "roc", "bc", "tc", "anc", "src", "nc", "sc", "cc", "rn", "cod", "init", "rys", "co", "rt", "c", "RC", "cs", "sync", "irc", "ok", "ry", "fc", "lc", "ec", "uc", "act", "func", "clus", "ce", "auth", "auc", "initialized", "pc", "ck", "cur", "cv", "con", "code", "ro", "row", "abc", "ctr", "rec", "rl", "rr", "cmp", "arc", "coll", "ack", "cont"]}}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n", "idx": 23924, "substitutes": {"new_size": [" new_user", "newingsize", "new_page", "newingdump", " new_length", "new_dump", "new_user", "New_page", " new_container", "New_sum", "newjcontainer", "New_scale", " new_SIZE", "new_sum", "newjSIZE", "newingsum", "new23length", "newjsize", "new_form", "new23user", "New_Size", "new23storage", "new_Size", "New_dump", "New_size", "next_cache", " new_form", "new_container", "new_SIZE", " new_storage", "next_Size", "new_scale", "next_name", "new_name", "new_storage", "new23size", "newingSIZE", "new_length", "New_SIZE", " new_Size", "next_size"], "errp": ["errorP", "nerp", "orderpe", "lrpre", "privpress", "privpre", "errpkg", "errorpc", "irp", " errP", " errpc", "arrpre", "rrpolicy", "orderpa", "warnpc", "lrpkg", "errpress", "privpkg", "irpb", "errpe", "arrpkg", "irpolicy", "privp", "errpre", "errpb", "rrpb", "errorp", "errorpa", "nerpb", "errpc", " errpe", "errpolicy", "rrp", "warnp", "irpre", "orderp", "arrpress", "nerpolicy", "orderP", "rrpre", "lrp", "errpa", "errP", "warnpa", "arrp", " errpa", "lrpress", "nerpre", "errorpe", "warnP"], "new_cache": ["fromlyc", " new_cas", "new_code", "ew_Cache", "newThespec", "ew_cache", "newTheCache", "new_binary", " new_spec", "ewJcache", "new____binary", "newThec", "ewJsize", "newJcache", "ewJsuccess", "new____Cache", "new_c", "newlycode", "ewJCache", "from_c", "fromlycache", "newJsize", "new____cache", "newjCache", "from_cas", "newjcache", "newJsuccess", "newlycas", "newlyc", "ew_size", " new_Cache", " new_binary", "new_spec", "ew_success", "from_code", " new_c", "newThecache", "newjcas", "new____cas", "new_success", "new_cas", "new_Cache", "fromlycode", "from_cache", "fromlycas", "newJCache", "newjbinary", "newlycache"], "ret": ["gc", "reset", "uf", "try", "alt", "Return", "tr", "Ret", "def", "ext", "it", "rem", "status", "inter", "fin", "l", " Ret", "result", "rt", "xt", "nl", "final", "nt", "flag", "dr", "print", "t", "ft", "res", "lt", "rez", "ref", "rev", "re", "resp", "out", "len", "arg", "rets", "mem", "gt", "nz", "str", "new", "rm", "elt", "RET", "rel", "back", "progress", "mt", "ne", "cont", "opt", "val"]}}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_rt_sigframe *frame;\n\n    int i, err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 23933, "substitutes": {"sig": ["tsig", "vsix", "insig", "psign", "nsag", "sag", "psamp", " sigma", "nsign", "sigs", " samp", "sigen", "Sign", "nsigs", "sigma", "psigs", "isigs", "insag", "Sag", "psix", "psigma", "isix", "isig", "isign", "ssigma", "nsig", " sigs", "tsigen", "vsigs", "tsigma", "six", "msigs", " sigen", "Sig", "samp", "vsign", "msamp", "psig", "msigma", "msig", "ssig", "sign", "vsig", "insigs", "ssigen", "insign", "Sigs"], "ka": ["ctx", "ha", "ta", "ke", "Ka", "kan", "kr", "ko", "ca", "ema", "ja", "kat", "kt", "KO", "unk", "ama", "ak", "km", "cki", "KA", "ica", "sa", "ker", "kit", "ski", "kw", "tk", "kl", "k", "kas", "ket", "arma", "ck", "ken", "ku", "ks", "gha", "aka", "sk", "kj", "ki"], "info": ["ctx", "meta", "fo", "INFO", "hi", "recent", "check", "json", "ta", "data", "ist", "conf", "si", "loc", "user", "Info", "def", "information", "conn", "ext", "it", "init", "ti", "text", "inf", "doc", "aux", "isu", "jo", "ok", " ki", "about", "in", "auth", "prof", "ki", " fi", "fi", "ui", "metadata", "txt", "desc", "is", "now", "mem", "os", "priv", "ami", "stat", "f", " inf"], "set": ["ctx", "post", "m", "check", "spec", "get", "reset", "pack", "end", "add", "start", "data", "Set", "list", "sp", "name", "push", "parse", "up", "def", "range", "sc", "init", "site", "dict", "sa", "sh", "c", "pair", "send", "tx", "gen", "ut", "map", "size", "k", "en", "open", "sche", "msg", "et", "create", "setup", "store", "SET", "handle", "code", "ch", "mem", "context", "equal", "sys", "pre", "se", "op", "new", "save", "st", "block", "clear", "use"], "env": ["ctx", "dev", "stage", "vt", "viron", "exc", "v", "te", "qt", "ev", "end", "manager", "inv", "esm", "conf", "loc", "gov", "esc", "eng", "vs", "ra", "va", "ei", "ah", "vm", "sc", "environment", "ten", "init", "er", "neck", "ote", "vp", "tk", "ec", "uv", "org", "ef", "server", "net", "en", "ner", "ew", "et", "buf", "window", "nv", "obj", "e", "context", "sv", "hw", "gear", "st", "cb", "cv"], "frame_addr": [" frame_address", "frame__address", "frame__addr", "Frame_address", "frame_loc", "Frame_ptr", "frame_offset", "Frame_loc", "frame__loc", " frame_ptr", "frame_address", "frame__ptr", "frame_pos", " frame_offset", "Frame_addr", "frame_ptr", " frame_pos"], "r26": [" r89", "R26", "R16", " r65", "r0", "r65", "R20", "ar16", "R0", "r16", "rr20", "R89", " r0", "ar26", "r20", "rr26", " r16", " r20", "rr65", "r89", "ar0", "rr89", "R65"], "frame": ["user", "force", "role", "chain", "feature", "step", "rame", "frames", "condition", "fake", "call", "block", "f", "trace", "ctx", "stage", "command", "request", "component", "ence", "scope", "function", "remote", "error", "message", "setup", "flow", "fb", "draw", "face", "profile", "scene", "state", "word", "image", "module", "fr", "init", "Frame", "fram", "send", "thread", "header", "node", "point", "version", "shot", "fi", "page", "window", "channel", "row", "rule", "connection", "err", "sequence", "zone", "def", "feat", "style", "line", "lock", "show", "ce", "ref", "process", "event", "code", "base", "context", "cf", "response", "ze"], "i": ["hi", "m", "me", "list", " ti", "ci", "ix", "p", "us", "o", "id", "si", " bi", "zi", "multi", " mi", " di", "ei", "n", "y", "it", "xi", "ims", "l", "ti", "mi", "qi", "iu", "c", "u", "j", "di", "in", "dr", "\u0438", "point", "ai", "t", " ii", " I", " k", "phi", "ui", "li", "ic", "key", " j", "ip", "sim", "gi", "series", "ji", "ini", " x", "bi", "ind", "h", "ii", "x", "index", "pi", "batch", "asi", "I", "ami", " ni", "is", " pi"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n", "idx": 23938, "substitutes": {"dev": ["spec", "ve", "ev", "pad", "conf", "Dev", "w", "Device", "ver", "d", "def", "des", "DEV", "conn", "test", "ds", "att", "er", "proc", "doc", "hid", "serv", "scan", "go", "dm", "pro", "dem", "watch", "de", "device", "cam", "mem", "sys", "hw", "ad", "devices", "usb", "v"], "s": ["south", "so", "rs", "bs", "conf", "ver", "gets", "fs", "sa", "settings", "cs", "stats", "set", "ins", "store", "its", "sam", "os", "ls", "es", "ads", "ids", "bes", "vs", "ps", "sis", "l", "ds", "b", "ts", "serv", "less", "ports", "conv", "se", "is", "locks", "v", "js", "gs", "sl", "state", "reads", "des", "parts", "bis", "states", "sm", "ms", "r", "ses", "terms", "ss", "aws", "g", "ers", "hs", "services", "obj", "sts", "sys", "ats", "stat", "pers", "sports", "comm", "spec", "p", "sq", "details", "sb", "n", "has", "tests", "sync", "sw", "mods", "t", "ns", "changes", "sv", "qs", "S", "als", "ops", "sd"]}}
{"project": "qemu", "commit_id": "9ed415b28b0c808e8b0fc631902cb9ce277f0245", "target": 1, "func": "static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}", "idx": 23942, "substitutes": {"t": ["ta", "m", "tp", "vt", "p", "te", "o", "qt", "tr", "tt", "ot", "kt", "tc", "n", "dt", "it", "tm", "b", "wt", "rt", "c", "task", "r", "tk", "ts", "nt", "T", "pt", "tu", "tn", "txt", "a", "tz", "h", "f", "v", "ct"], "ev": ["dev", "tv", "eg", "ep", "vc", "inv", "ve", "tr", "ver", "ell", "veh", "av", "eng", "vent", "it", "iv", "att", "expr", "attr", "Ev", "ote", "serv", "enc", "ig", " evict", "ec", "uv", "lv", "eval", " ov", "ever", " emit", "ek", "vr", "rev", "ew", " dev", "event", "el", "e", "ent", "lif", " event", " sv", "sv", "ee", "EV", "exec", " tv", "err", "ele", "ov", " eval", " vec", " te", "v", "val"], "host_timer": [" host2timer", "host_Timer", "Host_tim", " host2time", "server_timer", "server_tim", "server_tick", "host_tm", "host_tim", " host_time", " host2tm", "Host_timer", "Host_Timer", "host2Timer", "host_time", "host2tm", "host2timer", " host_Timer", "server_Timer", " host_tm", "host_tick", "host2time", "host_er", "Host_er", " host2Timer"], "act": ["action", "Act", "ac", "acts", "ctx", "xp", "eff", "acc", "ACT", "and", "fact", "pr", "ax", "aj", "at", "am", "apt", "ace", "ann", "av", "ant", "iat", "it", "init", "att", "sa", "attr", "rt", "tx", " ac", "j", "enc", "cmd", "ec", "pt", "active", "auth", "set", "sect", "txt", "et", "con", "a", "obj", "actor", "ind", "ect", " acts", "agent", "h", "x", " enc", "crit", " cla", "err", "cap", "ack", "cont", "cv", "ct"]}}
{"project": "qemu", "commit_id": "b7022d9ac61311f92aef0994e2ab801b76d55f14", "target": 1, "func": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n", "idx": 23947, "substitutes": {"cc": ["ctx", "cp", "gc", "acc", "ci", "CC", "vc", "isc", "bc", "xc", "tc", "sc", "nc", "mc", "cm", "cod", "cz", "cl", "co", "craft", "c", "cs", "fc", "lc", "ec", "cmd", "pc", "cd", "cci", "dc", "ck", "cv", "hh", "sec", "cca", "cu", "cf", "cb", "cont", "ctl", "rc", "ct"], "pec": ["ped", "cp", "xp", "pel", "spec", "vc", "pr", "ppo", "pes", "pe", "per", "xc", "ptr", "yp", "Spec", "pan", "typ", "sc", "ps", "wid", "pl", "eps", "pect", "phy", "fif", "mp", "scl", "spe", "c", "cs", "fc", "vp", "lc", "pat", "ec", "act", "pt", "pc", "lip", "pac", "ppa", "rpm", "pic", "cf", "lp", "pi", "fp", "cmp", "px", "ctl", "cod", "ct"], "fh": ["ffth", "efh", "efhe", "xhandle", " fhandle", "bhd", "ph", "bkh", "hc", "ffaddr", "xh", " fkh", "efhandle", "fc", "xid", "fhd", "xhe", "ffh", "efid", "fkh", "phandle", " fhe", "bh", "fth", "fhe", "fhandle", "haddr", "bhandle", "hh", "phd", "hth", "ffc", " fth", " fhd", "pkh", " fc"], "fid": ["fkind", "vkid", "fids", " foid", "utfid", "vhid", "fhid", "fkid", " fids", "vrid", "tfkind", "ckind", "ckid", "xfids", "utfkind", "cid", "tfrid", "lkid", "ifid", "lrid", "lhid", "ifids", "xfaddr", "fmid", "lid", "tfmid", "ifaddr", "ifoid", "chid", "tfid", "foid", "xfoid", "crid", "xfid", "frid", "utfmid", "utfrid", "cmid", "vid"], "faddr": ["fptr", "fpad", "lcoord", "fiaddress", "qcoord", "fcaddr", "fisha", "qaddr", "qpad", "fsha", "qdate", "waddr", "fadr", "wsha", "paddr", "wptr", " fsha", "ladr", "fadd", "fiaddr", "fiptr", " fpad", "paddress", " faddress", " fptr", "fcdate", " fdate", "fcadd", " fadd", "laddress", "qadr", "qaddress", "fcpad", "qadd", "laddr", "waddress", "fcoord", "pcoord", "fdate", "faddress", "padr"], "e": ["me", "m", "em", "eg", "ep", "end", "te", "eb", "p", "o", "ne", "be", "debug", "eeee", "pe", "d", "n", "ei", "oe", "ue", "l", "ye", "b", "er", "ae", "xe", "c", "r", "ec", "i", "t", "g", "u", "E", "en", "ed", "ate", "ge", "note", "el", "se", "ee", "eu", "ele", "f", "le", "v"], "sei_cont": ["sei0cont", "seiptcont", "sei_control", "sei_cert", "seiptcar", "seiamcont", "uci_cert", "seiedcert", "seiptcoll", "sei0car", "nai_coll", "osi_Cont", "sei0coll", "seiedcom", "nai_cell", "sea_cont", "nai_det", "nai_well", "sei_stream", "osi_cur", "nai_car", "sei_dat", "enei_dat", "seieddat", "sei_nav", "osi_com", "seiedcar", "sea_container", "sei1cont", "nai_cont", "seaammont", "enei_cont", "sei_car", "ista_stream", "seaamcar", "seaamcont", "sei_com", "seiamcar", "sei_cat", "sei_coll", "sei1stream", "sei1control", "sei_cell", "sei0well", "sei_det", "sei1cat", "enei_controller", "seaamcontainer", "uci_nav", "sea_car", "osi_cont", "seiedcontroller", "sei_controller", "ici_cont", "sea_mont", "sei_Cont", "ici_cert", "sei_mont", "ista_cont", "seiptwell", "uci_ont", "seiedcont", "ista_cat", "sei_ont", "sei_container", "ici_car", "uci_cont", "seiammont", "sei_cur", "seiamcontainer", "ici_dat", "enei_com", "sei_well", "ista_control"], "s": ["js", "gs", "m", "sets", "ls", "p", "sq", "rs", "state", "details", "sb", "gets", "ties", "n", "ps", "states", "bis", "fs", "sis", "ds", "c", "settings", "r", "ts", "ss", "i", "stats", "t", "joined", "less", "set", "ns", "services", "hs", "ports", "ares", "sts", "sv", "qs", "tains", "sys", "h", "se", "ats", "S", "is", "v"]}}
{"project": "qemu", "commit_id": "81907a582901671c15be36a63b5063f88f3487e2", "target": 1, "func": "void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,\n\n                CPSRWriteType write_type)\n\n{\n\n    uint32_t changed_daif;\n\n\n\n    if (mask & CPSR_NZCV) {\n\n        env->ZF = (~val) & CPSR_Z;\n\n        env->NF = val;\n\n        env->CF = (val >> 29) & 1;\n\n        env->VF = (val << 3) & 0x80000000;\n\n    }\n\n    if (mask & CPSR_Q)\n\n        env->QF = ((val & CPSR_Q) != 0);\n\n    if (mask & CPSR_T)\n\n        env->thumb = ((val & CPSR_T) != 0);\n\n    if (mask & CPSR_IT_0_1) {\n\n        env->condexec_bits &= ~3;\n\n        env->condexec_bits |= (val >> 25) & 3;\n\n    }\n\n    if (mask & CPSR_IT_2_7) {\n\n        env->condexec_bits &= 3;\n\n        env->condexec_bits |= (val >> 8) & 0xfc;\n\n    }\n\n    if (mask & CPSR_GE) {\n\n        env->GE = (val >> 16) & 0xf;\n\n    }\n\n\n\n    /* In a V7 implementation that includes the security extensions but does\n\n     * not include Virtualization Extensions the SCR.FW and SCR.AW bits control\n\n     * whether non-secure software is allowed to change the CPSR_F and CPSR_A\n\n     * bits respectively.\n\n     *\n\n     * In a V8 implementation, it is permitted for privileged software to\n\n     * change the CPSR A/F bits regardless of the SCR.AW/FW bits.\n\n     */\n\n    if (write_type != CPSRWriteRaw && !arm_feature(env, ARM_FEATURE_V8) &&\n\n        arm_feature(env, ARM_FEATURE_EL3) &&\n\n        !arm_feature(env, ARM_FEATURE_EL2) &&\n\n        !arm_is_secure(env)) {\n\n\n\n        changed_daif = (env->daif ^ val) & mask;\n\n\n\n        if (changed_daif & CPSR_A) {\n\n            /* Check to see if we are allowed to change the masking of async\n\n             * abort exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_AW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_A flag from \"\n\n                              \"non-secure world with SCR.AW bit clear\\n\");\n\n                mask &= ~CPSR_A;\n\n            }\n\n        }\n\n\n\n        if (changed_daif & CPSR_F) {\n\n            /* Check to see if we are allowed to change the masking of FIQ\n\n             * exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_FW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_F flag from \"\n\n                              \"non-secure world with SCR.FW bit clear\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n\n\n            /* Check whether non-maskable FIQ (NMFI) support is enabled.\n\n             * If this bit is set software is not allowed to mask\n\n             * FIQs, but is allowed to set CPSR_F to 0.\n\n             */\n\n            if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_NMFI) &&\n\n                (val & CPSR_F)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to enable CPSR_F flag \"\n\n                              \"(non-maskable FIQ [NMFI] support enabled)\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n        }\n\n    }\n\n\n\n    env->daif &= ~(CPSR_AIF & mask);\n\n    env->daif |= val & CPSR_AIF & mask;\n\n\n\n    if (write_type != CPSRWriteRaw &&\n\n        (env->uncached_cpsr & CPSR_M) != CPSR_USER &&\n\n        ((env->uncached_cpsr ^ val) & mask & CPSR_M)) {\n\n        if (bad_mode_switch(env, val & CPSR_M)) {\n\n            /* Attempt to switch to an invalid mode: this is UNPREDICTABLE.\n\n             * We choose to ignore the attempt and leave the CPSR M field\n\n             * untouched.\n\n             */\n\n            mask &= ~CPSR_M;\n\n        } else {\n\n            switch_mode(env, val & CPSR_M);\n\n        }\n\n    }\n\n    mask &= ~CACHED_CPSR_BITS;\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);\n\n}\n", "idx": 23956, "substitutes": {"env": ["pkg", "equ", "end", "ve", "shell", "conf", "eng", "conn", "ei", "environment", "loader", "chain", "attr", "worker", "enc", "server", "et", "pb", "client", "store", "buf", "cookie", "cam", "hw", "container", "gear", "block", "erd", "table", "cb", "cv", "ctx", "vt", "qt", "manager", "vs", "vm", "enter", "iv", "era", "self", "config", "ec", "ener", "net", "en", "ew", "desc", "ent", "kernel", "v", "menu", "dev", "te", "ev", "here", "engine", "console", "ka", "chart", "timer", "oe", "er", "act", "open", "txt", "msg", "outer", "var", "window", "answer", "obj", "hl", "policy", "ee", "ger", "kh", "vv", "em", "forge", "oder", "ter", "entry", "w", "esc", "def", "ah", "door", "vp", "query", "cmd", "ef", "db", "ner", "gate", "vert", "ey", "disk", "nv", "code", "e", "context", "runner", "addr", "operator", "Environment", "response"], "val": ["V", "check", "alpha", "sel", "conf", "ver", "prop", "test", "ret", "lib", "pt", "vec", "buf", "arg", "arr", "x", "pal", "cal", "block", "ctx", "vt", "data", "z", "cache", "it", "iv", "l", "bit", "b", "vol", "doc", "fail", "serv", "uv", "flag", "k", "Val", "pol", "len", "xy", "local", "fb", "kl", "v", "dev", "aval", "alt", "state", "req", "item", "lv", "eval", "res", "bl", "msg", "var", "al", "el", "elt", "valid", "stat", "Value", "p", "pr", "def", "value", "values", "lock", "VAL", "tx", "t", "db", "buffer", "key", "ref", "out", "zero", "all", "base", "mem", "index", "pre", "vals"], "mask": ["check", "pack", "transform", "hide", "hold", "name", "type", "cast", "magic", "mode", "feature", "address", "mac", "set", "count", "sign", "bug", "pattern", "condition", "filter", "ask", "block", "clear", "Mask", "box", "tag", "shift", "bit", "allow", "config", "flag", "known", "sum", "shape", "map", "hash", "comment", "mission", "part", "perm", "m", "alt", "mk", "length", "field", "module", "ms", "broad", "delay", "ma", "skip", "patch", "xf", "window", "level", "form", "miss", "batch", "make", "id", "flags", "scale", "tar", "layout", "style", "lock", "mark", "black", "size", "mail", "match", "buffer", "key", "gate", "code", "zero", "cf", "sk", "mt", "label", "fix"], "write_type": ["writer_mode", "writeTypetype", "write__pe", "write_pe", "write__Type", "write__key", "writeTypeype", "write_Type", "write__type", " write_pe", "writeTypemode", "write_mode", " write_Type", "writer_ype", "write_key", "writer_type", " write_key", "write_ype"], "changed_daif": ["changed__naip", "changed_gaemon", "changed_deig", "changed_ndaif", "changed_daig", "changed_taf", "changed_shaaph", "changed_nail", "changed_naib", "changed__daif", "changed_naig", "changed_diaph", "changed_ndaIF", "changed_gaig", "changed_eaig", "changed_daib", "changed_daim", "changed_gaib", "changed_deif", "changed_cail", "changed_diIF", "changed_daf", "changed_naif", "changed___naif", "changed_dait", "changed__naig", "changed_ndaim", "changed_taiff", "changed_taif", "changed_eaip", "changed_eail", "changed_maiff", "changed_maf", "changed__daig", "changed_ndaaph", "changed___daif", "changed_diif", "changed___naig", "changed___daemon", "changed_eaif", "changed_mait", "changed_daIF", "changed_maif", "changed_deib", "changed_daemon", "changed___naemon", "changed___naib", "changed_naip", "changed__nail", "changed___daig", "changed_caig", "changed_diim", "changed_caip", "changed_daaph", "changed_shaIF", "changed_gaif", "changed_dail", "changed_tait", "changed_deemon", "changed__naif", "changed_daip", "changed_shaif", "changed__dail", "changed__daip", "changed___daib", "changed_daiff", "changed_caif", "changed_shaim", "changed_naemon"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIOConfigMirrorQuirk *mirror;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vfio_is_vga(vdev) || nr != 0) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 23965, "substitutes": {"vdev": ["vDev", "mdb", "avconf", "vmdiv", "tver", "fev", "vardes", "vcstore", "vtcast", "avdevices", "gdevice", "vDEV", "avdevelop", "gdev", "vcam", "tcam", "vtdev", "avcam", " vdb", "pdev", "vlink", "mdes", "vdem", " vswitch", " vDEV", "vver", "mconn", "svdata", "vtdevice", "avpad", "vconf", "dDev", "mdev", "pdevice", "vtswitch", "vtcmd", "avvar", "fpad", "vpad", "mev", " vver", "vmvar", "mdevice", "vmdev", "svdevice", "dcam", "avdevice", "avdiv", "avdev", "svconn", "mswitch", "vdiv", "vdef", " vdevices", "ldev", "fdev", "vtconf", "vdb", "vcmd", "tev", "vswitch", "mhw", "dev", "vcdb", "mlink", "varlink", "vmconf", " vcam", "vdes", "vdevices", "vev", "ldef", "vcdevice", "vardevice", "vhw", "vtdem", "lconn", "vtdiv", "mcast", " vev", "gDev", "pcmd", "ddevice", "ddev", "gev", " vstore", "svcam", "mdem", "fdevelop", "mcmd", "avstore", "vcdoc", "mdef", "vcdev", "svdev", "vdevelop", "fDEV", "avdes", " vhw", "vtvar", "vconn", "vchw", "mDEV", "vardev", "tdevice", "pdem", "mdata", " vdoc", "tdevices", "avlink", "vdoc", " vcast", "avdoc", "svev", "vcast", "vdevice", "mDev", "ldata", "vstore", "svdef", "vvar", "vcconf", " vdevice", "tdev", " vconf", " vpad", " vdevelop", "fver", "vdata", "fdevice"], "nr": ["byter", " nm", "nw", "hr", "num", "sn", "cor", "kr", "mr", "nb", "np", " hr", "bar", "adr", "radius", "NRS", " sidx", "uj", "gov", "nm", "nn", "br", "n", "nc", "nih", "nie", "inter", "nor", "ij", " nib", "attr", "yr", "gr", "r", "no", "NV", "org", "ni", "NR", "arity", "tn", " neighbor", "ner", "ng", " NV", "vr", " n", " resid", " np", "next", "number", "nv", "nar", "eno", "obs", "obj", "ctr", "nz", " NR", "nir", "sys", "usr", "Ni", "rr", "addr", "err", " ni", "ne", "cb"], "quirk": ["qurison", "quiry", "acquack", "qorum", "quoise", "quavour", "queryirk", "swirrel", "conirt", "aquorum", "chirk", "aquavour", " quirus", "requirus", "requrison", "quack", "qirk", "requirrel", "squirrel", "squavour", "squorum", "quail", "queryirt", "iquiet", "acquirt", "qualirus", "chlict", "qulict", "qirus", "querylict", "QUiat", "squirt", "squack", "quiet", "squiry", "swirk", "wiat", "iquiat", "iquirus", "conirus", "coniry", "requiry", "inquail", "acqurison", "swirus", "acquoise", "inquack", "squail", "aqurison", "clirt", "inquirk", "requlict", "QUavour", "quiat", "squiat", "quallict", "quirt", "acqulict", "qualavour", "acquiry", "quirus", " quiat", "shirk", "squirk", "acquail", "iquirt", "aqulict", "squoise", "chavour", "wirk", "acquiat", "conirk", "requirk", "shiat", "shiet", "requoise", "cllict", "clirus", "wirus", "quorum", "queryirus", "quirrel", "swavour", "qualirk", "iquiry", "qirrel", "chirus", "acquirk", "wirrel", "squiet", "inquirus", "aquirrel", "acquirus", "acquavour", " quavour", "acquirrel", "squlict", "shirus", "squirus", "QUirus", "clirk", "iquirk", "aquirus", "QUirk", "aquirk", "requiat", "iquirrel"], "mirror": ["murmont", "merior", "torror", "morror", " mirrett", "morrect", "mrect", "rerder", "mirvert", "merrored", "mormit", "torior", "porror", " mirgr", "merrett", "liberror", "mirrup", "pirrelation", "mirference", "merder", "pirrage", "mirerect", "irmrect", " mirmit", "mirner", "bormit", "mirri", "marner", "mervention", "morner", "mirride", "verrage", "morrup", "mirvention", " mirrup", "MirROR", "borvey", "merror", "mride", "irrect", " mirfix", "rerrelation", "mirrect", "Mirmont", "mirallow", "irri", "irrage", "mirmit", "pirvention", "rerior", " mirallow", "rerror", " mirrect", "murROR", "mintrect", "porvey", "merrect", " mirvey", "mintner", "irride", "mintror", " mirbug", "irmmont", "mirrage", "porride", "irrup", " mirROR", "mirener", "mirr", "mirfix", "ververt", "mireder", "borror", "irrored", "mintfix", "Mirrect", "irror", "mirrett", "morrr", "libermit", "irvey", "verROR", "marror", "merride", "mror", " mirvention", "irmror", "mirebug", " mirri", "murror", "verror", "mirmont", "Mirror", "miror", "liberrect", "interride", "liberrr", "mirior", "intervey", "miference", "mirvey", "rerrect", "porder", "marvention", "rerride", "mirbug", "verrored", "irvert", "irfix", "rervey", "interror", "murmit", "murrect", "pirvert", "mirerr", "irgr", "murri", "pirror", "marrr", "irmit", "morvention", "mvention", "irner", "mirevey", "irference", "rervert", " mirrr", "verrect", "mireallow", "torride", "pirgr", "mirder", " mirder", "morvey", "mirROR", " mirride", "irmROR", "mirgr", " mirference", "pirrect", "irder", "mirrored", " mirner", "interROR", "pirride", "rergr", "irrett", "irbug", "mervey", "mirrelation", " mirrored", "mirrr", "irROR", "torvey", "merROR", "borrr", "irrr", "irrelation", "mireror", "migr", "irallow"]}}
{"project": "qemu", "commit_id": "8e7a6db96566fe4162edaeb3e8b62fc8004d1598", "target": 1, "func": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n", "idx": 24009, "substitutes": {"ctx": ["cp", "pkg", "cfg", "CT", "this", "CC", "ca", "np", "mk", "bc", "req", "jp", "kt", "tmp", "xc", "tc", "anc", "conn", "nc", "cm", "cc", "mc", "sc", "Context", "tm", "c", "kw", "tx", "config", "cmd", "act", "ck", "setup", "cur", "con", "handle", "context", "sys", "cf", "hw", "cmp", " cx", "cv", "ct"], "arg0": ["ig0", "arg4", "tag4", "Arg00", "arg00", "Arg50", "ig50", "Arg1", "param0", "arg50", "tag1", " arg50", "ig00", "tag0", "param4", "param1", " arg4", "param00", "tag00", "Arg0", "ig1", " arg00"], "arg1": ["arg4", "args2", "tag4", "args3", "paramn", "argn", " argn", "arg01", "agg3", "param01", "args4", "aggn", "args0", "tag2", "tag1", "arg3", " arg3", "agg01", "tag0", "param1", "param3", " arg4", " arg01", "args1", "agg1", "tag3"], "arg2": ["arg4", "args2", "doc02", "args3", "prop1", "agg02", " arg6", "arg02", "arg6", "agg4", "agg3", "agg2", "doc4", " arg02", "doc3", "prop2", "prop6", "arg3", " arg3", "args6", " arg4", "prop3", "args1", "doc2"], "sub": ["any", "pub", "add", "big", "pop", "un", "control", "mod", "ub", "push", "bc", "small", "mut", " Sub", "tag", "super", "sc", "delete", "shift", "broad", "false", "neg", "sum", "reg", "set", "cond", "match", "repl", "watch", "sim", "desc", "con", "pred", "sing", "ch", "Sub", "pre", "cmp", "sup", "is", "rc"]}}
{"project": "FFmpeg", "commit_id": "cd19c677cb5dcaecc472c021bd38370817740a5e", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, \n\n                             void *data, int *data_size,\n\n                             uint8_t *buf, int buf_size)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    MpegEncContext *s = &h->s;\n\n    AVFrame *pict = data; \n\n    int buf_index;\n\n    \n\n    s->flags= avctx->flags;\n\n    s->flags2= avctx->flags2;\n\n\n\n   /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_TRUNCATED){\n\n        int next= find_frame_end(h, buf, buf_size);\n\n        \n\n        if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )\n\n            return buf_size;\n\n//printf(\"next:%d buf_size:%d last_index:%d\\n\", next, buf_size, s->parse_context.last_index);\n\n    }\n\n\n\n    if(h->is_avc && !h->got_avcC) {\n\n        int i, cnt, nalsize;\n\n        unsigned char *p = avctx->extradata;\n\n        if(avctx->extradata_size < 7) {\n\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n\n            return -1;\n\n        }\n\n        if(*p != 1) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown avcC version %d\\n\", *p);\n\n            return -1;\n\n        }\n\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n\n           so put a fake nal_length_size = 2 while parsing them */\n\n        h->nal_length_size = 2;\n\n        // Decode sps from avcC\n\n        cnt = *(p+5) & 0x1f; // Number of sps\n\n        p += 6;\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding sps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Decode pps from avcC\n\n        cnt = *(p++); // Number of pps\n\n        for (i = 0; i < cnt; i++) {\n\n            nalsize = BE_16(p) + 2;\n\n            if(decode_nal_units(h, p, nalsize)  != nalsize) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Decoding pps %d from avcC failed\\n\", i);\n\n                return -1;\n\n            }\n\n            p += nalsize;\n\n        }        \n\n        // Now store right nal length size, that will be use to parse all other nals\n\n        h->nal_length_size = ((*(((char*)(avctx->extradata))+4))&0x03)+1;\n\n        // Do not reparse avcC\n\n        h->got_avcC = 1;\n\n    }\n\n\n\n    if(!h->is_avc && s->avctx->extradata_size && s->picture_number==0){\n\n        if(decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) < 0) \n\n            return -1;\n\n    }\n\n\n\n    buf_index=decode_nal_units(h, buf, buf_size);\n\n    if(buf_index < 0) \n\n        return -1;\n\n\n\n    //FIXME do something with unavailable reference frames    \n\n \n\n//    if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_index, buf_size);\n\n    if(!s->current_picture_ptr){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"error, NO frame\\n\");\n\n        return -1;\n\n    }\n\n\n\n    {\n\n        Picture *out = s->current_picture_ptr;\n\n#if 0 //decode order\n\n        *data_size = sizeof(AVFrame);\n\n#else\n\n        /* Sort B-frames into display order */\n\n        Picture *cur = s->current_picture_ptr;\n\n        Picture *prev = h->delayed_output_pic;\n\n        int out_idx = 0;\n\n        int pics = 0;\n\n        int out_of_order;\n\n        int cross_idr = 0;\n\n        int dropped_frame = 0;\n\n        int i;\n\n\n\n        if(h->sps.bitstream_restriction_flag\n\n           && s->avctx->has_b_frames < h->sps.num_reorder_frames){\n\n            s->avctx->has_b_frames = h->sps.num_reorder_frames;\n\n            s->low_delay = 0;\n\n        }\n\n\n\n        while(h->delayed_pic[pics]) pics++;\n\n        h->delayed_pic[pics++] = cur;\n\n        if(cur->reference == 0)\n\n            cur->reference = 1;\n\n\n\n        for(i=0; h->delayed_pic[i]; i++)\n\n            if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)\n\n                cross_idr = 1;\n\n\n\n        out = h->delayed_pic[0];\n\n        for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)\n\n            if(h->delayed_pic[i]->poc < out->poc){\n\n                out = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        out_of_order = !cross_idr && prev && out->poc < prev->poc;\n\n        if(prev && pics <= s->avctx->has_b_frames)\n\n            out = prev;\n\n        else if((out_of_order && pics-1 == s->avctx->has_b_frames)\n\n           || (s->low_delay && \n\n            ((!cross_idr && prev && out->poc > prev->poc + 2)\n\n             || cur->pict_type == B_TYPE)))\n\n        {\n\n            s->low_delay = 0;\n\n            s->avctx->has_b_frames++;\n\n            out = prev;\n\n        }\n\n        else if(out_of_order)\n\n            out = prev;\n\n\n\n        if(out_of_order || pics > s->avctx->has_b_frames){\n\n            dropped_frame = (out != h->delayed_pic[out_idx]);\n\n            for(i=out_idx; h->delayed_pic[i]; i++)\n\n                h->delayed_pic[i] = h->delayed_pic[i+1];\n\n        }\n\n\n\n        if(prev == out && !dropped_frame)\n\n            *data_size = 0;\n\n        else\n\n            *data_size = sizeof(AVFrame);\n\n        if(prev && prev != out && prev->reference == 1)\n\n            prev->reference = 0;\n\n        h->delayed_output_pic = out;\n\n#endif\n\n\n\n        *pict= *(AVFrame*)out;\n\n    }\n\n\n\n    assert(pict->data[0]);\n\n    ff_print_debug_info(s, pict);\n\n//printf(\"out %d\\n\", (int)pict->data[0]);\n\n#if 0 //?\n\n\n\n    /* Return the Picture timestamp as the frame number */\n\n    /* we substract 1 because it is added on utils.c    */\n\n    avctx->frame_number = s->picture_number - 1;\n\n#endif\n\n    return get_consumed_bytes(s, buf_index, buf_size);\n\n}\n", "idx": 24018, "substitutes": {"avctx": ["afreq", "ajcontext", " avconn", "aftx", "abctx", "avconf", "avcmp", "iverpkg", "afpkg", "aftmp", " avconfig", "avekt", "avcpp", "afcc", "avectx", "aveconf", "avcontext", "ravcpp", "ajcmp", "ajcpp", "iverctx", " avtx", "cvctx", "cvpkg", "afcpp", "avtx", "averpkg", "averreq", "afcomp", "ajcm", "averctl", "abconfig", "avtmp", "abcontext", "ajctx", "avcm", "ajtmp", "iverctl", "abcmp", "AVjp", "afctx", "iverkt", "avjac", "ravctx", "averjac", "avepkg", " avconf", "avjp", "avectl", "avstack", " avpkg", "afcmp", "afcmd", "AVctl", " avcontext", "afcu", "avereq", "averctx", "abtx", "avkt", "ravcu", "avconn", "averstack", "ajcomp", "avercc", "averconn", "avreq", "afstack", "aveconn", "avejp", "iverstack", "ajreq", "avcomp", " avctl", "avecomp", "ajcmd", "ajconfig", " avcm", "avercontext", "avconfig", "cvkb", "avekb", "iverjp", " avkb", "avecontext", "avcu", "afjac", "cvcontext", "avecmp", "iverjac", "ajtx", "avpkg", "avecc", "avkb", "avcc", "AVctx", "avecm", "ravcmd", "avctl", "ajconf", "avcmd", "AVkt", "abtmp", "ajcu"], "data": ["m", "json", "dat", "one", "image", "bin", "d", "rew", "def", "to", "value", "bytes", "feed", "text", "Data", "r", "raw", "empty", "in", "t", "map", "na", "frame", "buffer", "first", "device", "read", "next", "window", "a", "obj", "DATA", "record", "str", "ata", "rel", "block", "f", "table"], "data_size": ["data2len", "data2length", "data_len", "data2offset", "data_length", "data_offset", " data_offset", " data_length", "data2size", " data_len"], "buf": ["ctx", "pkg", "ff", "uf", "np", "bar", "seq", "tr", "bc", "box", "tmp", "xff", "wb", "br", "Buffer", "bytes", "b", "doc", "buff", "cmd", "img", "db", "bl", "rb", "buffer", "ref", "pb", "vec", "Buff", "cv", "window", "mem", "arr", "queue", "fb", "err", "alloc", "cap", "cb", "v"], "buf_size": ["buf2size", "bufableize", " buf_Size", "buf64state", "buffer_index", "buffer_state", " buf_len", "bufablen", "queue2SIZE", "buf_count", "buf64index", "queue2size", "buf_len", "buf2Size", "buf2ize", "buf2n", "queue2n", "buf64size", "queue2ize", "buf2index", "buf64SIZE", " buf_count", "buf_SIZE", "buf_Size", "queue_size", "buf_ize", "buffer_SIZE", "bufableSIZE", "buf_n", "bufablesize", "queue_n", "queue_SIZE", "queue_ize", "buffer_size", "buffer_ize", "buf2SIZE", "buf_state"], "h": ["ctx", "high", "hi", "m", "hr", "kh", "q", "hz", "here", "oh", "ih", "w", "cache", "ah", "ph", "y", "hm", "l", "self", "ht", "hd", "b", "rh", "dh", "c", "sh", "history", "he", "eh", "html", "host", "t", "bh", "H", "g", "hp", "her", "subject", "hash", "hs", "hh", "hl", "his", "ch", "http", "x", "hw", "th", "f", "v"], "s": ["ctx", "js", "gs", "m", "spec", "ssl", "sections", "so", "ls", "sq", "sp", "sl", "rs", "bs", "es", "conf", "w", "d", "sb", "vs", "sports", "n", "ps", "cc", "fs", "ds", "self", "b", "c", "cs", "sh", "settings", "cpp", "sw", "ts", "mods", "ss", "utils", "stats", "t", "g", "ns", "session", "a", "hs", "sam", "sts", "sv", "qs", "http", "sys", "sg", "ats", "se", "os", "S", "sf", "caps", "is", "v"], "pict": [" fa", "ff", "q", " f", "fw", "req", "fl", "fr", "fd", "Frame", "fn", "fc", "raw", "buff", "vp", "ef", "ft", " frame", "fi", "foo", "rf", "ref", " fr", "frames", "F", " fn", "fb", "f", "cv", "fx"], "buf_index": ["bufrowaddress", "uf_address", "uf_position", "uf__position", "uf__index", "uf_window", "buf__index", "buf_window", "bufrowindex", "buf_position", "buf__address", "buf__window", "bufstrindex", "uf__address", "bufstraddress", "bufstrposition", "uf__window", "buf__position", "uf_index", "bufrowposition", "bufrowwindow", "bufstrwindow", "buf_address"], "i": ["iy", "hi", "m", "me", "this", "MI", "ci", "ix", "us", "id", "si", "zi", "multi", "by", "port", "n", "ei", "y", "it", "xi", "init", "ij", "status", "ims", "ti", "mi", "er", "qi", "iu", "c", "info", "iii", "PI", "j", "iter", "di", "in", "point", "\u0438", "ai", "ki", "ie", " I", "ui", "phi", "ic", "li", "gi", "ip", "cli", "iq", "sim", "ri", "ji", "ini", "bi", "ind", "oi", "index", "ii", "x", "pi", "eu", "I", "ami", "io", "is", "im"], "cnt": ["mcnz", "mcNT", "ncnt", "Cnz", "Ccount", "crNT", " cant", "lcount", "ecnt", "cant", " cnz", "ncount", "mcnt", "ecct", "lcant", " ccount", "cust", "Count", "ecount", " cct", "crnt", "cNT", " cNT", "crount", "CNT", "crnz", "lcnt", "ncNT", "ncant", " cust", "count", "ccount", "Cust", "mcust", "Cct", "Cnt", "lcNT", " count", "eccount", "cnz", "cct", "Cant"], "nalsize": ["nselsize", "nsalsizer", "nsalize", "nalesiz", "nalsIZE", "nallsize", "naldize", "nelsiz", "calsization", "calsiz", "nALSource", "talesIZE", "celsize", "naldource", " nalsizes", "nALSiz", "talsized", "nalsizes", "naledizes", "nalesource", "nalesized", "nalesIZE", "talesiz", "nALSized", "calesize", "nalize", "nsalized", "nelsizer", "celsization", "celsizer", "naldiz", "naledized", "talsiz", "calesizer", "nalfizer", "nsalesize", "nalized", "nselsizer", " naledize", "nalfize", "nalledizer", "talesized", "naledization", "nsalfizer", "nsalesiz", "calesization", "nalizer", "nsalization", "nalfiz", "nsalsource", "talsIZE", "nalfized", "nelsization", "nsalsized", " naledizes", "nalfization", "nelsized", " naledizer", "nalesization", " nalsizer", "nalledize", "nallsIZE", "nalesizer", "nsalesizer", "celsized", "nalfource", "nALSizer", "nalledizes", "nsalfiz", "nalledization", "calsized", "calsize", "nalsiz", "talesize", "nsalsization", "nelsize", " nalsization", "nsalfource", "nalesize", "naledize", "naldizer", "nsalizer", "nALSize", "talsize", "nalsizer", "nselsiz", "nalource", "nalsized", "nsalsiz", "calesiz", "calsizer", "nalfizes", "nalsization", "nsalesource", "nalization", "nsalfize", "nalediz", "nselsized", " naledization", "nALSIZE", "nalsource", "nALSization", "nsalsize", "naledizer", "nallsiz", "nallsized", "naliz"], "p": ["cp", "pid", "pkg", "m", "perm", "xp", "tp", "post", "q", "np", "pp", "o", "par", "sp", "at", "pr", "pad", "jp", "port", "pe", "d", "padding", "up", "bp", "cache", "ps", "n", "y", "it", "pl", "P", "b", "rep", "wp", "c", "vp", "pat", "j", "point", "pt", "pos", "g", "pro", "pc", "pa", "pn", "ip", "pb", "dp", "ap", "ping", "pod", "a", "pre", "op", "lp", "pi", "part", "pg", "fp", "progress", "pers"]}}
{"project": "qemu", "commit_id": "2cd53943115be5118b5b2d4b80ee0a39c94c4f73", "target": 0, "func": "static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu_tb_jmp_cache_clear(cpu);\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n", "idx": 24044, "substitutes": {"cpu": ["pkg", "np", "pp", "memory", "kt", "copy", "aq", "sc", "conn", "coin", "chip", "cum", "uu", "cs", "mac", "lib", "apache", "pt", "stats", "phys", "home", "pc", "software", "none", "upt", "resource", "hw", "docker", "cv", "ctx", "cp", "gc", "tp", "hz", "jp", "CPU", "util", "execute", "cache", "vm", "component", "prefix", "core", "config", "nic", "pie", "net", "loop", "efficiency", "cat", "cu", "gp", "kernel", "clock", "num", "program", "profile", "linux", "module", "nc", "proc", "thread", "aux", "aco", "node", "ck", "window", "comp", "sys", "alloc", "pu", "stat", "pool", "ctl", "physical", "current", "ilo", "library", "que", "c", "gpu", "processor", "computer", "performance", "cmd", "utils", "prof", "cli", "process", "all", "mem", "runner", "boot"], "cc": ["ac", "cp", "ctx", "gc", "acc", "ci", "CC", "oc", "ca", "isc", "soc", "xx", "bc", "BC", "tc", "AC", "icc", "nc", "cm", "mc", "cz", "zz", "cl", "cs", "fc", "lc", "CCC", "ec", "uc", "cci", "pc", "ck", "cca", "cf", "cy", "cb", "cell", "ctl", "ct"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 24047, "substitutes": {"list": ["data", "parent", "file", "state", "seq", "tree", "lists", "test", "l", "result", "chain", "info", "List", "lock", "top", "listed", "stack", "LIST", "order", "print", "t", "map", "loop", "shape", "set", "li", "collection", "ul", "out", "lat", "level", "all", "base", "source", "queue", "batch", "sequence", "array", "block", "table", "v"], "func": ["action", "ctx", "inner", "callback", "impl", "bc", "conf", "bin", "nc", "orig", "cc", "FC", "cover", "fun", "closure", "b", "apply", "proc", "c", "fn", "fc", " function", "wrapper", "kw", "function", "go", "act", "loop", "fac", "unc", "con", "work", "now", "sec", "conv", "bf", "cf", " fn", "f", "cb"], "opaque": ["opaques", "paques", "opacity", "ipaques", "obaco", " opaco", "opaco", "opque", " opacity", "obaque", "ipacity", "ipque", "paque", "obque", " opque", "ipaco", "pacity", "obaques", "ipaque", " opaques"], "abort_on_failure": ["abort_on_successures", "abort_on_failederror", "abort_on_passURE", "abort_on_failURE", "abort_on_failures", "abort_on_failedure", "abort_on_passure", "abort_on_failedURE", "abort_on_successerror", "abort_on_successURE", "abort_on_writeerror", "abort_on_failedures", "abort_on_passures", "abort_on_failerror", "abort_on_successure", "abort_on_writeURE", "abort_on_writeure", "abort_on_writeures"], "opts": ["opls", "prets", " opTS", "prels", "optTS", "attls", "optcs", "OPcs", "OPts", "attts", "atttions", " options", " opcs", "iopls", "iopcs", "optts", "opfs", " ops", "optls", "opTS", "OPfs", "OPTS", "OPs", "iopts", "ioptions", "attcs", "optfs", "options", "prefs", "OPls", "opcs", " opls", "pres", "ops"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void subpage_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned len)\n\n{\n\n    subpage_t *mmio = opaque;\n\n    unsigned int idx = SUBPAGE_IDX(addr);\n\n    MemoryRegionSection *section;\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: subpage %p len %d addr \" TARGET_FMT_plx\n\n           \" idx %d value %\"PRIx64\"\\n\",\n\n           __func__, mmio, len, addr, idx, value);\n\n#endif\n\n\n\n    section = &phys_sections[mmio->sub_section[idx]];\n\n    addr += mmio->base;\n\n    addr -= section->offset_within_address_space;\n\n    addr += section->offset_within_region;\n\n    io_mem_write(section->mr, addr, value, len);\n\n}\n", "idx": 24050, "substitutes": {"opaque": ["Opaque", "operlay", "opacity", "ogque", "plque", "opslay", "placity", "operque", "opute", "opque", "opsque", "Opient", "oplay", "ogaque", "Opque", "ogacity", "Opacity", "operaque", " oplay", " opque", " opute", "plient", "opsute", "operute", "opsaque", "opient", "plaque", "ogient"], "addr": ["ac", "ctx", "ix", "end", "add", "Address", "adr", "grad", "rs", "arp", "at", "id", "pad", "adj", "help", "loc", "ag", "store", "ptr", "url", "src", " address", "offset", "dest", "inter", "attr", "dh", "address", "sha", "r", "tx", "ord", "iter", "cmd", "dr", "point", "pos", "res", "phys", "db", "et", "ref", "asm", "align", "ap", "ip", "coord", "work", "eth", "now", "hl", "off", "ress", "mem", "a", "au", "arr", "index", "x", "alloc", "ad", "seek", "ack"], "value": ["tv", "vector", "Value", "json", "vt", "data", " Value", "wise", "name", "type", "length", "bin", "w", "padding", "unit", "ay", "field", " address", "test", "ue", "we", "values", "address", "r", "VAL", "function", " arg", "func", "cas", "format", "size", "set", "buffer", "key", "total", "VALUE", " weight", " parameter", "code", "byte", "mem", " val", "index", "fee", "v", "val"], "len": ["lf", "ls", "end", " length", "z", "seq", "L", "length", "loc", "ln", "ld", "n", "offset", "lon", "Len", "l", "ly", "fin", "ret", "limit", "nl", "lock", "lib", "lan", "lit", "enc", "pos", "size", "lis", "en", "vec", "align", "ll", "hl", "last", "mem", "h", "lp", "lang", "fee", "elt", "cmp", "label", "kl", "Length", "val"], "mmio": ["miu", "mmmiu", " mmisco", "miot", "mxogo", "mbios", "mxios", "mmia", "mmIO", "mbia", "mxait", "mliu", "mmios", "dmio", "mmmiot", "mbIO", "mxio", "mmmogo", "dmait", "mlio", " mmios", "dmios", "mmmio", "mmait", "mmmait", "mio", "mmiot", "mmogo", " mmia", "mmmia", "MMios", "mliot", "mmmios", "mbio", "MMIO", "mmiu", "mmisco", "MMio", "mios", "mlios", "mmmisco", "dmogo", "mbisco", " mmIO"], "section": ["relation", "sections", "description", "data", "parent", "ment", "rup", "state", "mod", "entry", "setting", "slot", "division", "tag", "journal", "service", "ion", "definition", "test", "status", "region", "ser", "prefix", "access", "feature", "tab", "address", "lc", "header", "config", "function", "version", "format", "shadow", "size", "set", "sect", "area", "usage", "key", " Section", "position", "see", "second", "member", "session", "comment", "ECTION", "group", "sec", "sector", "null", "context", "option", "portion", "index", "se", "connection", "Section", "part", "dimension", "block", "tower"]}}
{"project": "FFmpeg", "commit_id": "48e52e4edd12adbc36eee0eebe1b97ffe0255be3", "target": 0, "func": "static int nvenc_find_free_reg_resource(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;\n\n    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;\n\n\n\n    int i;\n\n\n\n    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {\n\n        for (i = 0; i < ctx->nb_registered_frames; i++) {\n\n            if (!ctx->registered_frames[i].mapped) {\n\n                if (ctx->registered_frames[i].regptr) {\n\n                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,\n\n                                                ctx->registered_frames[i].regptr);\n\n                    ctx->registered_frames[i].regptr = NULL;\n\n                }\n\n                return i;\n\n            }\n\n        }\n\n    } else {\n\n        return ctx->nb_registered_frames++;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR, \"Too many registered CUDA frames\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 24072, "substitutes": {"avctx": [" avconn", "vrctx", "abctx", " avcontext", "avcmp", "vrcmp", "vcctx", "avconn", "vcconn", "AVtx", "avecontext", "vrcontext", "avwork", "abcontext", "AVcmp", "AVconn", "avecmp", "avework", "vctx", "avectx", "abcmp", " avcmp", "avcontext", "vccontext", "AVctx", "vrtx", "abwork", " avtx", " avwork", "avtx", "AVcontext"], "ctx": ["pkg", "xp", "check", "inst", "np", "conf", "kt", "tmp", "tc", "iat", "conn", "sc", "info", "acl", "nt", "org", "work", "wcs", "crit", "hw", "wx", "cb", "cv", "cp", "gc", "command", "qt", "jp", "ctrl", "cc", "tm", "co", "prefix", "today", "config", "setup", "desc", "conv", "github", "kl", "rc", "td", "req", "loc", "xc", "ka", "that", "nc", "cm", "history", "wp", "proc", "kw", "lc", "act", "timeout", "jac", "msg", "txt", "ck", "window", "obj", "abc", "comp", "exec", "ctl", "comm", "ct", "cfg", "p", "bc", "expr", "c", "fc", "tx", "cmd", "t", "context", "xs", "cf", "ia", "cmp", "pg"], "dl_fn": ["dl___fn", "dl_cb", "dlockfm", "pkgockfn", "dl1ln", "sel___compl", "pkgockln", "dl1fm", "sel___cb", "dlockfun", "sel_obj", "dl_ln", "pkg_fn", "dlockfn", "dlockln", "pkg_fm", "sel___obj", "pkg_ln", "dl_fun", "dl1fun", "pkg_fun", "sel_compl", "dl_obj", "sel_fn", "dl___obj", "dl1fn", "dl___compl", "pkgockfm", "dl_compl", "sel_cb", "dl_fm", "dl___cb", "pkgockfun", "sel___fn"], "p_nvenc": ["p_NrenC", "p_navenl", "p_noreng", "p_korenl", "p_naveng", "p_nrenC", "p_Nrenc", "p_nrenac", "p_nvenec", "p_Nvenac", "p_kvenl", "p_nvenac", "p_korenc", "p_navencon", "p_Nrenac", "p_nveng", "p_ngenc", "p_nigenac", "p_Nvenec", "p_norenl", "p_norencon", "p_kveng", "p_nigenec", "p_nvencon", "p_nvenl", "p_koreng", "p_kvenc", "p_nrenc", "p_nigenc", "p_Nvenc", "p_ngenec", "p_Nrenec", "p_ngenC", "p_nigenC", "p_nvinl", "p_nrenec", "p_ngenac", "p_nving", "p_NvenC", "p_norenc", "p_navenc", "p_nvenC", "p_korencon", "p_nvincon", "p_nvinc", "p_kvencon"], "i": ["rest", "gl", " li", "multi", "user", " mi", "ei", "ims", "chain", "mi", "info", " wi", "\u0438", "uri", "phi", "series", "ip", "iq", "ri", "ini", "ind", "x", "ii", "pi", "io", "f", "ki", "im", " pi", "try", "z", " bi", "zi", "request", "it", "b", "qi", "iu", "di", "in", "print", "remote", "k", "u", " I", "slice", "is", "menu", "m", "me", "si", "to", "xi", "init", "history", " ki", "point", "ai", "fi", "ui", "li", " multi", " m", " ti", "ci", "ix", "p", " index", "id", "mount", "y", "ij", "ti", "c", "j", "t", " ii", "gi", "ic", "key", "wait", "cli", "sim", "ji", "bi", "e", "oi", "index", "eu", "I"], "nb_registered_frames": ["nb_registered2frames", "nb_recorded_features", "nb_registeredptbytes", "nb_registered_features", "nb_registered_files", "nb_registered__frames", "nb_registered_bytes", "nb_recorded_objects", "nb_registeredptframes", "nb_recorded_faces", "nb_registered2features", "nb_recorded_frames", "nb_registered_events", "nb_registered2objects", "nb_recorded_files", "nb_registeredptevents", "nb_registered__events", "nb_registered_faces", "nb_registeredfframe", "nb_registered2frame", "nb_registeredptframe", "nb_recorded_frame", "nb_recorded_bytes", "nb_registeredffeatures", "nb_registered__frame", "nb_registered_objects", "nb_registeredfframes", "nb_registered_frame", "nb_registered__bytes", "nb_registeredfobjects", "nb_recorded_events"]}}
{"project": "qemu", "commit_id": "f3ced3c59287dabc253f83f0c70aa4934470c15e", "target": 1, "func": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n", "idx": 24075, "substitutes": {"cpu": ["ctx", "cp", "ola", "gc", "tp", " CPU", "p", "np", "linux", "jp", "CPU", "machine", "mu", "execute", "cache", "conn", "percent", "vm", "self", "cum", "proc", "c", "core", "gpu", "thread", "aco", "processor", "nic", "bench", "t", "phys", "pc", "target", "cli", "device", "process", "cu", "mem", "kernel", "sys", "runner", "hw", "clock", "pai", "pu", "pool"], "addr": ["ctx", "m", "ix", "arp", "add", "Address", "adr", "sp", "rs", "at", "id", "pad", "loc", "ptr", "to", "src", " address", "y", "offset", "inter", "attr", "dh", "address", "r", "tx", "ord", "cmd", "dr", "act", "pos", "ar", "res", "target", "ip", "ref", "adj", "align", "link", "hash", "coord", "off", "a", "eth", "now", "sha", "mem", "index", "x", "rc", "hw", "ad", "rel", "mt", "v"], "i": ["iy", "m", " l", "list", "ci", "ix", "uri", "z", " index", "id", "si", " bi", "multi", "zi", "ei", "abi", "y", "it", "xi", "init", "ij", "ti", "mi", "qi", "info", "iu", "c", " wi", "di", "in", "\u0438", "ai", "t", "print", " I", " ii", "gi", "phi", "ic", "li", " p", "ui", "fi", "ip", "cli", "ri", " err", "ini", " m", "bi", " c", "index", "ii", "x", "oi", "pi", "str", "I", "ami", "f", "is", "v", " pi"]}}
{"project": "qemu", "commit_id": "fa879d62eb51253d00b6920ce1d1d9d261370a49", "target": 0, "func": "DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n", "idx": 24084, "substitutes": {"bs": ["gs", "ls", "bb", "bing", "bits", "bc", "bes", "sb", "vs", "bp", "bis", "ps", "fs", "acs", "blocks", "has", "ds", "b", "ms", "cs", "bm", "iss", "ts", "ses", "ss", "aos", "bles", "bh", "bl", "BS", "ubs", "ns", "pb", "its", " BS", "ks", "bps", "bi", "obs", "qs", "bos", "lbs", "als", "bd", "is", "bn"]}}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 24085, "substitutes": {"qov": ["Qov", "quove", "qtvo", "Qav", "Qove", "quov", "qqerv", " qav", " qove", "qqov", " qnov", "qhov", " qerv", " qhov", "qnov", "qqhov", "qterv", " qvo", "qerv", "qunov", "qqvo", "qtov", "quav", "Qnov", "qthov", "qav", "qove", "qvo"], "value": ["any", "current", "always", "Value", "json", "property", "p", "data", "parent", "entry", "name", "type", "memory", "w", "field", "widget", "tree", "content", "expression", "ue", "holder", "result", "values", "hello", "true", "address", "r", "raw", "item", "function", "node", "message", "buffer", "element", "key", "variable", "create", "select", "VALUE", "instance", "now", "null", "none", "source", "record", "package", "attribute", "index", "new", "python", "sequence", "block", "v", "val"], "e": ["m", "me", "eg", "ep", "te", "p", "es", "o", "eb", "ev", "entry", "eeee", "pe", "ei", "n", "eps", "oe", "ea", "ue", "er", "ae", "xe", "c", "ec", "node", "i", "ef", "t", "ce", "ie", "g", "E", "en", "ed", "est", "ek", "element", "et", "ate", "ge", "ze", "entity", "a", "el", "ent", "h", "ee", "se", "eu", "ele", "ne", "le", "ome"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)\n\n{\n\n    void *p;\n\n\n\n    size *= items;\n\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n\n\n    p = qemu_mallocz(size);\n\n\n\n    return (p);\n\n}\n", "idx": 24087, "substitutes": {"x": ["ctx", "xp", "m", "ix", "z", "xx", "w", "xc", "y", "xi", " xp", "xe", "xt", "lex", "xa", "tx", "xml", "message", "ux", "xf", "X", "e", "xy", "xs", "px", "v"], "items": ["pins", "ips", "orders", "workers", "z", "bits", "points", "objects", "ids", "links", "bytes", "types", "blocks", "jobs", "values", "files", "users", "groups", "Items", "item", "units", "keys", "faces", "lines", "results", "rows", "args", "members", "names", "actions", "levels", "xs", "vals", "pages", "codes"], "size": ["m", "height", "start", "parent", "data", "body", "z", "name", "type", "SIZE", "si", "length", "small", "sy", "to", "scale", "Size", "n", "offset", "l", "capacity", "style", "max", "s", "c", "address", "score", "storage", "scope", "item", "empty", "i", "order", "sum", "shape", "city", "set", "message", "area", "g", "position", "total", "count", "window", "len", "number", "now", "options", "grow", "mem", "index", "ize", "pi", "weight", "dimension", "fee", "space", "zone", "v"], "p": ["cp", "pid", "m", "q", "np", "pp", "sp", "par", "pr", "jp", "port", "per", "ptr", "ps", "n", "pl", "P", "b", "rep", "c", "r", "vp", "j", "i", "pt", "pointer", "t", "g", "u", "pc", "pa", "ip", "pb", "ap", "ping", "php", "a", "lp", "pi", "fp", "f", "v"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n\n                         VncPalette *palette)\n\n{\n\n    png_byte color_type;\n\n    png_structp png_ptr;\n\n    png_infop info_ptr;\n\n    png_colorp png_palette = NULL;\n\n    pixman_image_t *linebuf;\n\n    int level = tight_png_conf[vs->tight.compression].png_zlib_level;\n\n    int filters = tight_png_conf[vs->tight.compression].png_filters;\n\n    uint8_t *buf;\n\n    int dy;\n\n\n\n    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,\n\n                                        NULL, vnc_png_malloc, vnc_png_free);\n\n\n\n    if (png_ptr == NULL)\n\n        return -1;\n\n\n\n    info_ptr = png_create_info_struct(png_ptr);\n\n\n\n    if (info_ptr == NULL) {\n\n        png_destroy_write_struct(&png_ptr, NULL);\n\n        return -1;\n\n    }\n\n\n\n    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);\n\n    png_set_compression_level(png_ptr, level);\n\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);\n\n\n\n    if (palette) {\n\n        color_type = PNG_COLOR_TYPE_PALETTE;\n\n    } else {\n\n        color_type = PNG_COLOR_TYPE_RGB;\n\n    }\n\n\n\n    png_set_IHDR(png_ptr, info_ptr, w, h,\n\n                 8, color_type, PNG_INTERLACE_NONE,\n\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        struct palette_cb_priv priv;\n\n\n\n        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n", "idx": 24090, "substitutes": {"vs": ["js", "gs", "roots", "ls", "vt", "tops", "bs", "rs", "posts", "params", "nets", "otes", "docs", "blogs", "ups", "lists", "ps", "pps", "gets", "eps", "fs", "ds", "ms", "values", "cs", "Vs", "VS", "ts", "vp", "iss", "ses", "stats", "atts", "env", "vr", "ns", "ins", "vis", "changes", "boxes", "ks", "wcs", "hs", "obs", "ports", "sts", "sv", "court", "xs", "qs", "sys", "fps", "vals", "ops", "caps", "pers", "v"], "x": ["m", "ox", "rx", "ix", "p", "ax", "dx", "n", "on", "l", "c", "r", "tx", "i", "t", "X", "xy", "xs", "wx", "px", "ex", " cx", "v"], "y": ["iy", "ery", "yl", "oy", "p", "my", "ym", "yp", "py", "b", "ny", "ry", "Y", "yt", "ys", "yd", "yy", "axy", "iny", "hy", "ch", "xy", "cy", "sy", "gy"], "w": ["wh", "nw", "m", "p", "z", "iw", "fw", "d", "wb", "n", "wa", "rw", "wid", "ww", "l", "W", "win", "wt", "r", "ow", "wd", "sw", "i", "wr", "t", "en", "wi", "ew", "hw", " W", "wx", "ex", "f", "v"], "h": ["hi", "wh", "m", "height", "hr", "high", "q", "p", "o", "z", "oh", "ih", "d", "n", "ph", "l", "ht", "b", "c", "hei", "he", "r", "i", "t", "bh", "size", "H", "g", "head", "hh", "hl", "ch", "v"], "palette": ["alet", "Pallette", "whette", "filte", "allete", "palettes", " pallete", "promte", "holette", "alettes", "pallette", "pallete", "stalte", " palte", "hollete", "filette", "Palene", "promette", "stalene", "Palte", "Pallete", "promlette", "palet", " pallette", "hollette", "whlete", "palene", "allette", "stallette", "palte", "Palette", "whettes", "filene", "fillette", "Palettes", " palet", "holet", "promlete", "whlette", "alette", "alte", "stalette"], "color_type": ["color_TYPE", "colorETYPE", " color_pe", "colortypetype", "colorLEnum", "coloritymethod", " color_method", " color_file", "coloritytype", " color_format", " color_color", "colorityTYPE", "color_pe", "color_color", " color_no", " color_TYPE", "color_no", "color_set", "colorEfile", " color_num", "color_method", "colorLETYPE", " color_model", "colorLEtype", "colorLEno", "color_num", "colortypeTYPE", "colortypeformat", "colortypecolor", "color_file", "color_model", "colorEmethod", "colorityfile", "color_format", " color_set", "colorEtype"], "png_ptr": ["ng_ptr", "draw_ptr", "png_tr", "png_pdf", "png_pointer", "img_ptr", "png__rect", "png_handle", "native_Ptr", "png__obj", "img_pointer", "phot_dep", "png__pt", "png_addr", "png___cur", "png___ptr", "png_Ptr", "psyTYpointer", "pngacpointer", "native_cmd", "ng_pointers", "png___cert", "pngxrep", "pngxpointers", "png___ret", "pngacPtr", "png_ret", "ng__rect", "ng__pointer", "ping_ptr", "pn_ret", "native_handle", "pngEdep", "ng_tp", "psyTYcur", "png_dep", "ping_Ptr", "native_ptr", "psy_cur", "pngacpointers", "pngacptr", "psy_cert", "png_tp", "pngTYptr", "png_data", "pngTYcert", "pngTYpointer", "png__ptr", "png_cmd", "png__tr", "draw_pointer", "pn_pointer", "pngEpointer", "pngacdata", "pngTYcur", "pngxPtr", "png_rep", "pngactp", "png_obj", "pngxpointer", "draw_pt", "png___pointer", "png_cert", "ng__ptr", "png_pt", "ng_rect", "pngEpdf", "img_addr", "ng_Ptr", "ngacpointers", "ngacPtr", "img_pointers", "pngxpt", "png_pointers", "png___rep", "ng__obj", "phot_ptr", "ng_obj", "png__pointer", "pngxtp", "psy_ptr", "pngxptr", "png_rect", "psyTYptr", "psy_pointer", "ngactp", "phot_pointer", "ping_pointer", "phot_pdf", "ng_tr", "pngEptr", "png__rep", "pn_rep", "draw_rep", "ngacptr", "psyTYcert", "png_cur", "ping_data", "ng_pointer", "pn_ptr"], "info_ptr": [" info_pointer", "info____ptr", " info_pt", "info____Ptr", "info__ptr", "infopttile", "info_Ptr", "info____rel", "notice_tile", "info__pt", "info_addr", " info_rel", "notice_loc", "info_tr", "infoptptr", "info_loc", "info_pointers", "info_pointer", "info_rel", "info_tile", " info_obj", "infoptaddr", "notice_addr", "info_obj", " info_tr", "info__pointer", "infoptloc", "notice_ptr", "info__Ptr", "info_pt", "info__rel", "info____pt", " info_Ptr", "info__pointers", " info_pointers"], "linebuf": ["pagebuffer", "pagedata", "linebuff", " linebuff", "linkdata", "linedata", "linkbuffer", "linebuffer", "pagebuff", " linebuffer", " linedata", "linkbuff", "linkbuf", "pagebuf"], "buf": ["pkg", "uf", "v", "bc", "tmp", "wb", "Buffer", "lim", "b", "doc", "buff", "cmd", "img", "map", "buffer", "msg", "txt", "ref", "vec", "cur", "out", "mem", "conv", "queue", "alloc", "cap", "cb", "cv"], "dy": ["iy", "Height", "height", "dir", "done", "diff", " height", "dx", "foot", "d", "low", "j", "di", "deg", "tie", "ded", "yy", "foo", " d", "len", "ch", "xy", "ii", "err", "dim", "draw"], "priv": ["pkg", "dev", "cp", "ep", "pub", "cert", "sp", "soc", " Priv", "pr", "Pr", "req", "or", "deb", "Pri", " pri", "def", "conn", "prop", "expr", "rep", "proc", "Priv", "admin", "serv", "org", "pty", "auth", "pro", "env", "riv", "rev", "pri", "resp", " privilege", "sec", "rib", "trust", "usr", "policy", "pal", "private", "err", "alloc", "ilege", "rel", "rc", "prov"]}}
