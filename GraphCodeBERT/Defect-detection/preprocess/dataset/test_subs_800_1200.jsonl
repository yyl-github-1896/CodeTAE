{"project": "FFmpeg", "commit_id": "08a747afb98c11da48b89339c2f1c5fdc56ced7e", "target": 0, "func": "static void count_frame_bits_fixed(AC3EncodeContext *s)\n\n{\n\n    static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };\n\n    int blk;\n\n    int frame_bits;\n\n\n\n    /* assumptions:\n\n     *   no dynamic range codes\n\n     *   bit allocation parameters do not change between blocks\n\n     *   no delta bit allocation\n\n     *   no skipped data\n\n     *   no auxilliary data\n\n     *   no E-AC-3 metadata\n\n     */\n\n\n\n    /* header */\n\n    frame_bits = 16; /* sync info */\n\n    if (s->eac3) {\n\n        /* bitstream info header */\n\n        frame_bits += 35;\n\n        frame_bits += 1 + 1 + 1;\n\n        /* audio frame header */\n\n        frame_bits += 2;\n\n        frame_bits += 10;\n\n        /* exponent strategy */\n\n        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)\n\n            frame_bits += 2 * s->fbw_channels + s->lfe_on;\n\n        /* converter exponent strategy */\n\n        frame_bits += s->fbw_channels * 5;\n\n        /* snr offsets */\n\n        frame_bits += 10;\n\n        /* block start info */\n\n        frame_bits++;\n\n    } else {\n\n        frame_bits += 49;\n\n        frame_bits += frame_bits_inc[s->channel_mode];\n\n    }\n\n\n\n    /* audio blocks */\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        if (!s->eac3) {\n\n            /* block switch flags */\n\n            frame_bits += s->fbw_channels;\n\n\n\n            /* dither flags */\n\n            frame_bits += s->fbw_channels;\n\n        }\n\n\n\n        /* dynamic range */\n\n        frame_bits++;\n\n\n\n        /* spectral extension */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* exponent strategy */\n\n            frame_bits += 2 * s->fbw_channels;\n\n            if (s->lfe_on)\n\n                frame_bits++;\n\n\n\n            /* bit allocation params */\n\n            frame_bits++;\n\n            if (!blk)\n\n                frame_bits += 2 + 2 + 2 + 2 + 3;\n\n        }\n\n\n\n        /* converter snr offset */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* delta bit allocation */\n\n            frame_bits++;\n\n\n\n            /* skipped data */\n\n            frame_bits++;\n\n        }\n\n    }\n\n\n\n    /* auxiliary data */\n\n    frame_bits++;\n\n\n\n    /* CRC */\n\n    frame_bits += 1 + 16;\n\n\n\n    s->frame_bits_fixed = frame_bits;\n\n}\n", "idx": 8181, "substitutes": {"s": ["ms", "vs", "ats", "sg", "hs", "cs", "m", "ins", "details", "r", "http", "se", "y", "t", "sports", "os", "b", "w", "comm", "ims", "sql", "gs", "sts", "changes", "g", "sv", "args", "ses", "sam", "bs", "less", "js", "als", "ss", "ops", "e", "sb", "z", "ls", "state", "sq", "spec", "qs", "a", "rs", "as", "l", "es", "i", "ts", "n", "sw", "ns", "ds", "eps", "p", "ps", "aws", "is", "series", "S", "its", "v", "self", "c", "h", "stats", "set", "sys", "parts"], "frame_bits_inc": ["frame_bits_enc", "frame_bytes_INC", "frame_bits_ins", "frame_bit_ins", "frame_bytes_enc", "frame_bytes_inf", "frame_bit_enc", "frame_bits_INC", "frame_bits_inf", "frame_bit_inc", "frame_bytes_inc", "frame_bit_INC"], "blk": ["blkg", "lockk", " brark", "blker", "lockuk", "lockck", "bltk", "jlmk", "trker", "btk", "jlkg", "bttk", "Blks", " blark", "BLk", " bltk", "lbck", "blark", "blogker", "Blck", "btijk", "replak", "blogkr", " blko", "jluk", "Blak", "Blkid", "blkw", "replk", "arrkr", " blks", "abelk", "lbkid", "blijk", "blck", "btak", "iblck", "lbak", "BLck", "blogk", " brk", "blks", " blkid", "Blkw", "iblko", "locktk", "arrker", "BLks", "abelark", "blak", "djk", "BLkw", " brkid", "blogkg", "djkg", "belak", "trkr", "djmk", "Blk", "lockkg", "blko", " blak", "lockak", "iblk", "iblijk", "blkr", "blmk", "jlk", "abelkid", "btck", " blkw", "abelkg", "trkg", " blck", "belk", "lbk", " blijk", "belko", " blkg", "trk", "arrk", "lockmk", "replko", "blkid", "bluk", " brkg", "djuk", "arrkg", "btko"], "frame_bits": [" frame_bugs", "frame__bit", "frame___tests", " frame_tools", "frameThebits", "frameTheits", "frame_tests", "queue_its", "frame____tools", "component64its", "frame___its", "frame_abilities", "frame64jobs", "frame__its", "Frame_fits", "versionletrates", "fake_its", "frame_plugins", "frameThefixes", "versionletbits", "point_jobs", "frame_stats", "request_bits", "point_bit", "queue_vals", "frame____its", "frame__notes", "request_outs", "frame___nets", "frame64its", "queue24bits", "frame_pins", "Frame_bits", "frame00bits", "frameerits", "frame_details", "queue___nets", " frame_locks", " frame2stats", "frame_files", "request00stats", "frame2vals", "frame_values", "version_its", "frame64stats", "frame7bit", "component_its", "queue24plugins", " frame2vals", " frame_ads", "zone_weights", "frameerplugins", " frame_details", " frame_tests", "frame7values", " frame_keys", " frame_words", "frame_sets", "frame_bit", "version_rates", " frame_notes", " frame2bits", "frame67bits", "versionletits", "Frame_its", "frame___outs", "queue24files", "frame_pieces", "frame_bs", "request00bits", "frame_keys", "component_rates", "frame64notes", "component64pieces", "frameletbits", "frame____bits", "frame_notes", "frame64nets", "frameTimestats", "fake_devices", "frameTimebits", "frame_tools", "component_pieces", "queue___its", "zone_bits", "frameThreaddetails", "queue_files", "point_bits", "frameTimetools", "frame_ads", "frameThreadtags", "frame___fits", "request_stats", "queue_nets", "frame___pins", "frame7bits", " frame_stats", " frame_bs", "frame_vals", "frame_jobs", "frame2bits", " frame_tags", "frame64outs", "frame24bits", "frame_ids", "frame2its", "queue___bits", "frame64ads", "frame_locks", "frame_bis", "frame64sets", "frameletits", " frame2its", "version_bits", "frame_tags", "frame64pieces", " frame_outs", "frame___bits", "frame24plugins", "frame00outs", "frame__ads", "frame67pieces", "fake_stats", "queue_bits", "Frame_stats", " frame_its", "versionletnets", " frame_pins", " frame_values", "component64rates", "frameThelocks", "fake_bits", " frame_ids", "frame__bits", "queue_plugins", "frameTimedetails", "frame67rates", "frameThreadbits", "frameerbits", "frame_its", "component_bits", "frameThreadits", "request00sets", "frame24files", "frame00stats", "frameerbugs", "frame67its", "request00outs", "frameletrates", "frame2stats", "version_nets", "frame7nets", "frame___stats", " frame_vals", "frame_words", "frame____pins", "frame24vals", "frameletnets", "queue24vals", "frame64bit", "frame_weights", "frame64rates", "frame64vals", " frame_nets", " frame_jobs", " frame_fixes", " frame_abilities", "frame_devices", "frame_ints", "frame_fixes", "frame2devices", "frame7bis", "frame__jobs", "point_notes", "request_sets", "frame_bugs", "frame_rates", "frame7outs", " frame_bis", "frame64bits", "frame_nets", "zone_ints", "frame00sets", "zone_abilities", " frame_plugins", " frame_bit", "frame_outs", "frame_fits", "component64bits"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 8197, "substitutes": {"pix": ["cpx", "cpix", " px", "PIX", "Px", "vpx", "cpixels", "Pct", "pixel", "npixels", "vpix", " pixel", "npix", "vpIX", "cpct", "pIX", "px", " pct", "Pix", " pIX", "Pixels", "npixel", "npx", "vpixel", "cpIX", "pct", "pixels", "npIX", " pixels"], "stride": [" strride", "glride", "strime", "stime", "divime", "glope", "divend", "stend", "strine", " strider", "glade", " strine", "scheider", "Strider", "strride", "divine", "strade", " strend", "strider", " strope", "strope", "strite", "strend", " strade", "stine", "Stride", "glide", "stade", "scheite", "Strade", " strime", "stope", " strite", "divide", "stide", "scheide", "Strite", "scheade"], "bS": ["ibSeries", " bA", "sbV", "bVS", "nbVS", "bA", "cbS", "nbJS", "bNS", "bbP", "bbFS", "bbR", " bFS", "bgVS", "nbS", "baNS", "baN", "bSS", " bUS", "fbUS", " bINS", "bV", "ibP", " bJS", "bgR", "cbSS", "bFS", "baS", "bbS", "bbSS", "ibUS", "sbBS", " bSS", "sbS", " bN", "bbA", "nbFS", "sbA", "bN", "fbS", "bbJS", " bVS", "bbNS", "bR", "bP", "bbBS", "nbINS", "bbN", "bUS", " bSeries", "bgINS", "ibS", " bR", " bBS", "bBS", "baJS", " bV", "cbP", "fbP", "bbV", "bSeries", "bgS", " bNS", "bINS", "fbSeries", "nbR", " bP", "bJS"], "qp": ["qup", " qpa", " qpad", "qpad", "iqp", "qupc", "quwp", "qP", "qqP", "qupa", "Qpa", "reqpc", " qP", "reqnp", "qunp", "qpc", "qqpc", "reqwp", "Qpad", "Qp", "quP", "reqp", "iqwp", "QP", "iqnp", "qwp", "qnp", "Qpc", "qqpad", "iqpc", " qpc", "qpa", "qqp"], "h": ["hal", "he", "H", "ah", "hm", "ph", "a", "ch", "pp", "q", "k", "hs", "p", "hash", "th", "g", "m", "l", "hd", "hl", "oh", "handle", "hh", "hp", "http", "n", "t", "ctx", "v", "rh", "cache", "e", "host", "b", "c", "sh", "kh", "bh", "hw", "w", "ih", "help", "php", "it", "comm", "s", "dh", "history", "hz", "ht"], "tc": ["td", "oc", "tf", "tt", "aco", "tx", "pc", "cus", "ctrl", "tic", " TC", "css", "cca", "toc", "ec", "cf", "ui", "bc", "dc", "cs", "unc", "LC", "ctl", "ic", "cc", "tif", "cci", "ta", "icc", "ts", "currency", "pb", "mc", "t", "ci", "cas", "ctx", "rc", "lc", "https", "gc", "cache", "ctr", "c", "tmp", "uc", "TC", "times", "asc", "cm", "cot", "temp", "etc", "cu", "fee", "fc", "sc", "tu", "cv", "uca", "tim"]}}
{"project": "FFmpeg", "commit_id": "ac66834c759b7130fb5be51f63cb6dff9b294cba", "target": 0, "func": "int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,\n\n                         int *frame_size_ptr,\n\n                         uint8_t *buf, int buf_size)\n\n{\n\n    int ret;\n\n\n\n    *frame_size_ptr= 0;\n\n    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){\n\n        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,\n\n                                buf, buf_size);\n\n        avctx->frame_number++;\n\n    }else\n\n        ret= 0;\n\n    return ret;\n\n}\n", "idx": 8199, "substitutes": {"avctx": ["devcontext", " avgo", "wavtx", "Avcontext", "avgo", "evctx", " avcv", " avcontext", "avconn", "aftx", " avreq", "evpkg", "avecontext", "evcontext", "afctx", "Avconn", "Avpkg", "devctx", "AVtx", " avpkg", "afsys", "avsys", "wavctx", "evreq", " avsys", "cvpkg", "AVctx", "AVcontext", "afgo", "avesys", "avreq", "avcontext", "AVgc", "Avctx", "wavcv", "cvctx", "avgc", "cvconn", "devreq", "cvcontext", "avecv", "avectx", "avcv", " avconn", "afgc", "afcontext", "wavcontext", "avegc", "avtx", "avpkg", " avtx", "devpkg", "avetx", "avego"], "samples": ["jsample", " sample", "sample", "samps", "sources", "damps", "jsamps", " samps", "jsamples", "dample", "cample", " sources", "cources", "camps", "camples", "ssample", "jsources", "ssamps", "ssamples", "ssources", "dources", "damples"], "frame_size_ptr": ["frame_name_pointer", "frame_sizemmptr", "frame_sizemmmap", "frame_size_obj", "frame_size_addr", "frame_name_obj", "frame_size_map", "frame_name_addr", "frame_size_ref", "frame_name_map", "frame_Size_pointer", "frame_sizemmpointer", "frame_Size_tr", "frame_size_tr", "frame_name_tr", "frame_size_pointer", "frame_Size_ptr", "frame_name_ptr", "frame_sizemmaddr", "frame_Size_ref"], "buf": ["arr", "doc", "bf", "map", "buffer", "uf", "rb", "proc", "func", "p", "bc", "vec", "np", "block", "cur", "fb", "cb", "raw", "bytes", "bs", "mu", "queue", "bound", "data", "wav", "br", "pb", "box", "cap", "good", "mk", "b", "cmd", "orig", "etc", "buff", "db", "bar", "cv", "msg", "img", "wb"], "buf_size": ["buf_length", "buf_Size", "uf_count", "queue_len", "box_index", "queue_size", "uf_Size", "buf_len", "box1number", "box_number", "buf_number", "box_ize", "uf_length", "buf1size", "box1index", "buf1index", "buf1number", "box_size", "buf_count", "box1size", "buf_ize", "uf_size", "buf_index", "queue_length", "box1ize", "buf1ize"], "ret": ["ert", "len", "tr", "reset", "et", "back", "flag", "err", "print", "det", "RET", "resp", "reply", "nt", "iter", "cat", "rev", "pret", "def", "ptr", "after", "desc", " alt", "ort", "alt", "ter", "ext", "r", "cont", "final", "t", "rem", "rets", "repl", "virtual", "val", "Ret", "xt", "ctr", "red", "cmd", "rt", "re", "elt", "res", "rm", "cert", "result", "att", "gt", "ll", "ft", "out", "mt"], "frame_number": ["frames_span", "frames_volume", "frames_num", "frame_num", "frames_number", "frame_volume", "frame_span"]}}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n\n                    int mb_x, int mb_y, int layout)\n\n{\n\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n\n                                  mb - 1 /* left */,\n\n                                  0      /* top-left */ };\n\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n\n    int idx = CNT_ZERO;\n\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n\n    int8_t *sign_bias = s->sign_bias;\n\n    VP56mv near_mv[4];\n\n    uint8_t cnt[4] = { 0 };\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n\n        mb_edge[0] = mb + 2;\n\n        mb_edge[2] = mb + 1;\n\n    } else {\n\n        mb_edge[0] = mb - s->mb_width - 1;\n\n        mb_edge[2] = mb - s->mb_width - 2;\n\n    }\n\n\n\n    AV_ZERO32(&near_mv[0]);\n\n    AV_ZERO32(&near_mv[1]);\n\n    AV_ZERO32(&near_mv[2]);\n\n\n\n    /* Process MB on top, left and top-left */\n\n#define MV_EDGE_CHECK(n)                                                      \\\n\n    {                                                                         \\\n\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n\n        int edge_ref = edge->ref_frame;                                       \\\n\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n\n            if (mv) {                                                         \\\n\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n\n                    /* SWAR negate of the values in mv. */                    \\\n\n                    mv = ~mv;                                                 \\\n\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n\n                }                                                             \\\n\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n\n                cnt[idx] += 1 + (n != 2);                                     \\\n\n            } else                                                            \\\n\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n\n        }                                                                     \\\n\n    }\n\n\n\n    MV_EDGE_CHECK(0)\n\n    MV_EDGE_CHECK(1)\n\n    MV_EDGE_CHECK(2)\n\n\n\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n\n        mb->mode = VP8_MVMODE_MV;\n\n\n\n        /* If we have three distinct MVs, merge first and last if they're the same */\n\n        if (cnt[CNT_SPLITMV] &&\n\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n\n            cnt[CNT_NEAREST] += 1;\n\n\n\n        /* Swap near and nearest if necessary */\n\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n\n        }\n\n\n\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n\n                /* Choose the best mv out of 0,0 and the nearest mv */\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n\n\n\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n\n                    mb->mode = VP8_MVMODE_SPLIT;\n\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n\n                } else {\n\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n\n                    mb->bmv[0] = mb->mv;\n\n                }\n\n            } else {\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n\n                mb->bmv[0] = mb->mv;\n\n            }\n\n        } else {\n\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n\n            mb->bmv[0] = mb->mv;\n\n        }\n\n    } else {\n\n        mb->mode = VP8_MVMODE_ZERO;\n\n        AV_ZERO32(&mb->mv);\n\n        mb->bmv[0] = mb->mv;\n\n    }\n\n}\n", "idx": 8208, "substitutes": {"s": ["ms", "sym", "sq", "spec", "sl", "a", "rs", "as", "asm", "sg", "p", "gs", "sts", "hs", "sm", "f", "ps", "sac", "g", "m", "l", "ins", "sv", "i", "ses", "es", "scl", "bs", "r", "is", "js", "less", "S", "ss", "ts", "n", "its", "t", "v", "conf", "self", "os", "sb", "b", "e", "h", "ns", "w", "fs", "z", "app", "ims", "space", "ds", "sys"], "mb": ["ms", "lb", "ml", "arb", "bf", "nm", "mx", "orm", "mm", "ghost", "gm", "rb", "meta", "gov", "sm", "GB", "fm", "mg", "ram", "mount", "m", "ref", "bm", "um", "nob", "ab", "fps", "mn", "mem", "mph", "md", "bound", "ma", "pb", "mc", "emb", "umb", "sb", "b", "cmd", "kb", "ym", "sbm", "bb", "ob", "orb", "mac", "org", "MB", "gb", "memory", "ib", " MB", "db", "img", "mp", "vm", "conv", "mt", "mop"], "mb_x": ["emb_y", "emb_z", "emb_x", "mb_z", "mb_rx", "emb_rx"], "mb_y": ["MB_top", "mb_top", "MB_w", "mb11top", "mb11y", "mb_w", "mb11x", "MB_y", "MB_x", "mb11w"], "layout": ["display", "sync", "config", "buffer", "Layout", "padding", "layer", "base", "update", "height", "slot", "normal", "mount", "location", "label", "block", "np", "l", "position", "parent", "mask", "loop", "background", "scroll", "math", "margin", "mode", "lc", "hidden", "unknown", "gc", "shape", "offset", "lay", "border", "center", "draw", "style"], "mb_edge": ["ambJconn", "mbJconn", "mb__face", "amb_ende", "mb___entity", "amb_se", "mb8element", "amb_conn", "mb0ende", "mb__ge", "mb0entity", "mt_see", "amb0entity", "mb_ende", "mbJedge", "ambJextra", "mbJextra", "mp_edge", "amb0edge", "amb0se", "mb8edge", "mb___ee", "mt_ee", "ambJsource", "mb8see", "mb_entity", "mp_link", "ib_ee", "mb_source", "mb0edge", "mb8ee", "mb__link", "mbJsource", "mb_ge", "mp_ge", "ib_edge", "amb_edge", "ib_ge", "ambJedge", "amb0ende", "mb___ende", "amb_extra", "amb_entity", "mb_element", "amb_source", "ib_connect", "mb_see", "mb___see", "mb_conn", "mb_ee", "mt_element", "mb_connect", "mb0se", "mp_face", "mb__edge", "mb_se", "mb___edge", "mt_edge", "mb_extra", "mb___se", "mb___element", "mb_link", "mb_face"], "sign_bias": ["sign_labaid", "sign_bgis", "sign_embuster", "sign_bgias", "sign_vaid", "sign_vius", "sign___rbuster", "sign_rbuster", "sign_rbases", "sign_gius", "sign_embases", "sign_rbali", "sign___buster", "sign_buster", "sign_labases", "sign_gias", "sign_guster", "sign___rbases", "sign_bgases", "sign_bis", "sign_bris", "sign_labias", "sign_gali", "sign___rbias", "sign___bias", "sign_embali", "sign_boom", "sign_bases", "sign_vias", "sign_vases", "sign___rbali", "sign_lases", "sign_brias", "sign_gaid", "sign_bgoom", "sign_labius", "sign_embias", "sign_lias", "sign_gases", "sign_lis", "sign_bius", "sign_rbias", "sign___bases", "sign_loom", "sign_broom", "sign_baid", "sign_brases", "sign___bali", "sign_bali"], "near_mv": ["near_mdvr", "near_fmv", "near_mdval", "nearingmv", "near_metv", "near_mvr", "near_miv", "near_mmv", "near______mv", "near_Mvr", "nearablemetval", "near2pvs", "near_mq", "near_pvs", "near_fmval", "nearablemvr", "near______mpi", "near______fmv", "near_Mval", "near_fmim", "near_mmval", "near______mim", "nearablemval", "near2mv", "nearingmm", "near_fmpi", "near_mpi", "near_pw", "near_rmw", "nearingmtm", "near______fmpi", "near2mw", "near_mval", "near______fmim", "nearablemetvr", "near_mtv", "near_vmpi", "near_mdv", "near2pv", "near_mtms", "near_mmpi", "nearingmms", "nearablemv", "near_vmval", "nearablemetq", "near_nmtv", "near_mim", "nearablemetv", "nearingmtms", "near_nmms", "near_pv", "near2mvs", "near_Mv", "near_mms", "nearingmttv", "near_Mq", "near_rmv", "near_mttv", "near_mw", "near_mims", "near_mitv", "near_vmim", "nearablemq", "near2pw", "near_mtm", "near______fmval", "near_metval", "near_mm", "near_nmv", "near_Mvs", "near_metvr", "near_metq", "near_rmvs", "near_nmm", "nearingmtv", "near_Mw", "near_vmv", "near______mval", "near_mdq", "near_mvs", "near_mmim"], "cnt": ["nnt", "pcNT", "pcn", "cNT", "pcpt", "Cn", "CNT", "nNT", "Cnt", "cpt", "nn", "pcnt", "Cpt", "npt", "cn"], "c": ["u", "pc", "a", "ch", "ct", "p", "ec", "cl", "f", "cp", "bc", "dc", "xc", "g", "cs", "tc", "m", "l", "cc", "r", "n", "mc", "t", "ctx", "ac", "lc", "v", "cache", "e", "b", "h", "cm", "w", "sc", "fc", "C", "co", "cv", "ca"]}}
{"project": "qemu", "commit_id": "29851ee7c8bd3fb8542e21cd0270c73132590350", "target": 1, "func": "int main()\n\n{\n\n    int rd, rt, dsp;\n\n    int result, resultdsp;\n\n\n\n    rt        = 0x12345678;\n\n    result    = 0xA000C000;\n\n    resultdsp = 1;\n\n\n\n    __asm\n\n        (\"shll.ph %0, %2, 0x0B\\n\\t\"\n\n         \"rddsp %1\\n\\t\"\n\n         : \"=r\"(rd), \"=r\"(dsp)\n\n         : \"r\"(rt)\n\n        );\n\n    dsp = (dsp >> 22) & 0x01;\n\n    assert(dsp == resultdsp);\n\n    assert(rd  == result);\n\n\n\n    return 0;\n\n}\n", "idx": 8209, "substitutes": {"rd": ["td", "dd", "hr", "fd", "ran", "lr", "rb", "rs", "erd", "ri", "rf", "ld", "d", "rob", "rw", "cd", "rn", "rr", "adr", "dra", "r", "rl", "rx", "rod", "rc", "fr", "rh", "rect", "ro", "sr", "rm", "RD", "ard", "nder", "db", "ru", "vr", "nd", "rar", "rid", "dr"], "rt": ["tt", "art", "tr", "hr", "tx", "tp", "pt", "rb", "rs", "RT", "ri", "rf", "rec", "nt", "mt", "rn", "ptr", "rr", "adr", "txt", "r", "rx", "t", "reg", "rc", "fr", "pr", "ro", "ot", "sr", "res", "rm", "irt", "vr", "dt", "rid", "dr", "ret"], "dsp": ["fdosp", "dnsp", "Disp", "Dwp", "fdsw", "ddSP", "disp", "Dsw", "fdsp", "ddsp", "dSp", "DSp", "Dsp", " dSp", "dSP", "dsw", "dspe", " dSP", " dspe", "DSP", "dnSP", " dwp", "dnwp", "ddosp", "sdSp", "nisp", "sdisp", "sdsp", "nsp", " disp", "ddsw", "ddspe", "nSp", "dwp", "dosp", "dnSp", "Dosp", "ddSp", "sdSP", "Dspe"], "result": ["tr", "success", "ful", "status", "message", "lr", "match", "err", "complete", "valid", "sp", "rf", "error", "report", "d", "np", "other", "def", "rn", "relation", "term", "ter", "r", "br", "test", "root", "total", "final", "new", "rc", "fr", "pr", "Result", "red", "results", "res", "table", "db", "vr", "description", "su", "ret", "number"], "resultdsp": ["resultlSp", " resultdp", "resultnisp", "resultnsp", "resultDip", "resultlsp", "resultpSp", "resultdsSp", "resultDisp", "resultdssh", "resultdp", " resultDsp", "resultpisp", "resultdssp", "Resultdsp", "resultnsw", "resultdsw", " resultDsw", "resultpsp", " resultDSp", "resultlsh", "Resultdop", " resultlSp", "ResultdSp", "resultdip", "resultDsw", "resultdSp", " resultdsw", " resultdisp", "resultlp", " resultlp", "resultpip", "resultDSp", " resultDisp", " resultdsh", " resultlsh", " resultlsp", "resultDsp", "resultDop", "resultpsw", "resultnSp", "Resultdip", "resultdisp", " resultdSp", "resultpop", "resultdsh", "resultdop"]}}
{"project": "FFmpeg", "commit_id": "eb24fd64589b7eea91fa752861f0c6f07e5a48a8", "target": 0, "func": "int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)\n\n{\n\n    int count, x;\n\n    uint8_t *out;\n\n\n\n    out = outbuf;\n\n\n\n\n\n        for(x = 0; x < w; x += count) {\n\n            /* see if we can encode the next set of pixels with RLE */\n\n            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n\n                if(out + bpp + 1 > outbuf + out_size) return -1;\n\n                *out++ = (count ^ xor) + add;\n\n                memcpy(out, ptr, bpp);\n\n                out += bpp;\n\n            } else {\n\n                /* fall back on uncompressed */\n\n                count = count_pixels(ptr, w-x, bpp, 0);\n\n                *out++ = count - 1;\n\n\n\n                if(out + bpp*count > outbuf + out_size) return -1;\n\n                memcpy(out, ptr, bpp * count);\n\n                out += bpp * count;\n\n        }\n\n\n\n        ptr += count * bpp;\n\n    }\n\n\n\n    return out - outbuf;\n\n}\n", "idx": 8211, "substitutes": {"outbuf": [" outcap", "inbuffer", "Outcap", "Outbuf", "outputbuf", "outbar", "OUTbuffer", "outputbuffer", "outputdb", "incap", " outbuff", "inbuff", "outputqueue", "Outqueue", "outcap", "savefb", " outBuffer", "inbuf", " outbar", "Outbuffer", "outfb", "savequeue", "inqueue", "savebuf", "outdb", "inbar", "outputBuffer", "OUTbuf", "outbuffer", "outbuff", "OUTBuffer", "inBuffer", "Outbuff", "outputfb", "outqueue", " outfb", "savedb", "outputbar", " outdb", "outBuffer", " outqueue", " outbuffer"], "out_size": ["resultableheight", "out_type", "result_size", "result_Size", "outjtoo", " out_SIZE", "out_SIZE", "result_type", "resultablesize", "outpttype", "resultpttoo", "out_height", "outjsize", "resultabletype", "resultptsize", " out_Size", "resultpttype", "resultptwidth", "outptsize", "out_too", "out8width", "out_Size", "out_width", "out8type", "result_height", "outableSize", "outptwidth", "outpttoo", "out8size", "out8too", "outjtype", "resultableSize", "outjwidth", "result_too", "outablesize", "result_width", "outabletype", "outableheight"], "ptr": ["src", "arr", "shift", "tr", "tx", "prime", "tp", "pc", "address", "buffer", "pointer", "pt", "req", "alloc", "per", "proc", "p", "sp", "inters", "point", "ind", "pad", "fp", "ps", "pointers", "iter", "th", "pos", "ref", "inter", "np", "desc", "adr", "handle", "addr", "expr", "index", "r", "rel", "br", "ts", "ix", "ctx", "deg", "fr", "pr", "rect", "ctr", "xt", "copy", "cmd", "rt", "hw", "start", "sys", "coord", "Ptr", "dh", "iv", "vr", "pre", "offset", "dr", "mt"], "bpp": ["bphp", "rbpp", "bbgp", "bph", "sbpo", "mbipp", "binpp", "bgphp", "bpl", "bcc", "bbpps", "bbpl", "bbPP", "mbphp", "bbpo", " bPP", " bff", "binpl", "blgp", "zppe", "bgps", "bipp", "bbpg", "bgpps", " bmm", "bgp", " bppy", "bpper", "sbpl", "bgpped", "bpo", " bpped", "bmm", "blpg", "dbipp", " bfx", "bamp", " bpo", "bbcc", "blff", "blppy", " bpl", "bpps", "sbmm", "sbpps", "zpp", "bgppe", "bbphp", "bbamp", " bph", "rbphp", " bppe", "sbpp", "sbamp", "bppe", " bphp", "bbmm", "bbipp", "rbpped", "bgfx", " bps", " bcc", "blphp", "rbps", "bff", "sbcc", "bpped", " bpg", "bps", "bbppy", "blpp", "dbphp", "zpper", "mbps", "bgppy", "bbfx", "bfx", "bppy", " bamp", "bbff", "dbpp", "bbps", " bpper", "bPP", "mbpp", "bbph", "bbpp", "zPP", " bpps", "bgpp", "bgPP", "binPP", "bpg", " bgp", "sbph", "binphp", "dbps", "bgpper"], "w": ["iw", "wal", "q", "end", "wk", "wind", "weight", "wi", "p", "we", "widget", "W", "wid", "wm", "rw", "wr", "m", "wx", "win", "window", "wh", "wa", "ew", "r", "wl", "n", "y", "wd", "v", "aw", "b", "sw", "wt", "wp", "h", "hw", "kw", " W", "z", "nw", "wb"], "add": ["grow", "acc", "inc", "extra", "sum", "a", "mult", "base", "q", "end", "update", "Add", "adv", "pad", "d", "act", "i", "mod", "mix", "addr", "ext", "create", "alpha", "plus", "ix", "ad", "n", "ac", "new", "ract", "added", "ads", "start", "make", "diff", "ADD", "att", "rad", "apply", "adder", "append", "attach"], "xor": ["xors", "Xors", "xorst", "ixort", " xors", "ixor", "axor", "xort", "fxort", "Xorst", "fxors", "ixors", "ixOR", " xOR", "axors", "axorst", " xorst", " xort", "fxor", "XOR", "axOR", "fxOR", "Xor", "xOR"], "count": ["each", "ct", "first", "mount", "ount", "cc", "amount", "t", "check", "wd", "found", "cmd", "result", "history", "size", "status", "call", "code", "message", "match", "weight", "ind", "try", "cond", "test", "Count", "conf", "e", "temp", "force", "z", "att", "number", "current", "a", "err", "counter", "ach", "hash", "nt", "cycle", "process", "cd", "index", "n", "now", "ctx", "info", "comment", "only", "find", "len", "num", "entry", "con", "sum", "flag", "base", "q", "list", "child", "p", "all", "core", "cont", "total", "v", "cache", "gc", "val", "ctr", "c", "h", "C", "max", "length"], "x": ["xp", "xy", "tx", "num", "u", "mx", "q", "step", "k", "p", "f", "ex", "ind", "ox", "dx", "xd", "xc", "l", "wx", "m", "X", "i", "xs", "inx", "lat", "index", "rx", "ix", "j", "n", "y", "t", "px", "v", "xi", "ey", "e", "xt", "c", "h", "xx", "yx", "xml", "z", "ax", "fx", "batch", "item", "lex", "el", "ux", "xf"], "out": ["on", "update", "end", "print", "over", "o", "OUT", "block", "parent", "y", "t", "check", "ion", "b", "cmd", "target", "ot", "serv", "ent", "opt", "result", "user", "conv", "output", "inner", "at", "code", "ex", "g", "outs", "ou", "server", "ac", "new", "conn", " Out", "batch", "att", "unt", "no", "obj", "net", "a", "ch", "pt", "external", "up", "go", "point", "nt", "i", "raw", "in", "index", "chain", "n", "remote", "cn", "tmp", "copy", "can", "it", "ret", "off", "con", "sum", "io", "soft", "list", "to", "p", "pool", "client", "port", "Out", "handle", "all", "alt", "bit", "ext", "v", "cache", "c", "res", "set", "gt", "msg", "co", "name", "sys"]}}
{"project": "FFmpeg", "commit_id": "cbbb2067341d7c2d98f560f81c6fb103af33a490", "target": 1, "func": "static int vdpau_frames_init(AVHWFramesContext *ctx)\n\n{\n\n    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;\n\n    VDPAUFramesContext        *priv = ctx->internal->priv;\n\n\n\n    int i;\n\n\n\n    switch (ctx->sw_format) {\n\n    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;\n\n    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;\n\n    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported data layout: %s\\n\",\n\n               av_get_pix_fmt_name(ctx->sw_format));\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {\n\n        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {\n\n            priv->chroma_idx  = i;\n\n            priv->pix_fmts    = device_priv->pix_fmts[i];\n\n            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];\n\n            break;\n\n        }\n\n    }\n\n    if (!priv->pix_fmts) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported chroma type: %d\\n\", priv->chroma_type);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (!ctx->pool) {\n\n        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,\n\n                                                            vdpau_pool_alloc, NULL);\n\n        if (!ctx->internal->pool_internal)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    priv->get_data = device_priv->get_data;\n\n    priv->put_data = device_priv->put_data;\n\n\n\n    return 0;\n\n}\n", "idx": 8217, "substitutes": {"ctx": ["tm", "ck", "xp", "cam", "ct", "alloc", "func", "kt", "pg", "desc", "ctl", "cc", "ce", "cas", "check", "wd", "wcs", "cmd", "nc", "org", "context", "comm", "cv", "history", "conv", "aco", "tx", "cmp", "ctrl", "tk", "sp", "ind", "bc", "jp", "ptr", "cz", "conn", "conf", "comp", "cm", "etc", "cpu", "sc", "phys", "jac", "obj", "pc", "abc", "crit", "req", "resp", "cp", "nt", "iat", "cur", "tc", "cd", "unc", "window", "mc", "mk", "anc", "tmp", "exec", "hw", "loc", "nw", " cx", "ack", "p", "pool", "cf", "xc", "act", "pkg", "np", "wx", "cb", "addr", "rc", "cfg", "gc", "ctr", "wp", "kw", "cu", "fc", "co", "msg", "sys", "working"], "device_priv": ["devicepypub", "device2private", "device_admin", " device_vt", "resource_ptr", "device0riv", "device0priv", "devicepyvt", "resource_pkg", "device_vt", "deviceptpriv", "resource_riv", "device_Priv", "deviceptadmin", " device_auth", "device0pkg", "devicepycaps", "devicepyadmin", "devicepyPriv", "dev_Priv", "device_private", "device_pkg", "device_gen", "dev_private", "device2Priv", " device_pub", "deviceptPriv", "dev_priv", "devicepyauth", "device0ptr", " device_admin", "resource_priv", "dev_gen", "devicepypriv", "device_caps", "device_auth", "device_pub", " device_Priv", "device_ptr", " device_caps", "device_riv", "deviceptcaps", "device2priv"], "priv": ["doc", "Priv", "prof", "decl", "deb", "prov", "alloc", "proc", "func", "rep", "rib", "prop", "attr", "pub", "cap", "pr", "env", "caps", "trust", "serv", "pi", "org", "ib", "public", "soc", "pro", " Priv", "notice", "cmp", "Pri", "sec", "prot", "rob", "rev", "cer", "ptr", "pri", "urg", "rel", "aux", "conn", "conf", "eas", "debug", "obj", "policy", "req", "err", "ev", "resp", "cp", "gr", "push", "admin", "def", "mem", "perm", "info", "exec", "rest", "loc", "lib", "eps", "adv", "dev", "Pub", "pkg", "por", "auth", "expr", "pb", "rc", "cfg", "riv", "pol", "stats", "stat", "private", "access"], "i": ["key", "ai", "I", "me", "io", "li", "base", "ei", "q", "uri", "iq", "span", "ri", "p", "o", "sim", "ex", "ind", "ui", "ip", "g", "m", " pi", "ki", "ji", "ti", "ic", " si", "in", " ti", "mi", "cli", "is", "chain", "j", "im", "ix", "index", "n", "y", "try", "t", "ci", "iu", "\u0438", "phi", "v", "zi", " ki", "xi", "multi", "qi", "c", "gi", "di", "bi", "ij", "pi", "si", "slice", "it", "x", "batch", "ini", " ii", "oi", "hi", "yi", "ims", " j", "ii"]}}
{"project": "qemu", "commit_id": "74892d2468b9f0c56b915ce94848d6f7fac39740", "target": 1, "func": "int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}", "idx": 8221, "substitutes": {"state": ["next", "run", "spec", "power", "status", "show", "call", "config", "resource", "code", "message", "policy", "thread", "init", "or", "event", "list", "job", "STATE", "post", "this", "size", "type", "local", "request", "port", "json", "in", "State", "data", "test", "t", "check", "zone", "info", "lock", "cmd", "copy", "start", "rule", "st", "stat", "it", "result", "msg", "states", "name", "out", "store"]}}
{"project": "FFmpeg", "commit_id": "801c39e1e3058fc4ba822bfb5d8612d777111e32", "target": 0, "func": "static int dca_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    AVFrame *frame     = data;\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    int lfe_samples;\n\n    int num_core_channels = 0;\n\n    int i, ret;\n\n    float  **samples_flt;\n\n    DCAContext *s = avctx->priv_data;\n\n    int channels, full_channels;\n\n    int core_ss_end;\n\n\n\n\n\n    s->xch_present = 0;\n\n\n\n    s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer,\n\n                                                  DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE);\n\n    if (s->dca_buffer_size == AVERROR_INVALIDDATA) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Not a valid DCA frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8);\n\n    if ((ret = dca_parse_frame_header(s)) < 0) {\n\n        //seems like the frame is corrupt, try with the next one\n\n        return ret;\n\n    }\n\n    //set AVCodec values with parsed data\n\n    avctx->sample_rate = s->sample_rate;\n\n    avctx->bit_rate    = s->bit_rate;\n\n\n\n    s->profile = FF_PROFILE_DTS;\n\n\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        if ((ret = dca_decode_block(s, 0, i))) {\n\n            av_log(avctx, AV_LOG_ERROR, \"error decoding block\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* record number of core channels incase less than max channels are requested */\n\n    num_core_channels = s->prim_channels;\n\n\n\n    if (s->ext_coding)\n\n        s->core_ext_mask = dca_ext_audio_descr_mask[s->ext_descr];\n\n    else\n\n        s->core_ext_mask = 0;\n\n\n\n    core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8;\n\n\n\n    /* only scan for extensions if ext_descr was unknown or indicated a\n\n     * supported XCh extension */\n\n    if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) {\n\n\n\n        /* if ext_descr was unknown, clear s->core_ext_mask so that the\n\n         * extensions scan can fill it up */\n\n        s->core_ext_mask = FFMAX(s->core_ext_mask, 0);\n\n\n\n        /* extensions start at 32-bit boundaries into bitstream */\n\n        skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n\n\n        while (core_ss_end - get_bits_count(&s->gb) >= 32) {\n\n            uint32_t bits = get_bits_long(&s->gb, 32);\n\n\n\n            switch (bits) {\n\n            case 0x5a5a5a5a: {\n\n                int ext_amode, xch_fsize;\n\n\n\n                s->xch_base_channel = s->prim_channels;\n\n\n\n                /* validate sync word using XCHFSIZE field */\n\n                xch_fsize = show_bits(&s->gb, 10);\n\n                if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) &&\n\n                    (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1))\n\n                    continue;\n\n\n\n                /* skip length-to-end-of-frame field for the moment */\n\n                skip_bits(&s->gb, 10);\n\n\n\n                s->core_ext_mask |= DCA_EXT_XCH;\n\n\n\n                /* extension amode(number of channels in extension) should be 1 */\n\n                /* AFAIK XCh is not used for more channels */\n\n                if ((ext_amode = get_bits(&s->gb, 4)) != 1) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"XCh extension amode %d not\"\n\n                           \" supported!\\n\", ext_amode);\n\n                    continue;\n\n                }\n\n\n\n                /* much like core primary audio coding header */\n\n                dca_parse_audio_coding_header(s, s->xch_base_channel);\n\n\n\n                for (i = 0; i < (s->sample_blocks / 8); i++)\n\n                    if ((ret = dca_decode_block(s, s->xch_base_channel, i))) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error decoding XCh extension\\n\");\n\n                        continue;\n\n                    }\n\n\n\n                s->xch_present = 1;\n\n                break;\n\n            }\n\n            case 0x47004a03:\n\n                /* XXCh: extended channels */\n\n                /* usually found either in core or HD part in DTS-HD HRA streams,\n\n                 * but not in DTS-ES which contains XCh extensions instead */\n\n                s->core_ext_mask |= DCA_EXT_XXCH;\n\n                break;\n\n\n\n            case 0x1d95f262: {\n\n                int fsize96 = show_bits(&s->gb, 12) + 1;\n\n                if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96)\n\n                    continue;\n\n\n\n                av_log(avctx, AV_LOG_DEBUG, \"X96 extension found at %d bits\\n\",\n\n                       get_bits_count(&s->gb));\n\n                skip_bits(&s->gb, 12);\n\n                av_log(avctx, AV_LOG_DEBUG, \"FSIZE96 = %d bytes\\n\", fsize96);\n\n                av_log(avctx, AV_LOG_DEBUG, \"REVNO = %d\\n\", get_bits(&s->gb, 4));\n\n\n\n                s->core_ext_mask |= DCA_EXT_X96;\n\n                break;\n\n            }\n\n            }\n\n\n\n            skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n        }\n\n    } else {\n\n        /* no supported extensions, skip the rest of the core substream */\n\n        skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb));\n\n    }\n\n\n\n    if (s->core_ext_mask & DCA_EXT_X96)\n\n        s->profile = FF_PROFILE_DTS_96_24;\n\n    else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH))\n\n        s->profile = FF_PROFILE_DTS_ES;\n\n\n\n    /* check for ExSS (HD part) */\n\n    if (s->dca_buffer_size - s->frame_size > 32 &&\n\n        get_bits_long(&s->gb, 32) == DCA_HD_MARKER)\n\n        dca_exss_parse_header(s);\n\n\n\n    avctx->profile = s->profile;\n\n\n\n    full_channels = channels = s->prim_channels + !!s->lfe;\n\n\n\n    if (s->amode < 16) {\n\n        avctx->channel_layout = dca_core_channel_layout[s->amode];\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            /*\n\n             * Neither the core's auxiliary data nor our default tables contain\n\n             * downmix coefficients for the additional channel coded in the XCh\n\n             * extension, so when we're doing a Stereo downmix, don't decode it.\n\n             */\n\n            s->xch_disable = 1;\n\n        }\n\n\n\n#if FF_API_REQUEST_CHANNELS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        if (s->xch_present && !s->xch_disable &&\n\n            (!avctx->request_channels ||\n\n             avctx->request_channels > num_core_channels + !!s->lfe)) {\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#else\n\n        if (s->xch_present && !s->xch_disable) {\n\n#endif\n\n            avctx->channel_layout |= AV_CH_BACK_CENTER;\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode];\n\n            } else {\n\n                s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode];\n\n            }\n\n        } else {\n\n            channels = num_core_channels + !!s->lfe;\n\n            s->xch_present = 0; /* disable further xch processing */\n\n            if (s->lfe) {\n\n                avctx->channel_layout |= AV_CH_LOW_FREQUENCY;\n\n                s->channel_order_tab = dca_channel_reorder_lfe[s->amode];\n\n            } else\n\n                s->channel_order_tab = dca_channel_reorder_nolfe[s->amode];\n\n        }\n\n\n\n        if (channels > !!s->lfe &&\n\n            s->channel_order_tab[channels - 1 - !!s->lfe] < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (s->prim_channels + !!s->lfe > 2 &&\n\n            avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) {\n\n            channels = 2;\n\n            s->output = s->prim_channels == 2 ? s->amode : DCA_STEREO;\n\n            avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n            /* Stereo downmix coefficients\n\n             *\n\n             * The decoder can only downmix to 2-channel, so we need to ensure\n\n             * embedded downmix coefficients are actually targeting 2-channel.\n\n             */\n\n            if (s->core_downmix && (s->core_downmix_amode == DCA_STEREO ||\n\n                                    s->core_downmix_amode == DCA_STEREO_TOTAL)) {\n\n                int sign, code;\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    sign = s->core_downmix_codes[i][0] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][0] & 0x0FF;\n\n                    s->downmix_coef[i][0] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                    sign = s->core_downmix_codes[i][1] & 0x100 ? 1 : -1;\n\n                    code = s->core_downmix_codes[i][1] & 0x0FF;\n\n                    s->downmix_coef[i][1] = (!code ? 0.0f :\n\n                                             sign * dca_dmixtable[code - 1]);\n\n                }\n\n                s->output = s->core_downmix_amode;\n\n            } else {\n\n                int am = s->amode & DCA_CHANNEL_MASK;\n\n                if (am >= FF_ARRAY_ELEMS(dca_default_coeffs)) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"Invalid channel mode %d\\n\", am);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                if (s->prim_channels + !!s->lfe >\n\n                    FF_ARRAY_ELEMS(dca_default_coeffs[0])) {\n\n                    avpriv_request_sample(s->avctx, \"Downmixing %d channels\",\n\n                                          s->prim_channels + !!s->lfe);\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                    s->downmix_coef[i][0] = dca_default_coeffs[am][i][0];\n\n                    s->downmix_coef[i][1] = dca_default_coeffs[am][i][1];\n\n                }\n\n            }\n\n            av_dlog(s->avctx, \"Stereo downmix coeffs:\\n\");\n\n            for (i = 0; i < s->prim_channels + !!s->lfe; i++) {\n\n                av_dlog(s->avctx, \"L, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][0]);\n\n                av_dlog(s->avctx, \"R, input channel %d = %f\\n\", i,\n\n                        s->downmix_coef[i][1]);\n\n            }\n\n            av_dlog(s->avctx, \"\\n\");\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Non standard configuration %d !\\n\", s->amode);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = channels;\n\n\n\n    /* get output buffer */\n\n    frame->nb_samples = 256 * (s->sample_blocks / 8);\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    samples_flt = (float **)frame->extended_data;\n\n\n\n    /* allocate buffer for extra channels if downmixing */\n\n    if (avctx->channels < full_channels) {\n\n        ret = av_samples_get_buffer_size(NULL, full_channels - channels,\n\n                                         frame->nb_samples,\n\n                                         avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        av_fast_malloc(&s->extra_channels_buffer,\n\n                       &s->extra_channels_buffer_size, ret);\n\n        if (!s->extra_channels_buffer)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = av_samples_fill_arrays((uint8_t **)s->extra_channels, NULL,\n\n                                     s->extra_channels_buffer,\n\n                                     full_channels - channels,\n\n                                     frame->nb_samples, avctx->sample_fmt, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    /* filter to get final output */\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n\n        int ch;\n\n\n\n        for (ch = 0; ch < channels; ch++)\n\n            s->samples_chanptr[ch] = samples_flt[ch] + i * 256;\n\n        for (; ch < full_channels; ch++)\n\n            s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256;\n\n\n\n        dca_filter_channels(s, i);\n\n\n\n        /* If this was marked as a DTS-ES stream we need to subtract back- */\n\n        /* channel from SL & SR to remove matrixed back-channel signal */\n\n        if ((s->source_pcm_res & 1) && s->xch_present) {\n\n            float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]];\n\n            float *lt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]];\n\n            float *rt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]];\n\n            s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256);\n\n            s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256);\n\n        }\n\n    }\n\n\n\n    /* update lfe history */\n\n    lfe_samples = 2 * s->lfe * (s->sample_blocks / 8);\n\n    for (i = 0; i < 2 * s->lfe * 4; i++)\n\n        s->lfe_data[i] = s->lfe_data[i + lfe_samples];\n\n\n\n    /* AVMatrixEncoding\n\n     *\n\n     * DCA_STEREO_TOTAL (Lt/Rt) is equivalent to Dolby Surround */\n\n    ret = ff_side_data_update_matrix_encoding(frame,\n\n                                              (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ?\n\n                                              AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_frame_ptr = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 8241, "substitutes": {"avctx": [" avctl", "afpkg", " avcp", "evctx", " avcontext", "avepkg", "ovcontext", "avconn", "avctl", "svctl", "aftx", "avecontext", "avercmp", "evcontext", "ovctx", "afctx", "averctl", " avpkg", "averconn", "ovconn", "avcp", "wavctx", "avecmp", "svctx", "avcontext", "afconn", "avercp", "wavcp", "cvctx", "avercontext", "ovctl", " avcmp", "svcontext", "cvcontext", "aveconn", "avectx", "afcp", "afctl", " avconn", "afcmp", "averctx", "afcontext", "cvctl", "avcmp", "svconn", "evtx", "wavcontext", "avecp", "avtx", "avpkg", "wavconn", " avtx", "cvcmp", "evctl"], "data": ["obj", "Data", "empty", "next", "map", "record", "buffer", "text", "message", "pointer", "padding", "format", "image", "init", "read", "sample", "to", "area", "form", "p", "value", "o", "f", "bin", "pad", "first", "name", "d", " DATA", "block", "ata", "def", "zero", "type", "length", "raw", "window", "bytes", "in", "package", "video", "body", "t", "feed", "input", "dat", "table", "batch", "DATA", "response", "offset", "size", "out"], "got_frame_ptr": ["got_frame2handle", "got_fr_pointer", "got_frame2pointer", "got_frame_handle", "got_framethandle", "got_fr_ptr", "got_fr_pointers", "got_frametpointers", "got_frame_pointer", "got_frame2pointers", "got_fr_handle", "got_frame2ptr", "got_frametptr", "got_frame_pointers", "got_frametpointer"], "avpkt": ["avespct", "avcpkt", "avpacket", "avppstat", "avcpkl", "afpkl", "avpmt", "avcpstat", "avepkg", "afcpett", "avespkg", "avwacket", "afpkt", "avjpkt", "avpgt", "avpadkt", "avspkg", "afpett", "avspct", "avpemt", "avwkt", "avspkt", "avjpgt", "avPkt", "avPgt", "afpacket", "afpstat", "avwkl", "afcpstat", "avppacket", "avpekl", "avpstat", "avespgt", "avpett", "avcpacket", "avpeacket", "afcpmt", "afcpkt", "avepgt", "avpekt", "avespkt", "afcpacket", "afcpkl", "avcpmt", "avpct", "avspgt", "avjpkg", "avepkt", "avjpct", "avpkl", "afpmt", "avPct", "avepct", "avPkg", "avpkg", "avppkt", "avpadstat", "avppett", "avpadett", "avpadacket", "avwmt", "avcpett"], "frame": [" packet", "channel", "feature", "base", "image", " response", " res", "f", " window", " video", "ata", "def", " df", " sequence", "window", " t", " image", "Frame", " chunk", " output", "cmd", " info", " frames", "name", " command", " message"], "buf": ["arr", "doc", "xff", "buffer", "uf", "rb", "cam", "ff", "p", "bl", "seq", "bc", "vec", "np", "vp", "cur", "pkg", "ref", "cb", "raw", "window", "bytes", "txt", "queue", "mem", "r", "br", "t", "rc", "v", "b", "tmp", "cmd", "orig", "Buff", "buff", "db", "cv", "img"], "lfe_samples": ["lfe_damples", "lfe_dannels", "lfe_Sents", "lfe_dents", "lfe_gsamps", "lfe_sents", "lfe_Samps", "lfe_damps", "lfe_Samples", "lfe_gsamples", "lfe_gsents", "lfe_sannels", "lfe_samps", "lfe_Sannels", "lfe_gsannels"], "i": ["depth", "id", "u", "ai", "I", "me", "li", "ei", "k", "p", "o", "sim", "ind", "ui", "iter", "ip", "m", "ki", "ti", "ic", "cli", "in", "mi", "r", "index", "is", "j", "im", "ix", "n", "y", "t", "ci", "iu", "\u0438", "zi", "v", "xi", "gu", "multi", "qi", "b", "c", "gi", "bi", "di", "ij", "pi", "si", "it", "x", "ini", " ii", "ims", "ii"], "ret": ["tf", "fin", "tr", "reset", "status", "nl", "back", "flag", "format", "summary", "err", "print", "det", "RET", "resp", "value", "reply", "report", "nt", "jp", "ref", "fun", "mt", "def", " Ret", "rr", "txt", "usr", "alt", "mem", "r", "cont", "try", "last", "final", "body", "mel", "aux", "rem", "rets", "deg", "not", "gc", "val", "Ret", "red", "rt", "re", "str", "elt", "res", "ber", "rm", "it", "result", "gt", "ll", "ft", "dr", "out"], "samples_flt": ["samples_dilt", "samples2Fld", "samples_dfilt", "samples_dmt", "samples_dflt", "samples_Filt", "samples_dfmt", "samples_filt", "samples2filt", "samples2flt", "samples2Flt", "samples2Filt", "samples_fmt", "samples2fmt", "samples_dld", "samples_dlt", "samples_Flt", "samples2Fmt", "samples_Fld", "samples2fld", "samples_dfld", "samples_Fmt", "samples_fld"], "s": ["ms", "vs", "ats", "hs", "d", "cs", "m", "bits", "ins", "details", "se", "y", "sports", "os", "b", "w", "comm", "ims", "ar", "ports", "source", "settings", "tests", "gs", "sts", "changes", "g", "ies", "sv", "args", "bs", "services", "als", "js", "less", "ss", "sets", "ops", "e", "sb", "ls", "sq", "obj", "spec", "qs", "a", "rs", "as", "ants", "l", "es", "store", "ts", "n", "sw", "ns", "tes", "ds", "eps", "p", "ps", "so", "aws", "is", "j", "S", "its", "v", "self", "c", "bis", "h", "stats", "fs", "set", "sys", "parts"], "channels": ["chunks", "camps", " champs", "Champs", "Chaos", " chunks", "cunks", "cannels", "Channels", "champs", "caos", " chaos", "Chunks", "chaos"], "full_channels": ["full_Chans", "full_lans", "full_chans", "full_Chats", "full_lannels", "full_Chunks", "full_nans", "full_nannels", "full_nats", "full_chunks", "full_lunks", "full_chats", "full_lats", "full_Channels", "full_nunks"], "core_ss_end": ["core_rss_ends", "core_ss_start", "core_rss_start", "core_ss_stop", "core_rss_stop", "core_ss_begin", "core_rss_begin", "core_rss_end", "core_ss_ends"]}}
{"project": "qemu", "commit_id": "f74990a5d019751c545e9800a3376b6336e77d38", "target": 0, "func": "static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    const unsigned long *features = cpu->model->features;\n\n    unsigned max_bit = 0;\n\n    S390Feat feat;\n\n\n\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n\n\n\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n\n        /* z/Architecture is always active if around */\n\n        words[0] = 1ull << (63 - 2);\n\n    }\n\n\n\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n\n         feat < S390_FEAT_MAX;\n\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n\n        const S390FeatDef *def = s390_feat_def(feat);\n\n        if (def->type == S390_FEAT_TYPE_STFL) {\n\n            unsigned bit = def->bit;\n\n            if (bit > max_bit) {\n\n                max_bit = bit;\n\n            }\n\n            assert(bit / 64 < MAX_STFL_WORDS);\n\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n\n        }\n\n    }\n\n\n\n    return max_bit / 64;\n\n}\n", "idx": 8247, "substitutes": {"env": ["vs", "tx", "net", "config", "et", "code", "init", "ev", "ack", "proc", "sp", "buf", "dev", "gov", "eng", "window", "en", "server", "mem", "ew", "qt", "pres", "js", "neck", "ctx", "conn", "v", "environment", "e", "anc", "eu", "hw", "serv", "org", "context", "cv", "nv", "viron"], "words": ["ms", "doc", "windows", "vs", "locks", "pieces", "frames", "blocks", "names", "weights", "wal", "workers", "we", "buf", "games", "W", "pages", "pointers", "rw", " docs", "docs", "works", "images", "papers", "bits", "values", "args", "pins", "Words", "word", "lists", "terms", "bytes", "posts", " w", "views", "rows", " keywords", " weights", "wd", "wcs", "tags", "ows", "flags", "w", "vals", "maps", "s", "items"], "cpu": ["ck", "aco", "cum", "mx", "gpu", "prof", "cam", "ct", "alloc", "nu", "proc", "cp", "pu", "linux", "process", "np", "util", "mu", "us", "CPU", "core", "mem", "clock", "node", "ctx", "conn", "ork", "xi", "os", "hw", "cu", "serv", "stat", "mac", "lif", "phys", "cv", "vm", "hog", "sys"], "features": ["abilities", "users", "ports", "events", "classes", "acts", "pieces", "frames", "Features", "names", "weights", "feature", "settings", "fts", "types", "tests", "workers", "keys", "modules", "ints", "files", "images", "papers", "bits", "pins", "mas", "fixes", "xs", " Features", "forms", "terms", "lists", "ATURES", "its", "rows", "fields", "nets", "tags", "properties", "eatures", "reports", "results", "products", "flags", "issues", "stats", "fits", "finals", "vals", "faces", "actions", "facts", "states", "jobs", "versions", " feats", "items"], "feat": ["doc", "feature", "format", "kt", "prop", "cat", "word", "miss", "month", " fmt", " doc", "fg", "cas", "man", "mit", " seq", " feats", "wit", "ex", " fi", "capt", "mod", "fact", "fn", " win", " threat", " fe", "cheat", "rt", "bug", " sect", " plat", "dit", "eat", "spec", "mat", "ffff", "crit", " cond", "flat", "focus", "wi", " frag", "lu", " mat", "vec", "fe", "supp", "apt", "kat", "fac", " lat", "pict", "mut", "it", " vec", "hit", "lt", "lit", "list", "seq", "act", "wx", "week", "lat", "bit", " wid", "fat", "tag", "stat", "fc", " fut", " feature"], "def": ["doc", "ef", "lit", "spec", "tx", "DEF", "decl", "crit", "list", "form", "defined", "dev", "df", "prop", "da", "d", "act", "vec", "block", "pos", "desc", "dep", "de", "cond", "fg", "conf", "fam", "info", "val", "du", "des", "Def", "definition", "tag", "fc", "pro", "ds", "define"]}}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return -errno;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n", "idx": 8254, "substitutes": {"bs": ["obs", "vs", "cks", "ats", "aos", "bp", "hs", "bes", "gs", "bc", "BS", "cs", "bm", "bits", "ses", "iss", "is", "js", "als", "ss", "bos", "its", "ts", "ils", "asis", "lbs", "ubs", "sb", "b", "bis", "bh", "acs", "ns", "bi", "fs", "bb", "ls", "ds"], "s": ["ms", "sq", "vs", "sl", "qs", "gets", "ats", "a", "eps", "rs", "hs", "p", "gs", "sts", "bes", "pers", "ps", " ss", "changes", "g", "cs", "l", "m", "bits", "ins", "sv", "es", "ses", "ies", "i", "args", "aws", "details", "is", "js", "less", "S", "ss", "ts", "n", "its", "als", "sports", "y", "t", "se", "v", "https", "os", "sb", "b", "e", "c", "bis", "ears", "h", "acs", "ns", "stats", "w", "fs", "des", "comm", "ls", "ims", "ds", "sys"], "sock": ["svox", "jsocked", "sender", "sinek", " socked", "sox", "desocked", "nsix", "hocket", "cip", "sck", "salocket", "wsice", "Sess", "ssocked", "svOCK", "lsck", "nsink", "lsip", "nsock", "sess", "nsck", "svock", "saloy", "sinocks", "hcp", "scp", "socket", "salip", "ssocket", "hoy", "sek", "wsocket", "tock", "servocket", "tsock", "Sck", "lsock", "hox", "tocks", "tocket", "nsig", "sot", "servock", "desice", " sox", " soy", "nock", "servocked", "sinip", "socked", "cOCK", "sinock", "tsocket", "socketocked", "sice", "wsocked", "socks", "Sig", "jsip", "salock", "nsess", "jsix", " sot", "cocket", "desock", "jsck", "socketock", " sck", " socket", "salOCK", "jsock", "socketender", "tsender", "sinocket", " sip", "jsocks", "sig", "ssender", "hot", "nip", "sink", "Sock", "jsocket", "hock", "rsock", " scp", "six", "sip", "sOCK", " sOCK", "jsek", "dsck", "jsink", " socks", "rsocks", "sinOCK", "tsocked", "nix", "dsess", "service", "svcp", "dsig", "rsocket", "salot", "ssock", "wsock", "sinocked", "hOCK", "soy", "socketocket", "nink", "tocked", "dsock", "desocket", "cock", "lsocket", "nsip", "rsocked"], "ret": ["tf", "len", "tr", "pas", " RET", "status", "pat", "nl", "reset", "back", "flag", "err", "det", "RET", "resp", "nt", "prot", "rev", "del", "inter", "mt", "fun", "git", "def", "usr", "alt", "ext", "cont", "sat", "t", "rem", "rets", "count", "deg", "arg", "val", "Ret", "ctr", "red", "cmd", "rt", "re", "elt", "res", "ber", "rm", "result", "att", "gt", "ll", "ft", "out"], "size": ["ms", "sym", "len", "empty", "num", "notice", "power", "send", "status", "use", "address", "sum", "sync", "code", "message", "format", "news", "izes", "export", "city", "area", "Size", "SIZE", "capacity", "scope", "timeout", "type", "args", "length", "window", "shell", "ize", "bytes", "addr", "mem", "storage", "owner", "data", "needed", "body", "mode", "count", "info", "since", "shape", "dim", "used", "scale", "sn", "fee", "equal", "space", "set", "memory", "time", "sized", "description", "name", "offset", "store"], "blocksize": [" blocksiz", "linesize", "bsiz", "bytesizer", "msized", "locksizer", "lockside", "locksIZE", "bsize", "msize", "idsiz", "blocksIZE", "locksize", "locksization", " blocksizer", "bsIZE", "idsizer", " blocksIZE", "bytesize", "locksiz", "linesization", "blockside", "msizer", "keysiz", "minsiz", "linesizer", "blocksized", "blocksizer", "ksized", "minsize", "idsization", "blocksization", "ksize", "keysize", "bytesiz", "keysization", "bsizer", "bytesization", "ksization", "minside", "idsize", "blocksiz", "msization", "keyside", "ksizer", "linesized", "minsization"]}}
{"project": "FFmpeg", "commit_id": "b52b398c30a729dda38c0dd5a0cdeef160c4ca54", "target": 0, "func": "static av_cold int vc2_encode_init(AVCodecContext *avctx)\n\n{\n\n    Plane *p;\n\n    SubBand *b;\n\n    int i, j, level, o, shift;\n\n    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    const int depth = fmt->comp[0].depth;\n\n    VC2EncContext *s = avctx->priv_data;\n\n\n\n    s->picture_number = 0;\n\n\n\n    /* Total allowed quantization range */\n\n    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;\n\n\n\n    s->ver.major = 2;\n\n    s->ver.minor = 0;\n\n    s->profile   = 3;\n\n    s->level     = 3;\n\n\n\n    s->base_vf   = -1;\n\n    s->strict_compliance = 1;\n\n\n\n    s->q_avg = 0;\n\n    s->slice_max_bytes = 0;\n\n    s->slice_min_bytes = 0;\n\n\n\n    /* Mark unknown as progressive */\n\n    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||\n\n                      (avctx->field_order == AV_FIELD_PROGRESSIVE));\n\n\n\n    for (i = 0; i < base_video_fmts_len; i++) {\n\n        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];\n\n        if (avctx->pix_fmt != fmt->pix_fmt)\n\n            continue;\n\n        if (avctx->time_base.num != fmt->time_base.num)\n\n            continue;\n\n        if (avctx->time_base.den != fmt->time_base.den)\n\n            continue;\n\n        if (avctx->width != fmt->width)\n\n            continue;\n\n        if (avctx->height != fmt->height)\n\n            continue;\n\n        if (s->interlaced != fmt->interlaced)\n\n            continue;\n\n        s->base_vf = i;\n\n        s->level   = base_video_fmts[i].level;\n\n        break;\n\n    }\n\n\n\n    if (s->interlaced)\n\n        av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\");\n\n\n\n    if ((s->slice_width  & (s->slice_width  - 1)) ||\n\n        (s->slice_height & (s->slice_height - 1))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if ((s->slice_width > avctx->width) ||\n\n        (s->slice_height > avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (s->base_vf <= 0) {\n\n        if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            s->strict_compliance = s->base_vf = 0;\n\n            av_log(avctx, AV_LOG_WARNING, \"Disabling strict compliance\\n\");\n\n        } else {\n\n            av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \"\n\n                   \"the specifications, please add a -strict -1 flag to use it\\n\");\n\n            return AVERROR_UNKNOWN;\n\n        }\n\n    } else {\n\n        av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\",\n\n               s->base_vf, base_video_fmts[s->base_vf].name);\n\n    }\n\n\n\n    /* Chroma subsampling */\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n\n\n    /* Bit depth and color range index */\n\n    if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 1;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG ||\n\n               avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) {\n\n        s->bpp = 1;\n\n        s->bpp_idx = 2;\n\n        s->diff_offset = 128;\n\n    } else if (depth == 10) {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 3;\n\n        s->diff_offset = 512;\n\n    } else {\n\n        s->bpp = 2;\n\n        s->bpp_idx = 4;\n\n        s->diff_offset = 2048;\n\n    }\n\n\n\n    /* Planes initialization */\n\n    for (i = 0; i < 3; i++) {\n\n        int w, h;\n\n        p = &s->plane[i];\n\n        p->width      = avctx->width  >> (i ? s->chroma_x_shift : 0);\n\n        p->height     = avctx->height >> (i ? s->chroma_y_shift : 0);\n\n        if (s->interlaced)\n\n            p->height >>= 1;\n\n        p->dwt_width  = w = FFALIGN(p->width,  (1 << s->wavelet_depth));\n\n        p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth));\n\n        p->coef_stride = FFALIGN(p->dwt_width, 32);\n\n        p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef));\n\n        if (!p->coef_buf)\n\n            goto alloc_fail;\n\n        for (level = s->wavelet_depth-1; level >= 0; level--) {\n\n            w = w >> 1;\n\n            h = h >> 1;\n\n            for (o = 0; o < 4; o++) {\n\n                b = &p->band[level][o];\n\n                b->width  = w;\n\n                b->height = h;\n\n                b->stride = p->coef_stride;\n\n                shift = (o > 1)*b->height*b->stride + (o & 1)*b->width;\n\n                b->buf = p->coef_buf + shift;\n\n            }\n\n        }\n\n\n\n        /* DWT init */\n\n        if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n\n                                      s->plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 8271, "substitutes": {"avctx": [" avcontext", "avconn", "avecontext", "navcu", "avsys", "avesys", "ravkt", "avcmd", "avaddr", "vrkt", "avecas", "avecu", "averconf", "averctx", "avcmp", "averjac", "avercfg", "avetx", "avetmp", "avpid", "avcas", "navcp", "Avconn", "avectl", "afconf", "wavctx", "avconf", "navctx", "avcontext", "afconn", "avergc", "vrctx", "Avctx", "navkw", "aveaddr", "wavcf", "ajtmp", "avercontext", "averkw", "ajpid", "averpid", "ajctx", "aveconn", "cvcontext", "avectx", " avconn", "afgc", "ajctl", "avtmp", "avcfg", "afcfg", "wavconn", " avtx", "avercf", "ajcontext", "avercmd", "wavtx", "avcu", "avermsg", "avkt", "ajjac", "avctl", "avcf", "afmsg", "avemsg", "afctx", "averctl", "varctx", "ravsys", "avekw", "averconn", "ravctx", "ajcmd", "vrtx", "avercp", "ajprop", "avecmd", "cvctx", "avgc", "wavcu", "varaddr", " avcmp", "avecf", "wavcmd", "ajsys", "Avtx", "aveconf", "wavctl", "avmsg", "wavcontext", "avegc", "avjac", "Avcontext", "avekt", "ravpid", "avecfg", "vartmp", "ravcmd", "averprop", " avkt", "avcp", "afcu", "avercas", "averkt", "avprop", "varctl", "aversys", "ravcas", "ajaddr", "avkw", "cvtx", "ravprop", "wavcmp", " avjac", "vrcontext", "avertx", "avecp", "avtx", "cvcmp", " avsys", "avercu"], "p": ["ph", "pc", "pe", "part", "a", "pp", "pt", "sp", "cp", "jp", "m", "l", "ap", "n", "P", "t", "v", "pr", "pl", "c", "pi", "pn", "pa"], "b": ["ba", "a", "base", "bp", "sub", "f", "B", "d", "bc", "g", "l", "m", "bs", "r", "n", "y", "t", "v", "e", "sb", "c", "bi", "z"], "i": ["key", "ami", "id", "u", "ai", "I", "me", "li", "ei", "init", "go", "ri", "ind", "ui", "ip", "g", "m", "l", "ori", "ki", "ti", "ic", "json", "cli", "in", "ish", "index", "mi", "r", "is", "ix", "n", "y", "t", "ci", "iu", "\u0438", "zi", "v", "info", "xi", "gu", "multi", "qi", "remote", "c", "gi", "bi", "di", "ij", "cgi", "pi", "si", "it", "x", "batch", "ini", " ii", " bi", "oi", "hi", "ji", "ims", "asi", "ii"], "j": ["bj", "aj", "jump", "J", "jc", "q", "k", "ind", "g", "jp", "pos", "l", "m", "jj", "index", "rel", "uj", "js", "n", "v", "oj", "z", "dj", "ji", "ij"], "level": ["key", "depth", "len", "stable", "status", "pe", "priority", "fl", "where", "lvl", "Level", "goal", "profile", "strength", "dev", "half", "report", "size", "scope", "label", "limit", "l", "vel", "type", "pos", "local", "score", "high", "quality", "pri", "loop", "family", "index", "rel", "stage", "version", "coll", "interface", "mode", "community", "levels", "state", "count", "lc", "val", "dim", "lock", "low", "scale", "title", "member", "tag", "color", "time", "group", "debug", "cost", "lo", "le", "loc", "offset", "length", "location"], "o": ["op", "off", "fo", "ao", "go", "iso", "ox", "ok", "m", "l", "ou", "oo", "n", "mode", "O", "os", "e", "ot", "po", "oe", "om", "oa", "lo", "offset", "out"], "shift": ["align", "depth", "sq", "hift", "Shift", "channel", "sch", "seek", "push", "pos", "ap", "shr", "sup", "share", "dq", "shape", "sh", "scale", "start", "si", "ul", "sc", "slice", "seed", "set", "offset", "dr", "ii"], "fmt": ["ptm", "funolt", "forformat", "vfm", "hMT", "flt", "fingformat", "dformat", "vlt", "fett", "vlux", " fett", " flt", "Fformat", "volt", "frett", " folt", "frmt", "funmt", "ptx", "frlux", "ftm", "vmt", "hmt", "flux", "pmt", "plt", "formmt", " fancy", "formancy", "folt", "ftx", "Ffm", "ferformat", "wmt", "fermt", " fpt", "fingmt", "ferlux", "ffm", "htx", " ftm", "vtx", "fpt", " ffm", "frformat", "fancy", "finglux", "dfm", "hformat", " flux", "funformat", "fformat", "dmt", "forlux", " fformat", "wformat", "frtm", " ftx", "vformat", "fMT", "fingMT", "forett", "formt", "frfm", "dtm", "vtm", " fMT", "funMT", "Fmt", "ferMT", "vMT", "Ftm", "formformat", "wpt", "formpt", "wancy"], "s": ["ms", "vs", "ats", "hs", "d", "m", "cs", "bits", "ins", "details", "r", "t", "sports", "os", "comm", "ims", "ers", "ports", "status", "settings", "tests", "gs", "sts", "changes", "g", "ies", "sv", "args", "ses", "mods", "bs", "services", "als", "less", "js", "ss", "sets", "e", "sb", "ls", "sq", "obj", "spec", "locks", "qs", "a", "rs", "as", "ants", "es", "terms", "ts", "n", "styles", "ns", "er", "ds", "comments", "eps", "uploads", "ps", "pers", "is", "S", "its", "v", "self", "c", "bis", "stats", "fs", "res", "actions", "set", "sys", "parts"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)\n\n{\n\n    int y;\n\n    uint8_t * fcode_tab= s->fcode_tab;\n\n\n\n    // RAL: 8 in MPEG-1, 16 in MPEG-4\n\n    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);\n\n\n\n    /* clip / convert to intra 16x16 type MVs */\n\n    for(y=0; y<s->mb_height; y++){\n\n        int x;\n\n        int xy= (y+1)* (s->mb_width+2)+1;\n\n        int i= y*s->mb_width;\n\n        for(x=0; x<s->mb_width; x++)\n\n            {\n\n            if (s->mb_type[i] & type)    // RAL: \"type\" test added...\n\n                {\n\n                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][0]>0) \n\n                        mv_table[xy][0]=  range-1;\n\n                    else\n\n                        mv_table[xy][0]= -range;\n\n                    }\n\n                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][1]>0) \n\n                        mv_table[xy][1]=  range-1;\n\n                    else                  \n\n                        mv_table[xy][1]= -range;\n\n            }\n\n            }\n\n            xy++;\n\n            i++;\n\n        }\n\n    }\n\n}\n", "idx": 8273, "substitutes": {"s": ["ms", "sq", "vs", "spec", "sl", "qs", "a", "ats", "rs", "als", "http", "as", "hs", "p", "gs", "sts", "ps", "cs", "m", "ins", "sv", "ses", "es", "bs", "aws", "r", "less", "js", "is", "S", "ss", "ts", "n", "its", "se", "t", "v", "conf", "ops", "e", "sb", "b", "c", "sw", "bis", "h", "ns", "stats", "w", "fs", "comm", "sis", "ls", "app", "ims", "space", "ds", "sys", "parts"], "mv_table": ["mV_map", "mvisttab", "mV_tab", "mek_record", "mv_tab", "mcv_table", "mv2buffer", "mv_collection", "mvv_table", "mvistdatabase", "mV_index", "mv_database", "mvv___table", "mvPstorage", "mv2index", "mvpttab", "mv_record", "mv___database", "mV_table", "mvistcollection", "mv_size", "mv_map", "mvPtab", "mv_queue", "mvacqueue", "mvc_tab", "mvv___tab", "mV_entry", "mv___table", "mv_stable", "mv__tab", "mvt_tmp", "mvt_collection", "mvptcount", "mvisttable", "mvv___size", "mV_encrypted", "mvv_size", "mvv___storage", "mcv_desc", "mv__table", "mcv_queue", "mvc_tmp", "mvc_table", "mvactable", "mvacdesc", "mV_stable", "mv_entry", "mvt_tab", "mv_encrypted", "mV_count", "mv_buffer", "mv2tab", "mv_storage", "mvc_database", "mvactab", "mv_count", "mvPsize", "mv_list", "mvpttable", "mek_table", "mv__map", "mv__found", "mv5stable", "mvt_table", "mv_tmp", "mV_database", "mV_buffer", "mv2db", "mek_tab", "mv_desc", "mvPtable", "mv_found", "mv___storage", "mv___size", "mV_db", "mcv_tab", "mvptentry", "mv_db", "mv5table", "mvv_storage", "mv2list", "mvv_tab", "mvisttmp", "mv___tab", "mV_found", "mv_index", "mv5tab", "mv2table", "mv5encrypted", "mV_list", "mv___tmp"], "f_code": ["rf_case", "f8Code", "f8codes", "sf_code", "rf_go", "fmytype", "fmyCode", " f__Code", "fmycode", "sf_type", "fmliccode", "sf__code", "fliccase", "fm_tag", "fjcode", "rf5code", "fmlicpage", "fliccode", "fliccoe", "fjgo", "f_tag", "flichello", "rf_hello", "sf__codes", "fmliccoe", "rf5hello", "fphpCode", "f__code", "fmCode", " f__version", "fmcode", "fm_page", " f_version", "fjcase", "f5hello", " f_Code", "f_codes", "f_coe", "f__type", " f_type", "sf_codes", "fmtype", "f8code", "f_hello", "flicgo", "fm_coe", "f8type", "fphpcodes", "flictag", "f5go", "f_type", "f_case", " f__code", "rf5go", "f__codes", "rf5case", "f__version", "fmyversion", "f5case", "fmlictag", "fmversion", " f__type", "f_version", "sf__Code", "f__Code", "fm_code", "sf__type", "fphptype", "fjhello", "rf_code", "f_page", "f5code", "f_Code", "sf_Code", "flicpage", "f_go", "fphpcode"], "type": ["typ", "status", "pe", "ty", "feature", "types", "role", "range", "to", "p", "f", "error", "unit", "field", "size", "TYPE", "length", "kind", "ver", "index", "r", "bit", "Type", "test", "t", "state", "count", "info", "ype", "tag", "color", "time", "name", "angle", "style"], "y": ["key", "aily", "py", "yt", "ya", "axy", "sky", "ty", "vy", "ady", "yy", "wy", "yi", "p", "height", "ay", "ry", "oy", "my", "ies", "ye", "yer", "iny", "ky", "dy", "ys", "row", "ley", "n", "icy", "t", "yr", "Y", "yo", "asy", "ey", "e", "b", "ly", "uy", "gy", "sy", "ot", "ym", "fy", "iy", "yx", "by", "z", "yl", "ny", "hy", "kit", "cy"], "fcode_tab": ["fclose_abs", "fcode_abs", "fcode___tab", "fcode_Tab", "fmap__stab", "fcodeopbt", "fcode_table", "fcode__table", "fcode32bag", "fcode_cache", "fcode32fab", "fode_table", "fcode_map", "fcodetbag", "fcode___tx", "fcode7tab", "fcode_cart", "fclose_tab", "fode_tab", "flinkoptab", "fmap__bt", "fode_cart", "fcodeopTab", "flink_tx", "fcodettab", "fcc_tab", "fcc2bag", "fcc_tag", "fmap_bag", "fode_Tab", "fcc_fab", "fcode_tag", "fcode_fab", "fco_tab", "fco_cache", "flinkopbt", "flink_bt", "fcode__stab", "fcode_bt", "fcode__map", "fcc2fab", "fclose_tool", "fcode32tag", "fcode2bag", "fcode32tab", "fcode_name", "fcc2tab", "fcc2tag", "fmap_tab", "flinkoptx", "fco_table", "fcode__bt", "fcode7abs", "fcode7tool", "fcode_stab", "fcode__bag", "fcode2tag", "fmap_bt", "fcode2fab", "fcc_bag", "fclose_name", "flinkopTab", "fmap_stab", "fcode_tool", "fcodeoptx", "fcode_tx", "flink_tab", "flink_Tab", "fcodetfab", "fcodettag", "fcode_bag", "fcode7name", "fcode___bt", "fmap__tab", "fcode__cache", "fco_map", "fmap__bag", "fcode___Tab", "fcode__tab", "fcode2tab", "fcodeoptab"], "x": ["key", "xp", "on", "tx", "ice", "mx", "a", "at", "nex", "q", "k", "p", "o", "ex", "ox", "dx", "xc", "xd", "m", "l", "wx", "X", "xxx", "inx", "lat", "ext", "index", "im", "ix", "rx", "n", "j", "px", "v", "xes", "xi", "iz", "e", "xt", "w", "xx", "zx", "yx", "php", "z", "ax", "fx", "xa", "el", "xe", "ux", "xf"], "xy": ["xp", "axy", "sky", "ie", "fo", "chan", "gay", "yy", "o", "ay", "ry", "linux", "bo", "yk", "fy", "iy", "hi", "ji", "dt", "key", "yt", "mx", "uxe", "ex", "note", "oy", "gone", "hello", "dy", "scroll", "try", "pei", "xi", "ey", "ym", "xx", "yz", "oe", "yx", "oxy", "batch", "xe", "XY", "wy", "zip", "dx", "my", "timeout", "xxx", "xxxx", "index", "phy", "zie", "ele", "px", "phi", "yo", "iz", "yout", "peer", "xxxxxxxx", "py", "zz", "sync", "qq", "io", "zy", "iso", "mie", "xc", "ox", "np", "wx", "te", "ye", "tif", "json", "bis", "zx", "coord", "mop"], "i": ["id", "u", "ai", "I", "io", "li", "p", "o", "f", "g", "m", "l", "ti", "ic", "index", "mi", "is", "j", "ix", "n", "ci", "phi", "v", "xi", "e", "c", "bi", "ij", "iy", "pi", "si", "it", " ii", "ii"]}}
{"project": "qemu", "commit_id": "524d18d8bd463431b120eeb5f9f3d1064a1c19e4", "target": 0, "func": "S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)\n\n{\n\n    S390CPU *cpu;\n\n    Error *err = NULL;\n\n\n\n    cpu = cpu_s390x_create(cpu_model, &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), core_id, \"core-id\", &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n\n\nout:\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n", "idx": 8291, "substitutes": {"cpu_model": ["cpu2type", "cpu2Model", " cpu_Model", " cpu_link", "cpu_models", "cpu_Model", " cpu_type", "pu_Model", "cpu_link", "pu_models", "pu_model", "pu_link", "cpu_type", "cpu2model", "cpu2link"], "core_id": ["core__ip", "cpu_ids", "core_ip", "core__type", "core_ids", "core__ref", "ore_ids", "cpu_id", "core_type", "ore_ref", "cpu_type", "core__ids", "core_ref", "ore_ip", "ore_id", "core__id"], "errp": ["scorem", "arrp", "arrpb", "scorepkg", " errpc", "arrm", "derbp", "errm", "errpb", "arrpc", "scorepb", "errbp", "errpc", "arrpkg", "arrP", "derpc", "errorpb", "errorp", "errpkg", "arrbp", " errbp", "derp", " errP", "derP", "errorpkg", "errP", "errorm", "scorep"], "cpu": ["ck", "rpm", "gpu", "prof", "thread", "alloc", "proc", "linux", "cs", "util", "queue", "clock", "bo", "cmd", "foo", "result", "memory", "cv", "hz", "bench", "aco", "tp", "ilo", "bean", "pu", "ni", "jp", "ka", "mu", "node", "aux", "que", "comp", "setup", "pid", "obj", "current", "cum", "pc", "runner", "processor", "device", "ach", "cp", "frame", "instance", "process", "met", "CPU", "mem", "phy", "ctx", "cn", "copy", "du", "hw", "gb", "uma", " cp", "out", " pc", "p", "ps", "pkg", "np", "lp", " CPU", "cli", "core", "boot", "cache", "gc", "c", "uu", "pause", "po", "cu", "sys"], "err": ["warn", "lr", " Err", " terr", "attr", "eor", "rr", "r", "fr", "wcs", "elt", "str", "fee", "rm", "result", "arr", "kr", "inner", "notice", "rb", "buf", "ex", "iter", "aaa", "rev", "cer", "gz", "ptr", "txt", "ger", "usr", "Er", "try", "rel", "js", "test", "conf", "e", "eas", "oc", "obj", "ef", "norm", "errors", "order", "ev", "resp", "error", "l", "rn", "later", "i", "mr", "term", "n", "ctx", "good", "die", "der", "ns", "er", "peer", "it", "exc", "timer", "out", "empty", "Error", "here", "erd", "p", "drm", "cb", "cli", "br", "cfg", "res", "coord", "msg", "dr", "sys"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n", "idx": 8296, "substitutes": {"deadline": ["faceline", "whenline", "dayliner", "offlock", "deadliner", " deadzone", "DeadLine", "offeline", "facline", "redlong", "newliner", "Deadlong", "whenlined", " deadeline", "offlined", "daylined", "facliner", "offline", "faclock", "newline", "deadzone", "deadlock", "deadlined", "offLine", "whenliner", " deadliner", "deadeline", "redLine", "whenLine", " deadlined", " deadlock", "redzone", " deadLine", " deadlong", "dayline", "dayLine", "newLine", "redline", "deadLine", "Deadzone", "offliner", "Deadline", "newlined", "deadlong"], "bh": ["lb", "ubb", "hal", "bj", "ah", "hr", "gh", "bf", "bp", "bel", "hs", "FH", "profile", "bl", "abb", "rob", "bc", "bm", "hl", "cb", "bn", "bs", "hh", "handle", "hold", "bg", "forth", "br", "pb", "body", "eb", "ctx", "ssl", "bang", "phi", "zh", "bo", "bol", "uh", "rh", "sb", "b", "sh", "bis", "h", "kh", "eth", "hole", "sbm", "ih", "hw", "bb", "hab", "broad", "batch", "nb", "nil", "bt", "dh", " inh", "lo", "history", "hz", "ht", "hub"]}}
{"project": "FFmpeg", "commit_id": "3beb9cbad35218ed1fb3473eeb3cfc97a931bff4", "target": 0, "func": "static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)\n\n{\n\n    int n=0, x, y, i;\n\n\n\n    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));\n\n\n\n    /* Map to the ROQ quadtree order */\n\n    for (y=0; y<enc->height; y+=16)\n\n        for (x=0; x<enc->width; x+=16)\n\n            for(i=0; i<4; i++) {\n\n                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;\n\n                tempData->cel_evals[n++].sourceY = y + (i&2)*4;\n\n            }\n\n}\n", "idx": 8313, "substitutes": {"enc": ["oc", "nec", "acc", "inc", "pc", "con", "et", "lang", "ack", "proc", "rec", "ec", "kt", "ENC", "ren", "nt", "Enc", "eng", "sec", "bc", "act", "desc", "en", "crypt", "pres", "cont", "coll", "ac", "ctx", "conn", "rc", "alg", "ang", "rh", "env", "c", "anc", "voc", "nc", "kw", "etc", "ent", "fc", "att", "exc", "conv", "ens"], "tempData": ["tempDo", "templateBu", "tempFile", " tempQuery", "empBu", "empData", "publicMemory", "tmpAppData", " tempMemory", "tmpDat", "tempMemory", " tempDo", "templateData", "empDo", "empFile", " tempDat", "tempDat", "empAppData", " tempDec", "empRecord", "empDat", " tempRecord", "tempAppData", "tmpDb", "tempQuery", "publicQuery", "publicDo", " tempAppData", "tempDb", "tempDec", "templateRecord", "publicFile", "tempBu", " tempDb", " tempBu", "empQuery", "publicDec", "publicAppData", "empDec", "empMemory", "empDb", "tmpData", " tempFile", "tempRecord", "publicData"], "x": ["key", "xp", "on", "xy", "tx", "mx", "at", "text", "pt", "column", "q", "ct", "axis", "p", "o", "f", "ex", "ox", "dx", "xc", "g", "xd", "m", "l", "wx", "X", "xs", "inx", "lat", "ce", "ext", "try", "rx", "ix", "px", "v", "xi", "e", "xt", "w", "xx", "zx", "yx", "pi", "xml", "php", "fx", "ax", "xa", "att", "el", "xe", "rex", "xf"], "y": ["aily", "yt", "py", "xy", "ya", "axy", "sky", "ty", "vy", "ady", "yy", "yi", "wy", "height", "ay", "ry", "yn", "oy", "my", "ies", "ye", "yer", "iny", "dy", "n", "yr", "Y", "yo", "asy", "ey", "ly", "uy", "gy", "sy", "fy", "ot", "yet", "ym", "iy", "yx", "sys", "by", "yl", "ny", "hy", "cy"], "i": ["ami", "id", "ai", "fi", "status", "I", "io", "me", "li", "ei", "iq", "ri", "ii", "sim", "ind", "ui", "ni", "ip", "jp", "m", "ki", "ti", "ic", "cli", "in", "mi", "index", "is", "j", "im", "ix", "n", "mc", "iu", "ci", "\u0438", "zi", "v", "phi", "info", "xi", "qi", "multi", "gi", "bi", "di", "pi", "si", "it", "ini", "hi", "s", "ji", "conv", "asi", "ij"]}}
{"project": "FFmpeg", "commit_id": "273e6af47b38391f2bcc157cca0423fe7fcbf55c", "target": 0, "func": "static int ea_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    EaDemuxContext *ea = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    int packet_read = 0;\n\n    unsigned int chunk_type, chunk_size;\n\n    int key = 0;\n\n    int av_uninit(num_samples);\n\n\n\n    while (!packet_read) {\n\n        chunk_type = avio_rl32(pb);\n\n        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;\n\n\n\n        switch (chunk_type) {\n\n        /* audio data */\n\n        case ISNh_TAG:\n\n            /* header chunk also contains data; skip over the header portion*/\n\n            avio_skip(pb, 32);\n\n            chunk_size -= 32;\n\n        case ISNd_TAG:\n\n        case SCDl_TAG:\n\n        case SNDC_TAG:\n\n        case SDEN_TAG:\n\n            if (!ea->audio_codec) {\n\n                avio_skip(pb, chunk_size);\n\n                break;\n\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n\n                       ea->audio_codec == CODEC_ID_MP3) {\n\n                num_samples = avio_rl32(pb);\n\n                avio_skip(pb, 8);\n\n                chunk_size -= 12;\n\n            }\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->audio_stream_index;\n\n\n\n            switch (ea->audio_codec) {\n\n            case CODEC_ID_ADPCM_EA:\n\n            case CODEC_ID_ADPCM_EA_R1:\n\n            case CODEC_ID_ADPCM_EA_R2:\n\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n                pkt->duration = AV_RL32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_EA_R3:\n\n                pkt->duration = AV_RB32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n                pkt->duration = ret * 2 / ea->num_channels;\n\n                break;\n\n            case CODEC_ID_PCM_S16LE_PLANAR:\n\n            case CODEC_ID_MP3:\n\n                pkt->duration = num_samples;\n\n                break;\n\n            default:\n\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n\n            }\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        /* ending tag */\n\n        case 0:\n\n        case ISNe_TAG:\n\n        case SCEl_TAG:\n\n        case SEND_TAG:\n\n        case SEEN_TAG:\n\n            ret = AVERROR(EIO);\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case MVIh_TAG:\n\n        case kVGT_TAG:\n\n        case pQGT_TAG:\n\n        case TGQs_TAG:\n\n        case MADk_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MVIf_TAG:\n\n        case fVGT_TAG:\n\n        case MADm_TAG:\n\n        case MADe_TAG:\n\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n\n            chunk_size += 8;\n\n            goto get_video_packet;\n\n\n\n        case mTCD_TAG:\n\n            avio_skip(pb, 8);  // skip ea dct header\n\n            chunk_size -= 8;\n\n            goto get_video_packet;\n\n\n\n        case MV0K_TAG:\n\n        case MPCh_TAG:\n\n        case pIQT_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MV0F_TAG:\n\nget_video_packet:\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->video_stream_index;\n\n            pkt->flags |= key;\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            avio_skip(pb, chunk_size);\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8340, "substitutes": {"s": ["sq", "a", "ats", "rs", "as", "hs", "sg", "gs", "sts", "p", "ec", "ps", "cs", "ins", "es", "ses", "xs", "bs", "aws", "less", "js", "S", "ss", "ts", "n", "t", "v", "e", "os", "has", "sb", "c", "b", "ns", "fs", "set", "ls", "ds", "sys"], "pkt": [" packet", " pelt", "prkt", "tpux", "npmsg", " pkg", "cpnt", "prconn", "Pkt", "epelt", "pqt", "pmsg", "patett", "ppacket", "cpkt", " pmsg", "pingelt", " ptt", "perkt", "paux", "pnt", "cpqt", "Pnt", "pst", " pett", "pingtt", " pqt", "pracket", "pconn", "hkt", "npkt", "pux", " pconn", "tpacket", "epacket", "prkg", "pwk", "wkl", "patwk", "eptt", "ppqt", "hconn", "ppkt", "pt", "hacket", "tpkt", "prokg", "ppt", "ppkg", "pelt", "promsg", " pt", "prokt", "wett", "epkt", "packet", "pakt", "psnt", " pwk", "pskt", "psacket", "perkg", "pkl", "cpkg", "patkl", "tpwk", "hkg", "ppnt", "pingacket", "wwk", "permsg", " pux", "ptt", "proacket", "npkg", "npacket", "pernt", "pkg", "pingkt", " pnt", "pawk", "patkt", "pett", "paacket", "Pkg", "wkt", "Pmsg", " pkl"], "ea": ["ota", "era", "ef", "je", "na", "ja", "et", "gae", "ie", "ei", "gp", "deb", "ee", "eh", "area", "ec", "eta", "rep", "au", "eur", "cp", "ne", "eni", "aaa", "chart", "jp", "ae", "ra", "ata", "exe", "note", "hd", "anza", "cb", "ia", "ean", "qa", "fa", "ega", "ew", "eg", "ta", "eval", "ma", "eb", "ele", "ctx", "e", "ace", "eas", "apache", "ena", "exec", "eu", "sa", "elt", "eric", "aria", "enda", "EA", "eeee", "ze", "raf", "oa", "adata", "ez", "el", "aa", "iera", "ar", "za", "ca", "af", "pa"], "pb": ["td", "tm", "tf", "obj", "apy", "bj", "tx", "typ", "pc", "tp", "ub", "mb", "pp", "pt", "gp", "uf", "bp", "rb", "tk", "pan", "span", "proc", "uv", "p", "sp", "buf", "tg", "resp", "ng", "cp", "fp", "pool", "pg", "vp", "jp", "pkg", "tc", "np", "ap", "mt", "cb", "orp", "lp", "bs", "txt", "pm", "snap", "emb", "eb", "ctx", "px", "bps", "erb", "patch", "pl", "gc", "sb", "wp", "tmp", "sys", "dp", "ob", "PB", "gb", "oa", "mp", "soc", "pid", "wb", "pa"], "chunk_type": ["chunk_Type", "chunk___typ", "chunks_start", "chunkityType", "chunks_template", "chunk_set", "chunkairtype", "chunkTypeid", "chunk_id", "chunkTypetype", "chunkairsize", "chunkityset", "chunk_template", "chunk___Type", "chunkairstart", "chunk___type", "chunkTypetag", "chunkairtemplate", "chunk_start", "chunkitytype", "chunkitytyp", "chunk_tag", "chunk_typ", "chunkTypesize", "chunks_size", "chunks_type", "chunk___set"], "chunk_size": ["chunk_number", "chunks_name", "chrain_Size", "chachment_term", "chrain_size", "chunk_len", "chunk_name", "chunk_body", "chachment_size", "chunk8num", "chrain_depth", "chunk_Size", "chunks_type", "chunk64Size", "chunk_depth", "chunklexcapacity", "chunk8data", "chrain_body", "chunks_string", "chunk8Size", "chunk_num", "chunk_term", "chunk64type", "chunks_Size", "chachment_len", "chunk_string", "chachment_type", "chunk8size", "chunk64name", "chunk_capacity", "chunk64size", "chunklexstring", "chunklexsize", "chunk_data", "chunklexSize", "chunks_capacity", "chunks_size"]}}
{"project": "qemu", "commit_id": "b061dc41f62048acd4a34c6570c0ea396cd9d0b4", "target": 1, "func": "static void type_initialize_interface(TypeImpl *ti, const char *parent)\n\n{\n\n    InterfaceClass *new_iface;\n\n    TypeInfo info = { };\n\n    TypeImpl *iface_impl;\n\n\n\n    info.parent = parent;\n\n    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);\n\n    info.abstract = true;\n\n\n\n    iface_impl = type_register(&info);\n\n    type_initialize(iface_impl);\n\n    g_free((char *)info.name);\n\n\n\n    new_iface = (InterfaceClass *)iface_impl->class;\n\n    new_iface->concrete_class = ti->class;\n\n\n\n    ti->class->interfaces = g_slist_append(ti->class->interfaces,\n\n                                           iface_impl->class);\n\n}\n", "idx": 8357, "substitutes": {"ti": ["tm", "tt", "ami", "uti", "ai", "fi", "tp", "ati", "sci", "fo", "tre", "ty", "ita", "li", "ei", "vi", "tk", "yi", "ri", "wi", "ni", "iat", "tile", "te", "ki", "i", "ite", "vt", "tif", "cci", "mi", "qt", "ta", "ski", "iti", "t", "ci", "tis", "wt", "di", "bi", "tip", "pi", "si", "TI", "hi", "tto", "tv", "ii"], "parent": ["id", "spec", "pc", "cmp", "father", "part", "path", "source", "prefix", "list", "child", "to", "file", "form", "p", "sp", "pool", "value", "home", "Parent", "unit", "point", "iat", "gr", "instance", "parents", "g", "scope", "m", "type", "client", "ref", "ip", "port", "txt", "term", "family", "server", "max", "snap", "owner", "global", "root", "ma", "paren", "t", "ctx", "self", "class", "shape", "via", "mother", "master", "target", "origin", "tip", "help", "peer", "by", "public", "module", "name", "pid", "template", "out", "mt"], "new_iface": ["new_Ifface", "new_interface", "new_ifac", "new_ilaces", "new__itac", "new_ifaces", "new__ifac", "new__itaces", "new__iface", "new__itace", "new_itaces", "new_ifest", "new__ifface", "new_itac", "new__ifaces", "new__itface", "new_ipface", "new_iaces", "new_Ifac", "new_itest", "new_ilace", "new_iac", "new_iacket", "new_itace", "new_interace", "new_ifacket", "new_ilac", "new_interac", "new_ipacket", "new_interest", "new_ifface", "new_itface", "new_ilacket", "new_Iface", "new_iace", "new_ipace", "new_ipac", "new_Ifaces", "new_ipaces"], "iface_impl": ["iface_inner", "iface_ind", "iface2impl", "ifinterface_inner", "iframe_ind", "iface2inner", "iface_obj", "ifrace_pl", "iframe_impl", "iface____imp", "ifinterface_Impl", "ifrace_Impl", "iface_im", "ifrace_obj", "iframe_Impl", "iface_rel", "ifrace_imp", "iface_expl", "ifac_expl", "ifinterface2inner", "iface_pl", "iface_Impl", "ifinterface2im", "iface2im", "ifac_rel", "ifac_inner", "ifinterface2impl", "ifinterface2Impl", "ifinterface_impl", "iface____Impl", "ifrace_impl", "iface____impl", "iface2Impl", "ifac_impl", "iface_imp", "ifinterface_im"]}}
{"project": "FFmpeg", "commit_id": "c97f54020d5d55511e28622551f13233bd8ceb56", "target": 0, "func": "static int video_open(VideoState *is){\n\n    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    int w,h;\n\n\n\n    if(is_full_screen) flags |= SDL_FULLSCREEN;\n\n    else               flags |= SDL_RESIZABLE;\n\n\n\n    if (is_full_screen && fs_screen_width) {\n\n        w = fs_screen_width;\n\n        h = fs_screen_height;\n\n    } else if(!is_full_screen && screen_width){\n\n        w = screen_width;\n\n        h = screen_height;\n\n    }else if (is->video_st && is->video_st->codec->width){\n\n        w = is->video_st->codec->width;\n\n        h = is->video_st->codec->height;\n\n    } else {\n\n        w = 640;\n\n        h = 480;\n\n    }\n\n#ifndef SYS_DARWIN\n\n    screen = SDL_SetVideoMode(w, h, 0, flags);\n\n#else\n\n    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */\n\n    screen = SDL_SetVideoMode(w, h, 24, flags);\n\n#endif\n\n    if (!screen) {\n\n        fprintf(stderr, \"SDL: could not set video mode - exiting\\n\");\n\n        return -1;\n\n    }\n\n    SDL_WM_SetCaption(\"FFplay\", \"FFplay\");\n\n\n\n    is->width = screen->w;\n\n    is->height = screen->h;\n\n\n\n    return 0;\n\n}\n", "idx": 8370, "substitutes": {"is": ["ms", "ports", "isi", "ists", "id", "num", "IS", "rs", "or", "isl", "does", "ires", "ri", "sim", "isal", "mis", "bits", "ins", "ois", "i", "dis", "bs", "terms", "iss", "ris", "us", "in", "mi", "js", "isc", "ss", "its", "isa", "ais", "plays", "details", "ist", "im", "isp", "ics", "info", "tis", "os", "has", "ips", "iris", "bis", "any", "times", "fs", "isin", "was", "it", "lis", "sis", "ls", "s", "Is", "oss", "are", "ims", "parts"], "w": ["ow", "xp", "wall", "fw", "ww", "iw", "wal", "q", "wy", "weight", "wi", "p", "we", "widget", "W", "wid", "words", "ex", "f", "wm", "d", "wr", "rw", "g", "l", "m", "wx", "i", "win", "window", "wh", "en", "word", "raw", "wa", "ew", "r", "wl", "t", "wn", "wd", "v", "aw", "sw", "wt", "wp", "rew", "hw", "kw", "x", "z", "el", "s", "max", "nw", "wb"], "h": ["he", "H", "ah", "ph", "hr", "hm", "a", "ch", " H", "q", "eh", "em", "k", "p", "hash", "height", "f", "d", "th", "g", "m", "l", "hd", "hl", "i", "length", "wh", "oh", "en", "window", "hh", "ish", "j", "html", "y", "t", "v", "uh", "rh", "host", "b", "c", "sh", "kh", "bh", "ih", "hang", "it", "z", "hi", "dh", "s", "max", "history", "high", "hz", "ht"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    struct nand_state_t *s = opaque;\n\n    uint32_t r;\n\n    int rdy;\n\n\n\n    r = nand_getio(s->nand);\n\n    nand_getpins(s->nand, &rdy);\n\n    s->rdy = rdy;\n\n\n\n    DNAND(printf(\"%s addr=%x r=%x\\n\", __func__, addr, r));\n\n    return r;\n\n}\n", "idx": 8380, "substitutes": {"opaque": ["pacity", "olay", "oca", "OPacity", "opsacity", "oplay", " opatile", "opsaque", "OPaque", "oaque", "oacity", "pca", " opacity", "paque", "popca", " opdoor", "opca", "play", "popacity", "OPatile", "opsatile", "poplay", "opdoor", "OPdoor", "popaque", "opatile", "opacity", "opsdoor"], "addr": ["src", "work", "obj", "on", "tx", "id", "address", "at", "add", "Address", "a", "err", "alloc", "ack", "asm", "to", "kt", "var", " address", "pad", "act", "pos", "ref", "inter", "attr", "ptr", "adr", "ord", "ix", "ad", "ctx", "cmd", "eth", "hw", "coord", "msg", "dh", "offset", "dr", "mt", "store"], "size": ["align", "len", "num", "id", "address", " offset", "message", "weight", "area", "Size", "SIZE", "l", "type", "args", "ize", "mem", "n", "count", "shape", "h", "w", "z", "name", "offset", "length", " length"], "s": ["sq", "spec", "sl", "status", "qs", "a", "sol", "rs", "asm", "hs", "p", "gs", "sts", "sp", "sm", "ps", " ss", "sv", "es", "ses", "sam", "bs", "less", "js", "S", "ss", "ts", "se", "n", "y", "is", "t", "state", "conf", "self", "ops", "sb", "b", "c", "h", "ns", "stats", "fs", "comm", "set", "ls", "space", "ds", "sys", "store"], "r": [" R", "u", "lr", "rb", "rs", "q", "err", "or", "p", "rf", "d", "rw", "g", "l", "rn", "i", "mr", "ptr", "rr", " rg", "rx", "n", "t", "rc", "rd", "nr", "v", "pr", "e", "b", "c", "h", "rt", "re", "sr", "w", "res", "er", "str", "rm", "x", "result", "it", "vr", "R", "cr", "rar", "ar", "dr", "out"], "rdy": ["ldry", "ndy", "rwy", "rdY", "redey", "rwi", "rwdy", "ridey", "rdx", "bindY", "ldy", "rownyn", "rwY", "ndi", "ldi", "rddy", "irdy", "rdey", "rowny", "ridy", "rdyn", "bindy", "redy", "ndry", "redx", "rdry", "irdry", "irdey", "ridyn", "rody", "rodyn", "ldey", "rowni", "ldx", "rwey", "rowndy", "rodi", "ndey", "roddy", "redi", "bindyn", "irdi", "bindey", "ridi", "ridx", "rwyn", "rdi", "ridY"]}}
{"project": "qemu", "commit_id": "442773cef15092b5927851237850760345d2cf16", "target": 0, "func": "void qmp_migrate_set_speed(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s;\n\n\n\n    if (value < 0) {\n\n        value = 0;\n\n    }\n\n\n\n    s = migrate_get_current();\n\n    s->bandwidth_limit = value;\n\n    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);\n\n}\n", "idx": 8409, "substitutes": {"value": ["command", "key", "power", "current", " voltage", "use", "priority", "weight", "area", "we", "number", "field", "unit", "maximum", "volume", "name", "limit", "type", "zero", "values", "position", "please", "sequence", "save", "efficiency", "length", "json", "hello", "sv", "function", "index", "attribute", "property", "max", " Value", "create", "data", "test", "total", "version", "now", "state", "new", "v", " v", "VALUE", "unknown", "input", "val", "expression", "Value", "scale", "fee", "operator", "php", "speed", "time", "description", "initial", "pain", "size", "ue"], "errp": ["errP", " errP", " errps", "Erp", "Erps", "errps", "erP", "ErP", "erps", "erp"], "s": ["sq", "spec", "sync", "sl", "status", "qs", "ats", "eps", "rs", "hs", "sp", "gs", "sts", "p", "sm", "south", "ps", "m", "service", "l", "ds", "sv", "es", "ses", "sam", "save", "bs", "session", "so", "services", "aws", "is", "js", "S", "ss", "ts", "se", "t", "sports", "v", "info", "os", "sb", "b", "c", "h", "sa", "ns", "stats", "fs", "serv", "stat", "comm", "set", "ls", "states", "state", "su", "sys", "store"]}}
{"project": "qemu", "commit_id": "3d5d319e1221082974711af1d09d82f0755c1698", "target": 1, "func": "void block_job_resume_all(void)\n\n{\n\n    BlockJob *job = NULL;\n\n    while ((job = block_job_next(job))) {\n\n        AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n        aio_context_acquire(aio_context);\n\n        block_job_resume(job);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n", "idx": 8412, "substitutes": {"job": ["command", "obs", "run", "op", "entry", "status", "runner", "jump", "config", "call", "kick", "base", "jo", "up", "cell", "em", "build", "event", "anim", "task", "gov", "sim", "cp", "worker", "brain", "rob", "normal", "block", "jp", "process", "tab", "bing", "session", "json", "jj", "try", "row", "j", "JO", "node", "emb", "one", "journal", "info", "unknown", "b", "lock", "cmd", "com", "pro", "exec", "member", "grab", "bot", "serv", "bug", "ob", "batch", "game", "item", "msg", "bar", "user", "name", "Job", "work", "state", "ann", "out"], "aio_context": ["aiotcondition", "aiao_handle", "aioacctx", "aync_client", "aaoacctx", "aioachistory", "aync_condition", "aio_work", "aync_context", "aio_condition", "aiotcontext", "aiooppath", "aao_ctx", "aio_handle", "aiotwork", "aao_history", "aio_path", "aioopcontext", "aio_history", "aao_context", "aioophandle", "aio_ctx", "aiao_path", "aio_config", "aioaccontext", "aiotclient", "aio_client", "aaoacconfig", "aao_config", "aiao_client", "aaoaccontext", "aiao_context", "aaoachistory", "aioopclient", "aync_work", "aioacconfig"]}}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static int write_option(void *optctx, const OptionDef *po, const char *opt,\n\n                        const char *arg)\n\n{\n\n    /* new-style options contain an offset into optctx, old-style address of\n\n     * a global var*/\n\n    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?\n\n                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;\n\n    int *dstcount;\n\n\n\n    if (po->flags & OPT_SPEC) {\n\n        SpecifierOpt **so = dst;\n\n        char *p = strchr(opt, ':');\n\n\n\n        dstcount = (int *)(so + 1);\n\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n\n        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : \"\");\n\n        dst = &(*so)[*dstcount - 1].u;\n\n    }\n\n\n\n    if (po->flags & OPT_STRING) {\n\n        char *str;\n\n        str = av_strdup(arg);\n\n        av_freep(dst);\n\n        *(char **)dst = str;\n\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n\n    } else if (po->flags & OPT_INT64) {\n\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n\n    } else if (po->flags & OPT_TIME) {\n\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n\n    } else if (po->flags & OPT_FLOAT) {\n\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n\n    } else if (po->flags & OPT_DOUBLE) {\n\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n\n    } else if (po->u.func_arg) {\n\n        int ret = po->u.func_arg(optctx, opt, arg);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR,\n\n                   \"Failed to set value '%s' for option '%s'\\n\", arg, opt);\n\n            return ret;\n\n        }\n\n    }\n\n    if (po->flags & OPT_EXIT)\n\n        exit_program(0);\n\n\n\n    return 0;\n\n}\n", "idx": 8425, "substitutes": {"optctx": ["optx", "optcontext", "optioncontext", "optobj", "opobj", "opcontext", "oppkg", "optionctx", "optiontx", "optionobj", "optpkg", " optcontext", " optobj", "opttx", " optpkg", "optionpkg", " opttx", "opctx"], "po": ["ota", "py", "obj", "aco", "ko", "mot", "pc", "pe", "fo", "policy", "pt", "pp", "jo", "ao", "go", "cro", "o", "odo", "pg", "PO", "flo", "mo", "Po", "pos", "ico", "pd", "ano", "opa", "ote", "yes", "ho", "ppo", "apo", "cho", "oo", "ta", "pm", "roo", "ctx", "O", "hea", "bo", "yo", "pr", "pot", "pre", "quote", "oe", "pi", "cu", "co", "gro", "lo", "no", "vo", "pro", "pty", "pa"], "opt": ["obj", "op", "oop", "lit", "lt", "spec", "off", "tx", "text", "pt", "crit", "init", "anon", "Opt", "sp", "buf", "prop", "var", "pred", "nt", "iter", "cat", "jp", "pkg", "ref", "timeout", "attr", "def", "other", "grad", "urg", "txt", "usr", "term", "alt", "ext", "expr", "j", "t", "riot", "info", "pr", "OP", "pot", "feat", "cmd", "ost", "option", "orig", "rt", "kw", "og", "tip", "tag", "stat", "it", "org", "msg", "oss", "img", "ret"], "arg": ["arr", "doc", " larg", "op", "pat", "arp", "call", "par", "req", "event", "ack", "star", "var", "argument", "agg", "g", "ref", "other", "attr", "args", "word", "parse", "urg", "usr", "addr", "ext", "mem", "r", "j", " targ", "Arg", "ad", "aux", "reg", "v", "alg", "conf", "val", "cmd", "target", "orig", "ag", "asc", "tag", "help", "it", "mac", "org", "ax", "param", "gt", "msg", "pack", "ar", "vol", "ret"], "dst": ["dnd", " dsp", " dint", " dirst", "dnet", "wdest", "didnd", "dsp", "dsdest", "dbST", " dynamic", "doost", "daost", "deirst", "dast", "didst", "dednd", "Dbl", "dadest", "dport", " dist", "dist", "Ddest", "dudest", "dint", "wst", "edost", " dport", "dsst", "daST", " dST", "dST", "Dstr", "dbirst", " dpt", "delst", " dsrc", "didnet", "duST", " ddest", "dosts", "dosp", "diddest", "dsest", "doST", "dsstr", "dssts", "deddest", "Dst", "dbl", "ddest", "dasts", "dirst", "Dnet", "dolas", "wist", " dbl", "Dpt", "Dnd", "Dist", "dust", "dednet", "delest", "DST", "edst", "daport", "deST", "Dint", " dstr", "edlas", "dsts", "dedest", "Dsts", " dest", "Dsrc", "delynamic", "daest", " dsts", "dlas", "daynamic", "dedst", "dbst", "Dsp", "dbdest", "delsts", "dpt", "dstr", "dalas", "dest", "duport", "dsrc", "dssrc", "dsbl", "wpt", "Dest", "dost", "daint", "dynamic", "edST"], "dstcount": ["dstsount", "ddestoffset", "Dstinfo", "dstrlength", "dputCount", " dstCount", "dstinfo", "ddestctr", "dstfind", "dndCount", "DstsCount", "ddestpage", "dndfind", "dconstlength", "dspcount", "destcount", "distcount", "dstsCount", "Dstamount", "dstlength", " dconstlength", "Dstsamount", "destamount", "Dstlength", "Ddestcount", "dstreamctr", "dconstCount", "dstsfind", "dcosCount", "dstsinfo", "Dstslength", "distCount", "dndcount", "dstctr", "dstoffset", "dstreamoffset", "dconstpage", "dstsamount", "dstslength", " dconstcount", " dconstpage", "dintlength", "dspamount", "Dstoffset", "Dstscount", "dputpage", "dintinfo", "Dstfind", "dcoslength", "Dstsount", "dstreamcount", "distfind", "Dstsfind", "dndount", "dsplength", "dstount", "dspCount", "dsetCount", "Dstrcount", "Dstount", "distount", "DstCount", "dsetoffset", "dputcount", "dstpage", "dsetcount", "Dstrlength", "Dstctr", "Dstcount", " dstlength", "ddestCount", "dintcount", "dstrCount", "dstreamCount", "DdestCount", "dstrcount", "dcosinfo", " dstpage", "destlength", "Ddestoffset", "dstscount", "dcoscount", "dintCount", "dputlength", "dconstcount", "dsetctr", "ddestcount", "dstCount", "dstamount", " dconstCount", "DstrCount", "destCount", "ddestlength", "Dstsinfo", "Ddestctr"], "so": ["So", "sq", "goo", "sync", "sl", "sky", "fo", "go", "loc", "sels", "sp", "o", "iso", "sm", "igh", "mo", "oid", "cs", "osp", "sam", "yes", "bs", "mi", "stro", "js", "se", "ski", "pb", "ssl", "bo", "since", "sty", "os", "sw", "sh", "tmp", "ism", "sie", "sa", "ost", "sel", "stri", "si", "st", "sc", "cu", "set", "co", "ls", "s", "sk", "lo", "SO", "pro", "soc", "su", "ico"], "p": ["xp", "imp", "ph", "op", "u", "tp", "pe", "a", "pp", "q", "ping", "sp", "o", "f", "ps", "fp", "cp", "ip", "g", "pkg", "m", "vp", "np", "jp", "ap", "l", "i", "lp", "r", "j", "n", "pb", "t", "P", "v", "b", "c", "wp", "pun", "dp", "php", "it", "s", "pa"], "str": ["arr", "obj", "tr", "spec", "text", "vol", "Str", "err", "print", "enc", "sp", "var", "bl", "rep", "f", "star", "ps", "buf", "cat", "cs", "txt", "r", "cont", "data", "coll", "n", "t", "v", "fr", "pr", "ctr", "c", "sw", "ns", "w", "st", "x", "set", "STR", "s", "String", "name", "dr", "out", "ret"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n", "idx": 8431, "substitutes": {"f": ["tf", "ef", "fd", "fw", "fi", "bf", "a", "uf", "q", "ile", "file", "form", "p", "df", "fp", "cf", "fm", "d", "elf", "g", "l", "m", "fb", "i", "fe", "lf", "r", "t", "conf", "fr", "e", "b", "c", "fac", "h", "F", "w", "fs", "fc", "af"], "pv": ["PV", " pvt", "pbvr", "mpv", "ppvt", "ppj", "mpvr", "pbV", "pvr", "pvt", "pbv", "pV", " pV", "Pvt", " pj", "mpvt", "ppv", "Pv", "pbvt", "mpV", "Pvr", "ppV", "Pj", "pj"], "size": [" space", "len", " st", " sizes", " count", " offset", " unused", " scale", " sh", " Size", " notice", "Size", "SIZE", "length", "ize", "_", " enc", "e", "shape", "fee", " sized", "s", "space", " shr", " len"], "v": ["vs", "u", "av", "vi", "q", "ev", "ov", "uv", "p", "value", "wire", "lv", "vp", "g", "m", "l", "sv", "i", "vt", "inv", "r", "j", "n", "y", "t", "tv", "V", "b", "c", "w", "vr", "cv", "s", "iv", "vm", "nv", "vol"]}}
{"project": "qemu", "commit_id": "61a36c9b5a12889994e6c45f4a175efcd63936db", "target": 1, "func": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 8435, "substitutes": {"cpu": ["bench", "aco", "rpm", "pc", "tp", "gpu", "socket", "upt", "processor", "device", "gnu", "cam", "bean", "nu", "proc", "java", "pool", "cp", "pu", "linux", "xc", "jp", "process", "np", "docker", "ctl", "util", "cc", "ka", "cli", "pai", "CPU", "core", "clock", "mem", "ctx", "conn", "ork", "gc", "apache", "c", "cn", "cmd", "hw", "nc", "cu", "onet", "stat", "kernel", "phys", "dh", "disk", "vm", "dt", "hog", "sys"], "ptex": ["aptEX", "plrex", "iptx", "usttex", "iptex", "ptexe", "ctex", "aptEx", "ptontex", "ptel", "ptrex", "aptex", "ustex", "iptEx", "ptonex", "pttex", "ipttex", "eptel", "ptEX", "pointEX", "petex", "iptEX", "ptEx", "onetrex", "eptex", " uptex", "PTexp", "iptpex", "petEx", "onettex", "PTel", "eptexp", "ctEx", " uptEx", "petexe", "petEX", "counttex", " ptEx", "ustEx", " uptx", "pointexe", "ptexp", "ptpex", "countex", "plex", "ustEX", "epttex", " uptpex", "ptx", "apttex", "PTex", "pointex", "onetex", "PTtex", "countexp", "pointEx", "ctexe", "ctEX", "countel", "pltex", " ptpex", " ptx", "ptonrex"], "avpn": ["avn", "vrPN", "averpc", "svpn", " avpa", "avPN", "ovpn", "ajPN", "svpc", "vpn", "ovpa", "Avpn", "AvPN", "svpa", "svn", "averpn", "ajpn", "abpn", "avpa", " avpc", "ajpa", "abPN", "abpa", "visen", "avisen", "averpa", "ovPN", "avp", "avern", "vPN", "ovpc", "ajpc", "avpc", " avn", "abpc", "vrpn", "vrisen", "Avp", "Avisen", "vrp"], "flags": ["abilities", "aps", "vs", " Flags", "Flags", "locks", "fl", "ffff", "flag", "weights", "settings", "rs", "wind", "ff", "goal", "ps", "words", "atts", "pages", "files", "bits", "pins", "values", "args", "fps", "heads", "members", "mask", "txt", "ts", "lag", "links", "ags", "fields", "assets", "sets", "fr", "wcs", "limits", "tags", "cmd", "fs", "res", "options", "vals", "checks", "actions", "features", "buff", "allows", "parts"], "vp": ["vs", "vert", "tp", "avi", "av", "ev", "vu", "vv", "ov", "uv", "ve", "p", "vc", "buf", "fp", "pes", "lv", "vP", "qv", "sv", "vt", "lp", "pb", "pr", "vim", "wp", "vr", "cv", "VP", "vm", "nv", "vg"], "rp": ["nrp", "rerc", "erpa", "erpc", "nrpc", "rpc", " rpc", "erp", "rpa", "nrpi", "rc", "nrc", "vrpc", " rpa", "vrsp", "rerp", "ersp", "rsp", " rc", " rsp", "rerpc", "rerpi", "rpi", "vrpa", " rpi", "vrp"], "env": ["ef", "next", "obj", "entry", "net", "con", "pe", "priv", "config", "et", "buffer", "reset", "ei", "end", "ev", "den", "goal", "proc", "home", "ec", "buf", "dev", "eni", "worker", "eng", "open", "scope", "pkg", "ptr", "vt", "window", "ka", "en", "ote", "ext", "server", "node", "ctx", "EN", "conn", "conf", "environment", "ten", "e", "lock", "cmd", "target", "hw", "er", "ent", "org", "context", "desktop", "set", "db", "cv", "dt", "viron"], "token": ["typ", "or", "span", "kt", "o", "word", "util", "session", "t", "kn", "tree", "ion", "wt", "Token", "oin", "ens", "factor", "key", "next", "at", "message", "channel", "ak", "KEN", "value", "oken", "txt", "node", "fn", "WT", "table", "seed", "time", "tick", "template", "number", "id", "buffer", "k", "field", "error", "worker", "TO", "prototype", "type", "index", "ts", "annot", " Token", "s", "tool", "timer", "ant", "mt", "vector", "empty", "pointer", "flag", "event", "list", "to", "an", "ok", "normal", "label", "zero", "json", "handle", "sid", "tn", "lock", "trigger", "offset"], "v": ["vs", " sv", "vert", "u", "va", "av", "vi", "ev", "vu", "vv", "ov", "uv", "ve", "p", "value", " V", "f", "vc", "lv", "rev", "m", "l", " ov", "vP", "sv", "qv", "i", "values", "vt", "ver", "inv", " w", "j", "version", "n", "vo", "t", "V", " av", "pr", "val", "b", "e", "c", "h", " tv", "w", "x", "cv", "iv", "vr", "vm", "nv", "conv", "tv"], "r": ["tr", "hr", "u", "rs", "q", "p", "rf", "d", "rw", "l", "rn", "i", "mr", "rr", "rx", "j", "br", "n", "rg", "rc", "rd", "nr", "pr", "e", "b", "c", "h", "ro", "rt", "reb", "sr", "re", "res", "w", "er", "rm", "ur", "ru", "vr", "R", "cr", "rar", "ar"], "rb": ["lb", "lr", "rs", "p", "rf", "xb", "bin", " RB", "rob", "rw", "rub", "fb", "ruby", "cb", "mr", "rr", "lp", "rl", "RB", "br", "pb", "rg", "rc", "rd", "erb", "nr", "rh", "sb", "b", "ro", "rt", "reb", "re", "bb", "rm", "nb", "gb", "db", "vr", "ru", "binary", "wb"]}}
{"project": "qemu", "commit_id": "33848ceed79679b5c9e558b768447af2614b8db2", "target": 1, "func": "int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size)\n\n{\n\n    PCIExpressDevice *exp;\n\n\n\n    pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER,\n\n                        offset, size);\n\n    exp = &dev->exp;\n\n    exp->aer_cap = offset;\n\n\n\n    /* log_max is property */\n\n    if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) {\n\n        dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT;\n\n    }\n\n    /* clip down the value to avoid unreasobale memory usage */\n\n    if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) {\n\n        return -EINVAL;\n\n    }\n\n    dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] *\n\n                                        dev->exp.aer_log.log_max);\n\n\n\n    pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SEVERITY_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,\n\n                 PCI_ERR_UNC_SUPPORTED);\n\n\n\n    pci_long_test_and_set_mask(dev->w1cmask + offset + PCI_ERR_COR_STATUS,\n\n                               PCI_ERR_COR_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_MASK_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_SUPPORTED);\n\n\n\n    /* capabilities and control. multiple header logging is supported */\n\n    if (dev->exp.aer_log.log_max > 0) {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC |\n\n                     PCI_ERR_CAP_MHRC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE |\n\n                     PCI_ERR_CAP_MHRE);\n\n    } else {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\n\n    }\n\n\n\n    switch (pcie_cap_get_type(dev)) {\n\n    case PCI_EXP_TYPE_ROOT_PORT:\n\n        /* this case will be set by pcie_aer_root_init() */\n\n        /* fallthrough */\n\n    case PCI_EXP_TYPE_DOWNSTREAM:\n\n    case PCI_EXP_TYPE_UPSTREAM:\n\n        pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL,\n\n                                   PCI_BRIDGE_CTL_SERR);\n\n        pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS,\n\n                                   PCI_SEC_STATUS_RCV_SYSTEM_ERROR);\n\n        break;\n\n    default:\n\n        /* nothing */\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8447, "substitutes": {"dev": ["ow", "usb", "priv", "feature", "cam", "prov", "end", "prop", "eng", "d", "desc", "util", "package", "data", "scan", "wd", "unknown", "env", "van", "cmd", "Device", "w", "serv", "history", "pro", "dd", "av", "ve", "buf", "ver", "server", "develop", "dem", "conn", "conf", "cast", "tech", "Dev", "any", "des", "pack", "debug", "app", "draw", "spec", "prom", "device", "req", "go", "ev", "den", "devices", "form", "var", "nt", "def", "serial", "raw", "window", "mem", "ad", "ctx", "info", "gu", "comment", "hw", "db", "off", "home", "adv", "pad", "normal", "port", "de", "DEV", "v", "vision", "watch", "disk", "stick", "sys"], "offset": ["reset", "config", "prefix", "offer", "alloc", "slot", "location", "attr", "queue", "attribute", "bound", "data", "metadata", "env", "cmd", "option", "slice", "address", "init", "buf", "job", "pixel", "ptr", "scroll", "Offset", "count", "alias", "seed", "batch", "item", "shift", "id", "order", "image", "req", "point", "pos", "ref", "timeout", "trace", "mask", "index", "header", "ctx", "from", "start", "crop", "loc", "style", "out", "align", "off", "entry", "pointer", "padding", "seek", "p", "pool", "offs", "pad", "hop", "pkg", "client", "position", "port", "handle", "addr", "snap", " offsets", "encrypted", "origin", "set", "length", "delay"], "size": ["shift", "len", "empty", "what", "send", "sum", "padding", "seek", "sp", "Size", "SIZE", "capacity", "gz", "ize", "bytes", "mem", "scroll", "amount", "total", "body", "count", "shape", "dim", "sh", "sn", "fee", "space", "z", "set", "fit", "no", "ose", "length"]}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 8457, "substitutes": {"cpu": ["command", "ck", "reset", "gpu", "prof", "prefix", "thread", "proc", "linux", "ruby", "parse", "util", "crypt", "queue", "clock", "chip", "cmd", "performance", "bench", "aco", "tp", "cmp", "ilo", "gnu", "pu", "docker", "jp", "efficiency", "mu", "aux", "que", "phys", "python", "nic", "current", "cum", "net", "pc", "runner", "processor", "goal", "profile", "cp", "frame", "component", "ip", "instance", "tc", "process", "CPU", "mem", "currency", "ctx", "execute", "remote", "panic", "cn", "copy", "du", "hw", "console", "num", "lib", "sync", "computer", "pool", "cow", "program", "pkg", "np", "lp", " CPU", "cli", "core", "boot", "total", "gc", "cache", "c", "uu", "po", "cu", "kernel", "mac", "coin"], "thread_name": ["threadityurl", "threadityname", "thread_url", "thread_size", "thread1name", "threadNamename", "template_class", "threadNamenames", "thread_names", "threadNameclass", "template_url", " thread_info", "thread_class", "threadNamestr", "template_names", "threaditysize", "template_name", "thread_Name", "thread1Name", "thread_info", "template_size", "template_str", "threaditynames", "thread_str", "thread1info", " thread_Name"], "tcg_halt_cond": ["tcg_halt_lock", "tcg_halt__compl", "tcg_hatal_cond", "tcg_hall_compl", "tcg_hall___cond", "tcg_hall_condition", "tcg_hal_condition", "tcg_hal_Cond", "tcg_halt__Cond", "tcg_halt_func", "tcg_halt___Cond", "tcg_hal_cond", "tcg_halt___cond", "tcg_halt2lock", "tcg_hatal_pos", "tcg_halt_pos", "tcg_hall___condition", "tcg_hall___compl", "tcg_hall___Cond", "tcg_halt_Cond", "tcg_halt2condition", "tcg_hall_cond", "tcg_halt___condition", "tcg_halt_compl", "tcg_halt_condition", "tcg_halt2Cond", "tcg_halt2cond", "tcg_halt___compl", "tcg_halt__condition", "tcg_halt__cond", "tcg_hatal_func", "tcg_hatal_compl", "tcg_hal_lock", "tcg_hall_Cond"], "tcg_cpu_thread": ["tcg_pu_process", "tcg_core_process", "tcg_cpu__thread", "tcg_cpu2process", "tcg_processor___old", "tcg_cpu___task", "tcg_cpu___process", "tcg_core_thread", "tcg_core_loop", "tcg_core_task", "tcg_processor_old", "tcg_cpu_loop", "tcg_cpu_process", "tcg_cpu2lock", "tcg_core___thread", "tcg_core___process", "tcg_processor___thread", "tcg_processor_loop", "tcg_processor___host", "tcg_cpu___old", "tcg_cpu___loop", "tcg_core___task", "tcg_cpu_type", "tcg_cpu2port", "tcg_cpu_lock", "tcg_processor_thread", "tcg_processor_host", "tcg_cpu__type", "tcg_pu_port", "tcg_pu_ready", "tcg_cpu2thread", "tcg_pu_thread", "tcg_cpu_host", "tcg_cpu_task", "tcg_pu_lock", "tcg_cpu_ready", "tcg_cpu_port", "tcg_cpu__process", "tcg_cpu___host", "tcg_pu_type", "tcg_cpu__ready", "tcg_processor___loop", "tcg_core___loop", "tcg_cpu_old", "tcg_cpu___thread"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = send(vs->csock, (const void *)data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n", "idx": 8466, "substitutes": {"vs": ["ms", "ports", "obs", "qs", "Vs", "settings", "rs", "gs", "sts", "ps", "VS", "lines", "changes", "pages", "vp", "cs", "sv", "es", "ses", "blogs", "vt", "xs", "bs", "values", "lists", "verts", "inv", "vers", "js", "ss", "ts", "links", "vd", "v", "wcs", "caps", "times", "ns", "stats", "fs", "ks", "vals", "ls", "vr", "s", "vm", "vc", "ds"], "data": ["len", "obj", "Data", "empty", "map", "buffer", "text", "message", "base", "device", "end", "as", "file", "form", "p", "buf", " Data", "bin", "error", "trans", "d", " DATA", "block", "ata", "def", "raw", "window", "bytes", "mu", "mem", "rel", "box", "ad", "new", "bus", "aw", "ops", "cache", "dat", "str", "rew", "res", "table", "batch", "msg", "DATA", "size", "out"], "datalen": ["dallen", "Datalength", " dalah", "dulah", "datalist", "Dataloc", "dallyun", "dallist", "dalength", "dalloc", "dalim", "dalah", "davalen", "datalah", "dallyen", "davalength", "dulen", "davaloc", "datlen", "dalize", "dallize", " datalength", "dalun", "dallyah", "Daloc", " datalist", " datalize", "dallength", "davalim", "datlist", "datalize", "dallyength", "datalength", " dalen", " dallist", "Datalen", "Dalength", " dallen", " dallize", " datalun", "dulun", "daloc", "Dalen", " dalun", " dalength", "Datalim", " dallength", "dataloc", "datlength", "datalim", "dulength", " datalah", "datalun", "dallim", "dalist", "Dalim", "dalen", "datlize"], "ret": ["ert", "len", "fin", "run", "tr", "num", "pas", " RET", "status", "reset", "fi", "sum", "read", "back", "flag", "got", "rs", "match", "err", "print", "RET", "resp", "sp", "buf", "f", "nt", "cat", "limit", "ref", " Ret", "def", "mt", "port", "txt", "ort", "alt", "mem", "r", "j", "ts", "done", "t", "__", "rem", "rets", "info", "gc", "val", "Ret", "red", "out", "rt", "re", "res", "st", "result", "gt", "db", "no", "Return", "arg"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static av_cold int decode_init(AVCodecContext * avctx)\n\n{\n\n    MPADecodeContext *s = avctx->priv_data;\n\n    static int init=0;\n\n    int i, j, k;\n\n\n\n    s->avctx = avctx;\n\n\n\n    ff_mpadsp_init(&s->mpadsp);\n\n\n\n    avctx->sample_fmt= OUT_FMT;\n\n    s->error_recognition= avctx->error_recognition;\n\n\n\n    if (!init && !avctx->parse_only) {\n\n        int offset;\n\n\n\n        /* scale factors table for layer 1/2 */\n\n        for(i=0;i<64;i++) {\n\n            int shift, mod;\n\n            /* 1.0 (i = 3) is normalized to 2 ^ FRAC_BITS */\n\n            shift = (i / 3);\n\n            mod = i % 3;\n\n            scale_factor_modshift[i] = mod | (shift << 2);\n\n        }\n\n\n\n        /* scale factor multiply for layer 1 */\n\n        for(i=0;i<15;i++) {\n\n            int n, norm;\n\n            n = i + 2;\n\n            norm = ((INT64_C(1) << n) * FRAC_ONE) / ((1 << n) - 1);\n\n            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRAC_BITS);\n\n            scale_factor_mult[i][2] = MULLx(norm, FIXR(0.6299605249 * 2.0), FRAC_BITS);\n\n            av_dlog(avctx, \"%d: norm=%x s=%x %x %x\\n\",\n\n                    i, norm,\n\n                    scale_factor_mult[i][0],\n\n                    scale_factor_mult[i][1],\n\n                    scale_factor_mult[i][2]);\n\n        }\n\n\n\n        RENAME(ff_mpa_synth_init)(RENAME(ff_mpa_synth_window));\n\n\n\n        /* huffman decode tables */\n\n        offset = 0;\n\n        for(i=1;i<16;i++) {\n\n            const HuffTable *h = &mpa_huff_tables[i];\n\n            int xsize, x, y;\n\n            uint8_t  tmp_bits [512];\n\n            uint16_t tmp_codes[512];\n\n\n\n            memset(tmp_bits , 0, sizeof(tmp_bits ));\n\n            memset(tmp_codes, 0, sizeof(tmp_codes));\n\n\n\n            xsize = h->xsize;\n\n\n\n            j = 0;\n\n            for(x=0;x<xsize;x++) {\n\n                for(y=0;y<xsize;y++){\n\n                    tmp_bits [(x << 5) | y | ((x&&y)<<4)]= h->bits [j  ];\n\n                    tmp_codes[(x << 5) | y | ((x&&y)<<4)]= h->codes[j++];\n\n                }\n\n            }\n\n\n\n            /* XXX: fail test */\n\n            huff_vlc[i].table = huff_vlc_tables+offset;\n\n            huff_vlc[i].table_allocated = huff_vlc_tables_sizes[i];\n\n            init_vlc(&huff_vlc[i], 7, 512,\n\n                     tmp_bits, 1, 1, tmp_codes, 2, 2,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_vlc_tables));\n\n\n\n        offset = 0;\n\n        for(i=0;i<2;i++) {\n\n            huff_quad_vlc[i].table = huff_quad_vlc_tables+offset;\n\n            huff_quad_vlc[i].table_allocated = huff_quad_vlc_tables_sizes[i];\n\n            init_vlc(&huff_quad_vlc[i], i == 0 ? 7 : 4, 16,\n\n                     mpa_quad_bits[i], 1, 1, mpa_quad_codes[i], 1, 1,\n\n                     INIT_VLC_USE_NEW_STATIC);\n\n            offset += huff_quad_vlc_tables_sizes[i];\n\n        }\n\n        assert(offset == FF_ARRAY_ELEMS(huff_quad_vlc_tables));\n\n\n\n        for(i=0;i<9;i++) {\n\n            k = 0;\n\n            for(j=0;j<22;j++) {\n\n                band_index_long[i][j] = k;\n\n                k += band_size_long[i][j];\n\n            }\n\n            band_index_long[i][22] = k;\n\n        }\n\n\n\n        /* compute n ^ (4/3) and store it in mantissa/exp format */\n\n\n\n        int_pow_init();\n\n        mpegaudio_tableinit();\n\n\n\n        for (i = 0; i < 4; i++)\n\n            if (ff_mpa_quant_bits[i] < 0)\n\n                for (j = 0; j < (1<<(-ff_mpa_quant_bits[i]+1)); j++) {\n\n                    int val1, val2, val3, steps;\n\n                    int val = j;\n\n                    steps  = ff_mpa_quant_steps[i];\n\n                    val1 = val % steps;\n\n                    val /= steps;\n\n                    val2 = val % steps;\n\n                    val3 = val / steps;\n\n                    division_tabs[i][j] = val1 + (val2 << 4) + (val3 << 8);\n\n                }\n\n\n\n\n\n        for(i=0;i<7;i++) {\n\n            float f;\n\n            INTFLOAT v;\n\n            if (i != 6) {\n\n                f = tan((double)i * M_PI / 12.0);\n\n                v = FIXR(f / (1.0 + f));\n\n            } else {\n\n                v = FIXR(1.0);\n\n            }\n\n            is_table[0][i] = v;\n\n            is_table[1][6 - i] = v;\n\n        }\n\n        /* invalid values */\n\n        for(i=7;i<16;i++)\n\n            is_table[0][i] = is_table[1][i] = 0.0;\n\n\n\n        for(i=0;i<16;i++) {\n\n            double f;\n\n            int e, k;\n\n\n\n            for(j=0;j<2;j++) {\n\n                e = -(j + 1) * ((i + 1) >> 1);\n\n                f = pow(2.0, e / 4.0);\n\n                k = i & 1;\n\n                is_table_lsf[j][k ^ 1][i] = FIXR(f);\n\n                is_table_lsf[j][k][i] = FIXR(1.0);\n\n                av_dlog(avctx, \"is_table_lsf %d %d: %x %x\\n\",\n\n                        i, j, is_table_lsf[j][0][i], is_table_lsf[j][1][i]);\n\n            }\n\n        }\n\n\n\n        for(i=0;i<8;i++) {\n\n            float ci, cs, ca;\n\n            ci = ci_table[i];\n\n            cs = 1.0 / sqrt(1.0 + ci * ci);\n\n            ca = cs * ci;\n\n            csa_table[i][0] = FIXHR(cs/4);\n\n            csa_table[i][1] = FIXHR(ca/4);\n\n            csa_table[i][2] = FIXHR(ca/4) + FIXHR(cs/4);\n\n            csa_table[i][3] = FIXHR(ca/4) - FIXHR(cs/4);\n\n            csa_table_float[i][0] = cs;\n\n            csa_table_float[i][1] = ca;\n\n            csa_table_float[i][2] = ca + cs;\n\n            csa_table_float[i][3] = ca - cs;\n\n        }\n\n\n\n        /* compute mdct windows */\n\n        for(i=0;i<36;i++) {\n\n            for(j=0; j<4; j++){\n\n                double d;\n\n\n\n                if(j==2 && i%3 != 1)\n\n                    continue;\n\n\n\n                d= sin(M_PI * (i + 0.5) / 36.0);\n\n                if(j==1){\n\n                    if     (i>=30) d= 0;\n\n                    else if(i>=24) d= sin(M_PI * (i - 18 + 0.5) / 12.0);\n\n                    else if(i>=18) d= 1;\n\n                }else if(j==3){\n\n                    if     (i<  6) d= 0;\n\n                    else if(i< 12) d= sin(M_PI * (i -  6 + 0.5) / 12.0);\n\n                    else if(i< 18) d= 1;\n\n                }\n\n                //merge last stage of imdct into the window coefficients\n\n                d*= 0.5 / cos(M_PI*(2*i + 19)/72);\n\n\n\n                if(j==2)\n\n                    mdct_win[j][i/3] = FIXHR((d / (1<<5)));\n\n                else\n\n                    mdct_win[j][i  ] = FIXHR((d / (1<<5)));\n\n            }\n\n        }\n\n\n\n        /* NOTE: we do frequency inversion adter the MDCT by changing\n\n           the sign of the right window coefs */\n\n        for(j=0;j<4;j++) {\n\n            for(i=0;i<36;i+=2) {\n\n                mdct_win[j + 4][i] = mdct_win[j][i];\n\n                mdct_win[j + 4][i + 1] = -mdct_win[j][i + 1];\n\n            }\n\n        }\n\n\n\n        init = 1;\n\n    }\n\n\n\n    if (avctx->codec_id == CODEC_ID_MP3ADU)\n\n        s->adu_mode = 1;\n\n    return 0;\n\n}\n", "idx": 8482, "substitutes": {"avctx": ["devcontext", " avcontext", " avtmp", "avecontext", "avercb", "avcmd", "airctx", "aircp", "airjp", "averctx", " avcm", "vjp", "vdata", "averobj", "avercfg", "avetx", " avctl", "avetmp", "abtx", "avectl", "devctx", "vrcm", "auxtx", "AVctx", "avcontext", "vrctx", "avercontext", "vrobj", "avjp", "auxcu", "abdata", "avcm", "auxcontext", "avectx", "avertmp", "avtmp", "avcfg", " avtx", "avercmd", "avcu", "afobj", " avcmd", "avctl", " avcb", "afctx", "averctl", "devcu", "avcb", "vcontext", "AVcontext", "abctx", "avdata", "avercp", "devtx", " avcfg", "avecb", "avobj", "afcontext", "avercm", "abcontext", " avobj", " avcp", "averjp", "avecfg", " avcu", "avcp", "afcmd", "abcb", "abjp", "AVjp", "AVdata", "auxctx", "vrcontext", "avtx", " avjp", "aircontext", "vctx"], "s": ["ms", "sq", "vs", "spec", "ats", "rs", "hs", "p", "gs", "sts", "ps", "m", "sv", "es", "utils", "bs", "services", "aws", "is", "js", "S", "ss", "ts", "its", "t", "ctx", "ssl", "self", "os", "sb", "b", "c", "ns", "stats", "fs", "set", "ls", "ds", "sys"], "i": ["u", "ie", "print", "span", "o", "m", "r", "im", "t", "zi", "b", "gi", "iii", "pi", "slice", "oi", "hi", "ji", "ims", "history", "key", "ami", "status", "I", "at", "li", "uri", "ri", "ind", "g", "ki", "ti", "ia", "mi", "ix", "xi", "multi", "qi", "si", "yi", "id", "ai", "ei", "go", "point", "ui", "iat", "ip", "l", "ic", "in", "index", "chain", "\u0438", "phi", "info", "it", "ini", "module", "ii", "me", "io", "q", "list", "to", "p", "sim", "this", "cli", "is", "iu", "ik", "c", "bi", "di", "name", "ij"], "j": ["jac", "aj", "jump", "J", "jc", "q", "p", "o", "g", "jp", "l", "pos", "m", "jj", "js", "uj", "jl", "b", "c", "bi", "z", "ji", "kj", "ij"], "k": ["key", "ko", "u", "K", "q", "ak", "p", "o", "ok", "g", "m", "l", "ki", "ka", "ik", "mk", "c", "w", "kw", "it", "z", "km", "max", "sk", "kk"], "offset": ["align", "key", "command", "off", "id", "reset", "address", "buffer", "pointer", "padding", "base", "seek", "point", "o", "error", "pad", "ui", "slot", "location", "ip", "limit", "pos", "position", "window", "mask", "index", "attribute", "ix", "ian", "Offset", "skip", "info", "lock", "scale", "option", "origin", "load", "start", "si", "table", "seed", "loc", "size", "ii"], "shift": ["align", "command", "sq", "small", "tr", "off", "hift", "power", "Shift", "prime", "sign", "q", "seek", "step", "p", "hash", "trans", "push", "m", "shr", "ize", "mix", "mask", "index", "sup", "share", "ix", "fix", "transform", "sh", "scale", "load", "start", "w", "tip", "diff", "z", "seed", "set", "size"], "mod": ["ms", "tr", "min", "off", "prime", "small", "sum", "mm", "sign", "mult", "add", "MOD", "step", "modified", "sub", "sim", "od", "pad", "trans", "Mod", "m", "fun", "mods", "mask", "mix", "bit", "r", "md", "im", "perm", "mode", "rot", "deg", "scale", "med", "cm", " Mod", "z", "set", "lex", "module", "loc"], "n": ["len", "on", "num", "u", "nan", "na", "nm", "nl", "gn", "nu", "ng", "p", "o", "ne", "ni", "nt", "nor", "g", "m", "l", "note", "np", "nn", "mn", "en", "dn", "all", "N", "t", "pn", "c", "cn", "sn", "ns", "w", "nb", "z", "size", "out"], "norm": ["nv", "na", "num", "net", "orm", "nm", "sum", "orth", "sync", "lim", "base", "req", "err", "non", "nu", "form", " norms", "iso", "known", "dev", "unit", "prop", "ne", "nt", "normal", "nor", "NOR", "vec", "np", "fun", "common", "raw", "mn", "all", "mem", "inv", "none", "rel", "loss", "Normal", "deg", "iz", "Norm", "low", "scale", "orig", "str", "nom", "dist", "adj", "res", "diff", "nb", "nd", "loc", "ann"], "h": ["u", "a", "ch", "q", "ht", "p", "hash", "o", "g", "m", "l", "oh", "r", "hp", "header", "t", "cache", "b", "c", "w", "H"], "xsize": ["rxSize", "txcount", "txsize", "XSize", "Xsize", "rxSIZE", "xcount", "txSIZE", "txSize", "XSIZE", "rxcount", "xSize", "xSIZE", "Xcount", "rxsize"], "x": ["xy", "tx", "p", "height", "o", "ex", "dx", "m", "l", "X", "xs", "index", "rx", "ix", "px", "xi", "c", "w", "z", "size"], "y": ["col", "key", "py", "yt", "xy", "ch", "yy", "p", "o", "height", "m", "l", "t", "Y", "ey", "b", "c", "sy", "iy", "z", "yl", "yi"], "tmp_bits": ["tmp___keys", "tmpablebytes", "tmp2its", "mp_its", "tmp_batch", "mp_codes", "mp_bytes", "tmp___bytes", "mp_keys", "tmpablekeys", " tmp_bytes", "tmp___tops", "tmp___bits", " tmp_tops", "mp_batch", "tmpablebits", "tmp_its", "tmp2bytes", "tmp2codes", " tmp_bit", "tmp_bytes", "mp_bits", "tmp___batch", "tmp___bit", "tmpablebatch", "tmp2bits", "tmp_bit", "tmp_tops", "tmp_keys"], "tmp_codes": ["tmp_names", "tmp_xy", "tmp5code", "mp_xy", "mp_codes", "tmp8codes", "tmp8xy", "tmp8code", "tmp5codes", "tmp5names", "tmp_code", "mp_code", "mp_names", "tmp8names", "tmp5xy"]}}
{"project": "FFmpeg", "commit_id": "480324e7ca0b87105fd7ee168292a0d5692af128", "target": 0, "func": "static int libgsm_decode_frame(AVCodecContext *avctx,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt) {\n\n    uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);\n\n\n\n    if (*data_size < out_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (buf_size < avctx->block_align) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch(avctx->codec_id) {\n\n    case CODEC_ID_GSM:\n\n        if(gsm_decode(avctx->priv_data,buf,data)) return -1;\n\n        break;\n\n    case CODEC_ID_GSM_MS:\n\n        if(gsm_decode(avctx->priv_data,buf,data) ||\n\n           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;\n\n    }\n\n\n\n    *data_size = out_size;\n\n    return avctx->block_align;\n\n}\n", "idx": 8487, "substitutes": {"avctx": ["ajjp", "wavcfg", " avcontext", "avecontext", "vrpkg", "avercand", "avsys", "avercb", "avstate", "avectr", "avesys", "wavconf", "airctx", "ajparams", "avecu", "aircp", "averconf", "avparams", "averctx", "avcmp", "avecand", "airjac", "averjac", "avejac", "avercfg", "wavcand", "avetx", " avctl", "avepkg", "aftx", "avertxt", "wavctx", "avconf", "AVctx", "avcontext", "vrctx", "avercontext", "averstate", "averkw", "avjp", "ajctx", "avectx", "avcand", "avtxt", "afctr", "afcb", "aveparams", "avcfg", " avtx", "wavtx", "avcu", "avejp", "ajjac", "avctl", "afctx", " avcb", "wavctr", "avekw", "AVtx", "avcb", "AVcontext", "afjac", "wavcu", "vrcu", "AVctl", "ajsys", "aveconf", "wavstate", "wavctl", "afcontext", "wavcontext", "wavkw", "avjac", "wavpkg", " avcp", "averjp", "vrcmp", "avecfg", "avcp", "ajtxt", "ajconf", "averparams", "avecmp", "wavjac", "aversys", "avctr", "avkw", "afstate", "avetxt", "wavcmp", " avjac", "avecp", "avertx", "avtx", "avpkg", "aircontext"], "data": ["len", "Data", "empty", "id", "extra", "buffer", "text", "message", "padding", "image", "sample", "valid", "area", "p", "value", "bin", "frame", "pad", "error", "da", "d", "this", " DATA", "block", "m", "nt", "ata", "def", "zero", "type", "length", "raw", "window", "bytes", "win", "mu", "addr", "package", "none", "content", "rel", "done", "t", "one", "feed", "new", "aw", "ops", "action", "cache", "input", "mid", "any", "dat", "str", "results", "res", "batch", "result", "msg", "DATA", "no", "name", "offset", "size"], "data_size": ["data_len", "block_sent", "dataptpath", "dataaxysize", "dataaxyscale", "dataptsize", "data_length", "block_len", " data_align", "data_Size", "dataptscale", "data_path", " data_SIZE", "dataptsent", "dataaxypath", "data_sent", "block_path", "block_size", "data_count", "data_SIZE", " data_length", "data_scale", "block_Size", "block_count", "dataaxysent", "data_align", "block_scale"], "avpkt": ["avcpkt", "avpacket", "avbpacket", "avPk", "avenpkt", "avenpck", "avcpct", "avcpdt", "avbpkt", "avewpacket", "avnpct", "ajpk", "avepacket", "avPft", "avwpkt", "avewpkt", "avepck", "ajvpkt", "avbpk", "avpck", "avPkat", "avPacket", "avwpct", "avPck", "avPkt", "avpk", "avepft", "avvpkat", "avpft", "ajpkat", "avwpdt", "avcpacket", "avbpkat", "avvpacket", "avpdt", "ajvpk", "ajvpkat", "ajpkt", "avpct", "avepdt", "avenpct", "ajpacket", "avPdt", "avvpkt", "avvpk", "avepkt", "avewpdt", "avnpck", "avenpft", "avwpacket", "avpkat", "avPct", "avepct", "avnpft", "ajvpacket", "avnpkt", "avewpct"], "buf": ["doc", "empty", "xy", "map", "xff", "buffer", "uf", "aka", "rb", "err", "ff", "alloc", "home", "func", "p", "pool", "seq", "bc", "Buffer", "vec", "pkg", "block", "ata", "cur", "limit", "cb", "ptr", "raw", "window", "queue", "mem", "water", "br", "done", "box", "cap", "ctx", "good", "b", "tmp", "cmd", "bh", "orig", "dat", "temp", "pipe", "Buff", "broad", "batch", "coord", "buff", "db", "msg", "cv", "loc", "img", "wb"]}}
{"project": "qemu", "commit_id": "e1622f4b15391bd44eb0f99a244fdf19a20fd981", "target": 1, "func": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n\n{\n\n    unsigned access_size_min = mr->ops->impl.min_access_size;\n\n    unsigned access_size_max = mr->ops->impl.max_access_size;\n\n\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n\n       otherwise specified.  */\n\n    if (access_size_min == 0) {\n\n        access_size_min = 1;\n\n    }\n\n    if (access_size_max == 0) {\n\n        access_size_max = 4;\n\n    }\n\n\n\n    /* Bound the maximum access by the alignment of the address.  */\n\n    if (!mr->ops->impl.unaligned) {\n\n        unsigned align_size_max = addr & -addr;\n\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n\n            access_size_max = align_size_max;\n\n        }\n\n    }\n\n\n\n    /* Don't attempt accesses larger than the maximum.  */\n\n    if (l > access_size_max) {\n\n        l = access_size_max;\n\n    }\n\n    /* ??? The users of this function are wrong, not supporting minimums larger\n\n       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */\n\n    assert(l >= access_size_min);\n\n\n\n    return l;\n\n}\n", "idx": 8518, "substitutes": {"mr": ["ms", "kr", "ml", "MT", "Mr", "hr", "hm", "rpm", "nm", "gm", "lr", "rb", "rs", "older", "asm", "Rs", "fm", "m", "bm", "rn", "MR", "drm", "mn", "rr", "adr", "usr", "r", "rl", "md", "br", "mc", "rg", "yr", "nr", "irm", "rd", "fr", "pr", "wcs", "ctr", "sr", "RM", "ocr", "rm", "rer", "vr", "ims", "rar", "mt"], "l": ["ml", "len", "lit", "lt", "u", "sl", "ll", "nl", "li", "lr", "list", "p", "f", "lu", "ld", "lam", "d", "lv", "g", "limit", "m", "hl", "i", "lp", "ln", "r", "il", "las", "j", "n", "dl", "t", "tl", "lc", "v", "pl", "e", "val", " L", "b", "c", "ly", "h", "ul", "x", "z", "lis", "ls", "el", "s", "le", "loc", "L", "length"], "addr": ["align", "arr", "src", "len", "address", "map", "nl", "mb", "at", "add", "Address", " ptr", "lr", "a", "rs", "init", "err", "asm", "hash", " address", "wire", "pad", "ld", "act", "ip", "ref", "gate", "inter", "hl", "ptr", "i", "adr", " r", "ord", "ext", "r", "__", "v", "ha", "h", "eth", "offset", "w", "res", "alias", "x", "z", "dh", "max", "name", "work", "size", "dr", "mt"]}}
{"project": "qemu", "commit_id": "d6b6abc51dda79a97f2c7bd6652c1940c068f1ec", "target": 1, "func": "void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,\n\n                              FWCfgCallback select_cb,\n\n                              FWCfgWriteCallback write_cb,\n\n                              void *callback_opaque,\n\n                              void *data, size_t len, bool read_only)\n\n{\n\n    int i, index, count;\n\n    size_t dsize;\n\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n\n    int order = 0;\n\n\n\n    if (!s->files) {\n\n        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);\n\n        s->files = g_malloc0(dsize);\n\n        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);\n\n    }\n\n\n\n    count = be32_to_cpu(s->files->count);\n\n    assert(count < fw_cfg_file_slots(s));\n\n\n\n    /* Find the insertion point. */\n\n    if (mc->legacy_fw_cfg_order) {\n\n        /*\n\n         * Sort by order. For files with the same order, we keep them\n\n         * in the sequence in which they were added.\n\n         */\n\n        order = get_fw_cfg_order(s, filename);\n\n        for (index = count;\n\n             index > 0 && order < s->entry_order[index - 1];\n\n             index--);\n\n    } else {\n\n        /* Sort by file name. */\n\n        for (index = count;\n\n             index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;\n\n             index--);\n\n    }\n\n\n\n    /*\n\n     * Move all the entries from the index point and after down one\n\n     * to create a slot for the new entry.  Because calculations are\n\n     * being done with the index, make it so that \"i\" is the current\n\n     * index and \"i - 1\" is the one being copied from, thus the\n\n     * unusual start and end in the for statement.\n\n     */\n\n    for (i = count + 1; i > index; i--) {\n\n        s->files->f[i] = s->files->f[i - 1];\n\n        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);\n\n        s->entries[0][FW_CFG_FILE_FIRST + i] =\n\n            s->entries[0][FW_CFG_FILE_FIRST + i - 1];\n\n        s->entry_order[i] = s->entry_order[i - 1];\n\n    }\n\n\n\n    memset(&s->files->f[index], 0, sizeof(FWCfgFile));\n\n    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));\n\n\n\n    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);\n\n    for (i = 0; i <= count; i++) {\n\n        if (i != index &&\n\n            strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n\n            error_report(\"duplicate fw_cfg file name: %s\",\n\n                         s->files->f[index].name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,\n\n                              select_cb, write_cb,\n\n                              callback_opaque, data, len,\n\n                              read_only);\n\n\n\n    s->files->f[index].size   = cpu_to_be32(len);\n\n    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);\n\n    s->entry_order[index] = order;\n\n    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);\n\n\n\n    s->files->count = cpu_to_be32(count+1);\n\n}\n", "idx": 8522, "substitutes": {"s": ["ms", "events", "vs", "ats", "hs", "d", "cs", "ins", "details", "r", "se", "y", "t", "sports", "os", "b", "sa", "w", "comm", "ims", "ares", "items", "ports", "gets", "settings", "tests", "sp", "gs", "sts", "changes", "sv", "ses", "utils", "bs", "services", "less", "js", "als", "these", "ss", "sb", "ls", "states", "state", "sq", "spec", "sl", "ges", "qs", "rs", "f", "l", "es", "store", "views", "ts", "n", "styles", "sw", "sh", "results", "ns", "ds", "p", "ps", "service", "aws", "is", "j", "S", "its", "ssl", "v", "bis", "h", "stats", "fs", "actions", "sys", "parts"], "filename": ["src", "key", "typ", "fd", "nm", "username", "path", "prefix", "text", "buffer", "nu", "file", "p", "Filename", "buf", "o", "f", "ren", "til", "fp", "files", "location", "ename", "ame", "txt", "jpg", "family", "ames", "fn", "n", "t", "directory", "v", "fr", "wcs", "fle", "cmd", "title", "subject", "sbm", "fil", "nil", "name", "length", "kj"], "select_cb": ["selectingcb", "select_cmd", "selectingcmd", "select_cv", "selectingcallback", " select_cv", "selectingcv", "select_callback", " select_callback", " select_cmd"], "write_cb": ["writeolycb", "writeolyinfo", "write_info", "writeolycallback", "write_callback", "write_CB", " write_CB", "writeolyCB", " write_info", " write_callback"], "callback_opaque": ["callback___opaque", "callback___epaque", "callback_openen", "callback___epened", "callback_epened", "callback___epen", "callback_openaque", "callback_popen", "callback_open", "callback_popened", "callback___opula", "callback_epula", "callback_epaque", "callback_openula", "callback_epen", "callback_popaque", "callback___opened", "callback___epula", "callback_opula", "callback___open", "callback_popula", "callback_openened", "callback_opened"], "data": ["Data", "next", "extra", "buffer", "message", "format", "image", "area", "value", "buf", "bin", "d", "block", "ata", "window", "done", "info", "cache", "batch", "result", "memory", "DATA", "name", "writer", "size", "out"], "len": ["fin", "lib", "cmp", "path", "Len", "file", "buf", "seq", "bin", "name", "vec", "pos", "l", "ref", "fun", "args", "length", "bytes", "en", "addr", "ln", "h", "ls", "ll", "offset", "size"], "read_only": ["readableonly", "readonlyonly", "readableenabled", "load_write", "read_write", "load_only", "read_enabled", "read_Only", "load_Only", "readonlyenabled", "readonlywrite", "readablewrite", "readonlyOnly", "readableOnly", "load_enabled"], "i": ["id", "u", "ice", "ai", "status", "fi", "I", "me", "ei", "li", "order", "init", "ile", "iq", "span", "ri", "p", "point", "f", "sim", "ind", "ui", "iter", "iat", "name", "ip", "instance", "m", "ti", "ic", "cli", "in", "all", "r", "mi", "is", "j", "im", "ix", "n", "y", "t", "ci", "iu", "v", "phi", "info", "zi", "xi", "qi", "multi", "b", "c", "gi", "di", "bi", "ij", "si", "pi", "slice", "it", "x", "ini", " ii", "ims", "ii"], "index": ["command", "inc", "prefix", "thread", "update", "end", "print", "location", "mix", "row", "create", "ci", "check", "iterator", "slice", "size", "key", "ice", "address", "I", "init", "axis", "value", "ex", "ind", "fail", "iter", "capacity", "loop", "scroll", "try", "when", "ix", "test", "node", "version", "interface", "e", "scale", "si", "rank", "z", "time", "no", "initial", "draw", "number", "id", "ai", "order", "point", "error", "ip", "instance", "dimension", "pos", "condition", "timeout", "local", "in", "connect", "Index", "n", "connection", "sort", "info", "action", "can", "start", "it", "loc", "find", "out", "ii", "empty", "num", "success", "pe", "seek", "list", "to", "act", "label", "active", "zero", "position", "all", "is", "j", "level", "total", "shape", "input", "search", "di", "x", "max", "name", "offset", "length"], "count": ["depth", "num", "current", "more", "sum", "buffer", "ch", "call", "code", "order", "counter", "list", "cart", "hash", "ind", "nt", "iter", "size", "cycle", "act", "limit", "ount", "l", "cd", "type", "zero", "common", "consider", "process", "cc", "handle", "core", "try", "amount", "cont", "chain", "total", "n", "coll", "collection", "cap", "t", "currency", "Count", "now", "v", "info", "ctx", "cache", "ctr", "c", "found", "h", "start", "nb", "z", "max", "name", "offset", "length", "find", "number"], "dsize": [" dscore", "moffset", "wci", "wtype", "msw", "mSize", "dSize", " dci", "dimsize", " dtype", "msize", "doffset", "ddscale", "djscale", "djsw", "ddoffset", "wsize", "dci", " dsum", "tize", "Dscore", "dtype", " dize", "dscale", "tsize", "dsw", "mscale", "djoffset", "Dsum", "djsize", "mize", "msum", "dimize", "dsum", "dimscore", "dscore", "tci", "ddsize", "DSize", "ttype", " dSize", "ddsw", "Dize", "Dsize", "dize", "wize", "dimSize"], "mc": ["ms", "tm", " MC", "MT", "mb", "mx", "pc", "mm", "cam", "Mc", "mic", "bc", "dc", "g", "m", "tc", "bm", "mn", "cc", "mi", "md", "isc", "MC", "ma", "ctx", "lc", "c", "cm", "fc", "mac", "mp", "vm", "mt"]}}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n", "idx": 8526, "substitutes": {"f": ["fab", "tf", "off", "fd", "fi", "fw", "bf", "fl", "fo", "uf", "q", "ff", "file", "p", "rf", "df", "fp", "cf", "fm", "d", "ut", "g", "l", "fb", "um", "ret", "lf", "tif", "fa", "through", "fn", "y", "t", "ac", "of", "new", "v", "conf", "fr", "sf", "e", "b", "c", "fac", "F", "w", "fs", "fc", "x", "full", "fx", "ft", "out", "af", "xf"], "opaque": [" opula", "Opaque", "iopque", "bolay", "pque", "Oplay", "OPiera", "opaques", "opque", "iopula", "oplay", "iopiera", " opaques", "OPaque", "Opaques", " oplay", "paque", "boula", "Opula", "OPula", "pula", "boaque", "iopaque", "OPque", "opula", "opiera", "piera", "boaques"], "s": ["ms", "events", "sq", "vs", "spec", "sl", "qs", "ats", "rs", "as", "hs", "p", "gs", "sts", "an", "ps", "ess", "changes", "bits", "ins", "sv", "ses", "ies", "es", "args", "bs", "so", "params", "us", "aws", "details", "is", "js", "als", "S", "ss", "ts", "its", "se", "conf", "ops", "os", "sb", "has", "b", "sw", "bis", "results", "ns", "stats", "des", "serv", "comm", "sis", "ls", "ims", "ds", "sys", "parts"], "i": ["ms", " m", "u", "print", "m", " pi", " multi", " x", "y", "t", "ci", "zi", " v", " mi", "gi", "iy", "pi", "slice", "oi", "hi", "ji", "asi", "ami", "status", "I", "li", "uri", "init", "ri", "ex", "ind", "g", "ki", "ti", " ti", "mi", "MI", "ix", " l", "xi", "multi", "qi", " index", "si", "batch", "id", "ai", "ei", "iq", "ui", "my", "ic", "in", "index", "chain", "\u0438", "info", "remote", " p", "it", "ini", " bi", " my", "ii", "me", " I", "p", "sim", "cli", "us", "is", "j", "iu", "v", "di", "bi", "x", " ii", " j"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static void exit_program(void)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        avfilter_graph_free(&filtergraphs[i]->graph);\n\n        for (j = 0; j < filtergraphs[i]->nb_inputs; j++) {\n\n            av_freep(&filtergraphs[i]->inputs[j]->name);\n\n            av_freep(&filtergraphs[i]->inputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->inputs);\n\n        for (j = 0; j < filtergraphs[i]->nb_outputs; j++) {\n\n            av_freep(&filtergraphs[i]->outputs[j]->name);\n\n            av_freep(&filtergraphs[i]->outputs[j]);\n\n        }\n\n        av_freep(&filtergraphs[i]->outputs);\n\n        av_freep(&filtergraphs[i]->graph_desc);\n\n        av_freep(&filtergraphs[i]);\n\n    }\n\n    av_freep(&filtergraphs);\n\n\n\n    /* close files */\n\n    for (i = 0; i < nb_output_files; i++) {\n\n        AVFormatContext *s = output_files[i]->ctx;\n\n        if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb)\n\n            avio_close(s->pb);\n\n        avformat_free_context(s);\n\n        av_dict_free(&output_files[i]->opts);\n\n        av_freep(&output_files[i]);\n\n    }\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        AVBitStreamFilterContext *bsfc = output_streams[i]->bitstream_filters;\n\n        while (bsfc) {\n\n            AVBitStreamFilterContext *next = bsfc->next;\n\n            av_bitstream_filter_close(bsfc);\n\n            bsfc = next;\n\n        }\n\n        output_streams[i]->bitstream_filters = NULL;\n\n        avcodec_free_frame(&output_streams[i]->filtered_frame);\n\n\n\n        av_freep(&output_streams[i]->forced_keyframes);\n\n        av_freep(&output_streams[i]->avfilter);\n\n        av_freep(&output_streams[i]->logfile_prefix);\n\n        av_freep(&output_streams[i]);\n\n    }\n\n    for (i = 0; i < nb_input_files; i++) {\n\n        avformat_close_input(&input_files[i]->ctx);\n\n        av_freep(&input_files[i]);\n\n    }\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        av_frame_free(&input_streams[i]->decoded_frame);\n\n        av_frame_free(&input_streams[i]->filter_frame);\n\n        av_dict_free(&input_streams[i]->opts);\n\n        av_freep(&input_streams[i]->filters);\n\n        av_freep(&input_streams[i]);\n\n    }\n\n\n\n    if (vstats_file)\n\n        fclose(vstats_file);\n\n    av_free(vstats_filename);\n\n\n\n    av_freep(&input_streams);\n\n    av_freep(&input_files);\n\n    av_freep(&output_streams);\n\n    av_freep(&output_files);\n\n\n\n    uninit_opts();\n\n\n\n    avfilter_uninit();\n\n    avformat_network_deinit();\n\n\n\n    if (received_sigterm) {\n\n        av_log(NULL, AV_LOG_INFO, \"Received signal %d: terminating.\\n\",\n\n               (int) received_sigterm);\n\n        exit (255);\n\n    }\n\n}\n", "idx": 8534, "substitutes": {"i": ["ie", "m", "parent", "im", "y", "ci", "zi", "gi", "iii", "pi", "oi", "hi", "ji", "history", "ims", "depth", "ami", "status", "I", "li", "uri", "init", "ri", "ind", "ni", "ki", "ti", "ia", "mi", "ir", "ix", "iti", "xi", "e", "multi", "qi", "si", "batch", "loading", "id", "ai", "ei", "iq", "associated", "iri", "ui", "ip", "l", "ic", "in", "index", "chain", "\u0438", "phi", "info", "remote", "er", "it", "ini", "ii", "fi", "me", "io", "q", "list", "to", "sim", "this", "json", "ish", "cli", "us", "is", "series", "iu", "v", "ik", "bi", "di", "x", " ii", "ij"], "j": ["jac", "col", "je", "obj", "bj", "xy", "aj", "ja", "jump", "J", "jc", "at", "pt", "jo", "q", "err", "ev", "k", "p", "job", "jit", "kid", "Ja", "d", "g", "jp", "note", "m", "other", "my", "json", "jj", "js", "uj", "br", "n", "y", "jas", "ix", "jl", "v", "bo", "fr", "pr", "b", "ijk", "kh", "bi", "str", "adj", "oj", "res", "er", "it", "z", "dj", "msg", "el", "ji", "jack", "kj", "ij"], "s": ["ms", "sq", "vs", "sl", "qs", "a", "ats", "rs", "as", "hs", "p", "gs", "sts", "ps", "g", "cs", "l", "m", "es", "sv", "sam", "xs", "bs", "us", "aws", "als", "js", "is", "S", "ss", "ts", "less", "its", "n", "sports", "ctx", "self", "os", "sb", "has", "c", "h", "acs", "ns", "fs", "ls", "ds"], "bsfc": ["bitslc", "bsFC", "bitsac", "bisfc", "bsdc", "bisf", "bsf", "bisFC", "bslc", "oscf", "cslc", "bsac", "ubsfp", "bpscf", "csdc", "bitsfc", "lsfp", "bitsfp", "utsmc", "gscf", "utsfc", "lscf", "csfc", "jsfc", "jscf", "bsfp", "ubsmc", "csfp", "psfc", "jslc", "bscf", "gsf", "osFC", "jsdc", "pslc", "cscf", "pscf", "lsac", "psmc", "osfc", "bpslc", "bpsfc", "ubsfc", "psac", "lsfc", "bitscf", "gsfc", "bitsdc", "bsmc", "ubscf", "bpsfp", "osf", "biscf", "utsfp", "utscf", "psfp", "gsFC"], "next": ["inner", "eq", "current", "secondary", "aj", "entry", " Next", "nl", "join", "behind", "soft", "prev", "Next", "child", "nz", "pool", "dev", "seq", "follow", "first", "sec", "future", "foreign", "jp", "other", "front", "def", "sequence", "later", "ptr", "nn", "parent", "desc", "after", "again", "ext", "inv", "chain", "n", "last", "ctx", "new", "big", "gen", "primary", "env", "tech", "adj", "dot", "link", "z", "get", "context", "gt", "head", "max", "nd", "append", "sys"]}}
{"project": "qemu", "commit_id": "091b1108ca6d6e3bfaea5f095f219bf5ea8c316b", "target": 1, "func": "static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n    int ret;\n\n    int changed;\n\n\n\n    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n    changed = cow_test_bit(bitnum, bitmap);\n\n    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n    return changed;\n\n}\n", "idx": 8543, "substitutes": {"bs": ["vs", "bf", "bp", "rs", "bas", "hs", "gs", "bl", "sts", "ps", "bc", "BS", "cs", "bm", "bn", "las", "js", "ss", "ts", "its", "pb", "bos", "bps", "lbs", "ubs", "ubis", "sb", "b", "bis", "bh", "bi", "ns", "cms", "fs", "bd", "bb", "blog", "ls", "bt", "s", "ds"], "sector_num": ["sector2num", "sector__number", " sector_mon", "sector_nam", "sector_n", "row_nm", " sector_nam", "sector_mon", "sector_number", "sector__num", " sector_number", "sector2mon", "sector_id", "sector2nam", "sector2number", "sector2n", "row_num", "sector2nm", "sector__mon", "sector_nm", "sector2id", "sector__nam", "row_id", "row_n"], "nb_sectors": ["nb_eards", "nb_becs", "nb_beors", "nb_iterards", "nb_veards", "nb_iterctors", "nb_vecs", "nb_seards", "nb_seors", "nb_ectors", "nb_veors", "nb_iterors", "nb_veivers", "nb_specs", "nb_speors", "nb_severs", "nb_evers", "nb_speivers", "nb_beivers", "nb_vevers", "nb_spectors", "nb_vectors", "nb_secs", "nb_eors", "nb_bectors", "nb_itervers", "nb_seivers"], "num_same": ["num__same", "nb00same", " num_shared", "num00good", "num00unique", " num_each", "nb00good", "num_unique", "num_repeat", "num__unique", "num00same", "nb_same", "nb_good", "nb_unique", "nb00repeat", "num00repeat", "nb00unique", "num_good", "num_shared", "num__good", "num__repeat", "num_Same", " num_Same", "num_each", "nb_repeat"], "bitmap": ["bugnum", "binmap", "bugmap", "bitsmask", "bitsmaps", "basemap", "bitlist", "blockmap", "bytemaps", " bitcode", "bitbuffer", "bitmaps", " bitmask", "Bitmap", "hexmap", "hexblock", "bitnum", " bitset", " bitmaps", "binnum", "bugset", "bytemap", "blockmask", "Bitbuffer", "blockbuffer", "Bitmask", "basecode", "basemaps", "lockmaps", " bitnum", "lockbuffer", "bitMap", "bugMap", "blocknum", "Bitnum", "lockcode", "binset", "bitslist", "bitcode", "basebuffer", "Bitblock", "hexnum", "bitset", "binMap", "bitsmap", " bitlist", "bitmask", "bitblock", "blockblock", " bitMap", "bytemask", "bytelist", "lockmap", " bitbuffer"], "ret": ["tr", "lit", "reset", " RET", "status", "url", "code", "flag", "err", "print", "det", "RET", "resp", "f", "nt", "prot", "rev", "jp", "ref", " Ret", "def", "git", "fun", "mt", "after", "desc", "txt", "checked", "alt", "ter", "cont", "pent", "j", "t", "rem", "rets", "repl", "deg", "not", "val", "Ret", "red", "found", "cmd", "rt", "re", "elt", "res", "pert", "eret", "result", "gt", "out"], "changed": ["colored", "len", "Changed", " updated", "jump", "created", "rolled", "modified", "bool", "anged", "tested", "different", "changes", "ref", "confirmed", "wired", "ended", "broken", "written", "failed", "checked", " unchanged", "edited", "index", "started", "n", "new", "adjusted", "updated", "added", "initialized", "hidden", "aligned", "change", "count", "ed", "found", "used", "forced", "diff", "loaded", "locked", "connected", "joined", "rendered", "set", "disabled", "required"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 8565, "substitutes": {"timer_list": ["timer_li", "Timer_List", "timerPleft", "timeristnet", "timer_name", "timer_alist", "timerriclist", "wrapperistname", "coord_alist", "coordistalist", "timer_lists", "timerricalist", "timeristcollection", "Timer_table", "timeristname", "timer_link", "timeristadd", "wrapper_collection", "ter_left", "wrapperistadd", "ter_listed", "timer_int", "timeristalist", "imer_list", "wrapper_add", "timer_listed", "Timer_tree", "timeraccollection", "ter_list", "timeracadd", "timeritycollection", "wrapperistcollection", "timeritylist", "timeracname", "timer_net", "coord_int", "coordistint", "imer_lists", "imer_listed", "timer_table", "timeristint", "imer_link", "coord_net", "imer_collection", "Timer_list", "timeraclist", "timer_LIST", "wrapper_name", "timeristlist", "timeristlink", "imer_alist", "timeristlists", "timeritytree", "wrapperistlist", "timerPlist", "timer_module", "coord_list", "timer_collection", "timerityList", "imer_li", "timerPlisted", "timerPLIST", "timer_List", "timerricnet", "coordistlist", "imer_module", "timeristlisted", "wrapper_list", "timer_add", "ter_LIST", "timeritytable", "timerricint", "coordistnet", "timeritylists", "timer_left", "timer_tree"], "expire_time": ["exiryzsequence", "expirextime", "expiration_time", "expirepttime", "expire_no", "exiryzstart", "expire_delay", "exiry_lock", "exiry_sequence", "expireUtime", "expirezlock", "expireptsequence", "expireThetime", "expiration_count", "expire_Time", "expirezstart", "exiry_start", "expiretimetime", "expiration_delay", "expire_lock", "exiryUno", "expireThelock", "expirexcount", "exiry_ime", "exiryUtime", "expire_start", "expiration_start", "expireptlock", "expire_count", "expirematime", "expireThesequence", "expirematno", "expiretimestart", "expireUime", "exiryUime", "expireThestart", "expireptstart", "expireztime", "exiryztime", "expireUno", "expiration_Time", "expire_ime", "exiry_time", "expirezsequence", "expiretimeTime", "expiremattime", "exiry_no", "expirexdelay", "expirexTime", "expire_sequence", "exiryzlock"]}}
{"project": "qemu", "commit_id": "e97fc193e1c65deb51643d5251e98affe07c59ca", "target": 0, "func": "static void check_refcounts(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t size;\n\n    int nb_clusters, refcount1, refcount2, i;\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n\n\n    size = bdrv_getlength(s->hd);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  0, s->cluster_size);\n\n\n\n    check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                           sn->l1_table_offset, sn->l1_size, 0);\n\n    }\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->refcount_table_offset,\n\n                  s->refcount_table_size * sizeof(uint64_t));\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        int64_t offset;\n\n        offset = s->refcount_table[i];\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, refcount_table, nb_clusters,\n\n                          offset, s->cluster_size);\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2)\n\n            fprintf(stderr, \"ERROR cluster %d refcount=%d reference=%d\\n\",\n\n                   i, refcount1, refcount2);\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n}\n", "idx": 8568, "substitutes": {"bs": ["jac", "ms", "obs", "vs", "cks", "ats", "aos", "bp", "rs", "css", "bas", "hs", "bes", "bl", "bles", "gs", "sts", "ps", "bc", "BS", "cs", "boxes", "bm", "bits", "outs", "fps", "iss", "bsp", "aus", "las", "irms", "js", "is", "its", "ts", "bos", "ss", "pb", "uses", "bps", "lbs", "ubs", "ops", "ubis", "os", "sb", "b", "bis", "bh", "acs", "ns", "bi", "fs", "blog", "ls", "bt", "oss", "ims", "hz", "ds"], "s": ["ms", "vs", "sq", "ashes", "spec", "sl", "qs", "a", "ats", "gets", "settings", "rs", "as", "hs", "p", "gs", "sts", "ps", "changes", "g", "cs", "m", "bits", "ins", "sv", "ses", "sam", "args", "es", "aws", "is", "js", "less", "S", "ss", "ts", "its", "n", "y", "als", "details", "irs", "state", "v", "conf", "ops", "os", "sb", "b", "scripts", "c", "h", "ns", "stats", "w", "fs", "stat", "comm", "ls", "states", "ims", "ds", "sys", "parts"], "size": ["len", "empty", "small", " sizes", "num", "id", "sum", "network", "resolution", "base", "area", "sp", "height", "south", "Size", "SIZE", "scope", "capacity", "l", "m", "type", "ize", "mem", "storage", "data", "total", "needed", "n", "t", "count", "zone", "v", "os", "shape", "dim", "scale", "start", "fee", "si", "options", "pi", "space", "z", "set", "memory", "time", "no", "max", "name", "length", "number"], "nb_clusters": ["nb_sclblocks", "nb_caocks", "nb_combiques", "nb_archutions", "nb_sclients", "nb_cluster", "nb_transusters", "nb_clusanches", "nb__clocks", "nb_lients", "nb_Clessions", "nb_explosures", "nb_cluers", "nb_relusters", "nb_clistries", "nb_cessions", "nb_clanches", "nb_relayers", "nb_sclusters", "nb_blodes", "nb_caosures", "nb_clusodes", "nb_volances", "nb__clusters", "nb_clusayers", "nb_glients", "nb_blocksayers", "nb_blocksodes", "nb_shores", "nb_decusters", "nb_cautions", "nbortexplusters", "nb2blroups", "nb_voluster", "nb_slUsers", "nb_cnusters", "nb_clodes", "nb__clanches", "nbortclistries", "nb_volosures", "nb_blroups", "nb_explistries", "nb2cients", "nb_transuers", "nb_clusograms", "nb_clusords", "nb_Cliques", "nb_decistries", "nb_clators", "nb_clocks", "nbortclograms", "nbortexplistries", "nb_shusters", "nb_combuster", "nb_blocksusters", "nb_explograms", "nb_clayers", "nb_clows", "nb_descators", "nbortclusters", "nb_explusters", "nb_clUsers", "nb_cnessions", "nb2blusters", "nb_clonents", "nb_clusutions", "nb2blients", "nb_locators", "nb_clessions", "nb_blusters", "nbortexplograms", "nb_locuers", "nb_combances", "nb_glodes", "nb2clusters", "nb2custers", "nb_caonents", "nb_combusters", "nb_descuers", "nb2clroups", "nb_archusters", "nb2clodes", "nb_relords", "nb2cluster", "nb_volusters", "nb_clograms", "nb_clients", "nb_shients", "nb_sclUsers", "nb_clances", "nb_caanches", "nb_custers", "nb_caances", "nb_cliques", "nb_archanches", "nb_transows", "nb_relodes", "nb_closures", "nb2blodes", "nb_cnients", "nb2cessions", "nb_descusters", "nb_clusosures", "nb_Clances", "nbortexplosures", "nb_clores", "nb_clroups", "nb_CLblocks", "nb_losures", "nb_transators", "nb_descows", "nb_Clients", "nb_locows", "nb_CLores", "nb_custer", "nbortclosures", "nb_clords", "nb_locusters", "nb_CLients", "nb_volonents", "nb_Clusters", "nb_voliques", "nb_shblocks", "nb2clients", "nb_lodes", "nb__clutions", "nb_lroups", "nb_clususters", "nb_slutions", "nb_CLusters", "nb_glusters", "nb_Cluster", "nb_clutions", "nb_clblocks", "nb_cnuster", "nb_decograms", "nb_sclutions", "nb_lances", "nb_lonents", "nb_blients", "nb_sclores", "nb_clusocks", "nb_cients", "nb_clusistries", "nb_blocksords", "nb2custer", "nb_slanches", "nb2clessions", "nb_decosures", "nb_archUsers", "nb_glroups", "nb_causters", "nb_sclanches", "nb_lusters", "nb_slusters"], "refcount1": ["refCount1", "refcount0", "refcountOnce", "refount11", "relount2", "refempt1", "refcache2", "fount3", "refCount2", " refcount001", "refcount9", "refsum0", "refcore2", "refount2", "refount1", "refcore0", "refcore11", "reffilter_", "defount8", "defount0", "fcount2", "refcore1", "refountOnce", "reffilterOnce", "refempt001", "defcount1", " refount_", "refsum8", "fount2", "defount1", "refount_", "refcount_", "refcount3", " refount001", "refempt_", "relcount9", "relountOne", "reffilter1", "refount01", "refount8", "refcache1", "refCount01", "refount9", "refcount8", "fcount3", "refcount11", "refcore8", "defcount0", "defcount11", "relount9", "refemptOnce", "refCount9", "fount1", "refount001", "relcountOne", "refCount3", " refountOnce", "refount3", "relcount1", "relcount2", "reffilter001", " refount1", "fcount01", "defount11", "refcount001", "refCountOne", "defcount8", "refcache01", "refcountOne", "fount01", " refcount_", "refountOne", "refcache3", "refcoreOne", "relount1", "refcore9", "refsum11", "fcount1", "refsum1", "refcount01", "refount0", " refcountOnce"], "refcount2": ["refcount256", " refcount0", "memcount256", "refcache4", "memount2", "refcore0", " refcounttwo", "refcycle4", "refcmd0", "refount256", "relount02", "refcache0", "refCount1", "refount4", "refcount0", "refCounttwo", "relcount02", "refcache1", "refchild256", "refchild2", "memcount02", "refount02", "refcmd2", "refcycletwo", "relounttwo", "relount2", "refcount02", "refcore1", "refcmd1", " refCount0", "refcache2", "refchild02", " refCount2", "refcycle2", " refCount1", "relcounttwo", "refc256", "memount02", "refCount2", "refcoretwo", "refcore2", "refcachetwo", "memcount2", "relcount4", "refcounttwo", " refCounttwo", "refcycle02", "relount4", "relcount2", "refcache02", "refounttwo", "memount256", "refc2", "refcount4", "refount0", "refc02", "refount2", "refCount0", "refount1"], "i": ["print", "span", "o", "m", "parent", "im", "y", "ci", "zi", "gi", "pi", "oi", "hi", "ji", "ims", "key", "ami", "status", "I", "li", "init", "ri", "ind", "iter", "g", "um", "ki", "ti", "mi", "MI", "ix", "xi", "multi", "qi", "e", "si", "batch", "yi", "id", "ai", "ei", "err", "point", "iri", "f", "ui", "ip", "inter", "ic", "in", "index", "chain", "n", "mc", "\u0438", "phi", "info", "remote", "er", "by", "it", "ini", "ii", "fi", "me", "p", "sim", "this", "cli", "us", "j", "iu", "v", "ik", "di", "bi", "x", "ij"], "sn": ["sq", "sl", "nl", "gn", "sol", "nex", "Sn", "span", "sp", "bl", "eni", "sm", "nt", "cs", "rn", "sv", "nn", "sam", "bn", "dn", "ln", "snap", "ss", "n", "ski", "SN", "fn", "wn", "kn", "tn", "sf", "sb", "sw", "sh", "cn", "ns", "sbm", "sa", "sr", "serv", "si", "stat", "sc", "ny", "sd", "syn", "pn"], "refcount_table": ["refstore_table", "refcount_database", "refcount2table", "refcount2db", "refcache_table", "refcount8table", "refattribute_table", "refcount32Table", "refstorepledatabase", "refstatus2point", "refstatus_point", "refcode_tab", "refref_pool", "refcount_cache", "refcodestable", "refstorepletable", "refcounttcontainer", "refcount_term", "refstore_term", "refstatus2try", "refcountpledatabase", "refcount2point", "refCount_table", "refref_t", "refstore_pool", "refcount_container", "refcountsTable", "refcountttable", "refcodestab", "refcounttscope", "refattribute32source", "refcount_t", "refcount32iterator", "refstatus_try", "refcount_trace", "refcountingpool", "refcount2TABLE", "refstatus_table", "refrefspool", "refcount8tab", "refcount_scope", "refcount_list", "refattribute_iterator", "refattribute32iterator", "refstorepleterm", "refstatus2table", "refcountplepoint", "refcountst", "refcount8t", "refcount_try", "refcountpletry", "refcountpleterm", "refcount_db", "refcount_map", "refcount8pool", "refstatus_cache", "refcode_trace", "refstore_database", "refcodesdatabase", "refcountdcontainer", "refcountplepool", "refcountsdatabase", "refountttable", "refcount32table", "refcount_tab", "refCount_db", "refcode_database", "refcode_table", "refcountingdatabase", "refcountdtable", "refcount_Table", "refcountsTABLE", "refcount_iterator", "refref_table", "refounttcontainer", "refcountstable", "refattribute_source", "refcount_TABLE", "refCount_tab", "refcache_buffer", "refCount_list", "refcount32source", "refcache_list", "refcountstrace", "refcountplesource", "refcache_type", "refattribute32Table", "refcount_source", "refcountpleiterator", "refrefst", "refrefstab", "refattribute32table", "refcountpleTable", "refCount_map", "refcodestrace", "refcountingtable", "refcount_type", "refattribute_Table", "refref_tab", "refstoreplepool", "refCount_TABLE", "refount_container", "refcount_pool", "refcountplecache", "refount_table", "refcount_buffer", "refcount2try", "refrefstable", "refcount_point", "refcount2tab", "refcountdscope", "refcountspool", "refcountstab", "refcountingterm", "refcount2cache", "refounttscope", "refcountpletable", "refount_scope", "refstatus2cache"], "offset": ["key", "shift", "frequency", "off", "extra", "entry", "address", "prefix", "source", "pointer", "padding", "end", "seek", "point", "o", "height", "field", "error", "fp", "slot", "volume", "tile", "instance", "location", "pos", "timeout", "zero", "ptr", "position", "balance", "port", "window", "trace", "unk", "index", "attribute", "total", "needed", "Offset", "cache", "ace", "tmp", "option", "origin", "iterator", "start", "oe", "missing", "alias", "slice", "options", "link", "set", "angle", "length"]}}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static int ipoctal_init(IPackDevice *ip)\n\n{\n\n    IPOctalState *s = IPOCTAL(ip);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < N_CHANNELS; i++) {\n\n        SCC2698Channel *ch = &s->ch[i];\n\n        ch->ipoctal = s;\n\n\n\n        /* Redirect IP-Octal channels to host character devices */\n\n        if (ch->devpath) {\n\n            const char chr_name[] = \"ipoctal\";\n\n            char label[ARRAY_SIZE(chr_name) + 2];\n\n            static int index;\n\n\n\n            snprintf(label, sizeof(label), \"%s%d\", chr_name, index);\n\n\n\n            ch->dev = qemu_chr_new(label, ch->devpath, NULL);\n\n\n\n            if (ch->dev) {\n\n                index++;\n\n\n                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,\n\n                                      hostdev_receive, hostdev_event, ch);\n\n                DPRINTF(\"Redirecting channel %u to %s (%s)\\n\",\n\n                        i, ch->devpath, label);\n\n            } else {\n\n                DPRINTF(\"Could not redirect channel %u to %s\\n\",\n\n                        i, ch->devpath);\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 8577, "substitutes": {"ip": ["ipp", "imp", "net", "address", "arp", "io", "pp", "up", "zip", "p", "ipe", "iso", "sp", "cp", "lip", "ap", "ep", "port", "ic", "inet", "addr", " sip", "ix", "phy", "ock", "isp", "chip", "host", "hip", "ips", "wp", "ipop", "pipe", "it", "mac", "phys", "mp", "IP"], "s": ["sq", "a", "ats", "rs", "as", "hs", "p", "gs", "sts", "sp", "sm", "o", "ps", "ess", "g", "m", "bits", "sv", "sam", "ses", "es", "bs", "so", "aws", "r", "is", "js", "S", "ss", "ts", "n", "se", "t", "ssl", "v", "conf", "self", "os", "sb", "b", "e", "c", "h", "ns", "fs", "sis", "ls", "ims", "ds", "sys"], "i": ["id", "ai", "I", "me", "li", "init", " I", "print", "list", "ri", "p", "point", "sim", "ex", "ind", "f", "ui", "name", "d", "mount", "g", "m", "l", "ki", "ti", "ic", "in", "mi", "is", "chain", "j", "im", "ix", "n", "y", "interface", "t", "ci", "iu", "count", "zi", "info", "v", "xi", "multi", "qi", "c", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "z", "ini", " ii", " bi", "ims", " j", "out", "ii"], "ch": ["col", "Ch", "kr", "mot", "hand", "ah", "gh", "sky", "ctrl", "channel", "chan", "sch", "ct", "chn", "ev", "range", " Ch", "form", "p", "ach", "cl", "ich", "cp", "gr", "th", "chart", "cs", "l", "hl", "arch", "cb", "cand", "cht", "wh", "cho", "cod", "j", "br", "y", "ctx", "qu", "check", "v", "zh", "conf", "och", "che", "mk", "c", "sh", "cmd", "h", "kh", "ot", "cm", "sc", "tch", "ech", "x", "chu", "comm", "z", "CH", "cr", "history", "loc", "ht", "cha"], "chr_name": ["char_name", "chrl_name", "chp2Name", "chp_names", "chr_Name", "chrl_num", "chr_attr", "chp2name", "char_names", "chp_Name", "char_attr", "chr_names", "chr2names", "chr_num", "chp_name", "chr_len", "chrl_len", "chp2names", "chr2name", "chr2Name", "chrl_names"], "label": ["button", "align", "key", "NAME", "len", "display", "id", "address", "nl", "path", "text", "message", "prefix", "leader", "tex", "summary", "cell", "list", "span", "els", "field", "error", "ind", "slot", "name", "l", "type", "local", "LI", "desc", "tab", "layout", " Label", "ell", "lab", "handle", "abel", "ID", "data", "node", "dl", "sort", "class", "line", "comment", "title", "Label", "str", "EL", "alias", "color", "link", "msg", "group", "el", "description", "LAB", "loc", "L", "state"], "index": ["num", "success", "id", "address", "status", "path", "axis", "IND", "list", "point", "insert", "f", "ind", "d", "instance", "dimension", "pos", "condition", "zero", "position", "length", "is", "row", "j", "Index", "level", "data", "node", "n", "state", "new", "count", "from", "si", "slice", "x", "z", "context", "speed", "name", "loc", "offset", "size", "find", "number"]}}
{"project": "qemu", "commit_id": "8417cebfda193c7f9ca70be5e308eaa92cf84b94", "target": 1, "func": "static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n", "idx": 8592, "substitutes": {"r1": ["rc001", "rcOne", "mr01", "r3", " r01", "rc1", "w1", "mr3", " r3", " r4", "br01", "rt3", " rOne", "w01", "gr1", "r4", "mr1", "rcFirst", "br1", "mr4", "rt1", "rt01", "r001", "r01", "rFirst", "rOne", " rFirst", "br001", "rt4", "w001", "grFirst", "grOne", " r001", "gr001"], "r2": ["RTwo", "res1", "w2", "rt2", "restwo", "r3", " r02", "stwo", "sg", "rc1", " rtwo", "s2", "R02", "wtwo", "rt3", "s3", "Rtwo", " r6", "r6", "rTwo", "rc6", "rc2", "R1", " rTwo", "rg", "wg", "rcTwo", "res02", "res2", "R6", "rttwo", "R2", "w3", "rtg", "r02", "rtwo"]}}
{"project": "FFmpeg", "commit_id": "7fffc879798bbbad647ad2b1b30f26855bf2abda", "target": 0, "func": "static int wc3_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    Wc3DemuxContext *wc3 = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    unsigned int fourcc_tag;\n\n    unsigned int size;\n\n    AVStream *st;\n\n    unsigned char preamble[WC3_PREAMBLE_SIZE];\n\n    int ret = 0;\n\n    int current_palette = 0;\n\n    int bytes_to_read;\n\n    int i;\n\n    unsigned char rotate;\n\n\n\n    /* default context members */\n\n    wc3->width = WC3_DEFAULT_WIDTH;\n\n    wc3->height = WC3_DEFAULT_HEIGHT;\n\n    wc3->palettes = NULL;\n\n    wc3->palette_count = 0;\n\n    wc3->pts = 0;\n\n    wc3->video_stream_index = wc3->audio_stream_index = 0;\n\n\n\n    /* skip the first 3 32-bit numbers */\n\n    url_fseek(pb, 12, SEEK_CUR);\n\n\n\n    /* traverse through the chunks and load the header information before\n\n     * the first BRCH tag */\n\n    if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n        WC3_PREAMBLE_SIZE)\n\n        return AVERROR(EIO);\n\n    fourcc_tag = AV_RL32(&preamble[0]);\n\n    size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    do {\n\n        switch (fourcc_tag) {\n\n\n\n        case SOND_TAG:\n\n        case INDX_TAG:\n\n            /* SOND unknown, INDX unnecessary; ignore both */\n\n            url_fseek(pb, size, SEEK_CUR);\n\n            break;\n\n\n\n        case _PC__TAG:\n\n            /* need the number of palettes */\n\n            url_fseek(pb, 8, SEEK_CUR);\n\n            if ((ret = get_buffer(pb, preamble, 4)) != 4)\n\n                return AVERROR(EIO);\n\n            wc3->palette_count = AV_RL32(&preamble[0]);\n\n            if((unsigned)wc3->palette_count >= UINT_MAX / PALETTE_SIZE){\n\n                wc3->palette_count= 0;\n\n                return -1;\n\n            }\n\n            wc3->palettes = av_malloc(wc3->palette_count * PALETTE_SIZE);\n\n            break;\n\n\n\n        case BNAM_TAG:\n\n            /* load up the name */\n\n            if ((unsigned)size < 512)\n\n                bytes_to_read = size;\n\n            else\n\n                bytes_to_read = 512;\n\n            if ((ret = get_buffer(pb, s->title, bytes_to_read)) != bytes_to_read)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case SIZE_TAG:\n\n            /* video resolution override */\n\n            if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n                WC3_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            wc3->width = AV_RL32(&preamble[0]);\n\n            wc3->height = AV_RL32(&preamble[4]);\n\n            break;\n\n\n\n        case PALT_TAG:\n\n            /* one of several palettes */\n\n            if ((unsigned)current_palette >= wc3->palette_count)\n\n                return AVERROR_INVALIDDATA;\n\n            if ((ret = get_buffer(pb,\n\n                &wc3->palettes[current_palette * PALETTE_SIZE],\n\n                PALETTE_SIZE)) != PALETTE_SIZE)\n\n                return AVERROR(EIO);\n\n\n\n            /* transform the current palette in place */\n\n            for (i = current_palette * PALETTE_SIZE;\n\n                 i < (current_palette + 1) * PALETTE_SIZE; i++) {\n\n                /* rotate each palette component left by 2 and use the result\n\n                 * as an index into the color component table */\n\n                rotate = ((wc3->palettes[i] << 2) & 0xFF) |\n\n                         ((wc3->palettes[i] >> 6) & 0xFF);\n\n                wc3->palettes[i] = wc3_pal_lookup[rotate];\n\n            }\n\n            current_palette++;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\\n\",\n\n                preamble[0], preamble[1], preamble[2], preamble[3],\n\n                preamble[0], preamble[1], preamble[2], preamble[3]);\n\n            return AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n\n\n        if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=\n\n            WC3_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n        fourcc_tag = AV_RL32(&preamble[0]);\n\n        /* chunk sizes are 16-bit aligned */\n\n        size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    } while (fourcc_tag != BRCH_TAG);\n\n\n\n    /* initialize the decoder streams */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_XAN_WC3;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = wc3->width;\n\n    st->codec->height = wc3->height;\n\n\n\n    /* palette considerations */\n\n    st->codec->palctrl = &wc3->palette_control;\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->audio_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n    st->codec->codec_id = CODEC_ID_PCM_S16LE;\n\n    st->codec->codec_tag = 1;\n\n    st->codec->channels = WC3_AUDIO_CHANNELS;\n\n    st->codec->bits_per_sample = WC3_AUDIO_BITS;\n\n    st->codec->sample_rate = WC3_SAMPLE_RATE;\n\n    st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n        st->codec->bits_per_sample;\n\n    st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS;\n\n\n\n    return 0;\n\n}\n", "idx": 8617, "substitutes": {"s": ["a", "ats", "rs", "as", "hs", "p", "gs", "sts", "sp", "f", "o", "ps", "g", "cs", "m", "ins", "in", "js", "S", "ss", "ts", "n", "t", "v", "e", "sb", "b", "os", "c", "h", "ns", "w", "fs", "sc", "comm", "ds", "sys"], "ap": ["aps", "op", "al", "tp", "pp", " mp", " pac", " ip", "bp", "sp", " sp", "ps", " par", "ip", " af", "ep", "cap", "ac", "tap", " p", " op", "att", " sap", " cp", "mp", " pu", "ar", "pa"], "wc3": ["exc3", "wcan3", "warc15", "wcache3", "wrcdef", "rewcard", "wc33", "wcima", "wpc15", "wrc7", "wecThree", "wpcache15", "wgc4", "wcury", " wc2", "wcent", "wcu3", "wcam15", "wlc9", "wcma", "weightcuster", "wciion", "wcamdef", "wcant", "wallcThree", "wearcma", "wcat15", "rewco5", "warcware", "wearc9", " wcry", "wcache7", "exlc03", "wc15", "wvc03", "wavcThree", "exc9", "wconred", " wcc2", "wc9", "wc2", "winecat3", "wcware", "wcanent", "wcam7", "wallcogent", "winecatdef", "rewcwd", "wcp3", "wcwd", "wci7", "wccred", "wec3", "wci4", "memlcware", "wcry", "wallco3", "rewc5", "wpc7", "weightxc003", "wci3", "winecat03", "wayc4", "warc3", "wc03", "wayci15", " wcred", "writercan33", "wlcware", "excware", "wgc3", "wacmThree", "wallcgent", "memlcent", "wayc7", "warcdef", "wac3", "wecma", "wcoard", "wc7", "wcsant", "memcent", "wvcThree", "wtc3", "wlc4", "memlc03", "weightc03", "wcp9", "wcan33", "wcu33", "wacm3", "wcp03", "wcanry", "wvc3", "wxc03", "exlc9", "wayc3", "winecdef", "wtc03", "wayci7", "writercan3", "wcion", "wcpware", "winec3", "wcuster", "wconard", "winec15", "wcatdef", "wxcuster", "rewcowd", "wxc003", "wearcion", "wcon5", "weightxc3", "wcat3", "wcgent", "warcent", "wcatant", "wayci4", "wcuma", "warc9", "writerc33", "wavc03", "wacmant", "rewco3", "rewc3", "wc4", "memc3", "writercry", "weightxcuster", "wlcent", "wcam3", "wci5", "wtc33", "writercanry", "wcatuster", "wpcache3", "warcion", "wlcThree", "wlcgent", "wtcust", "wccry", "wcc003", "wcThree", "wlc03", "wacmred", "winec03", "warc03", "wcdef", "wacant", "wccuster", "wcat2", "wallcoThree", "wayc15", "wcachedef", "wallc7", "wecion", "wcc03", "wcmThree", "wavc3", "wcred", "wpcachedef", "writerc3", "wtcThree", " wccred", "wciard", " wcc3", "wc5", "wec03", "wcatry", "wcatred", "wgc15", "weightc003", "wcoThree", "wciwd", "wlc15", "wc003", "wpcache7", "wconry", "wcsred", "wacThree", "wcu9", "weightxc03", "wcache03", "wpc3", "wcat03", "wgc7", "wrc15", "wcuion", "wcat003", "wconwd", "wco5", "memcware", "wcache15", "wcsThree", "exlcware", "memlc3", "wcust", "wcon2", "wxc3", "wco3", "wcanust", "weightc3", " wccry", "wearc3", "wlc7", "wcm3", "wrc3", "wcan03", "winecat15", "wco7", "wlc3", "wcogent", "wallc3", "wpcdef", "wcc3", "wallco7", "rewcoard", "exlc3", "wcuust", "wec9", "wcmant", "wcanware", "wcatThree", "wcon3", "memc03", "wcowd", "exc03", "wac03", "wtcry", "wcc2", "wcard", "wcmred", "warcma", "wci15", "wayci3", "writercanust", "wvc7", "wci9", "wcs3", "wacred", "writercust", "wvcgent"], "pb": ["td", "lb", "typ", "pc", "tp", "ub", "mb", "buffer", "pp", "uf", "pt", "bp", "rb", "tk", "asm", "proc", "p", "resp", "buf", "amp", "cp", "fp", "pg", "vp", "jp", "np", "tc", "pkg", "fb", "um", "cb", "lp", "bs", "appy", "pm", "snap", "phy", "ctx", "bps", "erb", "pl", "sb", "wp", "tmp", "bh", "dp", "bb", "stab", "PB", "buff", "ib", "cv", "mp", "wb", "pa"], "fourcc_tag": ["fourcc2type", "fourCC_type", "fourcc__tag", "fourcc_type", "fourcc_count", "fourcc2tag", "fourck_count", "fourCC_tag", "fourck2TAG", "fourCC_TAG", "fourck_TAG", "fourck_tag", "fourck2type", "fourcc__TAG", "fourcc_TAG", "fourck__count", "fourck2tag", "fourcc__type", "fourck_type", "fourcc_flag", "fourcc2TAG", "fourck__type", "fourck__TAG", "fourck__tag", "fourcc__count", "fourCC_flag"], "size": ["grow", "small", "name", "storage", "data", "fee", "pi", "notice", "use", "message", "settings", "sp", "height", "Size", "capacity", "sv", "ize", "count", "scale", "si", "z", "number", "shift", "buffer", "ui", "SIZE", "timeout", "mem", "iz", "space", "style", "len", "empty", "password", "sum", "p", "position", "bytes", "v", "c", "false", "sn", "set", "sized", "general", "offset", "length"], "st": ["src", "sl", "std", "pt", "St", "ct", "sp", "bl", "sv", "sam", "ste", "so", "ss", "ist", "se", "fr", "sw", "tmp", "ST", "sn", "str", "est", "rest", "serv", "sc", "lo", "inst", "mt"], "preamble": ["pamble", "Preambler", "pipherstring", "repreambl", "pipherble", "prambles", "reprambl", "prombl", "parmbles", "pramble", "preambles", "spramBLE", "probment", "reprambles", "Preamble", "parmbler", "promble", "pamment", "preambler", "Preamment", "preamstring", "repreambles", "repreambled", "parmble", "Pambler", "reparmbled", "Pambled", " preambles", "pambl", "preambl", "spreambler", "pambles", "spreamble", " parmble", "parmbled", "repreamble", "pamBLE", "repramBLE", "prambl", "Pamble", "pipherBLE", "parmbl", "prombles", "Pambles", "prambled", "spreamstring", "parmment", "preambled", "promBLE", " parmBLE", "parmstring", " parmbler", "probbler", "probble", "preamBLE", "repreamBLE", "pramBLE", "spreamBLE", "repramble", "preamment", "spramble", "Preambled", "parmBLE", "Preambles", "probbles", " preambler", "reparmbl", "Pamment", "sprambler", "pramstring", "reparmble", " preamBLE", "spramstring", "reparmbles", "pambler", "prambler", " parmbles", "pipherbler", "pambled"], "bytes_to_read": ["bytes_to_Read", "bytes_to_write", "bytes_to_load"], "i": ["ati", "I", "io", "li", "p", "f", "iter", "iat", "ip", "m", "pos", "ti", "mi", "index", "is", "j", "im", "n", "t", "ci", "v", "c", "di", "pi", "si", "it", "ii"], "rotate": [" rotationation", "Rotator", "validation", "validated", "Rotate", "rotation", " rotationate", "Rotation", "Rotated", " rotationated", "validator", "rotated", " rotationator", "rotator", "validate"], "current_palette": ["current_pallete", "current_fillette", "current_Palettes", "current_palettes", "current_realette", "current_realettes", "current_filettes", "current_pallette", "current_Pallete", "current_filette", "current_fillete", "current_Pallette", "current_reallete", "current_reallette", "current_Palette"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static int64_t do_strtosz(const char *nptr, char **end,\n\n                          const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval;\n\n    char *endptr;\n\n    unsigned char c;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    c = *endptr;\n\n    mul = suffix_mul(c, unit);\n\n    if (mul >= 0) {\n\n        endptr++;\n\n    } else {\n\n        mul = suffix_mul(default_suffix, unit);\n\n        assert(mul >= 0);\n\n    }\n\n    if (mul == 1 && mul_required) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        retval = -ERANGE;\n\n        goto out;\n\n    }\n\n    retval = val * mul;\n\n\n\nout:\n\n    if (end) {\n\n        *end = endptr;\n\n    } else if (*endptr) {\n\n        retval = -EINVAL;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 8673, "substitutes": {"nptr": ["snpt", " nPtr", "endaddr", " npointer", "dnpad", "npt", "nnPtr", " npad", "npad", "snpointer", "Npt", "dnptr", "Ntr", " naddr", "nntr", "dnaddr", "dnPtr", "ncPtr", "nPtr", "ncpointer", "dntr", "snPtr", "endpt", "snptr", "dnpt", "naddr", "npointer", " npt", "nnpt", "endpad", "nnptr", "ntr", "NPtr", "Nptr", "ncptr", "ncpt"], "end": ["id", "reset", "use", "send", "pay", "add", "event", "begin", "endif", "wind", "ff", "bind", "except", "END", "post", "pad", "End", "eng", "stop", "cend", "gate", "client", "ep", "ended", "rend", "pend", "edge", "en", "bound", "chain", "ad", "ending", "close", "hend", "rest", "start", "est", "st", "ent", "nd", "ender", "append", "out", "pod"], "default_suffix": ["default___suffIX", "default___affendix", "default_sideendix", "default___affIX", "default_supprefix", "default_subixed", "default_affix", "default_affixed", "default_supixed", "default___suffendix", "default_subix", "default___affixed", "default_prefixix", "default___suffixed", "default_subprefix", "default___suffix", "default_suixed", "default_suffixed", "default_affendix", "default_suprefix", "default_suffendix", "default_sideix", "default_suix", "default_suffprefix", "default_sideixed", "default___affix", "default_affIX", "default_supix", "default_supfix", "default_sufffix", "default_sufix", "default_prefixixed", "default_subfix", "default_prefixendix", "default_sideIX", "default_suffIX", "default_prefixIX"], "unit": ["command", "key", "doc", "norm", "u", "units", "sum", "prefix", "io", "lang", "format", "base", "device", "weight", "nu", "file", "value", "p", "normal", "domain", "stable", "cat", "block", "note", "tc", "type", "util", "mod", "term", "mu", "bit", "chain", "version", "root", "t", " units", "dir", "Unit", "un", "out", "comment", "dim", "scale", "option", "rt", "it", "unt", "name", "size", "style"], "retval": [" retVAL", "extval", "Retval", "altval", " returnval", "reteval", "RETval", "retVal", "reeval", "revalue", " retvalue", "printvalue", " returneval", "exteval", "altserv", "Retserv", "altVAL", "resultvalue", "alteval", "printeval", " reteval", "redata", "reVAL", "printVAL", "RETVAL", "extv", " retVal", "altVal", "retvalid", "Retvalue", " retdata", "RETvalue", "retserv", "printval", "reval", "RetVAL", "RETeval", "Retv", "RetVal", "extvalue", "resultval", "RETVal", "retVAL", "RETdata", "altvalid", "retdata", " returnVal", "RETvalid", "Reteval", "retv", " returnVAL", " retserv", "Retvalid", "resulteval", "altvalue", "retvalue", "resultv"], "endptr": [" endPtr", "ndpt", "endaddr", "oldptr", "ENDsp", "oldpt", "endedptr", "oldpad", "startPtr", " endctr", "outptr", "ENDPtr", "endingptr", "entpointer", "endedpointer", "endedctr", "ndpointer", "endedtr", "endedaddr", "endedPtr", "ENDaddr", "outtr", " endcoord", "endsp", " endaddr", "entptr", "endedpt", "endingcoord", "ENDctr", "endpointer", "startreq", "endctr", "startpad", "ndptr", "endPtr", " endtr", "endcoord", "ENDtr", "endingaddr", "endreq", "endpt", "startpointer", "enttr", " endpt", "startptr", "outpointer", "startctr", "ENDpad", "ndpad", " endpointer", "endedsp", "ENDreq", "endpad", "ENDpointer", "endtr", "endingpointer", "ENDpt", " endpad", "startaddr", "startcoord", "ENDptr", "entctr", " endsp", "oldpointer", " endreq", "outpt", "starttr"], "c": ["col", "u", "con", "ct", "k", "p", "ec", "f", "cp", "cf", "dc", "cat", "g", "tc", "cs", "l", "cd", "cb", "unc", "cc", "ce", "cont", "chain", "n", "t", "ctx", "ac", "ci", "rc", "v", "lc", "gc", "cache", "b", "cn", "uc", "cu", "fc", "sc", "C", "co", "cv", "cr", "ca"], "val": [" sv", "xy", "u", " arg", " value", "update", "func", " al", " aval", "util", "eval", " x", "data", " v", "pr", "pl", "bal", "elt", "el", "vol", " eval", " ty", "tx", "al", "call", "li", "VAL", "value", " res", "au", "sv", " el", "cal", "test", " vol", " tx", " ret", "vals", " vel", " valid", " ptr", "pt", "crit", "ev", " interval", "valid", "var", "point", "f", "grad", "ref", " ov", "Val", "def", "l", "pos", "vt", "mem", "ctx", " oval", " old", "it", " ver", " vec", "aval", "loc", "ret", "len", "num", "p", " delta", "dev", "act", "v", " resp", "pol", "sel", "res", "stat", "ul", " num", "x", " err", "oval"], "mul": ["Mula", "mult", "Mulate", "imular", "smula", "emul", "Muls", "mmol", "smule", "tmull", "mule", "mcul", "cmular", "smul", "vau", "emlu", "smular", "vul", " mulate", "imUL", "mall", "Mule", "imau", "smull", " mula", "lemulate", "smult", "mmcul", "mmall", "Mall", "umul", " mular", "mmau", "mmula", " muls", " mau", "Mular", "cmUL", "cmule", "MUL", "vil", "lemUL", "mmular", "umil", " mall", "imul", "mula", "mil", "smUL", "Mau", "tmul", "mau", "mmUL", "smlu", "cmul", "umular", "tmult", "mUL", "emular", "tmol", "mlu", "muls", "lemuls", " mil", "umcul", "mol", "emula", "lemul", "mull", " mcul", "mmult", "vular", "Mul", "mmull", " mUL", " mlu", "mular", "smol", "mmul", "mulate", "mmil"], "integral": ["Integration", " Integral", "intrix", "Integrum", "integraction", " Integrix", "integrum", "Integral", " integraction", " Integra", "frum", "integrix", "intra", "intraction", "integration", "contraction", "contra", "intral", "contral", "Integraction", " integration", "contrix", "fration", "fral", " integrum", "integra", " Integraction"], "fraction": ["infraction", "infterm", "tractions", "Fract", "extant", "vration", "fract", " fration", "vertility", " fterm", "fractions", "traction", "infral", "fitness", "tterm", "vraction", " fertility", " fract", "affitness", "Fractions", "tant", " fral", "infract", "extractions", "fterm", "fertility", "affertility", "affraction", "fant", " fitness", "Fraction", "affration", "tral", "fration", "vitness", "fral", "extraction", "Fant", "extract", "tract"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int check_refcounts_l1(BlockDriverState *bs,\n\n                              BdrvCheckResult *res,\n\n                              uint16_t **refcount_table,\n\n                              int64_t *refcount_table_size,\n\n                              int64_t l1_table_offset, int l1_size,\n\n                              int flags)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL, l2_offset, l1_size2;\n\n    int i, ret;\n\n\n\n    l1_size2 = l1_size * sizeof(uint64_t);\n\n\n\n    /* Mark L1 table as used */\n\n    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                        l1_table_offset, l1_size2);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 8707, "substitutes": {"bs": ["ms", "obs", "vs", "locks", "cks", "aos", "rs", "css", "hs", "gs", "bl", "bes", "sts", "bles", "ps", "rys", "bc", "BS", "cs", "boxes", "bm", "bits", "outs", "fps", "aus", "js", "its", "ts", "bos", "lbs", "irs", "bps", "ubs", "ubis", "os", "sb", "b", "bis", "bh", "ns", "bi", "fs", "blog", "ls", "hz", "ds", "sys"], "res": ["ms", "cons", "pas", "reset", "ch", "resolution", "rs", "req", "summary", "css", "resp", "Rs", "rek", "Res", "ps", "rys", "gr", "scope", "rev", "bits", "ins", "usr", "us", "expr", "pres", "r", "RES", "rel", "details", "js", "cond", "inv", "its", "aux", "rem", "reg", "rc", "wcs", "os", "ress", "der", "red", "ro", "des", "re", "rest", "sys", "ber", "results", "ns", "vals", "rss", "resh", "result", "comm", " Res", "rez", "response", "resources", "vol", "out"], "refcount_table": ["refstart_tab", "refstat_tab", "refvalpletab", "refcountationmap", "refcountplebinary", "refcount_master", "refstatingtab", "refcallttab", "refval_binary", "refcallttable", "refcall_table", "refcount_tab", "refcountationtable", "refvalplebinary", "refstatingtable", "refcountingtable", "refcountationtab", "refcountpleTABLE", "refval_table", "refstart_table", "refstat_master", "refstart_TABLE", "refcalltdb", "refvalpleTABLE", "refstatingmaster", "refstatingmap", "refstart_term", "refcountingmaster", "refcount_binary", "refval_TABLE", "refcountationmaster", "refcounttdb", "refstat_table", "refcountpletab", "refcountttab", "refval_tab", "refstartpletab", "refstartpleTABLE", "refcount_TABLE", "refstat_map", "refstartpleterm", "refcountingtab", "refvalpletable", "refcount_term", "refcountpleterm", "refcount_db", "refcountingmap", "refcount_map", "refcountpletable", "refcall_tab", "refstartpletable", "refcountttable", "refcall_db"], "refcount_table_size": ["refcount_table_length", "refcount_tab_SIZE", "refcount_TABLE_length", " ref_", "refcount_tab_scale", "refcount_tab_size", "refcount_TABLE_SIZE", "refcount_table_Size", "refcount_table_SIZE", "refcount_TABLE_size", "ref_", "rel_", "refcount_table_scale", "refcount_TABLE_Size", "col_", "refcount_TABLE_scale"], "l1_table_offset": ["l1_Table_position", "l1_Table_off", "l1_table_off", "l1_TABLE_Offset", "l1_TABLE_off", "l1_TABLE_index", "l1_table_position", "l1_Table_Offset", "l1_Table_offset", "l1_table_Offset", "l1_table_index", "l1_TABLE_offset"], "l1_size": ["l1dno", "l11_member", "l1_time", "l1_score", "l11toffset", "lOne_ize", "l1_offset", "l11tsize", "l11tmember", "l1_Size", "l1tmember", "l2_s", "l11_speed", "l1toffset", "lOne_size", "lOne_no", "l2_time", "l2_Size", "l11tspeed", "l1ptoffset", "l1ptsize", "l11_size", "l1_ize", "l11_offset", "l1_speed", "l1dize", "l1_length", "l1_s", "l1tsize", "l1dsize", "l1_member", "l2_length", "l1ptSize", "l1ptlength", "l1tspeed", "lOne_score", "l2_size", "l1dscore", "l1_no"], "flags": [" Flags", "Flags", "status", " unused", "flag", "func", "cf", "files", "FLAG", "bits", "args", " af", "kind", "mask", " flag", "cond", "lag", " fmt", "Flag", "ags", "fields", " options", "fs", "options", "vals", "faces", "ents", " f"], "s": ["sq", "vs", "ashes", "ats", "rs", "hs", "sp", "gs", "p", "sts", "ps", "cs", "bits", "ins", "sv", "es", "aws", "r", "is", "js", "less", "S", "ss", "ts", "its", "os", "sb", "b", "c", "h", "ns", "stats", "fs", "ls", "states", "ims", "ds", "sys"], "l1_table": ["l3tTABLE", "l3tbuffer", "l1__buffer", "l1Ttable", "l1acbuffer", "l1tbatch", "l87_buffer", "l3ttable", "l3_batch", "l1actable", "l3_buffer", "l87_table", "l3_size", "l2_container", "l3_TABLE", "l1acTABLE", "l1_tab", "l1_session", "l1_available", "l1_batch", "l87_size", "l2_table", "l1tTABLE", "l1_buffer", "l0_buffer", "l87_available", "l1TTABLE", "l0_TABLE", "l1tsize", "l1tbuffer", "l3_session", "l1_container", "l1__table", "l1_TABLE", "l2_Table", "l1_Table", "l2_TABLE", "l1Tcontainer", "l1TTable", "l3tbatch", "l1__tab", "l3_table", "l1__TABLE", "l0_tab", "l1ttable", "l0_table", "l1acsession"], "l2_offset": ["l1_error", "l2_Offset", "l1_off", "l2_bit", "l2_address", "l1_position", "l1_offset", "l1_bit", "l7_offset", "l2ptOffset", "l2__Offset", "l21_entry", "l6__error", "l2__error", "l21ptaddress", "l6_index", "l2ptoffset", "l2_window", "l6_offset", "l6__offset", "l2ptshift", "l1_lock", "l2__off", "l2__shift", "l2ptwindow", "l2_off", "l7_error", "l7__offset", "l1_window", "l21ptentry", "l1_pos", "l2__offset", "l21ptoffset", "l2ptaddress", "l2ptindex", "l2ptlock", "l7__Offset", "l6__index", "l21ptwindow", "l2_index", "l6_shift", "l2_error", "l2_position", "l2_shift", "l7__off", "l7_off", "l21_offset", "l2__index", "l2_pos", "l2pterror", "l6_error", "l2_entry", "l6__shift", "l21_window", "l2ptentry", "l2_lock", "l2ptbit", "l7_Offset", "l1_Offset", "l21_address", "l7__error"], "l1_size2": ["l1_storage3", "l1_SIZE1", "l1_ize2", "l1_size25", "l1_ize3", "l1_storage1", "l1_Size5", "l1_body2", "l1_cache2", "l1_nametwo", "l1_Size2", "l1_size02", "l1_size5", "l1_Size1", "l1_shape5", "l1_name02", "l1_name1", "l1_shape3", "l1_name3", "l1_storage25", "l1_cachetwo", "l1_shape2", "l1_SIZE3", "l1_SIZE2", "l1_sizetwo", "l1_body1", "l1_storage2", "l1_Size3", "l1_cache1", "l1_ize5", "l1_body5", "l1_Size02", "l1_SIZE5", "l1_Size25", "l1_shape1", "l1_cache02", "l1_name2", "l1_Sizetwo", "l1_size1", "l1_size3"], "i": [" m", "ami", "id", "ai", "status", "fi", "I", "me", "li", "ei", "uri", "init", " I", "iq", "ri", "point", "sim", "ind", "ui", "iter", "this", "ip", "m", "l", " pi", "ki", "ti", "ic", " si", "cli", " ti", "mi", "index", "in", "chain", "j", "im", "ix", "us", "y", "iu", "ci", "\u0438", "zi", "info", " mi", "xi", "gu", "multi", "qi", "gi", "bi", "di", "ij", "pi", "si", "it", "x", "batch", "ini", " ii", " bi", "oi", " ni", "ji", "ims", " j", "dr", "ii"], "ret": ["reset", "format", "print", " Ret", "arm", "t", "rem", "deg", "cmd", "elt", "opt", "vet", "rm", "result", "ll", "dt", "fin", "tr", "status", "at", "RET", "RT", "rev", "jp", "after", "txt", "usr", "ter", "try", "magic", "ben", "sat", "rets", "Ret", "rt", "att", "get", "tf", "RE", "net", "back", "mat", "err", "resp", "hash", "nt", "ref", "def", "mem", "reg", "backed", "tmp", "red", "cert", "ft", "out", "mt", "len", "success", " RET", "flag", "det", "fun", "git", "alt", "ext", "j", "gc", "val", "re", "ber", "gt", "response"], "check_errors": ["check_error", " check_rors", " check_error", "check_notes", " check_notes", "check_rors"], "corruptions": ["corruptedures", "corrotitions", "corruptors", "corruptures", "orruptedures", "orrupteditions", "corrotors", "corruptedors", "orruptedions", "orruptors", "corrupteditions", "corconnectitions", "corconnections", "corruptedions", "corconnectures", "orruptions", "orruptitions", "corrotures", "corrotions", "corruptitions", "orruptures", "orruptedors", "corconnectors"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8720, "substitutes": {"opaque": [" ophole", "obaques", "ankque", "oplaque", "spaque", "opaques", "opque", "oplhole", "opsole", " opaques", "ogubis", "opubis", "ankubis", "ogaque", "ankaques", " opsole", "obaque", "ogaques", "ophole", "oplaques", "ankaque", "sphole", "obubis", "spsole", "obque", "ogque", "oplsole", "spaques"], "dcrn": ["dCrb", " dctrn", "dncrn", "dcrmn", " dctrr", "dgrdn", "dnkrn", "docrr", "dctrm", "dnCrr", "dCrr", " dcrdn", "dgrn", "dcrdn", "dctrb", " dcrb", " dcrr", "dgrm", "dkrr", "dCrl", "dncrmn", "dnkrr", " dctrb", "dprb", "dctrl", " dctrdn", "dnkrdn", "dnCrl", "dctrn", "dkrm", "dcrm", "dctrdn", "dprdn", "dnCrmn", "dprr", "dncrm", "dncrl", "dCrdn", "dncrr", "dctrmn", "docrn", "dncrdn", "dCrn", "dprn", "dCrmn", "dcrr", "dgrr", "docrl", "dcrb", "dkrn", "dctrr", "dkrdn", "dnCrn", "dnkrm", "docrmn", "dcrl"], "pob": ["paobs", "pingorp", "hoby", "hobb", "poby", "paob", "paome", "phpobb", "Pobb", "hob", " pome", "Pob", "pingob", "phpob", "post", " pobs", " pobe", "Pub", " pub", "polorp", "paobe", " poby", "pub", "phob", "phpost", "phome", " porp", "propobb", "porp", "propoby", "phpub", "polob", "pobe", "pingobs", " pog", "probe", "propob", "polrobe", "Post", " pobb", "phobe", "polobs", " probe", "pog", "pingrobe", " post", "pobb", "pome", "propog", "hog", "phobs", "pobs"], "ret": ["ert", "arr", "tr", "pas", " RET", "reset", "oret", "at", "back", "flag", "uf", "print", "det", "nz", "RET", "nt", "iter", "cat", "jp", "ref", " Ret", "mt", "def", "pret", " alt", "txt", "alt", "ext", "cont", "liber", "last", "__", "aux", "t", "rem", "rets", "val", "Ret", "xt", "out", "cmd", "rt", "re", "des", "sys", "res", "pert", "rest", "rm", "quad", "result", "att", "get", "gt", "it", "ll", " fut", "ft", "arg"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_erase(OneNANDState *s, int sec, int num)\n\n{\n\n    uint8_t *blankbuf, *tmpbuf;\n\n    blankbuf = g_malloc(512);\n\n    if (!blankbuf) {\n\n        return 1;\n\n    }\n\n    tmpbuf = g_malloc(512);\n\n    if (!tmpbuf) {\n\n        g_free(blankbuf);\n\n        return 1;\n\n    }\n\n    memset(blankbuf, 0xff, 512);\n\n    for (; num > 0; num--, sec++) {\n\n        if (s->bdrv_cur) {\n\n            int erasesec = s->secs_cur + (sec >> 5);\n\n            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n\n            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            if (sec + 1 > s->secs_cur) {\n\n                goto fail;\n\n            }\n\n            memcpy(s->current + (sec << 9), blankbuf, 512);\n\n            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n\n                   blankbuf, 1 << 4);\n\n        }\n\n    }\n\n\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 1;\n\n}\n", "idx": 8755, "substitutes": {"s": ["ms", "sq", "vs", "spec", "status", "qs", "rs", "http", "hs", "p", "gs", "sts", "sm", "ex", "ps", "south", "sim", "g", "ysis", "ins", "sv", "es", "ses", "sam", "bs", "aws", "r", "less", "js", "is", "S", "ss", "ts", "se", "n", "y", "als", "t", "sports", "ssl", "its", "details", "v", "conf", "ops", "os", "sb", "b", "has", "c", "bis", "sw", "h", "ns", "stats", "fs", "comm", "ls", "states", "ims", "ds", "sys"], "sec": ["src", "sq", "isec", "next", "inc", "sync", "con", "day", "priv", "secondary", "secure", "ct", "enc", "proc", "rec", "ec", "sub", "sent", "seq", "ex", "nt", "sector", "bc", "th", "second", "cur", "year", "ses", "desc", "pri", "us", "scroll", "ser", "security", "sect", "sup", "isc", "cond", "row", "se", "j", "esc", "scan", "ss", "reg", "conf", "deg", "https", "sen", "c", "exec", "sel", "SEC", "Sec", "sic", "stat", "sc", "seconds", "time", "max", "sd", "loc", "syn", "size", "sys"], "num": ["sym", "run", "cum", "con", "nm", "al", "sum", "add", "mult", "iq", "nu", "proc", "nam", " nm", "Num", "span", "th", "m", "np", "quant", "um", "en", "us", "cal", "n", "final", "__", "uni", "rem", " nu", "multi", "mon", "un", "tim", "nom", "NUM", "mun", "ul", "x", "nb", "comm", "msg", "ju", "umi", "no", "ums", "number"], "blankbuf": ["boltbuff", "blindcap", " blankbuff", "blackfb", "ankmu", "blackdb", "birduf", "boltvec", "blankbytes", "blinduf", "blcap", "boltdb", "blackcap", "ankbuf", "ankdb", "blinddb", "birdprop", " blankbuffer", " blankbytes", "blankdb", "newbuff", "ankcap", "nullbox", "blackbuffer", "birdbuff", "nullbuff", "blankbuffer", "blankbox", "boldbuffer", "rainbuf", "blackcmd", "blankmu", "raindb", "ankfb", " blankuf", "bldb", "blackuf", "newbox", "blackbox", "ankvec", "blackmu", "ankbox", "blankfb", "boltbox", "blackbuff", "ankcmd", "boldmu", "bridgebuf", "boldbuf", "boltcmd", "nullbuf", "rainfb", "blankcmd", " blankcmd", "ankfont", "blankvec", "blindbytes", "blankbuff", "blindbox", "blindbuf", "rainbuff", "bridgevec", "blackbuf", "blankcap", " blankprop", "blankuf", " blankcap", "blcmd", "ankuf", "bridgebox", "boltprop", "birdbuf", "blankprop", "blindbuff", "boltuf", "blindcmd", "ankbuff", "ankbytes", " blankdb", "boltbuf", "newcap", "bridgefont", "blbuf", "boltfont", "ankbuffer", "nullcap", "boldbuff", "newbuf", "blankfont"], "tmpbuf": ["blankbuffer", " tmpvec", "tmpcmd", "imgbuf", "tempbuff", "tempbr", "tgbuff", "tmpcb", "mpcv", " tmpdata", "mpbuff", "blankcb", "imguf", "txtuf", "mpvec", "tempvec", "tempcv", "blankdata", "imgcmd", "tgdata", "imgbuffer", "tmpbuffer", "tabuf", " tmpbuff", " tmpbuffer", "tmpvec", "txtbuffer", "tabcv", "tmpcv", "txtbuff", "mpbuf", "tempbuf", "imgdata", "tempcb", "tmpbuff", "tabbuff", " tmpcmd", "tempuf", "mpbuffer", " tmpuf", "tgbuf", "txtbuf", "blankbuff", "tgcb", "mpcmd", " tmpbr", "tmpbr", "tabbuf", "tempdata", "mpuf", "mpbr", "tmpuf", "imgbuff", "tmpdata", "tempbuffer", "blankuf"]}}
{"project": "qemu", "commit_id": "ff74f33c310892c90c4439d963a6ce67f47ce18c", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n                              const char *desc_file_path, Error **errp)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                error_setg(errp, \"Invalid extent lines: \\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(type, \"VMFS\")) {\n\n            if (ret == 4) {\n\n                flat_offset = 0;\n\n            } else {\n\n                error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        extent_file = NULL;\n\n        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,\n\n                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);\n\n            }\n\n            if (ret) {\n\n                g_free(buf);\n\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 8793, "substitutes": {"desc": ["doc", "obj", "pat", "path", "Desc", "req", "err", "enc", "rec", "sub", "resp", "seq", "dc", "cur", "phrase", "ref", "cd", "raw", "txt", "ext", "cont", "esc", "rc", "lc", "sort", "comment", "cmd", "des", "asc", "dist", "res", "sc", "disc", "description"], "bs": ["obs", "vs", "bf", "bp", "rs", "hs", "gs", "bl", "bes", "ps", "bc", "BS", "cs", "bm", "bits", "cb", "js", "ss", "ts", "bos", "pb", "its", "ubs", "os", "sb", "b", "bis", "bh", "acs", "ns", "fs", "ls", "ds", "sys"], "desc_file_path": ["desc_File_name", "desc_File_path", "desc_file_length", "desc_file__name", "desc_File_Path", "desc_file__length", "desc_file__path", "desc_file_pointer", "desc_file_Path", "desc_file__pointer", "desc_File_length", "desc_file_name", "desc_File_pointer"], "errp": ["erup", "testr", "Erpc", "errr", "invp", "errpat", "ererp", "testp", "nerup", "nerpa", "strp", "errorm", "err", "erpa", "invg", "ermr", " errpc", " errpa", "diepa", "ermpa", "nerpb", "erphp", "errorpc", "strr", "errpb", "errpost", "errg", "invpat", "Erm", "errm", "errorP", "riskpat", "ErP", "errpc", "riskp", "erp", "errup", "ererpat", "ermp", " errpb", "ermphp", "dieP", "errorp", "testphp", "strup", " errm", "testpa", "nerp", "errping", " errP", "riskg", "diep", "ererpost", "errpa", "nerping", "Erp", "errP", "errphp", "diepb", "invpost", "erping", "ererg", "nerr", "nerP", "strping", "riskpost"], "ret": ["reset", "print", "gov", " Ret", "r", "t", "rem", "deg", "cmd", "elt", "result", "locked", "ll", "dt", "tr", "run", "status", "code", "bool", "RET", "iter", "prot", "rev", "after", "usr", "txt", "ter", "try", "ben", "final", "sat", "rets", "Ret", "rt", "att", "get", "tf", "net", "back", "err", "resp", "hash", "nt", "ref", "inter", "def", " alt", "backed", "red", "it", "ft", "out", "mt", "len", "lit", "success", "lt", " RET", "flag", "det", "fun", "cb", "alt", "cont", "j", "tn", "v", "rot", "gc", "val", "re", "res", "x", "gt"], "access": ["acc", "array", "id", "use", "status", "url", "Access", "config", "path", "read", "code", "priv", "a", "rs", "req", "accessible", "pass", "range", "area", "seq", "ex", "error", "act", "open", "ref", "attr", "arch", "request", "pri", "ext", "index", "row", "accept", "data", "test", "esc", "view", "mode", "ac", "sha", "scan", "aw", "acl", "ha", "exclusive", "ace", "ast", "cast", "exec", "str", "asc", "est", "alias", "stat", "sc", "ax", "att", "usage", "escape", "max", "length"], "type": ["key", "op", "id", "typ", "lib", "address", "pe", "use", "ty", "code", "buffer", "tp", "ping", "types", "role", "ime", "file", "area", "field", "error", "size", "TYPE", "ref", "te", "null", "port", "kind", "ver", "all", "index", "Type", "test", "version", "view", "t", "sort", "info", "ype", "class", "change", "shape", "action", "e", "otype", "ped", "title", "tag", "color", "table", "link", "time", "rage", "description", "name", "space", "length", "style", "sys"], "fname": ["bfno", "vName", "bfname", " fnames", "fName", "fno", "Fnames", "vnames", " fName", " fpath", "Fno", "fpath", "fnames", "vpath", "Fpath", " fno", "bfnames", "Fname", "vname", "bfName", "FName"], "p": ["op", "resp", "pc", "pat", "tp", "a", "pp", "pt", "q", "bp", "ping", "proc", "sp", "o", "point", "f", "rep", "ps", "cp", "fp", "pg", "d", "post", "ip", "g", "jp", "m", "np", "ap", "l", "pkg", "vp", "i", "progress", "port", "lp", "r", "pm", "j", "n", "pb", "perm", "t", "P", "ctx", "v", "pr", "e", "b", "c", "wp", "h", "pre", "pid", "pa"], "flat_offset": ["flat64Offset", " flat_set", " flat_field", "flatxpointer", " flat_offs", " flatxOffset", "flat_slice", "full_Offset", "flat_set", " flat_index", "flatlyoffset", "flatlyOffset", " flat_pointer", "flattOffset", " flatxset", "flattslice", "flatxoffset", " flatxoffset", "flatxOffset", "flat_Offset", "flat64offset", " flatxpointer", "full_offset", "flat_field", "flat_off", "flat_origin", "flat64off", "flat_pointer", "alt_pad", "flatlyindex", " flat_Offset", " flat_off", "full_origin", "flattoffset", "flat64offs", "flat_pad", "flat_index", "flattorigin", "alt_Offset", "alt_shift", "flat_shift", "flat_offs", "flatxset", "full_slice", "alt_offset", "flatlyfield"], "extent_path": ["extent2file", "extents_path", "extent_name", "extentxname", "extend_info", "extent_info", "extend_Path", "extent_dir", "extent2path", "extentxpath", "extend_file", "extentxPath", "extent_entry", "extentxentry", "extent___info", "extent___file", "extent_Path", "extents_name", "extent2info", "extents_dir", "extend_entry", "extend_path", "extents_Path", "extend_name", "extent___path"], "extent_file": ["extent_File", "extent2files", "extent_line", "extents_path", "extend_data", "extend_line", "extent_dir", "extent2path", "extents_files", "extend_file", "extent_files", "extend_files", "extents_File", "extent_data", "extents_file", "extent2dir", "extents_dir", "extent2file"], "s": ["ms", "sym", "vs", "sum", "ats", "rs", "stream", "gs", "sp", "f", "ps", "ess", "cs", "sv", "i", "es", "xs", "us", "is", "js", "j", "S", "ss", "ts", "ries", "n", "ix", "t", "v", "os", "sb", "b", "e", "h", "times", "ns", "stats", "str", "fs", "set", "ls", "name", "ds", "sd", "sys"], "extent": ["Extend", "extnt", "contents", "content", "Extnt", "xtent", "Extents", "contnt", "xtend", "extents", "extend", "xtnt", "xtents", "contend", "Extent"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "static int default_lockmgr_cb(void **arg, enum AVLockOp op)\n\n{\n\n    void * volatile * mutex = arg;\n\n    int err;\n\n\n\n    switch (op) {\n\n    case AV_LOCK_CREATE:\n\n        return 0;\n\n    case AV_LOCK_OBTAIN:\n\n        if (!*mutex) {\n\n            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            if ((err = pthread_mutex_init(tmp, NULL))) {\n\n                av_free(tmp);\n\n                return AVERROR(err);\n\n            }\n\n            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {\n\n                pthread_mutex_destroy(tmp);\n\n                av_free(tmp);\n\n            }\n\n        }\n\n\n\n        if ((err = pthread_mutex_lock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_RELEASE:\n\n        if ((err = pthread_mutex_unlock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_DESTROY:\n\n        if (*mutex)\n\n            pthread_mutex_destroy(*mutex);\n\n        av_free(*mutex);\n\n        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 8794, "substitutes": {"arg": ["arr", "doc", "obj", "inc", "mb", "call", "arp", "par", "ack", "alloc", "p", "argument", "pg", "act", "g", "ref", "attr", "args", "ig", "in", "mem", "ma", "Arg", "emb", "reg", "v", "aw", "val", "ag", "mac", "param", "ax", "bar", "pack", "exc", "loc", "ar", "ret"], "op": ["obj", "xp", "spec", "typ", "what", "cmp", "xy", "par", "up", "update", "ack", "k", "proc", "sp", "ok", "hop", "operation", "push", "ip", "pop", "type", "jp", "rol", "oper", "ep", "bit", "Op", "cod", "top", "wo", "perm", "opp", "ops", "OP", "cmd", "rop", "oe", "operator", "opt", "ob", "it", "mop"], "mutex": ["mitax", " mutect", "mitex", "mobsex", "metress", "mandex", "mutry", " mutry", "muthex", "matact", "mutEX", " mutEX", "metEx", " mutress", " muthex", "muttx", "mandext", "Mutry", "cmdex", "mitgex", "mtexclusive", "metax", " mutx", "mutax", "pirress", "petsex", "MutEx", "munect", "matect", " muttx", "munx", "mutgex", "Mutect", "mandax", "mtEX", " mutext", "mandhex", "mitry", "mutsex", " mutEx", "mutix", "mttex", " mutax", "munEx", "matex", " mutix", "Mutgex", "mutect", "mtact", "munexclusive", "matw", "Mutex", "mutux", "metx", "pirix", "mandix", "mithex", "mattx", "mutx", "muntx", "Mutw", "metexclusive", "mutexclusive", "mutress", "cmdtex", "muntex", "petex", "mobex", "munw", "mtx", " mutgex", "mutact", "cmdx", " mutact", "munact", "mandact", "Mutax", " mutexclusive", "mutext", "mtext", "mutEx", "matx", "pirx", "munex", " mutsex", "Mutact", "petux", "Mutexclusive", "metix", "mandEX", "petEx", "muttex", "mobux", "mutw", " mutux", "pirex", "mitEx", "cmdexclusive", "mtex", "mobEx", "metex", "matEx", "mitix"], "err": ["arr", "kr", "inner", "obj", "warn", "norm", "notice", "extra", "Error", "errors", "order", "rb", "or", "init", "cor", "req", "here", "ev", "resp", "ach", "buf", "dev", "error", "hz", "iter", "aaa", "rev", "cer", "attr", "rn", "gz", "my", "eor", "raw", "rr", "later", "usr", "ger", "Er", "try", "r", "br", "test", "yr", "nr", "conf", "cfg", "fr", "pr", "good", "die", "cmd", "str", "elt", "ns", "oe", "fee", "er", "res", "mr", "peer", "coord", "msg", "ner", "cr", "exc", "timer", "rar", "state", "dr", "sys"], "tmp": ["tm", "src", "arr", "tt", "obj", "tty", "xy", "empty", "priv", "cmp", "mb", "tp", "mm", "gm", "stuff", "init", "alloc", "proc", "p", "sp", "buf", "var", "cp", "nt", "aaa", "mint", "pkg", "np", "m", "cur", "attr", "null", "ptr", "sam", "tab", "vt", "txt", "appy", "snap", "vm", "data", "test", "perm", "t", "ctx", "v", "mk", "comp", "copy", "orig", "rt", "temp", "etc", "mut", "nb", "tar", "buff", "imm", "msg", "app", "mp", "emp", "img", "template"]}}
{"project": "FFmpeg", "commit_id": "aacc6615f8e3863cd930d3a1ab2cd28d9838f0f5", "target": 1, "func": "static inline int check_input_motion(MpegEncContext * s, int mb_x, int mb_y, int p_type){\n\n    MotionEstContext * const c= &s->me;\n\n    Picture *p= s->current_picture_ptr;\n\n    int mb_xy= mb_x + mb_y*s->mb_stride;\n\n    int xy= 2*mb_x + 2*mb_y*s->b8_stride;\n\n    int mb_type= s->current_picture.mb_type[mb_xy];\n\n    int flags= c->flags;\n\n    int shift= (flags&FLAG_QPEL) + 1;\n\n    int mask= (1<<shift)-1;\n\n    int x, y, i;\n\n    int d=0;\n\n    me_cmp_func cmpf= s->dsp.sse[0];\n\n    me_cmp_func chroma_cmpf= s->dsp.sse[1];\n\n    \n\n    assert(p_type==0 || !USES_LIST(mb_type, 1));\n\n    assert(IS_INTRA(mb_type) || USES_LIST(mb_type,0) || USES_LIST(mb_type,1));\n\n    \n\n    if(IS_INTERLACED(mb_type)){\n\n        int xy2= xy  + s->b8_stride;\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n        c->stride<<=1;\n\n        c->uvstride<<=1;\n\n        init_interlaced_ref(s, 2);\n\n        \n\n        assert(s->flags & CODEC_FLAG_INTERLACED_ME);\n\n\n\n        if(USES_LIST(mb_type, 0)){\n\n            int field_select0= p->ref_index[0][xy ];\n\n            int field_select1= p->ref_index[0][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            if(p_type){\n\n                s->p_field_select_table[0][mb_xy]= field_select0;\n\n                s->p_field_select_table[1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->p_field_mv_table[0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->p_field_mv_table[1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER_I;\n\n            }else{\n\n                s->b_field_select_table[0][0][mb_xy]= field_select0;\n\n                s->b_field_select_table[0][1][mb_xy]= field_select1;\n\n                *(uint32_t*)s->b_field_mv_table[0][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[0][xy ];\n\n                *(uint32_t*)s->b_field_mv_table[0][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[0][xy2];\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_FORWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[0][xy ][0]; \n\n            y= p->motion_val[0][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[0][xy2][0]; \n\n            y= p->motion_val[0][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1, 1, cmpf, chroma_cmpf, flags);\n\n        }\n\n        if(USES_LIST(mb_type, 1)){\n\n            int field_select0= p->ref_index[1][xy ];\n\n            int field_select1= p->ref_index[1][xy2];\n\n            assert(field_select0==0 ||field_select0==1);\n\n            assert(field_select1==0 ||field_select1==1);\n\n            s->b_field_select_table[1][0][mb_xy]= field_select0;\n\n            s->b_field_select_table[1][1][mb_xy]= field_select1;\n\n            *(uint32_t*)s->b_field_mv_table[1][0][field_select0][mb_xy]= *(uint32_t*)p->motion_val[1][xy ];\n\n            *(uint32_t*)s->b_field_mv_table[1][1][field_select1][mb_xy]= *(uint32_t*)p->motion_val[1][xy2];\n\n            if(USES_LIST(mb_type, 0)){\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BIDIR_I;\n\n            }else{\n\n                s->mb_type[mb_xy]= CANDIDATE_MB_TYPE_BACKWARD_I;\n\n            }\n\n\n\n            x= p->motion_val[1][xy ][0]; \n\n            y= p->motion_val[1][xy ][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select0+2, 0, cmpf, chroma_cmpf, flags);\n\n            x= p->motion_val[1][xy2][0]; \n\n            y= p->motion_val[1][xy2][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, field_select1+2, 1, cmpf, chroma_cmpf, flags);\n\n            //FIXME bidir scores\n\n        }\n\n        c->stride>>=1;\n\n        c->uvstride>>=1;\n\n    }else if(IS_8X8(mb_type)){\n\n\n        cmpf= s->dsp.sse[1];\n\n        chroma_cmpf= s->dsp.sse[1];\n\n        init_mv4_ref(s);\n\n        for(i=0; i<4; i++){\n\n            xy= s->block_index[i];\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 1, 8, i, i, cmpf, chroma_cmpf, flags);\n\n        }\n\n        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER4V;\n\n    }else{\n\n        if(USES_LIST(mb_type, 0)){\n\n            if(p_type){\n\n                *(uint32_t*)s->p_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER;\n\n            }else if(USES_LIST(mb_type, 1)){\n\n                *(uint32_t*)s->b_bidir_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                *(uint32_t*)s->b_bidir_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BIDIR;\n\n            }else{\n\n                *(uint32_t*)s->b_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_FORWARD;\n\n            }\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chroma_cmpf, flags);\n\n        }else if(USES_LIST(mb_type, 1)){\n\n            *(uint32_t*)s->b_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BACKWARD;\n\n           \n\n            x= p->motion_val[1][xy][0]; \n\n            y= p->motion_val[1][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chroma_cmpf, flags);\n\n        }else\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n    }\n\n    return d;\n\n}", "idx": 8815, "substitutes": {"s": ["ms", "vs", "ats", "sg", "hs", "cs", "m", "ins", "storage", "details", "http", "se", "os", "b", "w", "comm", "ims", "conv", "ports", "source", "settings", "asm", "gs", "sts", "ex", "changes", "g", "sv", "ses", "bs", "services", "less", "js", "als", "ss", "conf", "ops", "sb", "sc", "ls", "app", "params", "sq", "spec", "qs", "a", "rs", "css", "as", "ants", "es", "ts", "ctx", "sw", "ns", "space", "ds", "comments", "ps", "service", "aws", "is", "S", "its", "self", "https", "bis", "h", "acs", "stats", "fs", "csv", "set", "sys", "parts"], "mb_x": ["mb08wx", "mb00y", "mb08x", " MB_ex", " MB_wx", "mbjy", "emb_y", " MB08x", "emb_wx", "mb08ex", "mbjwx", "mb_ex", "mb00x", " MB_image", "mbjyx", "mb_yx", "mb_xx", " MB08image", "mbaxyex", "emb_x", "mbaxyx", " MB08ex", "emb_xx", "emb_image", "mb_wx", "mbaxyimage", " MB08wx", " MB_x", "mb00image", "mbaxywx", "mb08image", "emb_yx", "mbjx", "mb_image", "mb00xx"], "mb_y": ["ram_gy", "mb68Y", "ram_Y", "ebin_ym", "ob_Y", "mb_ym", "mb08y", "ram68gy", "ebin_yd", "mb_Y", "ob_y", "ebin_ye", "ram_ey", "mb__y", "mb2ey", "ebin_y", "mb_yd", "mb_ye", "ram_y", "mb__Y", "mb2gy", "ram68Y", "mb08ye", "mb08yd", "ob_xy", "mb__xy", "mb68gy", "mb_ey", "mb68y", "mb68ey", "ram68y", "mb__x", "ob_x", "ram68ey", "mb_xy", "mb2Y", "mb08ym", "mb2y", "mb_gy"], "p_type": ["P__types", "pb_ype", "m_name", "P__type", "p_ype", "pb_kind", "pairkind", "pbairkind", "P_Type", "p__ype", "pairype", "pairtypes", "pbairtype", "p__type", "p__types", "m_port", "p__Type", "p_Type", "p_name", "pairtype", "p_kind", "m_Type", "pbairype", "P__Type", "P__ype", "pbairtypes", "pb_type", "P_ype", "P_types", "p_port", "pb_types", "p_types", "P_type", "m_type"], "c": ["con", "pc", "abc", "config", "a", "cam", "ct", "ec", "o", "f", "cp", "cf", "bc", "dc", "d", "g", "m", "cs", "tc", "cc", "ce", "r", "cont", "coll", "mc", "t", "ctx", "ac", "rc", "lc", "conf", "v", "gc", "e", "cache", "b", "com", "h", "can", "cm", "w", "csv", "cu", "sc", "comm", "C", "co", "cv", "ca"], "p": ["op", "ph", "pic", "pc", "pe", "tp", "pp", "pt", "bp", "proc", "sp", "o", "f", "cp", "fp", "ps", "ip", "g", "jp", "m", "l", "pkg", "ap", "lp", "r", "pm", "j", "pb", "P", "t", "v", "pr", "e", "b", "wp", "h", "pi", "php", "app", "mp", "pro", "pa"], "x": ["on", "xy", "tx", "a", "o", "f", "ex", "ox", "dx", "m", "l", "X", "xs", "index", "r", "rx", "ix", "px", "v", "xi", "e", "w", "z", "ax"], "y": ["py", "xy", "vy", "yy", "yi", "o", "ay", "ry", "yn", "m", "oy", "ye", "dy", "ys", "j", "Y", "v", "ey", "b", "ym", "gy", "sy", "iy", "ny", "hy", "cy"], "i": ["id", "I", "a", "q", "k", "o", "f", "d", "g", "m", "l", "in", "mi", "index", "r", "j", "n", "t", "v", "e", "b", "bi", "w", "pi", "it", "ij"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "void ff_estimate_p_frame_motion(MpegEncContext * s,\n\n                                int mb_x, int mb_y)\n\n{\n\n    UINT8 *pix, *ppix;\n\n    int sum, varc, vard, mx, my, range, dmin, xx, yy;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    int mb_type=0;\n\n    uint8_t *ref_picture= s->last_picture[0];\n\n\n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[0];\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + 2         ][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + 2         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x = P[4][0];\n\n                pred_y = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x= P[1][0];\n\n                pred_y= P[1][1];\n\n            }\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    if(s->flags&CODEC_FLAG_4MV){\n\n        int block;\n\n\n\n        mb_type|= MB_TYPE_INTER4V;\n\n\n\n        for(block=0; block<4; block++){\n\n            int mx4, my4;\n\n            int pred_x4, pred_y4;\n\n            int dmin4;\n\n            static const int off[4]= {2, 1, 1, -1};\n\n            const int mot_stride = s->block_wrap[0];\n\n            const int mot_xy = s->block_index[block];\n\n            const int block_x= mb_x*2 + (block&1);\n\n            const int block_y= mb_y*2 + (block>>1);\n\n\n\n            const int rel_xmin4= xmin - block_x*8;\n\n            const int rel_xmax4= xmax - block_x*8 + 8;\n\n            const int rel_ymin4= ymin - block_y*8;\n\n            const int rel_ymax4= ymax - block_y*8 + 8;\n\n\n\n            P[0][0] = s->motion_val[mot_xy    ][0];\n\n            P[0][1] = s->motion_val[mot_xy    ][1];\n\n            P[1][0] = s->motion_val[mot_xy - 1][0];\n\n            P[1][1] = s->motion_val[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax4<<shift)) P[1][0]= (rel_xmax4<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line) && block<2) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = s->motion_val[mot_xy - mot_stride             ][0];\n\n                P[2][1] = s->motion_val[mot_xy - mot_stride             ][1];\n\n                P[3][0] = s->motion_val[mot_xy - mot_stride + off[block]][0];\n\n                P[3][1] = s->motion_val[mot_xy - mot_stride + off[block]][1];\n\n                if(P[2][1] > (rel_ymax4<<shift)) P[2][1]= (rel_ymax4<<shift);\n\n                if(P[3][0] < (rel_xmin4<<shift)) P[3][0]= (rel_xmin4<<shift);\n\n                if(P[3][0] > (rel_xmax4<<shift)) P[3][0]= (rel_xmax4<<shift);\n\n                if(P[3][1] > (rel_ymax4<<shift)) P[3][1]= (rel_ymax4<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            if(s->out_format == FMT_H263){\n\n                pred_x4 = P[4][0];\n\n                pred_y4 = P[4][1];\n\n            }else { /* mpeg1 at least */\n\n                pred_x4= P[1][0];\n\n                pred_y4= P[1][1];\n\n            }\n\n            P[5][0]= mx - mb_x*16;\n\n            P[5][1]= my - mb_y*16;\n\n\n\n            dmin4 = epzs_motion_search4(s, block, &mx4, &my4, P, pred_x4, pred_y4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, ref_picture);\n\n\n\n            halfpel_motion_search4(s, &mx4, &my4, dmin4, rel_xmin4, rel_ymin4, rel_xmax4, rel_ymax4, \n\n                                   pred_x4, pred_y4, block_x, block_y, ref_picture);\n\n     \n\n            s->motion_val[ s->block_index[block] ][0]= mx4;\n\n            s->motion_val[ s->block_index[block] ][1]= my4;\n\n        }\n\n    }\n\n\n\n    /* intra / predictive decision */\n\n    xx = mb_x * 16;\n\n    yy = mb_y * 16;\n\n\n\n    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    sum = pix_sum(pix, s->linesize);\n\n#if 0\n\n    varc = pix_dev(pix, s->linesize, (sum+128)>>8) + INTER_BIAS;\n\n    vard = pix_abs16x16(pix, ppix, s->linesize);\n\n#else\n\n    sum= (sum+8)>>4;\n\n    varc = ((pix_norm1(pix, s->linesize) - sum*sum + 128 + 500)>>8);\n\n    vard = (pix_norm(pix, ppix, s->linesize)+128)>>8;\n\n#endif\n\n\n\n    s->mb_var[s->mb_width * mb_y + mb_x] = varc;\n\n    s->avg_mb_var+= varc;\n\n    s->mc_mb_var += vard;\n\n\n\n    \n\n#if 0\n\n    printf(\"varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\\n\",\n\n\t   varc, s->avg_mb_var, sum, vard, mx - xx, my - yy);\n\n#endif\n\n    if(s->flags&CODEC_FLAG_HQ){\n\n        if (vard*2 + 200 > varc)\n\n            mb_type|= MB_TYPE_INTRA;\n\n        if (varc*2 + 200 > vard){\n\n            mb_type|= MB_TYPE_INTER;\n\n            halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n        }else{\n\n            mx = mx*2 - mb_x*32;\n\n            my = my*2 - mb_y*32;\n\n        }\n\n    }else{\n\n        if (vard <= 64 || vard < varc) {\n\n            mb_type|= MB_TYPE_INTER;\n\n            if (s->me_method != ME_ZERO) {\n\n                halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n            } else {\n\n                mx -= 16 * mb_x;\n\n                my -= 16 * mb_y;\n\n            }\n\n#if 0\n\n            if (vard < 10) {\n\n                skip++;\n\n                fprintf(stderr,\"\\nEarly skip: %d vard: %2d varc: %5d dmin: %d\", \n\n                                skip, vard, varc, dmin);\n\n            }\n\n#endif\n\n        }else{\n\n            mb_type|= MB_TYPE_INTRA;\n\n            mx = 0;//mx*2 - 32 * mb_x;\n\n            my = 0;//my*2 - 32 * mb_y;\n\n        }\n\n    }\n\n\n\n    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    set_p_mv_tables(s, mx, my);\n\n}\n", "idx": 8825, "substitutes": {"s": ["ms", "vs", "ats", "hs", "cs", "m", "bits", "ins", "details", "r", "http", "se", "t", "sports", "ties", "os", "b", "times", "w", "comm", "ims", "sym", "source", "settings", "gs", "sts", "changes", "g", "sv", "ses", "sam", "bs", "less", "js", "ss", "ops", "e", "sb", "z", "ls", "sq", "spec", "qs", "a", "rs", "as", "f", "sm", "l", "es", "i", "ts", "n", "sw", "ns", "er", "ds", "p", "an", "ps", "so", "us", "aws", "is", "j", "S", "its", "v", "c", "bis", "h", "stats", "fs", "set", "webkit", "sys"], "mb_x": ["mboxex", "mp_key", "mb___x", "mboxX", "mp_xy", "MB_X", "MB__ex", "mbFx", "mb_key", "MB_rx", "mp_y", "mb_ex", "mboxx", "mb___key", "mb_yx", "mb___y", "mb_X", "mbFxy", "mb___yx", "MB__X", "mb_rx", "mb_xi", "mp_x", "mboxrx", "mp_yx", "mb__rx", "MB_ex", "mp_xi", "mb__ex", "MB__rx", "mb__x", "MB_x", "mbFxi", "mb__X", "mb_xy", "MB__x"], "mb_y": ["mb3Y", "mm_Y", "mb3yo", "emb_y", "mm_x", "mp_y", "mb__my", "emb_my", "mb_Y", "mb_my", "emb_Y", "mb__y", "emb_x", "mb__Y", "mb_sy", "mp_Y", "mb3sy", "mm_ey", "mb_ey", "mp_yo", "mb__x", "mm_y", "mb3y", "mp_sy", "mb_yo"], "pix": ["pici", "pci", "piIX", "ppci", "pIX", "ppixels", "ppIX", "piix", "pixels", " pixels", "piixels", " pci", " pIX"], "ppix": ["spix", "spw", "mpw", "mpx", "mpix", "mpIX", "ppx", "dpIX", "ppIX", "spIX", "dpx", "dpw", "dpix", "spx", "ppw"], "sum": ["Sum", "doc", "num", "cum", "add", "star", "hash", "post", "sim", "volume", "ram", "score", "um", "sam", "cal", "mem", "sup", "sun", "total", "frac", "count", "fac", "scale", "si", "sc", "hum", "vol", "mean"], "varc": ["evarc", "vpip", "vparc", " varm", "vparm", "varm", "evarm", " vip", "evip", " vasc", "evasc", "vpasc", "vasc", "vip"], "vard": ["src", "num", "std", "vol", "av", "base", "uv", "sp", "var", "au", "act", "sex", "hd", "fps", "mix", "cal", "cod", "ss", "box", "cap", "aux", "vd", "zh", "dim", "comp", "scale", "vid", "sc", "cv", "tv"], "mx": ["ms", "ml", "windows", "MX", "xy", "mot", "tx", "mort", "mb", "axy", "me", "mm", "nox", "nz", "mie", "cp", "mic", "ox", "wx", "mas", "mr", "xs", "mn", "mph", "mi", "pm", "rx", "mc", "ctx", "px", "fax", "xes", "mk", "mouse", "yz", "yx", "xml", "mac", "phys", "ax", "x", "fx", "lex", "mp", "max", "vm", "ux", "mt"], "my": ["ms", "colm", "sym", "py", "thing", "ami", "xy", " My", "axy", "ty", "mm", "where", "cy", "ny", "your", "les", "wi", "mie", "mic", "their", "mis", "Mi", "mn", "mph", "mi", "mem", "try", "ys", "pm", "y", " MY", "mc", "mys", "dds", "MY", "mk", "multi", "mouse", "mmm", "ym", "gy", "ery", "ody", "memory", "maybe", "mp", "My", "vm", "mt"], "range": ["spread", "ranging", "ge", "multiple", "lim", "use", "call", "path", "ch", "resource", "base", "feature", "move", "route", "req", "span", "area", "frame", "domain", "ram", "size", "scope", "m", "ref", "type", "args", "progress", "Range", "length", "window", "rate", "edge", "filter", "term", "cal", "r", "chain", "bound", "race", "row", "view", "ANGE", "mode", "ange", "reg", "conf", "radius", "change", "remote", "transform", "rang", "release", "scale", "ro", "re", "res", "force", "slice", "diff", "batch", "get", "gb", "usage", "rage", "max", "history", "loc", "space", "angle", "arg"], "dmin": [" dinit", "Dni", "dxmn", "dxrain", "donedim", " dmid", " dMin", "rdmin", "dmn", "dMin", " dMIN", "DMin", "drainit", "didmin", "dradim", "Dmin", "donemin", " dmins", "dinit", "dMIN", "tdmin", "tdmid", "dxmin", "ddrain", "dmins", "draminute", "ddmins", "ddmn", "dni", "tdMin", " dmn", "rdinit", "drain", "ddim", " drain", "Dmid", " ddim", "domins", "didlower", "dminute", "dxmins", "dmid", "tdmins", "doMin", "dramin", "didMIN", "ddmin", "didinit", "domin", "rdlower", "Dmins", " dni", " dminute", "rdMIN", "doneinit", "doneminute", " dlower", "dlower", "doni"], "xx": ["phot", "xp", "dd", "zz", "xy", "sky", "mm", "cross", "ox", "dx", "wx", "XX", "nn", "xs", "xxx", "xxxx", "mix", "ss", "xi", "mk", "fy", "zx", "yz", "yx", "foo", "fx", "ux"], "yy": ["sym", "py", "yt", "YY", "xy", "axy", "vy", "yn", "oy", "xxx", "dy", "ys", "yd", "y", "yr", "Y", "ey", "yk", "ym", "gy", "uy", "fy", "iy", "yx", "yu", "yl", "dt"], "xmin": ["rxmin", "XMIN", "xbegin", " xadmin", "xamins", "lexmax", "xMin", "fxMIN", " xmins", "lexbegin", " xminute", "atmins", " xmid", "xxxxmax", " xbegin", "txstart", "lexmin", "ypre", "yMin", "rxmax", "xmon", "ixstart", "xMIN", "atmax", "lexmid", "txmin", "xamin", "txmon", "atmin", "xxxxmid", "ixmin", "xaadmin", "ixmax", "exmin", "fxmin", "txmax", "xamax", "xpre", "fxmax", " xpre", "rxadmin", "xminute", "exstart", "atminute", "ymins", "Xmax", "yminute", " xMIN", "Xmin", "exmon", "xmid", "xxxxbegin", "xapre", "xmins", "xstart", "exmax", "XMin", " xMin", "fxMin", "xaMin", "rxmins", "xxxxmin", "xadmin", "ixmon"], "ymin": ["systat", "axymain", "ypath", "nyax", "ymain", "symax", "erymind", "cymind", "oxmin", "oxax", "axylocal", "iymain", "uymin", "symin", "erymax", "yfirst", "ylocal", "Ymin", "iymin", "erymin", "ystore", "erymain", "iymax", " yname", "xmain", " ymain", "yax", "symins", "nystore", "oxmax", "xMIN", "lypath", "cymax", "cymin", "nymin", "ymind", " ymind", "uyfirst", "nymins", "ystat", "oxMIN", "uystore", "lyfirst", "uypath", "axymax", "ymins", "lystore", "Ymins", "erylocal", "nyMIN", "iyname", "nymax", "axymin", "nypath", " ylocal", "Ymax", "Ystat", "nyfirst", "lymin", "nystat", "yMIN", "xname", "yname", "xax"], "xmax": ["xlast", "xmlMAX", "pxmax", "eymax", "XMAX", "oxview", "oxstart", "yMax", "eyax", " xMax", "xmlmax", "xmlax", "xmlend", " xhost", "exax", "xMax", "yhost", "ixend", "xmlview", "yax", "ixstart", "oxmax", "Xax", "eyhost", "yMAX", " xax", "exmin", "fxmin", "ylast", "ixmax", "ixview", "fxmax", "oxend", "fxMAX", "xview", " xMAX", "Xmax", "xhost", "exlast", "Xmin", "xend", "xmlstart", "exmax", "exMax", "pxlast", "pxmin", "xstart", "fxax", "xMAX", "xax", "eymin"], "ymax": ["ypart", "ermag", "ypame", "hyas", "ymaz", "ymmain", "ymmake", "hyap", "symax", "ymain", "ermart", "yake", "irmax", "irmaz", "ymag", "ydake", "ymmap", "ymAX", "ymaxy", "hyain", "ymmag", "ymmaxy", "ypask", "symas", "ymap", "iemaxy", "ymmart", "ymand", "yax", "ypax", "yaz", "ydax", "iemax", "ypmax", "ypaxy", "ymmas", "ypake", "iemake", "ermax", "ymake", "hyax", "ydmax", "ymart", "ymmame", "ypaz", "ymas", "irmmax", "ymmax", "iemaz", "symain", "yask", "ydand", "iemand", "ymmaz", "ymmmax", "ymask", "iemmax", "ypand", "ymmask", "symap", "ypAX", "ymame", "ypag", "ymmAX", "ermame", "irmAX"], "rel_xmin": ["rel_zfirst", "rel_yname", "rel_ixmax", "rel_onmod", "rel_ypath", "rel_onmin", "rel_onfirst", "rel_ixpath", "rel_xfirst", "rel_xname", "rel_xpath", "rel_xmod", "rel_ixname", "rel_yfirst", "rel_onmax", "rel_ixmin", "rel_zmax", "rel_zmin", "rel_zmod", "rel_ymod"], "rel_ymin": ["rel_symin", "rel_ymon", "rel_xleft", "rel_symax", "rel_cymin", "rel_cmap", "rel_xmind", "rel_tryleft", "rel_ymind", "rel_cymax", "rel_symind", "rel_symap", "rel_trymin", "rel_yleft", "rel_cyleft", "rel_trymon", "rel_cmind", "rel_xmon", "rel_cymon", "rel_ymap", "rel_cmax", "rel_xmap", "rel_trymax", "rel_cmin"], "rel_xmax": ["rel_oxax", "rel_xcross", "rel_ycross", "rel_yxmin", "rel_yxcross", "rel_exmed", "rel_xmed", "rel_ymed", "rel_yax", "rel_exax", "rel_yxax", "rel_Xax", "rel_Xmin", "rel_yxmax", "rel_oxmax", "rel_exmax", "rel_oxmin", "rel_Xcross", "rel_xax", "rel_Xmax", "rel_oxmed", "rel_exmin"], "rel_ymax": ["rel_ymagic", "rel_ymmax", "rel_wyagic", "rel_yagic", "rel_ymmagic", "rel_yask", "rel_nmmax", "rel_wyaj", "rel_nmaj", "rel_yyap", "rel_yax", "rel_yymax", "rel_yaj", "rel_ymask", "rel_ymmaj", "rel_yyax", "rel_wyax", "rel_nmax", "rel_ymmap", "rel_wyask", "rel_ymap", "rel_ymmmax", "rel_yyaj", "rel_ymmask", "rel_nmap", "rel_ymaj"], "P": ["J", "I", "PI", "Q", "K", "Pro", "p", "Ps", "SP", "W", "PA", "BP", "B", "PO", "TP", "PP", "PU", "PE", "vP", "X", "AP", "DP", "G", "D", "CP", "SCP", "N", "S", "PT", "Array", "O", "Y", "PC", "V", "PS", "E", "GP", "PR", "PM", "M", "PIN", "F", "PRE", "Z", "T", "C", "Progress", "R", "PUT", "L", "H", "IP"], "ref_picture": ["refptpolicy", "ref_manager", "refptpicture", " ref_policy", "ref_Picture", "rel_memory", "ref2pict", "refptmedia", "ref2image", "ref2Picture", " ref_image", " ref_Picture", "ref_memory", " ref_profile", "ref2picture", " ref_media", "ref_policy", "ref_media", "ref2profile", "rel_policy", "ref_pict", "ref_image", "rel_picture", "refptmanager", " ref_pict", "ref_profile", " ref_manager"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAAPIEncodePicture *pic, *next;\n\n\n\n    for (pic = ctx->pic_start; pic; pic = next) {\n\n        next = pic->next;\n\n        vaapi_encode_free(avctx, pic);\n\n    }\n\n\n\n    if (ctx->va_context != VA_INVALID_ID) {\n\n        vaDestroyContext(ctx->hwctx->display, ctx->va_context);\n\n        ctx->va_context = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->va_config != VA_INVALID_ID) {\n\n        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);\n\n        ctx->va_config = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->codec->close)\n\n        ctx->codec->close(avctx);\n\n\n\n    av_buffer_pool_uninit(&ctx->output_buffer_pool);\n\n\n\n    av_freep(&ctx->codec_sequence_params);\n\n    av_freep(&ctx->codec_picture_params);\n\n\n\n    av_buffer_unref(&ctx->recon_frames_ref);\n\n    av_buffer_unref(&ctx->input_frames_ref);\n\n    av_buffer_unref(&ctx->device_ref);\n\n\n\n    av_freep(&ctx->priv_data);\n\n\n\n    return 0;\n\n}\n", "idx": 8835, "substitutes": {"avctx": ["navcontext", "vcc", "vcfg", "wavcfg", " avcontext", "vreq", "cvreq", " avcmd", " avreq", "AVtx", " avcc", "avqt", "vtx", "wavctx", "navctx", "wavcc", "vcontext", "AVctx", "AVcontext", "avcmd", "avreq", "vqt", "avcontext", "navtx", "cvctx", " avqt", "AVcmd", "vcmd", "navqt", "cvcontext", " avcfg", "cvtx", "wavcontext", "avtx", "avcfg", " avtx", "avcc", "vctx"], "ctx": ["tm", "warn", "doc", "ck", "xp", "config", "prefix", "quit", "ct", "proc", "func", "kt", "pg", "desc", "ctl", "progress", "parent", "cc", "check", "wcs", "cmd", "nc", "context", "comm", "cv", "lex", "history", "td", "tx", "cmp", "tp", "ctrl", "tk", "ind", "jp", "args", "xs", "ka", "txt", "cond", "fn", "conn", "conf", "comp", "rt", "cm", "etc", "batch", "work", "jac", "obj", "std", "crit", "req", "err", "compl", "resp", "cp", "reason", "nt", "iat", "scope", "tc", "timeout", "ic", "kl", "dl", "mc", "px", "lc", "mk", "anc", "tmp", "exec", "ns", "hw", "loc", "ann", "mt", "cons", " cx", "cl", "cf", "xc", "act", "pkg", "np", "wx", "cb", "addr", "ppo", "expr", "checked", "today", "cfg", "gc", "shape", "val", "ctr", "wp", "kw", "fc", "msg", "co", "inst", "pa"], "pic": ["phot", " nic", "icon", "nic", "png", "py", "Pic", "tx", "pc", "syn", "pat", "pas", "par", "sci", "pp", "li", "pse", "image", "fig", "ping", "cam", "prev", "pan", "picture", "p", "sp", "peg", "ps", "pg", "bc", "jp", "np", "capt", "ic", "txt", "ig", "pick", "shot", "pres", "pers", "snap", "pb", "mc", "pen", "photo", "px", "ics", "pr", "feat", "pot", "pl", "anc", "tmp", "eric", "pipe", "spr", "pi", "pin", "piece", "pict", "Picture", "img", "pn", "pa"], "next": ["inner", "png", "inc", "pc", "nl", "config", "path", "pp", "li", "ping", "end", "prev", "Next", "step", "span", "ng", "p", "sp", "seq", "gov", "frame", "ne", "first", "nt", "sec", "future", "jp", "np", "sequence", "ptr", "after", "nn", "desc", "txt", "j", "data", "n", "pb", "fn", "last", "new", "big", "nr", "gen", "info", "pr", "ns", "nc", "adj", "start", "peer", "pict", "link", "z", "gt", "msg", "ner", "head", "max", "nd", "size", "nw", "pn", "sys"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t socket_read(int sockfd, void *buff, size_t size)\n\n{\n\n    ssize_t retval, total = 0;\n\n\n\n    while (size) {\n\n        retval = read(sockfd, buff, size);\n\n        if (retval == 0) {\n\n            return -EIO;\n\n        }\n\n        if (retval < 0) {\n\n            if (errno == EINTR) {\n\n                continue;\n\n            }\n\n            return -errno;\n\n        }\n\n        size -= retval;\n\n        buff += retval;\n\n        total += retval;\n\n    }\n\n    return total;\n\n}\n", "idx": 8846, "substitutes": {"sockfd": ["sockspid", "tsocksf", " sockfile", " sinkfile", "sackfile", " sockfp", "sockfin", " sinkfd", "sinkfin", " sinkfp", "sackfin", "sackfp", "tsockfd", "sockfile", "sockf", "socksfd", "sackfd", "tsockf", "sinkfile", "sackpid", "socksptr", "sackptr", "tsockpid", "tsockspid", "sockpid", "sinkfp", "sockfp", "sockptr", "sickfp", "sinkfd", " sockfin", "sinkpid", " sinkfin", "tsockptr", "sackf", "sinkptr", "tsocksfd", "sickfd", "sinkf", "sickfile", "socksf", "tsocksptr", "sickfin"], "buff": ["butt", "grow", "obj", "off", "bf", "buffer", "read", "text", "uf", "quit", "uff", "ff", "form", "p", "buf", "bl", "f", "bin", "ind", " buf", "ref", "cb", "tab", "raw", "bytes", "bs", "txt", "hold", "ext", "mem", "bound", "data", "cond", "pb", "t", "v", "fr", "b", "tmp", "cmd", "orig", "Buff", "bb", "ob", "batch", "msg", "nd"], "size": ["len", "empty", "small", "ose", "success", "send", "status", "num", "sum", "read", "code", "buffer", "news", " Size", "complete", "valid", "sp", "sent", "Size", "SIZE", "capacity", "scope", "year", "type", "timeout", "zero", "args", "g", "length", "required", "ize", "term", "function", "all", "index", "scroll", "done", "needed", "total", "global", "t", "body", "count", "zone", "good", "iz", "shape", "e", "c", "sh", "scale", "sn", "fee", "si", "table", "equal", "full", "speed", "set", "z", "no", "max", "name", "offset", "state", "style"], "retval": [" retVAL", "extval", "eltvalue", "Retval", "Retvals", "altval", " returnval", "reteval", " retvalue", "retVal", "reeval", " retv", "reVal", "rVal", "exteval", "returneval", "altVAL", "alteval", " retvals", "interVal", "rtVal", " reteval", "intereval", "retvals", "returnVal", "rev", "pretVal", "rval", " retVal", "rtVAL", "rv", "reval", "RetVAL", "rVAL", "elteval", "eltVal", "pretvals", "interval", " returnvalue", "RetVal", "extvalue", "retVAL", "returnvalue", "preteval", "returnval", " returnVal", "rtvalue", "extVAL", "Reteval", "retv", " returnVAL", "rtval", "eltval", "altvalue", "retvalue", "pretval"]}}
{"project": "qemu", "commit_id": "4981bdec0d9b3ddd3e1474de5aa9918f120b54f7", "target": 0, "func": "AioContext *blk_get_aio_context(BlockBackend *blk)\n\n{\n\n    return bdrv_get_aio_context(blk->bs);\n\n}\n", "idx": 8855, "substitutes": {"blk": ["blak", "blj", " blj", "brk", "slk", " blck", "blK", "Blj", "Blak", "brkt", "blck", "brck", "Blkt", "Blk", "slck", "brj", "Blck", " blak", "BlK", "blkt", " blK", " blkt", "slK", "slak"]}}
{"project": "qemu", "commit_id": "6f864e6ec8812d5a5525a7861ca599c6bcabdebe", "target": 0, "func": "static int vfio_load_rom(VFIODevice *vdev)\n\n{\n\n    uint64_t size = vdev->rom_size;\n\n    char name[32];\n\n    off_t off = 0, voff = vdev->rom_offset;\n\n    ssize_t bytes;\n\n    void *ptr;\n\n\n\n    /* If loading ROM from file, pci handles it */\n\n    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {\n\n        return 0;\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\",\n\n             vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n             vdev->host.function);\n\n    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);\n\n    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);\n\n    memset(ptr, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->fd, ptr + off, size, voff + off);\n\n        if (bytes == 0) {\n\n            break; /* expect that we could get back less than the ROM BAR */\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            memory_region_destroy(&vdev->pdev.rom);\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);\n\n    vdev->pdev.has_rom = true;\n\n    return 0;\n\n}\n", "idx": 8858, "substitutes": {"vdev": ["vpriv", "vcstat", "uvpriv", "valdev", "vstat", "enwd", "svdef", "verdev", "convdev", "ovdev", "varDev", "wdev", "evobj", "vconn", " vdiv", "ivDEV", "vvtry", " vver", "verreq", "vcdiv", "verdevice", " vwd", "svgo", " vDEV", "svdes", " vdevice", "viewdev", "evserv", "pdev", "vrad", "uvdiv", "vmdat", " vstore", "verDEV", "nvver", "vserv", "endev", "vdd", "vvdd", " vcast", "vcast", "vserial", "uvcast", "wev", "valver", " vpad", "vcconn", "vctry", " vdat", "vcver", "pev", "uvserial", "vartry", "vcpay", " vval", "vtdev", "fcmd", "uvcmd", "viewtry", "viewdiv", "vvDev", "svobj", "vcreq", "vcomment", "uvdev", "uvconn", "vcve", "vcDEV", "vvdiv", " vpriv", "vmpay", "uvgu", "uvvalid", "wstat", "evgo", "hdev", "pdevice", "vergo", "ivdev", " vconn", "vev", "valdiv", "ovcomment", "avcast", "verwd", "endiv", "vercomment", "avver", "vmgu", "vdef", "svcomment", " vpay", "vDev", "vvpad", "valcmd", "Vserv", "pstat", "vstore", "hev", "vvdev", "wdevice", "svdev", "hdevice", "evdevice", "varpriv", "valrad", "avval", "fdev", "vcserv", "convval", "vgu", "ovDev", "verstore", "vmdev", "vwd", "vdat", "enDev", "Vver", "varpad", "vdevice", "varcomment", "fdevice", "avwd", "vcdat", "avdiv", "hgo", "vmvalid", "vvalid", "vver", " vserv", " vcomment", "nvdiv", "vtry", "nvcast", "vobj", "vardev", "vcwd", "Vdev", "vcmd", "vgo", "vercast", "valdevice", "vpad", "evdef", "ivtry", "ivcomment", "ivpad", "vdes", "uvtry", "vcdevice", "vardd", "uvstore", " vserial", "verdiv", "evdes", "frad", " vDev", "uvrad", "vtgu", "vreq", " vdef", "vDEV", "vcev", "vcdes", "Vve", "vtpad", "vcdev", "ivreq", "ovgo", "vtvalid", "verserial", "varconn", "avdev", "vargo", "vval", "avDev", "avpad", "vmpad", "svDev", "svev", " vgo", "vve", " vve", " vobj", "convpad", "evdev", "vmconn", "vpay", "vardiv", "evev", " vdd", "ivdiv", "nvdev", "svdevice", "vccomment", "uvdevice", "uvpad", "vvcomment", "valcast", "vdiv", "svserv", " vtry"], "name": ["NAME", "key", "len", "off", "id", "spec", "address", "nm", "part", "a", "prefix", "code", "resource", "names", "order", "format", " names", "base", "path", "init", "o", "error", "label", "m", "l", "type", "ame", "local", "word", "mem", "r", "data", "n", "v", "info", "e", "b", "c", "comment", "title", "str", "w", "start", "Name", "x", "z", "item", "time", "no", "space", "size"], "bytes": ["ms", "users", "len", "mb", "ges", "errors", "gets", "io", "frames", "blocks", "units", "oms", "izes", "les", "gs", "words", "lines", "files", "cs", "points", "outs", "bits", "ies", "values", "es", "zero", "fixes", "xs", "bs", "terms", "ries", "rows", "ones", "new", "bps", "strings", "os", "ips", "loads", "ows", "ns", "abytes", "results", "elt", "vals", "Bytes", "gb", "seconds", "steps", "ls", "tes", "eros", "odes", "maps", "byte", "size", "cells", "eds", "items", "parts"], "ptr": ["arr", "obj", "tr", "tty", "prime", "off", "address", "pc", "tp", "buffer", "code", "pointer", "pt", "err", "ff", "alloc", "proc", "p", "sp", "buf", "inters", "rep", "ps", "fp", "pad", "ind", "pointers", "prot", "pos", "ref", "inter", "port", "handle", "addr", "mem", "index", "r", "br", "ts", "ix", "t", "ctx", "fr", "pr", "ctr", "rect", "sh", "hw", "pipe", "pi", "Ptr", "set", "loc", "offset", "dr", "ret"]}}
{"project": "qemu", "commit_id": "9c5ce8db2e5c2769ed2fd3d91928dd1853b5ce7c", "target": 0, "func": "UuidInfo *qmp_query_uuid(Error **errp)\n\n{\n\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    char uuid[64];\n\n\n\n    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n\n\n    info->UUID = g_strdup(uuid);\n\n    return info;\n\n}\n", "idx": 8866, "substitutes": {"errp": ["ErP", "erP", "error", "errr", "errP", "rP", "Error", "rror", "Erp", "rp", "Err", "err", "rr", "errror", "erp"], "info": ["obj", "success", "id", "ready", "entry", "show", " information", "fi", "status", "fo", "off", " hello", "order", "up", "event", "list", "job", "o", "f", "report", "error", "open", "recent", "type", "ret", "def", "json", "details", "row", "data", "total", " Info", "state", "check", " inf", "conf", "one", " error", "unknown", "cache", "about", "ion", "inf", "lock", "query", "comment", "current", " tv", "from", "information", " INFO", "options", "it", "INFO", "group", "bar", "user", "time", "no", "Info", "sys"], "uuid": ["uidId", "cufrom", "uidname", " cuId", "duid", "duId", "uuname", "cuend", "uidd", " cufile", "uid", " buId", "cuid", "uud", "custr", "uidid", "cud", "uufrom", "duname", "uvl", " cufrom", "ud", "uvid", "uuId", "uuin", "uustring", " buid", "uId", "cuin", " cuid", "uustr", "ugid", "ugin", "ugstring", "uidstr", "uuend", "cuId", "custring", "uidend", "uufile", "cufile", "ustr", "uul", " bufile", " bufrom", "ugl", "uvstring", "uvin", "cuname", "duend", "cul"]}}
{"project": "FFmpeg", "commit_id": "d7eabd50425a61b31e90c763a0c3e4316a725404", "target": 0, "func": "static int mpc7_decode_frame(AVCodecContext * avctx, void *data,\n\n                             int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb;\n\n    int i, ch;\n\n    int mb = -1;\n\n    Band *bands = c->bands;\n\n    int off, ret, last_frame, skip;\n\n    int bits_used, bits_avail;\n\n\n\n    memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));\n\n\n\n    buf_size = avpkt->size & ~3;\n\n    if (buf_size <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet size is too small (%i bytes)\\n\",\n\n               avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (buf_size != avpkt->size) {\n\n        av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n\n               \"extra bytes at the end will be skipped.\\n\");\n\n    }\n\n\n\n    skip       = buf[0];\n\n    last_frame = buf[1];\n\n    buf       += 4;\n\n    buf_size  -= 4;\n\n\n\n    /* get output buffer */\n\n    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;\n\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    av_fast_padded_malloc(&c->bits, &c->buf_size, buf_size);\n\n    if (!c->bits)\n\n        return AVERROR(ENOMEM);\n\n    c->dsp.bswap_buf((uint32_t *)c->bits, (const uint32_t *)buf, buf_size >> 2);\n\n    init_get_bits(&gb, c->bits, buf_size * 8);\n\n    skip_bits_long(&gb, skip);\n\n\n\n    /* read subband indexes */\n\n    for(i = 0; i <= c->maxbands; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            int t = 4;\n\n            if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;\n\n            if(t == 4) bands[i].res[ch] = get_bits(&gb, 4);\n\n            else bands[i].res[ch] = bands[i-1].res[ch] + t;\n\n        }\n\n\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            mb = i;\n\n            if(c->MSS) bands[i].msf = get_bits1(&gb);\n\n        }\n\n    }\n\n    /* get scale indexes coding method */\n\n    for(i = 0; i <= mb; i++)\n\n        for(ch = 0; ch < 2; ch++)\n\n            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);\n\n    /* get scale indexes */\n\n    for(i = 0; i <= mb; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(bands[i].res[ch]){\n\n                bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i];\n\n                bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]);\n\n                switch(bands[i].scfi[ch]){\n\n                case 0:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 1:\n\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];\n\n                    break;\n\n                case 2:\n\n                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 3:\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    break;\n\n                }\n\n                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];\n\n            }\n\n        }\n\n    }\n\n    /* get quantizers */\n\n    memset(c->Q, 0, sizeof(c->Q));\n\n    off = 0;\n\n    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)\n\n        for(ch = 0; ch < 2; ch++)\n\n            idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n\n\n\n    ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);\n\n\n\n    bits_used = get_bits_count(&gb);\n\n    bits_avail = buf_size * 8;\n\n    if (!last_frame && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame: used %i of %i bits\\n\", bits_used, bits_avail);\n\n        return -1;\n\n    }\n\n    if(c->frames_to_skip){\n\n        c->frames_to_skip--;\n\n        *got_frame_ptr = 0;\n\n        return avpkt->size;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = c->frame;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 8878, "substitutes": {"avctx": [" avctl", "afpkg", "averkl", "wavtx", "apcontext", "avcu", " avcontext", "avejp", "avefx", "wavkl", "avctl", "vrjac", "avconn", "ovjp", "avecontext", "ovjac", "apctl", "avfx", "ovctx", "afctx", "avectl", "avereq", "averctl", "vrjp", "averconn", " avpkg", "wavctx", "afjp", "vrtx", "avreq", "avcontext", "ovtx", "vrctx", "wavjac", "avkl", "averpkg", "affx", "afreq", "avecu", "vrcu", "avjp", "aveconn", "avectx", "afkl", "afctl", " avjp", "averctx", "wavctl", "afcontext", " avjac", "averjac", "vrconn", "avertx", "aptx", "avtx", "avjac", "avejac", " avtx", "averreq", "avpkg", "averfx", "wavpkg", "apctx", "avetx", "avercu"], "data": ["output", "align", "Data", "empty", "next", "read", "buffer", "text", "a", "padding", "message", "image", "p", "value", "o", "f", "bin", "frame", "pad", "d", "block", "ata", "def", "bits", "sequence", "raw", "window", "bytes", "mu", "r", "video", "t", "input", "dat", "str", "w", "batch", "DATA", "name", "size", "out"], "got_frame_ptr": ["got_frame2handle", "got_fr_pointer", "got_frame2pointer", "got_frame_handle", "got_framethandle", "got_fr_ptr", "got_fr_pointers", "got_frametpointers", "got_frame_pointer", "got_frame2pointers", "got_fr_handle", "got_frame2ptr", "got_frametptr", "got_frame_pointers", "got_frametpointer"], "avpkt": ["avpacket", "averpkt", "avcpct", "wavpix", "averproux", "afpkt", "avjpacket", "avopkt", "avPkt", "avopmsg", "avpix", "avopct", "avptx", "averpet", "avPnt", "avppct", "averprokt", "avrespacket", "afpmsg", "afopkt", "afpct", "avpbtx", "avrespct", "avPet", "avcpet", "avcpKT", "averpct", "avproet", "avcpix", "afpnt", "avcpacket", "wavopacket", "avppnt", "avpnt", "avpux", "afopmsg", " avpacket", "wavopct", "avjpct", "avpmsg", "avppkt", "wavopkt", "afppct", "avopix", "avcpkt", "afpptx", "averproet", "avPKT", " avpKT", "avckt", "avcpux", "avcet", "avopet", "avjpkt", "avPacket", "averproct", "avpbnt", "afpacket", " avpct", "avPtx", "avproct", " avPKT", "avopacket", "wavopix", "avPct", " avPct", "wavpacket", "avcmsg", "avrespKT", "avcpmsg", "avprokt", "avjpix", "avpKT", "afppnt", "avpbkt", "afpet", "wavpkt", "afppkt", "avproux", "avcacket", "afptx", "avpbct", "wavpct", "afopet", "avpct", "avpptx", " avPacket", "avrespkt", "averpux", " avPkt", "avPux", "avpet", "afopacket"], "buf": ["arr", "doc", "len", "shift", "tr", "lim", "mb", "map", "nm", "xff", "buffer", "read", "jump", "uf", "rb", "err", "seek", "ff", "uv", "p", "func", "seq", "keep", "bin", "hz", "vec", "pkg", "boxes", "pos", "fb", "np", "limit", "cb", "block", "progress", "ref", "window", "bytes", "wait", "txt", "queue", "mem", "br", "done", "pb", "emb", "bps", "v", "deg", "good", "cast", "b", "mates", "tmp", "cmd", "late", "orig", "str", "pause", "Buff", "foo", "batch", "buff", "stop", "db", "msg", "cv", "img", "wb"], "buf_size": ["buff_se", "buf2num", "uf_length", "uf_name", "uf_time", "buf_name", "buftsize", "buff_length", " buf_unit", "buf_length", "buff_Size", "buf_sum", "buftnum", "buf_set", " buf_Size", "buf_num", "buf2length", " buf_len", "buff_SIZE", "uf_set", " buf_sum", "buff_len", "buf_len", "buf_se", "buf2set", "buf2size", "uf_num", "uf_ize", "buftset", "buf_ize", "uf_len", "uf_SIZE", "buf_Size", "buf_unit", "buf_SIZE", " buf_length", " buf_count", "buftlength", " buf_SIZE", "buf_time", "buf_count", "buff_size", "uf_size", " buf_ize"], "c": ["lib", "cmp", "con", "abc", "pc", "config", "a", "call", "cam", "ct", "enc", "k", "p", "ec", "cl", "f", "cp", "cf", "bc", "dc", "xc", "g", "d", "cs", "tc", "m", "l", "cb", "cc", "ce", "cont", "chain", "coll", "mc", "t", "ci", "ctx", "ac", "rc", "lc", "v", "conf", "cache", "e", "b", "com", "h", "cm", "etc", "cu", "fc", "comm", "C", "co", "cv", "cr", "vc", "conv", "ca"], "gb": ["tm", "py", "xy", "ge", "gg", "gif", "bf", "gm", "rb", "tk", "tg", "gs", " thumb", "GB", "Gb", " np", "pg", "g", " td", "bm", "fb", "git", "bits", "cb", " GB", " db", "gin", " rg", "yg", "bg", "storage", "eg", "gd", "eb", "rg", "fg", " ssh", "ubs", "cfg", "gu", "gc", " eg", "sb", " cz", "kb", " pg", "bd", "cgi", " ng", "by", " kb", "nb", "gt", "db", "ib", "bt", "cv", "vm", "wb", "bridge"], "i": ["ami", "id", "ai", "I", "io", "ie", "li", "ei", "at", "wi", "p", "o", "sim", "ind", "ni", "ui", "ip", "m", "l", "ki", "ti", "ic", "in", "us", "mi", "r", "chain", "is", "j", "im", "ix", "index", "n", "y", "t", "ci", "zi", "v", "phi", "xi", "multi", "e", "b", "h", "gi", "bi", "di", "pi", "si", "er", "it", "x", "ini", "hi", "ims", "ii"], "ch": ["Ch", "chid", "mot", "ph", "pc", "sky", "qq", "channel", "q", "chan", "sch", "cor", "chn", "k", "sub", "ach", "height", "an", "ich", "cp", "th", "l", "cs", "hl", "cb", "cht", "qt", "cho", "chain", "y", "qu", "count", "v", "zh", "och", "mk", "chip", "sh", "h", "kh", "yet", "ih", "tch", "sc", "ech", "CH", "hi", "el", "high", "ht", "cha"], "bands": ["amps", "cards", "photos", "hands", "dos", "banks", "orders", "pieces", "units", "classes", "mb", "frames", "blocks", "balls", "types", "waves", "bright", "devices", "Bs", "artifacts", "words", "phones", "pages", "lines", "ints", "rooms", "files", "images", "points", "planes", "bits", "pins", "chains", "fps", "groups", "bys", "objects", "bytes", "heads", "books", "rings", "videos", "ands", "plugins", "metadata", "cats", "b", "annels", "products", "tags", "kb", "codes", "band", "ks", "versions", "hz", "missions", "parts"], "off": ["obj", "op", "Off", "on", " offset", "eff", "ff", "o", "f", "error", "offs", "ok", "pos", "ref", "def", " af", "raw", "j", "of", "new", "cmd", "from", "load", "start", "it", "set", "offset", "out"], "ret": ["fin", "len", "lt", "success", "tr", "reset", "net", "empty", "got", "back", "flag", "err", "print", "det", "bool", "RET", "resp", "f", "nt", "jp", "ref", "fun", "bits", "def", "progress", "txt", "alt", "mem", "last", "mel", "rem", "rets", "deg", "val", "Ret", "rt", "elt", "re", "str", "res", "rm", "it", "result", "gt", "nil", "fit", "ll", "dt", "dr", "out", "mt"], "last_frame": ["last_Frame", " last_channel", "last___Frame", "Last_frame", "Last_channel", "last___sample", "last___frame", "last_image", " last_frames", "last___image", "last___frames", " last_sample", "last_frames", " last_image", "last_channel", "last___channel", "Last_Frame", "last_sample"], "skip": ["fin", "ipp", "tr", "next", "syn", "send", "jump", "status", "cmp", "hide", "move", "eps", "seek", "Skip", "pass", "step", "prep", "sp", "ps", "slot", "iter", "ip", "push", "stop", "need", "pos", "pkg", "sleep", "zero", "wait", "miss", "mask", "addr", "mem", "index", "snap", "rel", "scan", "clip", "ips", "copy", "missing", "start", "strip", "seed", "offset", "sk", "sys"], "bits_used": ["bitsunused", "bytes2used", "bytes2read", "bits2read", "bits2available", "bitsunavailable", "bitsunread", "bits_available", "bytes_available", "bits_read", "bits2used", "bytes2available", "bytes_read", "bytes_used"], "bits_avail": ["bits_averile", "bits_avag", "bits_averag", "bits_overail", "bits_abag", "bits_overile", "bits_abile", "bits_abail", "bits_overil", "bits_averil", "bits_averail", "bits_overag", "bits_avile", "bits_abil", "bits_avil"]}}
{"project": "FFmpeg", "commit_id": "35cb6854bb76b4a5b6f2aea2dce81e18d7ab61cd", "target": 1, "func": "static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n\n                      unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    const unsigned char *ps_end;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    ps_end = src + src_len;\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (ps_end - ps < 1)\n\n            return 0;\n\n        *pd++ = *ps++;\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (ps_end - ps < 1)\n\n            break;\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end || ps_end - ps < l)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end || ps_end - ps < 2)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return ps - src;\n\n}\n", "idx": 8900, "substitutes": {"src": ["lb", "syn", "sync", "source", "std", "rs", "init", "proc", "stream", "sub", "buf", "seq", "bin", "ind", "trans", "rob", "iter", "cur", "ins", "null", "ptr", "gz", "gin", "pri", "cc", "supp", "usr", "txt", "addr", "in", "bg", "ser", "rl", "rel", "impl", "rc", "sur", "input", "sb", "ctr", "comp", "ipl", "tmp", "copy", "target", "rt", "sel", "sr", "origin", "start", "st", "rest", "sc", "dist", "result", "img", "msg", "pack", "loc", "inst", "out", "sys"], "src_len": [" src_line", "src_length", " src_list", "src_line", "source_length", "src_l", "src_lit", "source_lit", "src_list", "source_len", "source_list", " src_l"], "src_count": ["src2count", "src_Count", " src_length", "src_length", " src_Count", "src2len", "src2length", "rc_len", " src_size", "src_cache", "src2cache", "rc_length", "src_size", " src_cache", "rc_count", "rc_Count"], "dest": ["lit", "pas", "priv", "source", "std", "decl", "end", "to", "home", "sp", "dev", "prop", "gov", "cp", "trans", "del", "way", "gate", "pos", "type", "ptr", "desc", "port", "win", "usr", "txt", "dep", "phi", "v", "gen", "tmp", "target", "master", "origin", "est", "dist", "rest", "temp", "pipe", "st", "pro", "opt", "Dest", "result", "loc", "pid", "out"], "dest_len": ["target_l", "target_len", "destzlen", "src_length", "dest_l", "destzlength", "target_le", "src_line", "src_lim", "destzlim", "dest_lim", "dest_line", "dest_length", "destzline", "target_length", "dest_le"], "ps": ["ms", "vs", "ats", "pp", "proc", "hs", "pg", "pes", "cs", "pins", "ins", "fps", "parent", "pr", "pl", "os", "ips", "times", "pi", "checks", "maps", "ims", "ports", "aps", "tp", "ping", "sp", "gs", "sts", "pu", "changes", "jp", "outs", "ptr", "bs", "plays", "als", "js", "ss", "PS", "ops", "vals", "ls", "mp", "pid", "params", "ph", "pas", "pc", "pt", "places", "ppa", "rs", "css", "as", "Ps", "cp", "pos", "points", "es", "pps", "pa", "ts", "px", "bps", "ns", "s", "ds", "amps", "py", "pe", "eps", "pse", "p", "pkg", "lp", "pres", "posts", "pers", "its", "pb", "ress", "stats", "po", "fs", "res", "parts"], "ps_end": ["prJhead", "pslensend", "eps_begin", "eps_start", "psseqhead", "pr_end", "pslenedge", "psseqend", "psopend", "ts_ended", "eps_add", "pr___ord", "ps___range", "psipstart", "ps2end", "ps___end", "pszend", "psseqappend", "ps_send", "psiplast", "pr___ended", "pe_append", "ps2last", "pe_end", "pe_max", "ps_ends", "ps_edge", "pr_ended", "ps_gate", "pr_ord", "pe_gate", "prJend", "pr_head", "peopappend", "psJfin", "pr_fin", "psJhead", "ps_add", "ps2start", "psopappend", "ps_begin", "psseqfin", "ts_last", "ps_last", "pr_range", "ps_head", "pp_edge", "psseqmax", "pr___range", "pslenend", "ps2ended", "prJends", "ts_end", "peopgate", "eps_end", "ppzedge", "peopmax", "psseqends", "prJfin", "psopgate", "psseqgate", "ps_max", "ppzsend", "psJend", "psipend", "ts_start", "ps_append", "ppzend", "ps_range", "pp_send", "pr_ends", "pszsend", "ps___ord", "pszedge", "pr___end", "psJends", "ps_start", "psipended", "ps___ended", "pp_end", "peopend", "ps_ended", "ps_ord", "ps_fin", "psopmax"], "pd": ["td", "py", "dd", "ph", "id", "pic", "fd", "tp", "pe", "pat", "pc", "pp", "pt", "ppa", "ping", "pdf", "p", "cp", "pu", "ld", "d", "xd", "np", "jp", "cd", "ud", "hd", "pkg", "por", "lf", "lp", "md", "pm", "pb", "dl", "vd", "px", "phi", "pr", "pl", "PD", "ped", "po", "bd", "dp", "pi", "ls", "sd", "dt", "pid", "ds", "pn", "pod"], "i": ["u", "ai", "fi", "status", "I", "a", "me", "pp", "li", "ei", "print", "p", "o", "sim", "ind", "ui", "iter", "d", "ip", "g", "m", "ki", "ti", "ic", "cli", "in", "mi", "index", "is", "j", "im", "ix", "n", "y", "iu", "ci", "\u0438", "zi", "phi", "v", "xi", "e", "qi", "b", "multi", "c", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "ini", " ii", "oi", "hi", "s", "pid", "ii", "pa"], "l": ["ml", "len", "lin", "lit", "lt", "la", "u", "sl", "nl", "fl", "li", "list", "isl", "p", "o", "f", "lu", "ld", "d", "lv", "ol", "g", "limit", "m", "hl", "le", "lp", "ln", "il", "j", "kl", "n", "dl", "like", "t", "tl", "jl", "lc", "v", "pl", "b", "c", "h", "pi", "ul", "it", "lis", "lay", "z", "ls", "el", "s", "lo", "ll", "loc", "L", "length"], "dest_end": [" dest_stop", "prop_ended", "dest0est", "dest_est", "dest0dest", "dest_start", " dest_length", "prop_end", "src_end", "src_start", "dest_length", "prop_est", "dest_stop", "dest0ended", "dest_ended", " dest_start", "dest_dest", "src_stop", "prop_dest", "dest0end"]}}
{"project": "FFmpeg", "commit_id": "4f00519d9508e07aac58a00a9b514dae8ad95723", "target": 1, "func": "int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)\n\n{\n\n    av_log(avctx, AV_LOG_DEBUG, \"Header: %0X\\n\", show_bits(gb, 32));\n\n    v->profile = get_bits(gb, 2);\n\n    if (v->profile == PROFILE_COMPLEX)\n\n    {\n\n        av_log(avctx, AV_LOG_WARNING, \"WMV3 Complex Profile is not fully supported\\n\");\n\n    }\n\n\n\n    if (v->profile == PROFILE_ADVANCED)\n\n    {\n\n        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;\n\n        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;\n\n        return decode_sequence_header_adv(v, gb);\n\n    }\n\n    else\n\n    {\n\n        v->zz_8x4 = wmv2_scantableA;\n\n        v->zz_4x8 = wmv2_scantableB;\n\n        v->res_y411   = get_bits1(gb);\n\n        v->res_sprite = get_bits1(gb);\n\n        if (v->res_y411)\n\n        {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Old interlaced mode is not supported\\n\");\n\n            return -1;\n\n        }\n\n        if (v->res_sprite) {\n\n            av_log(avctx, AV_LOG_ERROR, \"WMVP is not fully supported\\n\");\n\n        }\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->s.loop_filter = get_bits1(gb); //common\n\n    if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"LOOPFILTER shall not be enabled in Simple Profile\\n\");\n\n    }\n\n    if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL)\n\n        v->s.loop_filter = 0;\n\n\n\n    v->res_x8 = get_bits1(gb); //reserved\n\n    v->multires = get_bits1(gb);\n\n    v->res_fasttx = get_bits1(gb);\n\n    if (!v->res_fasttx)\n\n    {\n\n        v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add;\n\n        v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add;\n\n    }\n\n\n\n    v->fastuvmc =  get_bits1(gb); //common\n\n    if (!v->profile && !v->fastuvmc)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"FASTUVMC unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->extended_mv =  get_bits1(gb); //common\n\n    if (!v->profile && v->extended_mv)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Extended MVs unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->dquant =  get_bits(gb, 2); //common\n\n    v->vstransform =  get_bits1(gb); //common\n\n\n\n    v->res_transtab = get_bits1(gb);\n\n    if (v->res_transtab)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"1 for reserved RES_TRANSTAB is forbidden\\n\");\n\n        return -1;\n\n    }\n\n\n\n    v->overlap = get_bits1(gb); //common\n\n\n\n    v->s.resync_marker = get_bits1(gb);\n\n    v->rangered = get_bits1(gb);\n\n    if (v->rangered && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_INFO,\n\n               \"RANGERED should be set to 0 in Simple Profile\\n\");\n\n    }\n\n\n\n    v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); //common\n\n    v->quantizer_mode = get_bits(gb, 2); //common\n\n\n\n    v->finterpflag = get_bits1(gb); //common\n\n\n\n    if (v->res_sprite) {\n\n        v->s.avctx->width  = v->s.avctx->coded_width  = get_bits(gb, 11);\n\n        v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11);\n\n        skip_bits(gb, 5); //frame rate\n\n        v->res_x8 = get_bits1(gb);\n\n        if (get_bits1(gb)) { // something to do with DC VLC selection\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported sprite feature\\n\");\n\n            return -1;\n\n        }\n\n        skip_bits(gb, 3); //slice code\n\n        v->res_rtm_flag = 0;\n\n    } else {\n\n        v->res_rtm_flag = get_bits1(gb); //reserved\n\n    }\n\n    if (!v->res_rtm_flag)\n\n    {\n\n//            av_log(avctx, AV_LOG_ERROR,\n\n//                   \"0 for reserved RES_RTM_FLAG is forbidden\\n\");\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Old WMV3 version detected, some frames may be decoded incorrectly\\n\");\n\n        //return -1;\n\n    }\n\n    //TODO: figure out what they mean (always 0x402F)\n\n    if(!v->res_fasttx) skip_bits(gb, 16);\n\n    av_log(avctx, AV_LOG_DEBUG,\n\n               \"Profile %i:\\nfrmrtq_postproc=%i, bitrtq_postproc=%i\\n\"\n\n               \"LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\\n\"\n\n               \"Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\\n\"\n\n               \"DQuant=%i, Quantizer mode=%i, Max B frames=%i\\n\",\n\n               v->profile, v->frmrtq_postproc, v->bitrtq_postproc,\n\n               v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv,\n\n               v->rangered, v->vstransform, v->overlap, v->s.resync_marker,\n\n               v->dquant, v->quantizer_mode, avctx->max_b_frames\n\n               );\n\n    return 0;\n\n}\n", "idx": 8901, "substitutes": {"avctx": [" avcontext", "avconn", "savcu", "avecontext", "avercmp", "averContext", "navconn", "avsys", "avesys", "avcmd", "avercpu", "averhandle", "avecu", "avehandle", "avnp", "vchandle", "averctx", "avcmp", "afpkg", "avepkg", "avernp", "navcp", "wavctx", "avcpu", "Avcmp", "navctx", "svctx", "avcontext", "Avctx", "avercontext", "savconn", "aveContext", "aveconn", "avectx", "avecpu", "navkt", "afcmp", "vcsys", "savctx", "avercf", "avcu", "avkt", " avcmd", "Avcmd", "avcf", "afctx", "svcmd", "averconn", "avercp", "vcctx", " avcmp", "avecf", "svcontext", "svcmp", "wavcontext", "Avcontext", "avekt", "avenp", "vccf", "avhandle", "avcp", "afcu", "avecmp", "averkt", "wavContext", "averpkg", "aversys", "vccpu", "savcp", "wavcmp", "avecp", "avContext", "avpkg", "vcnp", "avercu"], "v": ["vector", "vs", "current", "ch", "av", "vi", "q", "ev", "vv", "ov", "uv", "p", "ve", "vc", "value", "f", "k", "dev", "var", "d", "lv", "vp", "rev", "g", "m", "l", "sv", "qv", "i", "vt", "ver", "window", "max", "video", "j", "version", "data", "view", "t", "qu", "V", "cache", "env", "val", "b", "c", "query", "h", "w", "er", "pi", "it", "x", "get", "vr", "cv", "iv", "wire", "vm", "nv", "conv", "s", "tv"], "gb": ["tm", "py", "xy", "gg", "goo", "mb", "bf", "gif", "pc", "hog", "ch", "uf", "gm", "rb", "gnu", "hub", "range", "tg", "gs", "gov", "GB", "Gb", "bc", "g", "bm", "bits", "um", "gz", "cb", "wb", "args", "bn", "ruby", "bytes", "attr", "bs", "yg", "bg", "storage", "eg", "rl", "gd", "html", "pb", "emb", "eb", "phy", "rg", "ctx", "vg", "cfg", "deg", "erb", "gc", "sb", "b", "rect", "kb", "gy", "verified", "fb", "sys", "csv", "bb", "gam", "nb", "gt", "db", "bt", "vm", "img", "binary", "bridge"]}}
{"project": "qemu", "commit_id": "5b456438f5bb395ed6b1eec95e18ce7a7a884a0a", "target": 1, "func": "static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 8903, "substitutes": {"s390_dev": ["saddle_spec", "s380_conn", "s390jve", "s390_device", "saddle_device", "s390_ve", "s390__ev", "s390jdev", "slet__ve", "s380_ver", "slet_conf", "s390xdev", "s390__ve", "saddle_ev", "s380_dev", "s390_conf", "slet_Dev", "s390xconn", "s390_Dev", "s390_ev", "s380_ev", "s390__device", "saddle_dev", "slet_dev", "slet_ve", "s390xver", "s390__spec", "slet__dev", "s390_spec", "s390__Dev", "s390__dev", "s390jDev", "s390_conn", "slet__Dev", "s390xev", "s390_ver"], "dev": ["ow", "doc", "dd", "tr", "priv", "sky", " dw", "av", "device", "cam", "go", "build", "enc", "ev", "det", "form", " Dev", "var", "ve", "prop", "nt", "eng", "d", " device", "del", "cur", "def", "dis", "desc", "serial", "raw", "ver", "mem", "develop", "de", "test", "ad", "ac", "dem", "DEV", "rem", "conn", "v", "gu", "val", "Dev", "comment", "cmd", "des", "hw", "w", "res", "serv", "rad", "pack", "debug", "sd"], "vdev": ["qdiv", "vpriv", "hdevice", " vDev", "wde", "evdevice", "evDev", "qobj", "vdesc", "vstable", "vcev", "cvde", "kde", "udesc", " vdesc", "wstable", " vstable", "vcdev", "vde", "vvar", "vdevice", "wdev", " vdiv", "udiv", "cvstable", "wobj", " vpriv", "hpriv", "vcpro", "hDev", " vde", "vobj", " vobj", "evdev", "hdev", "uDev", "qev", "cvev", "vpro", " vvar", " vdevice", "vev", "qvar", " vpro", "qdevice", " vev", "vcde", "qdev", "udev", "kpro", "qpriv", "qdesc", "vdiv", "vDev", "cvdev", "kev", "qDev", "kdev", "evvar", "wev", "wdevice"]}}
{"project": "qemu", "commit_id": "0fbfbb59a9766247be20023b17eb7872e7b29323", "target": 0, "func": "static void apic_update_irq(APICState *s)\n\n{\n\n    int irrv, ppr;\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE))\n\n        return;\n\n    irrv = get_highest_priority_int(s->irr);\n\n    if (irrv < 0)\n\n        return;\n\n    ppr = apic_get_ppr(s);\n\n    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))\n\n        return;\n\n    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n}\n", "idx": 8927, "substitutes": {"s": ["ms", "sq", "spec", "a", "ats", "source", "rs", "hs", "p", "gs", "sts", "an", "ex", "ps", "d", "cs", "l", "m", "ins", "es", "sv", "ses", "bs", "aws", "r", "is", "js", "als", "S", "ss", "ts", "n", "its", "details", "sports", "t", "v", "ties", "os", "sb", "b", "c", "bis", "h", "ns", "fs", "z", "comm", "sis", "ls", "ds"], "irrv": ["irtrv", "irrq", "irrvp", "irvrvt", "irerrview", "ircrve", "irrrvr", "irvrvr", "outerrxvp", "ironrdv", "irrdvt", "irrxv", "ircrv", "irrva", "irrov", "irvrved", "irerrvr", "irrsv", "irvrve", "irrcva", "irrdf", "irrnv", "interrvi", "outerrxvr", "irrbvr", "irrove", "ironrq", "irrcv", "irrbv", "irtrbve", "irrvr", "interrv", "ironrdq", "outerrvr", "ironrdvt", "irrvi", "irrxvp", "irrnvt", "irerrvp", "irrdv", "irvrf", "irrnq", "irrnf", "irrvt", "irrbve", "interrcvi", "outerrvp", "outerrxv", "irrve", "irrcve", "irerrv", "irtrvr", "irrsview", "irrcvi", "ironrf", "outerrxview", "interrcva", "ironrv", "irrbved", "interrcv", "ircrva", "irvrq", "irrsvp", "irrrve", "irrxview", "irrrv", "irtrbved", "irtrbvr", "irrved", "irrdq", "interrva", "irtrved", "outerrv", "irrova", "irtrve", "ironrvt", "irrxvr", "ircrvi", "outerrview", "irrsvr", "interrve", "irrrved", "irrview", "interrcve", "ironrdf", "irrf", "irtrbv", "irrovi", "irvrv"], "ppr": ["ppvr", "upppr", "pprs", " pprs", "plr", "PPpr", "upprs", "padrc", "ampro", "PPr", "ppsr", "ppres", "appres", "ippro", "ippsr", "arpr", "pppr", "apppr", "apprs", "ipppr", "appr", "arppr", "plx", "PPres", "ppro", "amppr", "PPR", "PPrs", "pkgpr", "ppx", "padr", "PPx", "plrs", "pkgr", " ppx", "PPvr", "plR", "ampsr", "padvr", "padpr", "ampr", "pprc", "ippr", "uppres", " ppR", "PPrc", "pkgvr", "arpro", "pkgrc", "arpsr", "uppr", "ppR"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,\n\n\t\t CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr)\n\n{\n\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n\n    int err = 0;\n\n    uint16_t magic;\n\n\n\n\t/* already locked in setup_frame() */\n\n    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);\n\n    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);\n\n    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);\n\n    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);\n\n    __put_user(env->regs[R_EDI], &sc->edi);\n\n    __put_user(env->regs[R_ESI], &sc->esi);\n\n    __put_user(env->regs[R_EBP], &sc->ebp);\n\n    __put_user(env->regs[R_ESP], &sc->esp);\n\n    __put_user(env->regs[R_EBX], &sc->ebx);\n\n    __put_user(env->regs[R_EDX], &sc->edx);\n\n    __put_user(env->regs[R_ECX], &sc->ecx);\n\n    __put_user(env->regs[R_EAX], &sc->eax);\n\n    __put_user(cs->exception_index, &sc->trapno);\n\n    __put_user(env->error_code, &sc->err);\n\n    __put_user(env->eip, &sc->eip);\n\n    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);\n\n    __put_user(env->eflags, &sc->eflags);\n\n    __put_user(env->regs[R_ESP], &sc->esp_at_signal);\n\n    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);\n\n\n\n        cpu_x86_fsave(env, fpstate_addr, 1);\n\n        fpstate->status = fpstate->sw;\n\n        magic = 0xffff;\n\n    __put_user(magic, &fpstate->magic);\n\n    __put_user(fpstate_addr, &sc->fpstate);\n\n\n\n\t/* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n    __put_user(env->cr[2], &sc->cr2);\n\n\treturn err;\n\n}\n", "idx": 8931, "substitutes": {"sc": ["sche", "sq", "cle", "sync", "pc", "usc", "sci", "decl", "sch", "cam", "ec", "cl", "scrib", "sim", "mic", "bc", "dc", "sec", "scope", "tc", "osc", "sv", "desc", "capt", "ctl", "scl", "cc", "isc", "ss", "pb", "esc", "SC", "scan", "ci", "mc", "qu", "rc", "lc", "irc", "check", "ctx", "gc", "env", "c", "Sc", "anc", "sh", "sw", "uc", "asc", "sel", "sic", "cu", "fc", "tch", "mac", "comm", "cv", "cr", "ca"], "cs": ["ck", "vs", "spec", "Cs", "pc", "cus", "qs", "cks", "ats", "rs", "css", "err", "as", "ec", "gs", "CS", "ps", "cp", "cf", "tc", "es", "sv", "cc", "bs", "js", "ys", "isc", "ss", "ts", "esc", "ctx", "cas", "rc", "esp", "ics", "wcs", "os", "c", "acs", "ns", "fs", "ks", "csv", "si", "fc", "ces", "ls", "s", "ds", "sys"], "magic": ["empty", "ogo", " zero", "flag", "base", "init", "asm", "alloc", " maj", "field", "ok", "type", "length", " erase", "addr", "mem", "oo", "obar", "Count", "fields", "count", "os", "caps", "ctr", "red", "start"]}}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Free resources */\n\n    qemu_iovec_destroy(&acb->cur_qiov);\n\n    qed_unref_l2_cache_entry(acb->request.l2_table);\n\n\n\n    /* Free the buffer we may have allocated for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        qemu_vfree(acb->qiov->iov[0].iov_base);\n\n        acb->qiov->iov[0].iov_base = NULL;\n\n    }\n\n\n\n    /* Start next allocating write request waiting behind this one.  Note that\n\n     * requests enqueue themselves when they first hit an unallocated cluster\n\n     * but they wait until the entire request is finished before waking up the\n\n     * next request in the queue.  This ensures that we don't cycle through\n\n     * requests multiple times but rather finish one at a time completely.\n\n     */\n\n    if (acb == s->allocating_acb) {\n\n        s->allocating_acb = NULL;\n\n        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {\n\n            qemu_co_enter_next(&s->allocating_write_reqs);\n\n        } else if (s->header.features & QED_F_NEED_CHECK) {\n\n            qed_start_need_check_timer(s);\n\n        }\n\n    }\n\n}\n", "idx": 8946, "substitutes": {"acb": ["accbb", "aicx", "sacbe", " acbb", "aicwb", "acbe", "acsb", "absrb", "ancr", "pacd", "accsb", "aicbc", "achbs", "sacb", " cacb", "acbb", " acv", "actrb", "absbb", "ocr", "jacb", " cacbe", "ancd", "acbd", "accbr", "sacnb", "acbc", "acB", "accr", "ocB", "ancbb", "acrb", "ocbd", "pacsb", "jacx", "ancw", "ancsb", "mcb", "ancB", "accd", " acbr", " cacB", "achwb", " cacnb", "acw", " acr", "absb", "iacwb", "acbr", "accwb", "absbs", "accbd", "acv", "pacrb", "iacb", "ancrb", "accB", "actbb", "acr", "accb", "actbs", "mcB", "ocb", "ancb", "Acbs", "accrb", "acbs", "mcnb", "acd", "jacbc", "actb", "accbs", "achb", "accv", "iacbc", "acx", "ancbr", "aicb", "acwb", "achsb", "ocv", "mcbe", "ocw", "pacb", " acbd", "acnb", "Acb", "Acwb", "accw", "jacwb", "sacB", "Acsb", "iacx"], "s": ["sq", "vs", "spec", "sync", "sl", "ares", "qs", "sol", "ats", "rs", "hs", "p", "gs", "sts", "bes", "sm", "ps", "changes", "g", "cs", "ies", "sv", "ins", "ses", "sam", "es", "bs", "services", "params", "aws", "r", "is", "js", "als", "S", "ss", "ts", "j", "sports", "ssl", "state", "v", "ears", "sb", "b", "os", "sw", "bis", "has", "h", "ns", "stats", "fs", "comm", "sis", "ls", "tes", "ims", "ds", "uns", "sys"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte, page_mask;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    uint8_t access_flags;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /*\n\n     * We have standalone memory region for interrupt addresses, we\n\n     * should never receive translation requests in this region.\n\n     */\n\n    assert(!vtd_is_interrupt_addr(addr));\n\n\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,\n\n                                 iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        access_flags = iotlb_entry->access_flags;\n\n        page_mask = iotlb_entry->mask;\n\n        goto out;\n\n    }\n\n\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,\n\n                               cc_entry->context_entry.lo,\n\n                               cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                trace_vtd_fault_disabled();\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            goto error;\n\n        }\n\n        /* Update context-cache */\n\n        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,\n\n                                  cc_entry->context_cache_gen,\n\n                                  s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    /*\n\n     * We don't need to translate for pass-through context entries.\n\n     * Also, let's ignore IOTLB caching as well for PT devices.\n\n     */\n\n    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {\n\n        entry->iova = addr & VTD_PAGE_MASK_4K;\n\n        entry->translated_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n", "idx": 8949, "substitutes": {"vtd_as": ["vtd_a", "vcd_cs", "vsd_as", "vtdptbs", "vtdptcs", "vtd__las", "vsd_AS", "vtdptas", "vtd_s", "vtd_AS", "vsd_s", "vtd___s", "vtd_bs", "vcd_a", "vtd___ast", "vcd_bs", "vtd__ast", "vbd_ast", "vcd_as", "vbd_AS", "vtd_ast", "vbd_las", "vtd_cs", "vtdpta", "vtd_am", "vtd___AS", "vtd__as", "vtd___am", "vtd_las", "vtd__AS", "vtd___las", "vtd___as", "vbd_as", "vsd_am"], "bus": ["ck", "board", "bf", "al", "BUS", "as", "kt", "buf", "dev", "bc", "block", "way", "Bus", "type", "bs", "loop", "us", "chain", "clus", "boot", "box", "ctx", "ac", "dir", "os", "host", "b", "hw", "bug", " buses", "phys", "vc", "ux", "sys"], "devfn": ["evfin", "evFN", "devdn", "evdn", "Devln", "varfn", "varfun", " devpath", "varfilename", "evfn", "evfun", "patchfin", "evln", "patchfun", "devicefun", "Devnm", "devicedn", "Devfun", "varnm", "devpath", "devicefilename", "devln", "devicefn", " devFN", "evpath", "devfilename", " devfun", "devicenm", "devFN", "patchfn", " devln", "Devfn", "patchFN", " devfin", "devnm", "Devfilename", "devfin", "devfun", "Devpath", " devdn"], "addr": ["src", "arr", "ash", "dd", "id", "tx", "address", "map", "arp", "pat", "prefix", "add", "Address", "at", "rs", "route", "err", "ack", " address", "hash", "pad", "ip", "hop", "ref", "inter", "ptr", "adr", "handle", "ord", "alt", "r", "ix", "ad", "ac", "ctx", "rc", "ha", "ace", "ress", "host", "cmd", "eth", "rt", "str", "w", "hw", "res", "alias", "elt", "ag", "x", "mac", "coord", "phys", "msg", "name", "loc", "dr"], "is_write": ["isPwrite", " is_read", "isPwrit", " is_writ", " is_written", "is_writ", "isPwritten", "is_written", "isPread", "is_read"], "entry": ["doc", "RY", "record", "or", "cell", "event", "list", "enter", "ry", "nt", "cur", "inter", "ptr", "rance", "rent", "row", "ries", "se", "e", "ence", "er", "ent", "xml", "result", "set", "see", "Entry"], "s": ["source", "a", "rs", "as", "hs", "p", "sp", "gs", "sts", "ps", "g", "m", "service", "es", "sv", "ses", "bs", "r", "is", "js", "S", "ss", "ts", "se", "n", "its", "t", "v", "conf", "e", "sb", "os", "b", "c", "sw", "h", "sa", "ns", "w", "fs", "sc", "set", "ls", "space", "ds", "sys"], "ce": ["cue", "ck", "ate", " Ce", "cle", " che", " msg", "pe", "ice", "ie", "wife", "ge", " cc", " ge", "cell", "ct", "event", " ace", "cel", "ve", " pe", "ect", " car", "enter", " ne", "cf", "cur", "ae", "cer", "ere", "te", " ex", "cand", "ine", "cc", " sense", " cle", "CE", "se", "ane", "ci", "ense", "e", "ace", " fe", " eg", "ence", "ced", "com", "ke", "c", " ke", " CE", "er", " ice", "ent", "ces", "see", " ele", "ance", "ze", "co", "ade", "kee", "le", " ie", "ue", "ca", "cy"], "cc_entry": ["ctl_pair", "cc14pair", "cc__system", "cc2try", "cell_match", "cc14instance", "ccipry", "ccptentry", "ctledentry", "cell_entry", "ctledinstance", "ccedentry", "ctl_instance", "cc2entry", "ccmodentry", "cc2member", "ccgtry", "ctx_element", "cc_pair", "dc__system", "ccgenter", "ck2enter", "cc_info", "ccmodset", "cc_member", "ctx_info", "cc_system", "ck2member", "cc14entry", "ck_enter", "ctledpair", "ccptenter", "ctx_entry", "ccmexit", "dc_system", "ccipinfo", "cc_set", "ccipentry", "cc_ry", "ck2entry", "ck_try", "cc_match", "ccgentry", "ccptsystem", "cc_instance", "ck2try", "cc_ent", "ctl_entry", "ccgmember", " cc_ent", " cc_exit", "dc__entry", "dc_entry", "cc_exit", "ck_member", "ck_entry", "cc2enter", "dc_enter", "cc_try", "cell_set", "ccmodmatch", "ccment", "cc_enter", "dc__enter", "ccipelement", "ccedinstance", "cc_element", "cc__enter", "ctx_ry", "ccmentry", "cc__entry", "ccedpair"], "slpte": [" slpetes", "Slpporte", "slptE", "slntea", "slpted", "sslporte", "slnte", "slvante", "slptone", "Slpting", "slfting", "slpete", "slpetes", "sslpted", "Slpportd", "slapte", "sslportE", " slptea", "slpporten", " slpetea", "sslptE", "slntes", " slptee", "slpporte", "slportest", "slported", "slpportee", "slpporting", "sliptee", "slpeten", "slaptE", "slpportd", "slptoning", " slpete", "Slpten", "sliptd", "Slptee", "Slpportee", "sslptest", "sslported", "slppaes", "slptest", "slppaee", "slpetea", "slptd", "Slpporting", "slntee", "Slptd", "slptea", "slptes", "slfte", "slpetd", "Slpte", "slftee", "slipte", " slpetee", "slpten", "Slpporten", "slppae", "slptonen", "slvantest", "slptee", "slportE", "slvantE", "slapted", "slaptest", "slppaea", "slporte", "sslpte", "slptonee", "slipten", "slpetee", "slften", "slpting", "sslportest", " slptes", "slvanted"], "page_mask": ["pagelyflags", " page_id", "pagelyfee", "page_lock", "page_id", " page_flags", "page_flags", " page_lock", " page_flag", " page_cover", "pagelycover", "page_flag", "page_cover", "page_fee", "pagelymask", " page_fee"], "level": ["depth", "len", "status", "priority", "lan", "lvl", "flag", "layer", "lang", "Level", "weight", "height", "scope", "limit", "local", "loop", "index", "oom", "levels", "acl", "lock", "fac", "scale", "tag", "lay", "link", "debug", "high"], "ret_fr": ["ret2ly", "ret2fr", "dll", "ret_FR", "func", "ter_ly", "retfulFR", "Ret_FR", "ret2lr", "ret2br", " ret_br", "ter_Fr", "ret2dr", "retfulfr", "ret0ly", "retfulsim", "ret0Fr", "Ret_br", "ret_sim", "ret2Fr", "Ret_lr", "Ret_fr", "ret_dr", "Ret_fin", "ter_fr", "ret_lr", " ret_fin", "ret_Fr", "_", "Ret_sim", "ter_fin", "retfulbr", "ret_fin", "ret0fr", "ret_ly", " ret_dr", "ret_br", "ret2fin", "ret0fin"], "access_flags": ["access_rates", "access_mask", "accessingrates", "connectencetimes", "access_weights", "access_fields", " access_fs", "access2flags", "accessionflags", "accessiontimes", "accessetyflags", "accessenceweights", "access_levels", "accessencefields", "access_times", " access_flag", "access2mask", "connect_flags", "accessetyweights", "access_fs", "accessenceevents", "connect_rates", "connectenceevents", "connect_weights", "access2fs", "connectetyfields", "accessingflags", "access_flag", "connectetyweights", "connect_times", "connectencelevels", "accessionevents", "connectenceflags", "accessencetimes", "accessingfields", " access_mask", "accessetyfields", "connect_fields", "connectetyflags", "accessingweights", "accessencelevels", "connect_levels", "accessionlevels", "access_events", "accessencerates", "accessetyrates", "connectetyrates", "access2flag", "accessenceflags", "connect_events"], "iotlb_entry": ["iotlbs_Entry", "iotlas_member", "iotlb_ent", "iotlb_ry", "iotlb2Entry", "iotlbsptresult", "iotlb__ent", "iotlbsptEntry", "iotl_enter", "iotlbptEntry", "iotlab2Entry", "iotlbs_result", "iotlb__data", "iotl_entry", "iotl_data", "iotlab2member", "iotlbs_entry", "iotlb_Entry", "iotl_row", "iotlb_result", "iotlb2member", "iotlb__entry", "iotlas_entry", "iotl_ry", "iotlas_Entry", "iotl_Entry", "iotl_member", "iotlb_data", "iotlb2entry", "iotlb_enter", "iotlbptresult", "iotlb_row", "iotlb__member", "iotlab_member", "iotlbsptentry", "iotlb__ry", "iotl_ent", "iotlab2entry", "iotlab_Entry", "iotlbptentry", "iotlab_entry", "iotlb_member"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int load_multiboot(void *fw_cfg,\n\n                   FILE *f,\n\n                   const char *kernel_filename,\n\n                   const char *initrd_filename,\n\n                   const char *kernel_cmdline,\n\n                   int kernel_file_size,\n\n                   uint8_t *header)\n\n{\n\n    int i, is_multiboot = 0;\n\n    uint32_t flags = 0;\n\n    uint32_t mh_entry_addr;\n\n    uint32_t mh_load_addr;\n\n    uint32_t mb_kernel_size;\n\n    MultibootState mbs;\n\n    uint8_t bootinfo[MBI_SIZE];\n\n    uint8_t *mb_bootinfo_data;\n\n\n\n    /* Ok, let's see if it is a multiboot image.\n\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n\n    for (i = 0; i < (8192 - 48); i += 4) {\n\n        if (ldl_p(header+i) == 0x1BADB002) {\n\n            uint32_t checksum = ldl_p(header+i+8);\n\n            flags = ldl_p(header+i+4);\n\n            checksum += flags;\n\n            checksum += (uint32_t)0x1BADB002;\n\n            if (!checksum) {\n\n                is_multiboot = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!is_multiboot)\n\n        return 0; /* no multiboot */\n\n\n\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n\n    memset(bootinfo, 0, sizeof(bootinfo));\n\n    memset(&mbs, 0, sizeof(mbs));\n\n\n\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n\n    }\n\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n\n        uint64_t elf_entry;\n\n        uint64_t elf_low, elf_high;\n\n        int kernel_size;\n\n        fclose(f);\n\n\n\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_low, &elf_high, 0, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n\n            exit(1);\n\n        }\n\n        mh_load_addr = elf_low;\n\n        mb_kernel_size = elf_high - elf_low;\n\n        mh_entry_addr = elf_entry;\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n\n                  mb_kernel_size, (size_t)mh_entry_addr);\n\n    } else {\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n\n        mh_load_addr = ldl_p(header+i+16);\n\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n\n        uint32_t mb_load_size = 0;\n\n        mh_entry_addr = ldl_p(header+i+28);\n\n\n\n        if (mh_load_end_addr) {\n\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n\n        } else {\n\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n\n            mb_load_size = mb_kernel_size;\n\n        }\n\n\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n\n        uint32_t mh_width = ldl_p(header+i+36);\n\n        uint32_t mh_height = ldl_p(header+i+40);\n\n        uint32_t mh_depth = ldl_p(header+i+44); */\n\n\n\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n\n                 mb_load_size, mh_load_addr);\n\n\n\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n\n            fprintf(stderr, \"fread() failed\\n\");\n\n            exit(1);\n\n        }\n\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n\n        fclose(f);\n\n    }\n\n\n\n    mbs.mb_buf_phys = mh_load_addr;\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n\n\n\n    /* Calculate space for cmdlines and mb_mods */\n\n    mbs.mb_buf_size += strlen(kernel_filename) + 1;\n\n    mbs.mb_buf_size += strlen(kernel_cmdline) + 1;\n\n    if (initrd_filename) {\n\n        const char *r = initrd_filename;\n\n        mbs.mb_buf_size += strlen(r) + 1;\n\n        mbs.mb_mods_avail = 1;\n\n        while (*(r = get_opt_value(NULL, 0, r))) {\n\n           mbs.mb_mods_avail++;\n\n           r++;\n\n        }\n\n        mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n\n    }\n\n\n\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n\n\n\n    /* enlarge mb_buf to hold cmdlines and mb-info structs */\n\n    mbs.mb_buf          = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n    mbs.offset_cmdlines = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n\n\n\n    if (initrd_filename) {\n\n        char *next_initrd, not_last;\n\n\n\n        mbs.offset_mods = mbs.mb_buf_size;\n\n\n\n        do {\n\n            char *next_space;\n\n            int mb_mod_length;\n\n            uint32_t offs = mbs.mb_buf_size;\n\n\n\n            next_initrd = (char *)get_opt_value(NULL, 0, initrd_filename);\n\n            not_last = *next_initrd;\n\n            *next_initrd = '\\0';\n\n            /* if a space comes after the module filename, treat everything\n\n               after that as parameters */\n\n            target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename);\n\n            if ((next_space = strchr(initrd_filename, ' ')))\n\n                *next_space = '\\0';\n\n            mb_debug(\"multiboot loading module: %s\\n\", initrd_filename);\n\n            mb_mod_length = get_image_size(initrd_filename);\n\n            if (mb_mod_length < 0) {\n\n                fprintf(stderr, \"Failed to open file '%s'\\n\", initrd_filename);\n\n                exit(1);\n\n            }\n\n\n\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n            load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs);\n\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n\n\n\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n\n                     (char *)mbs.mb_buf + offs,\n\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n\n            initrd_filename = next_initrd+1;\n\n        } while (not_last);\n\n    }\n\n\n\n    /* Commandline support */\n\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n\n             kernel_filename, kernel_cmdline);\n\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n\n\n\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n\n\n\n    /* the kernel is where we want it to be now */\n\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n\n                                | MULTIBOOT_FLAGS_CMDLINE\n\n                                | MULTIBOOT_FLAGS_MODULES\n\n                                | MULTIBOOT_FLAGS_MMAP);\n\n    stl_p(bootinfo + MBI_MEM_LOWER,   640);\n\n    stl_p(bootinfo + MBI_MEM_UPPER,   (ram_size / 1024) - 1024);\n\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n\n\n\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n\n\n\n    /* save bootinfo off the stack */\n\n    mb_bootinfo_data = g_malloc(sizeof(bootinfo));\n\n    memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo));\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n\n                     mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n\n                     sizeof(bootinfo));\n\n\n\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n\n    option_rom[nb_option_roms].bootindex = 0;\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n", "idx": 8955, "substitutes": {"fw_cfg": ["fw_config", "framework_conf", "fw_conf", "framework_fg", "fw2cfg", "fw2config", "framework_cfg", "fw_fg", "fw2conf", "framework_config", "fw2fg"], "f": ["u", "fd", "fi", "fw", "buffer", "uf", "file", "p", "rf", "o", "fp", "cf", "d", "g", "m", "l", "fb", "j", "fn", "t", "feed", "v", "fr", "e", "b", "c", "fac", "h", "F", "w", "fs", "fc"], "kernel_filename": ["kernel_file", "kernel_location", "ernel_username", " kernel_directory", " kernel_file", "kernel_directory", "ernel_file", "kernel_username", "ernel_fn", "kernel_fn", " kernel_location", "ernel_filename"], "initrd_filename": ["initrnjfn", "initrn_filename", "initrdjfn", "initrdjdll", "initrdjfilename", "initrn_dll", "initrd_fn", "initrdffilename", "initrdjname", "initrnjfilename", "initrnjdll", "initrdfname", "initrdffn", "initrd_dll", "initrd_name", "initrdfdll", "initrn_name", "initrnjname", "initrn_fn"], "kernel_cmdline": ["kernel_paylines", "kernel_hostlines", "kernel_hostlist", "kernel_payLine", "kernel_cmdlines", "kernel_commandline", "kernel_hostLine", "kernel_cmdlist", "kernel_payline", "kernel_hostline", "kernel_paylist", "kernel_commandlist", "kernel_commandlines", "kernel_cmdLine", "kernel_commandLine"], "kernel_file_size": ["kernel_file_name", "kernel_data_name", "kernel_file_length", "kernel_file2name", "kernel_file2Size", "kernel_data_size", "kernel_file2length", "kernel_data_Size", "kernel_file_Size", "kernel_data_length", "kernel_file2size"], "header": ["len", "entry", "address", "config", "buffer", "prefix", "code", "padding", "layer", "format", "eh", "event", "list", "file", "meta", "p", "hash", "profile", "frame", "prot", "th", "block", "hawk", "Header", "hd", "hl", "drm", "ptr", "window", "handle", "hh", "term", "server", "index", "queue", "holder", "magic", "version", "n", "body", "info", "hea", "fr", "metadata", "line", "headers", "heading", "h", "title", "cmd", "tag", "er", "table", "peer", "tar", "head", "history", "offset", "dr"], "i": ["u", "ai", "I", "me", "io", "li", "ei", "uri", " I", "p", "point", "sim", "ind", "ui", "ip", "m", "ji", "ti", "ic", "cli", "in", "mi", "index", "j", "im", "ix", "n", "y", "t", "ci", "iu", "phi", "v", "zi", "info", "xi", "multi", "qi", "c", "gi", "bi", "di", "rest", "ij", "pi", "si", "slice", "it", "x", "batch", "ini", " ii", "oi", "hi", "yi", "ims", " j", "ii"], "mh_entry_addr": ["mh_add_offset", "dll", "mh_add_add", "func", "bl", "def", "ptr", "mh_entry_add", "mh_entry__addr", "mh_entry_address", "_", "cont", "mh_add_address", "new", "info", "mh_entry__offset", "mh_add_addr", "fat", "cmd", "mh_entry__add", "mh_entry__address", "mh_entry_offset"], "mh_load_addr": ["mh_load_add", "mh_loader_attr", "mh_load_attr", "mh_load_address", "mh_loader_add", "mh_loader_address", "mh_loader_addr"], "mb_kernel_size": ["mb_total_size", "mb_ernel_data", "mb_kernel_name", "mb_kernel__name", "mb_kernel__offset", "mb_ernel_size", "mb_kernel__SIZE", "mb_ernel_storage", "mb_ernel_SIZE", "mb_kernel_offset", "mb_total_offset", "mb_total_SIZE", "mb_kernel_storage", "mb_kernel_data", "mb_kernel__size", "mb_kernel_SIZE", "mb_total_name"], "mbs": ["ymbs", "ambs", " mbi", "hmws", "nbits", "nbs", "hmbs", "ymbits", "mfs", " mws", "emcs", "ymfs", "amubs", "hmbi", " mBS", "nfs", "mbi", "nts", "embs", " mfs", "nBS", " mvs", "mcs", " mcs", "emts", "mws", "mbits", "ymBS", "nvs", "amws", "mubs", "mvs", "emvs", " mubs", "mts", "ncs", "mBS", "ambi", " mbits", "hmubs", " mts"], "bootinfo": ["ootInfo", "businformation", "bootinformation", "ootfo", "businfo", "ootstat", "bootInfo", "busInfo", "bootdata", " bootdata", "buildinfo", "busstat", "busfo", "buildInfo", "buginformation", "bootfo", "bugInfo", "bootstat", "buginfo", "ootinformation", "ootinfo", " bootInfo", "buildstat", "buildinformation", "bugdata", " bootinformation", "ootdata", "buildfo"], "mb_bootinfo_data": ["mb_bootdata_data", "mb_bootinfo_size", "mb_bootdata_bytes", "mb_bootdata_table", "mb_bootinfo_bytes", "mb_bootinfo_table", "mb_bootdata_size"], "elf_entry": ["lf_name", "lf_ent", "elf2low", "elf2row", "lf_row", "lf_entry", "elf2name", "lf_list", "elf_ent", "lf_low", "elf_row", "elf2entry", "elf_list", "elf_name"], "elf_low": ["ELF_entry", "ELF_low", "elf___li", "ELF_small", "elf___low", "lf_diff", "elf_old", "elf_li", "lf_low", "elf_size", "lf_lower", "lf_li", "elf___diff", "lf_left", "ELF_size", "elf_lower", "elf_small", "ELF_left", "ELF_old", "elf_diff", "elf___high", "ELF_lo", "lf_high", "elf_lo", "elf_left"], "elf_high": ["elfachigh", "lf_high", "elf_large", "ELF_low", "ELF_hi", "elfachigher", "lf_hi", "elfaclow", "elf__low", "lf_higher", "elf_hi", "lf_low", "elf_higher", "ELF_high", "elf__no", "elf__higher", "elf__high", "elf_no", "elfacno", "lf_no", "lf_large"], "kernel_size": [" kernel64size", "kernel___speed", "kernel10speed", "ernel_speed", "kernel64ize", "ernel_index", "kernel_time", "kernel_ize", " kernel_ize", " kernel_Size", "kernel10index", "kernel10size", "kernel64Size", "kernel___index", "kernel10SIZE", "ernel_size", "kernel___SIZE", "kernel_speed", "ernel_SIZE", "kernelitySIZE", " kernel64ize", "kernelitytime", "kernelitylen", "kernel_SIZE", "kernel_Size", "kernel64size", " kernel_len", " kernel_time", "kernelitysize", "kernel___size", "kernel_len", " kernel_SIZE", " kernel64Size", "kernel_index"]}}
{"project": "FFmpeg", "commit_id": "73bb8f61d48dbf7237df2e9cacd037f12b84b00a", "target": 0, "func": "static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,\n\n                                          int *beta, int *tc, uint8_t *no_p,\n\n                                          uint8_t *no_q)\n\n{\n\n    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),\n\n                                beta, tc, no_p, no_q);\n\n}\n", "idx": 8963, "substitutes": {"pix": ["vixels", "ppixels", "pich", "cpix", "ppix", "jpix", "ppIX", "cpik", "cpixels", " pich", "jpich", "pIX", "pixt", "pik", "vixt", "vik", " pIX", "ppich", "jpIX", "vix", "cpixt", " pixt", "jpixels", " pixels", "pixels", " pik"], "stride": ["strue", " strride", "trl", "stides", "sprride", "stl", "stue", "sprides", "tride", "strride", " strl", "spride", "trides", "sprue", " strides", "trride", "strl", "stide", " strue", "strides"], "beta": ["ba", "\u03b2", "lambda", "buffer", "base", "boost", "fine", "mie", "late", "pixel", "nda", "cb", "confidence", "bs", "bet", "filter", "mu", "ta", "alpha", "margin", "t", "bps", "phi", "b", "bis", "Beta", "scale", "dust", "texture", "bil", "fee", "gam", "diff", "broad", "nb", "db", "pro"], "tc": ["tm", "td", "tf", "tt", "tty", "cus", " TC", "tk", "ec", "bc", "dc", "cs", "cb", "cc", " TTC", "cci", "ta", "ts", "currency", "mc", "t", "ci", "cas", "c", "TC", "cm", "cu", "fc", "sc", "tar", "tu", "cv", "uca", "dt", "tv", "tim"], "no_p": ["no_pp", "No_m", "no_pt", "no_m", "No_p", " no_pp", "no_P", " no_m", "No_P", "No_pt"], "no_q": [" no_b", "no_qs", "no___r", "no___qs", "no___p", "no___b", "No_p", "no_w", "no___q", "nojp", "nojq", "No_q", " no_r", "No_w", "no_r", "no_b", "No_qs", "no___w", "nojw", "nojqs"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, TCGLabel *l)\n\n{\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n", "idx": 8970, "substitutes": {"s": ["ms", "vs", "u", "ats", "sg", "hs", "o", "cs", "m", "session", "r", "se", "y", "t", "ties", "os", "w", "ims", "status", "source", "sql", "gs", "sts", "ex", "g", "ies", "sv", "ses", "xs", "bs", "als", "js", "ss", "ix", "sb", "sc", "z", "ls", "sq", "spec", "sl", "qs", "pt", "rs", "as", "f", "local", "es", "i", "ts", "n", "ctx", "sw", "ns", "ds", "sync", "eps", "q", "p", "ps", "south", "us", "is", "S", "its", "self", "v", "h", "stats", "fs", "x", "sys"], "ext": ["tf", "obj", "lt", "xp", "tx", "extra", "off", "at", "text", "external", "tex", "end", "enc", "p", "ec", "f", "ex", "ind", "fp", "g", "ref", "inter", "cb", "ab", "ptr", "ic", "txt", "r", "cont", "EXT", "test", "ix", "esc", "t", "ctx", "v", "e", "xt", "tmp", "cmd", "exec", "str", " Ext", "w", "temp", "x", "Ext", "out"], "c": [" cr", "cmp", "con", "abc", " cc", "ct", "enc", "loc", "p", "ec", "f", " ec", "cp", "cf", "d", "bc", "dc", "g", "cur", "cs", "tc", "m", "cb", "unc", "ic", "cc", "ce", "r", "chain", "cont", "n", "cation", "t", "ac", "rc", "lc", "v", "cache", "e", "gc", "fac", "uc", "can", "w", "cu", "fc", "sc", "z", "C", "co", "vc", "ca"], "a": ["ba", " sa", "na", "la", "u", "al", "part", "at", "ao", "as", "ar", "area", "p", "ach", "o", "an", "am", "m", "ae", "ata", "i", "ab", "ea", "ia", "index", "ta", "j", "alpha", "ma", "t", "ac", "sha", "v", "A", "sa", "sta", "aa", "oa", " A", "ca", "pa"], "b": ["ba", "be", "beta", "u", "bf", "ub", "base", "bp", "rb", "to", "p", "o", "f", "B", "d", "bc", "g", "m", "fb", "i", "ab", "cb", "bs", "r", "j", "n", "y", "t", "eb", "v", "e", "sb", "bi", "bb", "by", "nb", "ib", "db"], "b_const": [" b__conf", "b__con", "b__const", " b__const", "a_con", "b_cur", "a_cur", "b___con", "b__conf", "b_con", "b_conf", "a_const", " b_conf", "b___Const", "b___const", "b___cur", " b_Const", " b_con", "b_Const", "a_Const", " b__con"], "l": ["lb", "ml", "lin", "len", "lt", "la", "u", "sl", "nl", "li", "lang", "p", "o", "f", "lu", "lv", "ol", "g", "label", "m", "i", "le", "lp", "ln", "il", "rl", "r", "j", "kl", "n", "dl", "t", "tl", "jl", "lc", "v", "e", "h", "z", "ls", "el", "ll", "loc", "L"], "offset": ["range", "o", "slot", "location", "hl", "reference", "attribute", "amount", "row", "data", "needed", "t", "skip", "metadata", "payment", "slice", "size", "next", "frequency", "address", "path", "sp", "limit", "ptr", "top", "final", "Offset", "count", "e", "alias", "seed", "time", "shift", "id", "url", "buffer", "step", "point", "f", "error", "frame", "relative", "pos", "timeout", "balance", "trace", "onto", "index", "translation", "start", "loc", "angle", "len", "off", "entry", "pointer", "padding", "embed", "to", "p", "offs", "pad", "fp", "zero", "position", "online", "addr", "lag", "adjusted", "origin", "set", "usage", "length"], "need_cmp": ["needs_tmp", "needfulquick", "Need_cmp", "needs_cmp", "need__cmp", "Need_omp", "need_quick", "Need_comp", "need_cp", "need2comp", "need_conv", "needs_comp", "needfulcomp", "need_conn", "needfuldifferent", "need_different", "need__quick", "Need_conv", "neededtmp", "need2cmp", "need__different", "needs_omp", "need2omp", "Need_quick", "Need_cp", "need_omp", "neededcmp", "neededomp", "need2tmp", "neededcomp", "need_tmp", "Need_conn", "needfulcmp", "Need_different", "need_comp", "need__comp"]}}
{"project": "qemu", "commit_id": "3736cc5be31f0399999e37d8b28ca9a3ed0b4ccb", "target": 0, "func": "static int nbd_negotiate_options(NBDClient *client, Error **errp)\n\n{\n\n    uint32_t flags;\n\n    bool fixedNewstyle = false;\n\n\n\n    /* Client sends:\n\n        [ 0 ..   3]   client flags\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   Second NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n    */\n\n\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n\n        error_prepend(errp, \"read failed: \");\n\n        return -EIO;\n\n    }\n\n    trace_nbd_negotiate_options_flags();\n\n    be32_to_cpus(&flags);\n\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n\n        trace_nbd_negotiate_options_newstyle();\n\n        fixedNewstyle = true;\n\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n\n    }\n\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n\n        trace_nbd_negotiate_options_no_zeroes();\n\n        client->no_zeroes = true;\n\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n\n    }\n\n    if (flags != 0) {\n\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n\n        return -EIO;\n\n    }\n\n\n\n    while (1) {\n\n        int ret;\n\n        uint32_t option, length;\n\n        uint64_t magic;\n\n\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        magic = be64_to_cpu(magic);\n\n        trace_nbd_negotiate_options_check_magic(magic);\n\n        if (magic != NBD_OPTS_MAGIC) {\n\n            error_setg(errp, \"Bad magic received\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (nbd_read(client->ioc, &option,\n\n                     sizeof(option), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        option = be32_to_cpu(option);\n\n\n\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        length = be32_to_cpu(length);\n\n\n\n        trace_nbd_negotiate_options_check_option(option);\n\n        if (client->tlscreds &&\n\n            client->ioc == (QIOChannel *)client->sioc) {\n\n            QIOChannel *tioc;\n\n            if (!fixedNewstyle) {\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n            switch (option) {\n\n            case NBD_OPT_STARTTLS:\n\n                tioc = nbd_negotiate_handle_starttls(client, length, errp);\n\n                if (!tioc) {\n\n                    return -EIO;\n\n                }\n\n                object_unref(OBJECT(client->ioc));\n\n                client->ioc = QIO_CHANNEL(tioc);\n\n                break;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                /* No way to return an error to client, so drop connection */\n\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n\n                           option);\n\n                return -EINVAL;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_TLS_REQD,\n\n                                                 option, errp,\n\n                                                 \"Option 0x%\" PRIx32\n\n                                                 \"not permitted before TLS\",\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* Let the client keep trying, unless they asked to\n\n                 * quit. In this mode, we've already sent an error, so\n\n                 * we can't ack the abort.  */\n\n                if (option == NBD_OPT_ABORT) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            }\n\n        } else if (fixedNewstyle) {\n\n            switch (option) {\n\n            case NBD_OPT_LIST:\n\n                ret = nbd_negotiate_handle_list(client, length, errp);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_INVALID,\n\n                                                     option, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_POLICY,\n\n                                                     option, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_UNSUP,\n\n                                                 option, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32,\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 8988, "substitutes": {"client": ["command", "current", "entry", "net", "pc", "google", "con", "config", "call", "code", "wrapper", "channel", "network", "policy", "buffer", "ping", "api", "cell", "manager", "pattern", "Client", "complete", "application", "cl", "component", "secure", "admin", "service", "local", "request", "port", "window", "util", "cli", "server", "core", "connect", "attribute", "chain", "http", "connection", "handler", "conn", "plugin", "self", "remote", "cache", "close", "prefix", "lock", "c", "cmd", "query", "product", "master", "force", "context", "public", "app", "response", "patch", "store"], "errp": ["devping", "errpid", "rerd", "testp", "lrv", "derpy", "ezping", " errpa", "eorp", "rrp", "nerpoint", "lrpress", "erP", "rerpid", "errper", "reqp", "nerpad", "ezpg", "errpoint", "errps", "errn", " errP", "reqP", "errpa", "rrps", "errP", "errord", "lrpad", "derpress", "erping", "acerprogress", "nerv", "eorpa", "ezpa", "rrv", "arrp", "acerper", "rerpg", "errorpy", "addrP", "arrpa", "arrprogress", "herpg", "erpa", "errorpg", "derpid", "derpp", "ptrpa", "erp", "reqping", "ptrP", "arrper", "derd", "errping", "derp", "acerpa", "devpa", "eorprogress", "rrpress", "derpa", "lrp", "lrpid", "eorper", " errpp", "rrpad", "errpad", "addrp", "devP", "testpp", "errorps", "errprogress", " errping", "devp", "herpa", "errpp", "derps", "lrpoint", "errorping", "errorp", " errpid", "testpa", "nerp", "rerp", "errpress", "derP", "errpy", "rrpid", "errorpid", "rern", "herping", "errorn", " errps", "rerping", "dern", "herp", "derpg", "acerp", "derping", "errv", "testP", "addrpp", "errd", "ptrp", "ezp", "reqpa", "errpg", "addrping", "rrpoint", "lrps", "ptrpp", "rerpy"], "flags": ["ms", "marks", "weights", "cs", "bits", "heads", "values", "fps", "details", "fields", "reports", "fee", "options", "rates", "ports", "aps", "acts", "settings", "types", "atts", "phones", "opens", "FLAG", "args", "utils", "packages", "grades", "limits", "mates", "products", "fits", "finals", "vals", "faces", "features", "states", "Flags", "locks", "bugs", "goal", "lands", "ants", "words", "ints", "lines", "points", "orts", "xxx", "terms", "mask", "aints", "links", "ts", "styles", "ags", "levels", "tags", "properties", "amps", "comments", "alf", "flag", "ps", "cf", "members", "planes", "posts", "lag", "doms", "stats", "issues", "fs", "actions", "facts", "allows", "parts"], "ret": ["reset", " RET", "flag", "valid", "RET", "resp", "ry", "cat", "ruby", " alt", "usr", "alt", "mem", "try", "lag", "line", "val", "Ret", " resp", "lock", "opt", "result", "Return"], "option": ["command", "key", "op", "entry", "category", "prefix", "flag", "section", "feature", "order", "trial", "column", "event", "weight", "optional", "point", "field", "error", "argument", "pair", "slot", "volume", "variable", "dimension", "operation", "label", "condition", "timeout", "position", "example", "byte", "mod", "holder", "term", "package", "attribute", "bit", "index", "question", "connection", "ption", "Option", "action", "TION", "lock", "archive", "comment", "alias", "tag", "options", "opt", "table", "item", "offset"], "length": ["delay", "len", "display", "ll", "path", "prefix", "padding", "buffer", "text", "weight", "p", "var", "field", "error", "maximum", "volume", "size", "capacity", "location", "limit", "l", "block", "type", "sequence", "th", "position", "label", "window", "json", "ength", "loop", "term", "tail", "all", "row", "data", "total", "level", "test", "impl", "Length", "count", "line", "lock", "lv", "options", "full", "time", "angle", "duration", "partial", "loc", "offset", "style", "number"], "magic": ["icon", "vector", "notice", "spec", "pic", "status", "id", "config", "prefix", "cookie", "flag", "padding", "feature", "format", "mm", "policy", "code", "modified", "meta", "mini", "hash", "error", "mic", "volume", "slot", "size", "machine", "Magic", "type", "serial", "kind", "xxx", "session", "random", "mask", "holder", "script", "version", "header", "handler", "mobile", "interface", "mode", "zone", "info", "mag", "action", "generic", "metadata", "special", "tech", "mmm", "comment", "encrypted", "mid", "cmd", "origin", "eric", "tag", "alias", "bug", "module", "offset", "agic", "style"]}}
{"project": "qemu", "commit_id": "f21126df5f81797486eb3bd628da8e2ad5fae12e", "target": 1, "func": "static void pl181_fifo_run(pl181_state *s)\n\n{\n\n    uint32_t bits;\n\n    uint32_t value;\n\n    int n;\n\n    int is_read;\n\n\n\n    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;\n\n    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))\n\n            && !s->linux_hack) {\n\n        if (is_read) {\n\n            n = 0;\n\n            value = 0;\n\n            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {\n\n                value |= (uint32_t)sd_read_data(s->card) << (n * 8);\n\n                s->datacnt--;\n\n                n++;\n\n                if (n == 4) {\n\n                    pl181_fifo_push(s, value);\n\n                    n = 0;\n\n                    value = 0;\n\n                }\n\n            }\n\n            if (n != 0) {\n\n                pl181_fifo_push(s, value);\n\n            }\n\n        } else { /* write */\n\n            n = 0;\n\n            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        /* HACK: */\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        /* Update FIFO bits.  */\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n", "idx": 9025, "substitutes": {"s": ["ms", "events", "vs", "ats", "hs", "d", "cs", "m", "details", "r", "se", "y", "t", "sports", "ties", "os", "b", "w", "serv", "comm", "ims", "ports", "tests", "gs", "sts", "ex", "changes", "g", "ies", "sv", "args", "ses", "request", "bs", "services", "less", "js", "als", "ss", "conf", "sb", "ls", "state", "sq", "obj", "spec", "sl", "qs", "rs", "as", "es", "i", "terms", "store", "in", "ts", "sw", "results", "ns", "er", "ds", "comments", "sol", "p", "ps", "service", "so", "aws", "is", "series", "S", "its", "ssl", "v", "self", "search", "c", "bis", "h", "stats", "fs", "set", "sys", "parts"], "bits": ["abilities", "tops", "ports", "obs", "vs", "locks", "status", "units", "ats", "weights", "settings", "keys", "tests", "airs", "jobs", "changes", "dates", "points", "outs", "pins", "values", "fixes", "xs", "bs", "bytes", "mask", "bit", "details", "als", "its", "ts", " flags", "bps", "fields", "nets", "plugins", "cats", "limits", "tags", "ns", "flags", "stats", "issues", "options", "vals", "checks", "actions", "features", "ions", "ls", "tools", "ims", "versions", "ds", "items", "parts"], "value": ["format", "update", "end", "vp", "values", "package", "attribute", "data", "t", "VALUE", "expression", "result", "memory", "see", "size", "key", "power", "address", "status", "message", "VAL", "widget", "sv", "hello", "version", "test", "new", "scale", "initial", "ue", "number", "current", "buffer", "field", "unit", "f", "type", "sequence", "element", "function", "mem", "index", "description", "V", "vector", "entry", "sum", "p", "we", "variable", "this", "label", "position", "port", "save", "json", "bit", "total", "v", "cache", "val", "Value", "x", "max", "name", "length"], "n": ["len", "on", "next", "num", "na", "norm", "nan", "net", "nm", "nl", "gn", "network", "names", "inn", "p", "ng", "o", "an", "f", "ren", "ne", "nt", "ni", "nor", "d", "yn", "g", "m", "np", "note", "l", "i", "nn", "after", "mn", "en", "dn", "all", "ln", "j", "N", "node", "fn", "y", "t", "new", "tn", "v", "nr", "count", "cn", "c", "un", "sn", "ns", "ot", "nc", "w", "it", "x", "z", "nb", "no", "name", "pn", "number"], "is_read": ["ais_watch", "is_write", "is_mix", "Is_readable", "is___mix", "ais_readable", "is_watch", "is___write", "is___read", " is_reader", "isplacewrite", " is_mix", "is_readable", " is_write", "Is_current", "is___import", " is_import", "isplaceread", "isplaceimport", "ais_write", "ais_read", "is_reader", "Is_write", "isplacemix", "Is_read", "is_current", " is_readable", "is_import"], "datacnt": ["datainnt", "mutocent", "datacent", "catacno", "dtacnt", "mutacounter", "dtacentent", "dataicnc", "placnt", "datocot", "dtacentnc", "mutaconct", "placctn", "placcnc", "Datacct", "mutacent", "daticrowd", "datacNT", "datacentnc", "dataconct", "catacust", "datecnt", "mutocot", "datainNT", "datecnc", "Datacnc", "datecfg", "datainnc", "catainno", "datocent", "mutaconnt", "catacfg", "datactent", "daticnt", "datacentust", "dataconfg", "catainnc", "datacctn", "mutaconNT", "datacentent", "catacct", "mutacNT", "catainnt", "dataicot", "mutacct", "datcct", "catacnc", "datacno", "datacct", "datacentnt", "datocnt", "datactn", "datecno", "datocost", "dataconnt", "dtacentost", "datainno", "mutacnc", "dtacost", "dtacentnt", "datacounter", "dataconent", "dataconno", "datactnc", "datactnt", "datcnt", "daticnc", "mutaconounter", "catacentct", "mutacnt", "datainounter", "datacfg", "dataccct", "dataccnc", "datacrowd", "Datacnt", "dataconost", "dtacent", "datactot", "catainfg", "catacnt", "dataccnt", "dataconnc", "datacost", "mutacot", "datcust", "datainct", "placcnt", "catacentnc", "mutocnc", "placnc", "mutocnt", "datacust", "dtacnc", "catacentust", "dataconNT", "datacenttn", "Datacrowd", "dataicent", "datacentrowd", "datocnc", "dataicnt", "datacentct", "dataconounter", "placcct", "datcnc", "datacentost", "datacnc", "datacot", "daticct", "plactn", "catacentnt", "placct", "datainfg"]}}
{"project": "FFmpeg", "commit_id": "93c04e095dc37ebdab22174e88cfa91e24940866", "target": 0, "func": "static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)\n\n{\n\n    AMFDataType type;\n\n    AVStream *stream, *astream, *vstream;\n\n    AVIOContext *ioc;\n\n    int i;\n\n    // only needs to hold the string \"onMetaData\".\n\n    // Anything longer is something we don't want.\n\n    char buffer[11];\n\n\n\n    astream = NULL;\n\n    vstream = NULL;\n\n    ioc     = s->pb;\n\n\n\n    // first object needs to be \"onMetaData\" string\n\n    type = avio_r8(ioc);\n\n    if (type != AMF_DATA_TYPE_STRING ||\n\n        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)\n\n        return -1;\n\n\n\n    if (!strcmp(buffer, \"onTextData\"))\n\n        return 1;\n\n\n\n    if (strcmp(buffer, \"onMetaData\"))\n\n        return -1;\n\n\n\n    // find the streams now so that amf_parse_object doesn't need to do\n\n    // the lookup every time it is called.\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        stream = s->streams[i];\n\n        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n            astream = stream;\n\n        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            vstream = stream;\n\n    }\n\n\n\n    // parse the second object (we want a mixed array)\n\n    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)\n\n        return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 9036, "substitutes": {"s": ["sq", "spec", "sl", "qs", "source", "ats", "socket", "q", "rs", "hs", "p", "gs", "sts", "f", "ex", "ps", "g", "cs", "m", "ins", "sv", "ses", "es", "scl", "bs", "aws", "als", "js", "less", "S", "ss", "ts", "n", "se", "http", "series", "t", "v", "conf", "self", "os", "sb", "b", "e", "c", "h", "ns", "stats", "w", "fs", "sc", "x", "comm", "ls", "space", "ds", "sys"], "next_pos": [" next_POS", "next_POS", "next_Pos", " next_pc", " next_Pos", "nextrowloc", "nextrowoffset", " next_loc", "next_offset", "next_pc", "nextrowPos", " next_offset", "next_loc", "nextrowpos"], "type": ["key", "tr", "id", "typ", "what", "tp", "pe", "status", "ty", "at", "message", "format", "ping", "types", "role", "to", "area", "p", "o", "error", "TYPE", "m", " TYPE", "um", " kind", "kind", " family", "ver", "family", "index", "Type", "test", "t", "info", "ype", "tool", "class", "e", "rule", "oe", "tag", "tar", "time", "name", "TY", "size", "style", "mt"], "stream": ["send", "o", "open", "stack", "package", "row", "http", "data", "view", "bo", "iterator", "context", "display", "dd", "tr", "record", "socket", "source", "path", "message", "channel", "download", "ream", "follow", "loop", "video", "stage", "version", "test", "reflect", "temp", "pipe", "sc", "table", "batch", "driver", "time", "draw", "pod", "iver", "spec", "sl", "REAM", "sample", "form", "engine", "component", "Stream", "instance", "local", "window", "filter", "chain", "line", "transform", "host", "sw", "peer", "console", "sche", "sync", "wrapper", "embed", "pool", "track", "port", "cont", "v", "present", "archive", "runtime", "load", "length"], "astream": ["atore", " aststream", "asream", "astsem", "astingob", "aststream", "asrom", "estrom", "mastream", "astem", "asstream", "atream", "mastrom", "astsob", "mastore", "estroy", "astroy", "ASTiver", "asroy", "atrom", "astrom", "astore", "astsiver", "astsream", "estore", "atstream", "astsstream", " astroy", "astingream", " astob", "astsrom", " astiver", "astingstream", "eststream", "ASTream", "estream", "astob", " astem", "maststream", "ASTrom", "astiver", "ASTstream", " astrom", "astingem"], "vstream": ["vpstream", "vcserial", "cvcomponent", "avserial", "vcstream", "avream", "svloop", "vrdebug", "avstream", "avdebug", " vswitch", " vconst", "cvswitch", "vcontext", "vpdebug", "vcream", "avthread", "evpod", "avcontext", "avswitch", "evloop", "vswitch", "vpthread", "cvstream", "vream", "evstream", "vclean", "vrstream", "vpcontext", "vrthread", "cvloop", "vthread", " vclean", "vconst", "vcomponent", "vloop", "avconst", "avclean", " vream", "evcomponent", "svpod", "cvconst", "cvream", "vpod", "cvpod", "vrcontext", " vserial", "svstream", "vdebug", "vserial", "svcomponent", "vcclean"], "ioc": [" iroc", "diOC", " iot", " iocl", "dioc", "liod", "dioca", " iocon", "liocl", "piocl", "iroc", "pioco", "lioc", "iioc", "liot", "iod", "biroc", " ioci", " iod", "piod", "lioco", "liOC", "ioci", "biOC", "pioc", "piOC", "piocon", "piot", "iioca", "biog", "uioc", "dioci", "iioci", "uiOC", "iog", "ioca", " iog", "uiroc", "iocl", "ioco", "iocon", "bioc", " iOC", "iot", "iiOC", " ioco", "iOC", "liocon", "uiog", " ioca"], "i": [" m", "id", "u", "ai", "I", "me", "li", "uri", "ei", " I", "print", " di", "span", "ri", "sim", " li", "ind", "ui", "ip", "g", "m", "my", " pi", "ki", " multi", "ti", "ic", " si", "in", " ti", " init", "mi", "index", "cli", "j", " vi", "ix", "im", "y", "ci", "\u0438", "phi", "info", " mi", " j", "xi", "multi", "qi", "gu", "gi", "di", " index", "bi", "ij", "pi", "si", "it", "x", "batch", " err", " ii", " bi", "ini", " ni", "ji", " iter", " my", "ii"], "buffer": ["button", "command", "page", "available", "empty", "password", "extra", "never", "mb", "text", "message", "read", "source", "padding", "document", "uf", "buf", "reason", "iter", "size", "Buffer", "limit", "phrase", "fb", "sequence", "null", "position", "zero", "stack", "raw", "window", "byte", "bytes", "queue", "row", "data", "total", "header", "new", "check", "cache", "line", "b", "paste", "comment", "blank", "temp", "bb", "font", "table", "batch", "result", "buff", "memory", "context", "history", "database", "length", "binary", "bridge"]}}
{"project": "qemu", "commit_id": "2e2aa31674444b61e79536a90d63a90572e695c8", "target": 0, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n\n        ret = msi_init(dev, 0, 1, true, false, &err);\n\n        /* Any error other than -ENOTSUP(board's MSI support is broken)\n\n         * is a programming error */\n\n        assert(!ret || ret == -ENOTSUP);\n\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n\n            /* Can't satisfy user's explicit msi=on request, fail */\n\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n\n                    \"msi=off with this machine type.\\n\");\n\n            error_propagate(errp, err);\n\n            s->msi_in_use = false;\n\n            return;\n\n        } else if (ret) {\n\n            /* With msi=auto, we fall back to MSI off silently */\n\n            error_free(err);\n\n            s->msi_in_use = false;\n\n        } else {\n\n            s->msi_in_use = true;\n\n        }\n\n    }\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 9038, "substitutes": {"dev": ["usb", "dd", "tr", "spec", "off", "priv", "sky", "av", "pt", "device", "cam", "go", "ev", "det", "proc", "devices", "p", "ve", "buf", "var", "adv", "pad", "nt", " device", "vp", "def", "serial", "desc", "raw", "ver", "window", "handle", "mem", "md", "develop", "de", "test", "data", "ad", "scan", "ctx", "dem", "DEV", "conn", "v", "conf", "os", "env", "tech", "Dev", "cmd", "h", "Device", "des", "hw", "w", "er", "pi", "serv", "driver", "stick", "pack", "disk", "app", "sd", "pro", "draw", "ds", "out", "sys"], "errp": [" errps", "errorpa", " errpa", "diepa", "errorps", "rP", "errorP", "derps", "rpa", "dieP", "rp", "errorp", "errps", " errP", "derp", "diep", "errpa", "derP", "errP", "derpa"], "d": ["p", "o", "f", "g", "m", "i", "D", "dn", "r", "j", "data", "n", "ad", "t", "v", "e", "b", "c", "h", "di", "w", "db", "dm", "dh", "sd", "dt", "ds", "dr"], "s": ["ms", "vs", "ats", "hs", "func", "cs", "sing", "m", "session", "details", "se", "y", "t", "sports", "ties", "os", "b", "cmd", "sa", "times", "w", "serv", "comm", "sd", "ims", "source", "settings", "tests", "sp", "gs", "sts", "changes", "g", "sv", "args", "ses", "sam", "bs", "services", "less", "js", "ss", "test", "new", "conf", "sb", "des", "z", "ls", "params", "sq", "spec", "qs", "rs", "go", "as", "f", "scope", "l", "def", "es", "_", "ts", "n", "info", "sw", "results", "ns", "er", "ds", "shared", "p", "sim", "ps", "south", "so", "all", "aws", "is", "j", "S", "its", "ssl", "v", "self", "h", "stats", "fs", "res", "st", "set", "sys", "store"], "err": ["arr", "kr", "obj", "Error", "errors", "ch", "lr", "rb", "rs", "or", "erd", "ev", "ras", "resp", "p", "buf", "ec", "error", "ex", "iter", "aaa", " terr", "l", "ref", "attr", "rn", "gz", "mr", "rr", "txt", "usr", "Er", "r", "t", "erb", "cfg", "e", "eas", "der", "out", "str", "elt", "rt", "res", "er", "ocr", "it", "coord", "nil", "msg", "lex", "cr", "exc", "ers", "DERR", "sys"], "ret": ["arr", "len", "tr", "num", "success", "reset", " RET", "lit", "status", "got", "back", "flag", "det", "nz", "RET", "resp", "bool", " res", "f", "ry", "ne", "nt", "iter", "rev", "jp", "l", "ref", "fun", "mt", " Ret", "def", "ptr", " alt", "txt", "usr", "alt", "mem", "ter", "try", "cont", "ary", "j", "test", "sat", "t", "rem", "rets", "reg", "deg", "backed", "not", "val", "Ret", "cmd", "rt", "re", "verified", "elt", "res", "cert", "x", "result", "att", "rm", "gt", "locked", "ll", " fut", "out"]}}
{"project": "qemu", "commit_id": "1da41cc1c6c3efbe2ed47228068bd80dbdc49d0e", "target": 0, "func": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    int i;\n\n    GICState *s = KVM_ARM_GIC(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);\n\n\n\n    kgc->parent_realize(dev, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    i = s->num_irq - GIC_INTERNAL;\n\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n\n     * GPIO array layout is thus:\n\n     *  [0..N-1] SPIs\n\n     *  [N..N+31] PPIs for CPU 0\n\n     *  [N+32..N+63] PPIs for CPU 1\n\n     *   ...\n\n     */\n\n    i += (GIC_INTERNAL * s->num_cpu);\n\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n\n    /* We never use our outbound IRQ lines but provide them so that\n\n     * we maintain the same interface as the non-KVM GIC.\n\n     */\n\n    for (i = 0; i < s->num_cpu; i++) {\n\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n\n    }\n\n    /* Distributor */\n\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n\n                                   \"kvm-gic_dist\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    kvm_arm_register_device(&s->iomem,\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST);\n\n    /* CPU interface for current core. Unlike arm_gic, we don't\n\n     * provide the \"interface for core #N\" memory regions, because\n\n     * cores with a VGIC don't have those.\n\n     */\n\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n\n                                   \"kvm-gic_cpu\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n\n    kvm_arm_register_device(&s->cpuiomem[0],\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU);\n\n}\n", "idx": 9039, "substitutes": {"dev": ["dd", "priv", "sky", "av", "pt", "device", "cam", "ev", "proc", "home", "p", "ve", "buf", "adv", "pad", "nt", "d", "g", "def", "hd", "dis", "serial", "ver", "window", "mem", "de", "test", "data", "ad", "t", "scan", "dem", "DEV", "conn", "v", "os", "Dev", "cmd", "h", "Device", "des", "hw", "w", "serv", "disk", "debug", "sd", "pro", "ds", "out", "sys"], "errp": ["errorbp", "errorr", "errr", "nerpa", "errorpa", " errpa", "diebp", "errpb", "errpar", "lerpar", " errping", "dieping", "errbp", "diepar", " errpb", "errorping", "lerr", "lerpb", "lerp", "errorp", " errr", "errping", "nerp", "nerping", "diep", " errbp", "errpa", "diepb", " errpar", "nerr", "dier"], "i": ["ms", " m", "u", "print", "m", " pi", " x", "im", " t", "y", "t", "ci", "zi", " v", " mi", "gi", "iy", "pi", "oi", "hi", "ims", "asi", "I", "li", "uri", "init", "ri", "ex", "ki", "ti", " ti", "mi", "ix", " l", "xi", "multi", "qi", "si", "z", "batch", "id", "ai", "point", "f", "ui", "ip", "ic", "in", "index", "chain", "n", "mc", "\u0438", "phi", "remote", " p", "it", "ini", "ii", "fi", "me", " I", "to", " e", "p", "sim", " n", "client", "us", "is", "j", "iu", "c", "di", "bi", "x", " ii", " j"], "s": ["ms", "vs", "ats", "hs", "d", "sing", "cs", "m", "bits", "details", "r", "se", "t", "os", "has", "cmd", "w", "serv", "comm", "sd", "ims", "status", "gs", "sts", "changes", "g", "sv", "args", "ses", "sam", "services", "less", "js", "ss", "conf", "sb", "des", "sis", "ls", "params", "sq", "obj", "spec", "sl", "qs", "a", "rs", "as", "f", "l", "es", "store", "ts", "n", "sw", "results", "ns", "ds", "p", "ps", "aws", "is", "j", "S", "its", "self", "v", "c", "h", "stats", "fs", "st", "sys", "parts"], "sbd": ["sbb", "sbo", "csbo", "lsdb", "csbb", "jsbr", "asdb", "sbc", " sdb", "rsdd", "wsdd", "wsbd", "asbb", "csbd", "isbt", "isdd", "sbr", "rsbd", "lsbd", " sbc", "jsdd", "isbd", "lsbc", "jsbd", "sysbr", "wsbt", "lsbt", " sbo", "rsdb", "wsbr", "jsbc", "wsbc", "sbt", "sysbd", "sdb", "csdb", " sbb", "rsbc", " sbt", "isbc", "asbd", "rsbt", "asbo", "sysdd", "sdd", "sysbc"], "kgc": ["kgpc", "cmdcc", "kgl", " kgpc", "cmdc", "cmdl", "pkgcc", "workpc", "pkgci", "unkcc", "workl", " kgci", "pkgl", "unkc", "kgci", "cmdpc", "kgcc", " kgl", "pkgpc", "unkpc", "unkl", "pkgc", "workc", "workci"]}}
{"project": "FFmpeg", "commit_id": "ebea370dc3909aa182bae4c728b83516a904beca", "target": 0, "func": "static int write_fragments(struct Tracks *tracks, int start_index,\n\n                           AVIOContext *in)\n\n{\n\n    char dirname[100], filename[500];\n\n    int i, j;\n\n\n\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n\n        struct Track *track = tracks->tracks[i];\n\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n\n        mkdir(dirname, 0777);\n\n        for (j = 0; j < track->chunks; j++) {\n\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n\n                     dirname, type, track->offsets[j].time);\n\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n\n            write_fragment(filename, in);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 9047, "substitutes": {"tracks": ["shots", "needs", "amps", "events", "photos", "shows", "tr", "hands", "orders", "errors", "frames", "trak", "rs", "keys", "tests", "workers", "roads", "modules", "uploads", "phones", "files", "works", "docs", "points", "acks", "projects", "lists", "groups", "forms", "pps", "objects", "notes", "plays", "cycles", "stones", "series", "rows", "packages", "cases", "videos", "runs", "styles", "thumbnails", "fields", "sets", "storms", "metadata", "reads", "hops", "tags", "reports", "times", "stats", "tracking", "clips", "sections", "features", "steps", "maps", "jobs"], "start_index": [" start_slice", "startPointindex", "startPointlevel", "startPointvalue", "start_value", " start_value", "start_position", "start_level", " start_Index", "start_slice", " start_level", " start_position", "start_Index", "startPointposition"], "in": ["In", "doc", "inner", "tx", "inc", "current", "con", "pc", "config", "mm", "up", "or", "req", "file", "stream", "rec", "bin", "ex", "m", "ins", "cb", "gin", "IN", "window", "din", "ic", " din", "mc", "scan", "ac", "new", "conn", "ctx", "input", "nin", " out", "c", "rin", "cm", "isin", "serv", "context", "vin", "conv", "out", "inn"], "dirname": ["dirpath", "dirdir", " dirpath", "diskname", "DIRdir", "folderpath", "logdir", "relbase", "dirroot", " dirName", "directorypath", "folderName", "foldername", "directorybase", "diskpath", "reldir", "directoryroot", " dirdir", "DIRpath", "dirno", "logName", "diskroot", "DIRprefix", "relparent", "folderroot", " dirno", "DIRName", "diskName", "folderprefix", "dirparent", "directorydir", "dirNAME", "directoryNAME", "dirName", "directoryname", "directoryparent", "directoryno", "dirbase", "DIRname", "DIRparent", "dirprefix", "DIRbase", "logname", " dirprefix", "folderno", "relname", "directoryName", "logNAME", " dirNAME"], "filename": ["NAME", "lua", "png", "fd", "nm", "username", "source", "path", "prefix", "text", "seek", "file", "FN", "Filename", "f", "ren", "fp", "files", "location", "np", "ename", "ame", "unc", "println", "json", "txt", "jpg", "ames", "wav", "fn", "n", "figure", "directory", "jl", "journal", "metadata", "via", "fle", "tmp", "archive", "title", "csv", "result", "fil", "river", "description", "name", "writer", "length", "kj", "sys"], "i": ["ms", "ami", "id", "u", "ai", "I", "me", "ie", "li", " I", "iq", "ri", "point", "o", "sim", "ex", "ind", "ui", "name", "iat", "ip", "g", "instance", "m", "ori", "my", "inter", "ki", "ti", "ic", "us", "mi", "index", "is", "im", "ix", "n", "y", "ski", "iu", "ci", "\u0438", "phi", "zi", "info", "xi", "e", "qi", "multi", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "ini", " ii", "hi", "ji", "ims", "ii"], "j": ["key", "je", "obj", "bj", "next", "aj", "ja", "jump", "J", "jc", "at", "pt", "jo", "q", "req", "err", "k", "ng", "job", "f", "jit", "ind", "sim", "kid", "g", "jp", "m", "other", "note", "mn", "bs", "json", "jj", "index", "r", "js", "uj", "im", "br", "n", "y", "jet", "jl", "v", "nr", "bo", "fr", "b", "oj", "bot", "by", "it", "z", "ax", "att", "dj", "msg", "ji", "kj", "ij"], "track": ["tf", "tt", "tr", "toggle", "Track", "sync", "record", "kick", "train", "add", "trial", "order", "move", "match", "fire", "step", "complete", "ack", "rec", "form", "profile", "job", "task", "field", "report", "follow", "component", "mount", "process", "rack", "note", "trace", "tab", "save", "stack", "row", "trip", "race", "t", "skip", "sort", "check", "info", "ace", "search", "transform", "comment", "tmp", "play", "song", "tracking", "rule", "tag", "batch", "rank", "bar", "claim", "project", "find", "store"], "type": ["id", "typ", " Type", "pe", "ty", "buffer", "format", "types", "ack", "ime", "file", "error", " typ", "TYPE", " TYPE", "te", "kind", "ver", "Type", "test", " t", "y", "owner", "t", "info", "ype", "title", "tag", "color", "time", "pack", "rage", "name", "length", "style"]}}
{"project": "qemu", "commit_id": "31783203c3b74c11015b20194d57dada559940cf", "target": 0, "func": "char *qemu_find_file(int type, const char *name)\n\n{\n\n    int len;\n\n    const char *subdir;\n\n    char *buf;\n\n\n\n    /* If name contains path separators then try it as a straight path.  */\n\n    if ((strchr(name, '/') || strchr(name, '\\\\'))\n\n        && access(name, R_OK) == 0) {\n\n        return g_strdup(name);\n\n    }\n\n    switch (type) {\n\n    case QEMU_FILE_TYPE_BIOS:\n\n        subdir = \"\";\n\n        break;\n\n    case QEMU_FILE_TYPE_KEYMAP:\n\n        subdir = \"keymaps/\";\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n\n    buf = g_malloc0(len);\n\n    snprintf(buf, len, \"%s/%s%s\", data_dir, subdir, name);\n\n    if (access(buf, R_OK)) {\n\n        g_free(buf);\n\n        return NULL;\n\n    }\n\n    return buf;\n\n}\n", "idx": 9049, "substitutes": {"type": ["key", "op", "id", "typ", "what", "tp", "pe", "ty", "format", "ping", "types", "role", "range", "file", "area", "error", "size", "TYPE", "m", "year", "kind", "ver", "family", "rel", "Type", "test", "y", "like", "t", "info", "ype", "class", "lock", "otype", "start", "time", "state", "style"], "name": ["NAME", "key", "on", "run", "filename", "id", "tx", "nm", "part", "path", "prefix", "code", "read", "names", "base", "order", "news", "up", "named", "file", "nam", "error", "normal", "admin", "ame", "local", "null", "word", "parent", "raw", "lat", "none", "in", "rel", "data", "ma", "n", "root", "now", "version", "t", "one", "new", "old", "tree", "not", "dir", "search", "comment", "title", "str", "missing", "start", "Name", "x", "item", "time", "no", "size", "out"], "len": ["fin", " bl", "lt", "num", "lim", "cmp", "sl", "nl", "fl", "lan", "li", "Len", "end", " le", "compl", " ans", "sp", " Len", "bl", "wid", "ind", "resp", "ld", "nt", " n", "size", " clen", "gl", "l", "pos", "vec", "gz", "lf", " el", "le", "en", "lp", "mem", "ln", "cod", "coll", "n", "kl", "dl", "cap", " l", "gen", "val", "un", " dist", "comp", "elt", "str", " num", "z", "ls", "el", "ll", "loc", "offset", "length", " length", " mem"], "subdir": [" subpackage", "subdomain", "datadomain", "Subdir", "ubpackage", "dataDir", "subDir", "subparent", "ubDir", "ubdirectory", "datadir", "secpath", "Subparent", "datadirectory", "Subdomain", "ubdir", "subdiv", "SubDir", "subgroup", "ubparent", "superdirectory", "superDir", " subDir", "Subpath", "subpath", "secDir", " subdirectory", " subgroup", " subparent", "secdir", "Subpackage", "subpackage", "Subdiv", "subdirectory", " subdomain", "superdiv", "ubgroup", "Subgroup", "superdir", " subdiv", "secdirectory", "Subdirectory", " subpath"], "buf": ["doc", "cam", "alloc", "func", "uv", "pg", "Buffer", "cat", "block", "queue", "data", "cap", "b", "cmd", "str", "result", "cv", "arr", "read", "code", "uf", "rb", "ff", "bl", "bc", "bn", "bs", "txt", "gen", "temp", "Buff", "ob", "img", "nm", "buffer", "err", "var", "cp", "nt", "vec", "cur", "ref", "raw", "mem", "n", "ctx", "bed", "tmp", "broad", "db", "out", "ret", "fd", "text", "aka", "seq", "bin", "np", "cb", "port", "bytes", "br", "box", "rc", "v", "cache", "uffy", "buff", "msg", "wb"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "void term_flush(void)\n\n{\n\n}\n", "idx": 9055, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n", "idx": 9067, "substitutes": {"opaque": ["Opoid", "Opaque", "Oplay", "catoid", "opaques", "opque", "oplay", "opoid", "ipaques", "catacity", "Opque", " opaques", "cataque", " opoid", "OPaque", " oplay", "ipoid", "OPoid", " opacity", "ipacity", " opque", "OPlay", "OPque", "ipaque", "cataques", "opacity"], "addr": ["src", "address", "add", "alloc", "kt", "hash", "var", "ref", "attr", "ptr", "adr", "handle", "ix", "br", "ad", "cap", "ctx", "ctr", "eth", "start", "coord", "dh", "name", "loc", "offset", "state", "dr"], "size": ["align", "command", "len", "password", "num", "address", "sum", "message", "IZE", "weight", "Size", "SIZE", "type", "ize", "mem", "amount", "n", "body", "count", "shape", "fee", "name", "offset", "length", "params", "number"], "s": ["sq", "status", "a", "rs", "as", "hs", "p", "gs", "o", "sts", "ps", "d", "m", "cs", "ds", "es", "r", "is", "js", "S", "ss", "ts", "n", "its", "t", "ssl", "ops", "os", "sb", "b", "e", "c", "h", "ns", "stats", "w", "fs", "ls", "states", "state", "sys"]}}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         uint16_t *refcount_table,\n\n                         int64_t refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9072, "substitutes": {"bs": ["obs", "vs", "cks", "aos", "rs", "hs", "gs", "bles", "ps", "bc", "BS", "cs", "bits", "als", "js", "its", "ts", "ss", "bos", "bps", "lbs", "ubs", "ubis", "os", "sb", "b", "bis", "ns", "fs", "bb", "ls", "ds"], "res": ["ms", "cons", "ours", "pas", "resolution", "crit", "rs", "err", "ack", "resp", "rek", "sim", "Res", "gr", "scope", "def", "ins", "terms", "expr", "pres", "r", "RES", "rel", "details", "pers", "js", "als", "rem", "rc", "reg", "pr", "wcs", "ress", "red", "ro", "results", "re", "rest", "vals", "rss", "resh", "result", "comm", "rez", "response", "ret"], "refcount_table": ["refcode2tab", "refcount2total", "refcount2table", "refcount_tab", "refcode_table", "refcountingtable", "refcount_Table", "refcount2Table", "refcount_total", "refcode_tab", "refcountstable", "refcount2tab", "refcode2index", "refcode2total", "refcount_index", "refcountstab", "refcountingTable", "refcountingtab", "refcode_index", "refcount2index", "refcode_total", "refcode2table", "refcountsTable"], "refcount_table_size": ["refcount_tab_SIZE", "refcount_table_number", "refcount_list_SIZE", "refcount_tab_size", "refcount_table2SIZE", "refcount_list_number", "refcount_table_name", "refcount_table2size", "refcount_table_SIZE", "refcount_table2number", "refcount_tab_number", "refcount_list_size", "refcount_table2name", "refcount_tab_name"], "offset": ["align", "key", "shift", "off", "reset", "address", "et", "prefix", "buffer", "pointer", "padding", "base", "init", "end", "seek", "point", "o", "error", "slot", "first", "tile", "location", "original", "stop", "block", "ref", "pos", "oid", "position", "trace", "length", "window", "addr", "index", "attribute", "top", "row", "Offset", "count", "origin", "alias", "slice", "peer", "seed", "set"], "size": ["shift", "len", "empty", "small", "sum", "resolution", "message", "padding", "range", "height", "error", "south", "Size", "SIZE", "capacity", "dimension", "timeout", "type", "zero", "position", "window", "bytes", "ize", "storage", "scroll", "total", "state", "count", "since", "shape", "scale", "sn", "z", "space", "sized", "name", "gravity", "length", "style", "number"], "s": ["abilities", "sq", "sl", "qs", "a", "ats", "eps", "rs", "hs", "sp", "gs", "sts", "p", "bes", "ps", "south", "g", "cs", "sv", "ses", "sam", "xs", "aws", "als", "js", "less", "S", "ss", "ts", "its", "http", "is", "os", "sb", "b", "c", "bis", "h", "sn", "ns", "stats", "fs", "comm", "ls", "ims", "ds"], "start": ["shift", "art", "arts", "next", "id", "op", "use", "part", "entry", "pointer", "base", "init", "end", "step", "begin", "wind", "seek", "range", "first", "iter", " Start", "position", "ish", "index", "top", "row", "ist", "started", "root", "check", "count", "info", "from", " starting", "pre", "origin", "Start", "st", "it", "rank", "get", "set", "time", "head", "max", "before", "starting", "store"], "last": ["best", "next", "show", "base", "end", "most", "prev", "bottom", "first", "stable", "largest", "stop", "l", "scope", "local", "after", "length", "Last", "tail", "las", "total", "final", "latest", "old", "reverse", "count", "good", "since", "ast", "close", "query", "est", "rest", "highest", "st", "table", "full", "max", "nd", "vol"], "cluster_offset": ["clust_Offset", "clique_offset", "cluster_value", "clusters_Offset", "cluster___offset", "cluster_size", "clique_Offset", "clique_type", "cluster___size", "clust_pointer", "clist_length", "clusterptOffset", "cluster_Offset", "cliquepttype", "cluster__offset", "clusterixoffset", "cluster_start", "clusterptoffset", "clique_point", "cliqueptoffset", "clocker_start", "cluster_pointer", "cluster_length", "cliqueptOffset", "cluster_address", "clust_size", "clust_addr", "clist_shift", "cluster___length", "cluster_index", "clocker_value", "clist_point", "cluster__pointer", "clist_offset", "cluster_addr", "clust_offset", "cluster___addr", "clocker_point", "cliqueptpoint", "cluster__address", "clusters_point", "cluster_type", "clust_point", "clusters_offset", "clusterixstart", "clust_index", "cluster___shift", "clusterixpoint", "clocker_offset", "clusterpttype", "cluster_shift", "cluster___point", "cluster_point", "clust_address", "cluster___Offset", "clusterptpoint", "clusterixvalue"], "k": ["kr", "key", "ck", "acc", "ko", "u", "K", "q", "ak", "wk", "ack", "kan", "p", "kid", "ku", "g", "m", "isk", "i", "kind", "ka", "unk", "j", "kl", "n", "ikk", "kn", "ac", "v", "ik", "mk", "uk", "c", "ke", "kh", "kw", "ks", "z", "km", "ek", "kj", "sk", "kk"], "check_errors": ["check_error", "checkingrors", "check_results", "checkingerror", "read_errors", "read_error", "check_rors", "checkingresults", "read_rors", "checkingerrors", "read_results"], "corruptions": ["corritations", "corredions", "critions", "crition", "corredion", "cruptions", "critories", "cruptories", "corritions", "corruptations", "corression", "corruptories", "corredations", "corressions", "corressations", "corressories", "corrition", "corritories", "critations", "cruptations", "cruption", "corredories", "corruption"]}}
{"project": "qemu", "commit_id": "f140e3000371e67ff4e00df3213e2d576d9c91be", "target": 1, "func": "static int nbd_co_request(BlockDriverState *bs,\n\n                          NBDRequest *request,\n\n                          QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    if (qiov) {\n\n        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);\n\n        assert(request->len == iov_size(qiov->iov, qiov->niov));\n\n    } else {\n\n        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);\n\n    }\n\n    ret = nbd_co_send_request(bs, request,\n\n                              request->type == NBD_CMD_WRITE ? qiov : NULL);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nbd_co_receive_reply(client, request->handle,\n\n                                request->type == NBD_CMD_READ ? qiov : NULL);\n\n}\n", "idx": 9087, "substitutes": {"bs": ["obs", "vs", "qs", "cus", "socket", "aos", "bp", "bid", "gs", "bl", "sts", "ps", "bc", "BS", "cs", "boxes", "bm", "bits", "cb", "ses", "bn", "cli", "is", "js", "ss", "its", "bos", "pb", "ts", "lbs", "bps", "sb", "b", "bis", "bh", "ns", "bi", "fs", "ks", "bb", "blog", "ls", "bt", "hz", "ds", "sys"], "request": ["command", "reset", "each", "config", "post", "report", "enter", "first", "open", "word", "session", "reference", "package", "attribute", "create", "question", "import", "claim", "art", "run", "use", "call", "record", "message", "document", "delete", "object", "rate", "hello", "server", "version", "new", "setup", "QUEST", "rule", "xml", "get", "item", "pack", "initial", "work", "current", "require", "buffer", "req", "form", "point", "frame", "reason", "worker", "instance", "push", "condition", "local", "raw", "index", "header", "now", "execute", "forward", "transform", "quest", "Request", "begin", "complete", "list", "pair", "this", "phrase", "position", "have", "root", "change", "query", "re", "requ", "response", "store"], "qiov": ["questilo", "sqiev", "qualiev", "qvoice", "eqkov", "qivic", "oxiop", "qkov", "quiop", " qiv", "eqilo", "quvoice", "qualiov", "quuj", "qunox", " qnox", "eqiop", "sqiv", "oxuj", "qualnox", "sqkov", "qqiop", "qiev", "qilo", " qilo", "qiop", " quj", "qumom", "qiv", "qukov", "oxivic", "sqiov", "qualmom", "quivic", " qivic", "questiov", " qkov", "oxiov", "qqiv", "qualiop", "qqmom", "qqiov", " qiev", "qqiev", "quiv", " qvoice", "qqkov", "quilo", "questvoice", "questkov", "quiev", "eqiov", "qnox", "quiov", "quj", "qmom", " qiop", "qualiv", "qualivic"], "client": ["lib", "net", "con", "pc", "at", "bolt", "api", "cell", "web", "manager", "Client", "cl", "correct", "local", "null", "parent", "window", "util", "session", "ic", "cli", "server", "bound", "browser", "connection", "box", "handler", "ctx", "ac", "conn", "remote", "cache", "c", "sc", "co", "app", "response", "ca", "store"], "ret": ["arr", "tf", "len", "lt", "tr", "num", "reset", "status", "back", "code", "err", "print", "det", "nz", "RET", "nt", "rev", "ref", "fun", "pret", "mt", " Ret", "def", " alt", "en", "usr", "alt", "ord", "ter", "r", "cont", "ext", "t", "rem", "rets", "reg", "deg", "arg", "val", "Ret", "ctr", "red", "rt", "re", "elt", "str", "res", "cert", "rm", "result", "unt", "gt", "no", "ll", "ft", "out"]}}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n", "idx": 9091, "substitutes": {"ctx": ["jac", "tm", "ck", "obj", "xp", "tx", "cmp", "pc", "prefix", "crit", "this", " cx", "req", "ct", "kt", "sp", "Context", "cp", "nt", "cf", "xc", "bc", "dc", "iat", "jp", "tc", "pkg", "wx", "act", "np", "grad", "cb", "ctl", "xs", "window", "cc", "ka", "handle", "cci", "mem", "qt", "rx", "mc", "ci", "conn", "wd", "cas", "cfg", "gc", "ctr", "cn", "tmp", "cmd", "via", "bh", "kb", "rt", "hw", "nc", "cm", "kw", "voc", "cu", "sc", "batch", "context", "cv", "history", "ca", "ij"], "insn": ["rsnin", " inssn", "itsnm", "psl", "tspn", "rsns", "csns", "cssn", "insnin", "insgn", "psns", "insnm", "actsns", "rsl", "itsgn", "pinsl", "risn", "actsn", " insnm", "rssn", "rsn", "bessn", "linss", "psn", "rissn", "bess", "csgn", "linssn", "itssn", "outsgn", "itsn", "rispn", "actsnin", "tssn", "bespn", "pinsns", "inspn", "risnm", "itsns", "outsn", "linsn", "itspn", "outssn", "linspn", "tsn", " inspn", "inns", "actssn", "pinssn", "besn", "innin", "outsns", "tss", "inss", "pssn", "insns", "insl", "csn", "pinsn", "inssn", "inn"], "di": ["ai", "fi", "li", "ei", "ani", "det", "ni", "da", "dc", "chi", "Di", " Di", "ki", "dis", "ti", "i", "cci", "mi", "idi", "ci", "DI", "zi", "phi", "xi", "gi", "bi", "si", "pi", "adi", "ali", "ini", "yi", "asi", "ii"], "tcg_r1": ["tcg__r2", "tcg_ron", "tcg_er1", "tcg__r1", "tcg_lOne", "tcg_l0", "tcg_h4", "tcg_l2", "tcg_g2", "tcg_erOne", "tcg_r0", "tcg_grone", "tcg_mon", "tcg_r01", "tcg_gron", "tcg_l01", "tcg_m2", "tcg_p0", "tcg_gr2", "tcg_r4", "tcg_h1", "tcg_rOne", "tcg_er01", "tcg_p4", "tcg_h2", "tcg__l01", "tcg_gr1", "tcg_mone", "tcg_m1", "tcg__r01", "tcg_er2", "tcg_l1", "tcg_lone", "tcg_g01", "tcg_p2", "tcg__l2", "tcg_h0", "tcg_lon", "tcg__rOne", "tcg_p1", "tcg_l4", "tcg_rone", "tcg__lOne", "tcg_g1", "tcg_gOne", "tcg__l1"], "tcg_r2": ["tcg_Rtwo", "tcg_Rpl", "tcg_m4", "tcg_l0", "tcg_t02", "tcg_l2", "tcg_r02", "tcg_r0", "tcg_wpl", "tcg_g2", "tcg_R0", "tcg_t1", "tcg_R1", "tcg_w0", "tcg_gpl", "tcg_m2", "tcg_t0", "tcg_R2", "tcg_r4", "tcg_R4", "tcg_err0", "tcg_m1", "tcg_rpl", "tcg_l02", "tcg_w2", "tcg_wtwo", "tcg_l1", "tcg_err2", "tcg_m0", "tcg_g0", "tcg_rtwo", "tcg_gtwo", "tcg_t2", "tcg_err02", "tcg_err1", "tcg_l4"], "ret": ["tr", "lt", " RET", "status", "std", "err", "det", "nz", "RET", "RT", "resp", "ry", "ne", "nt", "rev", "ref", " Ret", "mt", "pret", "def", "vt", "txt", "ext", "alt", "r", "try", "t", "rets", "tn", "val", "Ret", "rt", "re", "des", "elt", "res", "rm", "it", "result", "gt", "bt", "ll", "dt", "ft", "out"]}}
{"project": "FFmpeg", "commit_id": "f27b22b4974c740f4c7b4140a793cac196179266", "target": 0, "func": "static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,\n\n                                            uint8_t *src_cb, uint8_t *src_cr,\n\n                                            int linesize, int uvlinesize,\n\n                                            int xchg, int chroma444,\n\n                                            int simple, int pixel_shift)\n\n{\n\n    int deblock_topleft;\n\n    int deblock_top;\n\n    int top_idx = 1;\n\n    uint8_t *top_border_m1;\n\n    uint8_t *top_border;\n\n\n\n    if (!simple && FRAME_MBAFF(h)) {\n\n        if (h->mb_y & 1) {\n\n            if (!MB_MBAFF(h))\n\n                return;\n\n        } else {\n\n            top_idx = MB_MBAFF(h) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    if (h->deblocking_filter == 2) {\n\n        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;\n\n        deblock_top     = h->top_type;\n\n    } else {\n\n        deblock_topleft = (h->mb_x > 0);\n\n        deblock_top     = (h->mb_y > !!MB_FIELD(h));\n\n    }\n\n\n\n    src_y  -= linesize   + 1 + pixel_shift;\n\n    src_cb -= uvlinesize + 1 + pixel_shift;\n\n    src_cr -= uvlinesize + 1 + pixel_shift;\n\n\n\n    top_border_m1 = h->top_borders[top_idx][h->mb_x - 1];\n\n    top_border    = h->top_borders[top_idx][h->mb_x];\n\n\n\n#define XCHG(a, b, xchg)                        \\\n\n    if (pixel_shift) {                          \\\n\n        if (xchg) {                             \\\n\n            AV_SWAP64(b + 0, a + 0);            \\\n\n            AV_SWAP64(b + 8, a + 8);            \\\n\n        } else {                                \\\n\n            AV_COPY128(b, a);                   \\\n\n        }                                       \\\n\n    } else if (xchg)                            \\\n\n        AV_SWAP64(b, a);                        \\\n\n    else                                        \\\n\n        AV_COPY64(b, a);\n\n\n\n    if (deblock_top) {\n\n        if (deblock_topleft) {\n\n            XCHG(top_border_m1 + (8 << pixel_shift),\n\n                 src_y - (7 << pixel_shift), 1);\n\n        }\n\n        XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg);\n\n        XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1);\n\n        if (h->mb_x + 1 < h->mb_width) {\n\n            XCHG(h->top_borders[top_idx][h->mb_x + 1],\n\n                 src_y + (17 << pixel_shift), 1);\n\n        }\n\n    }\n\n    if (simple || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n\n        if (chroma444) {\n\n            if (deblock_topleft) {\n\n                XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n            }\n\n            XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);\n\n            XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);\n\n            if (h->mb_x + 1 < h->mb_width) {\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);\n\n            }\n\n        } else {\n\n            if (deblock_top) {\n\n                if (deblock_topleft) {\n\n                    XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n                }\n\n                XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);\n\n                XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9094, "substitutes": {"h": ["hhh", "hal", "he", "H", "hm", "ah", "ph", "hr", "obj", "each", "a", "ch", "pp", "q", "eh", "here", "k", "hs", "p", "hash", "o", "dev", "f", "th", "g", "m", "l", "np", "hd", "hl", "ho", "oh", "handle", "hh", "mem", "hp", "http", "j", "header", "t", "v", "zh", "info", "uh", "rh", "cache", "host", "b", "c", "sh", "bh", "kh", "hw", "w", "ih", "it", "z", "comm", "hi", "dh", "history", "hz", "ht", "dr"], "src_y": ["source_Y", "src__xy", "src_xy", " src_xy", "src___yy", "src__Y", "src_Y", "source_y", "src__y", "src___ey", "source_yy", "src_yy", "src___Y", " src_yy", "src_ey", "src__yy", "src___y", "src__ey", " src_Y", "source_ey"], "src_cb": ["src_gb", "src_xy", " src_xy", "source_cf", " src_db", "source_gb", "src___rb", "src___db", "src___xy", " src_rb", "src_cf", "source_rb", "src___cb", "src_db", "source_cb", "src_rb"], "src_cr": ["rc_r", "source_ctr", "src__rc", "rc__rx", "src_rx", "src_rc", "rc__rc", "source_vr", "src__cr", "rc_rx", "rc_cr", "src_r", "src__r", "src_ctr", "rc__r", "rc_rc", "src__rx", "source_cb", "source_cr", "rc__cr", "src_vr"], "linesize": ["linksize", "pagesze", "linesime", "facesime", "inesize", "inesizer", " linesizer", "insize", "linksIZE", "linksized", "pagesime", "linesze", "insIZE", "pagesize", "insized", "pagesizer", "linesizer", "facesze", "facesize", "facesizer", "insizer", "inesIZE", "inesized", " linesze", "linesIZE", " linesime", "linksizer", "linesized"], "uvlinesize": ["uvlinesite", "uvvalszie", "UVpointsize", "uzlinesize", "uvlocksite", "uvringsizer", "UVlinesize", "uzlinesizer", "uzlinksize", "uvblocksized", "uvpointssize", "uvblocksite", "uzlinksizer", "uvvalsize", "uzlinksization", "UVblocksize", "UVlinesized", "uvworkssize", "uvlineize", "uvlinesized", "uvlsization", "uvworkszie", "UVlinesite", "UVlinesizer", "uvlinesizer", "uvlocksizer", "uvblocksizer", "uvringsite", "uvpointsize", "UVlineszie", "UVpointssize", "uvpointsze", "uvlsizer", "uvlinesization", "uzlinesization", "UVblocksizer", "uvblocksize", "uvlinesze", "uvlineze", "uvlinksization", "uvworksize", "uvlinksizer", "UVpointszie", "uvlineszie", "uvlszie", "uvpointszie", "uvlinessize", "uvlocksized", "uzlinkszie", "uvvalsization", "uvlinkszie", "UVlinesze", "UVpointsze", "uvlocksize", "UVlinessize", "UVblocksite", "uzlineszie", "uvlinezie", "uvringsize", "uvlsize", "uvlinksize", "uvringsized", "uvvalsizer", "uvworksze", "UVblocksized"], "xchg": ["maxcheg", " xChgg", " xChg", "xchng", "xchege", " xChgd", "xchgd", "xChgg", "xchegg", "xachg", " xchgd", "xachyg", "xchngd", "xchngg", "xchge", " xChgm", "xcheg", "xhyg", "xachgg", "xchegm", "xchyg", "xachge", "xChgd", "xChgm", "maxchge", "maxchyg", "maxchgg", " xchgm", "xhge", "xchgg", " xchgg", "xChg", "xhg", "maxchg", "xchegd", "xcheyg", "maxchegg", "xchngm", "xhgg", "xchgm", "maxcheyg", "maxchege"], "chroma444": ["chromaa95", "chromiue", "chromoauses", "chromiuses", "chromaauses", "chroma3", "chromi95", "loraue", "chromaa3", "chromoaue", "chromoa95", "loraauses", "chromaaue", "loraa95", "lora3", "loraaue", "chromoa3", "lora95", "chromaue", "lorauses", "chroma95", "chromauses", "chromi3", "loraa3"], "simple": ["solid", "spread", "clear", "small", "empty", "id", "min", "quick", "slow", "Simple", "valid", "thin", "same", "sim", "quiet", "standard", "complex", "normal", "classic", "common", "ply", "easy", "dirty", "details", "less", "friendly", "mode", "Basic", "minute", "special", "basic", "lower", "mid", "low", "single", "tiny", "strip", "full", "only", "partial"], "pixel_shift": [" pixel_size", "chip_hift", "pixel_vector", "pixel_hift", " pixel_diff", "border_vector", "pixel_offset", "cache67pull", "cache67shift", "pixel8offset", "pixel8diff", "border_transfer", "pixel_diff", "pixel_transfer", "pixel67pull", "cache_shift", "pixel2shift", "border_shift", "pixel2diff", "cache_sh", "pixel8size", "pixel_sh", "pixel2size", "pixel2offset", "pixel_size", "pixel67sh", "pixel8shift", "chip_shift", "pixel_history", " pixel_offset", "chip_history", "cache_pull", "cache67sh", "pixel67shift", "pixel_pull"], "deblock_topleft": ["deblock_Toplevel", "deblock_toekt", "deblock_Teloist", "deblock_Topleist", "deblock_topleaft", "deblock_topleist", "deblock_toovel", "deblock_Tplevel", "deblock_toeft", "deblock_todoreest", "deblock_tpleest", "deblock_tpleist", "deblock_tolekt", "deblock_stopleaft", "deblock_stoplekt", "deblock_steloaft", "deblock_Topleff", "deblock_toeleaf", "deblock_tpleft", "deblock_tpleff", "deblock_toleleaf", "deblock_tplevel", "deblock_stopleleaf", "deblock_tooct", "deblock_tooist", "deblock_teloleaf", "deblock_toplect", "deblock_Tplect", "deblock_teloct", "deblock_toplekt", "deblock_topleff", "deblock_Teloft", "deblock_teloff", "deblock_totheist", "deblock_stelokt", "deblock_Topleft", "deblock_Totheest", "deblock_telokt", "deblock_tooft", "deblock_teloft", "deblock_Telovel", "deblock_Tpleist", "deblock_todoreist", "deblock_tothevel", "deblock_totheft", "deblock_teloist", "deblock_stopleft", "deblock_steloleaf", "deblock_tplect", "deblock_toplevel", "deblock_Totheft", "deblock_Toplect", "deblock_topleleaf", "deblock_Tpleft", "deblock_Totheist", "deblock_totheest", "deblock_Teloff", "deblock_totheff", "deblock_teloaft", "deblock_telovel", "deblock_toleaft", "deblock_toeaft", "deblock_steloft", "deblock_toleft", "deblock_todoreft", "deblock_todorevel", "deblock_Tothevel", "deblock_topleest", "deblock_Topleest"], "deblock_top": ["debli_high", "deblocked_master", "debload_parent", "debock_top", "deblock_target", "debload_enabled", "deblock___target", "deblock_TOP", "deblock_enabled", "deblock_pop", "deblock_Top", "debock___Top", "debload_pop", "debock___top", "debli_top", "deblock_bottom", "debock___target", "debload_top", "deblockertype", "debload___enabled", "debock_TOP", "deblocked_tops", "deblock___pop", "deblock___parent", "deblock_tops", "deblock_type", "debload___top", "deblockertop", "debock_target", "debock_Top", "deblock___TOP", "deblockerhigh", "deblockerbottom", "deblock___Top", "deblock___enabled", "deblock___top", "deblock_master", "debload___parent", "debload___pop", "debock___TOP", "deblocked_top", "deblocked_TOP", "deblock_high", "debli_type", "debli_bottom", "deblock_parent"], "top_border_m1": ["top_border_l2", "top_border_v7", "top_border_M1", "top_border_v1", "top_border_m3", "top_border_l1", "top_border_M2", "top_border_l7", "top_border_p3", "top_border_l3", "top_border_M3", "top_border_p1", "top_border_l0", "top_border_p2", "top_border_m7", "top_border_m0", "top_border_v0", "top_border_p7", "top_border_v3", "top_border_v2", "top_border_M0", "top_border_m2"], "top_border": [" top___buffer", "topopfilter", "first_cross", "top_filter", "topopcross", "top___border", " top_Border", "firstopfilter", "top___buffer", "top_prefix", " top___border", "first_filter", " top_buffer", "top___Border", "top_bridge", "first_border", " top___Border", "topopborder", "first_bridge", " top_prefix", "top___prefix", "firstopcross", "top_Border", "firstopbridge", "top_cross", "top_buffer", " top___prefix", "topopbridge", "firstopborder"]}}
{"project": "FFmpeg", "commit_id": "c56e71309ec1a585ed4d4dc11ae0ba3ca7d19618", "target": 1, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint8_t *buf, int linesize)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len, height;\n\n    const uint8_t *ptr;\n\n    /* image block */\n\n\n\n    bytestream_put_byte(bytestream, 0x2c);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, avctx->width);\n\n    bytestream_put_le16(bytestream, avctx->height);\n\n    bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    /* no local clut */\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf;\n\n    for (height = avctx->height; height--;) {\n\n        len += ff_lzw_encode(s->lzw, ptr, avctx->width);\n\n        ptr += linesize;\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    bytestream_put_byte(bytestream, 0x3b);\n\n    return 0;\n\n}\n", "idx": 9095, "substitutes": {"avctx": [" avctl", "devcontext", "afpkg", "Avcontext", "abcmp", "abcmd", " avcontext", "ajobj", "avepkg", " avcmd", "ajjac", "avctl", "avecfg", "aftx", " avobj", "abtx", "avecontext", "avercmp", " avcb", "afctx", "Avpkg", "devctx", "abpkg", "averca", " avpkg", "avercb", "wavctx", "avcb", "avcmd", "abctx", "avcontext", "Avctx", "avecmd", "aveobj", "avercontext", " avca", " avtx", " avcmp", "avca", "ajctx", "avectx", " avcfg", "Avcfg", "ajtx", "avecb", "devctl", "averctx", "afcontext", "ajctl", "avcmp", "avobj", "wavcmp", "wavcontext", " avjac", "abcontext", "avcfg", "avpkg", "ajcontext", "ajcmp", "avtx", "devcmp", "wavcb", "avjac", "aveca", "avetx", "avejac"], "bytestream": ["byvestrown", "byportorage", "bytestreen", "byestorage", "byvestorage", "ytestagram", "lytestream", "bysteststream", " byteststream", "bygestream", "trytestingreen", "byestREAM", "bytestod", "byserverream", "bytestrar", "byvestream", "byparentroy", "byportream", "bygestep", "bygestram", "byseedrar", "byterream", " byestord", "byvestep", " bytestram", "byscriptagram", "thistestrog", "trytestingream", "lysettREAM", "bytestingreen", "bysettdem", "tryteststream", "bysportstream", "lytestREAM", "ingtestrog", "Bytestep", "Bytestream", "trytestob", "bysettrown", "ingtestingream", "byveststream", "bygestrar", "bygestreen", "bysettep", "bysettream", "byestord", "byparentream", " byestriber", "byestrar", " bytestorage", "Byteststream", "lysettream", "thisparentroy", "bytestord", "bytempream", "bytestorage", "Bygestream", "byportstream", "byestrown", "ingteststream", "bytestriber", "bygeststream", "bytestingord", "byestagram", "Byestep", "byeststream", "bystestREAM", "trytestreen", "bysettroy", " bytestod", "byfreshream", "bytestagram", "byportrog", "byterrum", "byparentep", "ytestream", "ingtestrum", " bygeststream", "Byestream", " bygestream", "bysettREAM", "byserverstream", "bygestrown", "byparentrog", "lytestep", "byparentstream", "byterob", "bytestsord", "bytestingep", "ytestrum", "byterstream", "lytestrown", "yterrum", "byestod", "byteststream", "bytestrown", "Bygestrog", "trytestingob", "thisparentream", "byestriber", " byeststream", "thistestroy", "bytemprar", " bygestep", "bytestob", "byscriptrum", "byportep", "bysportREAM", " bygestrar", "byestrog", " byestream", " bytestord", "byteragram", " bygestram", "byfreshrar", " byestod", "ingtestingrog", "thisparentrog", "byestep", "yteragram", "bytestram", "bysportream", " bytestrar", "byscriptream", "byportriber", "bytempstream", "byestream", "bytestREAM", "bygestrog", "ingtestingrum", "Bygestep", "lysettep", "bytestep", " byestrar", "byfreshriber", "byserverram", "bytestrum", " bygestrip", "bytestingrown", "bysettrog", "bytestingod", "bygestob", "bygestrum", "lysettrown", "byseedstream", "byparentdem", "yterstream", "bytestrip", " bytestep", "byscriptstream", "bystestorage", "byportrum", "bytestdem", "byseedorage", "byserverrip", "Byeststream", "bytestingstream", " bytestriber", "bytestingob", "Bytestrown", "yterream", "byterram", "thistestream", "bygestrip", "Byestrown", "byvestREAM", "trytestingstream", "byterreen", "bystestream", "byestrum", "byfreshep", "byseedream", "bytestrog", "bytestsod", "byportREAM", " byestep", "ingtestream", "byterrip", "bytestsream", " byestorage", "bytestingrog", "thisparentdem", "yteststream", "Bygeststream", "thistestdem", "bytestsstream", "ingtestingstream", "bytempep", "bytestroy", "trytestream", "bysportorage", "bytestingrum", "Bytestrog", " bytestrip", "bytestingream", "byportrar"], "end": ["id", "send", "buffer", "add", "begin", "to", "END", "post", "pad", "End", "eng", "size", "stop", "ended", "rend", "pend", "en", "all", " End", "bound", "last", "ending", "e", "close", "ed", "h", "hend", "start", "ent", "set", "max", "nd", "ender", "offset", "length"], "buf": ["src", "doc", "tx", "buffer", "text", "bu", "uf", "rb", "err", "ff", "alloc", "stream", "p", "bin", "pad", "bc", "Buffer", "block", "np", "cur", "vec", "fb", "limit", "ref", "cb", "raw", "window", "bytes", "txt", "mem", "queue", "bg", "data", "br", "pb", "cap", "ctx", "b", "tmp", "orig", "str", "temp", "result", "buff", "msg", "db", "cv", "img", "bag", "out", "wb"], "linesize": ["elinesizing", "linesizable", "setsize", "setsization", "elinesIZE", "odesIZE", "linesizing", "elinesizable", "linesizes", "elinesizes", "linesization", "lsize", "elinesized", "elinesize", "lsizing", "elinesization", "odesized", "lsIZE", "lsized", "blocksizable", "odesizing", "blocksization", "setsizable", "setsizes", "linesIZE", "odesize", "blocksizes", "linesized", "blocksize"], "s": ["sq", "vs", "spec", "qs", "a", "ats", "rs", "as", "hs", "p", "gs", "sts", "ex", "ps", "g", "cs", "m", "bits", "ins", "sv", "i", "es", "bs", "aws", "r", "is", "js", "j", "S", "ss", "ts", "n", "less", "its", "t", "ctx", "v", "conf", "self", "ops", "os", "sb", "b", "c", "sw", "h", "ns", "stats", "w", "fs", "set", "comm", "ls", "ims", "ds", "sys"], "len": ["lim", "cmp", "nl", "fl", "lan", "li", "Len", "list", "els", "sp", "p", "seq", "wid", "ld", "nt", "iter", "SIZE", "vec", "limit", "l", "pos", "lon", "fun", "gl", "label", "lf", "length", "le", "ref", "lp", "en", "ell", "addr", "all", "mem", "ln", "cod", "data", "coll", "n", "kl", "total", "t", "mil", "count", " l", "v", "val", "fac", "elt", "z", "msg", "ls", "el", "max", "ll", "loc", "L", "size", "ret"], "height": ["grow", "bottom", "d", "location", "block", "wh", "row", "data", "rows", "html", "y", "view", "t", "check", "zh", "hang", "context", "memory", "history", "size", "depth", "display", "widget", "half", "wid", "capacity", " size", "en", "Height", "alpha", "count", "radius", "visible", "above", "title", "ows", "table", "rank", "density", "high", "id", "buffer", "ch", "k", "hash", "volume", "th", " Height", "type", "window", "mode", "host", "dim", "crop", "gravity", "style", "num", "resolution", "padding", "seek", "week", "lat", "level", "total", "v", "hei", "shape", "h", "kw", "ul", "x", "max", "offset", "length"], "ptr": ["butt", "tr", "next", "prime", "off", "pc", "tp", "address", "buffer", "pointer", "pt", "pp", "seek", "alloc", "cut", "proc", "p", "sp", "rep", "point", "inters", "ps", "pad", "fp", "iter", "pointers", "ind", "th", "push", "cur", "np", "ref", "pos", "inter", "jp", "hl", "trace", "pend", "handle", "addr", "adr", "mem", "expr", "r", "index", "row", "rel", "dep", "br", "ts", "perm", "ctx", "pr", "ctr", "xt", "red", "cmd", "rect", "peer", "coord", "Ptr", "buff", "vr", "loc", "offset", "dr", "mt"]}}
{"project": "FFmpeg", "commit_id": "da048c6d24729d3bab6ccb0ac340ea129e3e88d5", "target": 1, "func": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"stbl\");\n\n    mov_write_stsd_tag(pb, track);\n\n    mov_write_stts_tag(pb, track);\n\n    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&\n\n        track->has_keyframes && track->has_keyframes < track->entry)\n\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n        track->flags & MOV_TRACK_CTTS && track->entry)\n\n        mov_write_ctts_tag(pb, track);\n\n    mov_write_stsc_tag(pb, track);\n\n    mov_write_stsz_tag(pb, track);\n\n    mov_write_stco_tag(pb, track);\n\n    return update_size(pb, pos);\n\n}\n", "idx": 9101, "substitutes": {"pb": ["td", "lb", "xp", "bj", "typ", "rpm", "pc", "tp", "ub", "mb", "pp", "pt", "uf", "gm", "bp", "rb", "tk", "pan", "asm", "proc", "func", "p", "resp", "buf", "job", "amp", "cp", "fp", "pg", "bc", "vp", "pkg", "tc", "np", "jp", "fb", "mt", "cb", "orp", "bs", "lp", "aus", "package", "pm", "obb", "emb", "pac", "eb", "px", "bps", "pr", "pl", "sb", "b", "wp", "cmd", "bh", "sys", "dp", "bb", "stab", "PB", "nb", "batch", "ib", "msg", "pack", "cv", "mp", "patch", "wb"], "track": ["tm", "ck", "each", "add", "train", "sound", "report", "consider", "attr", "progress", "stack", "stall", "rr", "word", "rl", "row", "roll", "scan", "check", "skip", "ace", "cmd", "rm", "ek", "claim", "agg", "tr", "tp", "record", "call", "trak", "move", "tk", "match", "fire", "job", "task", "follow", "jp", "txt", "try", "trip", "ac", "reflect", "rt", "batch", "rank", "pack", "work", "tf", "Track", "require", "req", "summary", "bind", "form", "trace", "tab", "hold", "met", "tracks", "review", "sort", "transform", "comment", "tracking", "round", "find", "mt", "sync", "kick", "seek", "complete", "ack", "pkg", "rack", "acks", "port", "token", "json", "adr", "race", "tn", "gc", "search", "wp", "tag", "stat", "stab", "btn", "store"]}}
{"project": "qemu", "commit_id": "80ee15a6b274dfcedb0ad7db8c9e7d392210d6a1", "target": 1, "func": "uint64_t qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n    int *num)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l1_index, l2_index;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int l1_bits, c;\n\n    int index_in_cluster, nb_available, nb_needed, nb_clusters;\n\n\n\n    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);\n\n    nb_needed = *num + index_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the offset and\n\n     * the end of the l1 entry\n\n     */\n\n\n\n    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    if (nb_needed > nb_available) {\n\n        nb_needed = nb_available;\n\n    }\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n", "idx": 9106, "substitutes": {"bs": ["lb", "obs", "vs", "cks", "aos", "bp", "rs", "bas", "hs", "bes", "bl", "gs", "bc", "BS", "cs", "bm", "bits", "js", "its", "bos", "ts", "ss", "pb", "lbs", "bps", "ubs", "ubis", "os", "sb", "b", "bis", "bh", "ns", "fs", "ks", "ls", "ds"], "offset": ["key", "shift", "vector", "op", "frequency", "off", "reset", "id", "address", "url", "et", "buffer", "pointer", "padding", "base", "order", "image", "seek", "range", "point", "o", "error", "offs", "pad", "slot", "fp", "tile", "size", "ip", "location", "block", "pos", "timeout", "position", "trace", "window", "addr", "onto", "alt", "scroll", "index", "top", "amount", "Offset", "cache", "origin", "start", "kernel", "seed", "set", "time", "length", "mt"], "num": ["unique", "con", "nm", "gpu", "sum", "cmp", "add", "mult", "non", "valid", "nu", "nam", "Num", "unit", "np", "note", "other", "um", "common", "mu", "cal", "snap", "n", "uni", "rem", "mon", "dim", "un", "nom", "NUM", "om", "missing", "kw", "nb", "no", "number"], "s": ["ms", "vs", "sq", "spec", "sl", "qs", "a", "ats", "settings", "rs", "as", "hs", "sp", "gs", "sts", "p", "dev", "ps", "changes", "g", "cs", "m", "bits", "ins", "sv", "es", "ses", "aws", "is", "js", "less", "S", "ss", "ts", "its", "y", "als", "j", "http", "details", "ssl", "conf", "self", "v", "os", "sb", "b", "bis", "sw", "h", "ns", "stats", "fs", "comm", "sis", "ls", "states", "ims", "ds", "sys", "parts"], "l1_index": ["l1__ind", "l2_id", "l1__index", "l1____alias", "l1_address", "l2_num", "l1____index", "l1_ind", "l1____ind", "l1_result", "l1Punit", "l1PIndex", "l1__Index", "l2_result", "l1_id", "l1_alias", "l1_Index", "l2_Index", "l1_num", "l1____Index", "l1__alias", "l1Paddress", "l1Pindex", "l2_alias", "l1_unit", "l2_ind"], "l2_index": ["l2_slice", "l2___Index", "l2___index", "l3_index", "l14_key", "l3_number", "l2_ind", "l2_number", "l14_slice", "l22ind", "l2_Index", "l2__slice", "l2__key", "l14_offset", "l2__offset", "l1_length", "l1_Index", "l3_Index", "l2___offset", "l2_length", "l2_key", "l22index", "l2_page", "l2__index", "l22number", "l3_ind", "l1_ind", "l2___page", "l2___length", "l2___value", "l22Index", "l1_value", "l2_value", "l14_index"], "l2_offset": ["ltwojflag", "l1_error", "l2_Offset", "l2_location", "l2_address", "l2ptset", "l14_location", "l1_offset", "l2__Offset", "l2_slice", "ltwojindex", "l2jaddress", "l2Paddress", "l2___index", "l2ptoffset", "ltwojoffset", "ltwo_offset", "l2_url", "l2_flag", "l2_set", "l2_slot", "l2jflag", "l2ptslice", "l2___error", "l2jindex", "l14_offset", "l1_url", "l14_Offset", "l2Pindex", "l2__offset", "ltwojaddress", "l2__address", "l2ptindex", "l2Poffset", "ltwo_index", "l3_address", "l2_error", "l2___offset", "l3_offset", "l2___url", "l3_Offset", "ltwo_flag", "ltwo_address", "l2Pflag", "l1_set", "l2__slot", "l2joffset", "l3_slot", "l1_slice", "l14_index"], "l2_table": ["l2ptinterface", "l22table", "l2Jsystem", "l2pinterface", "l2__table", "l1_table", "l52_map", "l2ttab", "l2_buffer", "l2_interface", "l22xlevel", "l42_trace", "l2pcache", "l2ttable", "l42ptinterface", "l52_internal", "l2Jtmp", "l2_map", "l2_internal", "loder_tab", "l52_module", "l2Tmodule", "l2Jtable", "l22_level", "l02_Table", "l022table", "l22xtable", "l2_level", "l2ptable", "l2xlevel", "l22xtmp", "l22_table", "loder_stable", "l02_TABLE", "l2xtmp", "l2_tab", "l22tree", "l2_module", "l1_tab", "l2xtable", "loderJstable", "l2Jstable", "loder_table", "l2Jtab", "l2Ptable", "l2ptrace", "l1_buffer", "l2tbuffer", "l52Tmodule", "loderJtab", "l2ptcache", "l52Tinternal", "l22TABLE", "l2__map", "l42_table", "l52Tmap", "l2tTABLE", "l022Table", "l2_tmp", "l2thesystem", "l022tree", "l22_buffer", "l2thetable", "l2xbuffer", "l2thetab", "l22_tmp", "loder_system", "l2_tree", "l02_table", "l02_tree", "l2pttrace", "l2Tinternal", "l42pttable", "l2_system", "l2Pmodule", "l42pttrace", "l2Pmap", "l1_TABLE", "l2thestable", "l2_Table", "loderJsystem", "l2_TABLE", "l2Pinternal", "l2Tmap", "l2__module", "l2_trace", "l42_interface", "l2__internal", "l22xbuffer", "l2_cache", "l52Ttable", "l2Jlevel", "l22Table", "l52_table", "l2Ttable", "l42_cache", "l2Jbuffer", "loderJtable", "l42ptcache", "l2pttable", "l2_stable", "l022TABLE"], "cluster_offset": ["cluster1index", "cluster___offset", "cluster_size", "cluster_Offset", "clignment_point", "cluster___count", "cluster67shift", "clression_shift", "clression_position", "cluster2offset", "clider_offs", "clider_off", "cluster67Offset", "clider2off", "clression_offset", "clression_Offset", "cluster67offset", "clignment_prefix", "cluster67position", "clression67position", "clider_offset", "clression67offset", "clignment_count", "cluster_offs", "clider_shift", "clusterListpoint", "cluster_index", "cluster____off", "clusterListcount", "cluster2off", "clression67Offset", "clusterListprefix", "cluster_prefix", "cluster_position", "cluster_count", "cluster_error", "clider_error", "clider2shift", "clusterListoffset", "clider2offset", "clignment_offset", "cluster____offs", "cluster1error", "clider2offs", "cluster____offset", "cluster2shift", "clression67shift", "clider_size", "cluster___prefix", "cluster1offset", "clider_index", "cluster2offs", "cluster____shift", "cluster_shift", "cluster1size", "cluster___point", "cluster_point", "cluster_off"], "l1_bits": ["l8_planes", "l1_obs", "l1___its", "l1___bis", "l1__bs", "l1_nuts", "l100_bs", "l1_caps", "l2_bis", "l1_bugs", "l1_planes", "l2_bytes", "l8_bugs", "l1___bits", "l100_nuts", "l1_bps", "l1___bytes", "l1_its", "l1__bps", "l8_bits", "l2_bs", "l1_bis", "l100_bits", "laxy_bs", "l8_obs", "l1_bytes", "l2_bits", "laxy_bits", "laxy_bytes", "l100_bytes", "l1_bs", "laxy_caps", "l2_its", "l1__bits", "l2_bps"], "c": ["comments", "pc", "con", "ch", "ct", "k", "cut", "p", "f", "cp", "bc", "d", "dc", "g", "cs", "l", "tc", "m", "i", "unc", "cc", "chain", "cont", "n", "mc", "t", "ci", "ac", "count", "v", "rc", "conf", "lc", "cache", "e", "gc", "b", "cn", "h", "cm", "cu", "fc", "z", "C", "co", "ca"], "index_in_cluster": ["index_in_fluster", "index_in_clause", "index_in_Clusters", "index_in_planger", "index_in_chust", "index_in_flause", "index_in_pluster", "index_in_aclusters", "index_in_Clause", "index_in_plusters", "index_in_clust", "index_in_Clust", "index_in_clanger", "index_in_flust", "index_in_aclause", "index_in_Cluster", "index_in_aclust", "index_in_clusters", "index_in_Clanger", "index_in_acluster", "index_in_changer", "index_in_flusters", "index_in_chusters", "index_in_chuster", "index_in_plust", "index_in_plause"], "nb_available": ["nb_defined", "nbwfree", "nb67available", "nrjexternal", "nbjplayed", "nr_available", "nblaware", "nz___available", "nbjinstalled", "nz_available", "nbjneeded", "nb_found", "nbfrequired", "n_initialized", "nr_installed", "nbjdefined", "nbwready", "n_availability", "nb67availability", "nz_loaded", "nb___availability", "nb67present", "ln_required", "nrjavailable", "cli_required", "uni67found", "clifaware", "nbFplayed", "nb____availability", "nbjexternal", "nz_ready", "nbfavailable", "nz___free", "nbjavailability", "nrjdefined", "nb_external", "ln_played", "nb67defined", "nb____available", "nbfaware", "nbjinitialized", "uni_available", "uni_found", "nb____defined", "n_available", "nbjrequired", "cli_present", "nbwloaded", "nb____found", "nb___free", "nbjloaded", "clifrequired", "nb___loaded", "nb67installed", "nb_loaded", "uni67availability", "nbFavailable", "nb_present", "nb_free", "nb____required", "uni67required", "nb___available", "nb____installed", "nr_defined", "nbfpresent", "uni67available", "n_loaded", "nblpresent", "nb_availability", "ln_available", "nb67found", "nblavailable", "nb_ready", "nb___initialized", "clifpresent", "nb67required", "uni_required", "ln_needed", "nb67aware", "nz_free", "uni_availability", "nz___ready", "nb_initialized", "nz___loaded", "nr_external", "nbjavailable", "nbwavailable", "nb_aware", "nbFneeded", "cli_available", "nrjinstalled", "nb67external", "nb____external", "clifavailable", "nb_played", "nblrequired", "nbFrequired", "nb___ready", "cli_aware", "nb_installed", "nb_required"], "nb_needed": ["nb7available", "nbznecessary", "nn2required", "nb7expected", "nb2dependent", "nb___needed", "nb_found", "nbWdependent", "span_expected", "nbJdirty", "span_loaded", "nbLneeded", "nb_forced", "nn2needed", "nn2necessary", "nbWnecessary", "nb___expected", "nbLmissing", "nbPwant", "nb___need", "nballneeded", "nbJneeded", "nb_need", "NB_needed", "nn_necessary", "cli_forced", "nb_missing", "span7expected", "nb_dependent", "nbLneed", "nbLwant", "nb2needed", "nn_needed", "nb_expected", "nballnecessary", "ni_allowed", "cli_found", "nbPmissing", "ni_necessary", "cli_need", "nb_dirty", "nbWrequired", "nb2necessary", "span_available", "nb___loaded", "ni_dirty", "nb_loaded", "nb7loaded", "niJallowed", "NB_want", "nn_dependent", "niJnecessary", "nn2dependent", "nbzrequired", "NB_need", "nb7needed", "nb___forced", "NB_missing", "nbJallowed", "nb___available", "nbJavailable", "niJneeded", "ni_needed", "nbJnecessary", "nb___found", "span7needed", "nbJexpected", "nbWneeded", "nb_want", "nbzdependent", "cli_needed", "nbzneeded", "nballdirty", "nn_required", "span_needed", "span7loaded", "niJdirty", "nb_necessary", "nballallowed", "nbJloaded", "nbPneed", "span7available", "nb2required", "nb_allowed", "nbPneeded", "nb_required"], "nb_clusters": ["nb_gliques", "nb_cluster", "nb_contanches", "nb_clanches", "nb_pluster", "nb_glients", "nb_chusters", "nb_continodes", "nb_closes", "nb_scusters", "nb_clodes", "nb_scators", "nb_ploses", "nb_contients", "nb_plroups", "nb_blroups", "nb_caluster", "nb_caloses", "nb_clators", "nb_glanches", "nb_chators", "nb_canches", "nb_continusters", "nb_continators", "nb_contiques", "nb_bluster", "nb_blusters", "nb_scores", "nb_chuster", "nb_clients", "nb_scodes", "nb_custers", "nb_cliques", "nb_contusters", "nb_chroups", "nb_lores", "nb_clores", "nb_clroups", "nb_calroups", "nb_chores", "nb_ciques", "nb_plores", "nb_calusters", "nb_lroups", "nb_continores", "nb_glusters", "nb_plusters", "nb_chodes", "nb_cients", "nb_luster", "nb_bloses", "nb_lusters"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;\n\n\n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n//printf(\"%X %X %X %X %X %X %X %X %X %X\\n\", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],\n\n//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\tb5Dither= dither8[y&1];\n\n\tg6Dither= dither4[y&1];\n\n\tg5Dither= dither8[y&1];\n\n\tr5Dither= dither8[(y+1)&1];\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\n/* no speed diference on my p3@500 with prefetch,\n\n * if it is faster for anyone with -benchmark then tell me\n\n\t\t\tPREFETCH\" 64(%0) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%1) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%2) \\n\\t\"\n\n*/\n\nYUV2RGB\n\n\n\n#ifdef DITHER1XBPP\n\n\t\t\t\"paddusb \"MANGLE(b5Dither)\", %%mm0;\"\n\n\t\t\t\"paddusb \"MANGLE(g6Dither)\", %%mm2;\"\n\n\t\t\t\"paddusb \"MANGLE(r5Dither)\", %%mm1;\"\n\n#endif\n\n\t\t     /* mask unneeded bits off */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm0;\" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_grnmask)\", %%mm2;\" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm1;\" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */\n\n\n\n\t\t     \"psrlw $3,%%mm0;\" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */\n\n\t\t     \"pxor %%mm4, %%mm4;\" /* zero mm4 */\n\n\n\n\t\t     \"movq %%mm0, %%mm5;\" /* Copy B7-B0 */\n\n\t\t     \"movq %%mm2, %%mm7;\" /* Copy G7-G0 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpcklbw %%mm4, %%mm2;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpcklbw %%mm1, %%mm0;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm2;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"por %%mm2, %%mm0;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\n\n\t\t     \"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t     MOVNTQ \" %%mm0, (%1);\" /* store pixel 0-3 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpckhbw %%mm4, %%mm7;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpckhbw %%mm1, %%mm5;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm7;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t     \"por %%mm7, %%mm5;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\t\t     \"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\n\n\t\t     MOVNTQ \" %%mm5, 8 (%1);\" /* store pixel 4-7 */\n\n\n\n\t\t     \"add $16, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n\n\n    return srcSliceH;\n\n}\n", "idx": 9109, "substitutes": {"c": ["con", "ch", "ct", "enc", "p", "ec", "f", "cp", "cf", "d", "bc", "dc", "cs", "m", "tc", "l", "cd", "cc", "ce", "cont", "coll", "n", "mc", "t", "ci", "ctx", "ac", "rc", "lc", "v", "conf", "e", "b", "h", "cm", "etc", "cu", "fc", "C", "co", "s", "cv", "ca"], "src": ["sq", "obj", "spec", "lib", "sl", "usc", "source", "secure", "rb", "rs", "req", "init", "proc", "stream", "sub", "bin", "iter", "cur", "pkg", "ins", "sv", "hl", "ptr", "conv", "supp", "bs", "usr", "in", "bg", "ser", "rl", "dest", "scan", "rc", "sort", "sur", "input", "sb", "ctr", "via", "sh", "comp", "sn", "inst", "str", "sr", "st", "stab", "sc", "it", "fc", "s", "iv", "img", "sys"], "srcStride": ["rcStrrub", "srcStide", "srcRestrobe", "srcStr", "srcStrope", "srcStrobe", "srcStro", "srcEstope", "srcSlrib", "srcSTrobe", "srcSTide", "srcStrr", "rcStrrip", "srcSTrip", "srcStrrip", "rcStrib", "srcstr", "srcOptro", "srcSTrib", "srcSTride", "srcSlride", "srcRestride", "srcStrrub", "srcStrro", "srcStrrib", "rcStrip", "srcOptrub", "srcSlrip", "srcSlro", "srcStrib", "rcStrr", "srcStope", "rcStrrobe", "rcStrro", "srcEstride", "rcStro", "rcStrrib", "srcOptide", "srcRestope", "srcOptride", "srcstride", "rcStrub", "rcStr", "srcRestr", "srcSlrub", "srcstide", "srcRestrip", "rcStrope", "srcStrride", "srcstrip", "srcRestide", "srcEstro", "rcStope", "srcSlrobe", "srcStrrobe", "rcStride", "srcStrip", "srcSlide", "srcRestro", "rcStide", "rcStrobe", "rcStrride", "srcEstide", "srcStrub"], "srcSliceY": ["srcSlidey", "srcSlideH", "srcPlICEH", "srcSlireW", "srcSlideX", "srcSlireX", "srcSlICEX", "srcSlslicey", "srcSLideH", "srcPliceY", "srcSlireH", "srcSLiceH", "srcPlICEX", "srcSLiceY", "srcSlideW", "srcSLidey", "srcSlICEH", "srcSlICEy", "srcSlsliceH", "srcSLiceX", "srcSlsliceX", "srcPlICEY", "srcSlicey", "srcPliceX", "srcPliceW", "srcSlICEY", "srcPlICEW", "srcSlireY", "srcPliceH", "srcSlICEW", "srcSlsliceY", "srcSlideY", "srcSliceX", "srcSliceW", "srcSLideX", "srcSLideY", "srcSLicey"], "srcSliceH": ["srcSlideN", "srcSlaceHT", "srcSlideHT", "srcSlideH", "srcSliceN", "srcSlaceHH", "srcPliceY", "srcSlaceH", "srcSlideW", "srcSlaceY", "srcSliceHT", "srcSliceHH", "srcSlICEH", "srcSlideHH", "srcSlICEHH", "srcPliceN", "srcSlICEHT", "srcPliceW", "srcSlICEN", "srcSlICEY", "srcPliceH", "srcSlICEW", "srcSlideY", "srcSliceW"], "dst": [" dlt", "dsts", "Dsts", "rsts", "dssts", "dsst", "Dlt", "Dst", " dsts", "ddest", "dslt", " dST", "dST", "rST", "dset", "Dset", "rdest", "rst", " dset", "dsset", "Ddest", " ddest", "DST", "dlt"], "dstStride": ["dstSlro", "dstSlide", "dstRestide", "dstStrub", "dsrcStrip", "dstStide", "dstSyrat", "dstSyide", "dststack", "destSlride", "dststide", "dsrcStrat", "dstStrro", "dstDestide", "destStro", "destSlack", "dsrcStrro", "dsrcStrride", "dststride", "dstRestack", "dstSlride", "dstStack", "dstStrride", "dsrcStrub", "dstStrat", "destStide", "dstRestride", "dstSlack", "dsrcStrrub", "dstStrip", "dstDestrub", "dsrcStrrat", "dstStrrub", "dsrcStide", "dstSyride", "dststrip", "dsrcStride", "dstDestride", "dstRestro", "destStack", "dstRestrip", "dstDestrat", "dsrcStro", "dstStrrat", "dstStrrip", "destSlro", "dstStro", "destStride", "destSlide", "dststro", "dsrcStrrip", "dstSyrub"], "y": [" ty", "key", "aily", "py", "yt", "xy", "ya", "axy", "sky", "ty", "ch", "vy", "ady", "yy", "yi", "wy", " ly", "p", "height", "ay", "ry", "m", "oy", "my", "ies", "i", "ye", "yer", "dy", "ky", "scroll", "try", "ys", "j", " busy", " ye", "ley", "n", "icy", "yd", "t", "yr", "Y", "yo", "ey", "b", "yk", " ya", "ly", "ym", "gy", "sy", "ot", "uy", "h", "iy", "hey", " ay", "x", "z", "iley", " py", "yl", "ny", "yle", " j", "kit", "cy"], "h_size": ["H_general", "hi_start", "h_start", "h_capacity", "H_group", "hbufsize", "h2size", "H_capacity", "h2scroll", "hi_value", "H2scope", "h_group", "H_scroll", "h2Size", "h67general", "h2group", "h67SIZE", " h2Size", "h_Size", "H2Size", "h_number", "h_SIZE", " h_Size", "hi_sum", "h2SIZE", "h_scope", "H2size", " h2number", "hi_size", " h_number", "H2group", "h_scroll", "hbufSize", "h2scope", "h67size", "hbufnumber", "h67group", "H_Size", "h_general", " h2size", "h67capacity", "H_scope", "h_value", "h2number", "H_SIZE", "h67Size", "h67scope", "h_sum", "H_size"], "_image": [" _img", "_pixel", "_img", "jimg", "jpng", "__png", "__image", " _pixel", "__img", "__pixel", "jimage", "jpixel", " _png", "_png"], "_py": [" _po", "_ps", "_px", " _ps", " _px", "_po"], "_pu": ["_mp", " _mp", "_pt", " _pt", " _pe", "_pe"], "_pv": ["_pj", "_prv", "_rv", "_Pj", "_prw", "_rj", "_pw", "_rx", "_Px", "_prx", "_Pw", "_px", "_rw", "_Pv", "_prj"]}}
{"project": "qemu", "commit_id": "b8aecea23aaccf39da54c77ef248f5fa50dcfbc1", "target": 1, "func": "void memory_region_add_eventfd(MemoryRegion *mr,\n\n                               hwaddr addr,\n\n                               unsigned size,\n\n                               bool match_data,\n\n                               uint64_t data,\n\n                               EventNotifier *e)\n\n{\n\n    MemoryRegionIoeventfd mrfd = {\n\n        .addr.start = int128_make64(addr),\n\n        .addr.size = int128_make64(size),\n\n        .match_data = match_data,\n\n        .data = data,\n\n        .e = e,\n\n    };\n\n    unsigned i;\n\n\n\n    adjust_endianness(mr, &mrfd.data, size);\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n\n            break;\n\n        }\n\n    }\n\n    ++mr->ioeventfd_nb;\n\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n\n    mr->ioeventfds[i] = mrfd;\n\n    ioeventfd_update_pending |= mr->enabled;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 9122, "substitutes": {"mr": ["ms", "tm", "kr", "ml", "MT", "tr", "hr", "hm", "rpm", "mx", "mm", "gm", "lr", "rb", "rs", "older", "arry", "asm", "wm", "rar", "gr", "wr", "m", "bm", "rn", "MR", "drm", "shr", "mn", "rr", "adr", "usr", "r", "rl", "pm", "br", "mc", "rg", "nr", "pr", "mk", "wcs", "ctr", "mmm", "mid", "rt", "sr", "cm", "ocr", "rm", "rer", "vr", "km", "Mr", "dr", "mt"], "addr": ["align", "src", "work", "len", "id", "tx", "net", "address", "map", "arp", "et", "a", "url", "add", " ptr", " ip", "ack", "alloc", " ref", " address", "wid", "pad", "iat", "act", "ip", "pkg", "pos", "ref", "gate", "attr", "inter", " af", "ptr", "desc", "np", "adr", "ord", "mem", "alt", "r", "rel", "ix", "dest", "ad", "aux", "conn", "ace", "host", " mac", "env", "cmd", "ag", "str", "start", "hw", "res", "alias", "off", " tid", "elt", "oad", "coord", " amp", " dst", "phys", "loc", "offset", "dr", "store"], "size": ["ms", "len", "small", "empty", "next", "min", "send", "address", "sum", "message", "device", "end", " Size", "range", "area", "sp", "height", "Size", "eng", "SIZE", "capacity", "limit", "pos", "m", "type", "g", "serial", "window", "ize", "bytes", "mem", "storage", "index", "last", "mode", "count", "zone", "since", "shape", "sh", "scale", "sn", "sy", "start", "fee", "si", "z", "space", "set", "max", "name", "offset", "length"], "match_data": ["matchxdev", "Match_data", "matchabledata", "Match_type", " matchableData", "matchableData", "matchdbData", " match_dat", "matchortype", "match_dat", " matchabledata", "matchabletype", " matchabledat", "Matchabledat", "matchxdata", "match_dev", "matchordata", "match_table", "match_Data", "Matchabletype", " match_Data", "matchxbytes", "matchabledat", "matched_table", "matched_dev", "matchordat", "MatchableData", "matched_bytes", "matched_data", "matchorData", "Match_dat", "matchxtable", "match_bytes", "Match_Data", "Matchabledata", "matchdbdata", "match_type", "matchdbdat"], "data": ["align", "len", "Data", "next", "tx", "fd", "al", "map", "address", " d", "buffer", "a", "device", "format", "image", "area", "p", "buf", " Data", "dev", "bin", "value", "ne", "f", "da", "d", " DATA", "block", "m", "pos", "ata", "timeout", "zero", "def", "type", "length", "raw", "window", "bytes", "mu", "ta", "done", "n", "ad", "mode", "t", "bus", "aw", "cache", "any", "dat", "di", "w", "flags", "str", " dat", "table", "batch", "only", "DATA", "name", "dt", "offset"], "e": ["u", "et", "a", "ei", "ee", "ev", "p", "o", "ec", "f", "ne", "d", "g", "m", "l", "es", "r", "eg", "n", "y", "t", "eb", "v", "E", "b", "ed", "c", "h", "eu", "re", "w", "oe", "er", "x", "el", "s", "ue"], "i": ["ms", "ami", "id", "ai", "fi", "I", "me", "ie", "io", "li", "ei", "uri", "q", "init", "ri", "p", "o", "sim", "f", "ind", "ui", "iter", "ip", "g", "m", "l", "ti", "ic", "cli", "us", "in", "index", "mi", "is", "j", "im", "ix", "n", "y", "t", "ci", "iu", "\u0438", "phi", "v", "zi", "info", "xi", "multi", "qi", "b", "c", "h", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "z", "ini", " ii", "ji", " j", "ii"], "ioeventfd_nb": ["ioeventfd__nr", "ioeventfp_cb", "ioeventFD_ns", "ioeventfd__nb", "ioeventf_nn", "ioeventf_nc", "ioeventf_nr", "ioeventfd_db", "ioeventfp_nb", "ioeventfd__nn", "ioeventfd_cb", "ioeventfd_nr", "ioeventfd__db", "ioeventfp_db", "ioeventf_nb", "ioeventf_db", "ioeventfd_nc", "ioeventfd_ns", "ioeventFD_nr", "ioeventFD_nb", "ioeventfd_nn", "ioeventfp_nr", "ioeventFD_cb", "ioeventf_cb"]}}
{"project": "FFmpeg", "commit_id": "c3778df2d4c05e76d28d77a2d740e435393046c9", "target": 0, "func": "enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)\n\n{\n\n    if (codec && codec->pix_fmts) {\n\n        const enum AVPixelFormat *p = codec->pix_fmts;\n\n        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;\n\n        enum AVPixelFormat best= AV_PIX_FMT_NONE;\n\n        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,\n\n                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };\n\n            }\n\n        }\n\n        for (; *p != AV_PIX_FMT_NONE; p++) {\n\n            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);\n\n            if (*p == target)\n\n                break;\n\n        }\n\n        if (*p == AV_PIX_FMT_NONE) {\n\n            if (target != AV_PIX_FMT_NONE)\n\n                av_log(NULL, AV_LOG_WARNING,\n\n                       \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\",\n\n                       av_get_pix_fmt_name(target),\n\n                       codec->name,\n\n                       av_get_pix_fmt_name(best));\n\n            return best;\n\n        }\n\n    }\n\n    return target;\n\n}\n", "idx": 9134, "substitutes": {"st": ["src", "tr", "sl", "std", "ch", "St", "ct", "step", "stream", "sp", "sts", "ut", "th", "stop", "mt", "sv", "ust", "sam", "stack", "ste", "cont", "stage", "ss", "ist", "se", "esc", "t", "fr", "stru", "ast", "sw", "sh", "irst", "ost", "ST", "sn", "str", "est", "start", "sta", "rest", "h", "ocr", "sc", "stat", "set", "nd", "inst", "sth", "spect"], "codec": ["preddec", "codeec", "codeco", "codesc", "codEC", "Codeth", "Codeco", "cedEC", " codeth", "odec", "odeco", "codEc", "payec", "pedEC", "codeocol", "predocol", "buckdec", "odeca", "Codec", "codeerer", "codeEC", "odesc", "Codocol", "Codesc", "codenc", "Coddec", "paydec", "Codenc", " codenc", "odisc", "buckEc", "codedec", "predec", "payeco", " codeco", "pedeco", " codEc", " coderer", "CodEc", "cedesc", "codeth", "predEC", "cedec", "pedeca", " codeca", "Coderer", "payEC", "codeenc", "cedisc", "buckEC", "pedec", "Codisc", "codisc", "codocol", "odEC", "coderer", "coddec", " codEC", "CodEC", "buckec", "codeca", "oddec", " coddec", "codeeth"], "target": ["output", "best", "png", "op", "next", "current", "expected", "buffer", "source", "pointer", "padding", "base", "format", "ARGET", "match", "arget", "to", "goal", "peg", "sp", "point", "standard", "error", "this", "g", "original", "np", "stop", "type", "mt", "local", "null", "ptr", "parent", "port", "top", "test", " targ", "root", "pb", "dest", "global", "t", "total", "v", "self", "primary", "transform", "compatible", "h", "master", "native", "alias", "wrong", "table", "peer", "result", "set", "gt", "debug", "max", "arg", "Target"], "p": ["xp", "imp", "u", "pc", "tp", "pat", "part", "par", "pp", "pt", "gp", "q", "ping", "bp", "proc", "sp", "point", "f", "pair", "cp", "ps", "fp", "pad", "d", "ip", "vp", "jp", "m", "g", "pkg", "ap", "pod", "np", "i", "l", "port", "lp", "pid", "pers", "j", "pb", "y", "t", "P", "v", "patch", "pr", "pl", "b", "c", "wp", "h", "w", "peer", "php", "x", "pro", "conv", "pa"]}}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "static void gic_set_irq(void *opaque, int irq, int level)\n\n{\n\n    /* Meaning of the 'irq' parameter:\n\n     *  [0..N-1] : external interrupts\n\n     *  [N..N+31] : PPI (internal) interrupts for CPU 0\n\n     *  [N+32..N+63] : PPI (internal interrupts for CPU 1\n\n     *  ...\n\n     */\n\n    GICState *s = (GICState *)opaque;\n\n    int cm, target;\n\n    if (irq < (s->num_irq - GIC_INTERNAL)) {\n\n        /* The first external input line is internal interrupt 32.  */\n\n        cm = ALL_CPU_MASK;\n\n        irq += GIC_INTERNAL;\n\n        target = GIC_TARGET(irq);\n\n    } else {\n\n        int cpu;\n\n        irq -= (s->num_irq - GIC_INTERNAL);\n\n        cpu = irq / GIC_INTERNAL;\n\n        irq %= GIC_INTERNAL;\n\n        cm = 1 << cpu;\n\n        target = cm;\n\n    }\n\n\n\n    assert(irq >= GIC_NR_SGIS);\n\n\n\n    if (level == GIC_TEST_LEVEL(irq, cm)) {\n\n        return;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        gic_set_irq_11mpcore(s, irq, level, cm, target);\n\n    } else {\n\n        gic_set_irq_generic(s, irq, level, cm, target);\n\n    }\n\n\n\n\n    gic_update(s);\n\n}", "idx": 9150, "substitutes": {"opaque": [" opula", "Opaque", "opos", "opaques", "opque", "compaques", "Opque", " opaques", "OPaque", "boute", "OPos", " opute", "OPaques", "boula", "Opula", "compque", "Opute", " opque", "compos", " opos", "boaque", "OPque", "opula", "compaque", "boque", "opute"], "irq": ["virquery", "Irq", "ironqi", "iradq", "iraqt", "frqu", "IRqi", "Irqu", "irquant", "irch", "iraqu", "iroque", "virqt", "rirqu", "iraqi", "ibrqq", "virQ", "rirquire", "ibrqi", "irity", "pirqu", "pirquery", "ibrqu", "irrequ", "iroqu", " irqu", " irqt", "pirch", "driq", "rirq", "iriqa", "irdq", "yrquant", "rirdq", "portch", "iriqq", "irqi", "virqu", "irtquest", " irquery", "ironcharge", "pirq", "viriq", "ririq", "iraqa", "pirqi", "ironquant", "irtrequ", "Irrequ", "iraque", "virq", "frqi", "irtque", "ibrq", "nirq", "IRq", "iriq", "irtq", "nirqu", "rirqq", "virity", "irtqu", "drq", " irity", " irquest", "irQ", "irqu", "nirquire", "ibrquant", "irqa", "portqi", "rirqi", "irquest", "yrqq", "yrcharge", "yrq", "irque", "ibrch", "irqt", "frdq", "irquery", "iroqq", "IRQ", "nirqi", "rircharge", "irtqi", "drquery", "nirQ", "rirquery", "irique", "frq", "drqq", "iroqa", "iroq", "ibrcharge", "portqu", "IRqu", "portq", "irtquery", "pirquest", "virqq", "irtquire", "ironqq", "iraqq", "virqi", "ironq", "iraity", "irorequ", "Irque", " irqq", "irqq", "iraq", "ircharge", "irquire"], "level": ["key", "depth", "score", "status", "pe", "priority", "where", "lvl", "message", "code", "Level", "counter", "goal", "file", "module", "ec", "point", "scope", "label", "VEL", "l", "vel", "type", "m", "limit", "tc", "local", "LC", "cc", "index", "stage", " lvl", "test", "coll", "cond", "mode", "levels", "state", "lc", "mid", "low", "scale", "tag", "color", "sc", "density", "cost", "time", "LE", "le", "high", "length", "style", "mt"], "s": ["sq", "obj", "series", "vs", "sl", "qs", "a", "rs", "or", "as", "hs", "p", "gs", "sts", "bes", "f", "ex", "ps", " ss", "changes", "d", "g", "m", "l", "ains", "bits", "cs", "sv", "es", "ses", "bs", "us", "details", "is", "js", "less", "S", "ss", "ts", "n", "y", "als", "se", "t", "sports", "its", "mos", "r", "self", "os", "sb", "b", "c", "bis", "sw", "h", "ns", "stats", "w", "fs", "z", "comm", "set", "ls", " self", "ims", "syn", "ds", "sys", "store"], "cm": ["cum", "pc", "mb", "mx", "cmp", "mm", "ch", "gm", "cy", "cam", "em", "ct", "asm", "cut", "fine", "form", "wm", "CM", "cp", "pu", "fm", "cr", "dc", "tc", "m", "bm", "cs", "um", "pixel", "mr", "mn", "cc", "mask", "arm", "core", "term", "mi", "cont", "pm", "im", "mc", "ci", "ctx", "rem", "lc", "conf", "mk", "gc", "multi", "ctr", "c", "cn", "cmd", "com", "ym", "sc", "rm", "broad", "fc", "imm", "comm", "cv", "km", "mp", "module", "dm", "rom", "ca", "mt"], "target": ["output", "obj", "next", "tp", "jump", "path", "source", "buffer", "ARGET", "thread", "device", "arget", "weight", "range", "cut", "goal", "home", "height", "prop", "slot", "iat", "location", "scope", "limit", "tc", "screen", "m", "local", "type", "process", "ptr", "trace", "port", "parent", "window", "mask", "term", "top", "rel", "total", "root", "node", "t", "ctx", "scan", "label", "Target", "cmd", "origin", "member", "peer", "sc", "mac", "table", "gt", "memory", "user", "dt", "offset", "size", "trap", "arg", "mt"], "cpu": ["nice", "nic", "num", "u", "cum", "pc", "tp", "gpu", "mx", "cmp", "thread", "processor", "device", "proc", "pool", "cp", "pu", "linux", "component", "ram", "process", "np", "pixel", " CPU", "mu", "core", "CPU", "mem", "us", "clock", "total", "ctx", "gc", "c", "hw", "nc", "cu", "mac", "phys", "memory"]}}
{"project": "FFmpeg", "commit_id": "366ac22ea5a8bab63c7f46cdad2ddb2ff22cdbed", "target": 1, "func": "static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,\n                          IVITile *tile, AVCodecContext *avctx)\n{\n    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,\n                mv_scale, blks_per_mb;\n    IVIMbInfo   *mb, *ref_mb;\n    int         row_offset = band->mb_size * band->pitch;\n    mb     = tile->mbs;\n    ref_mb = tile->ref_mbs;\n    offs   = tile->ypos * band->pitch + tile->xpos;\n    /* scale factor for motion vectors */\n    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);\n    mv_x = mv_y = 0;\n    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {\n        mb_offset = offs;\n        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {\n            mb->xpos     = x;\n            mb->ypos     = y;\n            mb->buf_offs = mb_offset;\n            if (get_bits1(&ctx->gb)) {\n                if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    av_log(avctx, AV_LOG_ERROR, \"Empty macroblock in an INTRA picture!\\n\");\n                    return -1;\n                }\n                mb->type = 1; /* empty macroblocks are always INTER */\n                mb->cbp  = 0; /* all blocks are empty */\n                mb->q_delta = 0;\n                if (!band->plane && !band->band_num && (ctx->frame_flags & 8)) {\n                    mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                           IVI_VLC_BITS, 1);\n                    mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                }\n                mb->mv_x = mb->mv_y = 0; /* no motion vector coded */\n                if (band->inherit_mv){\n                    /* motion vector inheritance */\n                    if (mv_scale) {\n                        mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                        mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                    } else {\n                        mb->mv_x = ref_mb->mv_x;\n                        mb->mv_y = ref_mb->mv_y;\n                    }\n                }\n            } else {\n                if (band->inherit_mv) {\n                    mb->type = ref_mb->type; /* copy mb_type from corresponding reference mb */\n                } else if (ctx->frame_type == FRAMETYPE_INTRA) {\n                    mb->type = 0; /* mb_type is always INTRA for intra-frames */\n                } else {\n                    mb->type = get_bits1(&ctx->gb);\n                }\n                blks_per_mb = band->mb_size != band->blk_size ? 4 : 1;\n                mb->cbp = get_bits(&ctx->gb, blks_per_mb);\n                mb->q_delta = 0;\n                if (band->qdelta_present) {\n                    if (band->inherit_qdelta) {\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n                                           (ctx->frame_flags & 8))) {\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                               IVI_VLC_BITS, 1);\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                    }\n                }\n                if (!mb->type) {\n                    mb->mv_x = mb->mv_y = 0; /* there is no motion vector in intra-macroblocks */\n                } else {\n                    if (band->inherit_mv){\n                        /* motion vector inheritance */\n                        if (mv_scale) {\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                        } else {\n                            mb->mv_x = ref_mb->mv_x;\n                            mb->mv_y = ref_mb->mv_y;\n                        }\n                    } else {\n                        /* decode motion vector deltas */\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_y += IVI_TOSIGNED(mv_delta);\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_x += IVI_TOSIGNED(mv_delta);\n                        mb->mv_x = mv_x;\n                        mb->mv_y = mv_y;\n                    }\n                }\n            }\n            mb++;\n            if (ref_mb)\n                ref_mb++;\n            mb_offset += band->mb_size;\n        }\n        offs += row_offset;\n    }\n    align_get_bits(&ctx->gb);\n    return 0;\n}", "idx": 9162, "substitutes": {"ctx": ["jac", "ck", "obj", "tx", "cmp", "abc", "config", "std", "crit", " cx", "req", "cam", "ct", "tk", "kt", "resp", "tz", "Context", "cp", "cf", "xc", "dc", "bc", "act", "pkg", "tc", "iat", "jp", "cb", "ctl", "ia", "cc", "txt", "handle", "mem", "mc", "ci", "conn", "cas", "conf", "info", "lc", "cfg", "wcs", "gc", "c", "anc", "cmd", "setup", "kb", "voc", "hw", "cm", "kw", "cu", "sc", "context", "comm", "cv", "loc", "conv", "ann", "ca", "sys"], "band": ["command", "brand", "day", "pp", "mm", "feature", "range", "amp", "d", "block", "word", "bound", "bo", "iband", "b", "cmd", "kb", "bd", "raid", "gain", "key", "bank", "power", "frequency", "bool", "road", "phase", "bor", "pixel", "chrom", "node", "member", "cm", "pipe", "link", "batch", "country", "grid", "byte", "bf", "part", "device", "image", "bind", "form", "cd", "bm", "tab", "filter", "chain", "amber", "mode", "plugin", "dom", "bus", "bed", "product", "library", "bb", "piece", "broad", "db", "bar", "style", "binary", "mt", "bridge", "bands", "flag", "cell", "ring", "and", "brid", "pair", "bin", "mg", "beam", "service", "ud", "port", "Band", "bit", "through", "tag", "group", " bands", "disk"], "tile": ["brand", "sky", "map", "feature", " Tile", "kt", "detail", "progress", "details", "t", "entity", "tree", "metadata", "chip", "target", "raid", "slice", "tar", "TI", "mate", "iled", "live", "ray", "note", "tle", "bor", "pixel", "ti", "test", "node", "feat", "league", "table", "tiny", "link", "game", "debug", "grid", "byte", "draw", "template", "skill", "buffer", "mat", "device", "image", "ile", "bat", "file", "fine", "Tile", "unit", "inter", "trace", "ite", "vt", "term", "phy", "reg", "line", "texture", "piece", "peer", "db", "tu", "module", "tool", "binary", "mt", "ty", "embed", "cell", "complete", "det", "sector", "mg", "domain", "service", "te", "port", "tif", "shot", "bit", "site", "player", "via", "query", "sel", "tip", "offset", "store"], "avctx": [" avdc", " avcontext", "avecfg", "avecontext", "AVtx", "avdc", "AVctx", "AVcontext", "awtx", "awcontext", "avcontext", "awcfg", "avercontext", "averdc", "AVdc", "avectx", " avcfg", "averctx", "avertx", "avtx", "avcfg", " avtx", "avetx", "awctx"], "x": ["xp", "on", "xy", "tx", "u", "mx", "at", "text", "path", "nex", " cx", "p", " i", "o", " dx", "ex", "ox", "dx", "xc", "xd", "ip", "m", "l", "wx", "lon", " ex", "i", "X", "xs", "xxx", "inx", "ext", "ord", "index", " w", "lat", "rx", "ix", "j", "px", "v", " tx", "xi", "xt", "c", "xx", "w", "zx", "yx", "xml", "z", "ax", "fx", "xa", "att", "el", " xx", "xe", "ux", "xf"], "y": ["aily", "key", "yt", "py", "xy", "ya", "axy", "sky", "ty", "vy", "ady", "yy", "wy", "p", "height", "ay", "ry", "yn", "ip", "m", "oy", "my", "ies", "ye", "i", "yer", "dy", "ys", "ley", "n", "icy", "t", "yr", "v", "asy", "yo", "ey", "e", "b", "h", "ery", "ym", "sy", "uy", "gy", "fy", "ot", "iy", "yx", "yet", "hey", "by", "yout", "sys", "yl", "ny", "ht", "kit", "cy"], "mv_x": ["mv_xs", "mv_xi", "mv__dx", "mov_px", "mv2y", "mva_rx", "mvc2width", "mv_width", "muv_xs", "mov_ex", "mvc_width", "muv_ex", "mv__x", "mva2x", "mv__y", "mv_dx", "mvc2xs", "mov_x", "mv__px", "mv_start", "mv____start", "mvc_xs", "mv_rx", "mv2start", "mv__rx", "mv2xs", "mvc2start", "mv_ex", "muv_x", "mov_rx", "mva2y", "mvc_start", "mv2x", "muv_dx", "mvc2x", "mv____width", "mva_y", "mv__xs", "mv____xs", "mv_px", "mv2width", "mva_x", "mv2rx", "mov_xi", "mv____x", "mva2rx", "mvc_x", "mv__ex"], "mv_y": ["mv__y", "mov_yt", "mv_yt", "mov_x", "mv_d", "mv_h", "mv2h", "mv2y", "mvt_y", "mvt_h", "mva_i", "mva_ey", "mv2v", "mv_b", "mv__b", "mov_b", "mva_y", "mv__ye", "mv__i", "mvJh", "mvJv", "mv_ye", "mv_ey", "mvt_v", "mv__yt", "mvJy", "mvt_d", "mov_y", "mv2d", "mv_i", "mv_v", "mv__ey", "mva_ye", "mvJd", "mv__x"], "mv_delta": ["mv_dota", "mv_delt", "mv_lelt", "mv_Delt", "mv_Delta", "mv_lelta", "mv_lota", "mv_Dota", "mv_DDelta", "mv_dDelta", "mv_lDelta"], "offs": ["ms", "tops", "amps", "obs", "aps", "xy", "off", "ats", "blocks", "eps", "keys", "gs", "inters", "ps", "cs", "points", "outs", "bits", "pos", "ins", "xs", "bs", "posts", "ts", "ones", " offsets", "sets", "ops", "os", "limits", "ows", "ns", "times", "origin", "ks", "vals", "oa", "s", "ims", "offset", "ds", "cells"], "mb_offset": ["mb_position", "mb64timeout", "mb_origin", "mb__index", "mb_shift", "mb__offset", "mb___offset", "mb_Offset", "kb_index", "mbsindex", "mb64translation", "mb__origin", "kbsposition", "kbsindex", "kb_position", "mb64offset", "emb_Offset", "emb_offset", "mbsoffset", "mb___timeout", "emb_info", "mb_translation", "bb_offset", "mb64shift", "mb_info", "kb_origin", "mb__position", "bb_shift", "mb_timeout", "kbsorigin", "mb___shift", "mb___translation", "kb_offset", "bb_translation", "mb_index", "mbsorigin", "kbsoffset", "bb_timeout", "mbsposition"], "mv_scale": ["mvarpyscale", "mav_scale", "mvarpydevice", "mvar_status", "mvar_device", "mvpydevice", "mv2save", "mv_size", "mvp_save", "mav_size", "mov_rate", "mvpyscale", "mvp_cale", "mov_scale", "mv_transform", "mvp_size", "mvpysize", "mvarpystatus", "mv_base", "mv_rate", "mv_cale", "mvp_scale", "mv2scale", "mvpystatus", "mov_size", "mvar_scale", "mvarpysize", "mvar_size", "mv2size", "mv_save", "mv_info", "mav_transform", "mav_info", "mv2cale", "mv_device", "mv_status", "mov_base"], "blks_per_mb": ["blks_PER_byte", "blks_per_mm", "blks_PER_mm", "blks_per_MB", "blks_per_byte", "blks_PER_mb", "blks_PER_MB"], "mb": ["ms", "lb", "amb", "norm", "management", "arb", "bf", "ub", "orm", "nm", "mm", "mx", "ebin", "abc", "bp", "hub", "em", "manager", "boost", "meta", "xb", "bl", "mar", "job", "GB", "amp", "fm", "brain", "mg", "gov", "sm", "m", "bor", "bm", "nob", "um", "ab", "mn", "iam", "mem", "md", "bound", "erm", "obb", "pb", "emb", "eb", "irm", "fam", "umb", "sb", "kb", "ym", "mor", "mob", "nom", "bd", "bb", "ob", "orb", "rm", "MB", "gb", "ib", "db", "bar", "mp", "vm", "byte", "mt", "mop"], "ref_mb": [" ref_emb", "ref2mem", "ref2MB", "ref___mor", "ref_MB", " ref_mor", " ref2MB", " ref2mor", "ref_mor", "ref_mem", "ref_band", " ref_mem", "ref2mb", "ref___MB", "ref2mor", "Ref_mi", "Ref_mb", "ref_mi", "ref_emb", "Ref_band", "ref___emb", " ref_MB", "ref___mb", " ref2mb", "Ref_MB", " ref2mem"]}}
{"project": "qemu", "commit_id": "0f888bfaddfc5f55b0d82cde2e1164658a672375", "target": 1, "func": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;", "idx": 9172, "substitutes": {"vty_lookup": ["vty_lookUp", "vty_LookUp", "vty_Lookup", "vty_cleanify", "vty_listify", "vty_Lookups", "vty_lookups", "vty_listup", "vty_listUp", "vty_cleanup", "vty_cleanups", "vty_cleanUp", "vty_lookify", "vty_listups", "vty_Lookify"], "sPAPRMachineState": ["sPAPRMachineStates", "sPAPROMachineInfo", "sPAPROMasterStates", "sPAPRMachineInfo", "sPAPROMachineSTATE", "sPAPRMotorStates", "sPAPRMasterInfo", "sPAPRMotionStates", "sPAPROMachineState", "sPAPRMotorState", "sPAPRMotorInfo", "sPAPRMasterStates", "sPAPRMasterState", "sPAPRMotionSTATE", "sPAPRMotionInfo", "sPAPRMachineSTATE", "sPAPROMasterSTATE", "sPAPROMachineStates", "sPAPRMotionState", "sPAPROMasterInfo", "sPAPRMasterSTATE", "sPAPROMasterState", "sPAPRMotorSTATE"], "spapr": ["spcaprs", " spapR", "spcappr", "spapsrar", "spaper", "aspapir", "spampir", "spaxpr", "spaxrs", "spcapor", " spaprs", "spapz", "spapsR", "spaptz", " spcapor", " spappr", " spcapr", "sparpar", " spipR", "sparpr", " spipar", "spampr", "aspapr", "spampz", "spapir", "spapar", "aspamper", "sparpR", "aspaper", "spapprs", " spapor", "spapR", "spapsz", "spapser", "spappr", "spiprar", "spcapr", " spiprar", "aspapz", "aspampir", "spapsr", "spipR", "spaptir", "sparprar", "spapppr", "spaprar", "spaprs", "spapsar", " spcaprs", "spapsir", "spaptr", "spamper", "spipar", " spipr", "spaxr", "spapor", "aspampr", "spaxor", "spappor", "spapter", "spipr", " spcappr", "aspampz", " spapar", " spaprar"], "target_ulong": ["target_uue", "target_ULlong", "target_ULng", "target_ULong", "target_ULue", "target_ung", "target_ulng", "target_uong", "target_longng", "target_longlong", "target_longong", "target_longue", "target_ulue", "target_ullong"], "reg": ["key", "arr", "map", "config", " REG", "code", "req", "cell", "region", "registered", "rec", " addr", "rep", "eng", "sec", "g", "ref", "rr", "urg", "mod", " rg", "addr", "mem", "r", "eg", " region", "Reg", "br", "rem", "gc", "red", "ro", "any", "re", " registry", "rest", "res", "tag", "REG", " mem", "org", "ru", "grid", "ret"], "sdev": ["gesDev", "lsdevice", "lsdev", "svar", "simpledevice", "sdevice", " svar", "gesdiv", "Sdevice", "Sdev", "vvar", "sesdem", "SDev", "tsdevice", "tsdev", "sesdevice", "lsvar", "sesdev", "gesvar", "simpledev", "sdiv", " sdiv", "simpleDev", "tsvar", "gesdev", "lsDev", " sdem", " sDev", "tsDev", "Svar", "sDev", "vDev", "vdiv", "sdem", "sesDev", " sdevice", "simplevar", "Sdem", "vdev"]}}
{"project": "qemu", "commit_id": "356f59b8757f47c0aca3e2e4e51d6010f64cade1", "target": 1, "func": "void coroutine_fn block_job_pause_point(BlockJob *job)\n\n{\n\n    assert(job && block_job_started(job));\n\n\n\n    if (!block_job_should_pause(job)) {\n\n        return;\n\n    }\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    if (job->driver->pause) {\n\n        job->driver->pause(job);\n\n    }\n\n\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n\n        job->paused = true;\n\n        job->busy = false;\n\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n\n        job->busy = true;\n\n        job->paused = false;\n\n    }\n\n\n\n    if (job->driver->resume) {\n\n        job->driver->resume(job);\n\n    }\n\n}\n", "idx": 9174, "substitutes": {"job": ["command", "op", "jump", "config", "gov", "some", "block", "word", "session", "package", "row", "b", "cmd", "jam", "org", "user", "pro", "resource", "message", "layer", "jo", "cor", "task", "jp", "request", "server", "jj", "try", "test", "version", "node", "member", "bug", "ob", "link", "batch", "item", "no", "work", "project", "policy", "image", "req", "meta", "sub", "error", "worker", "cp", "process", "tab", "trace", "failed", "function", "mem", "connection", "plugin", "info", "good", "remote", "line", "comment", "com", "low", "db", "module", "Job", "out", "hub", "obs", "entry", "flag", "trial", "cell", "manager", "event", "build", "to", "sim", "program", "client", "position", "json", "j", "cache", "lock", "pause", "tag", "msg", "group", "name", "store"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}", "idx": 9176, "substitutes": {"bs": ["ms", "obs", "vs", "bf", "qs", "cks", "aos", "bp", "rs", "css", "bas", "hs", "gs", "bes", "bles", "bl", "ps", "bc", "BS", "cs", "bm", "bits", "bytes", "iss", "bsp", "uts", "aus", "js", "ss", "ts", "its", "bos", "lbs", "bps", "ubs", "ubis", "gc", "sb", "b", "bis", "bh", "ns", "fs", "ks", "bb", "blog", "ls", "hz", "ds"], "offset": ["command", "esi", "off", "address", "bf", "et", "buffer", "at", "pointer", "article", "base", "offer", "seek", "range", "area", "sp", "o", "buf", "offs", "pad", "slot", "location", "ano", "pos", "oid", "zero", "position", "unk", "addr", "index", "scroll", "bound", "Offset", " offsets", "count", "origin", "start", "coord", "set", "oss", "loc", "size"], "buf1": ["buff0", "bagOne", "bufA", "bag1", " bufA", "uf1", "buf3", " bufOne", "ufA", "buffer2", "buf2", "buffer0", "buffer1", "buff2", " buf0", "bufOne", "buff3", "bagA", "uf3", "buf0", "uf0", "bag3", "bag0", "buffer3", "uf2", " buf3", "buff1", "buffOne"], "count1": ["comment1", "ount7", "ountPar", " countone", "ount2", " countPar", "counterPar", "Count1", " count2", "counter1", "cache9", "ount0", "countPar", "cacheone", "Count0", "ount1", "comment2", "comment9", " count7", "count7", "counter2", "cache1", "Count2", "Count7", "count0", "count9", "count2", "countone", " count0", "commentone", " count9", "cache2"], "drv": ["rrv", "drf", "rdr", "grj", " drvr", "crf", " drf", "trv", "rdv", " drve", "Drav", " drh", "parvd", "Drvr", "drve", "trvd", "parve", "crvd", "rrr", "rrvd", "drj", "Drv", "Drw", "crv", "drav", "drw", "trve", " drav", "drvr", "drp", "Drp", " drw", "DRav", "crV", "grvd", "rdvd", "drvd", "drh", "trf", "grv", " drV", "DRp", "grr", "drV", "DRw", "parf", "Drh", "DRh", "rdj", "drr", "parv", "DRvr", "rdV", "rdf", " drp", "rrj", "DRv", " drvd"]}}
{"project": "FFmpeg", "commit_id": "44ac13eed49593f4f8efdb72ab0d5b48e05aa305", "target": 1, "func": "int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,\n\n                             int max_size)\n\n{\n\n    uint32_t mrk;\n\n    int i, tmp;\n\n    const uint16_t *ssrc = (const uint16_t *) src;\n\n    uint16_t *sdst = (uint16_t *) dst;\n\n    PutBitContext pb;\n\n\n\n    if ((unsigned) src_size > (unsigned) max_size)\n\n        src_size = max_size;\n\n\n\n    mrk = AV_RB32(src);\n\n    switch (mrk) {\n\n    case DCA_SYNCWORD_CORE_BE:\n\n        memcpy(dst, src, src_size);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_LE:\n\n        for (i = 0; i < (src_size + 1) >> 1; i++)\n\n            *sdst++ = av_bswap16(*ssrc++);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_14B_BE:\n\n    case DCA_SYNCWORD_CORE_14B_LE:\n\n        init_put_bits(&pb, dst, max_size);\n\n        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {\n\n            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;\n\n            put_bits(&pb, 14, tmp);\n\n        }\n\n        flush_put_bits(&pb);\n\n        return (put_bits_count(&pb) + 7) >> 3;\n\n    default:\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n}\n", "idx": 9178, "substitutes": {"src": ["inner", "sq", "obj", "syn", "usc", "sl", "sync", "source", "rb", "rs", "proc", "sub", "bin", "ind", "nt", "RC", "rob", "sec", "th", "cur", "rol", "ins", "hl", "ptr", "raw", "supp", "pri", "usr", "txt", "addr", "ser", "rl", "cont", "sup", "rx", "r", "dest", "impl", "scan", "rc", "tn", "sur", "input", "sb", "pl", "ctr", "comp", "ipl", "ost", "sn", "sel", "str", "sr", "start", "st", "rt", "sc", "img", "ur", "s", "iv", "loc", "inst", "sys"], "src_size": ["source_status", "source_scale", "src10status", "src_loc", "ptr_loc", "source2scale", "ctr_to", "src_loss", "src_name", "ctr09to", "src2scale", "src_pos", "source_size", "src10length", "src2size", "src0size", "src_status", "src_length", "ptr_width", "src_width", "source_to", " src_send", " src2size", "source_name", "src09ize", " src2name", "ctr_size", "rc_size", "source2length", "source_length", "ctr_ize", "src2name", " src_len", "ptr_size", "src_len", "src8ize", "src2status", "src0name", " src_scale", "src_to", "ptr_ize", "src10scale", "ptr_loss", "src2length", "src10size", "src_send", "src8to", "ctr09size", "src_shift", " src_name", "src2send", "ptr_pos", "src09to", "rc_shift", "src0send", "src_start", "src8size", "src09size", "ctr09ize", "src0scale", " src_start", " src2scale", " src2send", "src_scale", "source2size", "rc_length", "source2status", "src_ize"], "dst": ["dsts", "sdist", "Dsts", "sdsts", " dest", "dnt", "drest", " drest", "dsst", " dnt", "Dst", " dsts", "sdrest", "dsbr", "ddest", "pdst", "pdbr", "dpt", "dsist", "pdpt", "dest", " dpt", "sdnt", "dsv", " dv", "dsrc", "sdest", "dssrc", " dbr", " dsrc", "jnt", "pdv", " dist", "jest", "sddest", "dspt", "dist", " ddest", "dsrest", "Dest", "dbr", "sdsrc", "Dbr", "sdbr", "jst", "dv", "jdest"], "max_size": ["maxLengthSize", "maxCapSize", "max_send", "rest_sample", "rest_depth", "max_length", "max_sample", "max2SIZE", "restCapsample", "maxLengthgo", "max_go", "maxmaxgo", "max2length", "maxLengthsize", " max_SIZE", "maxCapsize", "rest_Size", "max_SIZE", "max_depth", "maxCapsample", "MAX_size", " max_range", "maxmaxsize", "max2size", "MAX_SIZE", " max_length", "max2Size", " max_go", "maxingsize", "max_range", "maxCapdepth", "maxmaxrange", "maxingsample", "restCapdepth", "MAX_Size", "max_Size", "maxmaxSize", " max_Size", "MAX_send", "maxingdepth", "maxingSize", "maxLengthrange", "restCapSize", "rest_size", "restCapsize"], "mrk": ["rke", "mnck", " yrkm", "rijk", "mrK", "MRck", "Mrkt", "mnke", "krkk", "mrkk", "vrkk", "vrkid", "krk", "trke", "trkid", "mnkt", " yrijk", "rkm", "mnk", "mrkid", "sprkid", "mrck", "mrke", "MRke", " hrijk", "Mrke", "krkid", "krK", "MRk", "Mrk", "trck", " hrk", "trk", "Mrck", "mrijk", "mnkid", " yrke", " hrkm", "sprK", "vrk", "mrkt", "mrkm", " hrke", "rk", "sprk", "MRkid", "sprkk", "MRkt", " yrk", "vrK"], "i": ["ai", "fi", "I", "io", "me", "PI", "li", "ei", "q", "err", " I", "print", "sim", "f", "ind", "ui", "ni", "ip", "g", "m", "l", "ki", "ti", "ic", "cli", "in", "mi", "index", "is", "chain", "j", "im", "ix", "ir", "y", "t", "ci", "iu", "\u0438", "phi", "v", "zi", "info", "xi", "e", "multi", "b", "qi", "gi", "bi", "di", "ij", "si", "pi", "it", "x", "ini", " ii", "uli", "oi", "hi", " ni", "ims", " j", "dr", "ii"], "tmp": ["tm", "td", "tf", "tt", "obj", "acc", "cmp", "mb", "mm", "pp", " mp", "rb", "uff", "tk", "proc", "uv", "p", "sp", "resp", "prop", "buf", "nt", "nd", "vp", "tc", "np", "wx", "attr", "ptr", "cb", "vt", "txt", "appy", "cont", "snap", "test", "perm", "v", "mk", "cache", "orig", "temp", "mut", "nb", "MP", "buff", "msg", "cv", "mp", "emp", "img"], "ssrc": ["ssrt", "rssrc", " ssync", "cssrt", " sssrc", "sesrc", "ssync", "SSRC", "rssync", "sRC", "cssRC", "ssRC", "ssub", "srt", "cssrc", "ssr", "sesync", "SSrt", "cssr", "rssub", "sssrc", "rsssrc", "sr", " ssub", "sesub", "SSrc", "sessrc", "SSr"], "sdst": ["dsc", "SDest", "SDst", "dsst", "adsp", "dsost", "rdST", "dsp", "rdsc", "adst", "dST", "rdst", "sdsc", "dest", "sdST", "sdest", "rdest", "SDsc", "dssp", "adest", "SDST", "sdsp", "sdost", "dost", "dsest", "adost"], "pb": ["lb", "bj", "pas", "tp", "pc", "pp", "pt", "uf", "bp", "rb", "proc", "p", "sp", "xb", "resp", "amp", " np", "cp", "fp", "ps", "pg", "pad", "vp", "jp", "pkg", "pd", "np", "ap", "cb", "wb", "vt", "orp", "lp", "pm", "px", "pl", "gc", "sb", "tap", "wp", " outp", "dp", "PB", "nb", "gb", "cv", "mp", " xp", "mt", "pa"]}}
{"project": "qemu", "commit_id": "b21da4e504fbdb907543a918b190783dc896d8e1", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;", "idx": 9189, "substitutes": {"xhci": ["xhwci", "xwcci", "xheiti", "xhcs", "xhcci", "wxhcli", "xhtcu", "wxhtpi", "xhlco", " xhlcs", "Xhcci", "xhmi", "xhdcu", "xahpi", "xhpi", "xhspi", " xhmi", "fxhci", "fxhlcu", "xhcm", "xhecci", "Xheci", " xhuci", "xhwpi", "xahci", "xhscs", "xhecli", "xhdcm", "wxhci", "wxhtni", "xhtni", "fxhuci", "xhwni", "xhtco", "xhemi", "Xhcu", "wxhtcli", "xhtcli", "xhecs", "fxhcu", "fxhco", "wxhpi", " xhpi", "Xhecm", "xheci", "fxhlco", " xhlmi", "xheco", "xhsci", " xheiti", "Xhcm", "xhepi", "xhdci", " xhlpi", "xhiti", "xhluci", "xhlmi", "xhlpi", "xbhuci", "wxhni", "xheni", "xhcu", "xbhiti", "xhecu", "xwci", " xhiti", "fxhlci", "xwcm", "xheuci", "Xhci", "Xhecci", "xhlci", "xhni", " xhcs", "xhsmi", "xbhci", "xhcli", "xhwcli", " xheuci", "xhco", "xhdcci", "xhtpi", " xhepi", "xahiti", "fxhluci", "xhtuci", " xheci", "Xhecu", "xbhpi", "xhecm", "xahuci", "xhtci", "xwcu", " xhlci", "xhlcs", "xhlcu", "xhuci", "wxhtci"], "slotid": ["snapno", "shotlen", "slotd", "slotID", "lotlen", "shotmd", "snapname", "snapid", "lotname", "spotd", "snapId", "shotId", "shotno", "spotname", "spotno", "lotd", "slotname", "spoth", "slotmd", "slotno", "lotID", "spotid", "sloth", " slotId", "lotmd", "slotlen", " slotname", " slotno", " slotd", "spotId", "shotname", " sloth", "loth", "shotoid", "spotoid", "shotid", "spotmd", "lotno", " slotoid", "lotId", "slotId", "spotlen", "slotoid", "lotid", "lotoid", "spotID", " slotID"], "epid": ["eqtry", "peension", "epID", "ekension", "eghide", "ekkind", "ipID", "ekty", "epend", "expid", "epno", "EPno", "lipty", "mpId", "eeide", "liphide", "ecid", "eckind", "epkind", " epID", "ekid", "mpID", " epend", "espkind", "ekhide", "eqide", "epcode", "eqid", "eehide", "espension", "egcode", "eknum", "ekmid", "egend", "escide", "ecend", "EpID", "estide", "Epkey", "eeension", "ephide", "EPId", "expID", "epkid", "EPid", "esctry", "ekkey", "mpno", "ecID", "peide", " eppid", "lipcode", "estension", "epension", "eptry", " epmid", "ekcode", "peid", "epty", "esphide", "epmid", "ippid", " epnum", "escID", "ectry", "egID", "espID", "estID", "EPID", "expkid", "egid", "expmid", "eeid", "pehide", "ecide", "espend", " epkey", "estid", "lipid", "escid", "epkey", "Epid", "ekkid", "ekend", "epId", " epId", "esthide", "epnum", " epno", "eqID", "mpid", "egty", "ekID", "epide", "ipid", "Epnum", "ipend", " epkid", "egpid", "espid", "eppid"], "slot": ["zo", "entry", "sl", "part", "pointer", "pt", "section", "ct", "spot", "role", "module", "sp", "point", "pool", "p", "profile", "unit", "job", "nt", "sector", "scope", "label", "second", "pos", "service", "timeout", "zero", "null", "tab", "port", "session", "loop", "shot", "scroll", "ser", "snap", "sid", "bit", "share", "boot", "storage", "plugin", "zone", "site", "Slot", "pot", "binding", "option", "slice", "table", "piece", "batch", "room", "usage", "set", "lot", "soc", "space", "vol", "hit", "pod"], "epctx": ["apcmd", "espctx", "epcmp", "apectx", " epcmp", "espcontext", "apefunc", "evctx", "eqtx", "apcontext", "eqctx", "eqcontext", "ekctx", "esptx", "epscontext", "epcmd", "ekcmp", "evcontext", "epfunc", "epcontext", "liptx", "EPcmd", "espkw", "apetx", "ekcfg", "apecmp", "espfunc", "apcmp", "epscmd", "lipcmp", "lipcfg", "epscmp", "epstx", "epcfg", "espcmp", "evkw", "EPcontext", "epsfunc", "lipctx", "ethtx", "ethcontext", "epskw", "Epctx", "Eptx", "ektx", "EPctx", "ekcmd", "EPtx", "eptx", "ethcmd", "Epcfg", "ethctx", "eqcmp", " eptx", "evtx", "Epcmp", "epscfg", "eqcmd", "epsctx", " epcfg", "apctx", "epkw"], "i": ["ai", "fi", "I", "io", "li", "ei", " I", "p", "ip", "m", "ki", " pi", "ti", " ti", "mi", "j", "ci", "phi", "v", " v", "bi", "di", "pi", "si", " ii", " bi", " j", "ii"]}}
{"project": "qemu", "commit_id": "bc3e6a0d6c8ab6cd7cd4b576ed567756f1dcabd2", "target": 1, "func": "int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n", "idx": 9193, "substitutes": {"bus": ["usb", "bank", "hand", "board", " BUS", "cus", "back", "BUS", "ack", "book", "buf", "bc", "mount", "cat", "block", "US", "Bus", "way", " board", "port", "bs", "us", "chain", "boot", "box", "uses", "lock", "controller", "bug", "piece", "driver", "bar", "card", "bur", "jack", "bridge"]}}
{"project": "qemu", "commit_id": "679aa175e84f5f80b32b307fce5a6b92729e0e61", "target": 0, "func": "static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    uint32_t res;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n    int cm;\n\n    int mask;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    cm = 1 << cpu;\n\n    if (offset < 0x100) {\n\n        if (offset == 0)\n\n            return s->enabled;\n\n        if (offset == 4)\n\n            /* Interrupt Controller Type Register */\n\n            return ((s->num_irq / 32) - 1)\n\n                    | ((NUM_CPU(s) - 1) << 5)\n\n                    | (s->security_extn << 10);\n\n        if (offset < 0x08)\n\n            return 0;\n\n        if (offset >= 0x80) {\n\n            /* Interrupt Group Registers: these RAZ/WI if this is an NS\n\n             * access to a GIC with the security extensions, or if the GIC\n\n             * doesn't have groups at all.\n\n             */\n\n            res = 0;\n\n            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {\n\n                /* Every byte offset holds 8 group status bits */\n\n                irq = (offset - 0x080) * 8 + GIC_BASE_IRQ;\n\n                if (irq >= s->num_irq) {\n\n                    goto bad_reg;\n\n                }\n\n                for (i = 0; i < 8; i++) {\n\n                    if (GIC_TEST_GROUP(irq + i, cm)) {\n\n                        res |= (1 << i);\n\n                    }\n\n                }\n\n            }\n\n            return res;\n\n        }\n\n        goto bad_reg;\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Set/Clear Enable.  */\n\n        if (offset < 0x180)\n\n            irq = (offset - 0x100) * 8;\n\n        else\n\n            irq = (offset - 0x180) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Set/Clear Pending.  */\n\n        if (offset < 0x280)\n\n            irq = (offset - 0x200) * 8;\n\n        else\n\n            irq = (offset - 0x280) * 8;\n\n        irq += GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (gic_test_pending(s, irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;\n\n        for (i = 0; i < 8; i++) {\n\n            if (GIC_TEST_ACTIVE(irq + i, mask)) {\n\n                res |= (1 << i);\n\n            }\n\n        }\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = GIC_GET_PRIORITY(irq, cpu);\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target.  */\n\n        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {\n\n            /* For uniprocessor GICs these RAZ/WI */\n\n            res = 0;\n\n        } else {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_EDGE_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xf10) {\n\n        goto bad_reg;\n\n    } else if (offset < 0xf30) {\n\n        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n            goto bad_reg;\n\n        }\n\n\n\n        if (offset < 0xf20) {\n\n            /* GICD_CPENDSGIRn */\n\n            irq = (offset - 0xf10);\n\n        } else {\n\n            irq = (offset - 0xf20);\n\n            /* GICD_SPENDSGIRn */\n\n        }\n\n\n\n        res = s->sgi_pending[irq][cpu];\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else /* offset >= 0xfe0 */ {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    qemu_log_mask(LOG_GUEST_ERROR,\n\n                  \"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9210, "substitutes": {"opaque": ["opressed", "iopque", "iopatile", "obressed", "oplaque", "OPce", " opressed", "opque", "iopce", " opatile", "obatile", "OPaque", " opce", "oplatile", "opce", "oplressed", "obaque", "oplacity", " opacity", " opque", "obacity", "OPatile", "iopaque", "OPque", "opatile", "opacity"], "offset": ["button", "command", "reset", "prefix", "offer", "range", "o", "slot", "tile", "location", "atomic", "queue", "attribute", "bound", "row", "amount", "data", "always", "option", "dt", "output", "key", "next", "frequency", "address", "article", "et", "message", "notation", "OFF", "original", "ptr", "after", "layout", "scroll", "ta", "Offset", "table", "batch", "item", "esi", "shift", "id", "url", "buffer", "image", "err", "meta", "point", "error", "pos", "ref", "timeout", "window", "filter", "term", "index", "now", "zone", "start", "module", "loc", "style", "mt", "empty", "off", "entry", "pointer", "padding", "base", "flag", "seek", "p", "pool", "topic", "offs", "pad", "fp", "operation", "position", "handle", "addr", "alt", "adjusted", "h", "origin", "kernel", "set", "usage", "tz"], "attrs": ["attsRS", " attRS", "matr", "attributes", "attRS", "Attr", "attrd", "matributes", "attsributes", " attributes", "Attrd", "matrs", "AttRS", "attr", " attr", "Attributes", "Attrs", "attsrd", " attls", "attls", " attrd", "attsrs", "Attls", "matls"], "s": ["ms", "vs", "ats", "hs", "m", "cs", "bits", "ins", "details", "r", "se", "t", "sports", "os", "b", "sa", "serv", "comm", "ims", "status", "source", "settings", "gs", "sts", "changes", "g", "sv", "ses", "sam", "xs", "bs", "als", "js", "less", "ss", "sets", "sb", "z", "ls", "states", "state", "sq", "obj", "spec", "sl", "qs", "a", "rs", "sm", "l", "es", "ts", "n", "sw", "ns", "ds", "p", "ps", "aws", "is", "S", "its", "ssl", "self", "v", "c", "bis", "h", "stats", "fs", "x", "set", "sys", "store"], "res": ["ms", "arr", "cons", "reset", "pas", "sol", "resolution", "rs", "req", "ires", "resp", "hash", "rep", "Res", "ps", "gr", "rev", "vec", "ref", "bits", "ins", "bs", "expr", "pres", "RES", "r", "js", "rel", "details", "cond", "__", "rem", "reg", "conf", "fr", "ress", "val", "red", "results", "rest", " results", "re", " ret", "vals", "rss", "resh", "result", "msg", " Res", "rez", "response", "conv", "resources", "out", "ret"], "irq": ["virke", " irquire", "irtqq", "mrch", " irque", "ierqueue", "ironiq", "yrqueue", "rircache", "vircu", "irch", "irqual", "arch", "pirqual", "irqs", "rrqu", "rirqu", "mirqi", "rirquest", "rirquer", "ardq", "yrqu", "ibrqi", "ironqu", "pirqueue", "irtcharge", "pirqu", "pirquery", "ibrqu", "pirqq", "virtke", "ironresh", "iracharge", "mirq", "irresh", "rirresh", "iroqu", "ironcu", " irch", "irforce", "rirqual", "ironch", " irqu", "iraf", "pirch", "iterque", "rirq", "irdq", "mirqu", "rirf", "ibrqueue", "iroqueue", "pirf", "yrqi", "irqi", "arque", " irquery", "iriquire", "ierforce", "pirq", "pirresh", "viriq", "iorq", "ierqa", "pirqi", "mirqueue", "mrqu", " irdq", "ierq", "virq", "iterdq", "irtque", "ibrq", "ieraq", "iriq", "irg", "iriforce", "rirqs", "virtq", "irtq", "rirqq", "irquer", "arqu", "irich", "irtqu", "irtqueue", "ircu", "iriquery", "rrq", "rirqueue", "iraqual", "irqu", "rirch", "irqa", "rirqi", "iriaq", "ironke", "pirquer", "ierquer", "irquest", "rrg", "pirg", "iterqu", "yrq", "irque", " iraq", "iorquery", "iorqs", "ircache", "iracache", "irquery", "irtcache", "iorquest", "rirqa", "rircharge", " irforce", "irtqi", "pirqs", "mrq", "rrque", "iterq", "rirquery", "arqi", "iroqi", "pirqa", "irqueue", "virtcu", "iroq", "irke", "mrqi", "pirquest", "pirque", "iraqq", "arq", "ironq", "irtg", "pirquire", "virtiq", "irqq", "ierquire", "irf", "iraq", "ircharge", "irquire"], "i": ["ms", "ami", "id", "u", "ai", "fi", "I", "io", "me", "li", "ei", "uri", "q", "init", "p", "o", "sim", "ex", "ind", "ui", "ni", "this", "ip", "docker", "m", "l", "my", "ki", "ji", "ti", "ic", "cli", "in", "us", "mi", "index", "r", "MI", "j", "im", "ix", "ter", "y", "iu", "ci", "\u0438", "zi", "v", "phi", "xi", "qi", "multi", "c", "gi", "di", "bi", "pi", "si", "it", "x", "php", "ini", "oi", "yi", "ims", "ori", "ii", "ico"], "cpu": ["nice", "nic", "num", "current", "u", "cum", "pc", "mx", "gpu", "ilo", "buffer", "tp", "base", "processor", "device", "ile", "ct", "nu", "proc", "p", "cp", "pu", "ram", "cs", "m", "process", "l", "util", " CPU", "mu", "core", "CPU", "mem", "us", "clock", "total", "n", "ctx", "count", "gc", "c", "cn", "cu", "memory"], "cm": ["ms", "pc", "nm", "mx", "cmp", "mm", "ch", "mult", "gm", "cam", "asm", "cut", "fine", "CM", "cp", "fm", "mic", "ram", "cr", "m", "cs", "bm", "tc", "chrom", "mr", "mn", "mem", "mi", "pm", "mc", "mode", "perm", "ctx", "rem", "conf", "lc", "fr", "gc", "cache", "ctr", "c", "com", "cmd", "cms", "batch", "comm", "memory", "co", "km", "module", "rom", "ca"], "mask": ["ms", "clear", "key", "aps", "locks", "reset", "map", " bits", "weight", "ack", "hash", "ps", "bits", "zero", "bit", "RES", "final", "conf", "cache", "ress", "lock", "flags", "fs", "ask", "resh", "share", "sk"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                      target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int ds, pr, target_page_bits;\n\n    int ret;\n\n    target_ulong sr, pgidx;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n\n\n    sr = env->sr[eaddr >> 28];\n\n    ctx->key = (((sr & 0x20000000) && (pr != 0)) ||\n\n                ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;\n\n    ds = sr & 0x80000000 ? 1 : 0;\n\n    ctx->nx = sr & 0x10000000 ? 1 : 0;\n\n    vsid = sr & 0x00FFFFFF;\n\n    target_page_bits = TARGET_PAGE_BITS;\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"Check segment v=\" TARGET_FMT_lx \" %d \" TARGET_FMT_lx\n\n            \" nip=\" TARGET_FMT_lx \" lr=\" TARGET_FMT_lx\n\n            \" ir=%d dr=%d pr=%d %d t=%d\\n\",\n\n            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,\n\n            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);\n\n    pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;\n\n    hash = vsid ^ pgidx;\n\n    ctx->ptem = (vsid << 7) | (pgidx >> 10);\n\n\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n            \"pte segment: key=%d ds %d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ds, ctx->nx, vsid);\n\n    ret = -1;\n\n    if (!ds) {\n\n        /* Check if instruction fetch is allowed, if needed */\n\n        if (type != ACCESS_CODE || ctx->nx == 0) {\n\n            /* Page address translation */\n\n            qemu_log_mask(CPU_LOG_MMU, \"htab_base \" TARGET_FMT_plx\n\n                    \" htab_mask \" TARGET_FMT_plx\n\n                    \" hash \" TARGET_FMT_plx \"\\n\",\n\n                    env->htab_base, env->htab_mask, hash);\n\n            ctx->hash[0] = hash;\n\n            ctx->hash[1] = ~hash;\n\n\n\n            /* Initialize real address with an invalid value */\n\n            ctx->raddr = (hwaddr)-1ULL;\n\n            /* Software TLB search */\n\n            ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n\n#if defined(DUMP_PAGE_TABLES)\n\n            if (qemu_loglevel_mask(CPU_LOG_MMU)) {\n\n                CPUState *cs = ENV_GET_CPU(env);\n\n                hwaddr curaddr;\n\n                uint32_t a0, a1, a2, a3;\n\n\n\n                qemu_log(\"Page table: \" TARGET_FMT_plx \" len \" TARGET_FMT_plx\n\n                         \"\\n\", env->htab_base, env->htab_mask + 0x80);\n\n                for (curaddr = env->htab_base;\n\n                     curaddr < (env->htab_base + env->htab_mask + 0x80);\n\n                     curaddr += 16) {\n\n                    a0 = ldl_phys(cs->as, curaddr);\n\n                    a1 = ldl_phys(cs->as, curaddr + 4);\n\n                    a2 = ldl_phys(cs->as, curaddr + 8);\n\n                    a3 = ldl_phys(cs->as, curaddr + 12);\n\n                    if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n\n                        qemu_log(TARGET_FMT_plx \": %08x %08x %08x %08x\\n\",\n\n                                 curaddr, a0, a1, a2, a3);\n\n                    }\n\n                }\n\n            }\n\n#endif\n\n        } else {\n\n            qemu_log_mask(CPU_LOG_MMU, \"No access allowed\\n\");\n\n            ret = -3;\n\n        }\n\n    } else {\n\n        target_ulong sr;\n\n\n\n        qemu_log_mask(CPU_LOG_MMU, \"direct store...\\n\");\n\n        /* Direct-store segment : absolutely *BUGGY* for now */\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log_mask(CPU_LOG_MMU, \"ERROR: instruction should not need \"\n\n                          \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 9215, "substitutes": {"env": ["doc", "era", "obj", "ef", "tx", "ah", "net", "map", "config", "et", "network", "ei", "eh", "end", "here", "manager", "enc", "ev", "den", "erd", "proc", "uv", "ec", "dev", "eni", "worker", "eng", "open", "np", "te", "Environment", "desc", "vt", "window", "en", "ext", "inv", "ew", "equ", "vm", "node", "esc", "neck", "conn", "v", "conf", "esp", "init", "environment", "e", "setup", "cmd", "kh", "hw", "org", "context", "param", "db", "cv", "disk", "ner", "ez", "exc", "nv"], "ctx": ["jac", "ck", "obj", "tx", "fw", "cmp", "ctrl", "crit", " cx", "tk", "req", "ct", "event", "init", "alloc", "k", "proc", "func", "kt", "p", "resp", " context", "buf", "tz", "cp", "Context", "cf", "worker", "xc", "act", "bc", "dc", "jp", "tc", "np", "pkg", "this", "wx", "cb", "ctl", "cc", "ka", "txt", "index", "qt", "j", "aux", "cas", "conn", "check", "conf", "mk", "gc", "cache", "c", "tmp", "cmd", "kh", "rt", "kw", "cm", "nc", "cu", "fc", "x", "coord", "context", "msg", "co", "cv", "loc", "conv", "ca"], "eaddr": ["eddDR", "awdr", " xDR", "eadhr", "awhr", " dwdr", "inaldr", "expressdriver", " dwDR", "eaddriver", "expressstr", "ezder", "eadder", "ellDr", "ewdr", "eddr", "ewder", "eadr", "ezdriver", "adDr", "oadder", "awr", "eadDR", "ezstr", "eddder", "ezdr", "ekr", "inalr", "ekdr", " dwptr", "adr", "addr", "oadr", "ekDr", "eddstr", " xdr", "ellDR", "eadptr", "ewstr", " xder", "edddr", "oadDR", "adstr", "ewDR", "ellstr", "ekhr", "edddriver", "inalhr", "elldr", "awder", "ewptr", "ekder", "oaddr", " xptr", "eadDr", "oadstr", "ellder", "expressder", "eadstr", "oadDr", "inalder", "expressdr", " dwder", "eddDr"], "rw": ["ow", "dd", "hr", "write", "rb", "wr", "dx", "wx", "rn", "mr", "raw", " wr", "usr", "ew", "writ", "rl", "row", "rx", "dq", "wn", "wd", "rd", "nr", "aw", "dir", "wp", "sw", "RW", "rew", "hw", "w", "rt", "kw", "tw", "vr", "dt", "writer", "nw", "wb"], "type": [" ty", "op", "typ", "tp", "pe", "pc", "status", "ty", "ping", "types", "role", "sp", "p", "error", " typ", "TYPE", "ptr", "ver", "kind", "try", "r", "top", "Type", "test", "y", "like", "t", "state", "count", "info", "ype", "pro", "rt", "rule", "sys", "er", "time", "name", "dt", "size", "style", "mt", "ico"], "hash": ["key", "ash", "Hash", "shift", "tr", "hr", "id", "ah", "tx", "sum", "ch", "err", "hz", "ref", "hd", "ptr", "her", "shr", "oh", "usr", "handle", "addr", "alt", "mem", "index", "r", "md", "data", "sha", "ha", "chip", "has", "host", "sh", "h", "kh", "bh", "str", "res", "tag", "alias", "dh", "name", "size", "dr"], "vsid": ["VsID", "obsId", "dsID", "tsid", "fsid", "obsip", "obsmid", "vsident", "imskid", "obsident", "vsip", "nskid", "vside", "Vsid", "vskid", "vsID", "lsID", "obsid", "obskid", "rsId", "valsid", "tside", "dsid", "rsip", "valsId", " vskid", "rskid", "valsID", "vsmid", " vsID", "rsids", "fsId", "rsID", " vside", "lsids", "nsId", "vsId", "lsid", "nsident", "dsId", "VsId", "rsmid", "nsID", "tsID", "rsid", "vsids", "fsmid", "tskid", "nsid", "imsID", "rsident", "imside", "lsId", "imsid", "valsids", "fsip"], "ds": ["src", "dd", "fd", "eps", "DS", "rs", "keys", "gs", "dev", "ps", "d", "dc", "dx", "pd", "hd", "ptr", "xs", "bs", "bytes", "Ds", "addr", "js", "ys", "ts", "rows", "dq", "dl", "conn", "os", "der", "uds", "ns", "des", "ks", "dp", "db", "ls", "s", "dh", "sd", "dt", "dr", "eds", "sys"], "pr": ["kr", "tr", "hr", "typ", "pc", "pat", "pt", "lr", "rs", "per", "p", "rep", "ps", "wr", "ptr", "mr", "por", "rr", "ver", "expr", "ser", "r", "repl", "fr", "pl", "PR", "pol", "pro", "po", "spr", "Pr", "rer", "vr", "cr", "pir", "price", "dr", "pa"], "target_page_bits": ["target_pool__bit", "target_Page_locks", "target_pool_bit", "target_page_its", "target_page_points", "target_page__bit", "target_Page_its", "target_pool__bytes", "target_page__bits", "target_page_bytes", "target_Page_flags", "target_pool_bits", "target_page_locks", "target_Page_bits", "target_page__points", "target_pool__bits", "target_page__bytes", "target_Page_bytes", "target_page_bit", "target_pool__points", "target_page_flags", "target_pool_points", "target_pool_bytes"], "ret": ["len", "lit", "lt", "read", "flag", "pt", "err", "RET", "ry", "nt", "rev", "ref", " Ret", "def", "mt", "alt", "mem", "try", "rel", "ts", "t", "val", "Ret", "rt", "re", "elt", "res", "result", "att", "get", "gt", "set", "dt", "ft", "out"], "sr": ["src", "kr", "tr", "hr", "ear", "sl", "sol", "lr", "rb", "rs", "SR", "sp", "rf", "sts", "gr", "rn", "sv", "mr", "shr", "rr", "adr", "usr", "ser", "r", "rl", "rx", "ir", "rg", "ssl", "rc", "nr", "radius", "fr", "sur", "sb", "ctr", "sa", "sy", "rin", "sn", "rt", "spr", "serv", "rm", " sy", "vr", "cr", "rar", "ar", "dr"], "pgidx": ["pgIdn", "pgpidxc", "pgdd", "pgidentxs", "pginX", "PGIdx", "pgdex", "pgsidx", "pgidn", "pgidxs", " pghidez", "pgdX", "pgIdx", "pgpidxs", "pgidex", " pghideX", "PGidx", " pgidX", "pghidex", " pgidix", "pgdn", "PGIdxs", " pgidz", "pgIdd", "PGidxs", "pghideix", " pghidex", "pgidd", "PGIdex", "pgidentxc", "pgpidx", "pgidentx", "pgdz", "pgIdex", "pegidd", "pegsidz", " pghideix", "PGidxc", "pgidz", "pgmidX", "pgIdX", "pgidentz", "pghidez", "pgmidex", "PGIdz", "pegsidx", "PGIdxc", "pgidxc", "pgIdxc", "pgidix", "pgpidX", "pgsidd", "pginz", "pgsidn", "pgpidz", "pegidz", "pegidx", "pegsidd", "pginx", "pgIdxs", "PGIdX", "pghideX", "pgpidix", "pegidn", "pgmidx", "pginix", "pgmidz", "pgidX", "pgIdz", "pegsidn", "PGidX", "PGidz", "PGidex", "pgdx", "pgsidz"]}}
{"project": "qemu", "commit_id": "df3c286c53ac51e7267f2761c7a0c62e11b6e815", "target": 0, "func": "static void slirp_socket_save(QEMUFile *f, struct socket *so)\n\n{\n\n    qemu_put_be32(f, so->so_urgc);\n\n    qemu_put_be16(f, so->so_ffamily);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_faddr.s_addr);\n\n        qemu_put_be16(f, so->so_fport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_faddr and so_fport\\n\");\n\n    }\n\n    qemu_put_be16(f, so->so_lfamily);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_laddr.s_addr);\n\n        qemu_put_be16(f, so->so_lport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_laddr and so_lport\\n\");\n\n    }\n\n    qemu_put_byte(f, so->so_iptos);\n\n    qemu_put_byte(f, so->so_emu);\n\n    qemu_put_byte(f, so->so_type);\n\n    qemu_put_be32(f, so->so_state);\n\n    slirp_sbuf_save(f, &so->so_rcv);\n\n    slirp_sbuf_save(f, &so->so_snd);\n\n    slirp_tcp_save(f, so->so_tcpcb);\n\n}\n", "idx": 9225, "substitutes": {"f": ["fab", "tf", "off", "fd", "fw", "bf", "fi", "fo", "uf", "q", "ile", "ff", "fff", "k", "file", "form", "p", "rf", "o", "field", "fp", "cf", "fm", "d", "g", "l", "fb", "um", "lf", "through", "fn", "y", "t", "ac", "of", "new", "v", "conf", "fr", "sf", "e", "b", "c", "fac", "h", "F", "w", "fs", "fc", "it", "x", "full", "fx", "z", "ft", "out", "af", "xf"], "so": ["ow", "So", "lah", " o", "py", "je", "ko", "ge", "sync", "sl", "sum", " fo", "go", "inho", "ve", "shi", "iso", "o", "whe", "problem", "ku", "ne", "dev", "ld", "th", "mo", "sing", "sam", "yes", "ho", "oh", "ste", "oso", "stone", "wh", "ka", "usr", "stro", "cho", "oto", "ss", "ski", "se", "ssl", "one", "bo", "rh", "since", "os", " se", "sw", "sh", "sie", "sa", "sy", "sel", "esh", "ro", "si", "oooo", "tw", "hi", "lo", "no", "soc", "pro", "SO", "su", " co", "ico"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n", "idx": 9231, "substitutes": {"obj": ["src", "op", "obs", "id", "typ", "ie", "Obj", " ob", "o", "od", "nt", "ox", "pkg", "pos", "ref", "object", "attr", "js", "data", "ctx", "self", "tmp", "cmd", "elt", "ob", "db", "inst"], "name": ["col", "NAME", "key", "len", "nm", "read", "names", "nam", "p", "var", "prop", "nt", "type", "ame", "attr", "def", "word", "mem", "data", "n", "old", "cmd", "str", "ns", "w", "Name", "no"], "val": ["lit", "tx", "lib", "value", "var", "buf", "seq", "ref", "Val", "def", "values", "txt", "mem", "eval", "rel", "test", "data", "ctx", "v", "pr", "sel", "res", "serv", "vals", "item", "el", "ret"], "errp": ["errpa", "errP", "irP", " errps", "irps", "erp", "irp", "errps", " errpa", "erpa", "erP", "erps", " errP", "irpa"]}}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n", "idx": 9238, "substitutes": {"ctx": ["jac", "ck", "obj", "tx", "cmp", "pc", "abc", " cx", "req", "ct", "wk", "k", "kt", "Context", "cp", "cf", "bc", "dc", "jp", "tc", "pkg", "wx", "cb", "xs", "cc", "cpp", "kl", "mc", "conn", "lc", "mk", "gc", "c", "anc", "cmd", "kh", "hw", "nc", "kw", "sc", "context", "mom", "loc", "ca", "ij"], "i": ["ms", " m", "print", "span", "m", " pi", " multi", " x", "im", "y", "ci", "zi", " mi", "gi", " c", "pi", "ji", "asi", " axis", "ami", " wi", "I", "li", "uri", "init", "ri", "ex", "ind", "g", "ki", "ti", " key", " ti", "mi", "ix", " l", "xi", "multi", "qi", " index", "si", " y", "id", "ai", "ei", "point", "ui", "ip", "ic", "\u0438", " all", "phi", "gu", "it", " bi", " iter", "ii", "fi", "me", " I", "p", "sim", " n", "this", " bit", "cli", "us", "is", "iu", "di", "bi", "x", " err", " ii", " j", "ij"], "output": ["command", "page", "display", "next", "success", "current", "net", "op", "config", "buffer", "network", "write", "column", "message", "document", "put", "update", "print", "web", "export", "list", "four", "module", "o", "error", "component", "operation", "block", "other", "control", "client", "position", "filter", "all", "queue", "bit", "outer", "blue", "Output", "total", "connection", "view", "collection", "new", "sort", "hidden", "cache", "input", "product", "option", "results", "rule", "temp", "dot", "result", "batch", "see", "public", "dict", "console", "coin", "answer", "response", "no", "work", "out", "store"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstV, dstU, src1, width);\n\n}\n", "idx": 9246, "substitutes": {"dstU": ["dsrcUI", "rstV", "dsrcV", "rstU", "rstUV", "rstC", "DstP", "DstUI", "dptC", "rptU", "DstV", "DndV", "DndP", "DndUI", "dsrcU", "dndV", "ddestP", "dsrcUV", "rptUV", "ddestV", "dptUV", "dndUI", "dstUI", "dndP", "DstU", "dptV", "dstC", "dstP", "ddestU", "dndUV", "dstUV", "dsrcP", "dptU", "rptC", "dndU", "dsrcC", "ddestUI", "dndC", "rptV", "DndU"], "dstV": ["dsrcV", "DestV", "destU", "dsrcI", "DestUV", "DstV", " dstG", "dvU", "dstG", "destVC", " dstI", "distUV", "destV", "dnaUV", "dsrcU", "dvV", "dnaV", "dndV", "DestVC", " dsrcU", "dsrcG", "DstU", "distV", "dvG", "destUV", "dstI", "DstVC", "dstUV", "distU", " dsrcG", "dndU", "dnaVC", " dsrcV", " dsrcI", "DstUV", "dndI", "dvI", "dnaU", "distVC", "dndG", "dstVC", "DestU"], "src1": ["source2", "usr01", "rc1", "usr0", "src01", " src0", "src0", " src01", "source1", "rc0", "usr1", "rc2", "source01", "source0", "rc01", "usr2"], "src2": ["rc1", "rc3", "srcB", " srcB", "rc2", "source3", "source2", " src3", "src3", "sourceB", "source1", "rcB"], "unused": ["unalUsed", "unaluse", "unUsed", " unavailable", "UnUsed", " unuse", "unalavailable", "unuse", "Unused", "Unavailable", " unUsed", "unalused", "Unuse", "unavailable"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t lan9118_readl(void *opaque, target_phys_addr_t offset,\n\n                              unsigned size)\n\n{\n\n    lan9118_state *s = (lan9118_state *)opaque;\n\n\n\n    //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset);\n\n    if (offset < 0x20) {\n\n        /* RX FIFO */\n\n        return rx_fifo_pop(s);\n\n    }\n\n    switch (offset) {\n\n    case 0x40:\n\n        return rx_status_fifo_pop(s);\n\n    case 0x44:\n\n        return s->rx_status_fifo[s->tx_status_fifo_head];\n\n    case 0x48:\n\n        return tx_status_fifo_pop(s);\n\n    case 0x4c:\n\n        return s->tx_status_fifo[s->tx_status_fifo_head];\n\n    case CSR_ID_REV:\n\n        return 0x01180001;\n\n    case CSR_IRQ_CFG:\n\n        return s->irq_cfg;\n\n    case CSR_INT_STS:\n\n        return s->int_sts;\n\n    case CSR_INT_EN:\n\n        return s->int_en;\n\n    case CSR_BYTE_TEST:\n\n        return 0x87654321;\n\n    case CSR_FIFO_INT:\n\n        return s->fifo_int;\n\n    case CSR_RX_CFG:\n\n        return s->rx_cfg;\n\n    case CSR_TX_CFG:\n\n        return s->tx_cfg;\n\n    case CSR_HW_CFG:\n\n        return s->hw_cfg;\n\n    case CSR_RX_DP_CTRL:\n\n        return 0;\n\n    case CSR_RX_FIFO_INF:\n\n        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);\n\n    case CSR_TX_FIFO_INF:\n\n        return (s->tx_status_fifo_used << 16)\n\n               | (s->tx_fifo_size - s->txp->fifo_used);\n\n    case CSR_PMT_CTRL:\n\n        return s->pmt_ctrl;\n\n    case CSR_GPIO_CFG:\n\n        return s->gpio_cfg;\n\n    case CSR_GPT_CFG:\n\n        return s->gpt_cfg;\n\n    case CSR_GPT_CNT:\n\n        return ptimer_get_count(s->timer);\n\n    case CSR_WORD_SWAP:\n\n        return s->word_swap;\n\n    case CSR_FREE_RUN:\n\n        return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start;\n\n    case CSR_RX_DROP:\n\n        /* TODO: Implement dropped frames counter.  */\n\n        return 0;\n\n    case CSR_MAC_CSR_CMD:\n\n        return s->mac_cmd;\n\n    case CSR_MAC_CSR_DATA:\n\n        return s->mac_data;\n\n    case CSR_AFC_CFG:\n\n        return s->afc_cfg;\n\n    case CSR_E2P_CMD:\n\n        return s->e2p_cmd;\n\n    case CSR_E2P_DATA:\n\n        return s->e2p_data;\n\n    }\n\n    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);\n\n    return 0;\n\n}\n", "idx": 9255, "substitutes": {"opaque": ["iopque", "pque", "paco", "oplaque", "opaques", "oppade", "opque", "opaco", " opade", "iopaques", " opaques", "opade", "iopaco", "oppaques", "paque", "oplaques", "oplaco", "oplade", "oppaque", " opque", "oplque", "oppque", "paques", "iopaque"], "offset": ["align", "command", "shift", "len", "empty", "op", "off", "address", "buffer", "pointer", "padding", "base", "seek", "alloc", "range", "area", "sp", "point", "o", "tz", "into", "pad", "slot", "offs", "SIZE", "location", "operation", "block", "pos", "ref", "object", "oid", "timeout", "position", "length", "window", "tif", "addr", "index", "bound", "row", "transfer", "attribute", "data", "Offset", "count", "os", "from", "kh", "origin", "start", "slice", "set", "style"], "size": ["align", "shift", "len", "num", "address", "sum", "message", "sp", "Size", "SIZE", "type", "window", "ize", "mem", "amount", "n", "count", "e", "start", "fee", "z", "set", "name", "length"], "s": ["ms", "vs", "ats", "hs", "cs", "bits", "ins", "details", "im", "rows", "ials", "t", "ands", "ties", "os", "b", "alls", "sa", "comm", "rates", "ims", "resses", "eds", "ers", "ports", "acts", "tests", "sp", "gs", "sts", "bes", "ess", "changes", "ables", "ies", "sv", "args", "ses", "sam", "umps", "xs", "bs", "less", "js", "als", "erences", "ss", "grades", "conf", "sb", "des", "ests", "sis", "ls", "states", "itions", "aces", "sq", "ists", "spec", "sl", "qs", "a", "rs", "as", "izes", "sm", "ants", "dates", "es", "store", "ts", "ations", "ns", "ions", "tes", "ds", "ments", "comments", "sol", "ords", "p", "an", "ps", "south", "ains", "aws", "is", "j", "S", "its", "ries", "ches", "c", "bis", "h", "stats", "fs", "ing", "sys", "parts"]}}
{"project": "FFmpeg", "commit_id": "c94d551ea7b39c4e467e146cd347c407e8eb38ee", "target": 0, "func": "static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride)\n\n{\n\n    PixletContext *ctx = avctx->priv_data;\n\n    GetBitContext *b = &ctx->gbit;\n\n    unsigned cnt1, nbits, k, j = 0, i = 0;\n\n    int64_t value, state = 3;\n\n    int rlen, escape, flag = 0;\n\n\n\n    while (i < size) {\n\n        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);\n\n\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 < 8) {\n\n            value = show_bits(b, nbits);\n\n            if (value <= 1) {\n\n                skip_bits(b, nbits - 1);\n\n                escape = ((1 << nbits) - 1) * cnt1;\n\n            } else {\n\n                skip_bits(b, nbits);\n\n                escape = value + ((1 << nbits) - 1) * cnt1 - 1;\n\n            }\n\n        } else {\n\n            escape = get_bits(b, 16);\n\n        }\n\n\n\n        value = -((escape + flag) & 1) | 1;\n\n        dst[j++] = value * ((escape + flag + 1) >> 1);\n\n        i++;\n\n        if (j == width) {\n\n            j = 0;\n\n            dst += stride;\n\n        }\n\n        state = 120 * (escape + flag) + state - (120 * state >> 8);\n\n        flag = 0;\n\n\n\n        if (state * 4 > 0xFF || i >= size)\n\n            continue;\n\n\n\n        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;\n\n        escape = av_mod_uintp2(16383, nbits);\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 > 7) {\n\n            rlen = get_bits(b, 16);\n\n        } else {\n\n            value = show_bits(b, nbits);\n\n            if (value > 1) {\n\n                skip_bits(b, nbits);\n\n                rlen = value + escape * cnt1 - 1;\n\n            } else {\n\n                skip_bits(b, nbits - 1);\n\n                rlen = escape * cnt1;\n\n            }\n\n        }\n\n\n\n        if (i + rlen > size)\n\n            return AVERROR_INVALIDDATA;\n\n        i += rlen;\n\n\n\n        for (k = 0; k < rlen; k++) {\n\n            dst[j++] = 0;\n\n            if (j == width) {\n\n                j = 0;\n\n                dst += stride;\n\n            }\n\n        }\n\n\n\n        state = 0;\n\n        flag = rlen < 0xFFFF ? 1 : 0;\n\n    }\n\n\n\n    align_get_bits(b);\n\n    return get_bits_count(b) >> 3;\n\n}\n", "idx": 9258, "substitutes": {"avctx": ["Avcontext", " avcontext", " avcmd", "Avcmd", "aftx", "AVcmp", "afctx", "camcmp", "AVtx", "Avcmp", "AVctx", "AVcontext", "avcmd", "avcontext", "Avctx", "afcmd", "Avtx", "camctx", "camtx", "afcontext", "avcmp", "camcontext", "avtx", " avtx"], "dst": ["dsts", "Dsts", "dbut", "Dut", " dsp", "Dwidth", "dLdest", " dest", "Dsrc", " dut", "Dst", " dsts", "sstop", "dbst", "ddest", "Dsp", "sset", " dstop", "dbsts", "dsp", "dut", "dwidth", "dbsrc", "dset", "dest", "dsrc", "sdest", "rwidth", "rst", " dset", " dwidth", " dsrc", "dLst", "dLset", "rsp", "rest", " ddest", "Dest", "dLstop", "dstop", "sst"], "size": ["len", "shift", "num", "send", "padding", "settings", "range", "file", "sp", "height", "Size", "SIZE", "g", "limit", "m", "capacity", "zero", "win", "window", "ize", "body", "count", "e", "shape", "sw", "scale", "sn", "start", "w", "grade", "si", "z", "set", "s", "max", "name", "offset", "length"], "stride": [" strride", "swide", "brid", "swride", "brride", "brice", "strride", "bride", "STRide", "swice", "strade", "Strides", "brides", " strides", " strade", "strice", "STRice", "Stride", "STRid", "strid", "Strride", "Strade", "STRride", "swid", "brade", "strides"], "ctx": ["jac", "obj", "tx", "cmp", "config", "ctrl", "cam", "ct", "cp", "nt", "cf", "xc", "bc", "dc", "jp", "tc", "pkg", "np", "cb", "cc", "txt", "ac", "conn", "conf", "cfg", "gc", "c", "setup", "cmd", "kw", "cm", "sc", "context", "comm", "cv", "loc", "ca"], "b": ["ba", "be", "bf", "buffer", "a", "ch", "base", "rb", "bp", "as", "p", "buf", "bl", "f", "bin", "B", "bc", "g", "l", "bits", "fb", "cb", "ab", "bs", "bg", "j", "br", "y", "emb", "t", "eb", "v", "bo", "sb", "c", "bis", "h", "bh", "bi", "w", "bb", "ob", "it", "nb", "gb", "ib", "db", "buff", "bt", "wb"], "cnt1": ["ucnt0", "cct8", "ucnc0", "cncOne", " cntP", "ccount001", "Count1", " count2", "cnt001", " ccount0", "cct1", "cct001", "ecNT4", "countOne", "Cnt1", "ucnc001", " cntL", "cret8", "cntP", "cnt7", "count0", "cmd", "countP", "ccount1", "Count8", "cret0", " countOnce", "cNTOne", "contP", "crc4", "cct2", "custOnce", "cnc7", "cret2", "cret1", "cont1", "cct0", "count7", " count7", "ctxt0", "cNT1", " ccountOne", "ctxt1", "cnt4", "ecnt4", "ecNTOne", "new", "cOUNT1", "cntOne", "cOUNTOne", " count1", " count0", "cctOne", "cndL", "ucnt1", "ccount0", "Cnt0", "ccount7", " countOne", "count1", "cnc1", " ccount7", "be", " cnt7", "cnc001", "ccount2", "ccountL", "ucntOne", "cntOnce", "crc1", "cndP", "count8", "ecnt1", " cnt001", "Count0", " cntOne", " ccount1", "cnt8", "_", "cnt2", "Count2", "cnd7", " countn", "cnd0", "cnt0", "contn", "crcOne", "ecNT1", "ecntOne", " cntOnce", "ctxt001", "cOUNT4", "Cnt8", "cNT4", "cntn", "cnd1", "cndn", " cntn", "countOnce", " countP", "cust0", " ccount001", "countL", "ucnt001", "ctxtOne", "cnc0", "countn", "cndOne", "ucncOne", " cnt0", "ccountOne", "cont0", " cnt2", " countL", "count2", "gc", " ccount2", "cncOnce", "Cnt2", "cust7", "cnd2", "cntL", "cust1", "ucnc1"], "nbits": ["unops", "nblocks", "cntags", " ntags", "ontops", "untags", "unframes", "cbytes", "unbis", " nbytes", "onpoints", "anchanges", "unints", "anbits", "nlines", "numbits", "lbs", "untops", "Nbs", "onits", "uncodes", "ntags", "cnbytes", "Nbytes", "cncodes", "Nbps", "Nbits", "scanops", "lbits", "nits", "onbits", "onbytes", "units", " nblocks", " nflags", "nflags", "lits", "cits", "unfields", "onbis", "cnbps", "spanlines", "unflags", "anfields", " nints", "nints", "nchanges", "nrows", "spanrows", "lchanges", "cnbits", "scanbits", "spancodes", "nbps", "spanbits", "ncodes", "unrows", " npins", " nchanges", "npins", "anits", "unlines", "anparts", " nits", "nops", " nframes", "onbs", "onints", "npoints", "nbis", "onops", "scanbis", "numbytes", "unblocks", "nframes", "cnframes", "anblocks", " nfields", "ntops", "cnits", "numits", " ntops", "anflags", "lbytes", " nbs", "anints", "cbits", " nparts", "lparts", "nbs", "scanpoints", "unpoints", "nfields", "anbytes", "numbs", "cbs", "cnrows", "cnlines", "nbytes", "unbits", " nbps", "Npins", "anpins", "Nits", "nparts"], "k": ["key", "u", "K", "q", "ak", "seek", "p", "ok", "ip", "g", "m", "kind", "n", "ac", "count", "v", "e", "w", "start", "alias", "it", "x", "set", "ek", "max", "name", "offset"], "value": ["command", "sign", "format", "vp", "itude", "values", "parse", "random", "package", "attribute", "rue", "create", "data", "view", "VALUE", "unknown", "expression", "option", "result", "see", "key", "power", "address", "code", "message", "weight", "widget", "limit", "null", "hello", "try", " Value", "version", "new", "scale", "operator", "initial", "byte", "state", "ue", "python", "number", "itness", "current", "buffer", "image", "sample", "field", "unit", "process", "type", "sequence", "raw", "function", "index", "action", "transform", "ence", "start", "style", "vector", "success", "entry", "multiple", "text", "base", "we", "pair", "variable", "label", "position", "port", "save", "quality", "json", "checked", "all", "total", "commit", "v", "change", "val", "Value", "description", "name", "length"], "rlen": ["rtlim", "rlim", "rrlen", "pls", "plimit", "rls", "rrlimit", "rtlimit", "dlength", "Rmsg", "rrmsg", "rrlong", "rLen", "rtlength", " rlimit", " rlim", "rtlong", "Rlen", "RLen", " rlength", " rlong", "rlong", "dlim", "rrLen", "rrlength", "rmsg", "rlength", " rmsg", "dLen", "dlen", "rtlen", "Rlength", "rtls", "plen", " rls", "rlimit", "plength", " rLen", "rtLen", "rrls"], "escape": ["ie", "sign", "ee", "parse", "attribute", "eval", "se", "view", "check", "expression", "apache", "cmd", "speed", "key", "guard", "address", "cape", "code", "ctrl", "route", "match", "slave", "email", "aped", "limit", "illegal", "layout", "scroll", "echo", "esc", "e", "close", "scale", "alias", "scape", "force", "link", "pack", "esi", "shift", "ssh", "safe", "ignore", "buffer", "export", "stroke", "bind", "error", "ase", "condition", "control", "sequence", "edge", "forge", "execute", "comment", "quote", "APE", "ape", "style", "success", "secure", "flag", "event", "seek", "pair", "axe", "label", "save", "json", "expr", "secret", "esp", "aw", "change", "lock", "access", "rage", "offset", "delay"], "i": ["id", "ai", "I", "a", "li", "ei", "p", "ii", "o", "f", "ind", "ui", "iter", "ip", "m", "ti", "index", "mi", "is", "jj", "j", "im", "ix", "n", "y", "iu", "ci", "t", "phi", "v", "info", "zi", "e", "bi", "di", "pi", "si", "it", "x", "ini", "s", " j", "ij"]}}
{"project": "qemu", "commit_id": "fc19f8a02e45c4d8ad24dd7eb374330b03dfc28e", "target": 0, "func": "static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(s, &request);\n\n    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {\n\n        reply.error = errno;\n\n    } else {\n\n        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);\n\n    }\n\n    nbd_coroutine_end(s, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 9260, "substitutes": {"bs": ["obs", "vs", "cks", "aos", "bp", "rs", "hs", "gs", "bes", "ps", "bc", "BS", "cs", "bm", "bits", "bing", "aus", "als", "js", "ys", "is", "ss", "ts", "its", "bos", "lbs", "ubs", "os", "sb", "b", "bis", "bh", "ns", "bi", "fs", "blog", "ls", "ds"], "sector_num": ["sectoretynumber", "sector2num", "sector2Num", "ector_set", "sectoretymu", "ector_mu", "ector_number", "sector_number", "sector00set", " sector_number", "sector2um", "sector00number", "sector2number", "sector_set", "sector_Num", "sectoretynum", "sector00num", " sector_um", "sector_mu", "sector00mu", " sector_Num", "sector_um", "sectoretyset", "ector_num"], "nb_sectors": ["nb_serivers", "nb_beors", "nb_spevers", "nb_bevers", "nb_vecs", "nb_servers", "nb_serors", "nb_seors", "nb_veors", "nb_veivers", "nb_pecs", "nb_severs", "nb_speors", "nb_specs", "nb_beivers", "nb_pevers", "nb_vevers", "nb_spectors", "nb_vectors", "nb_secs", "nb_serctors", "nb_bectors", "nb_pectors", "nb_peors", "nb_seivers"], "qiov": [" qconv", "quconv", "quiour", "sqiop", "qiour", "quiop", " qiv", " qiour", "sqiour", "sqiv", "qoco", " qoco", "qiop", " Qoco", "qiv", "sqiov", "quiv", "qconv", "quoco", "quiov", " Qiov", " qiop", " Qiour", " Qconv"], "offset": ["shift", "len", "off", "address", "et", "prefix", "pointer", "padding", "layer", "seek", "ff", "point", "o", "error", "pad", "slot", "location", "pos", "oid", "timeout", "position", "ptr", "length", "addr", "index", "top", "Offset", " offsets", "from", "origin", "start", "seed", "set", "size", "number"], "s": ["sq", "sync", "sl", "a", "q", "rs", "http", "p", "gs", "sts", "an", "sm", "ex", "south", "ps", " ss", "g", "l", "m", "sv", "es", "ses", "i", "so", "r", "is", "js", "j", "S", "ss", "ts", "n", "less", "y", "its", "t", "conf", "os", "sb", "b", "sw", "h", "sn", "ns", "sa", "stats", "fs", "w", "z", "comm", "ls", "ds", "sys"], "request": ["command", "art", "select", "reset", "address", " req", "call", "record", "config", "message", "join", "order", "q", "req", "match", "document", "print", "begin", "complete", "child", "point", "task", "report", "pair", "frame", "response", "worker", "push", "police", "condition", "type", "reference", "package", "attribute", " query", "have", " requesting", "question", "trip", "create", "transfer", "accept", "import", "new", " requisite", "forward", "change", "input", "search", "suggest", "QUEST", "query", "cmd", "copy", "setup", "est", "xml", "requ", "ask", "ire", "rank", "param", "public", "claim", "quest", "project", "Request", "find", "store"], "reply": ["output", "command", "next", "lib", "send", "sync", "status", "nl", "respond", "part", "record", "write", "message", "Reply", "route", "err", " response", "resp", "ve", "report", "reason", "error", "rev", "jp", "process", "detail", "onse", "ply", "relation", "rr", "sett", "ish", "r", " Reply", "transfer", "translation", "place", "echo", "body", "repl", "bill", "related", "out", "comment", "query", "ror", "replace", "results", "des", "bb", "link", "result", "proxy", "answer", "response", "apply", "role", "ret"]}}
{"project": "FFmpeg", "commit_id": "dd5d61795690e339ae271692e7ab9df66b5eb153", "target": 0, "func": "static int request_frame(AVFilterLink *link)\n\n{\n\n    AVFilterContext *ctx = link->src;\n\n    IDETContext *idet = ctx->priv;\n\n\n\n    do {\n\n        int ret;\n\n\n\n        if (idet->eof)\n\n            return AVERROR_EOF;\n\n\n\n        ret = ff_request_frame(link->src->inputs[0]);\n\n\n\n        if (ret == AVERROR_EOF && idet->cur) {\n\n            AVFrame *next = av_frame_clone(idet->next);\n\n\n\n            if (!next)\n\n                return AVERROR(ENOMEM);\n\n\n\n            filter_frame(link->src->inputs[0], next);\n\n            idet->eof = 1;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (!idet->cur);\n\n\n\n    return 0;\n\n}\n", "idx": 9282, "substitutes": {"link": ["command", "sync", "sl", "call", "li", "thread", "route", "match", "ping", "linked", "Link", "task", "frame", "ld", "fail", "open", "label", "let", "l", "block", "local", "def", "flow", "ctl", "le", "parse", "loop", "handle", "connect", "ln", "links", "dl", "ick", "check", "lc", "mark", "line", "hip", "lock", "sh", "play", "load", "mail", "slice", "lay", "pack", "lex", "light", "tool", "ink"], "ctx": ["ck", "obj", "tx", "cmp", "config", "ctrl", "crit", "init", "ct", "kt", "cp", "nt", "cf", "xc", "iat", "act", "tc", "wx", "cb", "ic", "cc", "mc", "ac", "conn", "wd", "anc", "cmd", "tmp", "hw", "nc", "cm", "kw", "sc", "context", "co", "msg", "cv", "loc", "conv", "sys"], "idet": ["aidnet", "identiet", "Ident", "identetic", "pidet", "uidot", "identET", " idpt", "idote", "initot", " idect", "uidiet", "Idel", "initent", " idot", "idpt", "Idpt", "Idect", " idote", "idnet", " idel", "ident", "aidote", "initet", "initetic", " idec", "ridpt", "idot", "Idot", "identent", " idET", "idec", "Idnet", "ridet", "Idet", "idetic", "ridec", "idiet", "IdET", "identot", "indote", " idnet", "aidet", "idetter", "idET", "identel", "idel", "Idec", " idetter", "pidel", " idiet", "pidET", "identet", "uidetter", "indet", "ridect", "indnet", "uidel", "idect", "Idetic", "identetter", "uidET", "uidet", "pidnet"], "ret": ["len", "fin", "tr", "success", "lt", "reset", "num", "status", "back", "code", "end", "err", "print", "det", "nz", "RET", "resp", "hash", "nt", "prot", "rev", "jp", "ref", "fun", "mt", "pret", "inter", "def", "usr", "txt", "alt", "mem", "ter", "vers", "cont", "ext", "j", "try", "test", "done", "final", "t", "rem", "rets", "tn", "deg", "reg", "val", "Ret", "xt", "cmd", "rt", "re", "elt", "sys", "res", "rm", "cert", "result", "att", "gt", "ll", " fut", "ft", "state", "out"], "next": [" NEXT", "obj", "current", "be", "extra", "net", "inc", "nl", "err", "prev", "Next", "valid", "to", "ng", "buf", "gov", "seq", "dev", "frame", "ne", "first", "nt", "normal", "future", "sec", "rev", "cur", "gr", "other", "jp", "ref", "ptr", "desc", "nn", "pri", "ver", "txt", "ext", "max", "js", "j", "data", "br", "n", "last", "now", "fn", "new", "big", "self", "gen", "fr", "v", "info", "xt", "tmp", "sel", "adj", "dot", "batch", "z", "gt", "msg", "nil", "then", "nd"]}}
{"project": "FFmpeg", "commit_id": "a2085a7e9d83d99aca58bfb385f6db1afa5673dd", "target": 1, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n                             void *data, int *data_size,\n                             uint8_t *buf, int buf_size)\n{\n    DPCMContext *s = avctx->priv_data;\n    int in, out = 0;\n    int predictor[2];\n    int channel_number = 0;\n    short *output_samples = data;\n    int shift[2];\n    unsigned char byte;\n    short diff;\n    if (!buf_size)\n        return 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ROQ_DPCM:\n        if (s->channels == 1)\n            predictor[0] = AV_RL16(&buf[6]);\n        else {\n            predictor[0] = buf[7] << 8;\n            predictor[1] = buf[6] << 8;\n        }\n        SE_16BIT(predictor[0]);\n        SE_16BIT(predictor[1]);\n        /* decode the samples */\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n            predictor[channel_number] += s->roq_square_array[buf[in]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_INTERPLAY_DPCM:\n        in = 6;  /* skip over the stream mask and stream length */\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0])\n        output_samples[out++] = predictor[0];\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1])\n            output_samples[out++] = predictor[1];\n        }\n        while (in < buf_size) {\n            predictor[channel_number] += interplay_delta_table[buf[in++]];\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_XAN_DPCM:\n        in = 0;\n        shift[0] = shift[1] = 4;\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0]);\n        if (s->channels == 2) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1]);\n        }\n        while (in < buf_size) {\n            byte = buf[in++];\n            diff = (byte & 0xFC) << 8;\n            if ((byte & 0x03) == 3)\n                shift[channel_number]++;\n            else\n                shift[channel_number] -= (2 * (byte & 3));\n            /* saturate the shifter to a lower limit of 0 */\n            if (shift[channel_number] < 0)\n                shift[channel_number] = 0;\n            diff >>= shift[channel_number];\n            predictor[channel_number] += diff;\n            predictor[channel_number] = av_clip_int16(predictor[channel_number]);\n            output_samples[out++] = predictor[channel_number];\n            /* toggle channel */\n            channel_number ^= s->channels - 1;\n        }\n        break;\n    case CODEC_ID_SOL_DPCM:\n        in = 0;\n        if (avctx->codec_tag != 3) {\n            if(*data_size/4 < buf_size)\n            while (in < buf_size) {\n                int n1, n2;\n                n1 = (buf[in] >> 4) & 0xF;\n                n2 = buf[in++] & 0xF;\n                s->sample[0] += s->sol_table[n1];\n                 if (s->sample[0] < 0) s->sample[0] = 0;\n                if (s->sample[0] > 255) s->sample[0] = 255;\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n                s->sample[s->channels - 1] += s->sol_table[n2];\n                if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0;\n                if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255;\n                output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8;\n            }\n        } else {\n            while (in < buf_size) {\n                int n;\n                n = buf[in++];\n                if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F];\n                else s->sample[channel_number] += s->sol_table[n & 0x7F];\n                s->sample[channel_number] = av_clip_int16(s->sample[channel_number]);\n                output_samples[out++] = s->sample[channel_number];\n                /* toggle channel */\n                channel_number ^= s->channels - 1;\n            }\n        }\n        break;\n    }\n    *data_size = out * sizeof(short);\n    return buf_size;\n}", "idx": 9283, "substitutes": {"avctx": [" avctl", "vrcv", " avcontext", "avejp", "avctl", "vrcmd", "avecontext", "avectl", "AVtx", " avpkg", "vrtx", "vcontext", "AVctx", "AVcontext", "avcmd", "avcontext", "vrctx", "avecmd", "vctl", "avjp", "AVctl", "AVcv", "AVcmd", "AVpkg", "AVjp", "avecv", "avectx", "avcv", "avtx", "avpkg", " avjp", "vpkg", "avetx", "vctx"], "data": ["Data", "next", "empty", "buffer", "text", "message", "a", "channel", "image", "to", "value", "p", "bin", "frame", "pad", "d", "this", "block", "m", "pos", "ata", "ref", "length", "raw", "window", "bytes", "t", "feed", "input", "dat", "str", "w", "table", "batch", "DATA", "size"], "data_size": ["buf_send", "buf_length", "data_length", "buf_SIZE", "data_SIZE", "data_send"], "buf": ["doc", "config", "cam", "proc", "func", "prop", "Buffer", "boxes", "bits", "desc", "queue", "cap", "wd", "fam", "deg", "b", "cmd", "str", "mus", "nb", "cv", "conv", "hz", "arr", "bench", "tx", "uf", "rb", "ff", "args", "bs", "txt", "Buff", "etc", "batch", "pack", "img", "nm", "buffer", "mat", "bp", "err", "words", "vec", "docs", "late", "cur", "fb", "tab", "raw", "window", "mem", "ctx", "good", "tmp", "db", "bar", "bag", "aka", "p", "seq", "pkg", "np", "cb", "bytes", "br", "wav", "pb", "box", "v", "cache", "bh", "buff", "msg", "wb"], "buf_size": [" bufptSIZE", " bufpttoo", "queue_size", "buf1sent", "bufJsize", "buf1length", " buf_number", "buftnumber", "buf_sent", "buftsize", "bufptsum", "queue_sent", " buf_too", "buf5SIZE", " buf5offset", "buf_length", "bufptsize", "buf_sum", "bufpttoo", "buf_offset", "buftoffset", "bufJtoo", " buf_len", "buf5number", " buf5len", "buf_too", "buf5len", " buf_sum", "buftlen", " buf_offset", "buf5offset", "buf_len", " buf5size", "buf1size", " buf5number", "bufJSIZE", "buf_ize", "queue_length", "buf1ize", " bufptsum", "buf_SIZE", "queue_ize", "buf_number", "buf5size", " buf_SIZE", "bufptSIZE", " bufptsize", "bufJsum"], "s": ["sq", "vs", "spec", "a", "ats", "rs", "as", "hs", "p", "gs", "sts", "ex", "ps", "ess", "d", "changes", "g", "cs", "m", "sv", "i", "es", "bs", "aws", "r", "is", "js", "S", "ss", "ts", "its", "less", "t", "ctx", "ssl", "sports", "v", "conf", "ops", "os", "b", "c", "sw", "h", "ns", "stats", "sc", "z", "comm", "ls", "ims", "ds", "sk", "sys"], "in": ["In", "doc", "on", "inc", "add", "ee", "update", "end", "o", "d", "m", "ins", "win", "IN", "r", "row", "im", "check", "rin", "pin", "el", "oin", "inner", "al", "call", "record", "at", "init", "ex", "ind", "iter", "um", "after", "en", "loop", "ix", "new", "e", "isin", "time", "pid", "min", "id", "ai", "up", "as", "pos", "l", "inter", "local", "i", "gin", "window", "raw", "ic", "index", "old", "from", "start", "by", "it", "ini", "ax", "inn", "con", "pass", "p", "act", "din", "all", "is", "v", "input", "c", "x", "name"], "predictor": ["predictactor", "pictbor", "psuppetor", "pictionory", "predictolder", "compictionutor", "pointor", "pveyutor", "prredictoral", "pictionur", "predictger", "predictrator", "pingessoreur", "pertlor", "proppredractor", "predictrar", "priptor", "xpictionuser", "pingessorcer", "pculrar", "posterutor", "pingredictor", "predictur", "pertitor", " ppector", "pennractor", "psredictur", "propredictore", "pjectur", "pictionicator", "pingessorion", "pctor", "pessorcer", "wpredictur", "prictutor", "compictionor", "posterory", "xpredictor", "predicted", "ppecter", " predicter", "ppectutor", "psertor", "pctator", "puppetoring", "pconstructator", "prredictur", "pictractor", "pjectactor", "prredictger", "pictionOR", "predictutor", "pivotor", "priptior", "pjectore", "ppredrator", "ppictor", "pderlor", "predicter", "pitnessoral", "pictur", "compredictior", "prpector", "pinguppetoring", "pictter", "ppreded", "parsonori", "pderrar", "picteduser", "psertitor", "pingredictoral", "tpredictor", "psuppetractor", "priptant", "ppredur", "prjectactor", "predictior", "predictitor", "ppredori", "xpictionor", "pictger", "propredictori", "pculor", "prediction", "ppredeur", "pictionant", "pictutor", "ppectior", "pitnessor", "ppectcer", "xpictionider", "tpriptor", "pderor", "pripteur", "padaptutor", "pderessor", "predictOR", "predictractor", "pinguppetoral", "prpectger", "prpectcer", "xpictionory", "predictoring", "ppictutor", "ppredictor", "pictionter", "pveyor", "pocolori", "pocolator", "padaptger", "wpredictOR", "propredictor", "pconstructbor", "petermincer", "pennori", "xpredictider", "prpectutor", "ppector", "wppredbor", "pctbor", "padaptor", "ppredictbor", "prredictOR", "prredictrator", "prictlor", "psredictcer", "pveyant", " ppectutor", "predictore", "tpredictior", "predictory", "prredicted", "ppectOR", "puppetcer", "predictator", "prredictori", "pocollor", "puppetator", "predictbor", "pictionoring", "priptcer", "pocoloring", "priptoral", "pocolutor", "puppetur", "pictOR", "postered", " padaptutor", "pictlor", " ppecter", "tpriptant", "pictessor", "posterider", "pictionuser", "psredictractor", "wpredictbor", "parsonutor", "pconstructor", "pictionactor", "psivotor", "tpriptior", "pription", "tpredictoring", "psredictessor", "xpredictory", "prosterutor", "pictcer", "prpectOR", "pocolor", "parsonbor", "pingredictoring", "propredictractor", "wpredictessor", " predictbor", " predictutor", "padaptbor", "pjectori", "compredicticator", "pessoror", "priptoring", "pensoror", "pictedlor", "ppredictutor", "pictedory", "prredictcer", " padaptori", "predictant", "pictionolder", "pivotessor", "psredictrar", "ppredbor", "wpictor", "prjectutor", "tpredictant", "pointactor", "pictedori", "prredictutor", "ppictter", "predictoral", "wpredictator", "pitnessoring", "wpictolder", "psivotessor", "prredictor", "ppredutor", "proppredor", "pointur", "pingredicteur", "pictionior", "pennor", "prictor", "posteruser", "psredictor", "pveyior", "predictlor", "proppredori", "pveyicator", "pveyoring", "ppredter", "predictter", "predictuser", "peterminor", "pingredictator", "wppredor", "posteror", "prjectur", "pictionider", "pennore", "predicticator", "tpriptoring", "pctur", "ppectessor", "peterminoral", "puppetractor", "posterrator", "padaptori", "ppictbor", "pingredictcer", "psredictutor", "prredictlor", "priptur", "pinguppetator", "pjectutor", "pertor", "parsonor", "pensorrator", "pjectractor", "pictedider", "pocoloral", "prjector", "prredictactor", "predictcer", "pderitor", "pingessoror", "pointitor", "wpredictolder", "psertlor", "pensorutor", "predictori", "priptOR", "psredictlor", "pculessor", "ppectger", "pictedutor", "psuppetur", "pitnessator", "pensored", "priptractor", "predictessor", " ppectior", "wppredator", "pjector", "pictolder", "pessoreur", "pertutor", "ppecticator", "psertutor", "prictori", "pictori", "compictionicator", "xpredictuser", "psivotrar", "pointutor", "compictionior", "compredictutor", "puppetor", "ppredcer", "prosterrator", "pictionessor", "pictedor", "ppredion", "proppredore", "predictider", "pictioner", "psredictitor", "pictor", "predicteur", "wpredictor", " predictori", "pconstructur", "wpictessor", "prpectoral", " padaptbor", " predictior", "ppredore", "ppectolder", "pictionutor", "padaptOR", "pivotrar", "wpictOR", "prosteror", "pinguppetor", "pderutor", "pingrediction", "ppectoral", "ppredictter", "puppetoral", " padaptor", "psuppetcer", "pessorion", "ppredor", "peterminOR", "prostered", "wppredur", "ppredractor", "pictionor", "pictionbor", "ppredator", "pointlor", "compredictor"], "output_samples": ["output_sessions", "outputMemsamples", "output_statusamples", "output_exents", "output_courses", "output_cessions", "outputfulsourses", "output_exages", "output_examples", "outputMemsutes", "output_Sets", "output_statannels", "output_esples", "output_consents", "output_tsples", "outputfulsnapamples", "output_snapamples", "output_statages", "output_snapourses", "output_consages", "output_sets", "output_sannels", "output_statamples", "output_tsiders", "output_genresses", "outputfulsamples", "output_statusutes", "output_statets", "output_statamps", "output_genamples", "output_genourses", "outputfulsnapresses", "output_cresses", "outputfulsessions", "output_consannels", "output_statusiders", "output_tsutes", "output_namples", "output_snapessions", "output_statusples", "output_sages", "output_consamples", "output_namps", "output_tsamples", "output_sourses", "output_sresses", "output_nets", "output_Samples", "output_genessions", "output_statents", "outputMemstatusutes", "output_snapresses", "outputMemsples", "output_sents", "outputMemstatusples", "output_sples", "output_Samps", "output_exannels", "outputfulsnapourses", "outputfulsresses", "outputMemsiders", "output_esiders", "outputMemstatusamples", "outputMemstatusiders", "output_siders", "output_esutes", "output_esamples", "output_samps", "output_sutes", "output_camples", "outputfulsnapessions"], "shift": ["align", "next", "hift", "send", "Shift", "step", "hash", "pad", "push", "pos", "ref", "mask", "index", "version", "last", "skip", "count", "scale", "start", "slice", "seed", "set", "pack", "head", "offset", "size"], "byte": ["command", "cmp", "address", "io", "buffer", "code", "channel", "base", "value", "field", "bin", "unit", "pair", "word", "bytes", " bytes", "bit", "transfer", "mode", "b", "bb", "Byte", "binary"], "diff": ["command", "cmp", " difference", " differences", "err", " compare", " delta", " change", "error", "Delta", " dev", " seed", " differential", " desc", " remaining", "mix", "Diff", " reward", " distance", " Diff", " step", "sb", " dist", "iff", "result", " err", " leftover", " direction"], "out": ["output", "on", "obj", "num", "id", "off", "net", "con", "vert", "status", "at", "ch", "course", "external", "or", "end", "up", "list", "to", "over", "o", "OUT", "point", "ex", "ind", "ne", "nt", "pool", "iter", "pos", "outs", "client", "timeout", "ins", "i", "after", "port", "ver", "ou", "Out", "server", "index", "all", "outer", "chain", "bound", "t", "new", "cmd", "ot", "oe", "by", "it", "x", "batch", "set", "co", "no", "max", "high", "size", "sys"], "channel_number": ["resource_number", "channelendirectory", "batch_reference", "connectionitystatus", "secondationversion", "byte_name", "channel_group", " channel_position", "chatennumber", " Channel_class", "chat_document", "channelyvariable", "channelitydocument", " channel_Number", "button_raw", "resourceygroup", "connection_status", "connection_number", "channelityname", "channel_message", "batchitynumber", "batch_negative", " Channel_message", "channelitynegative", "batchitynegative", "batchityreference", "resource_group", "channel00collection", "channel_document", "channelendevice", "channel_note", "resource_note", "channel_negative", "channel_maximum", "channel_version", "batch_number", "channel_device", "chat_number", "channelationcollection", "secondationcollection", "button_cmp", "byteitynumber", "channelitymaximum", "channelitydevice", "connectionityclass", "channelynote", "channel00class", "byte_number", "channel_volume", " Channel_volume", "channelernegative", "channelationstatus", "channelityinteger", "channelendocument", "channelynumber", "channel_class", "resource_variable", "channelxposition", "channelennumber", "channel_directory", "channelernumber", "connection_class", "secondationclass", "batch_integer", "chatendevice", "channelationclass", "channel_Number", "channelerreference", "byteityreference", "channelerinteger", "channel_collection", "channel_name", "channel_position", "channel_integer", "channelxversion", "channelitynumber", "channelityreference", "chatendocument", "byteityindex", "second_collection", "channelygroup", "channelitystatus", "channelityclass", "second_version", "byte_index", "channelationversion", "byte_reference", "second_class", "channel00version", "channelityindex", "channel_reference", "chat_device", "connectionitynumber", "channel_variable", "channel_index", "channelxNumber", "second_number", "resourceynumber", "batchityinteger", "channel_status", "channel_cmp", "channel_raw", "channelationnumber", "chat_directory", " channel_version", "channelitydirectory", "channelationmaximum", "resourceynote", "resourceyvariable", "secondationnumber", "chatendirectory", "connectionitymaximum", "channel00number", "byteityname", " Channel_number", "channelxnumber", "connection_maximum"]}}
{"project": "FFmpeg", "commit_id": "03abf55f252945c70f4a79eaf4d609cee4d98710", "target": 1, "func": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n\n                              AVStream *st, RMStream *rst,\n\n                              unsigned int codec_data_size, const uint8_t *mime)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    if (codec_data_size > INT_MAX)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n\n\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n\n        int number_of_streams = avio_rb16(pb);\n\n        int number_of_mdpr;\n\n        int i;\n\n        for (i = 0; i<number_of_streams; i++)\n\n            avio_rb16(pb);\n\n        number_of_mdpr = avio_rb16(pb);\n\n        if (number_of_mdpr != 1) {\n\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n\n        }\n\n        avio_rb32(pb);\n\n        v = avio_rb32(pb);\n\n    }\n\n\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n\n        int stream_count, rule_count, property_count, i;\n\n        ff_free_stream(s, st);\n\n        if (avio_rb16(pb) != 0) {\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n\n            goto skip;\n\n        }\n\n        stream_count = avio_rb16(pb);\n\n        avio_skip(pb, 6*stream_count);\n\n        rule_count = avio_rb16(pb);\n\n        avio_skip(pb, 2*rule_count);\n\n        property_count = avio_rb16(pb);\n\n        for(i=0; i<property_count; i++){\n\n            uint8_t name[128], val[128];\n\n            avio_rb32(pb);\n\n            if (avio_rb16(pb) != 0) {\n\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n\n                goto skip; //FIXME skip just this one\n\n            }\n\n            get_str8(pb, name, sizeof(name));\n\n            switch(avio_rb32(pb)) {\n\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n\n                av_dict_set(&s->metadata, name, val, 0);\n\n                break;\n\n            default: avio_skip(pb, avio_rb16(pb));\n\n            }\n\n        }\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        if (fps > 0) {\n\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n\n                      0x10000, fps, (1 << 30) - 1);\n\n#if FF_API_R_FRAME_RATE\n\n            st->r_frame_rate = st->avg_frame_rate;\n\n#endif\n\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 9301, "substitutes": {"s": ["src", "sq", "a", "ats", "rs", "sg", "p", "sp", "gs", "sts", "ps", "pkg", "m", "cs", "ans", "sv", "es", "scl", "bs", "ss", "ts", "t", "ctx", "os", "sb", "b", "e", "c", "h", "sa", "ns", "stats", "w", "fs", "sn", "sc", "ls", "ds", "sys"], "pb": ["td", "lb", "bj", "typ", "pc", "tp", "ub", "pp", "pt", "uf", "bp", "rb", "tk", "asm", "span", "proc", "p", "sp", "buf", "resp", "pool", "cp", "ps", "pg", "rob", "vp", "pkg", "np", "jp", "tc", "fb", "um", "cb", "tab", "lp", "bs", "txt", "pm", "snap", "emb", "eb", "ctx", "erb", "pl", "sb", "b", "wp", "tmp", "ob", "PB", "bb", "sc", "nb", "stab", "peer", "ib", "buff", "db", "cv", "mp", "patch", "wb", "pa"], "st": ["td", "src", "tt", "art", "tx", "sl", "et", "std", "pt", "St", "put", "ct", "step", "stan", "sp", "p", "sts", "nt", "ut", "act", "th", "stable", "stop", "sv", "ust", "ste", "so", "usr", "storage", "r", "stage", "ist", "ts", "se", "interface", "t", "ctx", "stru", "ast", "sb", "sw", "sh", "ost", "ST", "sn", "rt", "rest", "start", "inst", "sta", "str", "stat", "sc", "stab", "est", "set", "nd", "ft", "mt", "store"], "rst": ["msw", "wST", "wstable", "mss", "rnd", " rsw", "lST", "mst", "rrst", "lstable", "arsw", "rrstable", "rST", "msp", "lnd", "rsw", "lst", "rstable", "rrST", "rrnd", "arst", "rsp", "arss", " rsp", "rss", "arsp", "wnd", " rss", "wst"], "codec_data_size": ["codec_no_len", "codec_no_size", "codec_no_ize", "codec_no_SIZE", "codec_data_len", "codec_data_SIZE", "codec_dataitysize", "codec_data_length", "codec_data_code", "codec_dataitycode", "codec_dataitylength", "codec_data_ize"], "mime": ["nmixed", "mixed", " mip", "mip", "cmIME", "cmip", "cmesh", "Mime", " mimes", "emime", "mimes", "MIME", "mIME", "emIME", "mesh", " mixed", "nmIME", " mesh", " mIME", "Mip", "cmixed", "emimes", "nmesh", "cmimes", " mim", "mim", "Mim", "Mimes", "nmime", "emim", "cmime"], "v": ["nv", "vs", "vert", "u", "vol", "av", "vi", "va", "q", "ev", "valid", "k", "ov", "uv", "p", "vv", "ve", " V", "var", "f", "value", "lv", "mint", "vp", "rev", "m", "l", "g", "sv", "qv", "vt", "ver", "inv", "j", "version", "y", "t", "qu", "V", " av", "env", "b", "nov", "c", "h", "w", "cv", "iv", "vr", "vm", "vc", "conv", "tv"], "size": ["len", "sum", "message", "format", "area", "sp", "Size", "SIZE", "g", "l", "m", "type", "ize", "mem", "total", "n", "t", "count", "e", "c", "scale", "sn", "si", "set", "offset", "length"], "codec_pos": ["codec_ref", "codEC_loc", "codoc_pos", "codec__pose", "codec_pose", "codoc_ref", "codEC_position", "codec_offset", "codEC_pose", "codec_position", "codoc_offset", "codEC_pos", "codec_Pos", "codec_loc", "codec__position", "codoc_Pos", "codec__pos", "codec__loc"], "ret": ["tf", "len", "ef", "tr", "success", "mb", "status", "back", "err", "print", "RET", "resp", "value", "over", "f", "nt", "rev", "ref", "inter", "pret", "def", " Ret", "txt", "alt", "mem", "ter", "cont", "final", "t", "mel", "rem", "rets", "not", "Ret", "elt", "re", "rt", "res", "ber", "it", "result", "gt", "ez", "ll", "ft", "out"], "number_of_mdpr": ["number_of_mmPr", "number_of_MDPR", "number_of_ndbr", "number_of_mpr", "number_of_mmpr", "number_of_MDpr", "number_of_mmPR", "number_of_dpr", "number_of_mondpr", "number_of_mmps", "number_of_dPr", "number_of_mdPr", "number_of_dPR", "number_of_mdporter", "number_of_mondPR", "number_of_mdPR", "number_of_MDbr", "number_of_mdbr", "number_of_ndPR", "number_of_ndPr", "number_of_mPR", "number_of_mdps", "number_of_mbr", "number_of_dps", "number_of_ndps", "number_of_mondporter", "number_of_MDporter", "number_of_ndporter", "number_of_ndpr"], "i": ["ai", "I", "me", "li", "q", "init", "sql", "print", "p", "f", "sim", "ind", "ex", "ui", "ip", "g", "m", "l", "ti", "ic", "cli", "us", "in", "mi", "is", "chain", "j", "im", "ix", "n", "y", "iu", "ci", "zi", "phi", "info", "xi", "gu", "multi", "e", "qi", "c", "gi", "uu", "di", "bi", "pi", "si", "it", "x", "ini", "hi", "ii"]}}
{"project": "qemu", "commit_id": "abda1f37eed86f3501db2e5439c1a7b97171ea22", "target": 1, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status &= ~COM_CRC_ERROR;\n\n        return 0;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n    if (sd->card_status & ILLEGAL_COMMAND)\n\n        rsplen = 0;\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 9330, "substitutes": {"sd": ["send", "sky", "dll", "decl", "sg", "d", "sing", "se", "sa", "dist", "bd", "ard", "sk", "td", "dd", "SD", "sql", "sp", "ind", "sec", "ess", "pd", "hd", "sv", "dis", "sam", "mod", "server", "gd", "dk", "js", "ss", "ma", "cond", "rh", "sb", "sy", "des", "sta", "si", "sc", "draw", "amd", "sl", "std", "form", "df", "od", "sm", "ld", "cd", "def", "ell", "dl", "ad", "reg", "sw", "sh", "db", "s", "ds", "style", "san", "fd", "and", "dev", "sim", "south", "service", "md", "vd", "ssl", "sn", "di", "nd", "sys", "store"], "req": ["sq", "tx", "reset", "spec", "qq", "config", "crit", "q", "rb", "iq", "ack", "compl", "proc", "rec", "resp", "seq", "ind", "ps", "sec", "this", "push", "pkg", "need", "ref", "jp", "client", "request", "desc", "urg", "usr", "ext", "inv", "md", "qt", "r", "j", "js", "cond", "needed", "aux", "ctx", "reg", "esp", "conf", "fr", "query", "cmd", "exec", "rest", "dist", "res", "requ", "comm", "msg", "quest", "pro", "Request", "required"], "response": ["output", "command", "vector", "next", "success", "entry", "Response", "reset", "send", "sol", "message", "image", "application", "form", "resp", "sp", "value", "ve", "reply", "error", "frame", "block", "pos", "service", "def", "sequence", "onse", "request", "yes", "window", "example", "json", "relation", "all", "r", "amount", "description", "de", "data", "question", "connection", "v", "tree", "e", "des", "res", "definition", "then", "rss", "respons", "result", "style", "memory", "no", "answer", "given", "out"], "rtype": ["rightpe", "righttype", "mrTYPE", "rTYPE", "mrpart", "Rype", "rightype", "airTYPE", "rtry", " rType", "erype", "rcolor", "airtype", "aircolor", "RTYPE", "ertry", "dtype", "mrtyp", "rmtyp", "rmpart", "rType", "ertyp", "RType", "arrule", "Rtyp", " rrule", "rype", "rmtype", "ertype", "dtyp", "artype", "arype", "Rrule", "erTYPE", "dTYPE", " rype", "Rtype", "Rpart", "mrtype", "rrule", "arType", "airtyp", "ercolor", "erpe", "rpe", "righttry", "rtyp", "rpart", " rtry", "dcolor", "rmTYPE", " rpe"], "rsplen": ["rsplun", "rsplugenum", "rspalest", "ricspleren", "adssplen", "rsPlen", "rsipllen", "rsimplens", "rspersree", "rspluf", "rosplugenum", "rspalresh", "rspersen", "adssplenum", "csplun", "rsplree", "rssplah", "rosplah", "rsPlel", "rsplerenc", "rosplugatten", "rsplerresh", "upssplen", "rsplereng", "upssplest", "adsplen", "rsspleng", "rsiplen", "rsplel", "ricsplerlen", "rspleruf", "rsplest", "adsplure", "rspalef", "rssplenum", "gesploen", "rspalure", "rsplerlen", "rssplest", "rspaloen", "rossplen", "csplen", "adssplef", "cspalun", "rsimplener", "versplen", "rspalenum", "rsplener", "rspalatten", "rsplah", "rossplel", "rsiplun", "rscllen", "rsprend", "rssplure", "rspeatten", "rsplerenum", "rspln", "adsplenum", "ricsplen", "rspersuf", "upsspleng", "rosplel", "ricspllen", "rsplresh", "cspalenum", "rsplend", "rossplah", "rsiplenum", "rspleroen", "rspeuf", "rspeen", "rsperee", "rsplens", "rssplel", "upsplest", "rsplure", "rsclun", "rssplenc", "rosspln", "rsplugatten", "rsplerend", "rspleren", "rsperslen", "rsprens", "rsprn", "rsprel", "upsplen", "rsPlah", "rsreplenum", "rosplatten", "rspalen", "csplenum", "rsPln", "gesplen", "rssplen", "rspallen", "gessplenc", "rssplef", "rsreplure", "rosplenum", "rospln", "rsimplend", "versplener", "cspallen", "versplerener", "rsplenum", "adsplef", "gesplatten", "rssploen", "rspalun", "rosplugen", "ricsplerree", "versplend", "rsploen", "rspaleng", "ricspluf", "rssplatten", "rsplef", "rsprah", "upssplresh", "rssplresh", "rsimplen", "versplens", "rsplugen", "rsclenum", "rspren", "rospluglen", "versplerens", "upsplresh", "cspllen", "ricsplree", "rspleratten", "rsplerens", "gessploen", "rspllen", "rsplerener", "rspalenc", "rsplenc", "cspalen", "rsreplef", "ricspleruf", "rsplatten", "rsprener", "rsclen", "versplerend", "rspelen", "gesplenc", "rsplerest", "gessplatten", "gessplen", "verspleren", "upspleng", "rsreplen", "rosplen", "rspluglen", "rospllen", "rsplerree", "adssplure", "rspeenum", "rspleng", "rsspln"]}}
{"project": "FFmpeg", "commit_id": "76db17dc7d4f19f9a03bdd6de79c2ea37b76888f", "target": 0, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DPCMContext *s = avctx->priv_data;\n\n    int in, out = 0;\n\n    int predictor[2];\n\n    int ch = 0;\n\n    int stereo = s->channels - 1;\n\n    short *output_samples = data;\n\n    int shift[2];\n\n    unsigned char byte;\n\n    short diff;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    // almost every DPCM variant expands one byte of data into two\n\n    if(*data_size/2 < buf_size)\n\n        return -1;\n\n\n\n    switch(avctx->codec->id) {\n\n\n\n    case CODEC_ID_ROQ_DPCM:\n\n        if (stereo) {\n\n            predictor[0] = buf[7] << 8;\n\n            predictor[1] = buf[6] << 8;\n\n        } else {\n\n            predictor[0] = AV_RL16(&buf[6]);\n\n        }\n\n        SE_16BIT(predictor[0]);\n\n        SE_16BIT(predictor[1]);\n\n\n\n        /* decode the samples */\n\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n\n            predictor[ch] += s->roq_square_array[buf[in]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n\n\n    case CODEC_ID_INTERPLAY_DPCM:\n\n        in = 6;  /* skip over the stream mask and stream length */\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0])\n\n        output_samples[out++] = predictor[0];\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1])\n\n            output_samples[out++] = predictor[1];\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            predictor[ch] += interplay_delta_table[buf[in++]];\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n\n\n        break;\n\n\n\n    case CODEC_ID_XAN_DPCM:\n\n        in = 0;\n\n        shift[0] = shift[1] = 4;\n\n        predictor[0] = AV_RL16(&buf[in]);\n\n        in += 2;\n\n        SE_16BIT(predictor[0]);\n\n        if (stereo) {\n\n            predictor[1] = AV_RL16(&buf[in]);\n\n            in += 2;\n\n            SE_16BIT(predictor[1]);\n\n        }\n\n\n\n        while (in < buf_size) {\n\n            byte = buf[in++];\n\n            diff = (byte & 0xFC) << 8;\n\n            if ((byte & 0x03) == 3)\n\n                shift[ch]++;\n\n            else\n\n                shift[ch] -= (2 * (byte & 3));\n\n            /* saturate the shifter to a lower limit of 0 */\n\n            if (shift[ch] < 0)\n\n                shift[ch] = 0;\n\n\n\n            diff >>= shift[ch];\n\n            predictor[ch] += diff;\n\n\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n    case CODEC_ID_SOL_DPCM:\n\n        in = 0;\n\n        if (avctx->codec_tag != 3) {\n\n            if(*data_size/4 < buf_size)\n\n                return -1;\n\n            while (in < buf_size) {\n\n                int n1, n2;\n\n                n1 = (buf[in] >> 4) & 0xF;\n\n                n2 = buf[in++] & 0xF;\n\n                s->sample[0] += s->sol_table[n1];\n\n                if (s->sample[0] < 0)   s->sample[0] = 0;\n\n                if (s->sample[0] > 255) s->sample[0] = 255;\n\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n\n                s->sample[stereo] += s->sol_table[n2];\n\n                if (s->sample[stereo] < 0)   s->sample[stereo] = 0;\n\n                if (s->sample[stereo] > 255) s->sample[stereo] = 255;\n\n                output_samples[out++] = (s->sample[stereo] - 128) << 8;\n\n            }\n\n        } else {\n\n            while (in < buf_size) {\n\n                int n;\n\n                n = buf[in++];\n\n                if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F];\n\n                else s->sample[ch] += s->sol_table[n & 0x7F];\n\n                s->sample[ch] = av_clip_int16(s->sample[ch]);\n\n                output_samples[out++] = s->sample[ch];\n\n                /* toggle channel */\n\n                ch ^= stereo;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    *data_size = out * sizeof(short);\n\n    return buf_size;\n\n}\n", "idx": 9343, "substitutes": {"avctx": ["wavtx", "Avcontext", "AVcc", "AVconn", " avcontext", "vrcmp", "avconn", "avctl", "AVcmp", "vrcc", "Avconn", "Avpkg", "avectl", "AVtx", " avpkg", "wavctx", "vrtx", "wavcc", "AVctx", "AVcontext", "avecmp", "avcontext", "vrctx", "Avctx", "AVctl", "AVpkg", "avectx", " avconn", "wavctl", "avcmp", "wavcmp", "avtx", "avpkg", "avcc", "avetx"], "data": ["Data", "empty", "array", "next", "map", "buffer", "text", "message", "a", "frames", "padding", "image", "sample", "to", "area", "stream", "value", "p", "bin", "frame", "pad", "d", "block", "pos", "ref", "ata", "bits", "zero", "values", "type", "length", "raw", "window", "bytes", "mu", "package", "video", "body", "t", "feed", "cache", "input", "dat", "w", "table", "batch", "DATA", "content", "size"], "data_size": ["buf_length", "buf_Size", "data_length", "buf_SIZE", "data_Size", " data_ize", " data_Size", " data_SIZE", "data_SIZE", "buf_size", "data_ize"], "avpkt": ["avcpkt", "avpacket", "avbpacket", " avcpcmd", "afcpnt", "avppcmd", "avcpct", "avbpkt", "avcompct", "avbpcmd", "avcompacket", "afpkt", "afpck", " avpac", "afcpdu", "avnpnt", "avpck", "avcpcmd", "avPacket", " avcpct", "avcpix", " avcpacket", "avcpac", "avcompac", "avppck", "avppdu", "avPkt", " avpcmd", " avcpix", "avpdu", "avpix", "afpnt", "avpcmd", "avcpck", "avppacket", "avcpacket", "avPac", " avpct", "avppnt", "afcpkt", "avpnt", "avppix", "avcpdu", "avnpdu", "avpct", "avpac", " avpacket", " avpix", "afcpck", "avcpnt", "avcompkt", "avnpck", " avcpkt", " avcpac", "avppkt", "avPct", "avbpix", "afpdu", "avnpkt"], "buf": ["arr", "doc", "tr", "tx", "map", "config", "buffer", "mat", "uf", "aka", "rb", "req", "cam", "ff", "proc", "func", "p", "var", "bl", "seq", "prop", "words", "Buffer", "vec", "late", "pkg", "boxes", "docs", "cur", "args", "cb", "tab", "conv", "desc", "window", "bytes", "bs", "txt", "queue", "mem", "r", "br", "pb", "emb", "cap", "ctx", "aux", "v", "deg", "que", "cache", "b", "mates", "tmp", "cmd", "bh", "dat", "Buff", "font", "vals", "batch", "fx", "buff", "db", "pack", "cv", "img", "bag", "wb"], "s": ["sq", "vs", "spec", "a", "rs", "hs", "p", "gs", "sts", "ps", "d", "g", "cs", "m", "sv", "i", "r", "is", "js", "j", "S", "ss", "ts", "t", "ctx", "ssl", "v", "os", "sb", "b", "c", "h", "ns", "stats", "w", "sc", "set", "ls", "ds", "sys"], "in": ["In", "on", "inc", "add", "update", "o", "m", "ins", "win", "IN", "r", "row", "im", "t", "scan", "rin", "w", "pin", "el", "oin", "inner", "al", "at", "init", "ex", "ind", "iter", "um", "en", "loop", "mi", "inside", "ix", "new", "isin", "head", "no", "min", "id", "ai", "up", "k", "l", "pos", "local", "i", "gin", "ic", "window", "index", "chain", "from", "it", "ini", "inn", "len", "con", "p", "bin", "act", "din", "all", "is", "v", "input", "c", "x", "name"], "predictor": ["puppetlor", "peterminive", "pveyor", "predictcer", "proppredessor", " ppectessor", "peterminiler", "pictedOR", "ppectorb", "pointicator", "pocolator", "ppriutor", " ppectorb", "pointor", "predictler", "ppredier", "pveyutor", "predictive", "posteriler", "pjectable", "parampriOR", "propredictor", " predictors", "pjection", "exppredractor", "spredictcer", "propointior", "predictori", "pointOR", "puteori", "priptOR", "predictmor", "priptor", "exppriorable", " predictored", "pjectOR", "expredictractor", "postericator", "pictionored", "tpredictlor", "pingpriter", "ppredable", "ppector", "tpictlor", "posterutor", "patriptor", "pingredictor", "pictoring", "prredictee", "pjectoring", "ppredory", "pveyOR", "pingredictter", "prictionor", "prredictOR", "pveyter", "predictors", "puppetutor", "patredictler", "puteors", "paramredictOR", "ppredicator", "priptler", " ppector", "expredictutor", "prictioning", "prredictier", "posterior", "posteroring", "puppetOR", "predictcor", "predictessor", "parampricer", "potor", "expredictator", "propredictior", "pocolractor", "pjectter", "picticator", "pjectcer", "pjector", "propredicticator", "pocolorb", "propointor", "propointicator", "expprior", "pecting", "posterori", "pingredictutor", "posterler", "posterory", "prredicticator", "propredictOR", "ppredee", "ppecticator", "pprior", "predictory", "ppectator", "pingprior", "priptorb", "prredictor", "predictored", "ppredutor", "proppredor", "ppectOR", "pointors", "predictiler", "pingpriOR", "pjectessor", " predictcor", "spuppetor", "prpectator", "puteor", "prredictoring", "puppetcer", "ppectmor", "proppredutor", "puppetoring", "expredictorable", "predictator", "expredictoring", "posteruser", "puppetor", "prredictable", "pocolOR", "prosteriler", "ppriOR", "ppriator", "pveyior", "predictlor", "pictionOR", "pripticator", "priptessor", "exppredutor", "predictier", "pictionmor", "prpectessor", "pveyicator", "predictable", "pveyoring", "predictutor", "patredicticator", "tpictler", "pictionoring", "pictedor", "pocoloring", "putecor", "pocolutor", "pointcor", " predictOR", "pictOR", "pectoring", "predictter", "puppetier", "paramredictor", "predictuser", "peterminor", "peterminuser", "pjectorable", "expprioring", "pictor", "pictionler", "exppredor", "puppetior", "posteror", "posterion", "pictator", "patriptory", "pingosteroring", " predictorb", "pocoling", "prictionoring", "ppectee", "puppetori", "pictedored", " predictori", "pictionlor", "pictlor", "propredictessor", "spuppetcer", "spuppetion", "tpredictler", "tpictoring", "puppetler", "prredictessor", "tpictor", "potutor", "predicticator", "prpector", "propredictable", "pictessor", "prredicting", "pictionuser", "pocolable", "exppriator", "posteressor", "exppredator", "expredictor", "patredictory", "pjectator", "practor", "ppectessor", "prosteror", "pprioring", "priptory", "tpredictor", " ppectored", "pectable", " ppectOR", "ppectier", "pingredictOR", "pingosterior", "predictee", "pictler", "potator", "propointOR", "spredictor", "prredictive", "predictior", " ppectmor", "prictionable", "predictorable", "pictionable", "propredictutor", "spredictori", "pictioniler", "pictionive", "practoring", "pveycer", "tpredictoring", "prosterive", "pingpriutor", "ppredor", "ppriorable", "paramprioring", "prediction", "prpecticator", "patredictor", "ppectored", "ppricer", "pictioning", "pictcer", "ppredOR", "prpectOR", "ppriter", "puppetion", "pocolor", "prpectee", "pector", "pingredictoring", "pocolessor", "ppectior", "predictorb", "pjectutor", "prpectier", "pingredictior", "paramredictoring", "pictedmor", "pingosterutor", "predicting", "posterator", "sprediction", "posterive", "postercer", "ppredessor", "patripticator", "paramredictcer", "ppredractor", "pjectori", "predictOR", "pictionor", "practator", "prredictuser", "predictractor", "patriptler", "practorable", "proppredable", "puppetee", "ppredator", "prosteruser", " predictmor", "predictoring", "prredictator", "prredictiler", " predictessor", "pingosteror", "paramprior", "ppredler", "spuppetori", "potractor", "pointior", "pointori"], "output_samples": ["output_sessions", "output___sns", "output_scams", "output_exents", "output_itsages", "output_examples", "output___itsonents", "output_sns", "output_insonents", "output_itsides", "output_consages", "output___insamples", "output_statamples", "output_scessions", "output_sams", "output_statonents", "output_nources", "output_consonents", "output_nents", "output_swages", "output_itsonents", "output_sides", "output___sonents", "output_nsents", "output_nsamples", "output___sages", "output___insonents", "output_exns", "output_consides", "output_nsamps", "output___insns", "output_exonents", "output_insns", "output_namples", "output_nsources", "output_sages", "output_consamples", "output_namps", "output_Samples", "output_swonents", "output___samples", "output_statents", "output_timesamples", "output_Sessions", "output_sources", "output_sents", "output_swamples", "output_statns", "output_insamples", "output_scamples", "output___itsamples", "output___itsides", "output___sents", "output_swides", "output___sides", "output_Sams", "output_timesams", "output_samps", "output___insents", "output_itsamples", "output_insents", "output___itsages", "output_sonents", "output_timesessions"], "shift": ["align", "next", "power", "hift", "send", "Shift", "map", "pointer", "step", "hash", "push", "pos", "ref", "ptr", "index", "version", "count", "transform", "scale", "start", "slice", "seed", "set", "pack", "offset"], "byte": ["command", "cmp", "io", "buffer", "code", "channel", "base", "field", "bin", "pixel", "word", "bytes", " bytes", "bit", "attribute", "transfer", "de", "version", "mode", "b", "bb", "iff", "link", "Byte", "binary"], "diff": ["command", "cmp", " difference", " differences", "err", " compare", " delta", " change", "error", " dev", "d", " differential", " desc", " remaining", "desc", "mix", "Diff", " distance", " Diff", " step", "change", " dist", " mix", "iff", " err", " difficulty", " mismatch", " direction"], "out": ["output", "obj", "off", "vert", "net", "id", "io", "at", "course", "external", "or", "chan", "up", "end", "list", "to", "p", "point", "o", "OUT", "over", "ex", "ind", "pool", "nt", "pos", "l", "outs", "client", "timeout", "i", "dis", "parent", "ou", "Out", "all", "index", "bit", "outer", "chain", "j", "bound", "boot", "t", "new", "conn", "v", "b", "un", "cmd", "ot", "can", "it", "x", "batch", "set", "co", "no", "max", "size", "inn"], "ch": ["col", "Ch", "key", "ck", "gh", "channel", "q", "chan", "cy", "sch", "cell", "cor", "chn", "k", "p", "ach", "cl", "height", "ich", "cp", "th", "cur", "l", "cs", "chi", "chrom", "i", "cb", "high", "wh", "cht", "chain", "cho", "j", "row", "br", "y", "count", "v", "och", "chip", "b", "c", "sh", "cmd", "h", "kh", "ot", "cm", "ih", "sc", "tch", "ech", "x", "z", "batch", "CH", "cr", "history", "vc", "ht", "cha"]}}
{"project": "FFmpeg", "commit_id": "0f34c0789f855f04dce518ffc93a01bb943ba1aa", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 9347, "substitutes": {"s": ["ms", "sq", "spec", "qs", "eps", "rs", "span", "hs", "p", "gs", "sts", "f", "sim", "ps", "scope", "cs", "m", "service", "ins", "sv", "i", "fps", "ses", "es", "session", "r", "is", "js", "S", "ss", "ts", "n", "se", "less", "t", "ctx", "v", "sf", "ops", "e", "os", "b", "c", "h", "ns", "fs", "sc", "comm", "ls", "ims", "space", "ds", "sys"], "frame": ["rame", "render", "show", "frames", "source", "movie", "feature", "image", "sample", "stroke", "file", "picture", "profile", "point", "form", "f", "screen", "process", "type", "face", "sequence", "object", "word", "window", "ce", "video", "view", "t", "iframe", "one", "Frame", "zone", "fr", "line", "ace", "ence", "c", "scene", "framework", "load", "slice", "context", "set", "ze", "state"], "value": ["command", "key", "shift", "vector", "array", "map", "sum", "buffer", "text", "message", "image", "weight", "p", "field", "size", "variable", "vp", "m", "type", "sequence", "values", "position", "length", "window", "function", "index", "r", "data", "total", "version", "view", "state", "v", "VALUE", "action", "expression", "val", "Value", "scale", "set", "memory", "time", "name", "ue", "number"], "run": ["work", "len", "ride", "num", "con", "call", "record", "ran", "thread", "order", "q", "image", "plot", "go", "step", "pass", "range", "job", "task", "pair", "error", "seq", "cycle", "block", "process", "fun", "running", "flow", "loop", "index", "r", "try", "row", "n", "runs", "line", "un", "lock", "cmd", "Run", "force", "batch", "z", "set", "ur", "name", "draw", "length"], "x": ["depth", "xy", "tx", "id", "al", "path", "q", "image", "step", "axis", "pan", "k", "p", "height", "ex", "ox", "dx", "l", "m", "pos", "client", "wx", "X", "i", "position", "length", "xs", "mask", "lat", "index", "row", "ix", "data", "n", "t", "px", "v", "xi", "e", "line", "w", "xx", "yx", "color", "z", "ax", "grid", "offset", "size"], "y": ["key", "page", "py", "yt", "xy", "ya", "axy", "sky", "a", "ch", "vy", "ty", "base", "yy", "p", "height", "o", "ay", "m", "type", "my", "ies", "i", "ye", "iny", "lat", "try", "ys", "row", "n", "t", "entity", "Y", "v", "rot", "hot", "ey", "b", "c", "h", "uy", "gy", "sy", "sys", "iy", "table", "z", "angle", "ny", "size", "cy"], "plane": ["key", "depth", "shift", "id", "mate", "board", "pe", "cube", "side", "plot", "axis", "goal", "flat", "stroke", "profile", "p", "ve", "cut", "half", "pose", "scope", "limit", "late", "gate", "type", "planes", "sequence", "flow", "lane", "port", "layout", "mask", "panel", "se", "cone", "ane", "pen", "mode", "zone", "line", "dim", "pin", "slice", "piece", "spin", "offset", "angle"], "bits_per_plane": ["bits_per_panel", "bits_per_pose", "bits_PER_planes", "bits_per__planes", "bits_per__plane", "bits_per__pen", "bits_per_planes", "bits_per_pen", "bits_PER_pen", "bits_PER_panel", "bits_PER_position", "bits_per_plan", "bits_PER_plane", "bits_per_factor", "bits_PER_plan", "bits_PER_factor", "bits_per__position", "bits_per_position", "bits_PER_pose"], "d": ["dd", "u", "fd", "q", "p", "o", "f", "da", "dc", "g", "m", "l", "i", "D", "r", "data", "n", "ad", "t", "v", "b", "dim", "c", "h", "du", "dat", "di", "w", "bd", "z", "db", "dict", "dm", "dh", "dt", "ds", "dr"], "j": ["shift", "obj", "bj", "aj", "ja", "jump", "J", "jc", "at", "ch", "jo", "q", "step", "k", " jump", "p", "o", "job", "jit", "ind", "g", "jp", "m", "l", "other", "i", "json", "jj", "r", "_", "js", "uj", "n", "t", "jl", "v", "b", "oj", "it", "z", "dj", "el", "ji", "kj", "out", "ij"]}}
{"project": "FFmpeg", "commit_id": "aaf78e4d14b4875e4cff30e979421a1087337b9f", "target": 1, "func": "mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){\n\n    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));\n\n  mp_image_t* mpi=NULL;\n\n  int w2;\n\n  int number = mp_imgtype >> 16;\n\n\n\n  av_assert0(vf->next == NULL); // all existing filters call this just on next\n\n\n\n  //vf_dint needs these as it calls vf_get_image() before configuring the output\n\n  if(vf->w==0 && w>0) vf->w=w;\n\n  if(vf->h==0 && h>0) vf->h=h;\n\n\n\n  av_assert0(w == -1 || w >= vf->w);\n\n  av_assert0(h == -1 || h >= vf->h);\n\n  av_assert0(vf->w > 0);\n\n  av_assert0(vf->h > 0);\n\n\n\n  av_log(m->avfctx, AV_LOG_DEBUG, \"get_image: %d:%d, vf: %d:%d\\n\", w,h,vf->w,vf->h);\n\n\n\n  if (w == -1) w = vf->w;\n\n  if (h == -1) h = vf->h;\n\n\n\n  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;\n\n\n\n  // Note: we should call libvo first to check if it supports direct rendering\n\n  // and if not, then fallback to software buffers:\n\n  switch(mp_imgtype & 0xff){\n\n  case MP_IMGTYPE_EXPORT:\n\n    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.export_images[0];\n\n    break;\n\n  case MP_IMGTYPE_STATIC:\n\n    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[0];\n\n    break;\n\n  case MP_IMGTYPE_TEMP:\n\n    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.temp_images[0];\n\n    break;\n\n  case MP_IMGTYPE_IPB:\n\n    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:\n\n      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n      mpi=vf->imgctx.temp_images[0];\n\n      break;\n\n    }\n\n  case MP_IMGTYPE_IP:\n\n    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];\n\n    vf->imgctx.static_idx^=1;\n\n    break;\n\n  case MP_IMGTYPE_NUMBERED:\n\n    if (number == -1) {\n\n      int i;\n\n      for (i = 0; i < NUM_NUMBERED_MPI; i++)\n\n        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)\n\n          break;\n\n      number = i;\n\n    }\n\n    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;\n\n    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h);\n\n    mpi = vf->imgctx.numbered_images[number];\n\n    mpi->number = number;\n\n    break;\n\n  }\n\n  if(mpi){\n\n    mpi->type=mp_imgtype;\n\n    mpi->w=vf->w; mpi->h=vf->h;\n\n    // keep buffer allocation status & color flags only:\n\n//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);\n\n    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;\n\n    // accept restrictions, draw_slice and palette flags only:\n\n    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);\n\n    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;\n\n    if(mpi->width!=w2 || mpi->height!=h){\n\n//      printf(\"vf.c: MPI parameters changed!  %dx%d -> %dx%d   \\n\", mpi->width,mpi->height,w2,h);\n\n        if(mpi->flags&MP_IMGFLAG_ALLOCATED){\n\n            if(mpi->width<w2 || mpi->height<h){\n\n                // need to re-allocate buffer memory:\n\n                av_free(mpi->planes[0]);\n\n                mpi->flags&=~MP_IMGFLAG_ALLOCATED;\n\n                mp_msg(MSGT_VFILTER,MSGL_V,\"vf.c: have to REALLOCATE buffer memory :(\\n\");\n\n            }\n\n//      } else {\n\n        } {\n\n            mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n            mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;\n\n        }\n\n    }\n\n    if(!mpi->bpp) mp_image_setfmt(mpi,outfmt);\n\n    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){\n\n\n\n        av_assert0(!vf->get_image);\n\n        // check libvo first!\n\n        if(vf->get_image) vf->get_image(vf,mpi);\n\n\n\n        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){\n\n          // non-direct and not yet allocated image. allocate it!\n\n          if (!mpi->bpp) { // no way we can allocate this\n\n              mp_msg(MSGT_DECVIDEO, MSGL_FATAL,\n\n                     \"vf_get_image: Tried to allocate a format that can not be allocated!\\n\");\n\n              return NULL;\n\n          }\n\n\n\n          // check if codec prefer aligned stride:\n\n          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){\n\n              int align=(mpi->flags&MP_IMGFLAG_PLANAR &&\n\n                         mpi->flags&MP_IMGFLAG_YUV) ?\n\n                         (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME\n\n              w2=((w+align)&(~align));\n\n              if(mpi->width!=w2){\n\n#if 0\n\n                  // we have to change width... check if we CAN co it:\n\n                  int flags=vf->query_format(vf,outfmt); // should not fail\n\n                  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,\"??? vf_get_image{vf->query_format(outfmt)} failed!\\n\");\n\n//                printf(\"query -> 0x%X    \\n\",flags);\n\n                  if(flags&VFCAP_ACCEPT_STRIDE){\n\n#endif\n\n                      mpi->width=w2;\n\n                      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n//                  }\n\n              }\n\n          }\n\n\n\n          mp_image_alloc_planes(mpi);\n\n//        printf(\"clearing img!\\n\");\n\n          vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);\n\n        }\n\n    }\n\n    av_assert0(!vf->start_slice);\n\n    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)\n\n        if(vf->start_slice) vf->start_slice(vf,mpi);\n\n    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){\n\n            mp_msg(MSGT_DECVIDEO,MSGL_V,\"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\\n\",\n\n                  \"NULL\"/*vf->info->name*/,\n\n                  (mpi->type==MP_IMGTYPE_EXPORT)?\"Exporting\":\n\n                  ((mpi->flags&MP_IMGFLAG_DIRECT)?\"Direct Rendering\":\"Allocating\"),\n\n                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?\" (slices)\":\"\",\n\n                  mpi->width,mpi->height,mpi->bpp,\n\n                  (mpi->flags&MP_IMGFLAG_YUV)?\"YUV\":((mpi->flags&MP_IMGFLAG_SWAPPED)?\"BGR\":\"RGB\"),\n\n                  (mpi->flags&MP_IMGFLAG_PLANAR)?\"planar\":\"packed\",\n\n                  mpi->bpp*mpi->width*mpi->height/8);\n\n            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,\"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\\n\",\n\n                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],\n\n                mpi->stride[0], mpi->stride[1], mpi->stride[2],\n\n                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);\n\n            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;\n\n    }\n\n\n\n  mpi->qscale = NULL;\n\n  }\n\n  mpi->usage_count++;\n\n//    printf(\"\\rVF_MPI: %p %p %p %d %d %d    \\n\",\n\n//      mpi->planes[0],mpi->planes[1],mpi->planes[2],\n\n//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);\n\n  return mpi;\n\n}\n", "idx": 9349, "substitutes": {"vf": ["vlf", "vmlf", " vconf", "uvv", "invxf", "wirev", "devfr", "invf", "vfo", "servf", "vcj", "vb", "vv", "verff", "avfx", "uvma", "cvfx", "ivff", " vaf", "vl", "avf", "ivfo", "vma", "vp", "uvf", "vrfc", "envfg", "vfr", " vp", "vcf", "svfo", "convfa", "vfac", "uvfc", "versionxf", "nvfr", "vcfa", "ivfac", "vmj", "invfc", "verfc", "nvfo", "vrf", "cvcf", "wireg", "vfg", "vcb", "verf", "ffo", "vvconf", "vfc", "vof", "envf", "ovfa", "vfx", "vcfx", "verma", "devfg", "vcaf", "versionconf", "wireff", "uvfx", "avxf", "vvfl", "ff", "vcfl", " vz", "visj", "vislf", "vrcf", "wiref", "varxf", "uvfa", "vvma", "devfac", "vj", "varf", "vcconf", "vvf", "verof", " vfo", " vcf", "fcf", "vvfo", "vcr", "ivxf", "ovxf", "vev", "avfo", "vcma", "nvfa", "ovf", "vcv", "vframe", "ivfa", "uvxf", "servaf", "devxf", "vg", "vifo", "vef", "vfa", "vecf", "vz", "cvfs", "uvF", "visframe", "avcf", "cvv", "vcxf", "vvff", "wirecf", "vifa", "verfo", "invb", "convff", " vg", "vrfx", "cvfa", "ovma", "uvfo", "varfr", " vff", "servfg", "invfx", "devfa", "ovfo", "vpconf", " vfc", "avfs", "nvaf", "vvfa", "vaf", "vF", "invr", "ivg", "vrv", "ivF", "envfl", "svfx", "devff", "wirefa", "vcz", "vrz", "vif", "wirefs", "vr", "uvof", "vcl", "ovF", "svaf", " vfa", " vv", "wirefo", "vvxf", "svcf", " vr", "vpf", "vrfo", "viv", "ivof", "devaf", "nvff", "devfl", "cvfo", "avfc", "envaf", "vfs", "vcff", "vmframe", "vpfo", "uvcf", " vl", "vccf", "visf", "servfl", "vefa", "convaf", "ivfs", "cvp", "svf", "vfl", "vff", "vcfr", " vxf", "uvfr", " vfx", "nvf", "devf", "ivfr", "vvcf", "varfac", "ffc", "versionf", "vmf", "vxf", "invconf", "ivf", "svl", "ivfc", "cvf", "avp", " vb", " vfs", "vconf", "vcframe", "vcfo", "vpcf", "nvma", "verfl", "versionfx", "vcfc", "wirefc", "convf", "vclf"], "outfmt": ["outtno", "outfno", "outdno", "out_lt", "outflt", "outdlt", "_dlt", "outtlt", "out_no", "_flt", "_dno", "out_format", "_fmt", "out_mt", "outfformat", "outdmt", "_fno", "outdformat", "_dformat", "_dmt", "outtformat", "_fformat", "outtmt"], "mp_imgtype": ["mp_imtype", "mp_pgflag", "mp_imagestyle", "mp_imagflag", "mp_imtag", "mp_imType", "mp_imagType", "mp_imageType", "mp_pgstyle", "mp_imagetag", "mp_imagty", "mp_imgtag", "mp_pgtype", "mp_imgType", "mp_imagety", "mp_imageflag", "mp_pgType", "mp_imagtype", "mp_imty", "mp_imagtag", "mp_imflag", "mp_imagetype", "mp_imgstyle", "mp_imagstyle", "mp_imgty"], "mp_imgflag": ["mp__imgtag", "mp_bgflags", "mp__imgflag", "mp_imagFlag", "mp__imgtype", "mp__imgflags", "mp__imagtype", "mp_imagflag", "mp_bgtag", "mp_imgflags", "mp_bgFLAG", "mp_imagetag", "mp_imgFlag", "mp_bgFlag", "mp_imgtag", "mp_imglag", "mp__imagflags", "mp_imgFLAG", "mp_algFlag", "mp_bgtype", "mp_imageflag", "mp_algflag", "mp_imagtype", "mp_imaglag", "mp_bglag", "mp__imagtag", "mp_imagFLAG", "mp_imagtag", "mp_algFLAG", "mp_bgflag", "mp_imagflags", "mp_imageflags", "mp_imagetype", "mp__imagflag", "mp_alglag"], "w": ["ow", "wall", "power", "fw", "ww", "a", "ch", "iw", "wal", "q", "wy", "weight", "wi", "p", "widget", "we", "height", "W", "wid", "f", "ex", "d", "rw", "wr", "th", "g", "l", "wx", "way", "win", "wh", "window", "en", "word", "wa", "ew", "ln", "r", "wl", "html", "y", "wn", "wd", "v", "deg", "aw", "b", "wp", "wt", "sw", "c", "rew", "hw", "kw", " W", "x", "z", "tw", "work", "ht", "nw", "wb"], "h": ["depth", "hal", "he", "ph", "ah", "hr", "hm", "u", "ch", "pp", "q", "eh", "end", "ht", "k", "hs", "p", "hash", "height", "f", "size", "th", "g", "l", "hd", "hl", "length", "wh", "ho", "oh", "hh", "r", "hp", "j", "br", "n", "y", "html", "t", "count", "v", "uh", "phi", "ha", "zh", "hei", "rh", "host", "b", "c", "sh", "bh", "kh", "hw", "ih", "hang", "it", "his", "z", "hi", "history", "high", "hz", "H"], "m": ["tm", "mm", "gm", "em", "k", "p", "o", "f", "sm", "fm", "d", "g", "l", "bm", "mn", "mi", "r", "pm", "j", "im", "n", "mc", "t", "ctx", "perm", "v", "man", "b", "c", "tmp", "M", "cm", "mut", "dm", "mp", "am"], "mpi": ["ppi", "mapit", "mpci", "mto", "cmpi", "cmpo", "ppit", "mapci", "capci", "mapi", "mapa", "mpa", "ppci", "cpis", "cpi", "mppi", "capit", "pppi", "cmpis", "pmI", "cmpa", "cpI", "pmis", "mpit", "pmi", "cmpit", "mpI", "mappi", "cpit", "cmpI", "mtit", "mti", "mta", "mapo", "mpo", "capi", "pmit", "mpis", "cappi"], "w2": ["W2", "wordSecond", "wTwo", "vSecond", " w4", "w4", "wayTwo", "ew2", "wt2", "w02", "rw0", "w1", "vTwo", "ew02", "rw4", "hw02", "rw2", "v2", " w0", "wtlet", "word2", "ew1", "way2", "wordTwo", "wt4", "wlet", "wt0", "rw02", " wlet", "hw0", "wSecond", "hw2", "W0", "W02", " w1", "w0", "rwlet", "ew0", " w02", "W1", "waySecond"]}}
{"project": "FFmpeg", "commit_id": "e630ca5111077fa8adc972fe8a3d7e2b3e8dc91f", "target": 1, "func": "static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)\n\n{\n\n    Mp4Descr *descr = d->active_descr;\n\n    int predefined;\n\n    if (!descr)\n\n        return -1;\n\n\n\n    predefined = avio_r8(&d->pb);\n\n    if (!predefined) {\n\n        int lengths;\n\n        int flags = avio_r8(&d->pb);\n\n        descr->sl.use_au_start       = !!(flags & 0x80);\n\n        descr->sl.use_au_end         = !!(flags & 0x40);\n\n        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);\n\n        descr->sl.use_padding        = !!(flags & 0x08);\n\n        descr->sl.use_timestamps     = !!(flags & 0x04);\n\n        descr->sl.use_idle           = !!(flags & 0x02);\n\n        descr->sl.timestamp_res      = avio_rb32(&d->pb);\n\n                                       avio_rb32(&d->pb);\n\n        descr->sl.timestamp_len      = avio_r8(&d->pb);\n\n\n\n\n\n\n        descr->sl.ocr_len            = avio_r8(&d->pb);\n\n        descr->sl.au_len             = avio_r8(&d->pb);\n\n        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);\n\n        lengths                      = avio_rb16(&d->pb);\n\n        descr->sl.degr_prior_len     = lengths >> 12;\n\n        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;\n\n        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;\n\n    } else {\n\n        avpriv_report_missing_feature(d->s, \"Predefined SLConfigDescriptor\");\n\n\n    return 0;\n", "idx": 9351, "substitutes": {"d": ["dd", "fd", "q", "nd", "p", "o", "dev", "ind", "da", "dc", "dx", "g", "pd", "m", "l", "cd", "ld", "i", "did", "mod", "D", "dn", "details", "r", "md", "ord", "j", "de", "done", "n", "ad", "dl", "t", "new", "v", "rd", "e", "b", "dim", "c", "ed", "du", "dat", "di", "w", "bd", "db", "dm", "s", "dh", "debug", "sd", "dt", "ds", "dr"], "off": [" start", "obj", "Off", "bf", " offset", "uf", " fo", "offer", "begin", "ff", "ov", " Off", "offs", "OFF", " clen", "pos", "ref", "ap", " af", " coff", "uts", " pos", "of", "from", "set", "oa", "head", "offset"], "len": ["fin", "nl", "Len", "enc", "sp", "seq", "l", "ref", "lf", "length", "bytes", "en", "ength", "ln", "ail", "n", "cap", "Length", "count", "val", "h", "ls", "el", "ll", "L", "size", " length"], "descr": ["desccr", "descro", "reflectrr", "colpair", "congr", "distrs", "desrar", "desric", "Descar", "commentcr", " descral", "schecr", "portrt", "Descrs", "ecour", "relnr", " desccr", "descmr", "descsr", "riptrar", "colmr", "relro", "descriptioncr", "colr", " descnr", "ecrer", "riptric", "Descr", "regric", "descrer", "criptrr", "schemr", "escre", "descadr", "descriptionral", "escr", "descer", "descriptionmr", "reflectr", "escer", "riptr", "descre", "descrar", " descri", "descriptionrb", "escric", "digre", "regadr", "criptral", "descbr", "digpair", "descrr", "Descrc", "condric", "escR", "descour", "condral", "relsr", "desor", " descro", "descrs", "descn", "escro", "derr", "escbr", " descrar", "descR", "congadr", "descpair", "schepair", "relR", "portr", "commentr", "escrc", "distrc", "descriptionR", " descrb", "escrs", "ecrb", "descriptionrate", "distar", "derbr", "porter", "drawrer", "congric", "escar", "descral", " descrt", "derer", "escadr", "portrb", " descrate", "desr", "drawrb", "colrate", "commentnr", "scheral", "scheadr", "descriptionr", "condrr", "regn", "drawour", "ecri", "scheor", " descadr", "commentrs", "descric", "derric", "schere", "drawrar", " descrer", "distnr", "reler", "distsr", "relr", "esccr", "riptor", "scherate", "descnr", "commentsr", " descor", "commentre", " descpair", "colric", "commentrer", "scher", "descor", "ecr", "relrer", " descn", "ecrar", "distr", "distrer", "criptr", "drawri", "escrb", "scheric", "regr", "descrate", "escor", "descar", "descriptionpair", "criptrb", "digr", "descriptionre", "condr", " descer", "digral", "criptnr", "descriptionric", "descriptionnr", "descriptionrs", "reflectral", " descric", "descrc", "colR", "reflectric", "escrt", " descour", "descrt", "descrb", " descR", "congn", "criptric", " descbr", "drawr", "descri"], "predefined": [" predacted", "rediscovered", "pedocumented", "redocumented", "Preddefined", "Predocumented", "redacted", " prediscovered", "prediscovered", "reddefined", "Predef", "pedefined", " predef", " predocumented", "preddefined", "redefined", "predef", "Predefined", " preddefined", "predocumented", "peddefined", "redef", "Predacted", "predacted", "pediscovered"], "lengths": ["countss", "widths", "lengthances", "rollrs", "widthals", "lengthls", "widthies", " lengthts", "ENGTHerences", "liberences", "historys", " lengtht", " Lengths", "historyerences", "ENGTHments", "counts", "widthances", "Lengthls", "Lengths", "lengtherences", "libments", "Lengthss", "widtht", "engthies", " Lengthls", "widthjs", "engthts", "engthrs", "engthances", " Lengthss", "engtht", "widthrs", " Lengthjs", "engthals", "lengthjs", "countjs", "alignals", "rollies", "widthls", "widthts", "libs", " lengthances", "historyments", "lengtht", "Lengthjs", "lengthies", "rollls", "rolls", "lengthrs", "lengthts", "ENGTHs", "engthjs", "aligns", "lengthss", "alignjs", "countls", "lengthals", "alignrs", "engths", "engthls", "lengthments"]}}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n", "idx": 9352, "substitutes": {"env": ["vs", "ah", "entry", "map", "me", "config", "code", "policy", "end", "manager", "ev", "ec", "sp", "buf", "dev", "enter", "eng", "scope", "vp", "np", "te", "ptr", "vt", "window", "shell", "en", "server", "mem", "ce", "ctx", "conn", "v", "conf", "environment", "ten", "e", "sb", "sw", "h", "hw", "er", "sc", "context", "cv", "nv", "viron"], "r1": ["array001", "dr01", "ar2", "ar0", "ROne", "arfirst", "arrayfirst", " r0", " rOne", "dr001", "array01", "r0", "R1", "r01", "rOne", "array1", "R0", "dr1", "drfirst", "ar01", "arOne", "R2", "ar1", "rfirst", "ar001", "r001"], "r2": ["m0", "mTwo", "msec", "rad2", "ar2", "rad0", "radsec", "radTwo", " rtwo", " r4", " rsec", " r0", "Rtwo", "ar4", "r4", "r0", "rTwo", "R1", " rTwo", "R2", "m2", "ar1", "R4", "rsec", "artwo", "rtwo"]}}
{"project": "FFmpeg", "commit_id": "ec79b1fc88b2cc6a9ab6cd953efcdbaebedde233", "target": 1, "func": "static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr)\n\n{\n\n    WtvContext *wtv = s->priv_data;\n\n    AVIOContext *pb = wtv->pb;\n\n    while (!url_feof(pb)) {\n\n        ff_asf_guid g;\n\n        int len, sid, consumed;\n\n\n\n        ff_get_guid(pb, &g);\n\n        len = avio_rl32(pb);\n\n        if (len < 32)\n\n            break;\n\n        sid = avio_rl32(pb) & 0x7FFF;\n\n        avio_skip(pb, 8);\n\n        consumed = 32;\n\n\n\n        if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) {\n\n            if (ff_find_stream_index(s, sid) < 0) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 28);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, 0, sid, mediatype, subtype, formattype, size);\n\n                consumed += 92 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_stream2_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0 && !((WtvStream*)s->streams[stream_index]->priv_data)->seen_data) {\n\n                ff_asf_guid mediatype, subtype, formattype;\n\n                int size;\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &mediatype);\n\n                ff_get_guid(pb, &subtype);\n\n                avio_skip(pb, 12);\n\n                ff_get_guid(pb, &formattype);\n\n                size = avio_rl32(pb);\n\n                parse_media_type(s, s->streams[stream_index], sid, mediatype, subtype, formattype, size);\n\n                consumed += 76 + size;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_StreamIDSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_SubtitleSpanningEvent) ||\n\n                   !ff_guidcmp(g, EVENTID_TeletextSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t buf[258];\n\n                const uint8_t *pbuf = buf;\n\n                int buf_size;\n\n\n\n                avio_skip(pb, 8);\n\n                consumed += 8;\n\n                if (!ff_guidcmp(g, EVENTID_CtxADescriptorSpanningEvent) ||\n\n                    !ff_guidcmp(g, EVENTID_CSDescriptorSpanningEvent)) {\n\n                    avio_skip(pb, 6);\n\n                    consumed += 6;\n\n                }\n\n\n\n                buf_size = FFMIN(len - consumed, sizeof(buf));\n\n                avio_read(pb, buf, buf_size);\n\n                consumed += buf_size;\n\n                ff_parse_mpeg2_descriptor(s, st, 0, &pbuf, buf + buf_size, NULL, 0, 0, NULL);\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_AudioTypeSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                int audio_type;\n\n                avio_skip(pb, 8);\n\n                audio_type = avio_r8(pb);\n\n                if (audio_type == 2)\n\n                    st->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n\n                else if (audio_type == 3)\n\n                    st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                consumed += 9;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_DVBScramblingControlSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 12);\n\n                if (avio_rl32(pb))\n\n                    av_log(s, AV_LOG_WARNING, \"DVB scrambled stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n                consumed += 16;\n\n            }\n\n        } else if (!ff_guidcmp(g, EVENTID_LanguageSpanningEvent)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                AVStream *st = s->streams[stream_index];\n\n                uint8_t language[4];\n\n                avio_skip(pb, 12);\n\n                avio_read(pb, language, 3);\n\n                if (language[0]) {\n\n                    language[3] = 0;\n\n                    av_dict_set(&st->metadata, \"language\", language, 0);\n\n                    if (!strcmp(language, \"nar\") || !strcmp(language, \"NAR\"))\n\n                        st->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n                }\n\n                consumed += 15;\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_timestamp_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0) {\n\n                avio_skip(pb, 8);\n\n                wtv->pts = avio_rl64(pb);\n\n                consumed += 16;\n\n                if (wtv->pts == -1)\n\n                    wtv->pts = AV_NOPTS_VALUE;\n\n                else {\n\n                    wtv->last_valid_pts = wtv->pts;\n\n                    if (wtv->epoch == AV_NOPTS_VALUE || wtv->pts < wtv->epoch)\n\n                        wtv->epoch = wtv->pts;\n\n                if (mode == SEEK_TO_PTS && wtv->pts >= seekts) {\n\n                    avio_skip(pb, WTV_PAD8(len) - consumed);\n\n                    return 0;\n\n                }\n\n                }\n\n            }\n\n        } else if (!ff_guidcmp(g, ff_data_guid)) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (mode == SEEK_TO_DATA && stream_index >= 0 && len > 32 && s->streams[stream_index]->priv_data) {\n\n                WtvStream *wst = s->streams[stream_index]->priv_data;\n\n                wst->seen_data = 1;\n\n                if (len_ptr) {\n\n                    *len_ptr = len;\n\n                }\n\n                return stream_index;\n\n            }\n\n        } else if (!ff_guidcmp(g, /* DSATTRIB_WMDRMProtectionInfo */ (const ff_asf_guid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) {\n\n            int stream_index = ff_find_stream_index(s, sid);\n\n            if (stream_index >= 0)\n\n                av_log(s, AV_LOG_WARNING, \"encrypted stream detected (st:%d), decoding will likely fail\\n\", stream_index);\n\n        } else if (\n\n            !ff_guidcmp(g, /* DSATTRIB_CAPTURE_STREAMTIME */ (const ff_asf_guid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PBDATAG_ATTRIBUTE */ (const ff_asf_guid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_PicSampleSeq */ (const ff_asf_guid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) ||\n\n            !ff_guidcmp(g, /* DSATTRIB_TRANSPORT_PROPERTIES */ ff_DSATTRIB_TRANSPORT_PROPERTIES) ||\n\n            !ff_guidcmp(g, /* dvr_ms_vid_frame_rep_data */ (const ff_asf_guid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelChangeSpanningEvent */ (const ff_asf_guid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelInfoSpanningEvent */ (const ff_asf_guid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) ||\n\n            !ff_guidcmp(g, /* EVENTID_ChannelTypeSpanningEvent */ (const ff_asf_guid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) ||\n\n            !ff_guidcmp(g, /* EVENTID_PIDListSpanningEvent */ (const ff_asf_guid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) ||\n\n            !ff_guidcmp(g, /* EVENTID_SignalAndServiceStatusSpanningEvent */ (const ff_asf_guid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) ||\n\n            !ff_guidcmp(g, /* EVENTID_StreamTypeSpanningEvent */ (const ff_asf_guid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) ||\n\n            !ff_guidcmp(g, ff_index_guid) ||\n\n            !ff_guidcmp(g, ff_sync_guid) ||\n\n            !ff_guidcmp(g, ff_stream1_guid) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) {\n\n            //ignore known guids\n\n        } else\n\n            av_log(s, AV_LOG_WARNING, \"unsupported chunk:\"FF_PRI_GUID\"\\n\", FF_ARG_GUID(g));\n\n\n\n        avio_skip(pb, WTV_PAD8(len) - consumed);\n\n    }\n\n    return AVERROR_EOF;\n\n}\n", "idx": 9366, "substitutes": {"s": ["ms", "src", "events", "sq", "vs", "aps", "aunts", "qs", "a", "ats", "rs", "sg", "p", "gs", "sts", "hs", "sp", "proc", "ps", "cs", "m", "bits", "ins", "sv", "es", "ses", "i", "xs", "scl", "bs", "ies", "aus", "aws", "r", "is", "js", "S", "ss", "ts", "n", "its", "t", "ssl", "v", "conf", "ops", "os", "sb", "b", "c", "h", "ns", "stats", "w", "fs", "sc", "ls", "ims", "ds", "sys", "parts"], "mode": ["command", "key", "status", "code", "flag", "format", "proc", "form", "pad", "fm", "m", "timeout", "te", "kind", "mod", "mask", "de", "perm", "Mode", "dim", "mid", "cmd", "scale", "flags", "tag", "opt", "ode", "state"], "seekts": ["_tes", "_tp", "_ts", "ektes", "_times", "arets", "aretimes", "ekts", "ektp", "aretp", "aretes", "ektimes"], "len_ptr": ["l_ref", "len_pointers", "len2ref", "len_pointer", "l_pointers", "l_ptr", "l_pointer", "len2pointers", "len_ref", "len2ptr", "len2pointer"], "wtv": ["wdvt", "wpvt", "webti", "wdTV", "WTV", "wtnews", "wdtv", "wTV", "Wtv", "wtk", "wpTV", "wptk", "wvt", " wti", "wttv", "webTV", "webtv", "wdtk", "wtti", " wnews", "wnews", " wTV", "wptv", "wti", "webnews", "wtTV", "Wtk", "Wvt"], "pb": ["apy", "typ", "prefix", "pp", "span", "proc", "func", "amp", "pg", "vp", "obb", "eb", "pl", "b", "kb", "PB", "ib", "cv", "pro", "td", "bj", "tp", "uf", "rb", "tk", "tg", "sp", "prot", "jp", "um", "bs", "emb", "sb", "bot", "dp", "mp", "pid", "asp", "tf", "obj", "pc", "ub", "pt", "gp", "bp", "req", "resp", "cp", "prototype", "tc", "ap", "fb", "tab", "phy", "ctx", "px", "erb", "tmp", "bb", "peer", "oa", "py", "pan", "p", "pool", "fp", "pkg", "np", "cb", "lp", "pm", "snap", "wp", "sys", "stab", "msg", "wb"], "g": ["ge", "gg", " msg", "ug", "gn", "gm", "gp", "go", "sg", "tg", "p", "gs", "f", "pg", "m", "gate", "gz", "i", "gin", " gp", "ger", "ig", "G", "bg", "eg", "r", "gd", "j", "ga", "n", "t", "rg", "fg", "v", "alg", "cfg", "gu", "gc", " eg", "ang", "c", "fac", "gi", "og", "ag", "gt", "msg", "group", "gain", "vg"], "len": ["fin", "num", "lib", "syn", "nl", "fl", "lan", "Len", "enc", "compl", "sp", "seq", "trans", "vec", "limit", "l", "pos", "lon", "ref", "fun", "lf", "en", "mem", "ln", "il", "coll", "n", "fn", "dl", "t", "count", "v", "gen", "val", "elt", "z", "L", "set", "full", "ls", "el", "ll", "loc", "offset", "length"], "sid": ["typ", "ident", "sing", "desc", "session", "ser", "data", "t", "zi", "since", "sa", "elt", "song", "sd", "sym", "notice", "source", "lang", "uri", "sp", "sec", "sam", "ti", "login", "uin", "sat", "sb", "sta", "vid", " tid", "si", "seed", "esi", "pid", "src", "id", "buffer", "iq", "hash", "kid", "sal", "_", "ts", "sha", "mid", "sil", "ds", "uint", "side", "bid", "p", "uid", "seq", "sit", "sim", "fp", "pkg", "token", "bytes", "addr", "ssl", "site", "gc", "sn", "stat", "buff", "msg", "rid", "sys", " Sid"], "consumed": [" reconsumed", " reconsumption", "consumption", "cosumed", " consocated", "resumption", "cosumption", "cosuming", " consuming", "Consume", "consocated", "consume", "presuming", "consum", "resocated", "filledum", " consum", "filledumed", "cosum", " reconserved", " reconsocated", "Consuming", "conserved", "Consumption", "coserved", "resumed", " consumption", "filleduming", " conserved", "presume", "presumed", "presumption", "reserved", "Consumed", "fillederved", "consuming", "cosume"], "mediatype": ["mediactyp", "mediantypes", "mediiatyp", "medietyp", "mediatttype", "mediiattype", "medianty", "mediatty", "framanty", " mediatypes", "framiatpe", "mediattype", "mediattyp", "mediantime", "framatype", "mediantpe", "mediantype", "medattime", "medattotype", "medietype", "medimatyp", "mediattime", "medietpe", "mediatyp", "mediatime", "medattype", "mediattotype", "medimatype", "framanttype", "framatyp", "framatime", "mediiatime", " mediattime", "medatype", "mediaty", "medimatotype", "mediiatpe", "framatpe", "framiatyp", "mediactime", "mediattypes", " mediatyp", " mediatime", "mediactotype", "framiattype", "framantime", " mediattyp", "mediatpe", "framantype", "medimatime", "mediantyp", "framaty", "mediatypes", " mediattypes", "medatotype", "medatyp", " mediattype", "framiatype", "mediiaty", "medattyp", "mediiatype", "framattype", "mediiatypes", "mediatotype", "medatime", "medianttype", "mediettype", "medatypes", "mediactype"], "subtype": ["subtag", "Subclass", "SubType", " subclass", "Subcondition", "perty", "ubstyle", "Subtype", " substyle", "filrole", "subterm", "subcondition", "substyle", "regrole", "filtype", "tagty", "formatype", "filty", "subname", "perpe", "subrole", "tagtype", "filype", "regype", "regterm", "formatterm", "regtype", " subty", " subname", "ubname", "ubpe", "subpe", " subcondition", "subclass", "singstyle", "singtag", "subty", "ubtype", "ubtime", " subpe", "ubrole", "ubtag", "tagype", " subType", "subtime", "singclass", "singType", "singtype", "pertype", "ubterm", "formatrole", "pertime", "subype", "subType", "singcondition", "singname", "ubty", " subtag", " subtime", "tagrole", "ubype"], "formattype": ["featgroup", "transformtype", "flattemplate", "initype", "formatoption", "subtag", " formatcomment", "featerror", "filtertype", "repeatype", "feattemplate", "filtererror", "flattype", "initunit", "repeattype", " formatfield", "repeatunit", "flatype", "formaterror", "formatType", "flatType", "formatype", " formattag", "formatstyle", "formatgroup", "inittype", "filterunit", "transformtemplate", "transformype", "filtertag", "featfield", "mediastyle", "formrole", "subcomment", "transformgroup", "formattag", "formattemplate", "flatrole", "formType", " formaterror", "initoption", "mediarole", "filtercomment", "formatfield", "flatgroup", " formatoption", "mediaType", "formatcomment", "featunit", "flatstyle", "featype", "subfield", "repeatoption", "formatrole", " formatunit", "formtype", "formatunit", "feattype", "formstyle", "filterfield", " formatype"], "size": ["ms", "empty", "small", "id", "send", "num", "fd", "notice", "sum", "ose", "resolution", "format", "area", "sent", "height", "hash", "Size", "SIZE", "score", "limit", "timeout", "type", "gz", "length", "window", "ize", "bytes", "term", "mem", "storage", "amount", "large", "description", "data", "loss", "needed", "owner", "body", "sha", "count", "shape", "dim", "scale", "any", "sn", "member", "fee", "alias", "diff", "speed", "z", "set", "space", "sized", "time", "duration", "name", "offset", "style", "number"]}}
{"project": "qemu", "commit_id": "db12451decf7dfe0f083564183e135f2095228b9", "target": 1, "func": "static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n", "idx": 9399, "substitutes": {"klass": [" kla", "knlasses", "knlass", "mkclass", " klasses", "ikkclass", "skclass", " kls", "sklas", "knla", "kase", "Kla", "kclass", "knls", " klas", "mkls", "Klasses", "ikkase", "ktase", " kase", "mklass", " kclass", "klas", "kla", "ktlass", "Klass", "ktls", "mklas", "Kls", "kls", "ktclass", "sklass", "klasses", "ikklass", "ikkls", "skls"], "data": ["Data", "device", "init", "value", "dev", "bin", "d", "ata", "def", "attr", "ds", "kind", "bytes", "json", "mu", "bus", "info", "cache", "dat", "di", "res", "result", "DATA", "module", "name", "resources", "params"], "dc": ["td", "dd", "pc", "ctrl", "cca", "cam", "DC", "iac", "ec", "vc", "df", "cp", "da", "bc", "d", "tc", "cs", "cd", "drm", "desc", "cc", "dq", "mc", "ac", "lc", "rc", "gc", " DC", "c", "dim", "uc", "di", "cm", "nc", "dp", "cu", "fc", "disc", "dm", "cr", "dt", "dr", "ca"], "vdc": [" vcca", "ivdp", "wiredi", "Vdesc", "zdc", "vdesc", "portadr", "vdr", "vcca", " vdesc", " vtc", "wirecca", " vadr", "fdisc", "verdc", "vdisc", "ivdc", "ivdr", " vmc", "portcca", "vtc", "vdp", "portdc", " vdr", "vermc", "zDC", "ffc", "ftc", "wiredc", " vdp", "Vdr", "portdi", "Vdc", "Vcca", " vfc", "maxdc", "vdi", "verdisc", "Vdi", "Vmc", "wireadr", "vDC", "maxfc", "verDC", "ivdi", "vmc", "zdesc", "maxdisc", "Vdp", "zcca", "fdc", " vdisc", "VDC", "vadr", " vDC", "vfc", "Vdisc", "maxtc", " vdi"]}}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "int kvm_init(int smp_cpus)\n{\n    KVMState *s;\n    int ret;\n    int i;\n    if (smp_cpus > 1)\n        return -EINVAL;\n    s = qemu_mallocz(sizeof(KVMState));\n    if (s == NULL)\n        return -ENOMEM;\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n        s->slots[i].slot = i;\n    s->vmfd = -1;\n    s->fd = open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}", "idx": 9418, "substitutes": {"smp_cpus": ["smp_gpu", "smp_cs", "smp_cpuus", "smp_gps", "smp_cpuu", "smp_gpors", "smp_pus", "smp_gpus", "smp_compores", "smp_cus", "smp_cpu", "smp_cponents", "smp_cpors", "smp_conents", "smp_pores", "smp_compus", "smp_cpores", "smp_pu", "smp_cpos", "smp_pors", "smp_pos", "smp_gpos", "smp_cpuonents", "smp_gpores", "smp_compu", "smp_gponents", "smp_cu", "smp_cps", "smp_compos"], "s": ["ms", "vs", "still", "parts", "ats", "hs", "cs", "m", "details", "r", "http", "se", "y", "t", "sports", "os", "b", "sa", "w", "comm", "ims", "ports", "sym", "gets", "source", "tests", "sp", "gs", "sts", "ex", "changes", "g", "sv", "args", "ses", "sam", "bs", "server", "less", "js", "ys", "als", "ss", "new", "rets", "conf", "sb", "sc", "ls", "state", "sq", "obj", "spec", "sl", "qs", "rs", "as", "sm", "f", "l", "es", "ts", "n", "sw", "copy", "ns", "tes", "ds", "sync", "p", "south", "ps", "aws", "is", "j", "S", "its", "self", "v", "https", "search", "c", "h", "stats", "fs", "res", "st", "set", "uns", "sys", "store"], "ret": ["ert", "reset", "print", "ry", "cat", " Ret", "desc", "r", "t", "rem", "deg", "cmd", "elt", "str", "sr", "vet", "rm", "result", "ll", "dt", "arg", "tr", "et", "RET", "iter", "prot", "rev", "jp", "pret", "txt", "usr", "ter", "try", "ben", "sat", "aux", "final", "rets", "Ret", "rt", "z", "att", "get", "obj", "net", "url", "got", "nl", "back", "err", "nz", "compl", "resp", "ne", "nt", "ref", "def", "red", "it", "cert", "ft", "mt", "len", "lt", " RET", "fi", "flag", "det", "del", "let", "fun", "git", "cb", "addr", "alt", "ext", "expr", "cont", "j", "tn", "not", "gc", "val", "re", "res", "gt", "Return", "dr"], "i": ["key", " m", "inner", "ami", "id", "ai", "fi", "I", "li", "fire", " I", "p", "o", "point", "sim", "iri", "ind", "ui", "ni", "ip", "g", "m", "ori", "client", "ki", "ti", "ic", " si", "us", " ti", "mi", "index", "is", "in", "j", "im", "ix", "n", "y", "t", "ci", "iu", "zi", "v", "phi", " mi", "xi", "multi", "qi", "gi", "di", "bi", "pi", "si", "it", "x", "ini", " ii", " bi", "oi", "spin", " ni", " j", "ii"]}}
{"project": "qemu", "commit_id": "7c24384b3b984f0256ba10eb26d877ec28985019", "target": 1, "func": "static int64_t nfs_client_open(NFSClient *client, const char *filename,\n\n                               int flags, Error **errp)\n\n{\n\n    int ret = -EINVAL, i;\n\n    struct stat st;\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    if (!uri->server) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    strp = strrchr(uri->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 9434, "substitutes": {"client": ["command", "current", "con", "call", "config", "prefix", "network", "wrapper", "channel", "code", "document", "application", "secure", "cell", "manager", "web", "Client", "pattern", "contact", "form", "p", "cl", "problem", "list", "sim", "open", "component", "service", "local", "window", "util", "cli", "core", "server", "chain", "http", "cod", "connection", "collection", "view", "ci", "ctx", "conn", "plugin", "man", "acl", "cache", "remote", "qualified", "close", "c", "force", "hunt", "batch", "context", "co", "public", "cv", "app", "response", "grid", "hog", "store"], "filename": ["folder", "bf", "nm", "url", "username", "path", "source", "prefix", "FN", "kan", "Filename", "FIL", "ren", "til", "fp", "location", "original", "ename", "ame", "txt", "family", "ames", "fn", "directory", "journal", "ername", "fle", "title", "sbm", "wrong", "fil", "vr", "name", "kj"], "flags": ["Flags", "fd", "status", "nl", "flag", "ensions", "files", "FLAG", "bits", "args", "kind", "mask", " flag", "details", "cond", "links", "ts", "lag", "mode", "ags", "fields", "tags", "ns", "fs", "options", "vals", "features", "ents"], "errp": ["errpid", "testp", "ierpy", "warnpat", "rerpost", "testpre", "errpar", "aerpid", "riskp", "aerjp", "errper", "aerp", "arrap", "errpoint", "riskpid", "errpa", "outerping", "errorpre", "errord", "errphp", "warnap", "warnpy", "hlp", "errorap", "strjp", "ierp", "orping", "arrp", "aerphp", "errorpy", "aerpre", "hljp", "aerpat", "outerp", "noticephp", "ierpkg", "arrpy", "testper", "errping", "outerpost", "orpost", "aerpa", "errorpkg", "riskpar", " errpar", "warnp", "aerpoint", "noticepost", "testpat", "aerping", "strpid", "strpkg", "noticep", "aerpost", "errorpar", "strpy", "errap", "ierd", "errorp", "errpkg", "strd", " errpid", "testpa", "rerp", "errpre", "testpost", "errpy", "errjp", "hlphp", "errorpid", "errpat", "noticeper", "errorpa", "strphp", "hlpid", "errpost", "outerpoint", "rerper", "orp", "arrpat", "orpoint", "errd", "testphp", "rerphp", "errorpat"], "i": ["ami", "id", "ai", "I", "me", "io", "li", "ei", "q", "go", "k", "ri", "p", "f", "sim", "ind", "ex", "ui", "ip", "g", "gl", "m", "l", "my", "ki", "ti", "ic", "cli", "index", "mi", "chain", "is", "j", "ir", "ix", "series", "n", "y", "t", "ci", "\u0438", "iu", "phi", "v", "zi", "info", "xi", "gu", "multi", "qi", "b", "c", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "batch", "ini", "oi", "hi", "ji", "ims", "ori", "ii"], "st": ["status", "et", "St", " structure", "stream", "func", "sts", "f", "nt", " desc", " ST", "ptr", "usr", "r", "ist", "n", "os", "ST", "str", "stat", " dst", "name", "sth", "mt"], "uri": ["folder", " URI", "u", "ouri", "address", "url", "mate", "username", "path", "resource", "prefix", "doi", "sofar", "message", "range", "nu", "ri", "p", "RI", "form", "picture", "URI", "iri", "fp", "ui", "volume", "sim", "domain", "ip", "location", "ori", "util", "term", "cli", "server", "mi", "http", "ir", "browser", "node", "connection", "uni", "directory", "ugi", "phi", "direction", "bo", " ur", "uno", "basic", "via", "qi", "query", "du", "urate", "subject", "uu", "origin", "iterator", "definition", "ini", "ur", "nil", "umi", "description", "general", "ue"], "qp": [" qn", "qqvp", "quwp", "quup", "checkm", "eqlp", "rypr", "checkp", "qualphp", "questup", "aqpa", "eqp", " qap", "qwp", "sqp", "questap", "qpkg", "qualcp", " qr", "eqpa", "qupkg", "qualpn", " qP", "ryvp", "qualpr", "sqpa", "sqwp", "aqpkg", "ckp", "qualp", "qvp", "qn", "aqwp", "querypn", "ekcp", "checkcp", "questm", "ckpa", "aqp", "queryn", "questtp", "sqpm", "questpr", " qpa", "qur", "qpr", "qqphp", "questP", "sqtp", "ekpa", "qlp", "quap", "qualvp", "qcp", "qucp", "querywp", "sqr", "qualwp", "ryphp", "qqpr", "ekpkg", "quP", "aqap", "qpm", "quallp", "qun", "qm", "questlp", "querypm", "qphp", "querycp", "qpn", "qpa", "qup", " qcp", "aqcp", "qtp", "qupn", "qP", "qupa", "queryp", "ryp", "cklp", "squp", "checkpm", "questpa", "questp", "cktp", " qtp", " qm", "qap", "sqap", "qutp", "qr", "sqcp", "aqP", "sqm", "sqP", "querym", "aqm", "aqtp", "qualpa", "sqlp", "ekp", "eqpr", "qqp", "qum"], "file": ["len", "fin", "fi", "bf", "part", "status", "buffer", "path", "read", "channel", "base", "format", "io", "File", "ile", "f", "error", "fp", "files", "local", "progress", "port", "byte", "handle", "bit", "il", "data", "t", "dir", "str", "F", "table", "full", "fil", "db", "user", "name", "offset", "arg", "ret"], "strp": ["srlp", "StrP", "stringvp", "strg", "Strpa", "stringP", "stringps", "arrp", "sprlp", "sprp", "Strpos", "strivp", "Strps", "strps", "srP", "divp", " strvp", "Strp", "Strr", " strpos", " strP", " strg", "strpa", "strr", "divvp", "Strg", "stringp", " strping", "strir", "Strvp", "strvp", "arrP", "sprpat", "stripa", "srp", " strpa", "strlp", "Strping", " strr", "striP", "sprP", "strips", "strP", "srpat", "strpat", "arrpos", "divP", "strip", "strig", "arrping", "divpat", "strping", " strpat", "Strlp", "strpos", "Strpat"]}}
{"project": "FFmpeg", "commit_id": "6f7f2396049575fcf2054b4dafa19ca01381638e", "target": 1, "func": "static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) {\n\n    NUTContext * priv = avf->priv_data;\n\n    AVIOContext * bc = avf->pb;\n\n    nut_demuxer_opts_tt dopts = {\n\n        .input = {\n\n            .priv = bc,\n\n            .seek = av_seek,\n\n            .read = av_read,\n\n            .eof = NULL,\n\n            .file_pos = 0,\n\n        },\n\n        .alloc = { av_malloc, av_realloc, av_free },\n\n        .read_index = 1,\n\n        .cache_syncpoints = 1,\n\n    };\n\n    nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts);\n\n    nut_stream_header_tt * s;\n\n    int ret, i;\n\n\n\n    if ((ret = nut_read_headers(nut, &s, NULL))) {\n\n        av_log(avf, AV_LOG_ERROR, \" NUT error: %s\\n\", nut_error(ret));\n\n\n        return -1;\n\n\n\n\n    priv->s = s;\n\n\n\n    for (i = 0; s[i].type != -1 && i < 2; i++) {\n\n        AVStream * st = avformat_new_stream(avf, NULL);\n\n        int j;\n\n\n\n        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);\n\n\n\n        st->codec->has_b_frames = s[i].decode_delay;\n\n\n\n        st->codec->extradata_size = s[i].codec_specific_len;\n\n        if (st->codec->extradata_size) {\n\n            st->codec->extradata = av_mallocz(st->codec->extradata_size);\n\n\n\n\n\n            memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size);\n\n\n\n\n        avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den);\n\n        st->start_time = 0;\n\n        st->duration = s[i].max_pts;\n\n\n\n        st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag);\n\n\n\n        switch(s[i].type) {\n\n        case NUT_AUDIO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag);\n\n\n\n            st->codec->channels = s[i].channel_count;\n\n            st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom;\n\n            break;\n\n        case NUT_VIDEO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag);\n\n\n\n            st->codec->width = s[i].width;\n\n            st->codec->height = s[i].height;\n\n            st->sample_aspect_ratio.num = s[i].sample_width;\n\n            st->sample_aspect_ratio.den = s[i].sample_height;\n\n            break;\n\n\n        if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n\n\n\n    return 0;\n", "idx": 9435, "substitutes": {"avf": ["avef", "avv", " avc", "avefc", "avcf", "avec", "avfc", "iverv", "iverc", "afg", "ovfc", " avcf", "affs", "avefs", "averm", "iverfi", "afv", "avfr", " avfc", "avfab", "aveg", "iverfab", "ovfs", "averfs", "avefab", "aff", "afcf", "avg", "avfi", "avefo", "avfs", "affi", " avfi", "avecf", "wavf", "avefr", "wavfo", "affr", "ovm", "avc", "affo", "afc", "ivercf", "avem", "avfo", "iverf", "avm", "wavv", " avv", "averc", "wavg", "ovf", "averfr", " avfab", "averf", "avercf", "averfc", "avev"], "ap": ["aps", "op", "al", "tp", "pp", "bp", "prov", "sp", "amp", " sp", "ip", "np", "ata", "AP", "apt", "ad", "cap", "ac", "pl", "tap", "dat", " p", "att", " sap", "mp", "ape", "ar", "am"], "priv": ["obj", "tr", "tx", "Priv", "ctrl", "deb", "req", "prep", "alloc", "proc", "sp", "sub", "buf", "dev", "cp", "nt", "sec", "rw", "mint", "pkg", "admin", "attr", "ptr", "auth", "pri", "vt", "util", "pub", "usr", "txt", "core", "mem", "rel", "cap", "ctx", "conn", "rc", "rot", "conf", "cfg", "pr", "riv", "env", "exec", "pro", "cot", "serv", "pi", "ib", "private", "access", "iv", "loc", "soc", "sys"], "bc": ["ba", "CBC", "pc", "bf", "con", "bp", "ec", "cf", "dc", "tc", "cb", "ic", "bs", "bg", "BC", "pb", "mc", "ctx", "ac", "rc", "bo", "gc", "c", "bi", "voc", "nc", "bd", "bb", "sc", "fc", "ib", "db", "bt", "soc", "ca"], "nut": ["utt", "six", "Nut", "orn", "norm", "san", "net", "bolt", "anon", "or", "prep", "cut", "cro", "critical", "gob", "nt", "ut", "nor", "mint", "ox", "np", "cb", "nit", "vt", "uts", "core", "snap", "n", "roy", "box", "fn", "node", "tn", "rot", "chest", "pot", "nat", "tap", "fat", "tub", "tmp", "nuts", "ot", "rt", "cot", "etc", "tube", "stab", "orb", "tar", "nv"], "s": ["ms", "vs", "ats", "hs", "cs", "m", "ins", "details", "ids", "t", "sports", "ties", "os", "b", "sa", "w", "ims", "eds", "abilities", "ports", "socket", "gets", "sp", "gs", "sts", "bes", "changes", "g", "sv", "sam", "ses", "xs", "mods", "bs", "services", "als", "js", "ys", "ss", "strings", "scripts", "sb", "ings", "ls", "states", "sq", "spec", "locks", "sl", "aunts", "qs", "a", "rs", "as", "es", "ts", "n", "rings", "views", "ags", "sw", "ns", "ds", "p", "uploads", "ps", "objects", "us", "aws", "is", "S", "its", "v", "c", "h", "stats", "fs", "actions", "sys", "parts"], "ret": ["tf", "len", "tr", "reset", "status", "got", "et", "back", "err", "print", "det", "RET", "resp", "ry", "nt", "bad", "ref", "mt", "def", "txt", "alt", "mem", "ter", "r", "cont", "n", "t", "aux", "mel", "rem", "rets", "v", "deg", "val", "Ret", "red", "rt", "re", "elt", "res", "it", "vet", "gt", "bt", "ft", "out"], "i": ["ami", "id", "ai", "status", "I", "io", "me", "li", "ei", "uri", "iq", "list", "ri", "p", "ii", "o", "sim", "iri", "ind", "f", "ui", "ni", "ip", "g", "m", "l", "ki", "ti", "ic", "cli", "in", "mi", "index", "is", "im", "ix", "n", "y", "iu", "ci", "\u0438", "zi", "v", "info", "phi", "xi", "multi", "qi", "e", "h", "gi", "bi", "di", "pi", "si", "it", "x", "ini", "oi", "hi", "ji", "ims", "asi", "ij"], "st": ["td", "src", "tt", "art", "tr", "tra", "obj", "net", "et", "std", "sum", "pt", "St", "put", "ct", "step", "stan", "form", "sp", "stra", "sts", "start", "nt", "ut", "th", "stable", "stop", "ust", "ste", "usr", "so", "stage", "ist", "ts", "se", "t", "stru", "cast", "ast", "sty", "sw", "sh", "ST", "ost", "irst", "sn", "str", "est", "ot", "sta", "inst", "rest", "dist", "sc", "it", "stat", "mont", "stab", "set", "nd", "ft", "mt", "store"], "j": ["jac", "key", "obj", "bj", "on", "off", "u", "aj", "ja", "jump", "J", "jc", "ch", "q", "k", "p", "ng", "job", "o", "jit", "kid", "g", "jp", "other", "json", "jj", "_", "max", "js", "uj", "ix", "br", "n", "y", "t", "jl", "v", "fr", "b", "c", "h", "str", "oj", "bot", "by", "it", "x", "z", "att", "dj", "msg", "ju", "ji", "jack", "kj", "ij"]}}
{"project": "qemu", "commit_id": "41264b385c2b324fea026204e5de9bef980733b1", "target": 1, "func": "static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n    Error *local_err = NULL;\n#if !defined(CONFIG_USER_ONLY)\n    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;\n#endif\n#if !defined(CONFIG_USER_ONLY)\n    if (smp_threads > max_smt) {\n        error_setg(errp, \"Cannot support more than %d threads on PPC with %s\",\n                   max_smt, kvm_enabled() ? \"KVM\" : \"TCG\");\n    if (!is_power_of_2(smp_threads)) {\n        error_setg(errp, \"Cannot support %d threads on PPC with %s, \"\n                   \"threads count must be a power of 2.\",\n                   smp_threads, kvm_enabled() ? \"KVM\" : \"TCG\");\n#endif\n    cpu_exec_init(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n#if !defined(CONFIG_USER_ONLY)\n    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt\n        + (cs->cpu_index % smp_threads);\n#endif\n    if (tcg_enabled()) {\n        if (ppc_fixup_cpu(cpu) != 0) {\n            error_setg(errp, \"Unable to emulate selected CPU with TCG\");\n#if defined(TARGET_PPCEMB)\n    if (!ppc_cpu_is_valid(pcc)) {\n        error_setg(errp, \"CPU does not possess a BookE or 4xx MMU. \"\n                   \"Please use qemu-system-ppc or qemu-system-ppc64 instead \"\n                   \"or choose another CPU model.\");\n#endif\n    create_ppc_opcodes(cpu, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    init_ppc_proc(cpu);\n    if (pcc->insns_flags & PPC_FLOAT) {\n        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,\n                                 33, \"power-fpu.xml\", 0);\n    if (pcc->insns_flags & PPC_ALTIVEC) {\n        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,\n                                 34, \"power-altivec.xml\", 0);\n    if (pcc->insns_flags & PPC_SPE) {\n        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,\n                                 34, \"power-spe.xml\", 0);\n    if (pcc->insns_flags2 & PPC2_VSX) {\n        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,\n                                 32, \"power-vsx.xml\", 0);\n    qemu_init_vcpu(cs);\n    pcc->parent_realize(dev, errp);\n#if defined(PPC_DUMP_CPU)\n    {\n        CPUPPCState *env = &cpu->env;\n        const char *mmu_model, *excp_model, *bus_model;\n        switch (env->mmu_model) {\n        case POWERPC_MMU_32B:\n            mmu_model = \"PowerPC 32\";\n            break;\n        case POWERPC_MMU_SOFT_6xx:\n            mmu_model = \"PowerPC 6xx/7xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_74xx:\n            mmu_model = \"PowerPC 74xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx:\n            mmu_model = \"PowerPC 4xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx_Z:\n            mmu_model = \"PowerPC 4xx with software driven TLBs \"\n                \"and zones protections\";\n            break;\n        case POWERPC_MMU_REAL:\n            mmu_model = \"PowerPC real mode only\";\n            break;\n        case POWERPC_MMU_MPC8xx:\n            mmu_model = \"PowerPC MPC8xx\";\n            break;\n        case POWERPC_MMU_BOOKE:\n            mmu_model = \"PowerPC BookE\";\n            break;\n        case POWERPC_MMU_BOOKE206:\n            mmu_model = \"PowerPC BookE 2.06\";\n            break;\n        case POWERPC_MMU_601:\n            mmu_model = \"PowerPC 601\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_MMU_64B:\n            mmu_model = \"PowerPC 64\";\n            break;\n#endif\n        default:\n            mmu_model = \"Unknown or invalid\";\n            break;\n        switch (env->excp_model) {\n        case POWERPC_EXCP_STD:\n            excp_model = \"PowerPC\";\n            break;\n        case POWERPC_EXCP_40x:\n            excp_model = \"PowerPC 40x\";\n            break;\n        case POWERPC_EXCP_601:\n            excp_model = \"PowerPC 601\";\n            break;\n        case POWERPC_EXCP_602:\n            excp_model = \"PowerPC 602\";\n            break;\n        case POWERPC_EXCP_603:\n            excp_model = \"PowerPC 603\";\n            break;\n        case POWERPC_EXCP_603E:\n            excp_model = \"PowerPC 603e\";\n            break;\n        case POWERPC_EXCP_604:\n            excp_model = \"PowerPC 604\";\n            break;\n        case POWERPC_EXCP_7x0:\n            excp_model = \"PowerPC 740/750\";\n            break;\n        case POWERPC_EXCP_7x5:\n            excp_model = \"PowerPC 745/755\";\n            break;\n        case POWERPC_EXCP_74xx:\n            excp_model = \"PowerPC 74xx\";\n            break;\n        case POWERPC_EXCP_BOOKE:\n            excp_model = \"PowerPC BookE\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_EXCP_970:\n            excp_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            excp_model = \"Unknown or invalid\";\n            break;\n        switch (env->bus_model) {\n        case PPC_FLAGS_INPUT_6xx:\n            bus_model = \"PowerPC 6xx\";\n            break;\n        case PPC_FLAGS_INPUT_BookE:\n            bus_model = \"PowerPC BookE\";\n            break;\n        case PPC_FLAGS_INPUT_405:\n            bus_model = \"PowerPC 405\";\n            break;\n        case PPC_FLAGS_INPUT_401:\n            bus_model = \"PowerPC 401/403\";\n            break;\n        case PPC_FLAGS_INPUT_RCPU:\n            bus_model = \"RCPU / MPC8xx\";\n            break;\n#if defined (TARGET_PPC64)\n        case PPC_FLAGS_INPUT_970:\n            bus_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            bus_model = \"Unknown or invalid\";\n            break;\n        printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\"\n               \"    MMU model        : %s\\n\",\n               object_class_get_name(OBJECT_CLASS(pcc)),\n               pcc->pvr, pcc->msr_mask, mmu_model);\n#if !defined(CONFIG_USER_ONLY)\n        if (env->tlb.tlb6) {\n            printf(\"                       %d %s TLB in %d ways\\n\",\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n                   env->nb_ways);\n#endif\n        printf(\"    Exceptions model : %s\\n\"\n               \"    Bus model        : %s\\n\",\n               excp_model, bus_model);\n        printf(\"    MSR features     :\\n\");\n        if (env->flags & POWERPC_FLAG_SPE)\n            printf(\"                        signal processing engine enable\"\n                   \"\\n\");\n        else if (env->flags & POWERPC_FLAG_VRE)\n            printf(\"                        vector processor enable\\n\");\n        if (env->flags & POWERPC_FLAG_TGPR)\n            printf(\"                        temporary GPRs\\n\");\n        else if (env->flags & POWERPC_FLAG_CE)\n            printf(\"                        critical input enable\\n\");\n        if (env->flags & POWERPC_FLAG_SE)\n            printf(\"                        single-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DWE)\n            printf(\"                        debug wait enable\\n\");\n        else if (env->flags & POWERPC_FLAG_UBLE)\n            printf(\"                        user BTB lock enable\\n\");\n        if (env->flags & POWERPC_FLAG_BE)\n            printf(\"                        branch-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DE)\n            printf(\"                        debug interrupt enable\\n\");\n        if (env->flags & POWERPC_FLAG_PX)\n            printf(\"                        inclusive protection\\n\");\n        else if (env->flags & POWERPC_FLAG_PMM)\n            printf(\"                        performance monitor mark\\n\");\n        if (env->flags == POWERPC_FLAG_NONE)\n            printf(\"                        none\\n\");\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n        dump_ppc_insns(env);\n        dump_ppc_sprs(env);\n        fflush(stdout);\n#endif", "idx": 9437, "substitutes": {"dev": ["vs", "spec", "pc", "sky", "device", "cam", "ev", "proc", "ve", "vc", "pu", "pad", "nt", "cp", "def", "ver", "mem", "de", "test", "boot", "data", "ad", "ctx", "dem", "DEV", "conn", "v", "ac", "conf", "gu", "os", "Dev", "c", "Device", "des", "hw", "w", "serv", "cu", "link", "att", "sd", "nv", "ds", "sys"], "errp": ["errorr", "attrpoint", "ererping", "errwp", "errt", " errpoint", "rrm", "rrp", "attrping", "attrper", "errbp", "solpress", "attrj", "errper", "ererm", "errorj", "errpoint", "errps", " errm", " errP", "rrP", "solps", "rrps", "errP", "traceping", "errphp", "tracep", "ererphp", "erert", "errj", "ererpart", "errorP", "errorper", "errorpoint", "solp", "orderpoint", " errbp", "errping", "ererper", "rrpart", "rrbp", "tracebp", "errr", "rrt", "attrp", "errorps", "errm", "rrwp", " errping", "errorping", "errorphp", "attrpart", "errorp", " errr", "errpart", "ererj", "errpress", "orderp", "errorwp", "ererwp", "ererp", " errps", "attrps", "attrm", "errorpress", "attrt", "rrping", "orderr", "traceP", "solpoint", "rrphp", "errorm", "attrpress"], "cs": ["ms", "ck", "vs", "pc", "cmp", "cus", "cks", "css", "rs", "gs", "sts", "cp", "ps", "CS", "cf", "tc", "bits", "cc", "bs", "core", "js", "ts", "ctx", "cas", "rc", "ics", "wcs", "gc", "os", "caps", "c", "cn", "ns", "cms", "fs", "cu", "ks", "sc", "checks", "ces", "ls", "s", "ds", "ca", "sys"], "cpu": ["nic", "ck", "spec", "cum", "sync", "pc", "cmp", "gpu", "runner", "tp", "device", "alloc", "proc", "p", "cp", "pu", "linux", "component", "cow", "process", "tc", "local", "np", "cc", "util", "core", "CPU", "clock", "dt", "mem", "boot", "n", "ctx", "lc", "gc", "os", "cache", "c", "cn", "copy", "target", "hw", "nc", "cu", "kernel", "sc", "stat", "phys", "cv", "vm", "pro", "hz", "sys"], "pcc": ["pcs", "hcc", "ppcc", "tpcc", "Pcc", "pepc", "tpCC", " pcci", " pcs", "pnc", "pecc", "Ppc", "ppcs", " pCC", "hCC", "ppcci", "Pcci", "Pcs", "ppCC", "peCC", "ppnc", "PCC", "tpcci", "tpvc", "hvc", "ppc", "pvc", "penc", "hcci", "pppc", "Pvc", "pcci", "Pnc", "pCC"], "local_err": ["personalmyexc", "inner_err", "localjcss", "errorjtek", "personalmyerr", "localmyexc", "inner_norm", "localingexc", "local_loc", "error_err", "localmyfee", "local___notice", "local_tek", "personal_er", "local7notice", "local_exc", "localityerr", "localedexc", "personal_exc", "local___ev", "personalmyfee", "local7rr", "localityelt", "inner___err", "localedloc", "errorjcss", "personal_fee", "personal_loc", "local_elt", "personal_err", "local_fee", "inner___norm", "inner_notice", "local_er", "localingerr", "error_tek", "localjtek", "local___rr", "local7norm", "localedfee", "inner_rr", "errorjelt", "localityer", "local___res", "errorjerr", "localederr", "localitylog", "localmyloc", "personal_log", "local_norm", "localedcss", "local_log", " local_ev", "localedtek", "inner___rr", "localjelt", "local___norm", "local_css", "local_rr", "localjerr", "local_ev", "error_elt", "personalmyloc", "localingfee", "localedelt", "local_res", "local_notice", "localingloc", " local_res", "error_css", "local7err", "local___err", "localmyerr", "inner___notice", "personal_elt"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "idx": 9443, "substitutes": {"addr": ["ash", "on", "id", "address", "map", "nl", "arp", "a", "add", "Address", "at", "rs", "err", "alloc", "to", " address", "pad", "act", "g", "ref", "ptr", "i", "adr", "r", "ad", "now", "t", "ctx", "v", "host", "cmd", "eth", "hw", "res", "oad", "x", "set", "dh", "name", "offset", "state", "dr", "mt", "store"], "RAM_size": ["AM_len", "AM_SIZE", "RAM_len", "RAM_Size", "RAM_name", "RAM_SIZE", "AM_size", "AM_Size", "AM_name"], "dev": ["obj", "dd", "tr", "be", "priv", "av", "device", "cam", "go", "ev", "ve", "p", "pad", "nt", "g", "th", "def", "ptr", "ver", "mem", "cho", "de", "data", "n", "ad", "t", "new", "DEV", "conn", "v", "dem", "info", "gu", "die", "Dev", "sh", "cmd", "h", "des", "di", "w", "hw", "db", "iv", "sd", "ds", "out", "sys"], "s": ["ms", "sq", "sl", "a", "rs", "sp", "gs", "sts", "p", "ps", "g", "sing", "cs", "l", "es", "sv", "sam", "i", "bs", "so", "r", "is", "js", "S", "ss", "ts", "se", "n", "state", "v", "e", "sb", "b", "c", "sh", "h", "sa", "ns", "des", "fs", "si", "st", "set", "ls", "sd", "ds", "sys"], "d": ["dd", "fd", "device", "p", "o", "ld", "da", "dx", "ded", "del", "m", "g", "pd", "i", "D", "dn", "r", "md", "gd", "data", "n", "dq", "ad", "t", "v", "e", "b", "der", "c", "h", "di", "dat", "w", "bd", "dj", "db", "dm", "dh", "sd", "ds", "dr", "out"]}}
{"project": "qemu", "commit_id": "49aa4058ac6dd0081aaa45776f07c98df397ca5e", "target": 1, "func": "QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n\n{\n\n    char host[65], port[33], width[8], height[8];\n\n    int pos;\n\n    const char *p;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n\n\n    opts = qemu_opts_create(qemu_find_opts(\"chardev\"), label, 1, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        return NULL;\n\n    }\n\n\n\n    if (strstart(filename, \"mon:\", &p)) {\n\n        filename = p;\n\n        qemu_opt_set(opts, \"mux\", \"on\");\n\n        if (strcmp(filename, \"stdio\") == 0) {\n\n            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default\n\n             * but pass it to the guest.  Handle this only for compat syntax,\n\n             * for -chardev syntax we have special option for this.\n\n             * This is what -nographic did, redirecting+muxing serial+monitor\n\n             * to stdio causing Ctrl+C to be passed to guest. */\n\n            qemu_opt_set(opts, \"signal\", \"off\");\n\n        }\n\n    }\n\n\n\n    if (strcmp(filename, \"null\")    == 0 ||\n\n        strcmp(filename, \"pty\")     == 0 ||\n\n        strcmp(filename, \"msmouse\") == 0 ||\n\n        strcmp(filename, \"braille\") == 0 ||\n\n        strcmp(filename, \"stdio\")   == 0) {\n\n        qemu_opt_set(opts, \"backend\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"vc\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"vc\");\n\n        if (*p == ':') {\n\n            if (sscanf(p+1, \"%8[0-9]x%8[0-9]\", width, height) == 2) {\n\n                /* pixels */\n\n                qemu_opt_set(opts, \"width\", width);\n\n                qemu_opt_set(opts, \"height\", height);\n\n            } else if (sscanf(p+1, \"%8[0-9]Cx%8[0-9]C\", width, height) == 2) {\n\n                /* chars */\n\n                qemu_opt_set(opts, \"cols\", width);\n\n                qemu_opt_set(opts, \"rows\", height);\n\n            } else {\n\n                goto fail;\n\n            }\n\n        }\n\n        return opts;\n\n    }\n\n    if (strcmp(filename, \"con:\") == 0) {\n\n        qemu_opt_set(opts, \"backend\", \"console\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"COM\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"serial\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"file:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"file\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"pipe:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"pipe\");\n\n        qemu_opt_set(opts, \"path\", p);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"tcp:\", &p) ||\n\n        strstart(filename, \"telnet:\", &p)) {\n\n        if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1)\n\n                goto fail;\n\n        }\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == ',') {\n\n            if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n\n                goto fail;\n\n        }\n\n        if (strstart(filename, \"telnet:\", &p))\n\n            qemu_opt_set(opts, \"telnet\", \"on\");\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"udp:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"udp\");\n\n        if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) {\n\n                goto fail;\n\n            }\n\n        }\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == '@') {\n\n            p += pos + 1;\n\n            if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n                host[0] = 0;\n\n                if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) {\n\n                    goto fail;\n\n                }\n\n            }\n\n            qemu_opt_set(opts, \"localaddr\", host);\n\n            qemu_opt_set(opts, \"localport\", port);\n\n        }\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"unix:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        if (qemu_opts_do_parse(opts, p, \"path\") != 0)\n\n            goto fail;\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/parport\", NULL) ||\n\n        strstart(filename, \"/dev/ppi\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"parport\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"tty\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n", "idx": 9445, "substitutes": {"label": ["key", "lit", "id", "prefix", "path", "section", "format", "cell", "err", "bind", "value", "bl", "error", "l", "type", "local", "desc", "layout", "kind", "lab", "family", "abel", "index", "rel", "version", "line", "val", "comment", "title", "Label", "LAB", "alias", "color", "link", "group", "description", "name", "loc"], "filename": ["prefix", "license", "format", "mpeg", "location", "vp", "fps", "jpg", "family", "r", "data", "fr", "rather", "metadata", "b", "partial", "size", "folder", "output", "jing", "tp", "username", "path", "source", "message", "download", "asm", "ren", "files", "original", "println", "txt", "none", "fn", "final", "wikipedia", "without", "lower", "title", "temp", "fil", "src", "lua", "png", "amd", "url", "pdf", "file", "Filename", "f", "their", "ename", "unc", "xxx", "minimum", "n", "phy", "latest", "tmp", "nil", "text", "ammy", "til", "fp", "whatever", "np", "position", "json", "il", "j", "root", "directory", "v", "wine", "oval", "description", "name", "length", "sys"], "host": ["src", "be", "address", " Host", "prefix", "base", "begin", "weight", "bind", "ca", "domain", "addr", "server", "family", "http", "Host", "cast", "search", "binding", "present", "ost", "link", "localhost", "proxy", "head", "role", "store"], "port": ["page", "ports", "key", "password", "address", "url", "priority", "socket", "path", "prefix", "channel", "range", "file", "value", "cp", "domain", "ip", "type", "position", "server", "row", "line", "dp", "table", "link", "length"], "height": ["depth", "grow", "power", "sky", "ty", "buffer", "resolution", "padding", "read", "range", "widget", "hash", "bottom", "volume", "SIZE", "capacity", "dimension", "high", "length", "window", "hold", "Height", "family", "tight", "alpha", "html", "count", "radius", "shape", "above", "dim", "headers", "h", "scale", "crop", "hang", "border", "rank", "memory", "density", "angle", "important", "time", "history", "gravity", "size", "upper"], "pos": ["col", " start", "len", "op", "POS", "base", "proc", " position", " loc", "Pos", "ref", "type", "position", "top", "row", "data", "n", "os", "val", "pro", "start", "no", "name", "loc", "offset", " len"], "p": ["op", "u", "tp", "pe", "part", "pc", "path", "a", "pp", "pt", "prefix", "q", "ping", "bp", "k", "point", "sp", "f", "cp", "fp", "ps", "d", "g", "jp", "m", "l", "vp", "pkg", "i", "lp", "pard", "r", "pm", "j", "n", "pb", "y", "perm", "t", "P", "v", "pr", "e", "b", "c", "wp", "h", "w", "peer", "s", "pid", "pn", "pa"], "opts": ["opsps", "optfs", "imts", "droptions", "OPps", " copts", "opths", "otts", " ops", " opjs", " opcs", "opsters", " opmt", "obTS", "optps", "Opts", "oputs", "opends", "opems", "ioptions", "dropems", "Oputs", "opters", "OPTs", "options", "opt", "OPrs", " opTS", "opsmt", "opjs", "optts", "iopps", "imouts", "optems", "optTS", "Opcs", " opps", "optths", " cops", "obpt", "opps", "opsths", "opsits", "optends", "obters", "ioprs", "optters", "opls", " copTs", "iopt", "dropts", "ops", " options", "coptes", " oppt", "ropters", "imls", "opstions", "otps", "oprs", "optTs", "opTS", "opsts", "optjs", "ott", " opters", "ropps", "optrs", "iopcs", "ioppt", " opTs", "ropts", "Options", " opits", "ropTS", "Opjs", "rops", "obls", " opths", "opsuts", "optls", "opttions", "copps", "opouts", "optmt", "opTs", "Opends", "obt", "OPtions", "optits", "OPtes", " oputs", "opsends", "opsfs", "oppt", " optes", "optouts", " oprs", "cops", "otrs", "obouts", "opsems", "opmt", "iopTS", "optuts", "imTS", "optes", "opits", "imrs", " opt", "OPts", "iopts", "opsTs", "opsrs", "roptions", "copts", "obts", "OPt", "Opfs", "imters", "roprs", "Opps", "opfs", "opcs", " opfs", "OPs"], "local_err": [" local_eas", " local_er", "local_state", "local_priv", "global_err", "localpyplain", "locallyerror", "locallyerr", "localingplain", "local_error", "local____error", "local_eas", "locallyeas", "locallystate", "local____eas", "global_er", "local_cfg", "local__err", " local_state", "local_fee", "localpyrr", "local_er", "localingerr", " local_msg", "global_cfg", "locallyer", " local_plain", "local__msg", "local__priv", " local_error", "local_plain", "local____fee", " local_fee", "localingrr", " local_rr", "local_rr", " local_priv", "locallyfee", "local____err", "local__rr", "local_msg", "locallypriv", "localpyerr", "global_msg"]}}
{"project": "qemu", "commit_id": "c73860803f8f8f56ee01b6e796507bfb4ea073ec", "target": 1, "func": "POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER8\";\n\n    dc->desc = \"POWER8\";\n\n    pcc->pvr = CPU_POWERPC_POWER8_BASE;\n\n    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;\n\n    pcc->init_proc = init_proc_POWER7;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_STFIWX |\n\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;\n\n    pcc->msr_mask = 0x800000000284FF36ULL;\n\n    pcc->mmu_model = POWERPC_MMU_2_06;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER7;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n}", "idx": 9457, "substitutes": {"oc": ["oco", "arc", "pc", "oci", "loc", "alloc", "toc", "ec", "o", "cp", "bc", "ok", "oid", "tc", "osc", "unc", "orp", "ic", "cc", "OC", "ocation", "mc", "ac", "rc", "PC", "c", "uc", "og", "voc", "ot", "nc", "oe", "ocr", "ob", "roc", "org", "co", "soc", "vc"], "data": ["output", "doc", "Data", "dll", "device", "image", "rec", "dev", "bin", "da", "d", " DATA", "ata", "def", "raw", "mu", "rc", "cache", "dat", "di", "des", "res", "fee", "result", "DATA"], "dc": ["doc", "dd", "pc", "cca", "DC", "rec", "ec", "iac", "vc", "cp", "da", "bc", "d", "cat", "tc", "admin", "cd", "cc", "dt", "mc", "ac", "rc", "lc", "gc", "c", "uc", "di", "asc", "dat", "bd", "dp", "etc", "fc", "disc", "mac", "dm", "loc", "ds", "dr", "ca"], "pcc": ["ptc", "cpfc", "Pcc", "rcc", "phpCC", "pacc", "fcca", "phpcc", "ccp", "fCC", "pfc", "cbb", "attcoin", "Pct", "rCC", "phpcca", " pcoin", " pcca", " pct", "ppc", "pcoin", "fcc", "nck", "pct", "ccc", "mcca", "procca", " pcon", "pbb", "apck", "cptc", "mcoin", "ipcca", " pCC", "rpc", "Pcca", "mbb", "nct", "cpct", "p_", "ncca", "fpc", "percc", "cpac", "mCC", "apacc", "puc", "apcc", "pCC", "mcc", "ppC", "rcca", " ptc", "cpcca", "macc", " pac", "Ppc", "ncc", "attct", "attcca", "pcca", "procp", "cuc", "apct", " pck", "ppCC", "pC", "P_", "ncon", "pac", "pck", "muc", "cacc", "mfc", "ccca", "phpuc", "pp_", " pfc", "apuc", "mcp", "mct", "procc", "percon", "pcp", "ipcc", " puc", " p_", " pC", "pertc", "PCC", "perct", "PC", "ipCC", "probb", "pcon", "ipuc", "percca", "apcca", "mac", "attcc", "cpcc"]}}
{"project": "FFmpeg", "commit_id": "842e98b4d83d8cf297e2bc2761f1f47eb89e49e4", "target": 0, "func": "static int parse_object_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n    PGSSubObject *object;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n    int id;\n\n\n\n    if (buf_size <= 4)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 4;\n\n\n\n    id = bytestream_get_be16(&buf);\n\n    object = find_object(id, &ctx->objects);\n\n    if (!object) {\n\n        if (ctx->objects.count >= MAX_EPOCH_OBJECTS) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Too many objects in epoch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        object = &ctx->objects.object[ctx->objects.count++];\n\n        object->id = id;\n\n    }\n\n\n\n    /* skip object version number */\n\n    buf += 1;\n\n\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > object->rle_remaining_len)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        memcpy(object->rle + object->rle_data_len, buf, buf_size);\n\n        object->rle_data_len += buf_size;\n\n        object->rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    if (buf_size > rle_bitmap_len) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Buffer dimension %d larger than the expected RLE data %d\\n\",\n\n               buf_size, rle_bitmap_len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height || !width || !height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions (%dx%d) invalid.\\n\", width, height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    object->w = width;\n\n    object->h = height;\n\n\n\n    av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!object->rle)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(object->rle, buf, buf_size);\n\n    object->rle_data_len = buf_size;\n\n    object->rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n", "idx": 9482, "substitutes": {"avctx": ["savkw", "avwcs", "abcmd", " avcontext", "vartx", "avecontext", " avcf", "avecpp", "avcmd", " avcss", "iverctx", "averctx", " avcm", "savwcs", "avejac", "avetx", "wavkl", "abtx", "ajkw", "avconf", "wavctx", "navctx", "AVctx", "avcontext", "vrctx", "Avctx", "avercontext", "averkw", "avcm", "ajctx", "avectx", "savctx", " avtx", "averkl", "ivercontext", " avcmd", "Avcmd", "ajjac", "avcf", "iverkw", "avercss", "afctx", "varctx", "avekw", "AVtx", "vrtx", "afcpp", "AVcontext", "abctx", "avewcs", "avecmd", "Avtx", "aveconf", "afcontext", "wavcontext", " avcpp", "abcontext", "avjac", "wavpkg", "Avcontext", "ajwcs", "AVconf", "avcpp", "avcss", "varcf", " avpkg", "vrconf", "avkl", "averpkg", "navtx", " avkw", "afcmd", " avkl", "navcm", "avkw", "savjac", "vrcontext", "varcm", "avtx", "avpkg", "navcf", "ivercss"], "buf": ["arr", "doc", "shift", "len", "obj", "off", "bf", "config", "buffer", "read", "mat", "uf", "rb", "cam", "end", "begin", "err", "ff", "proc", "prop", "pool", "pad", "iter", "eng", "rw", "Buffer", "vec", "block", "ref", "bc", "pos", "ered", "fb", "cb", "desc", "conv", "args", "window", "txt", "usr", "queue", "mem", "br", "pb", "box", "cap", "emb", "eb", "v", "gen", "aw", "cast", "b", "tmp", "cmd", "orig", "Buff", "ob", "batch", "coord", "buff", "nb", "db", "bar", "cv", "pack", "msg", "img", "bag", "wb"], "buf_size": ["queue_len", "queue_size", "bu_size", "buf_scope", "buflengthdev", "buf_dev", "bufvalstorage", "uf2scale", "wav_se", "burst_0", "buf_sent", "buf_now", "uf_now", "bufval0", "burstvalsize", "buf_0", "port_size", "bu_engine", "bu_scale", "bufvallength", "buf00fee", "buf_length", "queue_start", "port00loss", "burstval0", "buf_sum", "port_loss", "buf_start", " buf_Size", "port00Size", "port_Size", "buf2space", "burstvalstorage", "buf2len", "uf2sent", "bu_SIZE", "port00fee", "br_loc", "buf_loss", "bufDscope", "buf00loss", "bufvalsize", "cv_size", "br_scope", "cv_scale", "buf_engine", "wav_size", "burst_storage", "buf_scale", "buf00scope", "queue_SIZE", "uf_sent", "buf2count", "buf_len", "bufDsize", "buf_se", "uf2len", "uf2size", "buf2size", " buf_space", "buflengthSIZE", "br_len", "buf_loc", "buf_ize", "buf_space", "cv_length", "uf_len", "buf2Size", "uf_SIZE", "buflengthlen", "buf_Size", "buf00size", "bufDloc", "bufDlen", "buf_SIZE", "uf_dev", "buf00Size", "br_size", " buf_count", "burstvallength", "burst_length", "buf2scale", "buflengthsize", "buf_fee", "burst_size", "port_fee", "uf_sum", "port00size", "buf_count", "buf00len", "buf_storage", "buf00loc", "wav_len", "wav_ize", "uf_size", "uf_scale", "buf2sent"], "ctx": ["obj", "tx", "fw", "cmp", "abc", "config", "prefix", "ctrl", " cx", "cam", "req", "ct", "func", "kt", " context", "cp", "cf", "nt", "xc", "bc", "act", "pkg", "tc", "np", "jp", "local", "cd", "args", "cb", "unc", "ctl", "cs", "window", "cc", "txt", "mc", "aux", "px", "conn", "check", "cfg", "acl", "wcs", "gc", "caps", "c", "cn", "cmd", "voc", "hw", "cm", "nc", "kw", "ns", "po", "fc", "context", "cv", "nd", "loc", "conv", "ca", "sys"], "object": ["thread", "or", "o", "block", "oid", "other", "detail", "account", "model", "parent", "package", "attribute", "data", "actor", "entity", "unknown", "metadata", "os", "target", "subject", "option", "onet", "ent", "result", "context", "user", "key", "art", "article", "address", "status", "resource", "source", "message", "at", "document", "value", "job", "delete", "author", "null", "relation", "version", "node", "interface", "environment", "identified", "member", "operator", "ob", "item", "no", "number", "thing", "obj", "array", "part", "buffer", "external", "order", "image", "device", "Object", "file", "profile", "associated", "point", "error", "unit", "volume", "component", "instance", "ase", "condition", "type", "element", "index", "owner", "connection", "comment", "library", "module", "out", "empty", "entry", "event", "complete", "child", "normal", "operation", "service", "zero", "position", "directory", "commit", "archive", "offset"], "sequence_desc": ["sequence2des", "sequenceuredes", "sequence2desc", "ence_Desc", "sequence_description", "sequence_enc", "sequence_dist", " sequence_dist", "ence_enc", "sequenceuredesc", "sequence___Desc", " sequence_Desc", "sequence_des", "sequence_Desc", "ence_des", "sequenceureenc", "sequence___des", "sequence2description", "sequence___dist", "sequence2Desc", "ence_desc", "sequenceureDesc", "ence_description", "sequence___desc", " sequence_des"], "rle_bitmap_len": ["rle_bitmap_Len", "rle_bitmap_size", "rle_bitmap_el", "rle_bitmap_lib", "rle_bitmap3l", "rle_bitmap_vec", "rle_bitmap2len", "rle_bitmap2l", "rle_bitmap2lib", "rle_bitmap3Len", "rle_bitmap3vec", "rle_bitmap2size", "rle_bitmap3len", "rle_bitmap_l", "rle_bitmap2el", "rle_bitmap2Len"], "height": ["depth", "grow", "power", "xy", "gravity", "gh", "sky", "show", "ty", "resolution", "padding", "huge", "ht", "hash", "bottom", "volume", "capacity", "dimension", "docker", "type", "length", "window", "wh", "Height", "lat", "background", "tight", "row", "alpha", "through", "rows", "html", "total", "count", "radius", "hei", "shape", "host", "dim", "h", "title", "ows", "w", "dist", "crop", "pi", "hang", "rank", "border", "density", "angle", "max", "history", "high", "size", "style", "distance"], "id": ["key", "Id", "obj", "num", "status", "url", "path", "base", "bid", "init", "iq", "k", "uid", "ident", "hash", "kid", "iter", "ip", "oid", "ref", "type", "i", "did", "kind", "addr", "index", "ID", "sid", "data", "ids", "ad", "one", "info", "val", " fid", "b", "iden", "mid", "h", "offset", " ID", "start", "vid", " tid", "alias", "it", "aid", "link", "tar", "tag", "no", "name", "pid", "rid"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,\n\n        RDMALocalBlock *block, uintptr_t host_addr,\n\n        uint32_t *lkey, uint32_t *rkey, int chunk,\n\n        uint8_t *chunk_start, uint8_t *chunk_end)\n\n{\n\n    if (block->mr) {\n\n        if (lkey) {\n\n            *lkey = block->mr->lkey;\n\n        }\n\n        if (rkey) {\n\n            *rkey = block->mr->rkey;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* allocate memory to store chunk MRs */\n\n    if (!block->pmr) {\n\n        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));\n\n    }\n\n\n\n    /*\n\n     * If 'rkey', then we're the destination, so grant access to the source.\n\n     *\n\n     * If 'lkey', then we're the source VM, so grant access only to ourselves.\n\n     */\n\n    if (!block->pmr[chunk]) {\n\n        uint64_t len = chunk_end - chunk_start;\n\n\n\n        trace_qemu_rdma_register_and_get_keys(len, chunk_start);\n\n\n\n        block->pmr[chunk] = ibv_reg_mr(rdma->pd,\n\n                chunk_start, len,\n\n                (rkey ? (IBV_ACCESS_LOCAL_WRITE |\n\n                        IBV_ACCESS_REMOTE_WRITE) : 0));\n\n\n\n        if (!block->pmr[chunk]) {\n\n            perror(\"Failed to register chunk!\");\n\n            fprintf(stderr, \"Chunk details: block: %d chunk index %d\"\n\n                            \" start %\" PRIuPTR \" end %\" PRIuPTR\n\n                            \" host %\" PRIuPTR\n\n                            \" local %\" PRIuPTR \" registrations: %d\\n\",\n\n                            block->index, chunk, (uintptr_t)chunk_start,\n\n                            (uintptr_t)chunk_end, host_addr,\n\n                            (uintptr_t)block->local_host_addr,\n\n                            rdma->total_registrations);\n\n            return -1;\n\n        }\n\n        rdma->total_registrations++;\n\n    }\n\n\n\n    if (lkey) {\n\n        *lkey = block->pmr[chunk]->lkey;\n\n    }\n\n    if (rkey) {\n\n        *rkey = block->pmr[chunk]->rkey;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9508, "substitutes": {"rdma": ["ddmodel", "rodm", "rodma", "rtm", "ddm", "hrm", "rdman", "ddla", "redma", "rdla", "rtml", "rtca", "ndm", "redca", "rtma", "rdmodel", "redsa", "ldmas", "redla", "drma", "ldma", "ridman", "rcmas", "drm", "rdmas", "ddsa", "drml", "rcma", "drmu", "rdm", "ridmic", "rodml", "rtla", "hrman", "ldm", "rdca", "rdmic", "ndmic", "hrma", "rodmu", "ndma", "rdmu", "rtsa", "rdsa", "rtmu", "ldmodel", "hrmic", "ddca", "ridm", "ridma", "ddmas", "rcm", "ddma", "rdml", "ndman", "rcmodel"], "block": ["ck", "map", "prefix", "open", "other", "word", "model", "row", "view", "check", "b", "raid", "address", "record", "network", "channel", "rock", "bl", "bc", "object", "request", "none", "link", "pack", "no", "BL", "draw", "byte", "work", "number", "obj", "wall", "part", "buffer", "device", "image", "book", "profile", "point", "unit", "frame", "blocking", "instance", "ip", "condition", "ref", "type", "def", "local", "raw", "window", "Block", "chain", "plugin", "bus", "line", "library", "module", "sync", "blocks", "join", "base", "event", "list", "p", "cl", "dev", "client", "zero", "all", "inv", "bit", "snap", "transfer", "box", "commit", "cache", "lock", "load", "tag", "x", "set", "group", "co", "disk", "store"], "host_addr": ["host_host", "host_ptr", " host_address", "host_address", " host_ptr", " host_host", "hostingptr", "hostingaddr", "hostingaddress"], "lkey": ["lice", "lbchar", "lplock", "slchar", "nlentry", "ellkey", "lclock", "lecase", "ulcheck", "nl123", "mstr", "lmax", "olcase", "ellchar", "ullock", "lcchar", "slkey", "olkey", "olport", " lmax", "nlkey", "lcKEY", "lpcheck", "ulKEY", "ellnote", "lpKEY", "lecache", "rentry", "dlce", "plquery", "dlmax", "nlmax", "dlentry", "lekey", "lccheck", "plkey", "lce", "lquery", "nlice", "l123", "lbentry", "lequery", "rchar", "r123", " lchar", "lcache", " lentry", "plport", "mkey", "ellowner", "ulkey", "lckey", "lcase", "mcache", "lcnote", "lbce", "nlowner", "leclient", "dlkey", "lport", "olquery", "lstr", "rcache", "rice", "mclient", "slnote", "lbmax", "rclient", "lentry", "lc123", "rmax", "llock", "lowner", "rowner", "leport", "lbkey", "plcase", "lpkey", "lcowner", "lcheck", "lKEY", "rstr", "lnote", "lclient", "lestr", "lchar", "nlce", "slowner", "lcice"], "rkey": ["rckey", " rflag", "rprint", "srKey", "srrule", "llink", "srflag", "vrkey", "dlock", "rbcond", "ronly", "drchar", "rrecho", "recho", " rcond", "rrule", "lno", "erkey", "rbonly", "rcond", "rKEY", "srkey", "wcond", " rmatch", "mchar", "rfield", "rmatch", "rlock", "srstart", "lrfield", "lseed", "drecho", "rrcond", "drule", "drowner", "lrkey", "srKEY", "rtkey", "drcode", "rcode", "rtlink", "mfield", "lrrule", "mrule", "drkey", "rchar", "erseed", "rcchar", "mkey", "rflag", "rcowner", "rcprint", "drcond", "rKey", "mprint", "vrlock", "erlink", "lflag", "rbmatch", "rlink", "lfield", "dKEY", "rtseed", "vrrule", "wkey", "dkey", "wcode", "srcond", "mowner", "rstart", "rbkey", "lstart", "mno", "lrule", "rrcode", " rfield", " rKey", "vrKEY", "rtrule", " ronly", "srmatch", " rrule", "rowner", "srlock", "lKey", "rseed", "rno", " rchar", "drprint", "sronly", "lrno", "errule", " rstart", "lchar", "rrkey", "wecho"], "chunk": ["chunc", "chnunker", "shundle", "chace", "archom", "chnruck", "chedunks", "tchunk", "tchow", " chanch", "achom", "echank", "chnunk", "achundle", " chunc", "chow", "chnow", "achace", "achack", "archanch", " chork", " chom", "echunk", "chedoke", "chnack", "shunk", "chnank", "chnom", "chnart", "chundle", "achow", "chimp", "chruck", "archruck", "achimp", "chnanch", "achunks", "chnace", "Choke", "achork", "chedunc", "chack", "tchart", "achank", "echace", "chork", "Chunks", "chom", "chnork", " chruck", "archunk", "chank", " choke", "achunk", "shoice", "Chunc", " chimp", "achart", "shork", " chunks", "echack", "achoice", "chunks", "chart", "chunker", "Chimp", "chedunk", " choice", "tchunker", "choke", "Chunk", "achunker", "choice", "achunc", "chanch", " chundle", " chunker"], "chunk_start": ["chart_end", "chunk_st", "chunktpart", "chunks_end", "chunktstart", "chart_start", "chunker_origin", "chunk_begin", "chunker_end", "chunk_len", "chunks_from", "chunk_offset", "chunks_first", "chunktend", "chunks_start", "chunk_index", "chunk_from", "chunk_part", "chunktorigin", "chart_begin", "chunker_start", "chunker_part", "chunk_first", "chunks_len", "chart_index", "chunks_st", "chunk_origin", "chunk_size", "chunks_size", "chunks_offset"], "chunk_end": ["chulk_offset", "chunks_start", "chulk_start", "chunk_en", "chulk_end", "chunk32start", "chunk_offset", "chimp_ending", "chunks_end", "chulk_stop", "chunk_line", "chunk32line", "chunk32en", "chimp_ends", "chunks_en", "chimp_start", "chunks_line", "chunk32end", "chunk_stop", "chunk_ends", "chunk_ending", "chimp_end"], "total_registrations": ["total_registrators", "total_resistries", "total_regdistrators", "total_regibration", "total_remistration", "total_remistsries", "total_resistration", "total_regibations", "total_remistrations", "total_registration", "total_registsries", "total_regdistration", "total_resistsration", "total_resistsrations", "total_regisrators", "total_remistations", "total_remistsations", "total_resistsrators", "total_regdistries", "total_registsrations", "total_resistrations", "total_resistrators", "total_resistsries", "total_regisrations", "total_remistsration", "total_regestrations", "total_registations", "total_regisration", "total_registsration", "total_registsations", "total_regestations", "total_registries", "total_regestries", "total_remistsrations", "total_regibrations", "total_remistries", "total_regestration", "total_regisries", "total_regdistrations", "total_registsrators", "total_regibries"]}}
{"project": "qemu", "commit_id": "e3697092228770c3b23d0bf524e18b508b109932", "target": 1, "func": "static void vga_draw_graphic(VGAState *s, int full_update)\n\n{\n\n    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;\n\n    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;\n\n    int disp_width, multi_scan, multi_run;\n\n    uint8_t *d;\n\n    uint32_t v, addr1, addr;\n\n    vga_draw_line_func *vga_draw_line;\n\n\n\n    full_update |= update_basic_params(s);\n\n\n\n    if (!full_update)\n\n        vga_sync_dirty_bitmap(s);\n\n\n\n    s->get_resolution(s, &width, &height);\n\n    disp_width = width;\n\n\n\n    shift_control = (s->gr[0x05] >> 5) & 3;\n\n    double_scan = (s->cr[0x09] >> 7);\n\n    if (shift_control != 1) {\n\n        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;\n\n    } else {\n\n        /* in CGA modes, multi_scan is ignored */\n\n        /* XXX: is it correct ? */\n\n        multi_scan = double_scan;\n\n    }\n\n    multi_run = multi_scan;\n\n    if (shift_control != s->shift_control ||\n\n        double_scan != s->double_scan) {\n\n        full_update = 1;\n\n        s->shift_control = shift_control;\n\n        s->double_scan = double_scan;\n\n    }\n\n\n\n    if (shift_control == 0) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE4D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE4;\n\n        }\n\n        bits = 4;\n\n    } else if (shift_control == 1) {\n\n        full_update |= update_palette16(s);\n\n        if (s->sr[0x01] & 8) {\n\n            v = VGA_DRAW_LINE2D2;\n\n            disp_width <<= 1;\n\n        } else {\n\n            v = VGA_DRAW_LINE2;\n\n        }\n\n        bits = 4;\n\n    } else {\n\n        switch(s->get_bpp(s)) {\n\n        default:\n\n        case 0:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8D2;\n\n            bits = 4;\n\n            break;\n\n        case 8:\n\n            full_update |= update_palette256(s);\n\n            v = VGA_DRAW_LINE8;\n\n            bits = 8;\n\n            break;\n\n        case 15:\n\n            v = VGA_DRAW_LINE15;\n\n            bits = 16;\n\n            break;\n\n        case 16:\n\n            v = VGA_DRAW_LINE16;\n\n            bits = 16;\n\n            break;\n\n        case 24:\n\n            v = VGA_DRAW_LINE24;\n\n            bits = 24;\n\n            break;\n\n        case 32:\n\n            v = VGA_DRAW_LINE32;\n\n            bits = 32;\n\n            break;\n\n        }\n\n    }\n\n    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];\n\n\n\n    depth = s->get_bpp(s);\n\n    if (s->line_offset != s->last_line_offset ||\n\n        disp_width != s->last_width ||\n\n        height != s->last_height ||\n\n        s->last_depth != depth) {\n\n        if (depth == 16 || depth == 32) {\n\n            if (is_graphic_console()) {\n\n                qemu_free_displaysurface(s->ds->surface);\n\n                s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,\n\n                                                               s->line_offset,\n\n                                                               s->vram_ptr + (s->start_addr * 4));\n\n                dpy_resize(s->ds);\n\n            } else {\n\n                qemu_console_resize(s->ds, disp_width, height);\n\n            }\n\n        } else {\n\n            qemu_console_resize(s->ds, disp_width, height);\n\n        }\n\n        s->last_scr_width = disp_width;\n\n        s->last_scr_height = height;\n\n        s->last_width = disp_width;\n\n        s->last_height = height;\n\n        s->last_line_offset = s->line_offset;\n\n        s->last_depth = depth;\n\n        full_update = 1;\n\n    } else if (is_graphic_console() && is_buffer_shared(s->ds->surface) &&\n\n               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {\n\n        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);\n\n        dpy_setdata(s->ds);\n\n    }\n\n\n\n    s->rgb_to_pixel =\n\n        rgb_to_pixel_dup_table[get_depth_index(s->ds)];\n\n\n\n    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)\n\n        s->cursor_invalidate(s);\n\n\n\n    line_offset = s->line_offset;\n\n#if 0\n\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n\n           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);\n\n#endif\n\n    addr1 = (s->start_addr * 4);\n\n    bwidth = (width * bits + 7) / 8;\n\n    y_start = -1;\n\n    page_min = 0x7fffffff;\n\n    page_max = -1;\n\n    d = ds_get_data(s->ds);\n\n    linesize = ds_get_linesize(s->ds);\n\n    y1 = 0;\n\n    for(y = 0; y < height; y++) {\n\n        addr = addr1;\n\n        if (!(s->cr[0x17] & 1)) {\n\n            int shift;\n\n            /* CGA compatibility handling */\n\n            shift = 14 + ((s->cr[0x17] >> 6) & 1);\n\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n\n        }\n\n        if (!(s->cr[0x17] & 2)) {\n\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n\n        }\n\n        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);\n\n        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);\n\n        update = full_update |\n\n            cpu_physical_memory_get_dirty(page0, VGA_DIRTY_FLAG) |\n\n            cpu_physical_memory_get_dirty(page1, VGA_DIRTY_FLAG);\n\n        if ((page1 - page0) > TARGET_PAGE_SIZE) {\n\n            /* if wide line, can use another page */\n\n            update |= cpu_physical_memory_get_dirty(page0 + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n", "idx": 9509, "substitutes": {"s": ["events", "ats", "hs", "cs", "m", "ins", "details", "r", "http", "se", "sports", "t", "os", "b", "cmd", "sa", "w", "serv", "comm", "ims", "rates", "status", "source", "settings", "gs", "sts", "ex", "changes", "g", "ies", "sv", "ses", "sam", "bs", "services", "less", "js", "als", "ss", "conf", "ops", "sb", "z", "sis", "ls", "states", "state", "sq", "obj", "spec", "sl", "qs", "a", "rs", "as", "sm", "es", "i", "in", "ts", "n", "sw", "ns", "er", "ds", "eps", "p", "an", "sim", "ps", "service", "so", "aws", "is", "j", "S", "its", "c", "bis", "h", "stats", "fs", "stat", "set", "sys"], "full_update": [" full__UPDATE", "full1touch", "ful_update", "fullernew", " full__edit", "inner_apply", "fullthebatch", " full_n", "fulllyupdated", "fulleredit", "inner67apply", "full_UPDATE", "ful_run", " full_edit", "fullyerrun", "inner_diff", "full1edit", "full_up", "fullyupdate", "full1updated", "fullerdiff", "inner_batch", "fullpren", "full_apply", "full_updated", "fulltheapply", "fullamUPDATE", "fully_new", "full_start", "inner67diff", "full_run", "fulltheupdate", "full67UPDATE", "full__edit", " full_updated", "fullerbatch", "fully_update", "inner_update", "full67update", "fullamedit", "fulllyup", "full67updated", " full_UPDATE", "full_touch", "fullyupdated", "full1update", "inner67batch", "full67batch", "full__UPDATE", "fulllystart", "fullamupdated", "full__run", "ful_result", "full_result", "full_batch", "fullyup", "fullystart", "full___n", "fullerrun", "full67touch", "ful_updated", "full_n", "fullyernew", "ful_up", "full__new", "fullerupdate", "full67apply", " full__update", " full_touch", "full67edit", "full_new", " full__updated", "inner67update", "full67diff", "fullyeredit", "full_edit", "fullthediff", "fulllyupdate", "ful_start", "fullyerupdate", "fullamupdate", "fullerapply", "fully_edit", "full__update", "full_diff", "full__updated", "fully_run"], "y1": ["y0", "xy1", "xy2", "xy0", "Y1", "Y0", " y0", " y2", "Y2", "y2", "Y3", "y3", " y3", "xy3"], "y": ["page", "xy", "draw", "sky", "k", "p", "o", "g", "m", "my", "i", "dy", "scroll", "j", "t", "Y", "ey", "b", "ym", "gy", "w", "iy", "x", "z", "offset", "cy"], "update": ["num", "id", "status", "add", "image", "up", "init", "end", "o", "m", "window", "bit", "dirty", "create", "version", "new", "updated", "date", "val", "start", "w", "batch", "set", "offset", "out"], "page_min": ["page__1", "row_min", "row_1", "page_start", "page_1", "page__min", "page__max", "page__start", "row_max", "row_start"], "page_max": ["page_ax", " page_ax", " page_end", "page_end"], "linesize": ["blocksz", "linz", " linesz", " linesizes", " linessize", "linsize", "linesz", "linesizes", "linessize", "linize", "linizes", "blocksizes", "blockssize", "blocksize"], "y_start": ["y_offset", "ymmstart", "ymmrange", "y_range", "line_range", "line_start", "line_end", "y_end", "ymmend", "ymmoffset"], "double_scan": ["double__can", " double_index", " double_scroll", "double_plan", "multi_sc", " double_scale", "double__scale", "double2scan", "single_read", "doubleJrun", "double2scale", "doubleptpass", "doublelyget", "double2can", "double__scan", "doubleJget", " double_run", "doubleptrun", " double_pass", "doubleogplan", "single_index", "doubleJscan", "doublelyindex", "double42run", "double_index", "double_send", "double_fan", "double_sc", "double\u0648run", "doubleogrun", "single_fan", "doubleptwrite", " double_write", "single_scan", "double_scale", "double_can", "doublelyscale", "single_send", "double_run", "double\u0648read", "single_get", "single_plan", "doubleplescan", "double42sc", "double\u0648scan", "double_read", "multi_stat", "doubleogsend", "double2scroll", "double_write", "double42scan", "double42stat", "doubleptscan", "doubleplerun", "double_pass", "double_scroll", " double_can", "doublelyscan", "doubleJindex", "doubleplesc", "double_reach", "multi_reach", "double_stat", "double_get", "doubleplestat", "doublelyrun", "double\u0648fan", "single_run", "double__scroll", "multi_scale", "doubleogscan"], "mask": ["ms", "clear", "key", "id", "map", "flag", "hide", "q", "weight", "pad", "ip", "label", "m", "hold", "filter", "black", "is", "box", "mode", "skip", "Mask", "hidden", "shape", "lock", "scale", "flags", "batch"], "depth": ["orient", "padding", "order", "q", "focus", "ps", "pad", "ind", "tips", "progress", "stack", "parent", "details", "level", "dq", "mode", "skip", "count", "dir", "shape", "dim", "deep", "scale", "dist", "density", "debug", "patch", "dr"], "height": ["gh", "sky", "ty", "ch", "resolution", "padding", "buffer", "ht", "volume", "size", "capacity", "window", "Height", "row", "total", "rows", "view", "radius", "hei", "shape", "host", "dim", "h", "scale", "ows", "w", "density", "angle", "max", "history", "high", "length", "inches"], "shift_control": ["hift_flag", "hift_length", "shifterscore", "shift64score", "shift_number", "push_control", "shiftablecontroller", "hift_cut", "scale_controller", "shift64controller", "shift_scroll", "hift_ctrl", "shiftistlength", "scale_flow", "shift_flag", "shiftingco", " shift_flag", "shift_rate", "push_ctrl", "shiftercontrol", "hift_controlled", "hifterctrl", " shift_score", "shift_ctrl", " shift_number", "shiftistctrl", "shiftistcontrol", "shiftistoutput", "hift_rate", "shift_length", "hift_control", "shifterflow", "shift64control", "shift__flag", "hift_scroll", "shift_score", "shiftablecontrolled", "scale_control", "hift_left", "shift__controlled", "shift_output", "hift_controller", "shiftablecontrol", "push_output", "shifterscroll", "shift_co", "hifterControl", "shift64flow", " shift_co", "shifterctrl", "shift_cut", "shift_left", "shift_flow", " shift_controlled", "scale_score", "shift_controlled", " shift_ctrl", "hifterscroll", "shift_controller", "shift__control", "shiftablecut", "hift_Control", "shiftingscore", "shift_Control", "shiftercontroller", "shift__ctrl", "shifterControl", "push_length", "shiftingcontrol", " shift_length", "hiftercontrol"], "line_offset": ["link_set", "line_position", "line1position", "line1set", "link_offset", "line1offset", "line_start", "link_start", "link_position", "line_set", "line1start"], "page0": ["p1", "page2", "p0", "Page1", "p2", "Page2", " page2", "Page0"], "page1": ["phrase0", "phrase6", "line1", " page6", "page6", "line6", "line0", "phrase1"], "bwidth": ["bdist", "nbwidth", "nbcount", "bcount", " bdist", "bdim", " bcount", "lbdim", "lbdist", "nbdim", "lbcount", " bdim", "nbdist", "lbwidth"], "bits": ["ms", "abilities", "tops", "ports", "comments", "locks", "pieces", "units", "bands", "frames", "ats", "bugs", "weights", "settings", "keys", "ps", "ants", "ints", "words", "files", "dates", "points", "outs", "planes", "pins", "chains", "fps", "fixes", "bytes", "bs", "terms", "bit", "details", "its", "rows", "ads", "plugins", "cats", "limits", "ips", "bis", "fits", "reports", "flags", "issues", "codes", "fs", "jobs", "parts"], "disp_width": ["disp2length", "disp_filename", "disp___height", "disp_path", "disp2data", "disp32width", "disP_left", "disp_position", "disp32position", "disp32amount", "disP_filename", "disP_width", "disP_data", "disp2width", "disp_height", "disP_amount", "disp___length", "disP_size", "disp_left", "disp___width", "disp___left", "disp2path", "disp_size", "disP_length", "disp_data", "disp_length", "disp_amount", "disP_height", "disp32height", "disP_path", "disP_position"], "multi_scan": ["multiplegen", "double_pass", "multiacpass", "single_can", "multiacreach", "double_gen", "single_reach", "multiaxyrun", "multiplerun", "multiplepass", "multi_gen", "multi_can", "multiaxyreach", "multiplescan", "multi_reach", "multi_check", "double_check", "multiaxypass", "single_gen", "multiaxyscan", "double_run", "multiacscan", "single_run", "multi_runner", "multiacgen", "double_runner", "multi_pass", "single_scan", "multiacrun", "single_pass", "multiaccan"], "multi_run": ["multi_out", "single_rate", "single_out", "multiletscan", "multi__run", "multi_rate", "multi_update", "multiewrate", "multi__running", "single_update", "multi__scan", "multiletout", "multi__out", "multi_running", "multiewupdate", "single_run", "multiewrun", "single_scan", "multiewscan", "multiletrunning", "single_running", "multiletrun"], "d": ["dd", "fd", "p", "f", "da", "dc", "dx", "g", "m", "D", "gd", "ad", "e", "dim", "c", "di", "dat", "w", "bd", "dp", "z", "db", "dict", "dm", "dh", "dt", "ds", "dr"], "v": ["vector", "nv", "vs", "u", "va", "message", "vi", "format", "q", "vv", "ov", "uv", "p", "value", "ve", "var", "f", "lv", "vp", "g", "m", "rev", "qv", "sv", "values", "i", "vt", "ver", "all", "function", "inv", "r", "j", "version", "view", "V", "b", "c", "h", "w", "cv", "vr", "iv", "wire", "vc", "conv", "tv"], "addr1": ["address1", "address2", "add2", " addr2", "address0", "addr2", "add0", "addr0", " addr0", "add1"], "addr": ["arr", "dd", "id", "off", "address", "at", "add", "Address", "order", "err", "pad", "act", "ip", "pos", "ref", "attr", "ptr", "adr", "alt", "ix", "cmd", "alias", "att", "dh", "offset", "dr", "ii"], "vga_draw_line": ["vga_clear_line", "vga_draw___function", "vga_clear_lines", "vga_draw___lines", "vga_draw_lines", "vga_clear_function", "vga_draw___line", "vga_draw___Line", "vga_clear_Line", "vga_draw_function", "vga_draw_Line"]}}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n", "idx": 9510, "substitutes": {"mask": ["ms", "key", "warn", "id", "mb", "map", "cmp", "sum", "buffer", "code", "flag", "message", "config", "image", "match", "weight", "ack", "form", "hash", "open", "label", "block", "m", "type", "bits", "win", "window", "filter", "miss", "in", "black", "bit", "ma", "allow", "box", "perm", "mode", "fix", "check", "gray", "conf", "Mask", " masked", "dir", "mark", "transform", "lock", "query", "cmd", "comment", "flags", "fee", "tag", "xml", "ask", "set", "msg", "pack", "max", "patch", "sk", "mt"], "attr": ["arr", "kr", "tt", "obj", "tr", "acc", "key", "typ", "priv", "cmp", "fd", "ctrl", "gm", "rb", "tk", "err", "ak", "ack", "alloc", "func", "var", "hash", "prop", "atts", "gr", "pkg", "m", "ptr", "rr", "txt", "addr", "ext", "alt", "attribute", "r", "md", "apt", "params", "perm", "t", "ac", "ctx", "pr", "tmp", "fac", "cmd", "rt", "str", "kw", "temp", "tag", "stat", "opt", "rm", "att", "imm", "msg", "vr", "emp", "dr", "mt"], "tid": ["TId", " tID", "npid", "tempbid", "TID", "tId", "nId", "tempid", "nid", " tId", " tbid", "Tpid", "nID", " tpid", "tpid", "tempId", "nbid", "tID", "Tid", "tbid"], "info": ["warn", "op", "map", "config", "fo", "update", "report", "open", "m", "other", "details", "import", "data", "ist", "check", "about", "history", "size", "Info", "inner", "status", "init", "ind", "iter", "note", "txt", "try", "conn", "count", "conf", "close", "information", "si", "link", "time", "pack", "debug", "no", "state", "id", "buffer", "order", "image", "zip", "meta", "f", "error", "ip", "type", "def", "local", "i", "trace", "in", "mem", "index", "now", " Info", "inf", "comment", "it", "INFO", "bar", "num", "entry", "fi", "sum", "where", "list", "ack", "iso", "ok", "auth", "json", "bit", "cache", "lock", "stats", "help", "stat", "msg"], "fds": ["fcs", "cfuds", "fwns", "fuds", "fd", "tfDs", "fifds", "Fds", "frs", "fcds", "fwDS", "fpds", "tfys", "fDs", "Frs", "fdDS", "fpdos", " fDS", "fifd", " fdds", " fdos", "fifdds", "fcd", "cfrs", "Fuds", "fns", "fifuds", " fd", "fdds", "tfdos", "fdcs", "fDS", "cfds", " fns", "cfys", " fuds", " fys", "fcuds", " fDs", "fpDs", "fwds", " fcs", "Fys", "fys", "fpys", "tfds", "fwcs", " frs", "fcdds", "fdns", "fdos"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n", "idx": 9516, "substitutes": {"vs": ["ms", "obs", "qs", "Vs", "settings", "rs", "hs", "gs", "sts", "ps", "VS", "lv", "vp", "cs", "sv", "blogs", "ses", "es", "vt", "values", "bs", "iss", "inv", "is", "ys", "js", "ss", "ts", "ils", "vd", "ctx", "v", "sb", "caps", "ns", "stats", "fs", "serv", "ls", "vr", "s", "vm", "vc", "ds"], "data": ["Data", "next", "buffer", "text", "read", "image", "to", "p", "buf", "bin", "pad", "d", "size", " DATA", "block", "ata", "def", "window", "bytes", "mu", "in", "r", "rel", "box", "ad", "t", "bus", "reg", "v", "fr", "cache", "input", "mid", "dat", "str", "table", "batch", "DATA", "nd", "ds", "dr"], "len": ["fin", "id", "lib", "lan", "Len", "bl", "bin", "ld", "name", "l", "type", "args", "lf", "lp", "en", "ail", "dl", "h", "str", "z", "db", "ll", "length", " length"]}}
{"project": "FFmpeg", "commit_id": "a0e5f7f363555d2befafb1c9e1579dbe0a2fbca7", "target": 1, "func": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n\n                                  cavs_vector *col_mv)\n\n{\n\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n\n    int den = h->direct_den[col_mv->ref];\n\n    int m = FF_SIGNBIT(col_mv->x);\n\n\n\n    pmv_fw->dist = h->dist[1];\n\n    pmv_bw->dist = h->dist[0];\n\n    pmv_fw->ref = 1;\n\n    pmv_bw->ref = 0;\n\n    /* scale the co-located motion vector according to its temporal span */\n\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n    m = FF_SIGNBIT(col_mv->y);\n\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n}\n", "idx": 9528, "substitutes": {"h": ["hal", "he", "H", "ah", "hm", "hr", "each", "ch", "q", "eh", "here", "k", "hs", "p", "hash", "o", "f", "g", "l", "m", "hl", "oh", "hh", "hp", "r", "t", "ctx", "v", "ha", "rh", "cache", "host", "c", "sh", "kh", "hw", "w", "ih", "his", "it", "context", "comm", "s", "hi", "dh", "history", "hz", "ht"], "pmv_fw": ["pmv___FW", "pmval7fb", "pmv_FW", "pmvpyfw", "pmv_wr", "pmvi_FW", "pmv___final", "pmv2wo", "pmv5FW", "pmv2rw", "pmv_iw", "pmv_rw", "pml_lb", "pmval7fw", "pmv_ld", "pmv_ht", "pmvi_fw", "pmvp_fw", "pmvgfw", "pmv2iw", "pmvpyflo", "pmv_final", "pmval_fw", "pmval_fb", "pmv_flo", "pmvgfb", "pml_def", "pmV_wr", "pmq_iw", "pmvi_urg", "pmvi_obj", "pmval7ht", "pmv2fw", "pmv____ht", "pmv____fb", "pmv2def", "pmvi_flo", "pmv5wu", "pmv___fw", "pmvi_ld", "pml_rf", "pmw_hw", "pmq_fw", "pmvgtails", "pmw_rf", "pmv_def", "pmw_fw", "pmv_hw", "pmV_FW", "pmv___flo", "pmv_wo", "pmvp_flo", "pmv___urg", "pmvi_final", "pmvght", "pmv___ld", "pmv2rf", "pmv_fb", "pmV_fw", "pmv5fw", "pmv___obj", "pmvp_fd", "pmv7ht", "pmv7fw", "pmv_tails", "pmv7fb", "pmw_FW", "pmv____fw", "pmv2lb", "pmvpyfd", "pmval_ht", "pmv_fd", "pml_fw", "pmv_lb", "pmv____tails", "pmq_rw", "pmval_tails", "pmv7tails", "pmv_obj", "pmvpytf", "pmv_rf", "pmv_tf", "pmv_wu", "pmq_wo", "pmv5wr", "pmv_urg", "pmV_wu", "pmval7tails", "pmvp_tf"], "col_mv": ["colObjmnvert", "col_lvd", "col_tth", "col_tvc", "colObjmnvc", "col_cve", "col___mvt", "col___mv", "col_nmv", "col_mvd", "col_mnv", "col___mw", "col_pvc", "col_mve", "col_bvc", "col_ruv", "col_vmv", "col_mvt", "col_ymvl", "col_tv", "col_mnvc", "col_rv", "colObjmnth", "col___vw", "col_mvm", "col_cv", "col_vmvt", "col___mpr", "colObjmvc", "col_Mv", "col_vpr", "col___mtv", "col_vmw", "col_numv", "col_vv", "col_Mvc", "col_MV", "col_numvc", "col_lvm", "col_nmw", "col_movm", "col_mav", "col_pve", "col_rw", "col_mtth", "col_mtv", "col_rmve", "col_lv", "col_vmve", "col_rvt", "col_ymw", "colObjmth", "col_movd", "col_rvc", "col___vtv", "col_mV", "col___vpr", "col_rve", "col_pw", "col_Mve", "col_vw", "col_cV", "col_mvl", "col_Mav", "col_rmv", "col_lvc", "col_mth", "col_ymv", "col_mpr", "col_pv", "colObjmv", "col_pV", "col_movc", "col_nmpr", "col___rmw", "col_numvm", "col_bve", "col_mnth", "col_vtv", "col___rmve", "col_mvert", "col___rmvt", "col_mtvc", "col_mw", "col_pav", "col_rtv", "col_Mw", "col_mnvert", "col_buv", "col_rmvt", "col_mtvert", "col_mov", "col_rmw", "col_muv", "col_nmtv", "col___rmv", "col_numvd", "col_rvl", "col_cw", "col_tvert", "col_puv", "col___vv", "col_bv", "col_rpr", "col_ymvc", "col___mve", "col_mvc", "colObjmvert", "colObjmnv"], "pmv_bw": ["pmv_tkw", "pmv_tust", "pmv_bbw", "pmv2bW", "pmv_mw", "pmv_fwx", "pmv_absw", "pmv_fbwd", "pmv_nbsw", "pmv_uew", "pmv_nbag", "pmv_biws", "pmv5bsw", "pmv___nbwb", "pmv_nbw", "pmv_bwl", "pmv2bwx", "pmv5basef", "pmv_gwd", "pmv_bsw", "pmv3bag", "pmv2gW", "pmv_abwd", "pmv5basew", "pmv3bwe", "pmv_abwl", "pmv_dws", "pmv___nbew", "pmv_gwx", "pmv_bkw", "pmv_nbew", "pmv_bbew", "pmv_pbwe", "pmv3bexp", "pmv_mws", "pmv_bW", "pmv2gwd", "pmv_bbwk", "pmv2bw", "pmv_mwh", "pmv_bew", "pmv_basesw", "pmv3cbwe", "pmv_gW", "pmv_fbsw", "pmv5bf", "pmv_biwh", "pmv_bbwx", "pmv_lbust", "pmv_nbwl", "pmv_dw", "pmv2bwd", "pmv_bwb", "pmv_cbw", "pmv___bwb", "pmv_nbW", "pmv_pf", "pmv___bwx", "pmv_bbwb", "pmv_bust", "pmv3cbexp", "pmv_abw", "pmv_nbwb", "pmv_bbkw", "pmv_nbwx", "pmv5basesw", "pmv_lbwk", "pmv_nbwe", "pmv_sbsw", "pmv3cbw", "pmv_bbust", "pmv___nbwx", "pmv_nbwd", "pmv_cbwe", "pmv_bwk", "pmv_cbexp", "pmv2gw", "pmv_nbexp", "pmv_lbkw", "pmv_pwl", "pmv___bw", "pmv___bew", "pmv_pbag", "pmv_fbw", "pmv_psw", "pmv_bag", "pmv_biw", "pmv_nbf", "pmv_pbw", "pmv_twk", "pmv_basewl", "pmv_pbexp", "pmv_sbw", "pmv2gwx", "pmv_bwx", "pmv_dwh", "pmv_bwd", "pmv_uwx", "pmv_uwb", "pmv_uw", "pmv3cbag", "pmv_bwh", "pmv3bw", "pmv_dwx", "pmv_bws", "pmv_bf", "pmv_fW", "pmv___nbw", "pmv_fbwl", "pmv5bwl", "pmv_cbag", "pmv_tw", "pmv_basef", "pmv_sbwd", "pmv_bwe", "pmv5basewl", "pmv_bexp", "pmv_fwd", "pmv_biwx", "pmv_basew", "pmv_sbwl", "pmv_mwx", "pmv_pw", "pmv_lbw", "pmv_gw", "pmv5bw"]}}
{"project": "FFmpeg", "commit_id": "22fa38f0c85fb31cddbb0bc22a2df5953c702b95", "target": 0, "func": "static inline void h264_deblock_q1(register vector unsigned char p0,\n\n                                                   register vector unsigned char p1,\n\n                                                   register vector unsigned char p2,\n\n                                                   register vector unsigned char q0,\n\n                                                   register vector unsigned char tc0) {\n\n\n\n    register vector unsigned char average = vec_avg(p0, q0);\n\n    register vector unsigned char temp;\n\n    register vector unsigned char uncliped;\n\n    register vector unsigned char ones;\n\n    register vector unsigned char max;\n\n    register vector unsigned char min;\n\n\n\n    temp = vec_xor(average, p2);\n\n    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */\n\n    ones = vec_splat_u8(1);\n\n    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */\n\n    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */\n\n    max = vec_adds(p1, tc0);\n\n    min = vec_subs(p1, tc0);\n\n    p1 = vec_max(min, uncliped);\n\n    p1 = vec_min(max, p1);\n\n}\n", "idx": 9533, "substitutes": {"p0": ["q1", " p7", "jp0", "pc0", "P0", "jp1", "jp50", "pa0", "q8", "P7", "p1", "pa8", "p7", "pc1", "q0", "p50", "pc2", "q50", "p2", "pc7", " p1", "P2", "P1", "p8", "pa50", " p2", "jp8", "pa1"], "temp": ["tm", "perature", "tr", "current", "empty", "sum", "buffer", "prefix", "pt", "base", "average", "or", "Temp", "to", "p", "pool", "ps", "mint", "tc", "type", "attr", "zero", "null", "ptr", "local", "txt", "term", "mem", "index", "ta", "volt", "tem", " temperatures", "test", "ts", "total", "t", "new", "v", "cache", "tmp", "tim", "med", "tar", "unt", "memory", "time", "mp", "emp", "pre", "offset", "out", "mean"], "uncliped": ["unstriped", "unmasking", "unmask1", "unclip1", "unalclipisted", "unalclipted", "uncropted", "unclipeds", "gunclipeded", "unclipted", "unalmapted", " unstriping", "guncliped", "unshapeed", "guncamed", "unmapted", "unalclipied", "unstripd", " unstrip1", "guncamated", "unmaped", "gunclipated", "unapeated", "unclipied", "unpixelied", "uncroped", "uncamd", " unclipeds", "unmaskeds", "uncamed", "unshape1", "unstripeds", "unapeed", " uncliping", "unstrip1", "unpixeled", "unaped", "unalmaped", "unshapeing", "unalmapied", "unshapeeds", "unalmapisted", "uncropied", " unstriped", "unstripated", "guncamd", "unpixelted", "unapeeded", "unmapied", " unstripeds", "unclipisted", "unstripeded", "unstriping", "unalcliped", "uncameded", "uncamated", "unmasked", "gunclipd", "unclipeded", "unmapisted", "uncropisted", "unpixelisted", "unclipd", " unclip1", "uncliping", "unclipated", "guncameded"], "ones": ["ms", "amps", "aps", "locks", "ices", "names", "weights", "oms", "devices", "inters", "ases", "ps", "offs", "phones", "lines", "cs", "points", "bits", "ins", "values", "zero", "ies", "mods", "icks", "bs", "ients", "terms", "ias", "als", "ples", "ts", "ids", "one", "tones", "ads", "os", "ips", "times", "des", "flags", "codes", "onents", "oned", "vals", "ions", "wise", "s", "eros", "tes", "odes", "ims", "ONES", "cells", "eds", "oses"], "max": ["Max", "on", "norm", "net", "map", "mx", "MAX", "base", "up", "end", "step", "created", "range", "cut", "k", "maximum", "act", "mad", "recent", "cur", "m", "parent", "mod", "inv", "r", "top", "ma", "plus", "last", "n", "box", "view", "root", "v", "h", "master", "med", "rest", "st", "x", "full", "ax", "co", "nd", "size", "out"], "min": ["lt", "beta", "small", "part", "mm", "base", "q", "p", "mini", "mint", "mad", "pos", "m", "l", "local", "mn", "emin", "mod", "mask", "minimum", "in", "mem", "mi", "mind", "mean", "n", "mins", "skip", "sort", "v", "minute", "lower", "lock", "mid", "tmp", "minus", "master", "med", "member", "start", "Min", "only", "s", "mp", "MIN", "size", "mit"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,\n\n                                target_ulong pc2, TCGv r_cond)\n\n{\n\n    int l1;\n\n\n\n    l1 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);\n\n\n\n    gen_goto_tb(dc, 0, pc2, pc1);\n\n\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);\n\n}\n", "idx": 9546, "substitutes": {"dc": ["td", "tm", "arc", "dd", "pc", "cca", "ct", "DC", "ec", "vc", "df", "cp", "da", "d", "bc", "xc", "tc", "cs", "cd", "cc", "dl", "mc", "ci", "rc", "lc", "gc", "c", "di", "cm", "nc", "dp", "fc", "disc", "sc", "mac", "dm", "dt", "ds", "dr"], "pc1": ["pcOne", "l2", "pc0", "arc2", "arc1", "PC2", "PC0", " pc4", "lOne", "lc4", "PC1", "l4", "arcOne", " pc0", " pcOne", "PCOne", "pc4", "arc0", "lcOne", "lc1", "lc2"], "pc2": [" pc02", "fc1", "pctwo", "isc1", "PC5", "mc1", " pc256", "vc2", " pctwo", "isc2", " pc8", "vc4", "PC2", "pc5", "PCtwo", " pc4", "fc4", "PC02", "PC4", "vc1", "isc4", "PC1", "PC256", "mc2", "mc5", "PC8", "pc4", "fc2", "fc256", "pc256", " pc5", "pc8", "mc8", "isctwo", "vc02", "pc02"], "r_cond": ["r_crit", " r__con", " r_Cond", "r2crit", " r2con", " r2cond", "r_Cond", " r2condition", " r__condition", "r__condition", " r_condition", "r2condition", "r2con", " r2crit", "r2Cond", "r__con", "r_con", "r_condition", " r_con", " r__Cond", "r__Cond", "r__cond", " r_crit", "r2cond", " r__cond"], "l1": ["slOne", "l2", " l2", "L2", "ll2", "lone", "ll1", "lc0", "sl1", " l11", "lId", "l0", "l9", "LId", " lone", "nl1", "llone", "L0", "lcId", "sl9", "lc81", " l0", "tl9", " l81", "lc9", " lId", "lOne", "ll11", "l81", "L1", "nl9", "l11", "tl81", "nl81", "tl2", "Lone", "tl1", "nlOne", "lcOne", "lc1", " l9", "lc2", "L11", "sl81"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 9548, "substitutes": {"bs": ["ms", "obs", "vs", "bf", "cks", "aos", "bp", "rs", "hs", "gs", "bl", "ps", "bc", "BS", "cs", "bm", "bits", "aus", "js", "ss", "ts", "bos", "pb", "its", "lbs", "bps", "ubs", "ubis", "os", "sb", "b", "bis", "bh", "ns", "bi", "fs", "ks", "ls", "ds"], "offset": ["align", "shift", "xy", "off", "id", "reset", "address", "url", "et", "pointer", "padding", "base", "end", "seek", "o", "error", "offs", "fp", "slot", "tile", "location", "oid", "ref", "um", "ptr", "unc", "onto", "scroll", "attribute", "top", "row", "index", "t", " offsets", "Offset", "rot", "os", "kh", "start", "set", "oss"], "n_start": ["n_first", "n___since", " n_first", "nPsince", "n___start", "nPstart", "nPend", "nPfirst", " n_since", "n_since", "n___end", "n___first"], "n_end": ["n_ends", "nipstart", " n_target", "niptarget", "nipends", "n___start", "n_fin", "nipend", "n___fin", " n_fin", "n_target", "n___end", " n_ends"], "num": ["na", "off", "con", "nm", "mult", "begin", "Num", "nt", " n", "np", "um", "common", "nn", "mu", "n", "node", "uni", "final", "mon", "dim", "un", "nom", "om", "NUM", "nb", "set", "no", "number"], "m": ["ms", "tm", "spec", "mb", "nm", "mm", "gm", "meta", "p", "sm", "this", "mint", "g", "bm", "mr", "mn", "mem", "mi", "r", "j", "n", "mc", "v", "man", "metadata", "b", "c", "M", "h", "cm", "w", "rm", "msg", "dm", "mp", "module", "vm", "mt"], "s": ["ms", "vs", "spec", "ats", "rs", "hs", "sp", "gs", "p", "sts", "ps", "changes", "cs", "bits", "sv", "i", "sam", "ses", "xs", "aws", "is", "js", "als", "S", "ss", "ts", "its", "state", "os", "sb", "b", "bis", "sa", "ns", "sn", "stats", "fs", "si", "ls", "ims", "ds", "sys"], "l2_index": ["l2jstart", "l56_default", "l56erindex", "l2__ind", "l2ptalias", "l2_second", "l2__Index", "l1_offset", "l1_index", "l2_slice", "l2___index", "l20_path", "l3_index", "l2___status", "l3_start", "l2_prefix", "l22path", "l2_ind", "lTwo_ind", "l2_path", "l2_start", "l2_set", "l20_seed", "l2ersecond", "l2_Index", "l2__slice", "l2___set", "l2_inc", "ltwo_pos", "l2dlist", "l2jindex", "l2dindex", "latterptalias", "l56_path", "l2___seed", "ltwo_set", "l56erpath", "l56ersecond", "lTwo_Index", "l2ptprefix", "l2ptindex", "l2___i", "latter_alias", "l56erdefault", "l2___alias", "l56_index", "ltwo_index", "l2___prefix", "l2_default", "latter_prefix", "l20_status", "l56_second", "l2_list", "l3_Index", "l1_start", "l1_Index", "l22default", "l2erdefault", "l20_index", "latterptindex", "latterptsecond", "l2___pos", "l2erindex", "l2jlist", "l22index", "l22second", "lTwo_index", "l2dIndex", "latterptprefix", "l2_i", "l2__index", "l2_pos", "l2___second", "l3_ind", "l1_ind", "lTwo_slice", "l2___path", "latter_second", "l2_status", "l1_inc", "l2_seed", "l2ptsecond", "l3_list", "l2erpath", "l2jIndex", "l2dstart", "l2_alias", "latter_index", "ltwo_i"], "ret": ["tf", "len", "tr", "success", "reset", "flag", "err", "det", "RET", "f", "ne", "nt", "prot", "rev", "jp", "true", "ref", "inter", "mt", "after", "tail", "mem", "alt", "r", "ter", "cont", "j", "bit", "ext", "total", "final", "t", "rem", "count", "rets", "deg", "val", "Ret", "tmp", "rt", "re", "elt", "res", "ber", "result", "ft", "gt", "ll", "conv"], "l2_offset": ["ltwo_offset", "l2thename", "ltwo_name", "ltwotheattr", "l2_name", "l3_address", "l2_address", "ltwo_table", "l2fpointer", "l2foffset", "l2ftable", "l3_table", "l3_pointer", "l2theattr", "ltwotheoffset", "l2theoffset", "l2_attr", "ltwothename", "l2thetable", "ltwothetable", "l3_offset", "l2faddress", "ltwo_attr", "l2_pointer"], "l2_table": ["l2isttmp", "l2Ppoint", "l2__tab", "l132_collection", "l2isttab", "l3_tab", "l2jmodule", "l2mtable", "l2_name", "l10_point", "l2__table", "l2_queue", "l2Dtable", "l10_trace", "l2_buffer", "l2ibtmp", "ltwo_queue", "l21_tmp", "l2istname", "l2istbuffer", "l2_internal", "lappingibpoint", "l2ptinternal", "l2___window", "l3_buffer", "l2_window", "l2mtmp", "l2jtab", "l2Dmodule", "l2mbuffer", "l2Jtable", "lappingibinternal", "l2__TABLE", "l21_table", "l3_module", "lappingibtable", "l2ibinternal", "ltwo_window", "l2__list", "l21_buffer", "l21istbuffer", "l2Dserver", "l2_tab", "ltwo_term", "l3_TABLE", "l2_module", "l132Jtable", "l2ptwindow", "l2___table", "l132Jbuffer", "l2Jtab", "l2Ptable", "l2pttmp", "l21isttable", "l10Dtable", "l132_tab", "l2jtable", "l10Dtab", "l10Dpoint", "l2Dtrace", "lapping_table", "l10_table", "l2istpoint", "l10_tab", "l132Jcollection", "l132Jtab", "l132_buffer", "l2ptpoint", "ltwo_table", "l2_list", "l2ptqueue", "l3_server", "l2_tmp", "l132_table", "l2thetable", "l2Ptmp", "l2ptterm", "l2_term", "l2___term", "l2thetab", "l2_point", "l2Jcollection", "l2ibpoint", "l2_collection", "l2themodule", "l2Dpoint", "l21isttmp", "l2_server", "l2isttable", "l2_TABLE", "lappingibtmp", "l2Pinternal", "l2isttrace", "l2ibtable", "l2_trace", "l21istname", "l10Dtrace", "l3_table", "l2thebuffer", "l2jserver", "lapping_point", "l3_list", "lapping_tmp", "l2Dtab", "l21_name", "l2mname", "l2Jbuffer", "l2pttable", "l2___queue", "lapping_internal"], "cluster_offset": ["cluber0off", "cluster2location", "cluster_value", "cluber0offset", "cluber0attribute", "cluster___offset", "clust2done", "cluster32done", "cluster_not", "cluster_attribute", "cluster_done", "cluster_size", "cluster___base", "cluster_Offset", "cluster_table", "cluster0pointer", "clumn_offset", "cluster_offer", "clbuster____address", "clbuster_info", "clause_length", "cluster0off", "cluster2offset", "clust2offset", "cluster_pointer", "clusterEvalue", "cluster_length", "cluster_address", "clust2location", "clust_style", "cluster32location", "clumn_range", "cluster___info", "cluster_range", "clluster_base", "clluster___base", "cluster_seek", "clust_offer", "cluster_index", "clust_off", "cluster_style", "clusterEaddress", "clusterIPoffer", "clause_index", "clusterIPseek", "cluster2offer", "clust_location", "cluster2point", "clusterEinfo", "cluster2done", "cluster____address", "cluster2off", "cluster2seek", "clbuster_value", "cluber_off", "clusteriptable", "clumn_not", "clluster_table", "cluber_pointer", "clusterEoffset", "clust_offset", "cluber0pointer", "clbuster_offset", "clust_seek", "clluster_offset", "cluster___address", "cluster0offset", "clust_point", "clusterIPpoint", "cluster___table", "cluster____value", "clause_Offset", "clluster___offset", "cluster____info", "clust2off", "clumn_size", "cluster_info", "cluster____offset", "cluster0attribute", "cluster___value", "clusteripbase", "cluber_attribute", "cluber_offset", "clluster___table", "clusterIPoffset", "clust_done", "cluster32offset", "clause_offset", "clbuster_address", "clusteripoffset", "clbuster____info", "cluster_point", "cluster_base", "cluster_off", "clbuster____offset", "cluster32off", "clbuster____value", "cluster_location"], "nb_clusters": ["nb_combiques", "nb_sclients", "nb_decliders", "nb_cluster", "nb_declograms", "nbofclonents", "nb_histues", "nb11clusters", "nb11clgroups", "nb_collusters", "nb2colliques", "nb_constograms", "nb_histusters", "nbaxyconstubes", "nb__clues", "nb_sclusters", "nb_scliders", "nb_pluster", "nb__clusters", "nbJcontuster", "nb_glients", "nb_contancers", "nb_chusters", "nb11cliders", "nb_closes", "nb__contusters", "nb_clodes", "nb_croups", "nb_clicas", "nb_clgroups", "nb_colodes", "nb2declusters", "nb2collusters", "nb_combients", "nb_colliders", "nb_contuster", "nb_allusters", "nbaxyconstusters", "nb_declroups", "nb_clanguages", "nb__contues", "nb_clues", "nballclusograms", "nb_execograms", "nbofclusters", "nb_clusograms", "nb_clusroups", "nb_cliders", "nb2clanguages", "nb_CLanguages", "nb2declroups", "nb_Cliques", "nbJclusters", "nb_plients", "nb_combuster", "nb_colliques", "nb_declicas", "nb_declgroups", "nb_glograms", "nbaxyclicas", "nb2pluster", "nb_histresses", "nb_sloses", "nb_declients", "nb_combubes", "nbJclancers", "nbofslusters", "nb_coients", "nb_chograms", "nb_execroups", "nb_clonents", "nb_cograms", "nb11clients", "nb_allubes", "nb11sclusters", "nb2declients", "nbJclodes", "nb_consticas", "nb_plancers", "nb_glodes", "nb2clusters", "nb_declanguages", "nb_collients", "nb__clores", "nbJcluster", "nb_combusters", "nballclusters", "nb_declodes", "nb2clroups", "nb_allograms", "nb_declusters", "nb2declanguages", "nbofcloses", "nbaxyconsticas", "nb_sclgroups", "nb_colusters", "nbaxyclubes", "nb__clresses", "nb_clograms", "nb2cluster", "nb_clients", "nb__contores", "nballclroups", "nb2ploci", "nb_custers", "nb_cliques", "nbaxyclusters", "nballclograms", "nb_contusters", "nb_contodes", "nb_slients", "nb_gallodes", "nb_Clonents", "nbofsloses", "nb_colluster", "nb_chubes", "nb_constubes", "nb_constusters", "nb11scliders", "nb_gallusters", "nb_clores", "nb_clroups", "nbofclients", "nb_clubes", "nb2collients", "nb_contores", "nbofslonents", "nb11sclgroups", "nbJcontusters", "nb_coonents", "nb_contresses", "nb_Clients", "nbaxyconstograms", "nballclususters", "nb_chores", "nb2plusters", "nb_clusicas", "nb_cooses", "nb_custer", "nb_cloudanguages", "nb_cloudusters", "nb_CLients", "nb_chues", "nb_chicas", "nb_coluster", "nb_histores", "nb_combicas", "nb_Clusters", "nb_cousters", "nb2cliques", "nb_combroups", "nb_collgroups", "nb2clients", "nbofslients", "nb_cloudients", "nb_plodes", "nb_clususters", "nb_clancers", "nb_CLusters", "nb_clusubes", "nb_glusters", "nb_Cluster", "nb_declubes", "nb__contresses", "nb_coci", "nb_ploci", "nb_execusters", "nb_plusters", "nb_gallograms", "nb_cloudroups", "nb_cloci", "nb11sclients", "nbJcontancers", "nb2plients", "nb_clresses", "nb_contues", "nb_cients", "nb_allicas", "nb2colluster", "nb_Closes", "nb_slonents", "nb_colloci", "nbJcontodes", "nb_CLroups", "nb_gallients", "nballclusroups", "nb2cloci", "nb_colancers", "nb_chresses", "nb_slusters", "nbaxyclograms"], "old_alloc": ["oldobjoc", "oldobjalloc", "oldobjmem", "new_oc", "newMalloc", "newMmem", "old___mem", "old_arch", "old___alloc", "oldMarch", "oldMmem", "new_arch", "oldMalloc", "new_mem", "old___oc", "newMarch", "newMoc", "old_oc", "oldobjarch", "oldMoc", "old___arch", "old_mem", "new_alloc"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static int tx_consume(Rocker *r, DescInfo *info)\n\n{\n\n    PCIDevice *dev = PCI_DEVICE(r);\n\n    char *buf = desc_get_buf(info, true);\n\n    RockerTlv *tlv_frag;\n\n    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\n\n    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };\n\n    uint32_t pport;\n\n    uint32_t port;\n\n    uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE;\n\n    uint16_t tx_l3_csum_off = 0;\n\n    uint16_t tx_tso_mss = 0;\n\n    uint16_t tx_tso_hdr_len = 0;\n\n    int iovcnt = 0;\n\n    int err = ROCKER_OK;\n\n    int rem;\n\n    int i;\n\n\n\n    if (!buf) {\n\n        return -ROCKER_ENXIO;\n\n    }\n\n\n\n    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));\n\n\n\n    if (!tlvs[ROCKER_TLV_TX_FRAGS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));\n\n    if (!fp_port_from_pport(pport, &port)) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {\n\n        tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]);\n\n    }\n\n\n\n    switch (tx_offload) {\n\n    case ROCKER_TX_OFFLOAD_L3_CSUM:\n\n        if (!tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    case ROCKER_TX_OFFLOAD_TSO:\n\n        if (!tlvs[ROCKER_TLV_TX_TSO_MSS] ||\n\n            !tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n            return -ROCKER_EINVAL;\n\n        }\n\n        break;\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]) {\n\n        tx_l3_csum_off = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_L3_CSUM_OFF]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_MSS]) {\n\n        tx_tso_mss = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_MSS]);\n\n    }\n\n\n\n    if (tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]) {\n\n        tx_tso_hdr_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_TSO_HDR_LEN]);\n\n    }\n\n\n\n    rocker_tlv_for_each_nested(tlv_frag, tlvs[ROCKER_TLV_TX_FRAGS], rem) {\n\n        hwaddr frag_addr;\n\n        uint16_t frag_len;\n\n\n\n        if (rocker_tlv_type(tlv_frag) != ROCKER_TLV_TX_FRAG) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        rocker_tlv_parse_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag);\n\n\n\n        if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\n            !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\n        frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\n\n\n        iov[iovcnt].iov_len = frag_len;\n\n        iov[iovcnt].iov_base = g_malloc(frag_len);\n\n        if (!iov[iovcnt].iov_base) {\n\n            err = -ROCKER_ENOMEM;\n\n            goto err_no_mem;\n\n        }\n\n\n\n        if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base,\n\n                     iov[iovcnt].iov_len)) {\n\n            err = -ROCKER_ENXIO;\n\n            goto err_bad_io;\n\n        }\n\n\n\n        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {\n\n            goto err_too_many_frags;\n\n        }\n\n    }\n\n\n\n    if (iovcnt) {\n\n        /* XXX perform Tx offloads */\n\n        /* XXX   silence compiler for now */\n\n        tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0;\n\n    }\n\n\n\n    err = fp_port_eg(r->fp_port[port], iov, iovcnt);\n\n\n\nerr_too_many_frags:\n\nerr_bad_io:\n\nerr_no_mem:\n\nerr_bad_attr:\n\n    for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) {\n\n        if (iov[i].iov_base) {\n\n            g_free(iov[i].iov_base);\n\n        }\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 9574, "substitutes": {"r": ["kr", "hr", "rb", "rs", "err", "rec", "p", "rf", "o", "ri", "d", "rw", "g", "m", "ra", "mr", "rr", "usr", "rx", "br", "t", "rc", "v", "rd", "self", "nr", "e", "b", "c", "reader", "h", "ro", "rt", "re", "w", "er", "vr", "s", "R", "cr", "rar", "dr"], "info": ["tm", "op", "current", "entry", "config", "fo", "text", "rec", "o", "f", "report", "error", "recent", "def", "zero", "te", "auth", "json", "mem", "details", "try", "when", "http", "is", "data", "with", "now", "check", "conf", "nr", "self", "about", "os", "inf", "isu", "from", "rt", "re", "information", "res", "it", "INFO", "full", "context", "user", "hi", "description", "history", "Info"], "dev": ["kr", "obj", "tx", "priv", "ch", "device", "cam", "ev", "nt", " device", "def", "attr", "ptr", "ver", "addr", "rel", "ad", "DEV", "conn", "Dev", "Device", "hw", "w", "er", "pack", "iv", "pro"], "buf": ["arr", "obj", "off", "xff", "buffer", "text", "uf", "rb", "err", "ff", "alloc", "proc", "bl", "bin", "bc", "rw", "Buffer", "block", "vec", "pkg", "cb", "conv", "raw", "bytes", "txt", "mem", "queue", "data", "br", "pb", "box", "cap", "rc", "v", "b", "tmp", "cmd", "str", "w", "Buff", "buff", "msg", "cv", "img"], "tlv_frag": ["tlv_pragg", "tlv_flig", "tlv_flagg", "tlv_brig", "tlv_flag", "tlv_bragg", "tlv_frags", "tlv_fragg", "tlv_frig", "tlv_prig", "tlv_brags", "tlv_brag", "tlv_prags", "tlv_flags", "tlv_prag"], "tlvs": ["twll", "hlvs", "tlvb", "tlvz", "tildo", "tvvses", "tvvl", "tlicts", "twlis", "tlegz", "tlfrs", "tvb", "tlfns", "tlics", "Tlfts", "tufb", "tcfses", "tlvo", "itvses", "tvvs", "tlegs", "tvs", "tvses", "tpkgs", "vlvo", "tlvns", " tcfz", "hlvns", "tengs", "Tlfl", "tlicrs", "itlvgs", "tloggs", " tcfses", "tlegses", "tengses", "itlvs", "tlvl", "tpkgts", "Tlfs", "tpools", "tilds", "tlvS", "tufs", "tcfs", "tlfgs", "tlfs", "tpkgrs", "tenggs", "itvs", " tlfs", "itvd", "tpoolS", "tvvS", " tlvis", "Tlvis", "itlvses", "tcfz", "twls", "tildds", "vxtds", "tvd", " tlvses", "Tlfis", "txts", "tlogd", "Tlvl", "txto", "txtds", " tcfs", " tlvb", "tvgs", "tlvis", "tlogses", "tlfis", "tlogs", "tufls", "tcfis", "tlfls", "vlvds", "tengd", "hvvS", " tlfls", "vlvs", "tlfts", "vxts", "vxto", "tvvz", "tlvds", " tlvgs", "tlvgs", "tlfS", " tlfgs", "tlfl", "tpoolns", "tlvrs", "hvvns", "tlfb", "Tlfrs", " tlvz", "hvvs", "tlvls", " tcfis", "tlvts", "tlvd", "hlvS", " tlvls", "tvls", "tvvns", "itvgs", "itlvd", "tufgs", "tvvds", "tlvses", " tlfb", "tvvis", "Tlvrs", "Tlvts", "tlegis", "Tlvs", "tvvo"], "ROCKER_TLV_TX_MAX": ["ROCKER_TLV_TX__Max", "ROCKER_TLV_TX_SIZE", "ROCKER_TLV_TX_MIN", "ROCKER_TLV_TR_SIZE", "ROCKER_TLV_TXIDmax", "ROCKER_TLV_TXIDMax", "ROCKER_TLV_TXIDMAX", "ROCKER_TLV_TX_Max", "ROCKER_TLV_TR_MIN", "ROCKER_TLV_TX_max", "ROCKER_TLV_TXIDSIZE", "ROCKER_TLV_TRIDMAX", "ROCKER_TLV_TR_MAX", "ROCKER_TLV_TXIDMIN", "ROCKER_TLV_TX__SIZE", "ROCKER_TLV_TR_Max", "ROCKER_TLV_TRIDSIZE", "ROCKER_TLV_TRIDMax", "ROCKER_TLV_TX__MAX", "ROCKER_TLV_TX__MIN", "ROCKER_TLV_TR_max", "ROCKER_TLV_TRIDMIN"], "iov": ["argo", "ogo", "io", "isl", "sels", "ov", "mg", "ip", "vec", "oys", "mn", "isco", "ibl", "iph", "ortex", "js", "ipher", "ibe", "ensor", "sw", "iol", "ors", "og", "ih", "vr", "iv", "iao", "ii"], "pport": ["eport", "Port", "ports", "pas", "sl", "pe", "arp", "fi", "socket", "pp", "pt", "policy", "ping", "rs", "per", "p", "phil", "cp", "pg", "act", "ip", "prot", "jp", "pos", "vp", "ptr", "orts", "supp", "tif", "pit", "ort", "support", "addr", "mph", "PORT", "cap", "pen", "phy", "ctx", "pl", "pet", "serv", "opt", "iff", "vet", "upp", "lex", "vr", "mp", "pro", "rog", " sport"], "port": ["Port", "eport", "ports", "key", "address", "pc", "pe", "socket", "priority", "channel", "pt", "format", "export", "p", "point", "ORT", "cp", "prot", "ip", "size", "limit", "pos", "type", "ptr", "pid", "ort", "server", "PORT", "import", "version", "count", "host", "fat", "serv", "tag", "offset", "length"], "rem": ["warn", "fin", "xp", "num", "cmp", "par", "req", "rec", "resp", " res", "progress", "raw", "Rem", "mem", "rel", "rx", "im", "REM", "val", " resp", "rest", "re", "res", "rm", "pack", "conv", "rom", "iam"], "i": ["fi", "I", "io", "ri", "p", "ii", "iat", "ip", "m", "l", "ki", "ti", "ia", "mi", "ir", "im", "j", "ci", "phi", "v", "xi", "b", "bi", "di", "pi", "it", "ij"], "iovcnt": ["iovCct", "iovCnd", "iovCnt", "lvcpt", "iovdcpt", "iovdcct", "iovlcnd", "iovcpt", "lvCpt", "iovlcnt", "lvcnd", "iovCpt", "lvCnd", "lvCct", "iovcct", "iovdcnd", "lvcnt", "iovdcnt", "iovcnd", "iovlcct", "iovlcpt", "lvcct", "lvCnt"]}}
{"project": "FFmpeg", "commit_id": "bd8ae4885b905415f0e86d4e348c4b72be81e6e6", "target": 0, "func": "AVFilterFormats *avfilter_all_colorspaces(void)\n\n{\n\n    return avfilter_make_format_list(35,\n\n                PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,\n\n                PIX_FMT_YUV411P,  PIX_FMT_YUV410P,\n\n                PIX_FMT_YUYV422,  PIX_FMT_UYVY422,  PIX_FMT_UYYVYY411,\n\n                PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,\n\n                PIX_FMT_YUV440P,  PIX_FMT_YUVJ440P,\n\n                PIX_FMT_RGB32,    PIX_FMT_BGR32,\n\n                PIX_FMT_RGB32_1,  PIX_FMT_BGR32_1,\n\n                PIX_FMT_RGB24,    PIX_FMT_BGR24,\n\n                PIX_FMT_RGB565,   PIX_FMT_BGR565,\n\n                PIX_FMT_RGB555,   PIX_FMT_BGR555,\n\n                PIX_FMT_RGB8,     PIX_FMT_BGR8,\n\n                PIX_FMT_RGB4_BYTE,PIX_FMT_BGR4_BYTE,\n\n                PIX_FMT_GRAY16BE, PIX_FMT_GRAY16LE,\n\n                PIX_FMT_GRAY8,    PIX_FMT_PAL8,\n\n                PIX_FMT_MONOWHITE,PIX_FMT_MONOBLACK\n\n                PIX_FMT_NV12,     PIX_FMT_NV21);\n\n}\n", "idx": 9576, "substitutes": {}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return &d->mmio;\n\n}\n", "idx": 9584, "substitutes": {"base": ["lb", "id", "reset", "use", "bf", "address", "socket", "buffer", "prefix", "source", "based", "shadow", "bp", "back", "bas", "file", "p", "f", "domain", "ase", "block", "m", "l", "bm", "type", "local", "null", "i", "parent", "bs", "server", "super", "r", "bound", "data", "root", "se", " b", "t", "new", "check", "b", "from", "scale", "quote", "bi", "master", "re", "set", "bar", "name", "Base", "state", "template", "out", "pa"], "irqA": ["irquestAB", "iriqAN", "irqE", "irquestAR", "irqAN", "irqAR", "irtqAs", "irquAR", "irtwareAs", "irquA", "irqqAR", "iriqAR", "irqqE", "irwareAN", "irqqD", "irquD", "irtwareAN", "iriqAB", "irquestD", "irwareA", "irtqE", "irtqAN", "irtqA", "irtwareA", "irqqAN", "iriquAB", "iriqE", "irqqAB", "irwareE", "iriqD", "irqD", "irqAB", "irwareAs", "iriquA", "irquAB", "iriquD", "irqqA", "irquestA", "irqqAs", "iriqA", "iriqAs", "iriquAR", "irtwareE", "irqAs"], "irqB": ["iriqV", "\u00edqE", "irqiBB", "irqE", "iriqT", "ioriqT", "iorqT", "irquB", "irqV", "irqq1", "irqiL", "irqu1", "irqqE", "irceE", "\u00edqiBB", "\u00edqiE", "ioriqV", "irqL", "irqqL", "irqqT", "irqqBB", "irceBB", "irqT", "ioriqB", "irqqV", "irqiE", "\u00edqBB", "irq1", "iorq1", "\u00edqiB", "irqBB", "iriq1", "iorqV", "irquT", "irquV", "\u00edqB", "irqiB", "irceB", "iorqB", "irqqB", "\u00edqL", "irceL", "\u00edqiL", "ioriq1", "iriqB"], "chrA": ["chrtU", "shrP", "chrAn", "chdrAn", "chrtAn", "chrL", "chrsP", "shrcL", "shrB", " chrU", " chdrA", " chdrU", "chrP", "chrsA", "chmrB", "chrU", "chrcL", "chmA", "chmB", "shrcB", "shrA", "chrtB", "chdrA", "chrsB", "shrL", "chmrA", "chmrU", "chmP", "chdrU", "chrcB", "shrcA", "chmL", " chdrB", "chdrB", "chrcP", "chrtA", " chrAn", "chrsL", " chdrAn", "chrcA", "chmrAn", "shrcP"], "chrB": ["chrAB", "corrtC", " chrG", "chrarB", "chtG", "chrarC", "chrar2", "chrarA", "corrt2", "chtAB", "chrtG", "corrtB", "chrcC", " chtAB", "chrC", "corrA", " chrAB", " chtB", "chrtC", "chrG", "chrtB", "corrB", "corrtA", " chtG", "corrC", "chrcB", "chtB", " chtA", "chrc2", "chtA", "chrtA", "chrcAB", "chrtAB", "chr2", "chrcA", "corr2", "chrt2", "chrcG"], "clock": ["vector", "ck", "frequency", "sync", "cor", "counter", "step", "poll", "block", "timeout", "sleep", "cker", "mr", "olar", "ctl", "ver", "cc", "loop", "acter", "addr", "server", "hello", "ser", "version", "boot", "node", "check", "change", "ctr", "lock", "c", "start", "Clock", "bot", "ber", "serv", "seed", "set", "watch", "time", "tick", "timer", "offset", "sys"], "it_shift": ["itfhift", "it_load", "itfload", "IT_shift", "it_hift", "t_hift", "IT_hift", "it_push", "t_shift", "t_load", "IT_push", "itfshift"], "dev": ["priv", "add", "cam", "eng", "desc", "data", "t", "scan", "env", "cmd", "Device", "w", "serv", "sd", "pro", "dd", "tr", "av", "ve", "dis", "develop", "test", "dem", "conn", "Dev", "des", "dat", "temp", "att", "debug", "app", "state", "obj", "spec", "a", "ch", "slow", "pt", "device", "go", "enc", "ev", "var", "cur", "def", "serial", "vt", "raw", "mem", "n", "ad", "gu", "sw", "sh", "db", "ds", "out", "off", "det", "p", "adv", "pad", "del", "de", "DEV", "v", "val", "h", "disk", "stick"], "s": ["spec", "sl", "socket", "a", "qs", "rs", "hs", "sp", "p", "gs", "sts", "sub", "ps", "south", "g", "cs", "m", "ins", "sv", "i", "ses", "sam", "bs", "so", "us", "r", "is", "ys", "js", "S", "ss", "ts", "n", "se", "its", "j", "t", "v", "self", "os", "sb", "b", "sw", "sh", "c", "h", "sa", "ns", "w", "fs", "sc", "comm", "ls", "sd", "ds", "sys"], "d": ["td", "dd", "fd", "p", "o", "f", "ld", "da", "dx", "g", "pd", "m", "l", "did", "D", "dn", "r", "j", "de", "n", "dq", "ad", "t", "v", "e", "b", "c", "h", "du", "di", "dat", "w", "bd", "z", "db", "dj", "dm", "dh", "dict", "sd", "dt", "ds", "dr"]}}
{"project": "FFmpeg", "commit_id": "a744064c4155bde063b9e8a47699542be3b8e5eb", "target": 1, "func": "static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}", "idx": 9598, "substitutes": {"s": ["sq", "vs", "qs", "a", "ats", "settings", "rs", "sg", "hs", "gs", "sts", "ps", "ants", "cs", "args", "es", "ses", "sv", "xs", "bs", "txt", "services", "aws", "is", "js", "less", "S", "ss", "ts", "its", "als", "erences", "t", "sets", "sf", "ops", "os", "sb", "b", "c", "sw", "h", "acs", "ns", "fs", "serv", "st", "csv", "comm", "set", "ls", "ims", "conv", "ds", "sys", "parts"], "i": ["ms", " m", "m", " pi", " multi", "im", "ski", "y", "t", "ci", "zi", " mi", "gi", "pi", "oi", "hi", "ji", "ims", "ami", "I", "li", "uri", "init", "ri", "ex", "ind", "ki", "ti", "mu", " ti", "mi", "ix", "xi", "multi", "qi", "si", "batch", " ni", "yi", "id", "ai", "ei", "iq", " li", "ui", "ip", "ic", "in", "index", "chain", "\u0438", "phi", "info", "remote", "it", "ini", " bi", " my", "ii", "fi", "me", "io", "base", "q", " I", "p", "sim", "us", "is", "j", "iu", "v", "c", "di", "bi", "x", " ii", " j", "ij"]}}
{"project": "FFmpeg", "commit_id": "c3afa4db913668e50ac8ffc0bc66621664adc1f4", "target": 1, "func": "void ff_bink_idct_c(DCTELEM *block)\n\n{\n\n    int i;\n\n    DCTELEM temp[64];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        bink_idct_col(&temp[i], &block[i]);\n\n    for (i = 0; i < 8; i++) {\n\n        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );\n\n    }\n\n}\n", "idx": 9607, "substitutes": {"block": ["array", "tx", "sync", "map", "record", "buffer", "blocks", "base", "event", "cell", "list", "hash", "bl", "cl", "point", "bin", "frame", "bc", "ip", "ref", "model", "raw", "bit", "Block", "chain", "row", "box", "view", "check", "line", "lock", "c", "pre", "load", "link", "set", "group", "pack", "BL", "byte"], "i": ["ms", " m", "print", " di", "span", "m", " pi", " multi", "im", " t", "y", "ci", "zi", " mi", "gi", " c", "pi", "slice", "oi", "ims", "asi", "key", " wi", "I", "at", "li", "uri", "init", "ri", "ex", "ind", "ni", "g", "ki", "ti", "loop", " ti", "mi", " vi", "ix", " l", " ki", "xi", "multi", "qi", " index", "si", " ni", "ai", "PI", "ei", "err", "life", "iq", "point", " li", "ui", "ip", "my", "ic", " si", "in", "index", "chain", "\u0438", "phi", "info", "it", "ini", " bi", " iter", "ii", "fi", "me", "io", "base", "q", " I", "p", "sim", "this", "json", "cli", "us", "is", "j", "iu", "v", "di", "bi", "x", "mac", " ii", "set", " j"], "temp": ["tm", "output", "tr", "current", "tx", "map", "buffer", "pt", "base", "Temp", "zip", "form", "p", "sp", "pool", "mint", "m", "tc", "type", "null", "ptr", "tab", "mod", "txt", "term", "alt", "mem", "tem", "data", "ts", "stem", "cap", "t", "v", "cache", "lock", "tmp", "w", "result", "tar", "set", "mp", "emp", "pre", "template", "out", "mt"]}}
{"project": "qemu", "commit_id": "603987488c61ca02ee99890d07cdaecdb118a659", "target": 1, "func": "PCIBus *pci_pmac_init(qemu_irq *pic)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    UNINState *d;\n\n\n\n    /* Use values found on a real PowerMac */\n\n    /* Uninorth main bus */\n\n    dev = qdev_create(NULL, \"Uni-north main\");\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    d = FROM_SYSBUS(UNINState, s);\n\n    d->host_state.bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                                         pci_unin_set_irq, pci_unin_map_irq,\n\n                                         pic, 11 << 3, 4);\n\n\n\n    pci_create_simple(d->host_state.bus, 11 << 3, \"Uni-north main\");\n\n\n\n    sysbus_mmio_map(s, 0, 0xf2800000);\n\n    sysbus_mmio_map(s, 1, 0xf2c00000);\n\n\n\n    /* DEC 21154 bridge */\n\n#if 0\n\n    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */\n\n    pci_create_simple(d->host_state.bus, 12 << 3, \"DEC 21154\");\n\n#endif\n\n\n\n    /* Uninorth AGP bus */\n\n    pci_create_simple(d->host_state.bus, 13 << 3, \"Uni-north AGP\");\n\n\n\n    /* Uninorth internal bus */\n\n#if 0\n\n    /* XXX: not needed for now */\n\n    pci_create_simple(d->host_state.bus, 14 << 3, \"Uni-north internal\");\n\n#endif\n\n\n\n    return d->host_state.bus;\n\n}\n", "idx": 9616, "substitutes": {"pic": ["phot", "doc", "nic", "py", "png", "Pic", "lib", "pc", "fi", "picked", "cam", "picture", "p", "sp", "peg", "mic", "jp", "i", "capt", "ic", "ican", "ig", "script", "magic", "icc", "mc", "phy", "ics", "xi", "anc", "eric", "pin", "pi", "fc", "pict", "php", " Pic", "sc", "style", "pa"], "dev": ["dd", "tr", "priv", "a", "av", "device", "go", "ev", "devices", "p", "ve", "o", "DE", "pad", "nt", "eng", "g", "def", "mem", "de", "data", "n", "ad", "dem", "DEV", "conn", "v", "gu", "os", "Dev", "sh", "h", "Device", "des", "hw", "w", "db", "iv", "disk", "sd", "pro", "ds", "out", "sys"], "s": ["sl", "qs", "a", "ats", "rs", "sp", "gs", "sts", "p", "south", "ps", "g", "cs", "m", "sv", "i", "sam", "ses", "bs", "us", "r", "is", "js", "S", "ss", "ts", "n", "se", "t", "v", "os", "sb", "b", "sw", "sh", "c", "h", "sa", "ns", "des", "w", "fs", "si", "x", "set", "ls", "sd", "ds", "sys"], "d": ["td", "doc", "dd", "id", "fd", "end", "p", "o", "f", "od", "ind", "ld", "da", "dx", "nd", "g", "pd", "m", "l", "cd", "dc", "did", "D", "dn", "r", "md", "j", "de", "gd", "done", "n", "y", "dl", "ad", "t", "new", "v", "rd", "e", "b", "c", "ed", "h", "di", "dat", "w", "bd", "des", "z", "result", "db", "dict", "dm", "dh", "dj", "sd", "dt", "debug", "ds", "dr"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    qdict_put(dict, \"token\", qstring_from_str(input->str));\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 9619, "substitutes": {"lexer": [" lexeme", "lexiter", "maile", "code", "mailer", "marker", "markeme", "scaner", "eye", "lexeme", "moditer", "modeme", "eyeder", "lexener", "scanener", " lexener", "lexe", " lexeder", "marke", "mode", "mailener", "coditer", "scaniter", " lexiter", "mailiter", "eyer", "eyiter", "codeder", "scane", " lexe", "coder", "moder", "lexeder", "markiter"], "input": ["output", "command", "select", "current", "config", "source", "text", "add", "buffer", "feature", "format", "Input", "image", "document", "pattern", "event", "history", "form", "argument", "response", "ip", "instance", "active", "local", "client", "request", "raw", "token", "qa", "in", "lat", "attribute", "script", "accept", "data", "view", " inputs", "check", "feed", "unknown", "expression", "query", "from", "start", "xml", "it", "get", "context", "initial"], "type": ["key", "op", "id", "typ", "what", "status", "pe", "part", "tp", "ty", "code", "at", "format", "ping", "match", "pattern", "role", "types", "file", "error", "TYPE", "inter", "length", "relation", "kind", "ver", "token", "word", "index", "top", "Type", "test", "level", "version", "t", "count", "ype", "class", "action", "change", "title", "start", "rule", "by", "color", "result", "set", "time", "name", "state", "style"], "x": ["xp", "on", "xy", "tx", "mx", " cx", "k", " i", "p", " dx", "ex", "ox", "dx", "xc", "l", "wx", "X", "i", "xs", "lat", "index", "rx", "ix", "t", "px", "xes", "xi", "xt", "xx", "yx", "fx", "ax", "xa", "lex", " xx", "xf"], "y": [" ty", "yt", "py", "xy", "ya", "axy", "sky", "vy", "ady", "yy", "ay", "sim", "year", "oy", "my", "ies", "ye", "yer", "ys", "yd", "Y", "hot", "yo", "asy", "ey", " ya", "ly", "ery", "gy", "sy", "fy", "ym", "sys", "iy", "by", " ay", " sy", " py", "ny", "cy"], "parser": ["command", "format", "older", "proc", "func", "true", "finder", "parent", "oder", "parse", "package", "http", "handler", "man", "unknown", "metadata", "iterator", "ard", "context", "rer", "pro", "upper", "bank", "inner", "dd", "tp", "message", "layer", "document", "could", "job", "bird", "server", "node", "rule", "operator", "table", "driver", "writer", "state", "params", "python", "number", "runner", "part", "language", "buffer", "policy", "upload", "processor", "Parser", "file", "book", "builder", "worker", "volume", "component", "instance", "process", "local", "container", "store", "function", "now", "plugin", "class", "der", "reader", "master", "er", "peer", " scanner", "jack", "student", "timer", "adder", "arser", "password", "wrapper", "event", "manager", "p", "pool", "program", "this", "client", "yer", "token", "json", "processing", "self", "primary", "player", "kernel", "php", "ner", "disk", "private", "loader", "parts"], "dict": ["key", "doc", "obj", "dd", "map", "part", "sum", "add", "vol", "decl", "ct", "list", "det", "func", "defined", "hash", "df", "pair", "nt", "da", "d", "ld", "pd", "pkg", "del", "client", "hd", "ud", "def", "cd", "container", "local", "window", "direct", "json", "D", "details", "md", "ict", "data", "cond", "ad", "count", "wd", "conf", "dir", "metadata", "inf", "cmd", "tmp", "dat", "di", "str", "bd", "make", "table", "dot", "result", "set", "db", "debug", "nd", "draw", "ds", "dr"], "brace_count": ["brace8check", "braceptcount", "apply_cycle", "brace_sum", "bracemingcount", "trackingconst", "style64total", "alias_count", "bracelecount", "braceitycount", "braceitynumber", "bracececounter", "bracefulcycle", "brace64type", "quote_count", "braceingcheck", "braceletcheck", "brace8count", "style64count", "brace_check", "bracefulweight", "bracelesum", "style_len", "apply_only", "alias_sum", "case_force", "bracemingsum", "brace_found", "alias_total", "apply_count", "bracecetype", "bracemingfound", "brace_type", "bracelefound", "braceityweight", "brace_counter", "brace_len", "quote64sum", "bracefulonly", "style_count", "braceitycycle", "case_counter", "caseceforce", "quote64number", "braceletconst", "aliascetotal", "brace8const", "bracemingtype", "casececounter", "trackingsum", "alias_found", "applyfulweight", "bracefulcount", "bracecetotal", "case_count", "braceceforce", "quote64counter", "braceletcount", "brace_weight", "brace_total", "applyfulonly", "style64len", "brace_only", "braceletotal", "brace64number", "aliascesum", "brace8sum", "quote_number", "brace64counter", "quote64count", "track_const", "quote_counter", "brace_number", "braceletsum", "brace_cycle", "bracecesum", "braceminglen", "bracepttype", "braceptforce", "applyfulcycle", "apply_weight", "bracemingtotal", "brace64total", "brace64sum", "braceitysum", "brace_force", "case_type", "aliascecount", "style64type", "style_total", "brace_const", "trackingcheck", "casecetype", "braceingconst", "braceityonly", "aliascefound", "track_count", "track_sum", "casececount", "bracecefound", "quote_sum", "brace64count", "brace64len", "braceingcount", "applyfulcount", "track_check", "trackingcount", "braceitycounter", "brace64force", "bracececount", "style_type", "braceptcounter", "braceingsum"], "bracket_count": ["brack_cache", "bratch_length", "brink_count", "brucker32number", "brink_amount", "brackets_Count", "brucket_filter", "bratchCountlength", "bracket_counter", "bracket_status", "bratch_info", "brucker_length", "bracket_filter", "brucker32count", "brucker32length", "bracket_Count", "brucket9count", "bracketCountcounter", "bracketCountcount", "bracket9close", "bracket9code", "brink_mount", "bracketTimecount", "brucker32status", "brucket_close", "brucket_count", "bracket32status", "brack_size", "bratch_counter", "bratchCountinfo", "brucket_code", "brucket9code", "bracket9filter", "bracket_amount", "bratchCountcount", "bracket9count", "bracket_size", "brucket9filter", "bracketCountlength", "brucker_number", "bracket32count", "brackets_count", "brucker_status", "bracket32length", "bracket_mount", "brucket9close", "brackets_cache", "bracketCountinfo", "bracket_number", "bracket_info", "bratch_count", "bracketTimecounter", "bracket_length", "brack_Count", "bracket32number", "bracketTimeinfo", "brack_count", "brucker_count", "bracketTimelength", "bratchCountcounter", "bracket_cache", "bracket_close", "bracket_code"]}}
{"project": "qemu", "commit_id": "041d95f42e39ed1d3a029332cab9966889f0aeb3", "target": 0, "func": "static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,\n\n                                              target_ulong eaddr, uint32_t pid)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n    ppcemb_tlb_t *tlb;\n\n    hwaddr raddr;\n\n    target_ulong page, end;\n\n    int i;\n\n\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb.tlbe[i];\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {\n\n            end = tlb->EPN + tlb->size;\n\n            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {\n\n                tlb_flush_page(cs, page);\n\n            }\n\n            tlb->prot &= ~PAGE_VALID;\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    ppc4xx_tlb_invalidate_all(env);\n\n#endif\n\n}\n", "idx": 9629, "substitutes": {"env": ["ef", "vs", "obj", "ah", "pe", "et", "config", "ch", "here", "enc", "ev", "proc", "ov", "ec", "sp", "ve", "dev", "gov", "enter", "uv", "eng", "sec", "vp", "cur", "esm", " ens", "sv", "Environment", "desc", "vt", "window", "en", "shell", "ce", "equ", "pres", "ew", "server", "esc", "ctx", "conn", "forge", "v", "esp", "rc", "environment", "e", "sb", "cmd", "nc", "er", "st", "sc", "org", "context", "db", "cv", "eve", "nv", "ds", "ens", "viron"], "eaddr": ["eddDR", "oaddress", " eddr", " llder", "eadder", "aydr", "eaddress", "aydress", "eddr", "eadr", "eadDR", " llmd", " edder", "eddder", " lldr", " edmd", "oadr", "edddr", "oadDR", " eddress", "ayr", "eddmd", "ayDR", "edddress", "oaddr", " lldress", "eadmd"], "pid": ["key", "id", "fd", "pc", "path", "pt", "ping", "pan", "proc", "p", "uid", "kt", "post", "kill", "wid", "ps", "phase", "pkg", "oid", "process", "pos", "ptr", "por", "parent", "pri", "port", "qt", "pm", "sid", " PID", " ps", "pr", "mid", " p", "po", "vid", " tid", "pi", "dh", "pty", "rid", "pa"], "cs": ["ms", "cons", "ck", "vs", "aps", "pc", "cus", "cks", "rs", "css", "ec", "gs", "sts", "CS", "ps", "cc", "bs", "js", "ys", "ts", "ac", "cas", "ctx", "wcs", "c", "acs", "ns", "nc", "fs", "cms", "ks", "sc", "ls", "ds", "sys"], "tlb": ["ptbl", "llp", "telb", "otbl", " tpl", " trb", "telp", "atlbs", " terb", "Tlp", "ptlbs", "atlp", " tlbs", "ttlbs", "itlb", "otlp", "mtlb", "tlab", "ktrb", "attrb", "lbl", "laterb", "ttlb", "entpl", "tlam", "tpl", "tli", "telab", "ktmb", "tbl", "ptlam", "tenbl", "tmb", "otlbs", "tslr", "Tbl", "ptlb", "Tlb", "llbs", "llb", "atlb", "attlab", "tlr", "latlp", "atlr", "otlab", "Tlbs", "mtpl", "ttzb", "tenlb", " tlam", "tenli", "itlam", "telbs", "ktlb", "tenlp", " tli", "mtlab", "entlb", "itbl", " tbl", "itlbs", "attmb", "trb", "tslp", "tzb", " tlp", "ttlr", " tmb", "attlb", "ktlab", "tlp", "latzb", "otlb", "tterb", "ttlp", "tlbs", "enterb", "tslbs", "entlab", "tslb", "ttlab", "Tli", "terb", "latlb", " tlab", " tzb", "mterb"], "raddr": ["radr", "raddress", "rdloc", "vraddr", "vrloc", "rdaddr", " rhash", "Rhash", " rarp", "rdarp", "rdaddress", "Raddr", "rfadr", "Radr", "rloc", " raddress", " radr", " rloc", "rfhash", "rfaddr", "rhash", "rarp", "vraddress", "vrarp", "Raddress", "rfaddress"], "page": [" PAGE", "next", "ph", "ge", "entry", "ice", " count", " offset", " req", "pe", "pc", "address", "pp", "url", "message", "order", "me", "route", "go", "step", "update", " pc", "Page", "p", "point", " pe", " port", "PA", "sp", "pad", "pages", "pg", " window", "g", "block", "phrase", "ref", "ip", "instance", "pixel", " pi", "fe", "port", "request", "window", " r", "loop", " pointer", "server", "index", "row", "j", "node", "count", "site", "pl", "line", " Page", " pg", " p", " row", "table", "peer", "x", "batch", "age", " pages", "pt", "aa", "offset", "out", "number"], "end": ["fin", "len", "next", "until", "id", "wall", "send", "eff", "add", "begin", "ff", "p", "except", "END", "pad", "End", "stop", "limit", "gate", "length", "ended", "en", "ext", " End", "bound", "last", "final", "check", "ending", "e", "close", "append", "hend", "est", "start", "rest", "ent", "it", "org", "max", "nd", "ender", "offset", "size"], "i": ["ami", "id", "ai", "I", "io", "me", "li", "ei", " I", "print", "iq", "k", "p", "o", "sim", "ind", "ui", "ip", "m", "ki", "ti", "ic", "in", "mi", "index", "is", "j", "im", "ix", "n", "y", "t", "ci", "\u0438", "iu", "phi", "v", "zi", "xi", "e", "multi", "qi", "gi", "di", "bi", "ij", "iy", "pi", "si", "it", "x", "batch", "ini", " ii", "oi", "ji", "ims", "asi", "ii"]}}
{"project": "qemu", "commit_id": "9cd1e97a7ae2856ec00b5682db0dea17f42fc734", "target": 0, "func": "void pci_bridge_initfn(PCIDevice *dev, const char *typename)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = PCI_BRIDGE(dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_word_test_and_set_mask(dev->config + PCI_STATUS,\n\n                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * TODO: We implement VGA Enable in the Bridge Control Register\n\n     * therefore per the PCI to PCI bridge spec we must also implement\n\n     * VGA Palette Snooping.  When done, set this bit writable:\n\n     *\n\n     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,\n\n     *                            PCI_COMMAND_VGA_PALETTE);\n\n     */\n\n\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * If we don't specify the name, the bus will be addressed as <id>.0, where\n\n     * id is the device id.\n\n     * Since PCI Bridge devices have a single bus each, we don't need the index:\n\n     * let users address the bus using the device name.\n\n     */\n\n    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {\n\n\t    br->bus_name = dev->qdev.id;\n\n    }\n\n\n\n    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, OBJECT(br), \"pci_bridge_pci\", UINT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, OBJECT(br), \"pci_bridge_io\", 65536);\n\n    br->windows = pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n}\n", "idx": 9630, "substitutes": {"dev": ["ow", "priv", "cam", "nav", "d", "eng", "block", "desc", "data", "scan", "rem", "wd", "os", "env", "van", "cmd", "w", "serv", "disc", "sd", "pro", "tr", "av", "ve", "buf", "task", "dis", "ver", "develop", "test", "dem", "conn", "conf", "Dev", "any", "des", "adj", "driver", "att", "pack", "debug", "app", "obj", "ch", "pt", "device", "go", "ev", "var", "nt", "admin", "def", "serial", "raw", "ctx", "bus", "info", "remote", "die", "comment", "exec", "hw", "er", "it", "db", "loc", "event", "det", "p", "adv", "normal", "de", "boot", "DEV", "v", "val", "watch"], "typename": ["typenamed", "typenew", "tyrename", "TYlenname", "tymenename", "tymenname", "TYpenew", "tyternAME", "typenname", "TYpenename", "TYpename", "TyrenAME", "tyrenAME", "Typenamed", "TYpenname", "typenename", "tymenew", "tyternename", "tyternamed", "tyternname", "tyternew", "Tyrename", "TYlenename", "TypenAME", "typenAME", "TYlename", "Tyrenname", "Tyrenamed", "tymename", "tymenamed", "tylename", "tymenAME", "tytername", "tylenew", "Typenname", "tylenname", "Typename", "tylenename", "tyrenname", "TYlenew", "tyrenamed"], "parent": ["cmp", "map", "par", "base", "child", "home", "p", "sp", "pool", "task", "Parent", "cp", "unit", "parents", "block", "g", "ref", "m", "local", "container", "port", "server", "chain", "test", "node", "root", "last", "t", "ctx", "reg", "self", "tree", "remote", "host", "fat", "master"], "br": ["lr", "prop", "block", "shr", "BR", "r", "bern", "rem", "fr", "pr", "b", "str", "bd", "nb", "comm", "el", "arr", "kr", "tr", "av", "rb", "bolt", "sp", "bl", "buf", "roller", "bc", "jp", "bor", "ptr", "bn", "ver", "bs", "usr", "rel", "repl", "batch", "bt", "cr", "bro", "obj", "hr", "ch", "bp", "err", "ev", "ov", "form", "resp", "var", "gr", "bm", "mr", "nah", "bsp", "bg", "browser", "n", "reg", "bed", "broad", "bar", "vr", "mt", "bridge", "Br", "aj", "mg", "adr", "j", "bre", "v", "ctr", "bh", "ber", "dr"], "sec_bus": ["esc___boot", "secure_bus", "esc___block", "esc_boot", "sec___box", "seccityBus", "esc_bus", "sec2bus", "secure___Bus", "sec___mount", "seccitybus", "esc___bus", "sec___boot", "esc_sync", "sec3mount", "sec1us", "esc___sync", "seq_bus", "esc_box", "sec3bus", "secure1driver", "sec___sync", "secitybus", "esc_block", " sec_machine", "esc___host", "esc_BUS", "sec___host", "sec_project", "sec_bridge", "seq_boot", "seccitysync", "secure1bus", "sec3machine", " sec_BUS", "secure_driver", "secitybook", "sec___machine", "sec_box", "sec___bridge", "secure___bus", "sec1box", "seq_project", "sec_Bus", "secure_Bus", "secure___us", "seccityblock", "secessionblock", "esc_dev", "Sec_block", "secure___box", "Sec_bridge", "sec___dev", "sec_us", "esc_host", "esc_Bus", "esc_book", "seq_block", "sec_board", "sec2bridge", "secure_us", "sec_sync", "sec_machine", "esc___Bus", "sec_block", "secityboard", "esc___dev", "sec3BUS", "secessionbus", "sec_dev", "Sec_bus", "secessionboot", "sec___BUS", "sec2block", " sec_Bus", "sec_mount", "sec_book", " sec_box", " sec_pipe", " sec_mount", "secure1box", "esc_board", "sec___Bus", "sec_boot", "secure_box", "sec___block", "sec_BUS", "secessionproject", "secure1us", "sec___us", "esc___BUS", "sec___bus", "sec1driver", "esc___box", "sec_host", "sec_pipe", "sec2box", "Sec_box", "sec_driver", "sec1bus"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,\n\n                              int width, int y)\n\n{\n\n    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,\n\n                           0, y, 0, 0, 0, 0, width, 1);\n\n}\n", "idx": 9639, "substitutes": {"linebuf": [" lineb", "Linebuffer", "Linequeue", "inebuffer", "Linebuf", "linkbuffer", "inevar", "linebuffer", " linecache", "linbuffer", " linequeue", " linevar", "inebuf", "lincache", "linequeue", "linecache", "inecache", " linebuffer", "linvar", "linkqueue", "linevar", "lineb", "linbuf", "Lineb", "linkbuf", "linkb"], "fb": ["lb", "FB", "fd", "bf", "fi", "uf", "rb", "ff", "rf", "buf", "f", "abb", "fp", "bm", "hd", "cb", "bs", "rl", "obb", "pb", "eb", "fg", "erb", "fr", "sb", "facebook", "b", "sbm", "grab", "bb", "fc", "nb", "fx", "gb", "ib", "bt", "wb", "bridge"], "y": ["ity", "yt", "xy", "id", "axy", "ty", "ch", "a", "yy", "p", "height", "ay", "o", "bottom", "ind", "type", "i", "dy", "index", "top", "j", "t", "Y", "v", "ey", "b", "c", "ly", "ery", "gy", "sy", "h", "ym", "w", " dy", "iy", "by", "x", " height", "ny", "offset", "out"]}}
{"project": "qemu", "commit_id": "30b8b68eb574fd68060eebcc4da790fdfe18d668", "target": 0, "func": "static inline abi_long target_to_host_cmsg(struct msghdr *msgh,\n\n                                           struct target_msghdr *target_msgh)\n\n{\n\n    struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh);\n\n    abi_long msg_controllen;\n\n    abi_ulong target_cmsg_addr;\n\n    struct target_cmsghdr *target_cmsg;\n\n    socklen_t space = 0;\n\n    \n\n    msg_controllen = tswapal(target_msgh->msg_controllen);\n\n    if (msg_controllen < sizeof (struct target_cmsghdr)) \n\n        goto the_end;\n\n    target_cmsg_addr = tswapal(target_msgh->msg_control);\n\n    target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);\n\n    if (!target_cmsg)\n\n        return -TARGET_EFAULT;\n\n\n\n    while (cmsg && target_cmsg) {\n\n        void *data = CMSG_DATA(cmsg);\n\n        void *target_data = TARGET_CMSG_DATA(target_cmsg);\n\n\n\n        int len = tswapal(target_cmsg->cmsg_len)\n\n                  - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr));\n\n\n\n        space += CMSG_SPACE(len);\n\n        if (space > msgh->msg_controllen) {\n\n            space -= CMSG_SPACE(len);\n\n            gemu_log(\"Host cmsg overflow\\n\");\n\n            break;\n\n        }\n\n\n\n        if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) {\n\n            cmsg->cmsg_level = SOL_SOCKET;\n\n        } else {\n\n            cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level);\n\n        }\n\n        cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type);\n\n        cmsg->cmsg_len = CMSG_LEN(len);\n\n\n\n        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n\n            gemu_log(\"Unsupported ancillary data: %d/%d\\n\", cmsg->cmsg_level, cmsg->cmsg_type);\n\n            memcpy(data, target_data, len);\n\n        } else {\n\n            int *fd = (int *)data;\n\n            int *target_fd = (int *)target_data;\n\n            int i, numfds = len / sizeof(int);\n\n\n\n            for (i = 0; i < numfds; i++)\n\n                fd[i] = tswap32(target_fd[i]);\n\n        }\n\n\n\n        cmsg = CMSG_NXTHDR(msgh, cmsg);\n\n        target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg);\n\n    }\n\n    unlock_user(target_cmsg, target_cmsg_addr, 0);\n\n the_end:\n\n    msgh->msg_controllen = space;\n\n    return 0;\n\n}\n", "idx": 9643, "substitutes": {"msgh": ["meshr", "mesgh", " msg", "Msge", "msht", "Msgh", "masgo", " msche", "msche", "msge", "csge", "mesGH", "Mshr", "csgh", "tsg", "csht", "masge", "tsgh", "csg", "masht", "msgo", "csgr", "msGH", "mesge", "csgo", "csche", "masgh", "tsgr", " msht", " msgr", "masGH", "msgr", "mashr", "tsche", "msg", " msgo", "MsGH", " msge", "mshr"], "target_msgh": ["target_mcph", "target_mmph", "target___mshr", "target_macgh", "target___masgh", "target_mesgr", "target___masg", "target_msgr", "target_mesgh", "target_mcha", "target_mshr", "target_masg", "target_mashr", "target___masha", "target_mcrh", "target_tsrh", "target_msph", "target_mesg", "target___msha", "target_msha", "target_macha", "target_tsgs", "target_mchr", "target_msgs", "target_mmgr", "target_msg", "target___msg", "target_mcgh", "target_masha", "target_tsph", "target___mashr", "target_mcg", "target_machr", "target_mmrh", "target___msgh", "target_msrh", "target_tsgh", "target_tsgr", "target_mesgs", "target_macg", "target_mcgr", "target_masgh", "target_mcgs", "target_tsg", "target_mmgh"], "cmsg": ["pcmsg", "confdomain", "Cmsg", " csum", "ancmail", "pcmessage", "lcmd", " cMsg", "rcmd", "ccmessage", "Cgm", "ecmd", "cachemsg", "ccmd", "camsum", "cog", "arcattr", "ccpkg", "curgm", "cmail", "cmd", "lmsg", "lcmessage", "lgm", "cMsg", "lccmd", " cmg", "curmsg", "ancmsg", "arcurl", "cudomain", "cmess", "camget", "cstat", "arcmail", "uncarg", "cdomain", "confmsg", "lcmg", "csum", "decurl", "cumsg", "curl", "cattr", "arcmessage", "rcgm", "xcsg", "carg", "decattr", "ancattr", " cgm", "cget", "curmd", "acpkg", "arcmess", "ccmsg", "lmessage", "lcsum", " ccmd", "acmessage", "concommand", "csend", "Cmd", "xcmsg", "gcgm", " cog", "decmail", "comsg", "cusum", "coarg", "costat", "cmg", "cuget", "lcog", "abcmessage", "csg", "curog", "ccommand", "confsum", "rcmsg", "ecsg", "Cog", "conmsg", "decmsg", "camdomain", "cammsg", "arcmsg", "abcsend", "cachecmd", "cpkg", "acmess", "cachemessage", "acsend", "abcmsg", "ecmsg", "cmessage", "xcmd", "unccommand", "acmsg", "pcmg", "gcmsg", "abcpkg", "gcog", "conarg", "arccmd", "ccsend", "constat", "cocommand", "pcMsg", "gcsum", " cmd", "rcog", "accmd", "uncmsg", "lcMsg", "ancurl", "cgm", "confget", " csg", "cachemess", "lcmsg", " cmessage", "lcgm", "uncstat"], "msg_controllen": ["msg_controlnum", "msg_controlen", "msg_controllerener", "msg_controllerens", "msg_controle", "msg_controllinger", "msg_introllen", "msg_introlledlen", "msg_introllnum", "msg_controllan", "msg_controlens", "msg_ontrollan", "msg_contillen", "msg_controlledlen", "msg_introlleden", "msg_controlleder", "msg_contcontlen", "msg_controllinglen", "msg_ontrolle", "msg_ontrolen", "msg_contcolen", "msg_ontroller", "msg_introler", "msg_contvallen", "msg_controlleden", "msg_controlledEN", "msg_controllingen", "msg_introlllen", "msg_contcolle", "msg_contcontnum", "msg_introllens", "msg_introlledens", "msg_introlEN", "msg_contcollen", "msg_controlener", "msg_contillens", "msg_controllerEN", "msg_contvalun", "msg_ontrollen", "msg_controler", "msg_contvalle", "msg_controllnum", "msg_introllle", "msg_ontrole", "msg_ontrolener", "msg_controllede", "msg_controlan", "msg_contillan", "msg_introllun", "msg_controlllen", "msg_controllednum", "msg_introlle", "msg_controlleren", "msg_ontrollener", "msg_contillEN", "msg_introllednum", "msg_contcolun", "msg_controlEN", "msg_ontrolEN", "msg_controllEN", "msg_controllerlen", "msg_introller", "msg_controller", "msg_controlleran", "msg_controllens", "msg_controlle", "msg_contconten", "msg_controllun", "msg_controllinge", "msg_ontrolens", "msg_controllle", "msg_contvalen", "msg_controlun", "msg_introlun", "msg_ontrolllen", "msg_introllEN", "msg_controllener", "msg_introlen", "msg_controllerer", "msg_ontroler", "msg_ontrollens", "msg_controlledens", "msg_ontrollEN", "msg_contcontens", "msg_ontrolan", "msg_controllingener"], "target_cmsg_addr": ["target_cmsg_order", "target_cmsg_address", "target_cg_addr", "target_cg_ptr", "target_cmsg_dr", "target_cmsg_add", "target_cmsg__address", "target_cmsg_ptr", "target_cmsg__order", "target_cmsg__addr", "target_cmsg__dr", "target_cg_address", "target_cg_add"], "target_cmsg": ["target_rcog", "target_lcmessage", "target_acundle", "target_lcmd", "target_acdr", "target_acmg", "target_arcmsg", "target_ctx", "target_xcg", "target_curg", "target_lcurl", "target_acog", "target_ancmessage", "target_mmd", "target_cosmessage", "target_cgl", "target_cMsg", "target_cammsg", "target_tmsg", "targetableancurg", "target_arcmn", "target_commmsg", "target_rcmg", "target_xcmsg", "target_cacheundle", "target_encundle", "target_cdr", "target_lcog", "target_camog", "target_lcmsg", "targetableancmessage", "target_xctx", "target_tmessage", "target_vcmn", "target_cerg", "target_mcMsg", "target_rcmessage", "target_cog", "target_ancurg", "targetablecmessage", "target_acmessage", "target_Cmsg", "target_gcmn", "target_cmn", "targetablecmsg", "target_gcimg", "target_lcg", "target_vcimg", "target_csm", "target_gcgl", "target_CMsg", "target_rctx", "target_encurl", "target_ancmsg", "target_vcmsg", "target_rcg", "targetablecurg", "target_lctx", "targetableancmsg", "target_mMsg", "target_mcmd", "target_cosurg", "target_commgame", "target_cgame", "target_commmessage", "target_cosurl", "target_ancurl", "target_cpgame", "target_cosmsg", "target_cpsm", "target_mcdr", "target_lcMsg", "target_cmg", "target_acurl", "target_vcgl", "target_lcerg", "target_arcgl", "target_cacheurl", "target_cpmsg", "target_cimg", "target_encog", "target_tsm", "target_cpmessage", "target_Cmd", "target_Cog", "target_mmsg", "target_rcmsg", "target_gcmsg", "target_cmd", "target_camerg", "target_cundle", "target_lcdr", "target_curl", "target_mcmsg", "target_mog", "target_commsm", "targetableancurl", "target_lcurg", "target_cammessage", "target_xcmessage", "target_cachemsg", "targetablecurl", "target_arcimg", "target_cmessage", "target_cg", "target_tgame", "target_acmsg", "target_mcog", "target_acMsg", "target_cacheog", "target_rcerg", "target_encmsg", "target_acmd"], "data": ["len", "Data", "extra", "map", "area", "hash", "trans", "pos", "ata", "def", "zero", "type", "window", "mu", "rel", "done", "ATA", "mode", "info", "cache", "ns", "options", "msg", "DATA", "no", "name", "space", "size"], "target_data": ["target_len", "target___len", "target___data", "target___info", "target_info", " target_info", "target___addr", " target_addr", "target_addr", " target_len"]}}
{"project": "qemu", "commit_id": "9d6f1b73f83a02fb28438fa9a487f5c7d245e4af", "target": 0, "func": "static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    sprintf(pidstr, \"%d\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n", "idx": 9647, "substitutes": {"pidfile": ["pfile", " pidFile", "pinfile", "pidfilename", "pinFile", " pidname", "logFile", " pidf", "pFile", "procfile", "pfilename", "pinblock", "pidtree", "logfile", " pidel", "pinlist", "pidname", "proctree", "pidFile", "procFile", " pidfilename", "pidblock", "pingf", "pintree", "pingfile", "pinel", "proclist", "pidel", " pidtree", "pingblock", "pidlist", "pingel", " pidblock", "logname", "pname", "pinf", "pidf", " pidlist", "logfilename"], "pidfd": ["procld", " pidld", "ptyd", "pfc", "pidfin", "panfp", "reqfd", "pinfin", "pinfp", "pinfd", " pidd", "conddb", "cpfd", "panstream", "cpfin", "killfc", "phyfd", "pidfp", "piddir", "prFD", "pidfunc", "ptyfe", "killf", "pfp", "prdir", " pofin", "reqFD", " piddb", " pofd", "pidfi", " piddd", "phyfp", "ptyfc", "reqfc", " pidfe", "panfin", "phyfi", "pidf", "condFD", "reqf", "piddb", " pidFD", "condfd", "panfn", "killFD", " pidfc", " pidfin", " pidfunc", "pf", "cpFD", "procfc", "pidd", " pof", "prfd", "condd", "procfd", "panfd", "pinfi", "pidld", "prdd", " pidstream", "prfc", "pinfc", " pidfn", "pidFD", "ptyFD", "pindir", "pidstream", "phyfc", "prld", "piddd", "ptydb", "panfunc", " pidf", "pinfn", "pidfc", "panfc", "pfunc", "pinstream", " pidfp", "pidfn", "pfd", "ptyfin", "prfin", "panf", "pinfe", "cpdir", " pofp", "killfd", "pinFD", "pidfe", "pfi", "ptyfd", "procdd"], "pidstr": ["pinfr", " piddef", "pinhex", "pidstring", "pingstring", "pidhex", "pst", "msgSTR", "pingfr", "pidSTR", " pidname", "pantr", "pstr", "pinvol", "pinghex", "psstr", "panvol", "pindef", " pidSTR", "pidfr", "piddef", "pintr", " pidfr", "pstring", " pidhex", "pingdef", "pidvol", "pSTR", "pidname", " psname", "psstring", "panstring", "panstr", " pidst", "msgvol", "pinstr", " psstr", "pidtr", "pingstr", "psfile", "panfile", "pingSTR", "msgtr", "pidst", " piddata", " psdata", "pdata", "pname", "piddata", " pidstring", " pidtr", "pingst", "pinSTR", " psstring", "msgstr", "panSTR"]}}
{"project": "qemu", "commit_id": "3d3efba020da1de57a715e2087cf761ed0ad0904", "target": 1, "func": "static void handle_pending_signal(CPUArchState *cpu_env, int sig)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(cpu_env);\n\n    abi_ulong handler;\n\n    sigset_t set, old_set;\n\n    target_sigset_t target_old_set;\n\n    struct target_sigaction *sa;\n\n    struct sigqueue *q;\n\n    TaskState *ts = cpu->opaque;\n\n    struct emulated_sigtable *k = &ts->sigtab[sig - 1];\n\n\n\n    trace_user_handle_signal(cpu_env, sig);\n\n    /* dequeue signal */\n\n    q = k->first;\n\n    k->first = q->next;\n\n    if (!k->first)\n\n        k->pending = 0;\n\n\n\n    sig = gdb_handlesig(cpu, sig);\n\n    if (!sig) {\n\n        sa = NULL;\n\n        handler = TARGET_SIG_IGN;\n\n    } else {\n\n        sa = &sigact_table[sig - 1];\n\n        handler = sa->_sa_handler;\n\n    }\n\n\n\n    if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) {\n\n        /* Guest has blocked SIGSEGV but we got one anyway. Assume this\n\n         * is a forced SIGSEGV (ie one the kernel handles via force_sig_info\n\n         * because it got a real MMU fault), and treat as if default handler.\n\n         */\n\n        handler = TARGET_SIG_DFL;\n\n    }\n\n\n\n    if (handler == TARGET_SIG_DFL) {\n\n        /* default handler : ignore some signal. The other are job control or fatal */\n\n        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {\n\n            kill(getpid(),SIGSTOP);\n\n        } else if (sig != TARGET_SIGCHLD &&\n\n                   sig != TARGET_SIGURG &&\n\n                   sig != TARGET_SIGWINCH &&\n\n                   sig != TARGET_SIGCONT) {\n\n            force_sig(sig);\n\n        }\n\n    } else if (handler == TARGET_SIG_IGN) {\n\n        /* ignore sig */\n\n    } else if (handler == TARGET_SIG_ERR) {\n\n        force_sig(sig);\n\n    } else {\n\n        /* compute the blocked signals during the handler execution */\n\n        target_to_host_sigset(&set, &sa->sa_mask);\n\n        /* SA_NODEFER indicates that the current signal should not be\n\n           blocked during the handler */\n\n        if (!(sa->sa_flags & TARGET_SA_NODEFER))\n\n            sigaddset(&set, target_to_host_signal(sig));\n\n\n\n        /* block signals in the handler using Linux */\n\n        do_sigprocmask(SIG_BLOCK, &set, &old_set);\n\n        /* save the previous blocked signal state to restore it at the\n\n           end of the signal execution (see do_sigreturn) */\n\n        host_to_target_sigset_internal(&target_old_set, &old_set);\n\n\n\n        /* if the CPU is in VM86 mode, we restore the 32 bit values */\n\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n\n        {\n\n            CPUX86State *env = cpu_env;\n\n            if (env->eflags & VM_MASK)\n\n                save_v86_state(env);\n\n        }\n\n#endif\n\n        /* prepare the stack frame of the virtual CPU */\n\n#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \\\n\n    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)\n\n        /* These targets do not have traditional signals.  */\n\n        setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n#else\n\n        if (sa->sa_flags & TARGET_SA_SIGINFO)\n\n            setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n        else\n\n            setup_frame(sig, sa, &target_old_set, cpu_env);\n\n#endif\n\n        if (sa->sa_flags & TARGET_SA_RESETHAND) {\n\n            sa->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n    }\n\n    if (q != &k->info)\n\n        free_sigqueue(cpu_env, q);\n\n}\n", "idx": 9650, "substitutes": {"cpu_env": ["cpu___en", "cpu___conn", "cpu_vm", "cpuacstate", "cpupyenv", "cpu_conn", "pu_vm", "cpu_en", "pu_server", "pu_env", "pu_en", "cpuacconn", "cpu___env", "cpuacen", "cpuacserver", "pu_conn", " cpu_state", "cpu_server", "cpupyvm", " cpu_en", "cpu___server", "cpu_state", "cpuacenv", "cpupyen"], "sig": ["getsIG", "dsature", "getsature", "atsig", "sign", "unsature", "sIG", "jsig", "jseg", "jsIG", "Sign", "asif", "Sick", "insigma", "csIG", "sick", "fsig", "nigma", "sif", "opensif", "atsigen", "Sigh", "isign", "ssigh", " sigen", "vick", "fsigma", "unsiger", "atsiger", "getsig", "vig", "ssign", " sigma", "nigs", "sature", "vsigma", "unsigma", "unsig", "isig", "dsIG", "alsigen", "ssigma", "esig", "Sag", "gesiger", " sigs", "SIG", "esigma", "Sigen", "sec", "insiger", "lsig", "alsig", "jsec", "sigs", "ssIG", "unsigen", "gesig", "fsIG", "dsign", "asig", "seg", "vsign", "alsiger", "asigen", "siger", "csign", "lsif", "jsigen", "ssigs", "Sig", "vsigh", "sigma", " sature", "ssag", "gesag", "nig", "gesigen", "jsigma", "Sif", "jsick", "nIG", "insigh", "sseg", " siger", "insature", "vigma", "design", "isIG", "opensigo", "vigen", "asigo", "vsiger", " sag", "desIG", "insig", "sigh", "insigen", " sign", "dsigma", "asIG", "unsIG", " sIG", "insIG", "csig", "Sature", "opensig", "asick", "Sigma", "ssig", "esature", "lsigen", "vsigen", "csigen", "asigma", "vsig", "desig", "lsIG", "unsigs", "alsIG", "isigh", "vsick", "ssec", "opensigma", "dsig", "Sigs", "desiger", "fsigen", "esigen", " sif", "atsag", "sigen", "insign", "sigo", "unsign", "dsigen", " sigo", "sag", "getsiger"], "cpu": ["ck", "aco", "net", "pc", "tp", "gpu", "mx", "socket", "thread", "processor", "ct", "nu", "proc", "p", "pool", "cp", "pu", "frame", "linux", "process", "np", "tc", "cs", "ka", "mu", "core", "CPU", "us", "boot", "t", "ctx", "conn", "gc", "os", "c", "cn", "hw", "cu", "onet", "mac", "phys", "vm", "pid", "sys"], "handler": ["command", " value", "format", "lr", "or", "older", "func", "package", "storage", " h", " handlers", "cmd", "controller", "Handler", "hi", " handle", "then", "size", "folder", "key", "callback", "hand", "message", " signal", "hd", "loop", "server", "when", "magic", "test", "node", "interface", "rule", "driver", "high", " Handler", "policy", "hander", "processor", "err", "behavior", "profile", "hash", "error", "worker", "timeout", " hand", "handled", "function", "index", "connection", "mode", "direction", "sh", "mid", "style", "sche", "lambda", "priority", "wrapper", " hook", "here", "event", "manager", " sched", "LER", "te", "handle", "holder", " error", "ler", "h", " err", "usage", "trap"], "set": ["sche", "clear", "reset", "sync", "apply", "map", "SET", "et", "read", "add", "ch", "base", "match", "Set", "sub", "hash", "sm", "m", "save", "parse", "mod", "en", "handle", "index", "root", "ctx", "new", "check", "sets", "gen", "ha", "cast", "change", "lock", "sh", "target", "start", "st", "stat", "sc", "mut", "get", "name", "loc", "size", "store"], "old_set": ["old_Set", " old_SET", "old_SET", " old_Set", "old_gen", " old_gen"], "target_old_set": ["target_old_SET", "target_OLD_SET", "target_OLD_Set", "target_old_Set", "target_OLD_set"], "sa": ["sche", "ba", "ami", "la", "na", "ai", "ja", "al", "a", "va", "aos", "ao", "Sa", "as", "sg", "au", "ray", "da", "am", "act", "ama", "sam", "auth", "ia", "ka", "pa", "session", "so", "SA", "storage", "wa", "ta", "asi", "ga", "ma", "se", "ais", "sha", "ssl", "ha", "aw", "cache", "sb", "sw", "sh", "asa", "acs", "sta", "si", "sc", "apa", "ain", "s", "aa", "ua", "sd", "za", "ca", "sama"], "q": ["sq", "ck", "eq", "u", "qq", "qs", "ch", "Q", "iq", "p", "o", "seq", "f", "d", "ok", "g", "l", "qv", "i", "qa", "queue", "r", "qt", "j", "dq", "y", "t", "ctx", "qu", "v", "ql", "que", "qi", "b", "c", "query", "kw", "w", "er", "requ", "z", "s", "ek", "aq", "ue"], "ts": ["ms", "tm", "tops", "ports", "tt", "vs", "tr", "tx", "tp", "ats", "pt", "tk", "hs", "gs", "TS", "sts", "Ts", "ps", "nt", "cs", "tc", "te", "bs", "uts", "ta", "als", "t", "tl", "tn", "ops", "wcs", "tis", "times", "ns", "acs", "tur", "fs", "ks", "vals", "ls", "tz", "ds", "mt"], "k": ["kr", "key", "ck", "ko", "pc", "ch", "kick", "K", "tk", "ak", "wk", "ack", "p", "ku", "ok", "th", "pkg", "tc", "ki", "i", "ka", "unk", "j", "kl", "n", "t", "ikk", "ctx", "v", "ik", "mk", "uk", "c", "ke", "kh", "kw", "ks", "z", "km", "ek", "kj", "sk", "kk"]}}
{"project": "qemu", "commit_id": "d659d94013390238961fac741572306c95496bf5", "target": 1, "func": "static void pcie_pci_bridge_write_config(PCIDevice *d,\n\n        uint32_t address, uint32_t val, int len)\n\n{\n\n    pci_bridge_write_config(d, address, val, len);\n\n    msi_write_config(d, address, val, len);\n\n    shpc_cap_write_config(d, address, val, len);\n\n}\n", "idx": 9651, "substitutes": {"d": ["dos", "dd", "fd", "send", "q", "p", "dev", "ind", "ld", "da", "dc", "dx", "del", "l", "pd", "dis", "dn", "D", "details", "md", "r", "de", "data", "done", "dq", "ad", "t", "new", "v", "e", "b", "c", "di", "dat", "w", "bd", "db", "dict", "dm", "dh", "debug", "sd", "draw", "ds", "dr", "out"], "address": ["command", "id", "each", "prefix", "add", "Address", "message", "at", "order", "device", "route", "build", "event", "range", "point", "act", "location", "block", "service", "gate", "inter", "ptr", "position", "port", "i", "trace", "handle", "addr", "reference", "index", "attribute", "chain", "create", "interface", "ad", "execute", "shape", "ace", "host", "eth", "alias", "link", "description", "offset", "length", "store"], "val": [" bin", "lit", "tx", "lib", "al", "sl", " arg", "sol", " value", "loc", "valid", "VAL", "value", "var", "buf", "bl", "dev", "resp", "fail", "ival", "abl", "vec", "grad", "ref", "Val", "vt", "util", "cal", "eval", "ctx", "v", " v", "pl", "pol", "bal", "sel", "serv", "vals", "item", "msg", "el", "aval", "vc", "vol", "ret"], "len": ["fin", "lit", "num", "lib", "syn", "nl", "fl", "lan", "mat", "Len", "den", "compl", "seq", "nt", "size", "l", "pos", "fun", "lf", "ann", "bytes", "en", "alt", "mem", "ln", "rel", "level", "kl", "n", "coll", "count", " l", "fac", "elt", "fil", "ls", "el", "ll", "offset", "length", "vol", " length", "ret"]}}
{"project": "qemu", "commit_id": "62be4e3a5041e84304aa23637da623a205c53ecc", "target": 0, "func": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n\n\n    if (QTAILQ_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset = end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n\n\n    if (offset == RAM_ADDR_MAX) {\n\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n\n                (uint64_t)size);\n\n        abort();\n\n    }\n\n\n\n    return offset;\n\n}\n", "idx": 9670, "substitutes": {"size": ["shift", "len", "empty", "small", "send", "address", " count", "sum", "buffer", "code", "message", "padding", "news", "range", "area", "sent", "Size", "SIZE", "capacity", "limit", "dimension", "type", "position", "length", "window", "ize", "bytes", "mem", "storage", "index", "total", "node", "n", "now", "body", "global", "count", "zone", "shape", "from", "scale", "sn", "start", "fee", "si", "space", "z", "set", "ze", "s", "time", "memory", "max", "name", "offset", "state", "number"], "block": ["tx", "sync", "address", "map", "record", "part", "buffer", "prefix", "blocks", "join", "base", "device", "image", "event", "list", "cl", "bl", "hash", "point", "bin", "frame", "ip", "label", "object", "def", "zero", "type", "word", "all", "mem", "bit", "Block", "chain", "row", "snap", "node", "box", "header", "bus", "check", "line", "b", "lock", "load", "start", "piece", "link", "batch", "space", "group", "pack", "BL", "byte", "length"], "next_block": ["prev_lock", "entry_blocking", "next_piece", "next_lock", "next_byte", "next_object", " next_line", "next_blocking", "prev_block", " next_image", "entry_Block", "next_bl", "next_Block", " next_byte", "next_line", "prev_bl", "next_tx", " next_object", "entry_piece", "entry_block", "prev_tx", "next_image"], "end": ["len", "obj", "next", "id", "off", "send", "entry", "eff", "add", "back", "order", "event", "enable", "enc", "ff", "wind", "begin", "ment", "END", "dev", "point", "ex", "ind", "ne", "End", "pad", "eng", "name", "stop", "pos", "limit", "after", "ended", "en", "pend", "edge", "term", "ord", "all", "index", "ext", "east", "bound", "n", "last", "se", "entity", "ending", "e", "env", "ed", "append", "ension", "eu", "est", "start", "hend", "st", "ent", "z", "set", "head", "max", "nd", "ender", "offset", "length", "out", "ue"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n", "idx": 9683, "substitutes": {"chr": [" chres", "echrb", "chsr", " chrc", " chdr", "achsr", "chedr", " chrs", "echres", "echdr", "anchrs", "Chrs", "Char", "schrc", "schr", "chdr", "chrs", "Chbar", "cheres", "achrc", "chbar", "chrc", "Chr", "chrb", "anchbar", "cher", "chres", "anchar", " chrb", "achar", "schar", "echr", "cherb", "anchr", " chbar", "achr", "schsr", " chsr"]}}
{"project": "qemu", "commit_id": "fdaef06917100d97782df550c1807a1da054e27e", "target": 0, "func": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int buflen = 0;\n\n    int ret;\n\n\n\n    switch (req->cmd.buf[0]) {\n\n    case TEST_UNIT_READY:\n\n        if (!bdrv_is_inserted(s->bs))\n\n            goto not_ready;\n\n        break;\n\n    case REQUEST_SENSE:\n\n        if (req->cmd.xfer < 4)\n\n            goto illegal_request;\n\n        buflen = scsi_device_get_sense(&s->qdev, outbuf, req->cmd.xfer,\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        break;\n\n    case INQUIRY:\n\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case MODE_SENSE:\n\n    case MODE_SENSE_10:\n\n        buflen = scsi_disk_emulate_mode_sense(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case READ_TOC:\n\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n\n        if (buflen < 0)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RESERVE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE:\n\n        if (req->cmd.buf[1] & 1)\n\n            goto illegal_request;\n\n        break;\n\n    case RELEASE_10:\n\n        if (req->cmd.buf[1] & 3)\n\n            goto illegal_request;\n\n        break;\n\n    case START_STOP:\n\n        if (s->qdev.type == TYPE_ROM && (req->cmd.buf[4] & 2)) {\n\n            /* load/eject medium */\n\n            bdrv_eject(s->bs, !(req->cmd.buf[4] & 1));\n\n        }\n\n        break;\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n        bdrv_set_locked(s->bs, req->cmd.buf[4] & 1);\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        /* The normal LEN field for this command is zero.  */\n\n        memset(outbuf, 0, 8);\n\n        bdrv_get_geometry(s->bs, &nb_sectors);\n\n        if (!nb_sectors)\n\n            goto not_ready;\n\n        nb_sectors /= s->cluster_size;\n\n        /* Returned value is the address of the last sector.  */\n\n        nb_sectors--;\n\n        /* Remember the new size for read/write sanity checking. */\n\n        s->max_lba = nb_sectors;\n\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n\n        if (nb_sectors > UINT32_MAX)\n\n            nb_sectors = UINT32_MAX;\n\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n\n        outbuf[3] = nb_sectors & 0xff;\n\n        outbuf[4] = 0;\n\n        outbuf[5] = 0;\n\n        outbuf[6] = s->cluster_size * 2;\n\n        outbuf[7] = 0;\n\n        buflen = 8;\n\n        break;\n\n    case SYNCHRONIZE_CACHE:\n\n        ret = bdrv_flush(s->bs);\n\n        if (ret < 0) {\n\n            if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_FLUSH)) {\n\n                return -1;\n\n            }\n\n        }\n\n        break;\n\n    case GET_CONFIGURATION:\n\n        memset(outbuf, 0, 8);\n\n        /* ??? This should probably return much more information.  For now\n\n           just return the basic header indicating the CD-ROM profile.  */\n\n        outbuf[7] = 8; // CD-ROM\n\n        buflen = 8;\n\n        break;\n\n    case SERVICE_ACTION_IN:\n\n        /* Service Action In subcommands. */\n\n        if ((req->cmd.buf[1] & 31) == 0x10) {\n\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n\n            memset(outbuf, 0, req->cmd.xfer);\n\n            bdrv_get_geometry(s->bs, &nb_sectors);\n\n            if (!nb_sectors)\n\n                goto not_ready;\n\n            nb_sectors /= s->cluster_size;\n\n            /* Returned value is the address of the last sector.  */\n\n            nb_sectors--;\n\n            /* Remember the new size for read/write sanity checking. */\n\n            s->max_lba = nb_sectors;\n\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->cluster_size * 2;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case REPORT_LUNS:\n\n        if (req->cmd.xfer < 16)\n\n            goto illegal_request;\n\n        memset(outbuf, 0, 16);\n\n        outbuf[3] = 8;\n\n        buflen = 16;\n\n        break;\n\n    case VERIFY_10:\n\n        break;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    return buflen;\n\n\n\nnot_ready:\n\n    if (!bdrv_is_inserted(s->bs)) {\n\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n    } else {\n\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n    }\n\n    return -1;\n\n\n\nillegal_request:\n\n    scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    return -1;\n\n}\n", "idx": 9706, "substitutes": {"r": ["kr", "hr", "rb", "q", "rs", "err", "or", "rec", "p", "rf", "ry", "d", "rw", "m", "i", "mr", "rr", "rg", "rc", "rd", "v", "e", "b", "c", "rt", "re", "sr", "w", "res", "er", "requ", "vr", "R", "cr"], "outbuf": ["OUTbuff", " outprop", "inbuffer", " outvec", "offbr", "offbag", "outbag", "OUTvec", "upbuf", "Outbuf", "upcmd", "outputbuf", "outputbuffer", "outprop", " outbuff", "inbuff", "outcmd", "taskbuf", "outputbag", "Outvec", "infb", "outputbr", "inbuf", "outfb", "inprop", "outputbuff", "taskfb", "upbag", "OUTbuf", "outbuffer", "offbuf", "taskbuff", "offbuffer", "outbuff", "taskbuffer", " outbr", " outcmd", "Outbuff", "upbuffer", "outvec", " outfb", "outbr", "outputcmd", "outputprop", " outbag", " outbuffer"], "req": ["rpm", "prefix", "mm", "pp", "alloc", "range", "proc", "rec", "attr", "desc", "progress", "rr", "qt", "http", "needed", "rem", "rd", "fr", "pr", "cmd", "sr", "org", "comm", "pro", "tx", "rb", "init", "buf", " res", "ind", "jp", "gz", "request", "urg", "usr", "rel", "dq", " cir", "aux", "conn", "conf", "rh", "comp", "debug", "required", "sq", " q", "crit", "rs", "err", "compl", "tek", "resp", "nt", "gr", "ref", "raw", "term", "mem", "rx", "perm", "ctx", "reg", "good", "exec", "rss", "quest", "eq", "qq", "q", "p", "dev", "seq", "pkg", "wx", "ext", "inv", "expr", "md", "j", "esp", "ctr", "query", "res", "stat", "requ", "msg"], "s": ["sq", "vs", "spec", "sl", "sol", "ats", "rs", "hs", "sp", "p", "gs", "sts", "ps", "g", "cs", "m", "ies", "sv", "es", "sam", "ses", "bs", "so", "is", "ys", "js", "S", "ss", "ts", "n", "y", "its", "t", "os", "sb", "b", "sw", "c", "h", "ns", "str", "fs", "serv", "st", "sc", "set", "sis", "ls", "space", "ds", "sys"], "nb_sectors": ["nb_belements", "nb_becs", "nb_velements", "nb_vecs", "nb_lecs", "nb_beves", "nb_selements", "nb_lelements", "nb_leves", "nb_veves", "nb_vectors", "nb_secs", "nb_seves", "nb_bectors", "nb_lectors"], "ret": [" RET", "net", "et", "flag", "RET", "resp", "nt", "def", "alt", "mem", "final", "rem", "val", "Ret", " resp", "sel", "re", "res", "result", "set", "ll", "Return", "out", "sys"]}}
{"project": "qemu", "commit_id": "376692b9dc6f02303ee07a4146d08d8727d79c0c", "target": 0, "func": "static void flush_queued_work(CPUState *cpu)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (cpu->queued_work_first == NULL) {\n\n        return;\n\n    }\n\n\n\n    while ((wi = cpu->queued_work_first)) {\n\n        cpu->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n        if (wi->free) {\n\n            g_free(wi);\n\n        }\n\n    }\n\n    cpu->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9707, "substitutes": {"cpu": ["bench", "aco", "cum", "net", "pc", "cmp", "gpu", "tp", "prof", "rpm", "hog", "computer", "runner", "processor", "sync", "device", "cam", "alloc", "nz", "proc", "java", "p", "cp", "pu", "linux", "ram", "cil", "program", "jp", "process", "np", "cs", "pkg", "ruby", "parse", " CPU", "mu", "core", "CPU", "clock", "pai", "cli", "boot", "phy", "aux", "px", "conn", "ork", "gc", "os", "apache", "c", "library", "hw", "nc", "pause", "cu", "kernel", "php", "phys", "aq", "hz", "sys"], "wi": ["wei", "isi", "fi", "hirt", "wife", "ei", "wal", "wk", "wy", "wit", "Wi", "we", "wm", "wid", "mie", "igi", "ui", "ni", "rw", "wr", "wx", "ki", "ye", "wiki", "ti", "pai", "mi", "innie", "wa", "WI", "wl", "iu", "wen", "feat", "xi", "hei", "qi", "ushi", "rus", "wp", "hip", "wine", "gi", "wic", "bi", "cgi", "wig", "lis", "hus", "yu", "hi", "dit", "xe", "yi", "esi", "hog", "pie", "wu"]}}
{"project": "qemu", "commit_id": "e568f9df086965813a318ff0558782ba90e59c33", "target": 0, "func": "static int validate_guest_space(unsigned long guest_base,\n\n                                unsigned long guest_size)\n\n{\n\n    unsigned long real_start, test_page_addr;\n\n\n\n    /* We need to check that we can force a fault on access to the\n\n     * commpage at 0xffff0fxx\n\n     */\n\n    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);\n\n\n\n    /* If the commpage lies within the already allocated guest space,\n\n     * then there is no way we can allocate it.\n\n     */\n\n    if (test_page_addr >= guest_base\n\n        && test_page_addr <= (guest_base + guest_size)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Note it needs to be writeable to let us initialise it */\n\n    real_start = (unsigned long)\n\n                 mmap((void *)test_page_addr, qemu_host_page_size,\n\n                     PROT_READ | PROT_WRITE,\n\n                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n    /* If we can't map it then try another address */\n\n    if (real_start == -1ul) {\n\n        return 0;\n\n    }\n\n\n\n    if (real_start != test_page_addr) {\n\n        /* OS didn't put the page where we asked - unmap and reject */\n\n        munmap((void *)real_start, qemu_host_page_size);\n\n        return 0;\n\n    }\n\n\n\n    /* Leave the page mapped\n\n     * Populate it (mmap should have left it all 0'd)\n\n     */\n\n\n\n    /* Kernel helper versions */\n\n    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));\n\n\n\n    /* Now it's populated make it RO */\n\n    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {\n\n        perror(\"Protecting guest commpage\");\n\n        exit(-1);\n\n    }\n\n\n\n    return 1; /* All good */\n\n}\n", "idx": 9709, "substitutes": {"guest_base": ["guest_based", "guess_size", "guest0start", "guest0buffer", "guess_buffer", "guest_area", "guests_Base", "guester_space", "guesteringbase", "guestingid", "guess_len", "guest0size", "guester_id", "guest_prefix", "guest_buffer", "guesteringprefix", "guester_prefix", "guest_space", "guest_id", "guess0buffer", "guestingspace", "guests_base", "guest2start", "guest_len", "guest_name", "guess_based", "guesteringid", "guess0base", "guestingprefix", "guess_area", "guester_base", "guess_base", "guest2base", "guess0size", "guest2size", "guests_name", "guest_Base", "guesteringspace", "guess_start", "guest2buffer", "guess0start", "guest_start", "guest0base", "guestingbase"], "guest_size": ["guest_length", "guest_space", "guEST_count", "guEST_size", "guest_count", "guess_size", "guess_length", "guEST_SIZE", "guest_SIZE", "guEST_space", "guest_sum", "guess_sum"], "real_start": ["absolute_start", "realityopen", "real_Start", "realityint", "absoluteityopen", " real_end", "real___index", "Real_start", "absolute_open", "real_type", "Real_end", "real_data", "real_open", "real_stop", "absoluteitymatch", "real___int", "realitymatch", "real_st", " real_st", "real_index", "realitytype", "realitylast", "absoluteitystart", "real_match", "realityindex", "real___type", "Real_data", "Real_Start", "absoluteitylast", "real_int", " real_int", "absolute_match", " real_stop", "absolute_last", "real_last", " real_type", " real_index", "realitystart", "real_end", "real___start"], "test_page_addr": ["test_page2start", "test_page_start", "test_page__address", "test_page_block", "test_port_addr", "test_row_addr", "test_page2address", "test_page_res", "test_page__ptr", "test_pagelyaddress", "test_row_ptr", "test_port_start", "test_page_attr", "test_page__addr", "test_pageekaddr", "test_page_ptr", "test_page2addr", "test_row_address", "test_port_address", "test_pagelyend", "test_page_end", "test_pageekaddress", "test_page_address", "test_row_res", "test_row_block", "test_pageekblock", "test_pagelyaddr"]}}
{"project": "qemu", "commit_id": "f5f601afcec6c1081128fe5a0f831788ca9f56ed", "target": 1, "func": "long do_sigreturn(CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\ttarget_sigset_t target_set;\n\n\tsigset_t set;\n\n\tint i;\n\n\n\n\tframe_addr = env->regs[R_SP];\n\n\t/* Make sure the guest isn't playing games.  */\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n\t\tgoto badframe;\n\n\n\n\t/* Restore blocked signals */\n\n\tif (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n\t\tgoto badframe;\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\ttarget_to_host_sigset_internal(&set, &target_set);\n\n        do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n\trestore_sigcontext(&frame->sc, env);\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[10];\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 9721, "substitutes": {"env": ["obj", "vs", "eq", "entry", "buffer", "code", "rb", "eh", "here", "err", "end", "enc", "ev", "erd", "uv", "ec", "buf", "dev", "enter", "open", "scope", "vp", "pkg", "hl", "ptr", "cb", "stack", "window", "en", "txt", "addr", "server", "queue", "ew", "vm", "esc", "ctx", "conn", "v", "self", "environment", "ten", "e", "h", "hw", "w", "er", "context", "db", "cv", "exc", "nv", "state", "viron"], "frame": ["rame", "doc", "next", "reset", "send", "fi", "call", "frames", "code", "channel", "base", "feature", "image", "hide", "init", "event", "step", "role", "range", "proc", "file", "profile", "point", "f", "cf", "scope", "push", "block", "fram", "process", "ref", "face", "def", "sequence", "flow", "trace", "stack", "window", "term", "ce", "function", "package", "chain", "row", "version", "header", " Frame", "connection", "t", "ctx", "Frame", "zone", "info", "fr", "feat", "line", "ace", "close", "lock", "scene", "cmd", "framework", "load", "fc", "link", "context", "tick", "module", "draw", "state", "style"], "frame_addr": ["frame2id", "frame_nr", "component_ord", "frame__nr", "component_ptr", " frame_id", "frame9addr", "component9arm", "frame_ptr", "frame_ord", " frame_nr", "frameingptr", "frame2ptr", " frame_address", "component9addr", "frame9ptr", "frame_address", "frame2addr", "component_addr", "frame_arm", "frame2address", "frameingaddr", "frame_adr", "frameingoa", "frame__addr", "component9ord", "frame__id", "component_oa", "frame_id", "frame__ptr", "component_arm", "frame_oa", "frame9arm", "frame9ord", "component9ptr", " frame_ptr", "frameingadr", "component_adr"], "target_set": ["target_sets", "targetTheset", "target2base", "target_tree", "target_se", "target2sets", "current_sets", " target_se", "current_base", "target_base", "current_set", "current2tree", "targetingsubject", "source_session", "Target_Set", "current2sets", "targetvalbase", "current2base", "targetetset", "targetingsc", "targetetsc", "Target_sc", "target_type", "targetThetree", "targetvalset", "target_Set", "targetThebase", "source_group", " target_type", "target_sc", "target2set", "targetingSet", "source_set", "current_tree", "targetingset", "target_subject", "target_session", "Target_subject", "target_group", "targetetSet", "targetvaltree", "targetetsubject", "target2tree", "current2set", "Target_set", "targetThesets", "targetvalsets"], "set": ["sche", "clear", "san", "op", "spec", "reset", "id", "map", "SET", "et", "add", "flag", "section", "lang", "format", "settings", "sign", "match", "ch", "setting", "step", "export", "cut", "Set", "hash", "error", "open", "scope", "g", "local", "parse", "util", "session", "mod", "mask", "en", "ext", "package", "script", "global", "se", "new", "check", "sets", "gen", "arg", "cast", "wrap", "setup", "sh", "st", "sc", "equal", "result", "get", "group", "msg", "store"], "i": ["ms", " m", "u", "ai", "fi", "I", "me", "li", "uri", "q", " I", "p", "o", "sim", " k", "ind", "ui", "ip", "g", "m", "l", "ki", "ti", "ic", "mu", "cli", " ti", "mi", "index", "is", "in", "j", " x", "ix", "im", "n", "y", "t", "ci", "\u0438", "zi", "v", " v", "phi", "xi", "multi", "qi", "e", "gi", "di", "bi", "pi", "si", "it", "x", "z", "ini", " ii", " bi", "oi", "hi", "ims", " j", "ii"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_interrupt_packet(void *priv, uint32_t id,\n\n    struct usb_redir_interrupt_packet_header *interrupt_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = interrupt_packet->endpoint;\n\n\n\n    DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\",\n\n            interrupt_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n\n        ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n\n            DPRINTF(\"received int packet while not started ep %02X\\n\", ep);\n\n            free(data);\n\n            return;\n\n        }\n\n\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);\n\n    } else {\n\n        int len = interrupt_packet->length;\n\n\n\n        AsyncURB *aurb = async_find(dev, id);\n\n        if (!aurb) {\n\n            return;\n\n        }\n\n\n\n        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {\n\n            ERROR(\"return int packet mismatch, please report this!\\n\");\n\n            len = USB_RET_NAK;\n\n        }\n\n\n\n        if (aurb->packet) {\n\n            aurb->packet->len = usbredir_handle_status(dev,\n\n                                               interrupt_packet->status, len);\n\n            usb_packet_complete(&dev->dev, aurb->packet);\n\n        }\n\n        async_free(dev, aurb);\n\n    }\n\n}\n", "idx": 9722, "substitutes": {"priv": ["tr", "Priv", "path", "deb", "ev", "proc", "prop", "pad", "pkg", "attr", "ptr", "auth", "pri", "vt", "pub", "mem", "conn", "rc", "conf", "info", "DEV", "pr", "riv", "env", "serv", "pi", "phys", "org", "private", "disabled", "iv", "access", "pro"], "id": ["key", "Id", "status", "path", "end", "event", "p", "uid", "ident", "sp", "wid", "kid", "size", " pid", "ip", "oid", "ref", "type", "i", "ep", "addr", "ID", "sid", "ids", "ad", " rid", "info", " fid", "iden", "mid", "h", "eth", "str", "start", "tag", "vid", " tid", "aid", "ide", "name", "pid", "rid"], "interrupt_packet": ["interruptingpet", "interrupt_octer", "interrupt_payET", "interrupt_parseet", "interrupt_octetter", "interrupt_packingoint", "interruptingpickacket", "interrupt_packageant", "interruptingpkt", "interrupt_signett", "interrupt_paykt", "interrupt_packingET", "interrupt_packingacket", "interrupt_preskt", "interrupt_picket", "interrupt_packageett", "interrupt_signET", "interruptingpackET", "interrupt_picker", "interrupt_packetter", "interrupt_acketter", "interrupt_presET", "interrupt_parseetter", "interrupt_pET", "interrupt_preset", "interrupt_signetter", "interrupt_packets", "interrupt_linkET", "interrupt_presacket", "interrupt_ackacket", "interruptingpicker", "interrupt_packageacket", "interrupt_pickacket", "interrupt_packET", "interrupt_packkt", "interrupt_octett", "interrupt_pet", "interrupt_packinget", "interrupt_signacket", "interrupt_packser", "interrupt_packset", "interrupt_signer", "interrupt_octet", "interrupt_parseeter", "interrupt_signet", "interrupt_presoint", "interrupt_checket", "interrupt_octET", "interrupt_packageets", "interrupt_packett", "interrupt_packsett", "interrupt_packageET", "interrupt_pickett", "interrupt_packacket", "interrupt_packsetter", "interruptingpacket", "interrupt_signets", "interruptingpET", "interruptingpackett", "interrupt_parseacket", "interrupt_packer", "interrupt_acketer", "interrupt_packant", "interrupt_pkt", "interruptingpickett", "interrupt_packeter", "interruptingpackacket", "interrupt_checkET", "interrupt_acket", "interrupt_octacket", "interrupt_linketter", "interrupt_packsoint", "interrupt_packageetter", "interrupt_payet", "interrupt_linker", "interruptingpacker", "interrupt_packoint", "interrupt_checkant", "interrupt_presant", "interruptingpicket", "interrupt_checkoint", "interrupt_octets", "interrupt_linket", "interrupt_payacket", "interrupt_packsET", "interrupt_packageet", "interruptingpackkt", "interrupt_packsacket", "interrupt_signeter", "interrupt_signoint", "interrupt_packageoint"], "data": ["len", "obj", "Data", "empty", "off", "tx", "extra", "map", "buffer", "text", "device", "end", "rec", "p", "sp", "buf", "resp", "bin", "form", "pad", "nt", "trans", "d", "pos", "ata", "def", "length", "raw", "window", "bytes", "mu", "all", "mem", "rel", "snap", "n", "ad", "dl", "t", "new", "bus", "dat", "str", "w", "rew", "res", "table", "DATA", "size", "out"], "data_len": ["data2length", "data36lang", "byte_Len", "len2length", "data_Len", "byte_lim", "data_fil", "len_len", "len2len", "len_length", "data_lang", "data_length", "len2lang", "data36Len", "data36len", " data_Len", "data_lim", "data2len", "byte_pos", "data2lang", "len2Len", "len_lang", "len_Len", "data2Len", "data_lon", " data_fil", "data36length", "byte_len", "data_pos", " data_lon"], "dev": ["ow", "doc", "obj", "tr", "av", "pt", "prom", "device", "api", "cam", "go", "ev", "den", "proc", "home", " Dev", "p", "ve", "var", "adv", "pad", "nt", "d", "pkg", "block", "def", "local", "ptr", "serial", "desc", "ver", "window", "pub", "server", "mem", "md", "test", "ctx", "conn", "DEV", "v", "wd", "conf", "env", "tech", "val", "Dev", "des", "hw", "w", "school", "er", "serv", "pi", "link", "db", "debug", "app", "access", "sd", "pro", "sys"], "aurb": ["urchB", "averbar", "aurbody", "aursb", "arB", "thuru", "aurbe", "aurbar", "augbd", "ravl", "averxb", "thurl", "thurr", "ard", "averbc", "urchsb", "urb", "urchbd", "arb", "urchrb", "thurb", "auru", "afferbe", "urdcb", "aurr", "aurv", "urchu", "urdrb", "averb", "urdr", "urdbd", "urchbe", "urd", "afferv", "averv", "urchr", "averl", "urchv", "aurbase", "augcb", "aurbs", "aucb", "ravbc", "urbe", "averbe", "ravb", "averbase", "urchxb", "urchba", "afferxb", "urerb", "urchd", "urchcb", "urerbd", "aurrb", "arbe", "thurbody", "aurbd", "urchbase", "urchbs", "urdbs", "urdbc", "aurd", "aurbc", "urerbody", "urchbody", "urB", "urdl", "aurB", "urerl", "aurxb", "thurbd", "ravbar", "augb", "averba", "urdb", "aucba", "thurbs", "aurcb", "urchl", "aversb", "urdbar", "augrb", "urchb", "aucsb", "aucbase", "afferb", "aurl", "aurba", "urdu"]}}
{"project": "FFmpeg", "commit_id": "461cd5bfb5c38e48a81b4a9a5912dfd65da1ba3d", "target": 0, "func": "void mpeg1_encode_mb(MpegEncContext *s,\n\n                     DCTELEM block[6][64],\n\n                     int motion_x, int motion_y)\n\n{\n\n    int i, cbp;\n\n    const int mb_x = s->mb_x;\n\n    const int mb_y = s->mb_y;\n\n    const int first_mb= mb_x == s->resync_mb_x && mb_y == s->resync_mb_y;\n\n\n\n    /* compute cbp */\n\n    cbp = 0;\n\n    for(i=0;i<6;i++) {\n\n        if (s->block_last_index[i] >= 0)\n\n            cbp |= 1 << (5 - i);\n\n    }\n\n    \n\n    if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || (mb_y != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && \n\n        ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && (motion_x | motion_y) == 0) ||\n\n        (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) |\n\n        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {\n\n        s->mb_skip_run++;\n\n        s->qscale -= s->dquant;\n\n        s->skip_count++;\n\n        s->misc_bits++;\n\n        s->last_bits++;\n\n        if(s->pict_type == P_TYPE){\n\n            s->last_mv[0][1][0]= s->last_mv[0][0][0]= \n\n            s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0;\n\n        }\n\n    } else {\n\n        if(first_mb){\n\n            assert(s->mb_skip_run == 0);\n\n            encode_mb_skip_run(s, s->mb_x);\n\n        }else{\n\n            encode_mb_skip_run(s, s->mb_skip_run);\n\n        }\n\n        \n\n        if (s->pict_type == I_TYPE) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 2, 1, 0, 0); /* macroblock_type : macroblock_quant = 1 */\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 1, 1, 0, 0); /* macroblock_type : macroblock_quant = 0 */\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n        } else if (s->mb_intra) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 6, 0x01, 0, 0);\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 5, 0x03, 0, 0);\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n            memset(s->last_mv, 0, sizeof(s->last_mv));\n\n        } else if (s->pict_type == P_TYPE) { \n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp != 0) {\n\n                    if ((motion_x|motion_y) == 0) {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 1, 0, 0); /* macroblock_pattern & quant */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 2, 1, 0, 0); /* macroblock_pattern only */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                    } else {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 2, 1, 0); /* motion + cbp */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 1, 1, 1, 0); /* motion + cbp */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                        mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                        mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                        s->mv_bits+= get_bits_diff(s);\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->misc_bits+= get_bits_diff(s);\n\n                    mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                    mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                    s->qscale -= s->dquant;\n\n                    s->mv_bits+= get_bits_diff(s);\n\n                }\n\n                s->last_mv[0][1][0]= s->last_mv[0][0][0]= motion_x;\n\n                s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y;\n\n            }else{\n\n                assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD);\n\n\n\n                if (cbp) {\n\n                    if(s->dquant){\n\n                        put_mb_modes(s, 5, 2, 1, 1); /* motion + cbp */\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    }else{\n\n                        put_mb_modes(s, 1, 1, 1, 1); /* motion + cbp */\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits+= get_bits_diff(s);\n\n                for(i=0; i<2; i++){\n\n                    put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                    s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                    s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                }\n\n                s->mv_bits+= get_bits_diff(s);\n\n            }\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n            s->f_count++;\n\n        } else{  \n\n            static const int mb_type_len[4]={0,3,4,2}; //bak,for,bi\n\n\n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 0);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); \n\n                    mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); \n\n                    s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0];\n\n                    s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1];\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); \n\n                    mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); \n\n                    s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0];\n\n                    s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1];\n\n                    s->b_count++;\n\n                }\n\n            }else{\n\n                assert(s->mv_type == MV_TYPE_FIELD);\n\n                assert(!s->frame_pred_frame_dct);\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 1);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                        s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                        s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                    }\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[1][i]);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][0] -  s->last_mv[1][i][0]    , s->b_code);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code);\n\n                        s->last_mv[1][i][0]=   s->mv[1][i][0];\n\n                        s->last_mv[1][i][1]= 2*s->mv[1][i][1];\n\n                    }\n\n                    s->b_count++;\n\n                }\n\n            }\n\n            s->mv_bits += get_bits_diff(s);\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n        }\n\n        for(i=0;i<6;i++) {\n\n            if (cbp & (1 << (5 - i))) {\n\n                mpeg1_encode_block(s, block[i], i);\n\n            }\n\n        }\n\n        s->mb_skip_run = 0;\n\n        if(s->mb_intra)\n\n            s->i_tex_bits+= get_bits_diff(s);\n\n        else\n\n            s->p_tex_bits+= get_bits_diff(s);\n\n    }\n\n}\n", "idx": 9727, "substitutes": {"s": ["ms", "events", "vs", "ats", "hs", "cs", "m", "bits", "ins", "details", "se", "sports", "mys", "os", "times", "w", "comm", "ims", "ares", "ar", "eds", "gets", "settings", "tests", "gs", "sts", "ex", "changes", "g", "ies", "sv", "args", "ses", "xs", "bs", "plays", "less", "js", "als", "ss", "conf", "sets", "ops", "ads", "e", "sb", "z", "ls", "app", "states", "sq", "ges", "aunts", "qs", "rs", "as", "ants", "l", "es", "terms", "ts", "n", "sw", "ns", "tes", "ds", "comments", "eps", "p", "ps", "ains", "us", "aws", "is", "pers", "S", "its", "v", "https", "c", "bis", "acs", "stats", "fs", "sys", "parts"], "block": ["obj", " bl", "map", "record", "config", "buffer", "blocks", "base", "image", "p", "bl", "frame", "ram", "media", "m", "ref", "type", "bm", "window", "Block", "OCK", "data", "view", " b", "info", "b", "lock", "size"], "motion_x": ["motion_yx", "ori67x", "motion_ix", "motion___xc", "mission___id", "ori67yx", "motion67ix", "motion___ox", "mission___ox", "ori_X", "motion12yx", "motion_X", "motion___id", "motion67yx", "motion_id", "mission_xc", "ori67X", "motion12ix", "mission___xc", "mission_ox", "motion67X", "motion_ox", "motion___x", "motion12X", "ori67ix", "mission_x", "ori_x", "mission___x", "motion12x", "motion08xc", "mission_id", "motion08ox", "motion67x", "motion_xc", "motion08x", "ori_ix", "motion08id", "ori_yx"], "motion_y": [" motion2Y", "motion67Y", "motion_yl", "motion_h", "motion___lon", "motion2yl", "motion67y", " motion_cy", " motion2y", "motion___yl", "movie___lon", "motion_cy", "motion_Y", "movie___y", "movie_h", "motion2Y", "motion______h", "motion_lon", "movie_lon", "movie___h", "motion2cy", "movie_yl", " motion2cy", " motion2yl", "motion67yl", " motion_yl", " motion_Y", "motion______yl", "motion______y", "motion2y", "movie_y", "motion______lon", "motion67cy", "motion___y", "motion___h", "movie___yl"], "i": ["ai", "fi", "I", "at", "me", "li", "init", " I", "iq", "list", "p", "o", "sim", "f", "ind", "ui", "ip", "m", "ti", "ic", "ish", "in", " ti", "mi", "index", "is", "us", "j", "im", "ix", "series", "ski", "y", "n", "iu", "ci", "\u0438", "zi", "v", "info", "multi", "qi", "e", "c", "bis", "gi", "bi", "di", "pi", "si", "it", "x", "batch", "ini", " ii", " bi", "oi", "conv", " j", "ii"], "cbp": ["callbackp", "nbp", "rbpp", "callbackpc", "bcv", "kbp", "cbpp", "cvv", "cvpa", "cbphp", "kbpc", "bcpb", "cfpc", "erbpp", "callbackpp", "cvpc", "cvpp", "rbps", "cbpa", "cvp", "cvcp", "sbps", "cbpb", "cfpp", "bccp", "kbpn", "cfphp", "erbphp", "cfpn", "cfps", "bcp", "cvpb", "cfp", "cbcp", "sbp", "kbps", "sbpc", "rbp", "rbphp", "cfpa", "nbcp", "erbps", "erbp", "cbps", "cbv", "nbpb", "cbpn", "sbpn", "nbv", "callbackpa", "cbpc"], "mb_skip_run": ["mb_miss_run", "mb_skip__out", "mb_miss_runs", "mb_skip__skip", "mb_skip_runs", "mb_miss_out", "mb_miss_skip", "mb_skip_skip", "mb_skip_out", "mb_skip__runs", "mb_skip__run"], "skip_count": ["passseqprogress", "skip_bits", "passseqsteps", "passseqcount", "passseqbits", "pass_bits", "skipseqprogress", "skipseqbits", "pass_progress", "pass_count", "pass_steps", "skipseqcount", "skip_steps", "skipseqsteps", "skip_progress"], "misc_bits": ["first_parts", "first_bits", "first_bit", "static_bit", "static_bits", "static_parts"], "last_bits": ["next___bits", "last___bytes", "next_bits", "last_bit", "next_bytes", "next___bit", "last_bytes", "last_fps", "last___bits", "last___fps", "next___fps", "last___bit", "next___bytes", "next_bit", "next_fps"]}}
{"project": "qemu", "commit_id": "fb846a094fdee7bb6a88b48aeed0d97a8080a20d", "target": 0, "func": "static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)\n\n{\n\n    unsigned int cssid = 0;\n\n    unsigned int ssid = 0;\n\n    unsigned int schid;\n\n    unsigned int devno;\n\n    bool have_devno = false;\n\n    bool found = false;\n\n    SubchDev *sch;\n\n    int num;\n\n    DeviceState *parent = DEVICE(dev);\n\n    Error *err = NULL;\n\n    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);\n\n    VirtIODevice *vdev;\n\n\n\n    sch = g_malloc0(sizeof(SubchDev));\n\n\n\n    sch->driver_data = dev;\n\n    dev->sch = sch;\n\n\n\n    dev->indicators = NULL;\n\n\n\n    /* Initialize subchannel structure. */\n\n    sch->channel_prog = 0x0;\n\n    sch->last_cmd_valid = false;\n\n    sch->thinint_active = false;\n\n    /*\n\n     * Use a device number if provided. Otherwise, fall back to subchannel\n\n     * number.\n\n     */\n\n    if (dev->bus_id) {\n\n        num = sscanf(dev->bus_id, \"%x.%x.%04x\", &cssid, &ssid, &devno);\n\n        if (num == 3) {\n\n            if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) {\n\n                error_setg(errp, \"Invalid cssid or ssid: cssid %x, ssid %x\",\n\n                           cssid, ssid);\n\n                goto out_err;\n\n            }\n\n            /* Enforce use of virtual cssid. */\n\n            if (cssid != VIRTUAL_CSSID) {\n\n                error_setg(errp, \"cssid %x not valid for virtio devices\",\n\n                           cssid);\n\n                goto out_err;\n\n            }\n\n            if (css_devno_used(cssid, ssid, devno)) {\n\n                error_setg(errp, \"Device %x.%x.%04x already exists\",\n\n                           cssid, ssid, devno);\n\n                goto out_err;\n\n            }\n\n            sch->cssid = cssid;\n\n            sch->ssid = ssid;\n\n            sch->devno = devno;\n\n            have_devno = true;\n\n        } else {\n\n            error_setg(errp, \"Malformed devno parameter '%s'\", dev->bus_id);\n\n            goto out_err;\n\n        }\n\n    }\n\n\n\n    /* Find the next free id. */\n\n    if (have_devno) {\n\n        for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n            if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                sch->schid = schid;\n\n                css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                found = true;\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"No free subchannel found for %x.%x.%04x\",\n\n                       cssid, ssid, devno);\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"user-configured\");\n\n    } else {\n\n        cssid = VIRTUAL_CSSID;\n\n        for (ssid = 0; ssid <= MAX_SSID; ssid++) {\n\n            for (schid = 0; schid <= MAX_SCHID; schid++) {\n\n                if (!css_find_subch(1, cssid, ssid, schid)) {\n\n                    sch->cssid = cssid;\n\n                    sch->ssid = ssid;\n\n                    sch->schid = schid;\n\n                    devno = schid;\n\n                    /*\n\n                     * If the devno is already taken, look further in this\n\n                     * subchannel set.\n\n                     */\n\n                    while (css_devno_used(cssid, ssid, devno)) {\n\n                        if (devno == MAX_SCHID) {\n\n                            devno = 0;\n\n                        } else if (devno == schid - 1) {\n\n                            error_setg(errp, \"No free devno found\");\n\n                            goto out_err;\n\n                        } else {\n\n                            devno++;\n\n                        }\n\n                    }\n\n                    sch->devno = devno;\n\n                    css_subch_assign(cssid, ssid, schid, devno, sch);\n\n                    found = true;\n\n                    break;\n\n                }\n\n            }\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"Virtual channel subsystem is full!\");\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"auto-configured\");\n\n    }\n\n\n\n    /* Build initial schib. */\n\n    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);\n\n\n\n    sch->ccw_cb = virtio_ccw_cb;\n\n\n\n    /* Build senseid data. */\n\n    memset(&sch->id, 0, sizeof(SenseId));\n\n    sch->id.reserved = 0xff;\n\n    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;\n\n\n\n    if (k->realize) {\n\n        k->realize(dev, &err);\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        css_subch_assign(cssid, ssid, schid, devno, NULL);\n\n        goto out_err;\n\n    }\n\n\n\n    /* device_id is only set after vdev has been realized */\n\n    vdev = virtio_ccw_get_vdev(sch);\n\n    sch->id.cu_model = vdev->device_id;\n\n\n\n    /* Only the first 32 feature bits are used. */\n\n    dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                         dev->host_features[0]);\n\n\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          parent->hotplugged, 1);\n\n    return;\n\n\n\nout_err:\n\n    dev->sch = NULL;\n\n    g_free(sch);\n\n}\n", "idx": 9744, "substitutes": {"dev": ["ow", "doc", "priv", "cam", "nav", "d", "desc", "data", "scan", "wd", "os", "env", "cmd", "w", "serv", "sd", "pro", "vol", "dd", "av", "ve", "buf", "dis", "ver", "server", "test", "dem", "conn", "conf", "Dev", "des", "driver", "att", "dm", "app", "obj", "ch", "pt", "device", "go", "ev", "den", "form", "var", "nt", "grad", "def", "local", "raw", "mem", "ad", "ctx", "info", "die", "sw", "exec", "hw", "db", "iv", "ds", "out", "det", "p", "adv", "normal", "port", "md", "de", "DEV", "v", "val", "h", "disk"], "errp": [" errpp", "erbpad", "terpp", "arrp", "rarpun", "ererp", "errpad", "rerP", "errpe", " errpa", " errpoint", "errpb", "eorP", "eorp", "eorpad", "ererpe", "erbpun", "errpp", "errpun", "derpb", "terp", "rarphp", "rerpb", "erbphp", "terpoint", " errpb", "ererpp", "errpoint", " errpad", "eorpoint", " errP", "erbp", "derp", "rerp", "eorphp", "ierP", "rarp", "derP", "errP", "errpa", "rerpa", "ierpoint", "ierpp", "errphp", "derpa", "derpoint", "terP", "eorpun", "rarpad", "derpad", "arrpe", "ierp", "arrpp", " errpe"], "schid": ["chtype", "krId", "schpid", "scoid", "chin", "sstype", "sk_", "khid", "khids", "scID", "schmid", " schin", "skId", "skbid", "krid", "ssaid", "scid", "scpid", "skyin", "schnew", "khnew", "skoid", "schtype", " schmid", "chanid", "kh_", "schbid", "skaid", "schids", "chanident", "khkey", " schkey", "schdef", " schId", "schide", "ssno", "ssoid", "scheid", "kraid", "chId", "khident", "skyid", "kride", "chident", "ssin", "krin", "chanId", "skdef", "khID", "skybid", "ssId", " schids", "chid", " schpid", "chanID", "kroid", "sh_", "schno", "scin", "schId", "skyide", "khdef", "khmid", "sktype", "krbid", "chanpid", "shnew", "skide", "schaid", " schID", "skid", "skin", "sch_", "skno", "shdef", "schin", "schident", "scheids", "chanoid", "khId", "schekey", "schkey", "chno", "schemid", "chID", "sknew", "schID", "scId", " schoid", "schoid"], "devno": [" devo", "diffNo", " devyes", " devnos", "devNo", "testno", "divyes", "evno", "devicenos", "divnum", "divn", "Devnum", "evyes", "devn", "evNo", " devn", "divni", "deviceNo", "devyes", "divNo", "evnum", "diffni", "evnos", " devNo", "devo", "testNo", "diffo", "DevNo", "evni", "devnum", "devni", "evo", "divno", "diffno", "Devno", "testnos", "evn", "devnos", "deviceno", "divo", "testn"], "sch": ["sche", "kr", "ksh", "Ch", "usb", "sym", "mot", "ah", "gh", "sl", "sky", "ssh", "priv", "cmp", "ch", "sol", "sum", "hess", "channel", "chan", "go", "chn", "css", "sg", "hs", "sp", "ach", "sm", "ich", "sim", "sec", "gr", "th", "shop", "scope", "cs", "Sch", "osc", "arch", "cht", "gross", "chain", "isch", "ss", "mc", "ssl", "conn", "conf", "zh", "cfg", "https", "rh", "hed", "chip", "mk", "sw", "sh", "kh", "sy", "cms", "school", "serv", "sc", "disc", "chu", "rss", "cr", "soc", "hz", "sd", "sk"], "num": [" NUM", "len", " remain", "off", "typ", "con", "nm", "cum", "sum", "add", "mult", "end", "go", "non", "nam", "Num", "lam", " number", "m", "um", "zero", "ver", "en", "ord", "cal", "index", "ta", "snap", "n", "final", "t", "rem", "count", "old", "good", "mon", "dim", "un", "alph", "tim", "nom", "NUM", "ul", "coord", "comm", "msg", "no", "max", "number"], "parent": ["obj", "spec", "id", "cmp", "child", "pool", "task", "Parent", "cp", "ram", "instance", "parents", "g", "pos", "def", "attr", "chain", "data", "root", "self", "conf", "cfg", "shape", "cmd", "master", "name", "pid", "params"], "err": ["arr", "kr", "obj", "cmp", "Error", "ch", "req", "ev", "proc", "ec", "resp", "buf", "error", "attr", "rr", "usr", "Er", "conf", "cfg", "pr", "eas", "cmd", "er", "msg", "cr", "exc"], "k": ["kr", "key", "ck", "sky", "K", "tk", "kt", "p", "kid", "ok", "pkg", "m", "kind", "ka", "j", "n", "v", "ik", "mk", "c", "kh", "kw", "ks", "kernel", "ek", "kit", "sk", "kk"], "vdev": ["Vdevice", "vdef", "vdevice", " vdef", "svdef", "Vdev", " vdevice", "Vdef", "svdevice", "svdev"], "ssid": ["sspid", "sside", "ssy", "cssest", "rssids", "snpid", "rsspid", "csside", "essids", "rssoid", "csida", "ssie", "csshide", "esside", "snide", "statside", "cside", "skit", "csie", "hesshide", "rssit", "rssy", "ssit", "hessd", "ksid", "rssidy", "hessidy", "kspart", "ssoid", "rssida", "statsid", "cssd", "ksoid", "yssoid", "yssid", "wside", "ssidy", "hessify", "wsids", "ssin", "rssolid", "rsspart", "wsie", "wsest", "csids", "sspart", "cssidy", "ssest", "essin", "rssid", "wsd", "csmid", "ssolid", "csin", "csit", "statshide", "essid", "hessid", "rssd", "wsmid", "cssids", "ssida", "ssify", "ysspart", "hesside", "wsid", "cssin", "skide", "ysside", "cssid", "skid", "hessida", "snid", "statsida", "cssie", "ssids", "cssmid", "rssest", "sshide", "ssd", "ssmid", "cssify", "csolid", "skolid", "snida", "cssida", "csify", "kside", "csid", "cspid", "hessmid", "rsside", "cssy", "wsy"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_registers(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 9754, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tunsigned i;\n\n#ifdef HAVE_MMX\n\n\tlong mmx_size= 23 - src_size;\n\n\tasm volatile (\n\n\t\t\"test %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\"jns 2f\t\t\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24r)\", %%mm5\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24g)\", %%mm6\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24b)\", %%mm7\t\\n\\t\"\n\n\t\tASMALIGN(4)\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\tPREFETCH\" 32(%1, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq  2(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // R BGR BGR B\n\n\t\t\"psllq $16, %%mm0\t\t\\n\\t\" // 00 BGR BGR\n\n\t\t\"pand %%mm5, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq  6(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\tMOVNTQ\" %%mm1,   (%2, %%\"REG_a\")\\n\\t\" // RGB RGB RG\n\n\t\t\"movq  8(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // R BGR BGR B\n\n\t\t\"movq 10(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // GR BGR BGR\n\n\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq 14(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // R BGR BGR B\n\n\t\tMOVNTQ\" %%mm1,  8(%2, %%\"REG_a\")\\n\\t\" // B RGB RGB R\n\n\t\t\"movq 16(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // GR BGR BGR\n\n\t\t\"movq 18(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // BGR BGR BG\n\n\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\tMOVNTQ\" %%mm1, 16(%2, %%\"REG_a\")\\n\\t\"\n\n\t\t\"add $24, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t: \"+a\" (mmx_size)\n\n\t\t: \"r\" (src-mmx_size), \"r\"(dst-mmx_size)\n\n\t);\n\n\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n\n\n\tif(mmx_size==23) return; //finihsed, was multiple of 8\n\n\n\n\tsrc+= src_size;\n\n\tdst+= src_size;\n\n\tsrc_size= 23-mmx_size;\n\n\tsrc-= src_size;\n\n\tdst-= src_size;\n\n#endif\n\n\tfor(i=0; i<src_size; i+=3)\n\n\t{\n\n\t\tregister uint8_t x;\n\n\t\tx          = src[i + 2];\n\n\t\tdst[i + 1] = src[i + 1];\n\n\t\tdst[i + 2] = src[i + 0];\n\n\t\tdst[i + 0] = x;\n\n\t}\n\n}\n", "idx": 9761, "substitutes": {"src": ["obs", "sq", "tr", "imp", "lit", "lib", "syn", "sl", "usc", "sync", "source", "secure", "std", "rs", "proc", "sub", "sts", "seq", "cc", "ind", "RC", "iter", "rob", "sec", "cur", "ins", "ptr", "desc", "supp", "bs", "urg", "usr", "earth", "addr", "in", "txt", "ser", "rl", "cont", "rx", "dest", "scan", "rc", "sort", "sur", "input", "sb", "ctr", "sw", "sh", "tmp", "comp", "sn", "rt", "str", "sr", "dist", "sel", "st", "sc", "fc", "img", "s", "iv", "loc", "inst", "ux", "sys"], "dst": ["dnd", "nst", " dsp", "fsts", " dint", "drc", "func", "dsp", "Dbl", "fdest", "nsp", "Dx", "Ddest", "dint", "jst", "sst", "dput", "scp", "sput", "Dcp", "dsst", " dput", "jx", "lnd", "ndest", "dcp", "dset", " dcp", "new", "Dset", " dset", " ddest", "lsts", "nset", "obj", "fnd", "Dst", "Drc", "dbl", "ddest", "dx", "def", " dbl", "_", " dnd", "Dnd", "dsset", "Dint", "dsts", "ncp", " dsts", " dx", "fst", "nput", "ldest", "lst", "dsrc", " drc", "dsbl", "jint", "jnd", "ssp"], "src_size": ["st_Size", "src_Size", "rc_offset", "src_SIZE", "src2SIZE", "src_mode", "src2size", "src_shape", "src_length", "src2len", "rc_scale", " src_shape", "rc_len", "src_offset", "rc_size", "src_time", "src_len", "src2length", "rc_set", "rc_SIZE", "sr_length", " src_SIZE", "st_len", "sr_size", "sr_no", " src_mode", "st_ize", "src_set", "rc_space", "st_size", "src_space", "src2space", "rc_time", "src_no", "src_scale", "rc_length", "src_ize"], "i": [" m", "o", "m", " pi", "im", "y", "t", "ci", "zi", " mi", "gi", "pi", "slice", "key", "depth", "ami", "status", "I", "at", "li", "init", "ind", "ti", " ti", "mi", "try", " pos", "ix", "ma", " l", "xi", "e", "multi", "qi", " index", "si", "batch", "id", "ai", "ei", " k", "ui", "ip", "ic", "in", "index", "chain", "\u0438", "info", " p", "er", "it", "ini", " bi", "ii", "me", "q", " I", "list", " e", "sim", "this", "cli", "is", "j", "iu", "v", "c", "di", "bi", " err", " ii", " j", "ij"], "memory": ["command", "Memory", "vector", "address", "record", "buffer", "javascript", "message", "integer", "pointer", "write", "region", "variable", "media", "location", "sequence", "random", "reference", "mem", "storage", "attribute", "function", "directory", "metadata", "gc", "mouse", "library", "information", "disk", "module", "history", "statement", "binary"], "x": ["xp", "xy", "tx", "u", "mx", "p", " dx", "ex", "ox", "dx", "xc", "g", "m", "wx", "X", " ex", "r", "rx", "ix", "y", "px", "v", " tx", " X", "xi", "e", " ax", "xt", "c", "xx", "zx", "w", "z", "fx", " err", " y", " xx", "xe", " xp", "ux", "xf"]}}
{"project": "FFmpeg", "commit_id": "ffd7fd79441f97f1edb25181af0603ff6ea9b342", "target": 1, "func": "static int vda_h264_end_frame(AVCodecContext *avctx)\n{\n    H264Context *h                      = avctx->priv_data;\n    struct vda_context *vda_ctx         = avctx->hwaccel_context;\n    AVFrame *frame                      = &h->cur_pic_ptr->f;\n    struct vda_buffer *context;\n    AVBufferRef *buffer;\n    int status;\n    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)\n    status = vda_sync_decode(vda_ctx);\n    frame->data[3] = (void*)vda_ctx->cv_buffer;\n    if (status)\n        av_log(avctx, AV_LOG_ERROR, \"Failed to decode frame (%d)\\n\", status);", "idx": 9772, "substitutes": {"avctx": ["Avcontext", "avedyl", "AVcc", "cvkw", " avcontext", "avkb", "avekb", "avdyl", "aftx", "AVcmp", "avecontext", "afctx", "AVtx", " avcc", "Avcmp", "afdyl", "AVctx", "AVcontext", "avcontext", "Avctx", " avkw", "Avcc", "cvctx", "avercontext", " avdyl", "averkw", " avcmp", "cvcontext", "avectx", "avkw", "cvtx", "AVkb", "averctx", "afcontext", "avcmp", "avertx", "avtx", " avkb", " avtx", "avcc", "avetx"], "h": ["he", "ph", "hm", "ah", "eh", "here", "ht", "hs", "p", "hash", "f", "m", "l", "hd", "hl", "ptr", "oh", "hp", "r", "t", "ctx", "v", "host", "b", "c", "sh", "bh", "hw", "w", "ih", "help", "hum", "hi", "history", "H"], "vda_ctx": ["vdainghistory", "vda__tx", "vda2context", "vta_msg", "vda_jp", "vda____tx", "vda2tx", "vda_history", "vda2ctx", "vda_tz", "vta_tx", "vta_history", "vda____nt", "vDA_tx", "vda2txt", "vda_nt", "vDA_nt", "vDA_ctx", "vta_jp", "vda_context", "vda_txt", "vda____ns", "vda_tx", "vda_cfg", "vta_context", "vta_tz", "vta_cmp", "vta_txt", "vda__tz", "vDA_ns", "vdaingtx", "vda_cmp", "vda____ctx", "vdaingjp", "vta_ctx", "vda_ns", "vdaingctx", "vta_cfg", "vda_msg", "vda__ctx", "vda__cfg"], "frame": ["zo", "command", "entry", "board", "call", "frames", "message", "channel", "base", "image", "event", "file", "profile", "point", "f", "component", "object", "def", "sequence", " df", "request", "window", "ce", "r", "row", " fr", "data", "version", "header", "one", "Frame", "info", "fr", "feat", "line", "e", "ence", "result", "response", "state"], "context": ["command", "tx", "map", "config", "text", "message", "channel", "path", "format", "document", "event", "history", "Context", "window", "filter", "reference", "index", "header", "connection", "ctx", "metadata", "cache", "shape", "c", "content", "template"], "buffer": ["command", "map", "source", "message", "channel", "uf", "document", "stream", "profile", "buf", "Buffer", "ref", "window", "filter", "reference", "queue", "data", "header", "view", "v", "cache", "b", "batch", "buff", "cv", "length"], "status": ["ms", "atus", "success", "spec", "id", "sync", "comments", "negative", "code", "flag", "prefix", "message", "summary", "ping", "err", "valid", "compl", "Status", "iso", "error", "reason", "ex", "score", "g", "US", "sex", "args", "i", "progress", "yes", "wait", "details", "pres", "ss", "uses", "ssl", "check", "esp", "gc", "e", "sw", "str", "stats", "flags", " Status", "res", "stat", "sc", "result", "usage", "msg", "s", "states", "state"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data,\n\n                        int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    Picture *out;\n\n    int i, out_idx;\n\n    int ret;\n\n\n\n    h->flags  = avctx->flags;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\n    if (buf_size == 0) {\n\n out:\n\n\n\n        h->cur_pic_ptr = NULL;\n\n        h->first_field = 0;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f.key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            out->reference &= ~DELAYED_PIC_REF;\n\n            ret = output_frame(h, pict, &out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n\n        int cnt= buf[5]&0x1f;\n\n        const uint8_t *p= buf+6;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n        cnt = *(p++);\n\n        if(!cnt)\n\n            goto not_extra;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n\n\n        return ff_h264_decode_extradata(h, buf, buf_size);\n\n    }\n\nnot_extra:\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n\n    if (buf_index < 0)\n\n        return -1;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        av_assert0(buf_index <= buf_size);\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n\n            return buf_size;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        field_end(h, 0);\n\n\n\n        /* Wait for second field. */\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n\n            ret = output_frame(h, pict, &h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n            if (CONFIG_MPEGVIDEO) {\n\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n\n                                    &h->low_delay,\n\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n\n            }\n\n        }\n\n    }\n\n\n\n    assert(pict->data[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 9781, "substitutes": {"avctx": [" avcp", "navcontext", " avcv", "navjac", " avcontext", "apjac", "avconn", "navcmp", "avertc", "avecontext", "avercmp", "avcp", "navctx", "apcmp", "avcontext", "auxcp", " avtc", "avercontext", "avtc", "avercv", "auxcontext", "aptc", "aveconn", "avectx", "avcv", "auxconn", " avconn", "navcv", "averctx", "auxctx", "avcmp", "navtc", "avecp", "averjac", "avjac", "apctx"], "data": ["doc", "obj", "Data", "empty", "next", "id", "buffer", "text", "message", "pointer", "a", "device", "image", "padding", "read", "to", "area", "picture", "value", "form", "bin", "frame", "pad", "first", "into", "d", "media", "block", "images", "ata", "def", "zero", "length", "raw", "window", "bytes", "mu", "package", "video", "content", "snap", "rel", "t", "ctx", "action", "input", "dat", "start", "res", "table", "batch", "DATA", "name", "img", "size"], "got_frame": ["got_state", "got_frames", "got_channel", "kept_frames", "received_error", "received__state", "received__sequence", "got__error", "got_error", "received__frame", "kept_point", "received_frame", "got__state", "kept_channel", "received__error", "got_sequence", "received_sequence", "kept_frame", "got__frame", "received_state", "got_point", "got__sequence"], "avpkt": ["afpkg", "avcpkt", "avpacket", "avnpkt", "avnpacket", "avepkg", "avpskg", "avpskat", "afpkt", "afcpdu", "avpingct", "avnpdat", "avPkat", "avcpdat", "avPkt", "avepskg", "avdptxt", "avprekg", "afpacket", "avpdu", "afcpkg", "avpskt", "avpingkg", "avcpkg", "avepkat", "avpretxt", "avcpacket", "afpdat", "avdpacket", "avptxt", "afcpkt", "avpreacket", "afcpacket", "avcpdu", "avdpdu", "avnpdu", "avpdat", "avpct", "avepskt", "avcptxt", "avepkt", "avpsct", "avdpdat", "avdpkg", "avpingkat", "avdpkt", "avpkat", "avepskat", "avepsct", "afptxt", "avPct", "avepct", "avPkg", "avpkg", "afcptxt", "afcpdat", "afpdu", "avpingkt", "avprekt"], "buf": ["doc", "cam", "alloc", "uv", "pg", "Buffer", "cat", "block", "desc", "queue", "cap", "deg", "BU", "b", "used", "cmd", "str", "w", "font", "cv", "conv", "size", "read", "uf", "rb", "ff", "bl", "bc", "ptr", "txt", "emb", "count", "cast", "dat", "Buff", "batch", "pack", "img", "nm", "xff", "buffer", "mat", "bp", "err", "enc", "words", "vec", "late", "pos", "ref", "fb", "def", "raw", "mem", "n", "ctx", "good", "fac", "tmp", "db", "len", "empty", "off", "packed", "aka", "begin", "pool", "seq", "bin", "pad", "pkg", "cb", "port", "bytes", "br", "pb", "box", "rc", "v", "cache", "ctr", "c", "buff", "msg"], "h": ["hal", "he", "H", "ah", "hm", "ph", "gh", "ch", "hook", "q", "eh", "here", "go", "HH", "k", "hs", "hash", "o", "f", "th", "g", "m", "l", "hd", "hl", "oh", "hh", "hold", "handle", "hp", "http", "j", "n", "y", "t", "ctx", "phi", "v", "self", "uh", "ha", "zh", "rh", "cache", "host", "b", "c", "sh", "bh", "kh", "hw", "w", "ih", "his", "comm", "hi", "dh", "history", "high", "hz", "ht"], "pict": ["doc", "png", "oin", "obj", "pic", "Pic", "pas", "fi", "avi", "uf", "image", "fig", "cam", "ct", "picture", "kt", "fp", "act", "vp", "np", "capt", "txt", "Pict", "pres", "fn", "phy", "photo", "ctx", "feat", " picture", "fat", "ot", " pic", "piece", "phys", "buff", "Picture", "img", "ht"], "out": ["doc", "op", "u", "chan", "end", "cam", "o", "OUT", "again", "t", "check", "b", "cmd", "ot", "w", "serv", "ent", "opt", "result", "conv", "ht", "output", "status", "at", "aos", "init", "ex", "g", "jp", "note", "outs", "null", "after", "ou", "new", "conn", "one", "conf", "no", "img", "obj", "png", "pic", "pas", "net", "ch", "image", "up", "err", "f", "timeout", "in", "n", "ctx", "tmp", "copy", "comment", "can", "by", "it", "empty", "off", "to", "Out", "j", "v", "cfg", "cache", "c", "res", "full", "set", "co", "msg"], "i": ["span", "m", "them", "im", "ski", "y", "ci", "zi", "gi", "cgi", "iy", "pi", "oi", "hi", "ji", "ims", "tim", "ami", "status", "record", "I", "li", "uri", "init", "ri", "ind", "g", "ki", "ti", "mi", "try", "ix", "xi", "multi", "qi", "si", "batch", "ori", "id", "ai", "ei", "vi", "go", "k", "point", "ui", "ip", "l", "my", "ic", "in", "index", "chain", "n", "mc", "\u0438", "phi", "info", "gu", "remote", "it", "ini", "ii", "fi", "me", "io", "q", "list", "sim", "cli", "is", "j", "series", "iu", "v", "di", "bi", "x", " ii", "ij"], "out_idx": ["out_Idx", "out_idey", "out_Idix", "out_index", "out_Idn", "out_midz", "out_prxs", "out_Idy", "out_midx", "out_idn", "out_midxs", "out_idix", "out_Idxs", "out_Idex", "out_idez", "out_idy", "out_prx", "out_ndx", "out_idex", "out_idxs", "out_idct", "out_prct", "out_midct", "out_prz", "out_idz", "out_Idz", "out_indy", "out_indn", "out_ndz", "out_ideex", "out_ndxs", "out_ndix", "out_indx"], "ret": ["arr", "tf", "tt", "len", "tr", "net", "status", "back", "flag", "format", "print", "nz", "RET", "resp", "value", "ry", "nt", "cat", "rev", " Ret", "Return", "fun", "pret", "def", "usr", "txt", "alt", "mem", "ext", "r", "cont", "try", "j", "t", "rem", "rets", "v", "deg", "arg", "gc", "val", "Ret", "tmp", "cmd", "rt", "re", "elt", "str", "res", "it", "result", "gt", "msg", "ll", "ft", "mt"], "p": ["page", "pic", "pc", "tp", "pat", "part", "a", "par", "pp", "pt", "q", "ping", "bp", "per", "sp", "f", "cp", "ps", "pg", "d", "g", "pkg", "m", "pos", "ap", "jp", "l", "vp", "np", "lp", "r", "j", "n", "pb", "y", "t", "P", "v", "pr", "b", "c", "wp", "pre", "dp", "x", "pro", "pid", "pa"], "cnt": ["nnt", "count_", " count", " counter", "ncnt", "counter", "ncnd", "cnd", "ccount", "nNT", "Ccount", "account", "Cnt", "nounter", "nnd", "cNT", "acnt", "Count", "n_", "count", " cnd", " cNT", "acount", "c_", " c_", "ncNT", "CNT", "acNT", " ccount", "ncounter"]}}
{"project": "qemu", "commit_id": "e853ea1cc68716c3d9c22d04578020c6dd743306", "target": 1, "func": "GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)\n\n{\n\n    GIOStatus status = G_IO_STATUS_NORMAL;\n\n    size_t count;\n\n\n\n    while (size) {\n\n        status = ga_channel_write(c, buf, size, &count);\n\n        if (status == G_IO_STATUS_NORMAL) {\n\n            size -= count;\n\n            buf += count;\n\n        } else if (status != G_IO_STATUS_AGAIN) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return status;\n\n}\n", "idx": 9787, "substitutes": {"c": ["con", "a", "ch", "channel", "cor", "k", "p", "f", "cp", "cf", "d", "dc", "cat", "g", "l", "cs", "cb", "cc", "ce", "r", "cont", "t", "ac", "v", "lc", "e", "b", "com", "w", "cm", "etc", "cu", "fc", "sc", "comm", "C", "cr"], "buf": ["len", "shift", "mb", "buffer", "uf", "aka", "rb", "q", "end", "p", "seq", "bin", "iter", "bc", "Buffer", "block", "vec", "cur", "pos", "ref", "cb", "tab", "raw", "window", "bytes", "length", "addr", "queue", "data", "br", "pb", "box", "cap", "t", "new", "v", "b", "ctr", "tmp", "cmd", "w", "Buff", "batch", "nb", "buff", "coord", "msg", "bar", "cv", "bag", "wb"], "size": ["len", "empty", "small", "use", "status", "send", "sum", "read", "code", "message", "buffer", "complete", "valid", "sp", "sent", "height", "Size", "SIZE", "capacity", "g", "pos", "type", "zero", "null", "args", "length", "required", "ize", "all", "index", "chain", "data", "total", "needed", "done", "global", "n", "body", "ctx", "zone", "shape", "present", "scale", "any", "sn", "offset", "start", "w", "fee", "sc", "equal", "z", "speed", "set", "see", "time", "max", "name", "space", "state", "out", "number"], "count": ["empty", "num", "id", "expected", "status", "sum", "read", "code", "flag", "add", "base", "buffer", "at", "err", "ct", "counter", "created", "ind", "nt", "th", "type", "zero", "ptr", "length", "cc", "ize", "all", "index", "try", "amount", "cont", "data", "total", "needed", "n", "test", "t", "now", "Count", "check", "ctx", "info", "gc", "cache", "ctr", "found", "comment", "cmd", "temp", "stat", "z", "result", "set", "max", "state", "number"]}}
{"project": "FFmpeg", "commit_id": "22ecfcd4c79cdf812fdf406525ddf0fd1f7114e4", "target": 1, "func": "static int channelmap_query_formats(AVFilterContext *ctx)\n\n{\n\n    ChannelMapContext *s = ctx->priv;\n\n\n\n    ff_set_common_formats(ctx, ff_planar_sample_fmts());\n\n    ff_set_common_samplerates(ctx, ff_all_samplerates());\n\n    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);\n\n    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);\n\n\n\n    return 0;\n\n}\n", "idx": 9789, "substitutes": {"ctx": ["jac", "ck", "kg", "xp", "tx", "pc", "cmp", "std", "crit", "req", "cam", "go", "ct", "k", "hs", "kt", "cl", "p", "gs", "cp", "nt", "xc", "bc", "act", "jp", "tc", "pkg", "wx", "np", "gz", "ctl", "xs", "ic", "cc", "ia", "window", "aus", "jj", "qt", "mem", "kl", "fn", "dl", "mc", "cas", "lc", "cfg", "wcs", "gc", "c", "anc", "cmd", "setup", "kb", "kh", "ns", "hw", "nc", "cm", "kw", "cu", "sc", "context", "comm", "cv", "km", "history", "loc", "kj", "ca"], "s": ["sq", "sl", "ats", "settings", "rs", "sg", "p", "gs", "hs", "sp", "ps", "ess", "g", "cs", "sv", "es", "scl", "bs", "is", "js", "S", "ss", "ts", "its", "ssl", "sets", "os", "sb", "b", "c", "sn", "ns", "fs", "actions", "set", "ls", "ds", "sys"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n", "idx": 9805, "substitutes": {"env": ["era", "esi", "vs", "ah", "extra", "gear", "tp", "pe", "et", "config", "code", "policy", "ei", "rb", "eh", "end", "here", "manager", "erd", "ev", "enc", "ov", "uv", "ec", "ve", "buf", "dev", "eni", "enter", "engine", "eng", "vp", "gate", "te", "sv", "Environment", "desc", "cb", "vt", "window", "en", "txt", "shell", "addr", "server", "equ", "ew", "ext", "expr", "esc", "conn", "forge", "v", "environment", "ten", "e", "eas", "exec", "eu", "elt", "nc", "oe", "er", "estate", "org", "bar", "vr", "console", "nv", "nw", "viron"], "wi": ["wei", "isi", "fi", "qq", "wife", "ei", "wal", "wk", "wy", "wit", "wik", "Wi", "we", "wm", "wid", "mie", "ui", "ni", "rw", "wx", "ye", "wiki", "ti", "pai", "mi", "innie", "wa", "WI", "wl", "iu", "wen", "phi", "feat", "xi", "wcs", "qi", "ushi", "hip", "wp", "rus", "dim", "wine", "gi", "wic", "bi", "wig", "lis", "hus", "hi", "dit", "yi", "fif", "esi", "hog", "pie", "wu"]}}
{"project": "qemu", "commit_id": "477830727821e4bc337f4ac1fd222ffe0b900e1a", "target": 0, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, bool create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -errno;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret < 0) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    socket_set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, s);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return 0;\n\n}\n", "idx": 9817, "substitutes": {"s": ["sq", "spec", "sync", "sl", "qs", "a", "socket", "rs", "hs", "sp", "p", "gs", "sts", "f", "o", "ps", "sub", "ex", "g", "cs", "m", "sv", "i", "ses", "conv", "es", "scl", "bs", "so", "r", "is", "js", "http", "S", "ss", "ts", "se", "n", "less", "j", "t", "sports", "ssl", "v", "conf", "self", "os", "sb", "b", "e", "ims", "c", "sw", "h", "ns", "stats", "w", "fs", "serv", "st", "er", "comm", "set", "ls", "sd", "syn", "ds", "soc", "sys", "store"], "aio_req": ["aio2requ", "aio_res", "aio_comp", "aio_cmd", "aive_requ", "aIO_request", "aioorequ", "aio___requ", "aio_rec", "aie_obj", "aie_urg", "aive_err", "aio____err", "aiooreq", "aio___request", "aie_err", "aive_cmd", "aio_seq", "aio2err", "aio_grab", "aio_urg", "aio____rec", "aio___urg", "aio___rec", "aio_requ", "aioocrit", "aio_crit", "aIO_grab", "aio_obj", "aIO_req", "aio_err", "aio2req", "aioores", "aio___err", "aio_rr", "aie_rec", "aIO_requ", "aioptrequ", "aio____req", "aive_req", "aio_request", "aio___rr", "aioptcmd", "aioptreq", "aio___req", "aie_req", "aio2comp", "aio___seq", "aiopterr", "aio____urg", "aie_res", "aio___comp"], "iov": ["icon", "ucc", "ef", "xff", "ilo", "io", "uf", "ovi", "iq", "ov", "uv", "ival", "vec", "isco", "oo", "version", "wo", "uart", "wcs", "nc", "ih", "river", "iv", "vr", "cv", "conv", "ux", "uns"], "niov": ["nuov", "iiov", "iiovi", "nuob", "iiob", "tiom", "iiom", "tiovi", "niob", "nuom", "nuovi", "niovi", "tiob", "tiov", "niom"], "create": ["clear", "Create", "ready", "drop", "send", "use", "add", "write", "code", "update", "build", "created", "enable", "complete", "destroy", "insert", "delete", "open", "ulate", "late", "ite", "save", "ure", "creat", "ize", "ce", "activate", "new", "one", "execute", "check", "change", "close", "raise", "copy", "cre", "make", "force", "ify", "creation", "equal", "only", "see", "creator", "ise"], "aiocb_type": ["aiocbamype", "aiocb__ype", "aiocrb_TYPE", "aiocb_ype", "aiocb_TYPE", "aiocB_type", "aiocbamtype", "aiocb_Type", "aiocbamTYPE", "aiocrbamype", "aiocb_state", "aiocb__state", "aiocb__type", "aiocrbamTYPE", "aiocrb_ype", "aiocB_Type", "aiocrbamtype", "aiocB_typ", "aiocrb_state", "aiocb__TYPE", "aiocb_typ", "aiocb_style", "aiocrbamstate", "aiocrb_type", "aiocB_style", "aiocbamstate"], "hdr": [" hmsg", "phfr", "ohfr", " hrd", " hfr", "heheader", " hpar", "httpdr", "Hrr", "hll", "hhdr", " hheader", "hhDR", " haddr", " husr", " hdef", "httpheader", " hr", "hrd", "hvr", "ohheader", "ohdr", " hrr", "thbr", "ihdr", "shstr", "held", "hmdef", "phstr", "husr", "hhll", "hstr", "hfr", "phpar", " hbr", "hmpar", "phcmd", "Hpar", "httprd", "hemsg", "hedr", "ohll", "thDR", " hDR", " hadr", "Hbr", " hder", "hmcmd", "phaddr", "ihpar", "hebr", "hcmd", "ihheader", "phheader", "hpr", "historydel", "hr", "Hdel", "phrr", "hhr", "historydr", "phdr", "heDR", "hrr", " hvr", "phDR", "Hmsg", "hder", " hcmd", "ohstr", "Hr", "HDR", "httppr", "hmrd", "Hstr", "thdr", "ohr", "hmdr", "Hvr", "Hadr", "haddr", "ohDR", "ohrr", "hdel", "phmsg", "shheader", "historyDR", "hmpr", "Hll", "Husr", "hadr", "hheader", "Hheader", "ihstr", " hld", " hstr", "Hder", "hpar", " hpr", "hdef", "hbr", "hmheader", " hdel", "thvr", "historyusr", "phbr", "hld", "headr", "hmsg", "phdef", "Hdr", "shpar", "ohaddr", "hDR", "Hld", "ohder", "shdr"], "wlen": [" wLen", "welt", "wlength", "hlen", "hwdl", " wlr", "WLen", "wtelt", "waitdl", " welt", "swln", "hls", "whcompl", "Wlen", "wcompl", "wdl", "wtlen", "hwlen", "whlen", "hwlr", " wdl", "wLen", "waitlen", "wtcompl", "Wlength", "wll", "hLen", "waitcompl", " wls", " wfun", "whelt", "wlr", "swlength", "wln", "swlen", "swfun", " wll", "whll", "hfun", " wlength", "hln", "hlength", "wtll", " wcompl", "waitlr", "hwcompl", "Wls", "wfun", "wls", " wln"], "ret": ["ef", "success", "off", "status", "et", "rs", "RET", "nt", "rev", "ref", " af", "alt", "ext", "final", "rets", "os", "val", "Ret", "trust", "cmd", "res", "fee", "vals", "uns", "af"]}}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_write_packet(AVFormatContext *s, int stream_index,\n\n                            UINT8 *buf, int size)\n\n{\n\n    VideoData *img = s->priv_data;\n\n    AVStream *st = s->streams[stream_index];\n\n    ByteIOContext pb1, *pb;\n\n    AVPicture picture;\n\n    int width, height, ret, size1;\n\n    char filename[1024];\n\n\n\n    width = st->codec.width;\n\n    height = st->codec.height;\n\n\n\n    switch(st->codec.pix_fmt) {\n\n    case PIX_FMT_YUV420P:\n\n        size1 = (width * height * 3) / 2;\n\n        if (size != size1)\n\n            return -EIO;\n\n        \n\n        picture.data[0] = buf;\n\n        picture.data[1] = picture.data[0] + width * height;\n\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n\n        picture.linesize[0] = width;\n\n        picture.linesize[1] = width >> 1; \n\n        picture.linesize[2] = width >> 1;\n\n        break;\n\n    case PIX_FMT_RGB24:\n\n        size1 = (width * height * 3);\n\n        if (size != size1)\n\n            return -EIO;\n\n        picture.data[0] = buf;\n\n        picture.linesize[0] = width * 3;\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (get_frame_filename(filename, sizeof(filename), \n\n                           img->path, img->img_number) < 0)\n\n        return -EIO;\n\n\n\n    if (!img->is_pipe) {\n\n        pb = &pb1;\n\n        if (url_fopen(pb, filename, URL_WRONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        pb = &s->pb;\n\n    }\n\n    switch(img->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_save(&picture, width, height, pb, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_save(&picture, width, height, pb, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_save(&picture, width, height, filename);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_save(&picture, width, height, pb);\n\n        break;\n\n    }\n\n    if (!img->is_pipe) {\n\n        url_fclose(pb);\n\n    }\n\n\n\n    img->img_number++;\n\n    return 0;\n\n}\n", "idx": 9842, "substitutes": {"s": ["src", "sq", "spec", "a", "ats", "q", "rs", "as", "sg", "p", "gs", "sts", "sp", "sm", "f", "ps", "g", "cs", "m", "l", "ins", "sv", "i", "aws", "r", "is", "js", "j", "S", "ss", "ts", "n", "t", "v", "conf", "os", "e", "sb", "b", "c", "sh", "h", "ns", "stats", "fs", "set", "ls", "ds", "sys"], "stream_index": ["stream_num", "channel_ind", "stream_handle", "channel_Index", "channel_handle", "stream__num", "stream_Index", "stream_ind", "channel_index", "stream__number", "channel_num", "stream_number", "channel_key", "channel_number", "stream__handle", "stream_key", "stream__index"], "buf": ["bf", "xff", "buffer", "read", "uf", "rb", "bp", "cam", "err", "begin", "p", "seq", "Buffer", "vec", "np", "ref", "block", "fb", "pkg", "cur", "cb", "raw", "queue", "bg", "r", "mem", "data", "br", "cap", "ctx", "rc", "v", "b", "paste", "tmp", "cmd", "orig", "Buff", "nb", "batch", "buff", "result", "msg", "cv", "wb"], "size": ["len", "small", "num", "empty", "send", "status", "sum", "message", "format", "IZE", " Size", "area", "file", "sp", "unit", "Size", "name", "SIZE", "scope", "note", "type", "length", "ize", "en", "bytes", "storage", "share", "loss", "global", "count", "iz", "shape", "e", "dim", "c", "scale", "offset", "w", "fee", "set", "fit", "max", "ose", "space", "style", "number"], "img": ["src", "doc", "obj", "png", "imp", "pic", "gif", "av", "uf", "gm", "upload", "image", "cam", "uv", "p", "ng", "anim", "f", "imgur", "amp", "imag", "pg", "g", "pkg", "m", "attr", "um", "def", "util", "iam", "jpg", "ext", " im", "gd", "im", "data", "j", "html", "emb", "v", "info", "feat", "tmp", "utm", "og", "dat", "animate", "str", "inst", "ob", "it", "att", "aug", "mp", "am", "mt"], "st": ["td", "tr", "lib", "sl", "ie", "std", "ch", "pt", "St", "ct", "step", "list", "sp", "p", "sts", "sm", "sim", "ut", "ess", "d", "th", "sv", "ust", "sam", "ste", "so", "stage", "ss", "ist", "se", "t", "ctx", "sty", "ast", "sw", "sh", "ST", "h", "ost", "sn", "rt", "str", "est", "sta", "rest", "start", "sc", "z", "set", "inst", "style", "spect"], "pb1": ["jp0", "sb2", "jp1", "p01", "pb2", "pb3", "p1", "p0", "cb1", "sb3", "pb01", "p3", "sb1", "cb01", "jp2", "cb3", "p2", "sb0", "cb2", "pb0", "jp01", "cb0"], "pb": ["td", "lb", "bj", "typ", "pas", "pc", "tp", "ub", "mb", "pp", "pt", "uf", "bp", "rb", "ping", "proc", "tg", "p", "resp", "pool", "func", "cp", "fp", "pg", "vp", "jp", "pkg", "np", "tc", "fb", "pod", "cb", "tab", "conv", "orp", "lp", "bs", "pm", "snap", "emb", "eb", "ctx", "erb", "pl", "gc", "sb", "b", "wp", "tmp", "sys", "dp", "bb", "ob", "PB", "apa", "nb", "buff", "ib", "db", "cv", "mp", "patch", "wb", "pa"], "picture": [" profile", "config", "feature", "print", "peg", "media", "brush", "jpg", "support", "family", "friendly", "attribute", "details", "import", "data", "figure", "closure", "pi", "camera", "public", "history", "before", "share", "performance", "foreign", "bank", "power", "Pic", "username", "path", "network", "sharp", " portrait", "widget", "imgur", "try", "video", "pen", "feat", "knife", "rule", " pic", "Picture", "png", "pic", "policy", "image", "summary", "iture", "profile", "file", "point", "associated", "error", "frame", "volume", "def", "sequence", "function", " perspective", "like", "info", "comment", "library", "professional", "definition", "pict", "pty", "statement", "database", "style", "password", "secure", "join", "proof", "p", "pair", "person", "whatever", "fortunately", "photo", "query", "stat", "remember", "important", "private", "description"], "height": ["command", "grow", "xy", "huge", "range", "bottom", "family", "data", "y", "html", "times", "hang", "history", "depth", "yt", "half", "capacity", "docker", "confidence", "Height", "alpha", "count", "radius", "above", "ows", "rank", "square", "density", "high", " heights", "number", "png", "buffer", "ch", "image", "stroke", "hash", "volume", "SIZE", "th", "instance", "type", "def", "window", "index", "chain", "host", "dim", "crop", "gravity", "angle", "style", "windows", "password", "ty", "resolution", "padding", "build", "quality", "total", "through", "shape", "headers", "h", "kw", "name", "length", "cy"], "ret": ["len", "id", "pas", "status", "url", "nl", "at", "back", "summary", "print", "det", "RET", "resp", "nt", "rev", "limit", "ref", " Ret", "def", "cb", "desc", "alt", "mem", "tail", "ext", "rel", "try", "box", "body", "t", "aux", "rem", "rets", "not", "arg", "gc", "val", "Ret", "rt", "re", "elt", "sys", "res", "rm", "result", "full", "att", "gt", "ft", "ll", "dt", "Return", "out", "mt"], "size1": ["Size61", "size001", "sum001", " size3", "SIZE1", "scale001", " sizeone", " sizeOne", "izeOne", "score001", "sizeOne", "SizeOne", "size61", "Size_", "score1", " size0", "sum3", "size3", "SIZE0", " size2", "scaleOne", "zeroOne", "zero1", "zeroone", "score2", "SIZE2", " size61", "size_", " size_", "ize2", "zero001", "scaleone", " size001", "size2", "size0", "Size2", "Size0", "SIZE_", "Size001", "zero3", "Size1", "ize61", "scoreOne", "sum1", "scale1", "ize1", "sizeone"], "filename": ["folder", "src", "png", "fw", "url", "nm", "username", "prefix", "buffer", "text", "path", "names", "image", "file", "FN", "Filename", "f", "fp", "files", "location", "original", "pkg", "np", "ename", "fb", "ame", "word", "bn", "txt", "jpg", "ames", "r", "kl", "fn", "n", "final", "new", "v", "b", "tmp", "title", "bh", "w", "result", "fil", "nil", "name", "length"], "img_number": ["image_number", "imgnnumber", "imgnnum", "imgnindex", "img_index", "img_no", "img_num", "image_num", "image_no", "imgnno", "image_index"]}}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n", "idx": 9845, "substitutes": {"mon": ["Mon", "on", "san", "chron", "min", "mx", "mat", "mm", "monkey", "den", "an", "mic", "admin", "m", "MON", "sam", "mn", "mu", "met", "mi", "monitor", "tem", "mir", "dom", "man", " man", " monitor", "om", "mun", "mons", "onet", "mut", "mont", "hum", "dm", "ann", "tim"], "qdict": ["sqmap", "qmap", " qmap", "qd", "qict", "dqd", "sqd", "dqict", " qict", "sqict", " qd", "dqdict", "dqmap", "sqdict"], "dinfo": ["adinf", " dinformation", "drinformation", "adinformation", "dInfo", "dinf", "drinfo", "dki", "Dconf", "Dinf", " dconf", "adki", " dinf", "dconf", "Dinfo", "adinfo", "linfo", "drki", " dInfo", "lconf", "drinf", "dinformation", "linf", " dki", "lInfo", "DInfo"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {\n\n  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;\n\n  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );\n\n  uint8_t *ysrc = src[0];\n\n  uint8_t *usrc = src[1];\n\n  uint8_t *vsrc = src[2];\n\n  const int width = c->srcW;\n\n  const int height = srcSliceH;\n\n  const int lumStride = srcStride[0];\n\n  const int chromStride = srcStride[1];\n\n  const int dstStride = dstStride_a[0];\n\n  const vector unsigned char yperm = vec_lvsl(0, ysrc);\n\n  const int vertLumPerChroma = 2;\n\n  register unsigned int y;\n\n\n\n  if(width&15){\n\n    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);\n\n    return srcSliceH;\n\n  }\n\n\n\n  /* this code assume:\n\n\n\n  1) dst is 16 bytes-aligned\n\n  2) dstStride is a multiple of 16\n\n  3) width is a multiple of 16\n\n  4) lum&chrom stride are multiple of 8\n\n  */\n\n\n\n  for(y=0; y<height; y++)\n\n    {\n\n      int i;\n\n      for (i = 0; i < width - 31; i+= 32) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_yA = vec_ld(i, ysrc);\n\n\tvector unsigned char v_yB = vec_ld(i + 16, ysrc);\n\n\tvector unsigned char v_yC = vec_ld(i + 32, ysrc);\n\n\tvector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);\n\n\tvector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);\n\n\tvector unsigned char v_uA = vec_ld(j, usrc);\n\n\tvector unsigned char v_uB = vec_ld(j + 16, usrc);\n\n\tvector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));\n\n\tvector unsigned char v_vA = vec_ld(j, vsrc);\n\n\tvector unsigned char v_vB = vec_ld(j + 16, vsrc);\n\n\tvector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_uv_b = vec_mergel(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);\n\n\tvector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n\tvec_st(v_yuy2_2, (i << 1) + 32, dst);\n\n\tvec_st(v_yuy2_3, (i << 1) + 48, dst);\n\n      }\n\n      if (i < width) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_y1 = vec_ld(i, ysrc);\n\n\tvector unsigned char v_u = vec_ld(j, usrc);\n\n\tvector unsigned char v_v = vec_ld(j, vsrc);\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n      }\n\n      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\n\n\t{\n\n\t  usrc += chromStride;\n\n\t  vsrc += chromStride;\n\n\t}\n\n      ysrc += lumStride;\n\n      dst += dstStride;\n\n    }\n\n\n\n  return srcSliceH;\n\n}\n", "idx": 9846, "substitutes": {"c": ["con", "a", "ch", "ct", "p", "ec", "f", "cp", "cf", "d", "dc", "bc", "g", "cs", "m", "tc", "cc", "ce", "cont", "mc", "t", "ci", "ctx", "ac", "rc", "v", "lc", "conf", "cache", "e", "b", "com", "h", "w", "cm", "sc", "fc", "C", "co", "s", "cv", "cr", "ca"], "src": ["sq", "tr", "sync", "sl", "source", "ch", "sp", "sub", "height", "bin", "trans", "iter", "cur", "ins", "hl", "supp", "usr", "split", "in", "bg", "ser", "rl", "sup", "dest", "rc", "sort", "tmp", "sur", "sb", "transform", "ctr", "sw", "sh", "comp", "via", "bh", "sn", "scale", "b", "sr", "dist", "st", "slice", "sc", "fc", "seed", "nil", "iv", "loc", "inst", "sys"], "srcStride": ["srcStide", "srcStrope", "srcStro", "srcRestri", "rcstrip", "srcSTide", "srcSTrip", "srcstro", "srcSTride", "sourceStope", "srcSlride", "srcRestride", "srcStrro", "rcStri", "rcStrip", "sourceStrope", "srcSlro", "srcSlri", "sourceStrride", "rcstro", "rcStrride", "srcStope", "rcStro", "sourceStride", "sourceStrro", "sourceStro", "rcstide", "srcstride", "sourceStide", "srcstide", "srcStrri", "srcRestrip", "rcStrri", "srcstrip", "srcRestide", "srcStrride", "srcSTro", "srcStri", "srcSlope", "rcStride", "srcStrip", "srcSlide", "srcRestro", "rcStide", "rcStrro", "rcstride"], "srcSliceY": ["srcSllicH", "srcSlaceX", "srcSlideH", "srcSlideX", "srcSllicYY", "srcSllicB", "srcSllicY", "srcSliceYY", "srcSLaceY", "srcSlaceH", "srcSlaceB", "srcSLiceH", "srcSLiceY", "srcSlideB", "srcSlideYY", "srcSlaceY", "srcSLaceH", "srcSLaceB", "srcSLiceX", "srcSLaceX", "srcSLiceB", "srcSliceB", "srcSlideY", "srcSliceX"], "srcSliceH": ["srcSlgeHeight", "srcSlideHT", "srcSluceW", "srcSlgeh", "srcSliceHeight", "srcSlideH", "srcSlipY", "srcSlipHT", "srcSlizeB", "srcSlsliceHH", "srcSluceHT", "srcSlideB", "srcSlsliceB", "srcSlideW", "srcSlizeY", "srcSliceHT", "srcSliceHH", "srcSlizeHT", "srcSlICEH", "srcSlICEHeight", "srcSlsliceH", "srcSlipH", "srcSlideHH", "srcSlgeH", "srcSluceY", "srcSlICEHT", "srcSliceh", "srcSluceH", "srcSlICEY", "srcSliceB", "srcSluceHH", "srcSlipW", "srcSlICEh", "srcSluceB", "srcSlideY", "srcSlsliceY", "srcSliceW", "srcSlizeH", "srcSlICEB"], "dstParam": ["dstParameter", "ddestParam", " dstPar", "ddestMode", " dndParameter", "DstParam", "destParam", "dstsParameter", "dstsMode", "destParameter", "dndConf", "dstrMode", "ddestParameter", "drdPar", "destPar", "drdConf", " dndConf", "dstMode", "DstParameter", "dndParam", "destConf", " dstParameter", "dndParameter", " dstConf", "DstsMode", "DstsPar", "dstsParam", "dndPar", "dstrPar", "dstPar", " dndParam", "ddestPar", "dstrParameter", "DstsParam", "dstConf", "DstMode", " dndPar", "dstrParam", "DstsParameter", "dstsPar", "DstPar", "drdParameter", "drdParam"], "dstStride_a": ["dstStide_t", "dstStride_o", "dstStride_e", "dstStrip_e", "dstStri_t", "dstStride_A", "dstStri_a", "dstStrip_o", "dstStrip_a", "dstStride_b", "dstStide_b", "dstStide_e", "dstStri_A", "dstStride_t", "dstStri_b", "dstStide_a"], "dst": [" dost", "dsst", "dsot", "sdot", " dot", "ddest", " dST", "dsdest", "dST", "sost", "tST", "tdest", "sdest", "dsrc", "dssrc", " dsrc", "sddest", "sdst", " ddest", "tost", "dot", "sdsrc", "dost", "tst", "sst", "sST"], "ysrc": ["bysrc", "ysrt", "yscusc", "ysr", "yssusc", "iesource", "iesirc", "myssrc", "insirc", "ynrs", "ysRC", "ynrin", "ysirc", "iesrc", "bysrs", "syscore", "ysrin", "ynRC", "yssirc", "sysrin", "iesrs", "yscrc", "iesack", "yssource", "ysrec", "owsr", "owsrc", "yssrc", "iesrec", "insource", "iessrc", "ysource", "sysource", "ysusc", "bysrt", "iesr", "insrc", "yssack", "ynrc", "yscack", "sysrs", "mysrc", "yscore", "yscource", "iesrin", "ysack", "owscore", "iesRC", "insRC", "mysrt", "byssrc", "owsrec", "mysrs", "yssRC", "iesrt", "owsRC", "yssrec", "iescore", "iesusc", "sysRC", "sysr", "owsirc", "sysirc", "ysrs", "sysrc"], "usrc": ["tsRC", "USirc", "ausrl", "usessrc", "psource", " usrl", " usRC", "pssrc", " usarc", "tssrc", "USsrc", "syssrc", "ausrs", "cusrc", "usource", "usRC", "osource", "cusirc", "psr", "osr", "usrl", "usesrs", "cussrc", " usrs", "aussrc", "usr", "ussrc", "sysource", "cusr", "USrc", "usesrl", "ausrc", "tsarc", "usesrc", "ausRC", "usrs", "tsrc", "usirc", "usarc", "ossrc", "psrc", "cusource", " ussrc", "ausarc", "sysirc", "osrc", "USource", "sysrc"], "vsrc": [" vcur", "waddr", "Vrc", "Vsource", "vsettings", "Vcur", " vaddr", "qvcur", " vrc", "qvsettings", "vaddr", "wsource", "vrc", "Vsrc", "vsource", "qvsrc", "vcur", "wrc", "qvsource", "Vsettings", " vsource", "wsrc", "Vaddr", " vsettings"], "y": ["aily", "key", "py", "yt", "ity", "xy", "ya", "axy", "sky", "status", "ty", "ch", "vy", "ady", "yy", "yi", "wy", "p", "o", "ay", "height", "ry", " Y", "g", "m", "my", "ies", "ye", "dy", "ys", "j", "row", "html", "Y", "v", "ey", "b", "h", "ym", "ery", "sy", "gy", "ot", "w", "any", "iy", "yout", "by", "z", "yl", "ny", "ht", "cy"], "i": ["ami", "id", "u", "ai", "I", "a", "li", "ei", "init", "iq", "ri", "p", "ii", "o", "point", "ex", "ind", "ui", "this", "ip", "m", "l", "ji", "ti", "ia", "ic", "in", "mi", "index", "is", "try", "j", "im", "ix", "n", "iu", "ci", "t", "zi", "v", "info", "xi", "e", "qi", "b", "multi", "h", "gi", "bi", "di", "origin", "pi", "si", "it", "x", "z", "ini", "oi", "hi", "ij"]}}
{"project": "qemu", "commit_id": "338c858c946017cd3ec8c2be06d817e001d94bc3", "target": 0, "func": "void cpu_loop(CPUAlphaState *env)\n\n{\n\n    CPUState *cs = CPU(alpha_env_get_cpu(env));\n\n    int trapnr;\n\n    target_siginfo_t info;\n\n    abi_long sysret;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_alpha_exec(cs);\n\n        cpu_exec_end(cs);\n\n\n\n        /* All of the traps imply a transition through PALcode, which\n\n           implies an REI instruction has been executed.  Which means\n\n           that the intr_flag should be cleared.  */\n\n        env->intr_flag = 0;\n\n\n\n        switch (trapnr) {\n\n        case EXCP_RESET:\n\n            fprintf(stderr, \"Reset requested. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MCHK:\n\n            fprintf(stderr, \"Machine check exception. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_SMP_INTERRUPT:\n\n        case EXCP_CLK_INTERRUPT:\n\n        case EXCP_DEV_INTERRUPT:\n\n            fprintf(stderr, \"External interrupt. Exit\\n\");\n\n            exit(EXIT_FAILURE);\n\n            break;\n\n        case EXCP_MMFAULT:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID\n\n                            ? TARGET_SEGV_ACCERR : TARGET_SEGV_MAPERR);\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_UNALIGN:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGBUS;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_BUS_ADRALN;\n\n            info._sifields._sigfault._addr = env->trap_arg0;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_OPCDEC:\n\n        do_sigill:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_ILL_ILLOPC;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_ARITH:\n\n            env->lock_addr = -1;\n\n            info.si_signo = TARGET_SIGFPE;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_FPE_FLTINV;\n\n            info._sifields._sigfault._addr = env->pc;\n\n            queue_signal(env, info.si_signo, &info);\n\n            break;\n\n        case EXCP_FEN:\n\n            /* No-op.  Linux simply re-enables the FPU.  */\n\n            break;\n\n        case EXCP_CALL_PAL:\n\n            env->lock_addr = -1;\n\n            switch (env->error_code) {\n\n            case 0x80:\n\n                /* BPT */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x81:\n\n                /* BUGCHK */\n\n                info.si_signo = TARGET_SIGTRAP;\n\n                info.si_errno = 0;\n\n                info.si_code = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            case 0x83:\n\n                /* CALLSYS */\n\n                trapnr = env->ir[IR_V0];\n\n                sysret = do_syscall(env, trapnr,\n\n                                    env->ir[IR_A0], env->ir[IR_A1],\n\n                                    env->ir[IR_A2], env->ir[IR_A3],\n\n                                    env->ir[IR_A4], env->ir[IR_A5],\n\n                                    0, 0);\n\n                if (trapnr == TARGET_NR_sigreturn\n\n                    || trapnr == TARGET_NR_rt_sigreturn) {\n\n                    break;\n\n                }\n\n                /* Syscall writes 0 to V0 to bypass error check, similar\n\n                   to how this is handled internal to Linux kernel.\n\n                   (Ab)use trapnr temporarily as boolean indicating error.  */\n\n                trapnr = (env->ir[IR_V0] != 0 && sysret < 0);\n\n                env->ir[IR_V0] = (trapnr ? -sysret : sysret);\n\n                env->ir[IR_A3] = trapnr;\n\n                break;\n\n            case 0x86:\n\n                /* IMB */\n\n                /* ??? We can probably elide the code using page_unprotect\n\n                   that is checking for self-modifying code.  Instead we\n\n                   could simply call tb_flush here.  Until we work out the\n\n                   changes required to turn off the extra write protection,\n\n                   this can be a no-op.  */\n\n                break;\n\n            case 0x9E:\n\n                /* RDUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0x9F:\n\n                /* WRUNIQUE */\n\n                /* Handled in the translator for usermode.  */\n\n                abort();\n\n            case 0xAA:\n\n                /* GENTRAP */\n\n                info.si_signo = TARGET_SIGFPE;\n\n                switch (env->ir[IR_A0]) {\n\n                case TARGET_GEN_INTOVF:\n\n                    info.si_code = TARGET_FPE_INTOVF;\n\n                    break;\n\n                case TARGET_GEN_INTDIV:\n\n                    info.si_code = TARGET_FPE_INTDIV;\n\n                    break;\n\n                case TARGET_GEN_FLTOVF:\n\n                    info.si_code = TARGET_FPE_FLTOVF;\n\n                    break;\n\n                case TARGET_GEN_FLTUND:\n\n                    info.si_code = TARGET_FPE_FLTUND;\n\n                    break;\n\n                case TARGET_GEN_FLTINV:\n\n                    info.si_code = TARGET_FPE_FLTINV;\n\n                    break;\n\n                case TARGET_GEN_FLTINE:\n\n                    info.si_code = TARGET_FPE_FLTRES;\n\n                    break;\n\n                case TARGET_GEN_ROPRAND:\n\n                    info.si_code = 0;\n\n                    break;\n\n                default:\n\n                    info.si_signo = TARGET_SIGTRAP;\n\n                    info.si_code = 0;\n\n                    break;\n\n                }\n\n                info.si_errno = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            default:\n\n                goto do_sigill;\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n            info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n            if (info.si_signo) {\n\n                env->lock_addr = -1;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n        case EXCP_STL_C:\n\n        case EXCP_STQ_C:\n\n            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* Just indicate that signals should be handled asap.  */\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 9864, "substitutes": {"env": ["doc", "vs", "ah", "config", "vv", "enter", "eng", "vp", "desc", "qt", "actor", "ener", "cmd", "eu", "ent", "org", "context", "cv", "era", "ja", "et", "init", "ec", "ve", "buf", "sv", "Environment", "en", "usr", "server", "outer", "js", "esc", "conn", "conf", "environment", "e", "eas", "estate", "sc", "door", "nv", "obj", "err", "enc", "ev", "engine", "worker", "scope", "vt", "window", "shell", "term", "ctx", "die", "anc", "er", "db", "console", "vm", "timer", "ds", "entry", "pe", "here", "event", "manager", "erd", "dev", "te", "cb", "addr", "dn", "inv", "ew", "pres", "box", "v", "esp", "cache", "query", "origin", "ner", "viron"], "cs": ["ms", "ck", "vs", "Cs", "pc", "cus", "qs", "cks", "rs", "css", "hs", "ec", "gs", "sts", "CS", "cp", "ps", "cf", "tc", "cc", "bs", "js", "ys", "ss", " cis", "ts", "ix", "ctx", "rc", "wcs", "gc", "c", "acs", "ns", "fs", "sc", "fc", "ces", "ls", "s", "cv", "vc", "ds", "sys"], "trapnr": ["rrnor", " trapnor", "testno", "tapNR", "trapr", "testNR", "tapr", "trapnor", "testnb", "dropnr", "trapno", "rrNR", "rrnb", "wrapnb", " trapNR", "wrapNR", "trapNR", "dropr", " trapnb", "rrnr", " trapno", "tapnr", "dropNR", "dropnb", "testnr", "wrapnor", "trapnb", "tapnb", " trapr", "wrapnr", "tapno"], "info": ["doc", "xy", "config", "fo", "update", "rec", "desc", "details", "http", "data", "ci", "check", "unknown", "about", "user", "history", "Info", "inner", "notice", "tx", "status", "settings", "init", "value", "iter", "note", "ti", "utils", "txt", "try", "one", "conf", "information", "alias", "si", "time", "dict", "pack", "debug", "no", "id", "image", "summary", "f", "error", "frame", "reason", "admin", "ref", "type", "def", "trace", "ote", "index", "now", " Info", "sort", "good", "action", "inf", "comment", "by", "it", "diff", "INFO", "off", "entry", "fi", "base", "list", "to", "auth", "json", "addr", "cache", "query", "kw", "help", "stat", "tag", "name"], "sysret": ["ysresult", "procret", "procRet", "procarg", "sysresult", " sysarg", "procresult", " sysRet", " sysresult", "ysret", "ysarg", "sysarg", "sysRet", "ysRet"]}}
{"project": "qemu", "commit_id": "e70377dfa4bbc2e101066ca35675bed4129c5a8c", "target": 0, "func": "static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)\n\n{\n\n    int i;\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    if (!target) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = s->pbdev[i];\n\n        if (!pbdev) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(pbdev->target, target)) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 9870, "substitutes": {"target": ["command", "output", "available", "expected", "select", "success", "address", "source", "buffer", "pointer", "ARGET", "path", "format", "device", "bolt", "match", "event", "base", "arget", "valid", "to", "focus", "hash", "field", "normal", "this", "scope", "label", "component", "true", "stop", "type", "null", "trace", "length", "handle", "term", "that", "selected", "test", "dest", "version", "root", "t", "state", "specified", "v", "arg", "primary", "remote", "transform", "host", "cmd", "title", "blank", "supported", "native", "tag", "alias", "peer", "table", "gt", "nil", "template", "debug", "name", "project", "enabled", "trap", "required", "Target"], "i": [" m", " wi", "ai", "fi", "I", "me", "li", "ei", "init", " I", "iq", " di", "span", "ri", "sim", " li", "ind", "ui", "iter", "m", "ori", " pi", "ki", "ti", " multi", "ic", " si", "cli", " ti", "mi", "index", "in", "us", "j", "im", "ix", "n", "y", "iu", "ci", "\u0438", "zi", "phi", " mi", " j", "xi", "e", "multi", "qi", "gi", "di", " index", "bi", "ij", "pi", "si", "it", "x", "batch", " err", " ii", " bi", "ini", "z", "hi", " ni", "ji", "ims", " iter", " my", "asi", "ii"], "pbdev": ["bpserv", "ebdevice", "sbDev", "pbev", "ppval", "bpcmd", "ppdev", "bpdev", "pbDev", "bjdevice", "sbdevice", "fbgu", "pbdec", "cbcmd", "bjconn", "cbval", "pbserv", "pbDEV", "tpdevice", "PBconn", "ppdec", "PBDev", "bpdevice", "PBev", "PBdec", "fbserv", "PBdev", "sbDEV", "PBDEV", "tpdec", "cbDev", "bjdev", "ppDEV", "fbdevice", "pbdevice", "bpgu", "ebDEV", "pbgu", "tpdev", "ebdev", "fbdev", "PBserv", "PBgu", "sbev", "cbev", "ebconn", "PBcmd", "cbdev", "ppDev", "sbdev", "tpDEV", "ebDev", "pbval", "pbcmd", "bjDev", "pbconn", "bpev", "ebev", "ppdevice", "sbval", "cbdevice", "PBdevice"], "s": ["sq", "rs", "hs", "p", "gs", "sts", "sm", "ps", "south", "local", "sv", "es", "ses", "bs", "session", "r", "is", "js", "less", "S", "ss", "ts", "n", "se", "t", "ssl", "self", "v", "b", "c", "h", "ns", "stats", "fs", "set", "syn", "store"]}}
{"project": "FFmpeg", "commit_id": "c95fefa0420be9cc0f09a95041acf11114aaacd0", "target": 0, "func": "static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)\n\n{\n\n    uint16_t cmd;\n\n    int i, sz, offset, code;\n\n    unsigned char *dst_end = dst + dst_size;\n\n    const unsigned char *src_end = src + src_size;\n\n\n\n    while (src < src_end && dst < dst_end) {\n\n        code = *src++;\n\n        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {\n\n            if (code & (1 << i)) {\n\n                *dst++ = *src++;\n\n            } else {\n\n                cmd = AV_RL16(src); src += 2;\n\n                offset = cmd >> 4;\n\n                sz = (cmd & 0xF) + 2;\n\n                /* don't use memcpy/memmove here as the decoding routine (ab)uses */\n\n                /* buffer overlappings to repeat bytes in the destination */\n\n                sz = FFMIN(sz, dst_end - dst);\n\n                while (sz--) {\n\n                    *dst = *(dst - offset - 1);\n\n                    ++dst;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9896, "substitutes": {"src": ["inc", "usc", "config", "proc", "func", "rec", "attr", "ins", "hl", "desc", "ctl", "cc", "ser", "rl", "ipl", "str", "sr", "imp", "tp", "cmp", "source", "rb", "init", "ind", "RC", "iter", "rob", "bc", "sec", "ptr", "urg", "bs", "usr", "txt", "rel", "ix", "aux", "sur", "sb", "comp", "rt", "sc", "syn", "img", "sq", "obj", "sl", "url", "rs", "req", "sub", "cur", "raw", "tmp", "copy", "start", "gb", "nil", "iv", "loc", "lit", "sync", "ack", "seq", "pkg", "addr", "cont", "stock", "dest", "rc", "input", "ctr", "via", "sn", "sel", "st", "stat", "inst", "sys"], "src_size": ["src_scope", "st_size", "st_SIZE", "src_SIZE", "src_name", "st_scope", "src_range", "st_range", "st_len", "src_len", "st_name"], "dst": [" dost", "ssts", "dnd", "lobj", "didpend", "fct", "gobj", " Dost", "dslt", " dpend", "dsdest", " Dnd", "sest", "didst", "snd", "Ddest", "sst", " dlt", "dput", "dobj", " dtd", " Dsts", "lput", "idnd", "dsst", "idsts", "didest", "ltd", "sct", "delst", "ddobj", "idost", " ddest", "ddst", "diddest", "desct", "dlt", "fest", "dutd", "Dpend", "dsest", "ddtd", "ddput", "desst", "fnd", "Dst", "ddest", "Dpt", " Dst", " dnd", "Dnd", "gst", "dust", "dult", "delest", "desnd", "dsts", "Dsts", "desdest", "dusts", " dest", "Dct", "gtd", " dsts", " dct", "fst", "dupt", "delpt", "delsts", "dpt", "dsct", "dstd", "lst", "idst", "dest", "gput", "dtd", "dct", "dsnd", "duct", "dpend", "Dest", "dost", "duest"], "dst_size": ["dst0start", "dset0name", "dset_start", "dst_start", "dst0name", "dst_sum", "dnd_end", "dset0size", "dset_size", "dst8end", "dnd_Size", "dset_sum", "dnd_size", "dst8Size", "dst_Size", "dset0start", "dst_scale", "dset_name", "dst_name", "dst0size", "dst8scale", "dnd_scale", "dst8size", "dset0sum", "dst0sum"], "cmd": ["MD", "command", "ck", "obj", "xy", "cmp", "config", "Cmd", "ctrl", "ch", "text", "req", "init", "ct", "cut", "kt", "ect", "cp", "nt", "cf", "cat", "pkg", "cur", "control", "cd", "attr", "def", "cb", "ctl", "kind", "cli", "ext", "md", "qt", "cod", "cont", "ctx", "check", "rc", "cfg", "mk", "ctr", "c", "comp", "opt", "buff", "msg", "cr", "awk"], "i": ["id", "u", "ai", "fi", "I", "io", "me", "ie", "li", "iq", "k", "p", "o", "sim", "ind", "ui", "ip", "m", "l", "ti", "ic", "ish", "mi", "index", "is", "j", "im", "ix", "n", "y", "iu", "ci", "\u0438", "t", "zi", "phi", "v", "info", "xi", "qi", "multi", "b", "c", "di", "bi", "ij", "pi", "si", "it", "x", "z", "ini", " ii", "batch", "s", " j", "asi", "ii"], "sz": ["alsz", "sq", "jsiz", "alsld", " siz", "idsz", "idszi", "Sq", "jszi", "idsiz", "dsz", "dszek", " suz", "bitszi", "Suz", "szi", "agszek", " sld", "idszek", "bitsiz", "Szek", "agszi", "alsiz", "dszi", "dsiz", "agsiz", " szi", " szek", "Szi", "bitszek", "agsz", "bitsz", " sq", "Sz", "jsuz", "dsq", "sld", "siz", "jsq", "szek", "jsz", "Siz", "Sld", "suz", "alszi"], "offset": ["align", "shift", "len", "output", "obj", "off", "reset", "id", "address", "et", "prefix", "pointer", "order", "init", "end", "seek", "o", "iso", "error", "pad", "slot", "ui", "location", "pos", "ref", "timeout", "attr", "position", "trace", "ptr", "window", "addr", "alt", "scroll", "index", "aff", "bound", "skip", "sort", "Offset", "rot", "info", "count", "out", "ot", "origin", "start", "set", "item", "oint", "loc", "size", "delay"], "code": ["command", "obj", "xy", "id", "status", "map", "config", "source", "text", "ch", "coe", "go", "ct", "ack", "Code", "error", "name", "cycle", "cd", "type", "control", "xxx", "cc", "ce", "bit", "cont", "cod", "magic", "data", "test", "body", "mode", "check", "rc", "count", "info", "close", "c", "comment", "comp", "copy", "tmp", "str", "xx", "codes", "x", "ode", "co", "msg", "content"], "dst_end": ["dot_size", "dst__end", "dnd_last", "dct_last", "dst___iter", "dst__env", "dest_start", "dest_end", "dst__start", "dst_env", "dct_name", "dst_all", "dnd_start", "dest_all", "dst_start", "dest_env", "dct_end", "dst_last", "dst___name", "dst___begin", "dst__all", "dot_iter", "dst_name", "dst_len", "dct_begin", "dot_end", "dnd_end", "dst___size", "dnd_len", "dst___last", "dst_iter", "dst_begin", "dst___end"], "src_end": ["src00head", "rc_start", "rc_origin", "src_origin", "srcLenend", "src_edge", "srcLenstart", " src_edge", "src00end", "src_head", "srcLenEND", "rc_END", " src_start", "rc_off", " src_head", "srcLenorigin", "src_off", "src00start", "rc_end", "src_END", "src00edge", "src_start"]}}
{"project": "FFmpeg", "commit_id": "84f0aba18dc8815c5cd408238909e4dc8b60684f", "target": 1, "func": "ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,\n\n                  void *priv_data, RTPDynamicProtocolHandler *handler)\n\n{\n\n    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->ic = ic;\n\n    s->streams = &ic->streams[first_stream_of_set_idx];\n\n    do {\n\n        s->n_streams++;\n\n    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&\n\n             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);\n\n    s->prev_set_id    = -1;\n\n    s->prev_stream_id = -1;\n\n    s->prev_timestamp = -1;\n\n    s->parse_packet = handler->parse_packet;\n\n    s->dynamic_protocol_context = priv_data;\n\n\n\n    return s;\n\n}\n", "idx": 9913, "substitutes": {"s": ["ms", "vs", "ats", "sg", "hs", "cs", "ins", "scl", "details", "se", "ids", "t", "sports", "os", "has", "b", "ears", "w", "comm", "ims", "sd", "conv", "ares", "ports", "gets", "gs", "sts", "ess", "changes", "g", "ies", "sv", "args", "ses", "bs", "services", "plays", "als", "js", "less", "ss", "ops", "sb", "ows", "his", "sc", "ls", "states", "sq", "obj", "sl", "qs", "a", "rs", "sm", "ants", "l", "es", "i", "terms", "ts", "n", "ags", "reads", "sw", "tags", "results", "ns", "ds", "comments", "eps", "p", "uploads", "ps", "so", "aws", "is", "pers", "j", "S", "its", "self", "v", "gc", "c", "h", "sn", "acs", "stats", "fs", "set", "sys", "parts"], "n_streams": ["n_streamats", "n_pathries", "n_streami", "n_streamries", "n_threads", "ngrfollowls", "n__hostats", "n_columni", "ngrstreamS", "n_columns", "n__streamd", "n_Streamries", "n_streamds", "ngrfollowers", "n_Streamds", "n_hostats", "n__streami", "ngrstreams", "n_hostd", "n_trs", "n_trers", "n_streamers", "n_pathd", "n_StreamS", "n_poolds", "n_followls", "n_pools", "n_threadS", "n_columnats", "n__streamats", "n_Streams", "n_paths", "n_pathats", "n__hosts", "n_followers", "n_hosti", "n_columnd", "n_streamd", "ngrstreamls", "n_streamS", "n_threaders", "n_streamls", "n_follows", "n_threadls", "ngrstreamers", "n_followS", "n_pathds", "ngrfollows", "n_hosts", "n__hosti", "ngrfollowS", "n__hostd", "n_trS", "n_pathi", "n_pathS", "n_poolS", "n_poolries", "n_trls", "n__streams"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    QCowL2Meta l2meta;\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    l2meta.nb_clusters = 0;\n\n    qemu_co_queue_init(&l2meta.dependent_requests);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        cluster_offset = l2meta.cluster_offset;\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buffer(&hd_qiov, cluster_data);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_link_l2(bs, &l2meta);\n\n\n\n        run_dependent_requests(s, &l2meta);\n\n\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 9922, "substitutes": {"bs": ["ms", "lb", "obs", "vs", "qs", "aos", "bp", "rs", "hs", "gs", "bes", "bc", "BS", "cs", "outs", "bits", "bm", "ses", "fps", "aus", "js", "its", "ss", "ts", "bos", "lbs", "bps", "ubs", "ubis", "os", "sb", "b", "bis", "bh", "ns", "fs", "blog", "ls", "bt", "ds", "sys"], "sector_num": ["driver_family", "sector2num", "sector_orig", "sectorNamenumber", "sectoripnb", " sector_NUM", "sector_mon", "ector_number", "sector_number", " sector_number", "sector2mon", "sectoripnum", "driver_num", "driver_con", "sector_NUM", "sector2number", "sectorNamemon", "sector2orig", "sector2nm", "sectoripcon", "ector_orig", "sector_family", " sector_nm", "sector_nm", "sectorNameorig", "sector_con", "sectorNamenum", "sector2NUM", "sectoripfamily", "sectorNamecon", "sector_nb", "ector_mon", "driver_nb", "sectorNamefamily", "sectorNamenb", "ector_num"], "remaining_sectors": ["remaining_sgments", "remaining_suors", "remaining_pselements", "remaining_welements", "remaining_weors", "remaining_suvers", "remaining_weonents", "remaining_pevers", "remaining_wectors", "remaining_perseors", "remaining_svisors", "remaining_vectors", "remaining_spellers", "remaining_pectors", "remaining_sellers", "remaining_spevers", "remaining_pseonents", "remaining_seonents", "remaining_sors", "remaining_sevisors", "remaining_persevisors", "remaining_speors", "remaining_veors", "remaining_sctors", "remaining_persegments", "remaining_sullers", "remaining_pellers", "remaining_vevisors", "remaining_veonents", "remaining_velements", "remaining_suctors", "remaining_seors", "remaining_selements", "remaining_peors", "remaining_severs", "remaining_pseors", "remaining_spectors", "remaining_vegments", "remaining_segments", "remaining_psectors", "remaining_persectors"], "qiov": ["sqiev", " qrolet", "iqiop", "quiour", "qveh", "sqiop", "qiour", " qiour", "quiop", "sqrolet", "kiev", "iqiv", "ckiop", "qqiop", "qiev", "qiop", "ckiov", "qiv", "qrolet", "kiour", "sqiov", "ckiv", "quveh", "qqiov", " qiev", "qqiev", "kveh", "quiv", "quiev", "iqrolet", "qurolet", "quiov", "ckrolet", " qiop", " qveh", "kiov", "iqiov", "qqrolet"], "s": ["ms", "vs", "ats", "hs", "cs", "m", "bits", "details", "t", "sports", "os", "has", "b", "w", "comm", "ims", "ares", "abilities", "settings", "sp", "gs", "sts", "bes", "changes", "g", "sv", "args", "sam", "ses", "services", "less", "js", "als", "ss", "conf", "sets", "sb", "ls", "sq", "spec", "sl", "qs", "a", "rs", "as", "es", "i", "ts", "tags", "ns", "ds", "eps", "p", "ps", "so", "aws", "is", "j", "S", "its", "series", "ssl", "v", "c", "bis", "h", "sn", "stats", "fs", "set", "sys", "parts"], "index_in_cluster": ["index_in_plorum", "index_in_clause", "index_in_Clusters", "index_in_ploser", "index_in_scusters", "index_in_gloser", "index_in_Clorum", "index_in_aclorum", "index_in_pluster", "index_in_scoser", "index_in_aclusters", "index_in_Clause", "index_in_plusters", "index_in_clorum", "index_in_clust", "index_in_glust", "index_in_Clust", "index_in_acloser", "index_in_aclause", "index_in_scust", "index_in_closer", "index_in_Closer", "index_in_Cluster", "index_in_gluster", "index_in_aclust", "index_in_clusters", "index_in_acluster", "index_in_scuster", "index_in_glusters", "index_in_plust", "index_in_plause"], "n_end": ["nm___pad", " n_nd", "n_nd", "n_next", "n_until", "n_END", "n_pad", "N_length", "N_END", "n___end", "nn_end", "nm_conn", "newpad", "nm_end", "nm___end", " n_ended", "nn_offset", "n_ended", "N_end", "n_ends", "nm_pad", "N_min", "N_next", "n_length", "n__nd", "newconn", "n__ended", "n_offset", "n__end", "n_conn", "n_min", "nm___conn", "nn_ends", "newend", "N_until", "n___conn", "n___pad"], "ret": ["ert", "tt", "len", "tr", "lt", "success", "reset", " RET", "status", "lit", "flag", "print", "nz", "RET", "job", "nt", "rev", "del", "jp", "ref", "mt", "Return", "def", "ptr", "terror", "alt", "mem", "ext", "try", "cont", "t", "mel", "rets", "deg", "virtual", "val", "Ret", "ctr", "tech", "encrypted", "cmd", "rt", "elt", "re", "res", "it", "cert", "quad", "rm", "gt", "ll", "ft", "out"], "cur_nr_sectors": ["cur_nr_peors", "cur_nr_vecs", "cur_nr_vekers", "cur_nr_seors", "cur_nr_shkers", "cur_nr_sellers", "cur_nr_SEgments", "cur_nr_spectors", "cur_nr_pellers", "cur_nr_segments", "cur_nr_SEctors", "cur_nr_pekers", "cur_nr_pecs", "cur_nr_vellers", "cur_nr_spegments", "cur_nr_shllers", "cur_nr_secs", "cur_nr_SEcs", "cur_nr_vectors", "cur_nr_meors", "cur_nr_SEors", "cur_nr_vegments", "cur_nr_mections", "cur_nr_vections", "cur_nr_speors", "cur_nr_shors", "cur_nr_sections", "cur_nr_shctors", "cur_nr_mectors", "cur_nr_spections", "cur_nr_sekers", "cur_nr_pegments", "cur_nr_megments", "cur_nr_pectors", "cur_nr_veors"], "l2meta": ["l3perm", " l2Meta", " l_mu", " l_eta", "l42perm", "l3metadata", "l3met", "l4metadata", "fl5meta", " l3Meta", "L2metadata", "l2mu", "l_meta", "l_eta", "l2eta", "l5metadata", "fl5met", "l2metadata", " l4dirty", "l5meta", "L3meta", "l_metadata", "l4perm", "l4Meta", " l4meta", "L3metadata", "l_options", "l42Meta", "l22options", "l42metadata", " l3meta", "l6metadata", "fl5metadata", "l22Meta", "l_mu", " l2dirty", "l5eta", " l3options", "L3Meta", "fl5eta", "fl2metadata", "l2Meta", " l2metadata", " l_meta", " l_metadata", "l3meta", "l2perm", "l2dirty", "fl2meta", "L2meta", "l3eta", " l3metadata", "l_Meta", "l6mu", "l5mu", " l2mu", "l4dirty", "L2Meta", "l3Meta", "l42meta", "fl2eta", " l4metadata", "l6meta", "L2perm", "l2met", "l22meta", "l22metadata", "l2options", "L3perm", "fl2met", "l5met", "l6met", " l4Meta", " l2eta", "l6eta", " l2options", "l4meta", "l3dirty", "l3options"], "cluster_offset": ["clust_error", "clusterablesize", "cluster___offset", "clluster___off", "cluster67off", "cluster_size", "clluster_count", "cluster___size", "cluster___key", "cluster___count", "cluster_start", "cluster___position", "cluster2offset", "cluster___off", "clusterablecache", "cluster_ptr", "cluster2position", "clluster___ptr", "clust_style", "cluster67offset", "cluster_key", "cluster67position", "cluster_cache", "clusters_cache", "clusters_size", "cluster_style", "clluster_ptr", "clusters_key", "cluster2count", "clluster___position", "clluster_position", "cluster67ptr", "cluster_position", "clust_offset", "cluster_count", "clust_start", "clluster_size", "cluster_error", "cluster___cache", "cluster2size", "clluster_offset", "clusterablekey", "clluster___offset", "clusters_offset", "cluster___ptr", "clluster_off", "clusterableoffset", "cluster_off"], "hd_qiov": ["hd_sqdyl", "hd___qiv", "hd_ckiov", "hd_krolet", "hd_ckiv", "hd___kiv", "hd___qiour", "hd_aqiov", "hd___kiour", "hd_ckovi", "hd_qdyl", "hd_eqiov", "hd_aqversive", "hd_eqovi", "hd___kiov", "hd_kiov", "hd_iqovo", "hd_qiv", "hd_quovi", "hd_eqiev", "hd_eqversive", "hd___kovo", "hd_quiov", "hd___qiev", "hd_kiv", "hd_kiev", "hd_iqovi", "hd_kiour", "hd___qovo", "hd_qiour", "hd_qversive", "hd_qovo", "hd___quiov", "hd_sqiov", "hd_aqovi", "hd_giour", "hd_iqiv", "hd_quiev", "hd_qrolet", "hd_govo", "hd_aqiev", "hd_iqiour", "hd_sqrolet", "hd___quovi", "hd_quversive", "hd_ckiev", "hd_qurolet", "hd_qiev", "hd___quiev", "hd_kovo", "hd___quiv", "hd_iqiev", "hd_sqiev", "hd_iqiov", "hd___qovi", "hd___qiov", "hd_qudyl", "hd_giv", "hd_qovi", "hd_giov", "hd_kdyl", "hd_quiv"], "cluster_data": ["cluster_supported", "clute_supported", "cluster_DATA", "cluster2step", "clusterlistdata", "clructureistdata", "clructureistlen", "cluster_next", "cluster2cache", "cluster____data", "clusteristlen", "cluster2data", "clute_data", "cluster_len", "clructure_data", "clusteristbuffer", "cluster_buffer", "clusters_data", "clusters_ops", "clructure_buffer", "clusteristnext", "clusterablebuffer", "clructure_len", "clute_offset", "cluster____cache", "clusterlistDATA", "clusterablenext", "cluster____ops", "cluster_cache", "clusters_step", "clructureistbuffer", "clusters_cache", "clusterablelen", "cluster2ops", "cluster_ops", "cluster_step", "clusterlistoffset", "clusteristdata", "clructure_next", "clructureistnext", "cluster____step", "clusterabledata", "clusterlistsupported", "clute_DATA"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n\n                   VhostBackendType backend_type, bool force)\n\n{\n\n    uint64_t features;\n\n    int i, r;\n\n\n\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -1;\n\n    }\n\n\n\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n\n        close((uintptr_t)opaque);\n\n        return -errno;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->migration_blocker = NULL;\n\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n\n        error_setg(&hdev->migration_blocker,\n\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n\n        migrate_add_blocker(hdev->migration_blocker);\n\n    }\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    hdev->memory_changed = false;\n\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n\n    hdev->force = force;\n\n    return 0;\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n\n    }\n\nfail:\n\n    r = -errno;\n\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n\n    return r;\n\n}\n", "idx": 9929, "substitutes": {"hdev": ["hhobj", "hhandle", "ohDev", "ohpad", "hhdes", "hdes", "ehDEV", "hmdev", "hvar", " haddr", " hgu", "ehaddr", " hdef", "chDev", "hpad", " hhandle", "Hvar", " hcast", "shdevice", "handledevice", "hdata", "vdata", "hobj", " hobj", "Hdev", "ehdev", "Hev", "ehgu", "hpro", "ehgo", "hostdevice", "hhdev", "handlepro", "chdevice", "vev", "htdata", "vdef", "ehdes", "vDev", "handleDEV", "Hdevice", "hmdata", "hev", "vdev", " hpad", "hdevice", "ohdata", "hostdev", "chdev", "Hdef", "hostev", "HDev", " hgo", "hmvar", "ehpro", "vdevice", "hgo", "ehev", "ohdes", "htdev", " hDEV", "hgu", "hDev", "ohdev", "hcast", " hpro", "hmdevice", " hdevice", "shev", "ohcast", "vpad", "ohpro", "haddr", "hmDEV", "Hdata", "shgu", "hDEV", "Hcast", "vDEV", "chDEV", "htpad", " hvar", " hdata", "HDEV", "shdev", " hdes", "htdevice", "hdef", " hDev", "hhdevice", "hmDev", "Haddr", "handledev", "ohgo", "vpro", "hhev", "ehobj", "hhgu", "hhhandle", "ehdevice", " hev", "ehhandle", "ohdevice", "hostDEV"], "opaque": ["obaques", "iopque", "OPent", "pacity", " opane", "ogane", "pque", "oent", "oaques", "opaques", "opatile", "opque", "opaco", "appaque", "opoid", "OPaco", "iopaques", "opent", " opaques", "boener", "obane", " opaco", "OPaque", "opane", "iopacity", "oaque", "oppoid", "booid", "ogaque", "obaque", "opener", "ogacity", " opacity", "appoid", "paque", "OPaques", "oppener", " opent", "oppaque", " opque", "obacity", "paques", "oppatile", "obque", "ogque", "iopaque", "boaque", "boatile", "appener", "oaco", "appatile", "opacity"], "backend_type": ["backend_key", "backrend_family", "backendetyowner", "backline_owner", "backlineTytype", "backrend_name", "backline_type", "backline_Type", "backrend_Type", "backlineTyType", "backendTyType", "backrend_type", "backend_owner", "backendTytype", "backlineTyowner", "backendetytype", "backendetyType", "backend_name", "backline_key", "backendTykey", "backlineTykey", "backend_Type", "backendTyowner", "backend_family", "backendetykey"], "force": [" overwrite", "Force", "secure", "write", "hide", "enable", " quiet", "fork", "quiet", " persistent", " suppress", " forced", " refresh", "dirty", " permanent", "remote", "fast", " ignore", "raise", " fake", "forced", " confirm", "ground", "apply", " defer"], "features": ["abilities", "events", "ports", "classes", "acts", "frames", "Features", "feature", "names", "settings", "weights", "fts", "types", "tests", "format", "devices", "ensions", "versions", "modules", "words", "ints", "files", "changes", "bits", "pins", "orts", "fixes", " Features", "forms", "relations", "services", "effects", "details", "its", " feat", "rows", "fields", "addons", "feat", "wcs", "plugins", "ops", "properties", "tags", "eatures", "reports", "results", "flags", "sections", "fs", "stats", "options", "fc", "ributes", "faces", "vals", "players", "actions", "facts", "states", "performance", "items"], "i": ["ami", "id", "u", "ai", "I", "me", "ie", "li", "q", "err", "iq", "p", "sim", "f", "ind", "ui", "ip", "m", "l", "port", "ti", "ia", "ic", "mu", "in", "cli", "mi", "is", "chain", "j", "im", "ix", "index", "n", "y", "iu", "ci", "phi", "v", "info", "zi", "xi", "e", "multi", "qi", "b", "gi", "di", "bi", "pi", "si", "it", "x", "batch", "ini", " ii", "hi", "s", "asi", "ii"], "r": ["kr", "arr", "tr", "run", "hr", "entry", "record", "lr", "q", "rs", "or", "err", "rb", "p", "rf", "ren", "ry", "error", "d", "rw", "g", "m", "attr", "rn", "mr", "rr", "row", "ir", "br", "rel", "rg", "repl", "rc", "rd", "nr", "fr", "radius", "pr", "rem", "e", "c", "h", "ro", "rt", "re", "sr", "res", "er", "rm", "result", "ur", "rer", "R", "cr", "response", "rar", "ar", "dr", "ret"]}}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        int r, g, b;\n\n\n\n        switch (pix_fmt) {\n\n        case AV_PIX_FMT_RGB8:\n\n            r = (i>>5    )*36;\n\n            g = ((i>>2)&7)*36;\n\n            b = (i&3     )*85;\n\n            break;\n\n        case AV_PIX_FMT_BGR8:\n\n            b = (i>>6    )*85;\n\n            g = ((i>>3)&7)*36;\n\n            r = (i&7     )*36;\n\n            break;\n\n        case AV_PIX_FMT_RGB4_BYTE:\n\n            r = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            b = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_BGR4_BYTE:\n\n            b = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            r = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_GRAY8:\n\n            r = b = g = i;\n\n            break;\n\n        default:\n\n            return AVERROR(EINVAL);\n\n        }\n\n        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9934, "substitutes": {"pal": ["ette", "Pal", "ph", "phal", "al", "pat", "mat", "pp", "li", "list", "cel", "p", "ass", "bl", "phil", "isal", "bin", "pu", "late", "ap", "pixel", "mal", "ell", "pill", "all", "mem", " Pal", "als", "data", "pac", "ele", "px", " PAL", "jl", "pl", "val", "pol", "dat", " pl", "ul", "vals", "table", "att", "pack", "el", "le", "out"], "pix_fmt": ["pix_fgt", "pix_Ftype", "pix_vgt", "pix_fnt", "pix_vmt", "pix_fcmt", "pix_Fformat", "pix_mdr", "pix_Fmt", "pix_flt", "pix_mgt", "pix_cmt", "pix_mmt", "pix_vlt", "pix_fcformat", "pix_ftype", "pix_fdr", "pix_fformat", "pix_Fnt", "pix_cnt", "pix_fcnt", "pix_vdr", "pix_ctype", "pix_mlt", "pix_cformat", "pix_fctype"], "i": [" m", "u", "print", "o", "mount", "m", " pi", " multi", "im", "y", "t", "ci", "zi", " mi", "gi", "pi", "adi", "oi", "ji", "ims", "key", "ami", "status", "I", "at", "li", "init", "ri", "ex", "ind", "ki", "ti", "ia", " ti", "mi", "ix", "xi", "multi", "qi", "e", " index", "si", "batch", "id", "ai", "ei", "err", "go", "k", "point", "iri", " li", "ui", "ip", "l", "ic", "in", "index", "n", "phi", "it", "ini", " bi", "s", " iter", " my", "out", "ii", "me", "io", " is", "list", "p", "sim", "cli", "is", "j", "iu", "v", "ik", " out", "c", "di", "bi", "x", "mac", " ii", "name", " j", "ij"], "r": ["u", "a", "lr", "rb", "rs", "err", "k", "ri", "p", "f", "d", "l", "m", "ra", "mr", "rr", "ir", "j", "br", "t", "rg", "reg", "rc", "v", "rd", "fr", "pr", "e", "c", "h", "ro", "rt", "re", "w", "sr", "res", "er", "rm", "x", "it", "ur", "vr", "s", "R", "cr", "rar", "ar", "dr", "ret"], "g": ["ge", "gg", "u", "gp", "gm", "go", "tg", "p", "gs", "f", "pg", "mg", "gr", "d", "gl", "l", "m", "gz", "ger", "G", "ig", "bg", "eg", "gd", "j", "ga", "rg", "fg", "reg", "v", "gray", "gu", "gc", "c", "h", "gi", "gy", "ag", "og", "er", "z", "gb", "gt", "erg", "group", "msg", "dr"], "b": ["ba", "lb", "be", "u", "mb", "bf", "ub", "a", "base", "rb", "bp", "p", "bl", "o", "f", "bin", "B", "bc", "l", "bm", "fb", "cb", "ab", "bs", "bg", "j", "br", "n", "y", "eb", "v", "bo", "e", "sb", "c", "h", "bh", "bi", "er", "bb", "ob", "by", "nb", "gb", "ib", "db", "s", "binary"]}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "void qmp_transaction(TransactionActionList *dev_list, Error **errp)\n\n{\n\n    TransactionActionList *dev_entry = dev_list;\n\n    BlkTransactionState *state, *next;\n\n    Error *local_err = NULL;\n\n\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;\n\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n\n\n    /* drain all i/o before any operations */\n\n    bdrv_drain_all();\n\n\n\n    /* We don't do anything in this loop that commits us to the operations */\n\n    while (NULL != dev_entry) {\n\n        TransactionAction *dev_info = NULL;\n\n        const BdrvActionOps *ops;\n\n\n\n        dev_info = dev_entry->value;\n\n        dev_entry = dev_entry->next;\n\n\n\n        assert(dev_info->kind < ARRAY_SIZE(actions));\n\n\n\n        ops = &actions[dev_info->kind];\n\n        assert(ops->instance_size > 0);\n\n\n\n        state = g_malloc0(ops->instance_size);\n\n        state->ops = ops;\n\n        state->action = dev_info;\n\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n\n\n        state->ops->prepare(state, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto delete_and_fail;\n\n        }\n\n    }\n\n\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->commit) {\n\n            state->ops->commit(state);\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    goto exit;\n\n\n\ndelete_and_fail:\n\n    /* failure, and it is all-or-none; roll back all operations */\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->abort) {\n\n            state->ops->abort(state);\n\n        }\n\n    }\n\nexit:\n\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n\n        if (state->ops->clean) {\n\n            state->ops->clean(state);\n\n        }\n\n        g_free(state);\n\n    }\n\n}\n", "idx": 9943, "substitutes": {"dev_list": ["dev2lists", "DEV_list", "DEV_List", "dev2table", "dev__def", "devactlist", " dev_def", "dev_lists", "DEV_type", "dev__entry", " dev__def", "dev_List", "devactList", "devacttype", "dev_type", "dev_table", "dev2type", "dev2list", "DEV_table", "dev__lists", "devacttable", "dev2List", "dev2def", " dev__entry", " dev__list", "dev2entry", "dev__list", " dev_lists", "dev_def", " dev__lists"], "errp": [" errnp", "errr", "arrp", " erp", "errnp", " errpa", "arrm", "arrr", " erpa", "errm", "rrr", "rrm", "rrp", "warnP", "arrP", "warnpa", " erP", " errm", " errr", " errP", "errpa", "rrP", "errP", "warnp", " ernp", "warnnp"], "dev_entry": ["devixry", "ev_row", "dev8member", "dev2row", "dev_start", "dev2member", " dev_start", "dev_Entry", " dev2member", " dev_Entry", "ev_list", "dev8search", "dev_ry", "dev2entry", " dev_ry", " dev_cue", "devrowry", "dev2Entry", "dev_search", "devixcue", "ev_info", "ev_Entry", "dev_cue", "devrowcue", "devrowentry", "devrowstart", "dev_member", "devixentry", "dev_row", "ev_entry", "dev8entry", "dev2search", " dev2search", "devixstart", " dev_search", " dev2entry", " dev_member"], "state": ["config", "update", "print", "range", "city", "post", "ry", "m", "parent", "session", "queue", "storage", "row", "data", "t", "check", "result", "context", "memory", "see", "public", "user", "size", "output", "key", "inner", "art", "run", "power", "status", "al", "call", "resource", "path", "init", "value", "job", "STATE", "task", "future", "request", "loop", "try", "that", "test", "version", "new", "conn", "count", "close", "rule", "batch", "dict", "states", "draw", "current", "runner", "buffer", "back", "policy", "step", "area", "form", "trans", "component", "instance", "scope", "type", "local", "trace", "State", "index", "n", "connection", "reg", "zone", "info", "remote", "start", "er", "it", "db", "module", "out", "entry", "base", "event", "list", "to", "ps", "this", "client", "port", "handle", "core", "monitor", "root", "commit", "self", "cache", "lock", "stats", "tag", "st", "stat", "private", "name", "store"], "next": ["key", "inner", "success", "current", "entry", "nl", "path", "end", "prev", "Next", "step", "child", "ng", "value", "seq", "ne", "nt", "first", "sec", "future", "name", "this", "sequence", "ptr", "parent", "inv", "index", "chain", "data", "owner", "node", "last", "new", "self", "action", "asc", "bi", "adj", "start", "er", "ent", "link", "result", "set", "gt", "ner", "head", "max", "response", "pre"], "local_err": ["self___err", "self___rr", "local___notice", "loc_eas", "local_error", "self___buf", "local_eas", "personal_er", "loc_err", "personal___error", "local___cr", "local2err", "self_notice", "localpybuf", " local_buf", "local2rr", "local2notice", "loc_er", "personal_err", "loc_msg", "localpyrr", "local_er", "local___buf", "local___er", "personal___er", "local___rr", " local_cr", "self_buf", "personal___err", "personal_notice", "local2buf", "localpynotice", "local___error", "local_buf", "self___notice", "local_rr", "local_cr", "local_msg", "local_notice", "localpyerr", "self_err", "personal_error", "local___err", "personal___notice", "self_rr"], "dev_info": ["dev_Info", " dev_Info", "Dev_info", "Dev_INFO", "dev__info", "Dev_no", "Dev_fo", "devPkind", " dev_INFO", "dev__inf", "ev_Info", "devPinfo", "ev_info", "dev__fo", "dev__no", "devPINFO", " dev__INFO", "ev_fo", " dev_inf", "dev__INFO", "dev_kind", " dev__info", "dev_no", "ev_entry", " dev_kind", "dev_inf", "ev_kind", "dev_INFO", "devPInfo", "devPinf", " dev__inf", "dev_fo"], "ops": ["ms", "events", "vs", "op", "orders", "bits", "ins", "values", "groups", "uts", "ups", "oops", "ands", "os", "hops", "ips", "caps", "times", "options", "checks", "ims", "items", "abilities", "opers", "ports", "aps", "settings", "sts", "opens", "changes", "outs", "ots", "opa", "args", "xs", "utils", "services", "als", "ows", "vals", "tools", "vers", "asts", "params", "apps", "tops", "obj", "names", "rs", "docs", "orts", "pps", "ts", "nets", "ds", "cons", "obs", "arts", "Ops", "oms", "eps", "modules", "ps", "oper", "forms", "posts", "its", "ils", "OPS", "stats", "flags", "actions"]}}
{"project": "qemu", "commit_id": "d15fda639ba356148fc7161bba863866fd2797ef", "target": 0, "func": "static int intel_hda_init(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n    uint8_t *conf = d->pci.config;\n\n\n\n    d->name = d->pci.qdev.info->name;\n\n\n\n    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(conf, 0x2668);\n\n    pci_config_set_revision(conf, 1);\n\n    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);\n\n    pci_config_set_interrupt_pin(conf, 1);\n\n\n\n    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */\n\n    conf[0x40] = 0x01;\n\n\n\n    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,\n\n                                          intel_hda_mmio_write, d,\n\n                                          DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);\n\n    if (d->msi) {\n\n        msi_init(&d->pci, 0x50, 1, true, false);\n\n    }\n\n\n\n    hda_codec_bus_init(&d->pci.qdev, &d->codecs,\n\n                       intel_hda_response, intel_hda_xfer);\n\n\n\n    return 0;\n\n}\n", "idx": 9956, "substitutes": {"pci": [" pcci", "pdu", "mcm", "ppmi", "Pct", "cpc", "persci", "cci", "mpi", "Pci", "Poci", " pct", "opcm", "perspi", "fpdu", "pct", "ppcm", "cpci", "hci", " pda", "pki", "ipci", "perscci", "apki", "cpcci", "apci", " pcm", "Pki", "mci", "ppci", " pdu", "fpcci", "appi", "apoci", "pcda", "cpct", "mki", "mmi", "opmi", "ipki", "apc", "cpki", "pcci", "cppi", "cpcm", "ipcm", "ppi", "ccm", "Ppi", "pc", "opci", "poci", "pcki", "ppki", "gcci", "cpda", "hoci", " ppi", "gki", "pcct", "perscm", "ippi", " pc", "fpci", "cpi", "pcm", "hpi", "opki", "Pcci", "pda", "gci", "pmi", "ccci", "fpct", "gcm", "hcm", "hki", " pki", "Pdu"], "d": ["td", "dd", "send", "fd", "config", "q", "p", "o", "dev", "f", "ind", "ld", "da", "dc", "g", "pd", "l", "m", "nd", "dx", "i", "did", "dn", "D", "ord", "r", "md", "j", "de", "data", "done", "n", "y", "dl", "ad", "t", "new", "rd", "v", "cfg", "e", "b", "c", "ed", "h", "di", "dat", "des", "bd", "w", "dp", "z", "dj", "dict", "db", "dh", "dm", "debug", "sd", "dt", "s", "ds", "dr"], "conf": ["fab", "acc", "Conf", "spec", "priv", "con", "map", "config", "ch", "q", "init", "sch", "func", "sub", "f", "cp", "cf", "sec", "plan", "ref", "def", "um", "cb", "auth", "confirmed", "cc", "aff", "try", "pb", "scan", "fg", "conn", "rc", "info", "cfg", "irm", "Con", "cache", "inf", "c", "comment", "cmd", "com", "query", "ns", "cn", "cm", "opt", "nb", "att", "gb", "comm", "msg", "Config", "app", "conv", "ca"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n\n        raw_aio_remove(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 9961, "substitutes": {"bs": ["obs", "locks", "qs", "cks", "aos", "bp", "bas", "gs", "bes", "bc", "BS", "cs", "bm", "bits", "ses", "bn", "iss", "aus", "irms", "ys", "js", "its", "bos", "pb", "lbs", "bps", "sb", "b", "bis", "bh", "ns", "bi", "fs", "bb", "blog", "ls"], "sector_num": ["sectorNamepos", "sectorNamenumber", "sector_mon", "sector9pos", "ector_number", "sector_number", " sector_number", "sector9num", "sectorNameenum", "sector_pos", " sector_enum", "sector9enum", " sector_pos", "sectorNamenum", "ector_no", "sector9number", "ector_num", "ector_mon", "sector_enum", "sector_no"], "qiov": ["qovi", "xovi", "qkov", "qiour", " qiour", "xiour", " qovi", "Qovi", "kkov", "chiev", "kiev", "Qiour", "qiev", "qiop", "Qiov", "chkov", "kiour", "xiop", " qkov", " qiev", "xiov", "chiov", " qiop", "kiov", "chiour", "Qiop"], "nb_sectors": ["nb_velements", "nb_vecs", "nb_spections", "nb_serors", "nb_seors", "nb_nevers", "nb_nectors", "nb_veors", "nb_pelements", "nb_serctions", "nb_neors", "nb_sections", "nb_specs", "nb_speors", "nb_severs", "nb_selements", "nb_pevers", "nb_vevers", "nb_spectors", "nb_nelements", "nb_vections", "nb_sercs", "nb_vectors", "nb_secs", "nb_serctors", "nb_pectors", "nb_peors"], "cb": ["lb", "ck", "callback", "CB", "bf", "ub", "ctrl", "rb", "bp", "func", "cp", "abb", "cf", "bc", "rob", "tc", "cd", "fb", "fun", "cc", "obb", "fn", "pb", "eb", "ctx", "rc", "erb", "sb", "b", "c", "nc", "ob", "fc", "nb", "gb", "db", "cv", "bt", "dt", "wb"], "opaque": ["opica", "hopica", "pacity", "pque", "opaques", "mopaques", "ocacity", "opque", "mopica", "iopaques", " opaques", "hopute", "ocaque", "iopute", "ocque", " opacity", "paque", " opque", "iopica", "hopaque", "paques", "mopute", "mopaque", "ocaques", "iopaque", "hopaques", "opute", "opacity"], "acb": [" acbc", "ascb", "accbb", " acbb", " acob", "acbe", "ocbc", "acsb", "cacheb", "aclab", "agbc", "icbt", "aicbc", " lacab", "acab", " acrb", "sacb", "acbb", "adbc", "achbe", " acbe", " lacb", "aicbe", "adbr", "ocsb", "sacbc", "awrb", "cacherb", "accbr", "acbc", "aicrb", "acrb", "icc", "acob", "adb", " lacbc", "achbc", "acbr", "sacc", "cachebc", "cachebt", "acc", "icrb", "iacb", " laczb", "accb", "ocb", "iacbt", "awb", "ascbb", "achb", "adbb", "aclb", "accbc", "ascob", "iacbc", "acbt", "iacrb", "ocbr", "aicb", "sacrb", "achrb", "agzb", "icb", " acsb", "awc", "aclbc", "aczb", "agab", "agb", "awbc", "aclzb", "ascsb", "ocbb", "ocob", "icbc"]}}
{"project": "FFmpeg", "commit_id": "3622988f2162e502727da476a70f5e4f48cd19c5", "target": 0, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n    \n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col) && l1ref0[0] == 0 &&\n\n                ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n    \n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n    \n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && l1ref0[x8 + y8*h->b8_stride] == 0){\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        /* FIXME assumes that L1ref0 used the same ref lists as current frame */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1mv0[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n    \n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n    \n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n    \n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9977, "substitutes": {"h": ["hal", "he", "H", "hm", "ph", "ah", "ssh", "each", "ch", "pp", "q", "eh", "rs", "here", "ct", "k", "hs", "p", "hash", "f", "hz", "th", "g", "m", "l", "hd", "hl", "oh", "cc", "hh", "handle", "hp", "http", "r", "t", "ctx", "v", "rh", "cache", "host", "b", "c", "sh", "sw", "bh", "kh", "hw", "ih", "help", "his", "context", "comm", "dh", "enh", "history", "conv", "ht"], "mb_type": ["mb8TYPE", "mb_order", "mp_Type", "mp_TYPE", "mb___col", "mp_name", "mbetricblock", "mbricorder", "MB_type", "emb_type", "vmricfamily", "mb_model", "mb_style", "mb_test", "mblymodel", "MB_block", "mbrictype", "mb_name", "mbricmodel", "mb___type", "mb_block", "vm_type", "vmrictype", "mb8type", "mb_col", "mbetricType", "mblyfamily", "mblystyle", "mbricType", "mbricstyle", "mb___name", "vm_model", "mp_order", "mbriccol", "vm_style", "mbricfamily", "mb_family", "mb8Type", "mbetrictest", "mp_col", "MB_Type", "vmricstyle", "emb_Type", "emb_TYPE", "MB_test", "mb_TYPE", "mp_type", "mb_ype", "mblytype", "vm_family", "mb8ype", "mbrictest", "mb_Type", "mbricname", "mbetrictype", "mb___order", "vmricmodel", "mp_ype", "emb_style", "mbricblock"], "s": ["ms", "shared", "ports", "sq", "spec", "sl", "ssh", "qs", "a", "ats", "rs", "css", "as", "hs", "p", "gs", "sts", "an", "f", "ps", "south", "changes", "g", "cs", "m", "l", "ins", "sv", "i", "mods", "xs", "bs", "session", "cpp", "is", "js", "als", "S", "ss", "ts", "n", "y", "its", "http", "t", "se", "styles", "v", "wcs", "e", "sb", "b", "os", "c", "sw", "sh", "ns", "stats", "w", "fs", "sections", "comm", "ls", "ims", "conv", "ds", "sys", "parts"], "l1mv0": ["l1Mvp1", "l1mf1", "l1mf_", "l1mvals", "l1Mv_", "l1mf0", "l1mvp1", "l1mj0", "l1Mv0", "l1Mvp0", "l1mj_", "l1mjals", "l1mv_", "l1mv1", "l1mvp0", "l1Mvp_", "l1Mv1", "l1mj1", "l1Mvpals", "l1Mvals", "l1mvp_", "l1mfals", "l1mvpals"], "l1ref0": ["l1reference2", "l1mem2", "l1mem1", "l2ref1", "l2ref0", "l1ref1", "l1ref2", "l1reference1", "l1reference0", "l1Ref2", "l2reference1", "l1Ref1", "l1Ref0", "l2reference0", "l2ref2", "l2reference2", "l1mem0"], "sub_mb_type": ["sub_MB_lock", "sub_mb_lock", "sub_mb_name", "sub_MB_class", "sub_mbdType", "sub_mbdpart", "sub_mblyTYPE", "sub_MB_TYPE", "sub_mb_class", "sub_mb_TYPE", "sub_mbdtype", "sub_mbdname", "sub_mblyType", "sub_mb_key", "sub_mb_Type", "sub_MB_Type", "sub_mb_types", "sub_mblytype", "sub_MB_part", "sub_MB_types", "sub_MB_key", "sub_MB_name", "sub_mblykey", "sub_mb_part", "sub_MB_type"], "i8": ["pi8", "b8", "pi6", "l6", "b08", "i6", "i9", "pi9", "pi08", "i08", "l8", "l08", "b6", "b9", "l9"], "i4": ["I8", "pi8", " i04", "pi04", "I04", "pi4", "I4", "i04"]}}
{"project": "qemu", "commit_id": "e3af7c788b73a6495eb9d94992ef11f6ad6f3c56", "target": 0, "func": "static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)\n\n{\n\n    uint32_t ret;\n\n\n\n    switch (ot) {\n\n    case MO_8:\n\n        ret = cpu_ldub_code(env, s->pc);\n\n        s->pc++;\n\n        break;\n\n    case MO_16:\n\n        ret = cpu_lduw_code(env, s->pc);\n\n        s->pc += 2;\n\n        break;\n\n    case MO_32:\n\n#ifdef TARGET_X86_64\n\n    case MO_64:\n\n#endif\n\n        ret = cpu_ldl_code(env, s->pc);\n\n        s->pc += 4;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n    return ret;\n\n}\n", "idx": 10000, "substitutes": {"env": ["bench", "ef", "vs", "net", "ja", "config", "et", "here", "end", "erd", "ev", "den", "ec", "sp", "buf", "ve", "engine", "enter", "vp", "esm", "gate", "te", "ds", "sv", "ptr", "Environment", "cb", "vt", "window", "en", "shell", "ger", "txt", "server", "queue", "outer", "ts", "n", "esc", "ctx", "conn", "v", "conf", "self", "environment", "e", "sb", "sen", "h", "w", "nc", "er", "him", "sc", "context", "cv", "ner", "console", "state", "viron"], "s": ["src", "vs", "sq", "spec", "syn", "sl", "qs", "source", "socket", "eps", "rs", "asm", "span", "sg", "sp", "gs", "sts", "p", "an", "sim", "ps", "south", "ess", "d", "scope", "cs", "client", "sv", "es", "ses", "sam", "bs", "session", "so", "als", "js", "is", "S", "ss", "ts", "n", "pers", "j", "scan", "self", "os", "sb", "b", "sw", "h", "sa", "ns", "stats", "serv", "stat", "st", "set", "sis", "space", "ds", "store"], "ot": ["ota", " ol", "tt", "oc", "mot", "ott", "et", "oot", " got", "or", "ct", "iet", "o", "Mot", "slot", "iat", "ox", " oy", "ol", "ots", " et", "ote", "ort", "oto", " blot", "rot", "not", "hot", "pot", "os", " tot", " quot", "og", "rt", "cot", "bot", "dot", " mot", "gt", "OT", "iot", "bt", "ant"], "ret": ["ert", "lit", "tr", "alf", "pas", " RET", "reset", "url", "oret", "al", "std", "back", "flag", "uf", "match", "print", "det", "RET", "resp", "rep", "nt", "cat", "ref", " Ret", "mt", "pret", "Return", "def", "txt", "ort", "alt", "ter", "ext", "r", "cont", "rel", "liber", "t", "rem", "rets", "v", "reg", "val", "Ret", "xt", "red", "cmd", "rt", "re", "rest", "des", "res", "rm", "cert", "result", "att", "get", "gt", "erey", "ll", "ft", "lt", "out"], "pc": ["page", "doc", "chron", "nic", "pic", "priv", "tp", "sync", "pointer", "pt", "pp", "bp", "ping", "cam", "pan", "proc", "p", "point", "post", "amp", "cp", "pad", "mic", "pu", "bc", "dc", "pkg", "cs", "tc", "client", "pod", "ptr", "cc", "mi", "pers", "pm", "isc", "pb", "mc", "ctx", "conn", "PC", "pr", "c", "pro", "asc", "nc", "cpu", "pi", "disc", "fc", "co", "vc", "pid", "pn", "pa"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void bdrv_throttle_write_timer_cb(void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n\n}\n", "idx": 10026, "substitutes": {"opaque": ["iopque", "oplaque", "opliphany", " opois", "opque", "popois", "iopacity", " Opaque", "oplacement", " Opacement", " Opiphany", "opiphany", "obaque", "oplacity", " opacity", "popacity", "obacity", "popque", " opque", "iopois", "obiphany", "opacement", "iopaque", "obacement", " Opacity", "popaque", "opois", "opacity"], "bs": ["obs", "vs", "ats", "cks", "aos", "bp", "gs", "bl", "sts", "ps", "bc", "BS", "cs", "bm", "ots", "bits", "ab", "bing", "uts", "aus", "ss", "bos", "ts", "pb", "its", "lbs", "bps", "ubs", "os", "sb", "has", "bis", "bh", "acs", "ns", "fs", "ks", "bb", "blog", "ls"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,\n\n                      int rw, int type, int target_page_bits)\n\n{\n\n    hwaddr pteg_off;\n\n    target_ulong pte0, pte1;\n\n    int i, good = -1;\n\n    int ret, r;\n\n\n\n    ret = -1; /* No entry found */\n\n    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);\n\n    for (i = 0; i < 8; i++) {\n\n        if (env->external_htab) {\n\n            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));\n\n            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);\n\n        } else {\n\n            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));\n\n            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);\n\n        }\n\n        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);\n\n        LOG_MMU(\"Load pte from %08\" HWADDR_PRIx \" => \" TARGET_FMT_lx \" \"\n\n                TARGET_FMT_lx \" %d %d %d \" TARGET_FMT_lx \"\\n\",\n\n                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,\n\n                (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n        LOG_MMU(\"found PTE at addr %08\" HWADDR_PRIx \" prot=%01x ret=%d\\n\",\n\n                ctx->raddr, ctx->prot, ret);\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n            if (env->external_htab) {\n\n                stl_p(env->external_htab + pteg_off + (good * 8) + 4,\n\n                      pte1);\n\n            } else {\n\n                stl_phys_notdirty(env->htab_base + pteg_off +\n\n                                  (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* We have a TLB that saves 4K pages, so let's\n\n     * split a huge page to 4k chunks */\n\n    if (target_page_bits != TARGET_PAGE_BITS) {\n\n        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))\n\n                      & TARGET_PAGE_MASK;\n\n    }\n\n    return ret;\n\n}\n", "idx": 10049, "substitutes": {"env": ["era", "obj", "vs", "ah", "net", "con", "config", "et", "code", "network", "eh", "end", "event", "init", "req", "ev", "uv", "sp", "ec", "dev", "eni", "worker", "eng", "act", "pkg", "np", "te", "desc", "vt", "window", "ka", "en", "server", "inv", "ew", "qt", "equ", "esc", "conn", "v", "conf", "cfg", "info", "environment", "sw", "setup", "cmd", "kh", "hw", "kw", "w", "nc", "operator", "sc", "org", "context", "param", "msg", "cv", "disk", "vm", "nv", "viron"], "ctx": ["jac", "obj", "ck", "nv", "tx", "fw", "cmp", "config", "std", "mom", " cx", "tk", "ct", "func", "p", "kt", "dev", "cp", "nt", "pg", "xc", "bc", "act", "cf", "jp", "tc", "np", "wx", "pkg", "timeout", "cb", "ctl", "window", "cc", "ka", "txt", "addr", "qt", "that", "vm", "handler", "conn", "rc", "conf", "ork", "cfg", "wd", "mk", "gc", "cn", "setup", "cmd", "tmp", "kh", "kb", "rt", "hw", "kw", "nc", "exec", "etc", "cu", "sc", "x", "org", "context", "nil", "co", "cv", "history", "loc", "conv", "ann", "ca"], "h": ["hal", "he", "H", "hr", "q", "k", "hs", "home", "p", "hash", "height", "o", "f", "g", "l", "m", "hd", "hl", "window", "oh", "hh", "handle", "n", "y", "t", "v", "ha", "rh", "host", "b", "c", "sh", "bh", "kh", "hw", "w", "ih", "x", "hi", "dh", "history", "hz", "ht"], "rw": ["hr", "ww", "iw", "write", "wal", "rb", "rs", "wind", "ng", "we", "rf", "buf", "W", "wr", "wx", "ptr", "mr", "wh", "window", "vt", "rr", "usr", "mem", "wa", "ew", "writ", "row", "wn", "wd", "rd", "rc", "rh", "wp", "sw", "wt", "ro", "RW", "rt", "w", "rew", "hw", "kw", "ru", "vr", "writer", "ht", "nw", "wb"], "type": ["op", "id", "typ", "pc", "pe", "ty", "ping", "types", "weight", "p", "sp", "f", "error", "unit", "size", "TYPE", "ref", "ptr", "ver", "kind", "try", "Type", "y", "t", "v", "info", "ype", "lock", "ro", "rt", "er", "Ty", "time", "name", "dt", "state", "style"], "target_page_bits": ["target_page2points", "target_page_points", "target_page64points", "target_page64bits", "target_page_pages", "target_page64pages", "target_hash_bits", "target_page2size", "target_hash64pages", "target_page2pages", "target_hash_pages", "target_hash64points", "target_hash64size", "target_hash_points", "target_hash_size", "target_hash64bits", "target_page2bits", "target_page64size", "target_page_size"], "pteg_off": ["pte_ov", "pteg0down", "pteng_down", "pteng_off", "pteg_Off", "ptejdev", "pte_dev", "pteg0over", "pteg67err", "pteg_o", "pterm_off", "ptegldOff", "ptejov", "ptag_Off", "pteg67OFF", "pteg_over", "pteg_offs", "pteg_down", "ptpeg_off", "pteg48left", "ptejoff", "ptegjov", "ptig_off", "ptig_o", "pterm67OFF", "pteg_old", "pteg67off", "pterm67off", "ptegldoff", "ptpeg_Off", "ptegjdev", "ptpeg_info", "pteg48no", "pteglerr", "ptpeg_dev", "pteg_on", "pteglddev", "pterm_err", "pteg2o", "pteg0old", "pteg2offs", "ptegjoff", "ptegldinfo", "pteret_no", "ptegloff", "pteng_over", "pteg_left", "pteg48off", "pteg_info", "pterm67on", "pterm_OFF", "pteg67on", "pteret_left", "ptig_offs", "pterm67err", "pteg_offset", "ptag_on", "pte_off", "pteg_err", "pteg0off", "pterm_on", "pteglOFF", "pteg_ov", "pteg_no", "pteg_dev", "ptag_off", "pteg2off", "pteng_old", "pteglon", "pteret_off", "ptag_offset", "pteg_OFF"], "pte0": ["portee15", " pte7", "porte195", "ptede1", "porte8", "ptoe1", "portee30", "ptye0", "ptel0", "ptoe2", "ntezero", "ptxe8", "ptec0", "ptee15", "ptoe7", "ptec1", " ptoe7", " ptoe0", "portee_", "ntee3", "ptxe1", "pte15", "ptye3", " ptoe1", "ntee0", "ptede8", "pteg1", "ptezero", "ptme1", "ptye195", "nte1", "pte7", "pteczero", "ptxe0", "ntee1", "pte_", "porte0", "pte3", "nte3", "ptte0", "ptee1", "ptye1", "pte2", "portee8", "ptje0", "portee1", "ptyezero", "porteezero", "ptee195", "ptel1", "ptee_", "ptxe_", "ptee0", "ptme7", "ptoe30", "ptelzero", "pteezero", " pte2", "ptee30", "ptte1", "ptoe3", " ptoe2", "ptele0", "ptele30", "nteezero", "porte15", "ptee3", "ptme2", "ptele1", "portee195", "ptme0", "pte195", "ptje15", "ptoe0", "pteg0", "ptte7", "ptede0", "ptede15", "ptje8", "nte0", "pteg195", "porte1", "portezero", "ptoe_", "ptte2", "ptoe8", "pte30", "porte30", "ptoezero", "pte8", "ptje1", "ptee8", "portee0", "porte_"], "pte1": ["ptee7", "portee2", "ptE3", "porte2", "ptoe1", "ptae2", "ptoe2", "pointoe0", "pointoe3", "ptoe7", "pointoe2", "ntee0", "ptee2", "nte2", "ntee2", "pter0", "pter1", "pointe4", "nte1", "ptE0", "pointoe4", "pointe8", "pte7", "ntee1", "ptae8", "porte0", "pte3", "nte100", "ptea100", "ptee100", "ptte0", "ptte100", "ptee1", "ptea0", "pte2", "portee1", "pointe1", "ptae0", "ptea1", "ptee9", "ptoe9", "ptee0", "portee9", "pointoe1", "porte9", "pointoe8", "ptte1", "ptoe3", "ptE2", "pointe2", "ptee4", "ptee3", "pointe0", "ptE7", "ptoe0", "pte100", "ptea2", "ptae1", "ptoe4", "nte0", "ntee100", "porte1", "ptte2", "ptoe8", "pointe3", "nte7", "pter4", "pte8", "pter2", "ntee7", "ptee8", "portee0", "ptE1", "pte4", "pte9"], "i": ["o", "m", "im", "y", "t", "ci", "zi", "b", "gi", "pi", "oi", "hi", "ji", "ims", "asi", "key", "ami", "status", "I", "li", "init", "ri", "ex", "ind", "g", "ki", "ti", "ia", "mi", "ix", "ma", "xi", "multi", "e", "qi", "si", "z", "id", "ai", "ei", "iq", "f", "ui", "ip", "l", "my", "ic", "in", "index", "n", "phi", "info", "it", "ini", " bi", "s", "ii", "me", "io", "p", "sim", "this", "is", "j", "iu", "v", "c", "bi", "di", "x", " ii", "name", " j"], "ret": ["ert", "len", "lt", "alf", "status", "fi", "et", "io", "back", "flag", "read", "rs", "err", "print", "nz", "RET", "resp", "rf", "buf", "f", "reply", "ry", "nt", "bad", "rev", "ref", "def", "mt", "rit", "ptr", "desc", "vt", "rr", "txt", "usr", "addr", "alt", "mem", "ter", "done", "t", "reg", "rets", "rd", "deg", "rc", "arg", "val", "Ret", "red", "cmd", "found", "rt", "re", "elt", "des", "res", "pert", "rew", "it", "rm", "result", "gt", "ll", "dt", "ft", "dr", "out", "store"], "r": ["kr", "hr", "rb", "rs", "q", "err", "ri", "p", "rf", "d", "g", "m", "l", "mr", "rr", "j", "br", "n", "t", "rg", "rc", "rd", "nr", "v", "e", "b", "c", "red", "reb", "rt", "re", "w", "sr", "res", "er", "ro", "rm", "result", "R", "cr", "rar", "dr"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xcrs(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XCRS\n\n    struct kvm_xcrs xcrs;\n\n\n\n    if (!kvm_has_xcrs())\n\n        return 0;\n\n\n\n    xcrs.nr_xcrs = 1;\n\n    xcrs.flags = 0;\n\n    xcrs.xcrs[0].xcr = 0;\n\n    xcrs.xcrs[0].value = env->xcr0;\n\n    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);\n\n#else\n\n    return 0;\n\n#endif\n\n}\n", "idx": 10055, "substitutes": {"env": ["obj", "vs", "next", "ah", "entry", "pe", "config", "code", "va", "req", "end", "manager", "ev", "proc", "uv", "ve", "sp", "buf", "dev", "ec", "enter", "worker", "eng", "vp", "cur", "sv", "container", "desc", "vt", "window", "en", "server", "ew", "eg", "node", "esc", "ctx", "conn", "v", "conf", "info", "esp", "environment", "e", "tmp", "h", "w", "po", "kernel", "sc", "context", "cv", "vm", "nv", "project"], "xcrs": ["cachearts", "xyrs", "xprs", "coerics", "xyres", "xcrics", "cacheears", "pcredits", "xpcs", "ccsels", "cacheras", "convributes", "pcubs", "ancears", "cvubs", "xyRS", "coeredits", "xcrc", "pcrics", "funcributes", "ancras", " cxrs", "ccards", "convubs", "cfras", "xdres", "abccs", "xcributes", "wxrs", "xcres", "cvributes", "funcras", "abcrs", "xres", "pcrs", "xcRS", "pcributes", "xpards", " cxrc", "xdrs", " conrc", "xdrc", "wxrc", "cfributes", "pcros", "cachers", "lcrys", "chestrs", "xcredits", "xcsels", "chestsels", "xcrys", "xccs", "apacheredits", "coverrys", "abcrys", "apacherics", " cxcs", " conres", "convrs", "apacheributes", "chestdes", "ancarts", "cfrys", " concs", "xcards", "xcs", "apachers", "coverrs", "convros", "wxres", "xrs", "wxRS", "funcrys", "funcarts", "funcears", "xcras", "xyrc", " conrs", "coers", "xcubs", "xprys", " cxres", "xcears", "coeributes", "lcras", "cvros", "ccrs", "xcarts", "coversels", "ancrs", "cfrs", "abcards", "cccs", "cvrs", "xrc", "funcrs", "lcributes", "xcros", "ccdes", "ccrys", "xcdes", "chestrys", "xdRS", "coverdes", "lcrs"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,\n\n                                     TCGv cmp, int32_t disp)\n\n{\n\n    uint64_t dest = ctx->pc + (disp << 2);\n\n    int lab_true = gen_new_label();\n\n\n\n    if (use_goto_tb(ctx, dest)) {\n\n        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);\n\n\n\n        tcg_gen_goto_tb(0);\n\n        tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb);\n\n\n\n        gen_set_label(lab_true);\n\n        tcg_gen_goto_tb(1);\n\n        tcg_gen_movi_i64(cpu_pc, dest);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);\n\n\n\n        return EXIT_GOTO_TB;\n\n    } else {\n\n        TCGv_i64 z = tcg_const_i64(0);\n\n        TCGv_i64 d = tcg_const_i64(dest);\n\n        TCGv_i64 p = tcg_const_i64(ctx->pc);\n\n\n\n        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);\n\n\n\n        tcg_temp_free_i64(z);\n\n        tcg_temp_free_i64(d);\n\n        tcg_temp_free_i64(p);\n\n        return EXIT_PC_UPDATED;\n\n    }\n\n}\n", "idx": 10064, "substitutes": {"ctx": ["jac", "work", "ck", "obj", "xp", "tx", "config", "prefix", "ctrl", "std", "req", "ct", "p", "pool", "Context", "cp", "xc", "bc", "act", "this", "jp", "tc", "pkg", "np", "wx", "timeout", "cb", "unc", "ctl", "cc", "txt", "handle", "mem", "mc", "handler", "cas", "conn", "today", "self", "conf", "cfg", "rc", "gc", "ctr", "tmp", "cmd", "anc", "exec", "hw", "nc", "cm", "kw", "cpu", "pause", "care", "sc", "phys", "context", "cv", "history", "loc", "conv", "sys"], "cond": [" com", " comp", "ck", " lock", " cred", " prep", "cum", "obj", "con", "map", " cop", " exc", "crit", " compl", "init", " cont", "ct", " sched", " con", "bind", "pred", "compl", "resp", "func", " val", "ind", " condition", "act", "xc", "condition", "pos", "cd", " def", "def", " ex", "cc", "expr", " pref", "cont", "cod", " control", "reg", " inf", " conditional", "conf", "comp", "lock", "cmd", "pre", "com", "adj", " compress", "imm", "co", "dict", "Cond", "loc", " pred", " trap"], "cmp": [" comp", "eq", "op", "con", "par", "ctrl", " mp", "prev", "p", "resp", "cp", "omp", "xc", "dc", "vp", "pkg", "tc", "np", "attr", "cb", "desc", "cc", "cod", "rel", "test", "mc", "rc", "conf", "c", "comp", "tmp", "cmd", "emp", " c", "etc", "diff", "sc", "phys", "co", "cv", "mp", "Comp", " cp", "loc", "conv"], "disp": ["dupar", "DisP", "disP", "Disp", "Dispat", "dupat", "Disps", "lyp", "dispat", "lypa", "Dispa", "duP", " dispa", "dispa", " dispatch", "dispatch", "lypatch", "lyps", " dispat", " dispar", "dispar", "Dispatch", "Dispar", "disps", "dup", " disP", " disps"]}}
{"project": "qemu", "commit_id": "1931e26054fdf2b1b84091f0b9662979eb6931ec", "target": 0, "func": "static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)\n\n{\n\n    uint32_t val = pci_default_read_config(d, address, len);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 10081, "substitutes": {"d": ["dose", "dd", "fd", "p", "o", "dev", "f", "da", "dc", "dx", "g", "pd", "m", "cd", "l", "dis", "i", "D", "dn", "md", "r", "de", "n", "dq", "ad", "t", "v", "e", "b", "c", "di", "dm", "sd", "ds", "dr"], "address": ["command", "pc", "each", "prefix", "resource", "Address", "message", "pointer", "add", "buffer", "base", "device", "event", "region", "seek", "point", " addr", "ay", "pad", "variable", "location", "process", " Address", "position", "ptr", "port", "length", "addr", "reference", "index", "attribute", "interface", "ad", "shape", "ace", "memory", "description", "offset", "size"], "len": ["align", "fin", "syn", "nl", "lan", "Len", "seq", "ld", "nt", "l", "pos", "fun", "lf", "length", "bytes", "en", "mem", "ln", "n", "t", "Length", "count", "un", "cmd", "load", "elt", "fil", "el", "ll", "offset", "size", "vol", " length"]}}
{"project": "qemu", "commit_id": "bbade20633a6b4ed7333e03a76038eda98950946", "target": 1, "func": "static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    struct tm tm;\n\n\n\n    if (nret != 8) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    qemu_get_timedate(&tm, spapr->rtc_offset);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, tm.tm_year + 1900);\n\n    rtas_st(rets, 2, tm.tm_mon + 1);\n\n    rtas_st(rets, 3, tm.tm_mday);\n\n    rtas_st(rets, 4, tm.tm_hour);\n\n    rtas_st(rets, 5, tm.tm_min);\n\n    rtas_st(rets, 6, tm.tm_sec);\n\n    rtas_st(rets, 7, 0); /* we don't do nanoseconds */\n\n}\n", "idx": 10104, "substitutes": {"cpu": ["pc", "gpu", "computer", "gp", "processor", "gnu", "nu", "proc", "pu", "cp", "linux", "cow", "jp", "process", "pixel", " CPU", "cli", "core", "CPU", "mem", "clock", "ctx", "conn", "chip", "cmd", "hw", "cu", " proc"], "spapr": ["spaprb", " spapR", "spapsrb", "spaprc", " spapp", "spAPrb", "spapprc", " spaprs", " spiprc", "spapsR", "spAPR", " spipR", "spAPr", "spampr", "spappR", "spAPrs", "spampp", "spappp", " spipp", "spapR", "spamprc", "spappr", " spaprc", "spapsr", "spipR", "spaprs", "spampR", " spipr", "spiprc", "spapsrs", "spipr", " spaprb", "spapp", "spipp"], "token": ["reset", "et", "kt", "ants", "nt", "oken", "ok", "raw", "session", "json", "alt", "aws", "fields", "secret", "tree", "info", "input", "wt", " ret", "result", "features", "Token", "response", "state", "ens", "sys"], "nargs": ["targs", "tnarg", "narg", "tnargs", " narg", "tnret", "trets", "tnrets", "tret", "nrets", "targ", " nrets"], "args": ["ms", "extra", "ars", "rs", "ras", "gs", "ints", "atts", "ins", "terms", "Args", "params", "data", "ts", "arms", "fields", "arg", "ns", "flags", "fs", "res", "vals", "ams", "uments", "ens", "uns", "ret"], "nret": ["NRET", "nnRET", "nreturn", "Nreset", " nRet", " nreturn", "nnrets", " nRET", "nnret", "Nret", "nvRet", "nvrets", "nRet", "NRet", "nnreturn", "nrets", "Nrets", "nvret", " nreset", "nRET", "nreset", "Nreturn", " nrets", "nvreset"], "rets": ["events", "fal", "qs", "gets", "ats", "rs", "fts", "RET", "ires", "els", "sts", "ants", "ints", "nt", "cs", " returns", "outs", "def", "ins", "values", "es", "mt", "vt", "lists", "rises", "uts", "alt", "utes", "details", "aws", "als", "its", "ts", "ils", "ails", "ards", "runs", "cas", "sets", "ads", "Ret", "ips", "iris", "fits", "results", "ets", "rt", "uds", "fs", " ret", "res", "acs", "des", "ns", "vals", " secrets", "sys", "checks", "ces", "uments", "mits", "ls", "gt", "tes", "states", "unts", "bt", "ds", "ens", "uns", "ret"], "tm": ["ms", " m", "mm", "em", "m", "esm", " t", "htm", "t", "mobile", "tis", "mmm", "wt", " tem", "rm", "ims", "tv", " mem", "tim", "td", "tt", "tr", "tx", "hm", "tp", "mx", "gm", "tk", " te", " TM", "wm", "mint", "sam", "ti", "txt", " ti", "mi", "tem", " rm", " ts", " tim", "utm", "ym", "temp", "att", "time", "dm", "mp", " tmp", "utt", "tf", " mc", "nm", "sm", "ram", " td", "tc", " template", "trace", "mem", "ts", "TM", "dim", "tmp", "hw", "him", "amm", "tu", "timer", " tc", "mt", "sim", "fm", " mt", "te", "tif", "tl", "tn", "cms", " mm"]}}
{"project": "qemu", "commit_id": "3d948cdf3760b52238038626a7ffa7d30913060b", "target": 0, "func": "void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    block_job_set_speed(job, speed, errp);\n\n}\n", "idx": 10128, "substitutes": {"device": ["command", "display", "id", "spec", "address", "drive", "path", "network", "slave", "event", "devices", "ident", "dev", "engine", "number", "pad", "component", "block", "location", "label", "position", "serial", "model", "port", "kind", "edge", "handle", "server", "index", "description", "test", "node", "connection", "mode", "directory", "DEV", "remote", "lock", "query", "Device", "product", "pipe", "controller", "link", "driver", "stick", "disk", "module", "name", "project", "template", "pod"], "speed": ["command", "power", "frequency", "spec", " sport", "status", "species", "EED", "config", "priority", "slow", "kick", "seek", "weight", "shock", "strength", "percent", "capacity", "powered", "limit", "sex", "Speed", "length", "port", "efficiency", "rate", "loss", "wage", "interface", "phy", "scale", "spe", " speeds", "start", "rank", "set", "peed", "gain", "size", "delay"], "errp": ["errr", "rrpe", " erp", "rerd", "errpe", "rrpc", " errpc", "rrd", " errpa", " errpl", "rrping", "errpb", "rrr", "rrp", " errping", "rrpb", " erping", "errpc", "rerpb", "usrpa", " errpb", "errpl", " erP", "usrpe", "errd", "usrp", " errr", "errping", " errP", "rerp", "rrP", " erpl", "errpa", "errP", "rrpa", "rerpc", "rrpl", "usrr", " errd", " errpe"], "job": ["command", "obs", "mb", "jump", "runner", "thread", "image", "cam", "build", "cor", "cell", "manager", "sub", "task", "gov", "jobs", "worker", "sim", "name", "block", "jp", "local", "client", "util", "queue", "jj", "row", "j", "node", " jobs", "phy", "photo", "journal", "good", "project", "Job", "lock", "tmp", "cmd", "com", "mob", "mor", "bot", "bug", "batch", "vision", "item", "group", "bar", "db", "user", " hub", "pro", "work"]}}
{"project": "FFmpeg", "commit_id": "e8c4db0d4d07738fed716b1d2f20c85aac944641", "target": 0, "func": "static int create_stream(AVFormatContext *s)\n\n{\n\n    XCBGrabContext *c = s->priv_data;\n\n    AVStream *st      = avformat_new_stream(s, NULL);\n\n    xcb_get_geometry_cookie_t gc;\n\n    xcb_get_geometry_reply_t *geo;\n\n    int ret;\n\n\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = av_parse_video_size(&c->width, &c->height, c->video_size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000000);\n\n\n\n    gc  = xcb_get_geometry(c->conn, c->screen->root);\n\n    geo = xcb_get_geometry_reply(c->conn, gc, NULL);\n\n\n\n    c->width      = FFMIN(geo->width, c->width);\n\n    c->height     = FFMIN(geo->height, c->height);\n\n    c->time_base  = (AVRational){ st->avg_frame_rate.den,\n\n                                  st->avg_frame_rate.num };\n\n    c->time_frame = av_gettime();\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width      = c->width;\n\n    st->codec->height     = c->height;\n\n    st->codec->time_base  = c->time_base;\n\n\n\n    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);\n\n\n\n    free(geo);\n\n\n\n    return ret;\n\n}\n", "idx": 10161, "substitutes": {"s": ["sq", "spec", "qs", "a", "ats", "rs", "as", "hs", "p", "gs", "o", "ec", "f", "sts", "ps", "g", "cs", "l", "sv", "i", "ses", "es", "bs", "cc", "aws", "r", "is", "js", "S", "ss", "ts", "n", "y", "its", "t", "v", "os", "b", "h", "acs", "ns", "w", "fs", "sc", "x", "ls", "ds"], "c": ["col", "con", "pc", "abc", "cus", "call", "config", "cmp", "ct", "enc", "k", "ec", "p", "cl", "f", "cp", "cf", "bc", "xc", "dc", "g", "cur", "cs", "tc", "l", "cd", "d", "cb", "ic", "cc", "ce", "cont", "chain", "coll", "n", "mc", "t", "ctx", "ac", "ci", "rc", "lc", "conf", "v", "cache", "e", "b", "cn", "anc", "comp", "com", "uc", "can", "cm", "nc", "etc", "cu", "fc", "sc", "csv", "comm", "C", "co", "cv", "cr", "content", "vc", "ca"], "st": ["td", "str", "tt", "art", "tr", "net", "sl", "et", "std", "ch", "at", "pt", "St", "put", "end", "ct", "step", "sp", "cl", "sts", "sh", "sm", "ut", "nt", " est", "sec", "stable", "th", "stop", "sv", "ust", "stack", "ste", "usr", "cont", "stage", "ist", "ts", "se", "sat", "t", "ctx", "fr", "ast", "sw", "ost", "ST", "irst", "sn", "rt", "est", "ot", "rest", "start", "w", "ent", "sc", "sta", "stat", "it", "ft", "set", "etc", "co", "cr", "nd", "inst", "state", "mt", "store"], "gc": ["gui", "nic", " mc", "gg", "pc", "gpu", "gn", "gm", "gp", "go", "sg", "GC", "ec", "pg", "bc", "dc", "g", "tc", "cs", "gz", " g", "cb", "ctl", "cc", "ig", "eg", "ga", "icc", " GC", "cz", "mc", "ac", "rg", " dc", "lc", "wt", "gor", "nc", "cm", "cu", "sc", "fc", "disc", "gb", "co"], "geo": ["memoa", "gebo", "geos", "Geo", "seos", "geoto", "leo", "leonet", "geology", "jeos", "leom", "geonet", "eo", "geom", "veonet", "Geoa", "veos", "Geology", "ideoto", "maology", "memo", "seo", "gerof", "gero", "seonet", "veom", "ideof", "seoe", "ideos", "seot", " geot", "genoto", "geof", "genology", "leology", "eos", "GEology", "ideology", "Gebo", "GEo", "geroto", "memom", "seology", "gerology", "geno", "GEom", "geoe", " geoa", " geom", "mao", "jeo", "seom", "eonet", "ideoe", "sebo", "genof", " geos", "eom", "jebo", "geoa", "maonet", "veo", " geoe", "maom", "GEonet", "memos", "ideo", "ideot", "jeology", "Geom", "geot", "Geos"], "ret": ["reset", "print", "rep", "report", "ry", " Ret", "ruby", "t", "rem", "deg", "nat", "rect", "ral", "cmd", "elt", "rm", "result", "erey", "ll", "virt", "arr", "tr", "status", "al", "at", "uf", "RET", "value", "prot", "rev", "pret", "usr", "ter", "try", "final", "rets", "Ret", "rt", "att", "no", "pas", "net", "url", "nl", "back", "err", "resp", "error", "nt", "ref", "def", " alt", "reg", "red", "rest", "it", "ft", "out", "mt", "len", "lt", "success", " RET", "oret", "flag", "det", "fun", "addr", "alt", "ext", "cont", "not", "val", "re", "res", "ber", "gt", " fut", "sys"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc)\n\n{\n\n    unsigned cb;\n\n    uint8_t  *tmp_vlc_bits;\n\n    uint32_t *tmp_vlc_codes;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t *codebook_multiplicands;\n\n    int ret = 0;\n\n\n\n    vc->codebook_count = get_bits(gb, 8) + 1;\n\n\n\n    av_dlog(NULL, \" Codebooks: %d \\n\", vc->codebook_count);\n\n\n\n    vc->codebooks = av_mallocz(vc->codebook_count * sizeof(*vc->codebooks));\n\n    tmp_vlc_bits  = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_bits));\n\n    tmp_vlc_codes = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_codes));\n\n    codebook_multiplicands = av_malloc(V_MAX_VLCS * sizeof(*codebook_multiplicands));\n\n\n\n    for (cb = 0; cb < vc->codebook_count; ++cb) {\n\n        vorbis_codebook *codebook_setup = &vc->codebooks[cb];\n\n        unsigned ordered, t, entries, used_entries = 0;\n\n\n\n        av_dlog(NULL, \" %u. Codebook\\n\", cb);\n\n\n\n        if (get_bits(gb, 24) != 0x564342) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook setup data corrupt.\\n\", cb);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        codebook_setup->dimensions=get_bits(gb, 16);\n\n        if (codebook_setup->dimensions > 16 || codebook_setup->dimensions == 0) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook's dimension is invalid (%d).\\n\",\n\n                   cb, codebook_setup->dimensions);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        entries = get_bits(gb, 24);\n\n        if (entries > V_MAX_VLCS) {\n\n            av_log(vc->avctx, AV_LOG_ERROR,\n\n                   \" %u. Codebook has too many entries (%u).\\n\",\n\n                   cb, entries);\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n        ordered = get_bits1(gb);\n\n\n\n        av_dlog(NULL, \" codebook_dimensions %d, codebook_entries %u\\n\",\n\n                codebook_setup->dimensions, entries);\n\n\n\n        if (!ordered) {\n\n            unsigned ce, flag;\n\n            unsigned sparse = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" not ordered \\n\");\n\n\n\n            if (sparse) {\n\n                av_dlog(NULL, \" sparse \\n\");\n\n\n\n                used_entries = 0;\n\n                for (ce = 0; ce < entries; ++ce) {\n\n                    flag = get_bits1(gb);\n\n                    if (flag) {\n\n                        tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n                        ++used_entries;\n\n                    } else\n\n                        tmp_vlc_bits[ce] = 0;\n\n                }\n\n            } else {\n\n                av_dlog(NULL, \" not sparse \\n\");\n\n\n\n                used_entries = entries;\n\n                for (ce = 0; ce < entries; ++ce)\n\n                    tmp_vlc_bits[ce] = get_bits(gb, 5) + 1;\n\n            }\n\n        } else {\n\n            unsigned current_entry  = 0;\n\n            unsigned current_length = get_bits(gb, 5) + 1;\n\n\n\n            av_dlog(NULL, \" ordered, current length: %u\\n\", current_length);  //FIXME\n\n\n\n            used_entries = entries;\n\n            for (; current_entry < used_entries && current_length <= 32; ++current_length) {\n\n                unsigned i, number;\n\n\n\n                av_dlog(NULL, \" number bits: %u \", ilog(entries - current_entry));\n\n\n\n                number = get_bits(gb, ilog(entries - current_entry));\n\n\n\n                av_dlog(NULL, \" number: %u\\n\", number);\n\n\n\n                for (i = current_entry; i < number+current_entry; ++i)\n\n                    if (i < used_entries)\n\n                        tmp_vlc_bits[i] = current_length;\n\n\n\n                current_entry+=number;\n\n            }\n\n            if (current_entry>used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \" More codelengths than codes in codebook. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n        }\n\n\n\n        codebook_setup->lookup_type = get_bits(gb, 4);\n\n\n\n        av_dlog(NULL, \" lookup type: %d : %s \\n\", codebook_setup->lookup_type,\n\n                codebook_setup->lookup_type ? \"vq\" : \"no lookup\");\n\n\n\n// If the codebook is used for (inverse) VQ, calculate codevectors.\n\n\n\n        if (codebook_setup->lookup_type == 1) {\n\n            unsigned i, j, k;\n\n            unsigned codebook_lookup_values = ff_vorbis_nth_root(entries, codebook_setup->dimensions);\n\n\n\n            float codebook_minimum_value = vorbisfloat2float(get_bits_long(gb, 32));\n\n            float codebook_delta_value   = vorbisfloat2float(get_bits_long(gb, 32));\n\n            unsigned codebook_value_bits = get_bits(gb, 4) + 1;\n\n            unsigned codebook_sequence_p = get_bits1(gb);\n\n\n\n            av_dlog(NULL, \" We expect %d numbers for building the codevectors. \\n\",\n\n                    codebook_lookup_values);\n\n            av_dlog(NULL, \"  delta %f minmum %f \\n\",\n\n                    codebook_delta_value, codebook_minimum_value);\n\n\n\n            for (i = 0; i < codebook_lookup_values; ++i) {\n\n                codebook_multiplicands[i] = get_bits(gb, codebook_value_bits);\n\n\n\n                av_dlog(NULL, \" multiplicands*delta+minmum : %e \\n\",\n\n                        (float)codebook_multiplicands[i] * codebook_delta_value + codebook_minimum_value);\n\n                av_dlog(NULL, \" multiplicand %u\\n\", codebook_multiplicands[i]);\n\n            }\n\n\n\n// Weed out unused vlcs and build codevector vector\n\n            codebook_setup->codevectors = used_entries ? av_mallocz(used_entries *\n\n                                                                    codebook_setup->dimensions *\n\n                                                                    sizeof(*codebook_setup->codevectors))\n\n                                                       : NULL;\n\n            for (j = 0, i = 0; i < entries; ++i) {\n\n                unsigned dim = codebook_setup->dimensions;\n\n\n\n                if (tmp_vlc_bits[i]) {\n\n                    float last = 0.0;\n\n                    unsigned lookup_offset = i;\n\n\n\n                    av_dlog(vc->avctx, \"Lookup offset %u ,\", i);\n\n\n\n                    for (k = 0; k < dim; ++k) {\n\n                        unsigned multiplicand_offset = lookup_offset % codebook_lookup_values;\n\n                        codebook_setup->codevectors[j * dim + k] = codebook_multiplicands[multiplicand_offset] * codebook_delta_value + codebook_minimum_value + last;\n\n                        if (codebook_sequence_p)\n\n                            last = codebook_setup->codevectors[j * dim + k];\n\n                        lookup_offset/=codebook_lookup_values;\n\n                    }\n\n                    tmp_vlc_bits[j] = tmp_vlc_bits[i];\n\n\n\n                    av_dlog(vc->avctx, \"real lookup offset %u, vector: \", j);\n\n                    for (k = 0; k < dim; ++k)\n\n                        av_dlog(vc->avctx, \" %f \",\n\n                                codebook_setup->codevectors[j * dim + k]);\n\n                    av_dlog(vc->avctx, \"\\n\");\n\n\n\n                    ++j;\n\n                }\n\n            }\n\n            if (j != used_entries) {\n\n                av_log(vc->avctx, AV_LOG_ERROR, \"Bug in codevector vector building code. \\n\");\n\n                ret = AVERROR_INVALIDDATA;\n\n                goto error;\n\n            }\n\n            entries = used_entries;\n\n        } else if (codebook_setup->lookup_type >= 2) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \"Codebook lookup type not supported. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n// Initialize VLC table\n\n        if (ff_vorbis_len2vlc(tmp_vlc_bits, tmp_vlc_codes, entries)) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Invalid code lengths while generating vlcs. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        codebook_setup->maxdepth = 0;\n\n        for (t = 0; t < entries; ++t)\n\n            if (tmp_vlc_bits[t] >= codebook_setup->maxdepth)\n\n                codebook_setup->maxdepth = tmp_vlc_bits[t];\n\n\n\n        if (codebook_setup->maxdepth > 3 * V_NB_BITS)\n\n            codebook_setup->nb_bits = V_NB_BITS2;\n\n        else\n\n            codebook_setup->nb_bits = V_NB_BITS;\n\n\n\n        codebook_setup->maxdepth = (codebook_setup->maxdepth+codebook_setup->nb_bits - 1) / codebook_setup->nb_bits;\n\n\n\n        if ((ret = init_vlc(&codebook_setup->vlc, codebook_setup->nb_bits,\n\n                            entries, tmp_vlc_bits, sizeof(*tmp_vlc_bits),\n\n                            sizeof(*tmp_vlc_bits), tmp_vlc_codes,\n\n                            sizeof(*tmp_vlc_codes), sizeof(*tmp_vlc_codes),\n\n                            INIT_VLC_LE))) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Error generating vlc tables. \\n\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return 0;\n\n\n\n// Error:\n\nerror:\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return ret;\n\n}\n", "idx": 10175, "substitutes": {"vc": ["ow", "xp", "vs", "vert", "fw", "pc", "sky", "ctrl", "vy", "vi", "av", "pp", "ee", "ct", "ev", "vv", "uv", "ve", "form", "vine", "vl", "ant", "xc", "lv", "bc", "vp", "wr", "cs", "VC", "wx", "act", "ud", "sv", "vt", "ver", "cc", "inv", "coll", "vo", "vd", "ctx", "tv", "wd", "v", "lc", "irm", "px", "ac", "wcs", "fax", "c", "cmd", "voc", "rt", "hw", "csv", "vid", "serv", "fc", "vet", "etc", "att", "ib", "cv", "vr", "iv", "vm", "nv", "conv", "ht", "vol", "vg"], "cb": ["lb", "ck", "bj", "callback", "CB", " count", "bf", "ub", "abc", "ebin", "ctrl", " cc", "rb", "bp", "CV", "func", "buf", "gov", "job", "cp", "abb", "fp", "cf", "bc", "xc", "cur", "tc", "cd", "unc", "wb", "bn", "cc", " coff", " eb", "bg", "cod", "obb", "pb", "eb", "ctx", "conn", "count", "rc", "tn", "cfg", "conf", "gc", "ctr", "c", "cn", "cmd", "uc", "kb", "nc", "kw", " rc", "bb", "ob", "fc", "crop", "etc", "nb", "org", "coord", "db", "cv", "dt", "conv", "kk"], "tmp_vlc_bits": ["tmp_vlci_its", "tmp_vlc__parts", "tmp_vlc_its", "tmp_vlc__tops", "tmp_vlci_codes", "tmp_vlcs_codes", "tmp_vlc_bytes", "tmp_vlcs_data", "tmp_vlc_data", "tmp_vlcs_bits", "tmp_vlc_parts", "tmp_vlci_bits", "tmp_vlci_tops", "tmp_vlc__codes", "tmp_vlcs_bytes", "tmp_vlc__bits", "tmp_vlci_parts", "tmp_vlc__bytes", "tmp_vlc__its", "tmp_vlc_tops", "tmp_vlci_bytes"], "tmp_vlc_codes": ["tmp_vlc__mods", "tmp_vlc5bits", "tmp_vlcs_cats", "tmp_vlp__objects", "tmp_vlc32cats", "tmp_vlc__objects", "tmp_vlc_names", "tmp_vlcs_codes", "tmp_vlcs_ints", "tmp_vlp__code", "tmp_vlc5codes", "tmp_vlp_codes", "tmp_vlc32objects", "tmp_vlcs_bits", "tmp_vlc_code", "tmp_vlc__codes", "tmp_vlc_objects", "tmp_vlc5names", "tmp_vlc__code", "tmp_vlp__codes", "tmp_vlc32mods", "tmp_vlc_ints", "tmp_vlc__bits", "tmp_vlp__bits", "tmp_vlcs_mods", "tmp_vlc32codes", "tmp_vlc5ints", "tmp_vlc_cats", "tmp_vlc__cats", "tmp_vlc_mods", "tmp_vlp_code", "tmp_vlp_objects", "tmp_vlcs_objects", "tmp_vlp_bits", "tmp_vlcs_names"], "gb": ["py", "gg", "gh", "mb", "bf", "ub", "gpu", "got", "gif", "goo", "gm", "hog", "rb", "gnu", "hub", "tg", "gs", "buf", "gov", "GB", "Gb", "pg", "g", "bm", "fb", "git", "ruby", "bytes", "jpg", "yg", "bg", "storage", "eg", "gd", "html", "eb", "vd", "ctx", "rg", "px", "vg", "cfg", "ha", "deg", "gu", "gc", "sb", "kb", "gy", "hw", "sys", "csv", "pi", "nb", "ib", "db", "gt", "cv", "vm", "img", "wb", "bridge"], "codebook_multiplicands": ["codebook_multiplacand", "codebook_ipliccents", "codebook_multiplicityands", "codebook_multiplistants", "codebook_multiplicoanded", "codebook_multICand", "codebook_iplicants", "codebook_multiplicand", "codebook_multiplICands", "codebook_multipliccand", "codebook_multiplicases", "codebook_ipliccates", "codebook_multiplICates", "codebook_multiplistates", "codebook_iplicands", "codebook_multipliccands", "codebook_multICates", "codebook_iplicents", "codebook_multiplacants", "codebook_multiplicityand", "codebook_multiplicates", "codebook_multiccand", "codebook_multiccants", "codebook_multicants", "codebook_multipliccents", "codebook_multiplICases", "codebook_multiplicityants", "codebook_multicases", "codebook_multiplicityanded", "codebook_multiplistands", "codebook_ipliccants", "codebook_multicand", "codebook_multipliccates", "codebook_multipliccants", "codebook_multiccases", "codebook_multiplicoates", "codebook_multiplicants", "codebook_multiplacands", "codebook_multICands", "codebook_multiccands", "codebook_multicands", "codebook_multiplacases", "codebook_multiplICanded", "codebook_multiplicityates", "codebook_iplicates", "codebook_multiplICand", "codebook_ipliccands", "codebook_multiplicoands", "codebook_multiplistents", "codebook_multicates", "codebook_multICanded", "codebook_multiplicoand", "codebook_multicanded", "codebook_multiplicanded", "codebook_multipliccases", "codebook_multiplICants", "codebook_multiplicents", "codebook_multiplicityents"], "codebook_setup": ["codebook_prep", "codebook2info", "codebook_Setup", "codebook_store", "codebook_upload", "codebook_handle", "codebooks_prep", "codebooks_Setup", "codecell_setup", "codebook2Setup", "codebook_info", "codebook_init", "codebooks_handle", "codebook2settings", "codebook2setup", "codebooks_upload", "codebook_settings", "codebooks_info", "codebook_set", "codebooks_store", "codebooks_settings", "codecell_init", "codecell_set", "codebooks_setup", "codecell_info", "codebooks_init"], "ordered": ["id", "CB", " unused", "order", "rb", "err", "f", "cf", "g", "ref", "cd", "bytes", "checked", "ord", "index", "r", "row", "version", "done", "rows", "box", "count", "c", "cmd", "bb", " tid", "coord", "db", "cv"], "t": ["tm", "td", "tf", "tt", "typ", "tp", "tg", "p", "f", "tc", "m", "type", "ptr", "ti", "txt", "ta", "ts", "n", "total", "tn", "tap", "wt", "c", "tmp", "T", "tu", "bt", "dt", "tz"], "entries": ["enties", " Entried", " enties", "entry", "entried", "entsries", "entures", "ntries", "ntry", "entsry", "Entures", "Entrys", "centies", " Entrance", "Enties", "entencies", "centrys", "entsried", "entslements", "ntrys", "rentries", "Entencies", " entrys", "Entrs", "entrs", "Entlements", "entsures", "Entrance", "entsrance", " entencies", " Entrys", "Entries", "Entried", " Entries", "entrys", "centencies", "entsrys", "entrance", "rentures", "ntlements", "centries", "rentrs", "entlements", "Entry", "entsrs", "rentrys"], "used_entries": ["used2entries", "used_ntrys", "used2pentries", "used2pentrs", "used_nties", "used2penties", "used_pentrys", "used_Enties", "used_penties", "used_enties", "used_Entrs", "used_Entries", "used_entrys", "used2enties", "used2pentrys", "used2entrs", "used_ntries", "used_pentries", "used2entrys", "used_ntrs", "used_entrs", "used_pentrs", "used_Entrys"]}}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                int64_t max_ns)\n\n{\n\n    bool final = max_ns < 0;\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int examined = 0, sent = 0;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(!spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart, invalidstart;\n\n\n\n        /* Consume non-dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n", "idx": 10180, "substitutes": {"f": ["tf", "fd", "fw", "fi", "bf", "fo", "uf", "base", "q", "ff", "file", "p", "rf", "o", "fp", "cf", "fm", "m", "l", "fb", "lf", "window", "r", "t", "ac", "v", "conf", "fr", "sf", "e", "b", "c", "fac", "h", "F", "w", "fs", "fc", "x", "z", "fx", "full", "ft", "out", "af", "xf"], "spapr": ["spaphrel", "Spapr", "expraprd", "spapsrar", "expampr", "spapard", "spaplr", "spcappr", "spaper", "ispapri", "spapperrr", " spcapr", "exprapra", "spaprd", "spaptlr", "expamprar", "sprappr", "sparpr", "ispapperrr", "spcapro", "spapelr", "spapsren", "spappR", "ispapperdr", "expappr", "spapreq", "spapar", "spraprt", "Spaprel", "sparpR", "spartrd", "spabR", "spapdr", "sprapru", "spapri", "pseaprd", " spaplr", "spcapr", "spapperner", "spiprb", "spaprer", "spapsr", "spapspr", "spcaperr", "sparmrel", "spaperr", "spapfr", " spapro", "ispappercr", "spaptr", "Spoprel", "espapr", " spipr", " spcappr", " spaprb", "espapsr", "spaceamrel", "sparmror", "exprapr", "spappdr", "spaprb", "spapeer", "spacheren", "spaceamr", "spapperri", "Spoprb", "spapra", "spapslr", "spapror", " spcaplr", "spamppr", "spcaplr", "spapsR", "sprapror", "sparmrd", "ispamprov", "pseapru", "spacheri", "spaprr", "pserapru", "spcaprr", " spapren", "spapsrer", "spippr", " spcaperr", "spabren", "spoprb", "expamprer", "spapR", "spaptreq", "spapser", "sparmra", "spcapcr", "expaprar", "spabr", "scopeapereq", "pseapr", "spartru", "ispapperr", "spappercr", "scopeaper", "spraprd", "spoprel", "scopeapr", "ispampri", " spaperr", "expaprer", "sparmr", "spapperdr", "spcapdr", "spachepr", "spipr", "scopeapreq", "spamr", "spamprov", "spcapren", "spapperrov", "spipro", "sparmner", "espapsR", "sparmfr", "spapyrd", "spaprel", "spapperr", "spapeR", "spapery", "scopeapeer", "spaprov", "spapero", "spapperpr", "spapro", "ispapr", "spapyra", " spipR", "spapsreq", " spapry", "spampri", "spamfr", "spampr", "spacherov", "spartrt", "exprapror", "espapsren", "spiperr", "spapprer", "pseraprd", "ispaprov", "spamprar", "spaceamner", "spipprb", "espapsrer", "spapart", "expaprd", "spaphr", "spcapR", "spipR", "spartr", "spapereq", "spipprel", "spapyror", "expapror", "spapyr", "pseaprt", "sprapra", "spappcr", "spapren", "spamrel", "spapter", "sparprb", "sparpry", "spapprr", "spaceapr", "spachelr", "expapra", "expapr", "spaparu", " spapR", "ispaprr", "Spaprb", "spabrer", "spaceapfr", "ispappr", "ispapdr", " spcapren", "spaceaprel", "ispamppr", "sprapr", "spapeerr", " spappr", "spaprt", "spaceapner", "scopeapelr", "spapry", "pseraprt", "espapR", "spapperrel", " spiprb", "ispampr", "Spopr", "spopr", "spraplr", "scopeaplr", "ispapcr", "spaceamfr", "espapren", "spappr", "espaprer", " spcapro", "sprapren", "spapppr", "spaprar", "spapner", "spapperfr", "pserapr", "spapprar", " spipry", "spapcr", "expamppr", "spacher", "spaperb", "spamprer", " spcapR", "spaphrb", "spamner", "spapru", "spappren", "spipry"], "max_ns": [" max2ms", "maxNfs", " max_fs", "max__ts", "max2ts", " max2ns", "max_sts", "maxNsts", "maxNms", " max_mins", "max_mins", " max2mins", "max__ms", "max__ns", "maxNns", "max2ms", "max_ts", "max2mins", " max_ms", " max2ts", " max_ts", "max__mins", "max_ms", "max2ns", " max_sts", "max_fs"], "chunkstart": ["frankStart", "chairstep", "chartsize", "chunksstop", "chnightstart", "achunkpad", "ichunkspace", "chackshift", "ichblockstart", "ChunkStart", "achunkstart", "ichblockspace", "chulkstart", "thacksize", "frankshift", "chreamStart", "chunkspace", "Chunksstart", "chartStart", "chunkinit", "chunksize", "achunkinit", "Chunkstart", "frunkStart", "chackst", "chunkspad", "Chunksentry", "chnightsize", "chblockStart", "chunkshift", "chunkssize", "achartstop", "chnightpad", "Chunksize", "chackend", "chairstart", "thunkstart", "thackstart", "achartstart", "chunksStart", "thackStart", "ichunkStart", "chartstart", "chunkslength", "chulkstop", "chankStart", "chairinit", "ichunkstart", "frankstart", "chblockst", "chunksshift", "achunkstep", "chankshift", "chramstop", "chunkoffset", "chowstart", "chreamentry", "chunksoffset", "chartentry", "chunksend", "Chunkssize", "chraminit", "chackstart", "chowsize", "achartinit", "chreamstart", "chairstop", "ChunksStart", "chunkstop", "thackend", "chunkstep", "chunkend", "chunkStart", "achunkstop", "chramstep", "ichunkst", "chunkpad", "chuncsize", "frunkstart", "chuncstart", "chankst", "achartstep", "frunklength", "chunkst", "frunkshift", "achuncstart", "chacksize", "chunklength", "chartstep", "chackspace", "chowStart", "thunkStart", "Chunkentry", "chanklength", "chramstart", "chunksstart", "chulkStart", "thunkend", "chuncoffset", "achuncsize", "chulkend", "Chunksend", "chuncpad", "Chunkstop", "chankspace", "chankstart", "franklength", "chackStart", "achuncpad", "chreamsize", "ichblockStart", "thunksize", "Chunkend", "chartstop", "chunksentry", "chowend", "chunkentry", "chartinit", "achunksize", "chnightoffset", "chblockspace", "chblockstart", "ichblockst", "achuncoffset", "Chunksstop", "chacklength", "achunkoffset"], "invalidstart": ["INvalwindow", "invalwindow", "INvalstop", " invalidend", "incompletestart", "INvalidStart", "invertstart", "invertend", "INvalidend", "infumentStart", "invalend", "infvalidstart", "inumentstart", "initerstop", "INvalidstop", "invertstop", "infumentstart", "incompletewind", "INvalStart", "INvalstart", "inunkstop", "initerStart", "invalStart", "invalidst", "invalstop", "infumentpart", "invalwind", "incompleteslice", "initerpart", "inunkend", "INvalidstart", "invalst", "invalpart", "inunkstart", "INvalidslice", " invalidst", "invalslice", "invertwindow", " incompletestart", "invalidend", "INvalidwindow", "invalidwind", " invalidwind", "infvalidstop", "inqualstart", "incompleteStart", "inunkwindow", " incompletest", "INvalslice", "incompletest", "invalidpart", "inqualslice", "invalstart", "invertwind", "invertst", "infumentstop", "initerstart", "invalidstop", "INvalend", "inumentstop", "invalidStart", "incompleteend", " incompleteend", "infvalidStart", "invalidwindow", "inumentStart", " incompletewind", "infvalidpart", "inumentpart", "invalidslice", "inqualStart"], "index": ["command", "doc", "prefix", "add", "thread", "update", "d", "eng", "open", "location", "block", "parent", "mix", "row", "create", "scan", "check", "tree", "ion", "subject", "slice", "speed", "context", "see", "size", "key", "tx", "address", "status", "path", "read", "document", "init", "value", "height", "ex", "ind", "fail", "iter", "capacity", "request", "example", "loop", "scroll", "try", "ix", "test", "version", "new", "count", "date", "close", "si", "link", "seed", "get", "item", "initial", "draw", "number", "page", "available", "id", "IND", "valid", "point", "engine", "unit", "reason", "instance", "dimension", "pos", "condition", "timeout", "local", "process", "i", "raw", "in", "connect", "Index", "n", "connection", "now", "ctx", "info", "action", "remote", "host", "localhost", "loc", "find", "select", "num", "event", "seek", "list", "insert", "act", "active", "zero", "position", "port", "handle", "is", "level", "root", "val", "search", "present", "query", "x", "connected", "set", "name", "offset", "length"], "examined": [" exachlied", "seximided", "eximided", "exagied", "exachlied", "exagining", "exagered", "exomered", "seximined", "examlied", "expmining", "seximinated", "exAmmented", "Expmining", "exAMided", "exachmented", "exAmining", "Expmined", "exAMining", "sexamining", "exumine", "exAMination", "exAMined", "exAmined", "exfammented", "exumined", " examining", "examinated", "exachined", "seximmented", "sexamination", "exumining", "expmied", "exAMine", "sexumination", "eximmented", "examination", "sexumining", " exammented", "Expmied", "examided", "exfamided", "exomied", " examlied", "eximinated", "examered", "sexumine", "Examered", "exomined", "expmmented", "examied", "Examining", "examine", "exammented", "eximined", "sexumined", "exomining", "exagined", "sexamined", "exAmlied", "exAMmented", "expmered", "sexaminated", "examining", "expmlied", "sexamided", "Examined", "sexammented", "Expmered", "exumination", " exachined", "exachining", "sexamine", " exachining", "exfamined", " exachmented", "Examied", "exAMinated", "exfaminated", "expmined"]}}
{"project": "qemu", "commit_id": "6c5b5645ae0b73c052df962e18e48d87bb7385e0", "target": 0, "func": "static abi_long do_socket(int domain, int type, int protocol)\n\n{\n\n    int target_type = type;\n\n    int ret;\n\n\n\n    ret = target_to_host_sock_type(&type);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (domain == PF_NETLINK)\n\n        return -TARGET_EAFNOSUPPORT;\n\n\n\n    if (domain == AF_PACKET ||\n\n        (domain == AF_INET && type == SOCK_PACKET)) {\n\n        protocol = tswap16(protocol);\n\n    }\n\n\n\n    ret = get_errno(socket(domain, type, protocol));\n\n    if (ret >= 0) {\n\n        ret = sock_flags_fixup(ret, target_type);\n\n        if (type == SOCK_PACKET) {\n\n            /* Manage an obsolete case :\n\n             * if socket type is SOCK_PACKET, bind by name\n\n             */\n\n            fd_trans_register(ret, &target_packet_trans);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 10190, "substitutes": {"domain": ["folder", "command", "net", "address", "url", "status", "prefix", "network", "policy", "channel", "uri", "base", "resource", "cookie", "where", "pattern", "range", "ca", "email", "topic", "unit", "scope", "label", "m", "gate", "client", "port", "example", "term", "server", "dn", "property", "index", "Domain", "chain", "family", "magic", "owner", "de", "root", "y", "bound", "handler", "plain", "dom", "zone", "site", "date", "change", "host", "AIN", "target", "origin", "rule", "controller", "table", "country", "rank", "group", "db", "module", "name", "role"], "type": ["command", "key", "method", "page", "id", "typ", "what", "address", "pe", "status", "tp", "resource", "ty", "message", "socket", "policy", "format", "where", "ping", "feature", "types", "range", "ime", "file", "module", "value", "field", "error", "size", "TYPE", "scope", "part", " TYPE", "port", "kind", "handle", "month", "family", "index", "try", "none", "function", "attribute", "Type", "version", "test", "owner", "y", "handler", "t", "count", "ype", "date", "class", "change", "origin", " Type", "rule", "tag", "table", "style", "link", "country", "time", "no", "description", "name", "state", "role"], "protocol": ["portocol", "phyprot", "propocol", "extprot", "extocol", "Prototype", "cryptport", "tport", "rotport", "phyocol", "Protprot", "tocol", "rotocol", "portension", "extport", "propicle", "scheicle", "proticle", "porticle", "rototype", "phyotype", "cryptprot", " protprot", "prototype", " protol", "scheotype", "scheocol", "tension", "propotype", "extotype", "protension", "Protport", "protol", "portport", "cryptol", "rotension", "Protol", "protprot", "phyport", " protport", "cryptocol", "portotype", "Protocol", "totype", "protport"], "ret": ["reset", "print", "gov", "prop", "report", "ry", "reply", "cat", " Ret", "detail", "desc", "r", "t", "rem", "deg", "cmd", "elt", "str", "rm", "result", "dt", "arg", "arr", "tr", "status", "code", "bool", "RET", "value", "iter", "rev", "pret", "txt", "usr", "ter", "try", "rets", "tech", "Ret", "reflect", "rt", "get", "att", "url", "nl", "back", "err", "nz", "resp", "hash", "f", "error", "nt", "ref", "def", "mem", "ts", "reg", "backed", "tmp", "it", "cert", "nil", "ft", "out", "mt", "len", "lit", "success", "num", "off", " RET", "flag", "det", "cb", "alt", "ext", "expr", "cont", "j", "total", "lag", "val", "re", "res", "set", "gt", "Return", "dr"]}}
{"project": "qemu", "commit_id": "1a61a9ae61cdf7b7d24c3eb711fe772c196c235e", "target": 0, "func": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n", "idx": 10192, "substitutes": {"env": ["vs", "net", "et", "code", "enc", "ev", "proc", "ec", "dev", "gov", "cp", "eng", "scope", "vp", "def", "window", "en", "server", "ew", "qt", "eg", "js", "pres", "ctx", "conn", "v", "conf", "environment", "e", "anc", "eu", "serv", "sc", "org", "context", "cv", "nv", "ds", "viron"], "buf": ["arr", "doc", "map", "xff", "buffer", "text", "read", "uf", "rb", "err", "ff", "alloc", "seq", "rw", "Buffer", "block", "vec", "ref", "fb", "cb", "ptr", "raw", "bn", "bytes", "txt", "queue", "mem", "br", "data", "pb", "v", "cast", "b", "cmd", "str", "Buff", "batch", "result", "buff", "db", "bar", "cv", "msg", "img", "wb"], "buf_len": ["buf_length", " buf2length", "Buffer_length", " buf2fin", " buf_length", "Buffer_len", "buf2elt", "buf2length", "buf2len", " buf2len", " buf_elt", "buf2fin", " buf2elt", "buf_fin", "buf5length", "buf_elt", "Buffer_en", "buf5elt", " buf_fin", "buf5fin", "buf_en", "buf5len"], "cpu": ["ck", "nic", "aco", "cum", "pc", "gpu", "prof", "processor", "alloc", "nz", "proc", "nu", "p", "cp", "pu", "cow", "jp", "process", "np", "pkg", "mu", "core", "CPU", "CP", "clock", "us", "ctx", "px", "ork", "gc", "cn", "anc", "uc", "uu", "hw", "nc", "cu"], "cs": ["ms", "cons", "vs", "spec", "Cs", "acts", "cus", "qs", "cks", "rs", "css", "ct", "hs", "ec", "gs", "sts", "CS", "cp", "ps", "cf", "act", "tc", "ins", "cc", "bs", "ys", "js", "ts", "ctx", "ac", "lc", "ics", "wcs", "caps", "c", "cn", "ctr", "acs", "ns", "nc", "fs", "cms", "ks", "cu", "sc", "ls", "cv", "s", "ds", "ca", "sys"], "hc": ["Hci", "ohcache", "oht", "hcc", "llcod", " hce", "thc", "strc", "handac", "strdc", "eachce", "Hc", "eachco", "strcc", "Hcc", "strac", "hgc", " hlc", "hlc", "htdc", "llc", "hhcache", " ht", " hgc", "Hac", "hhlc", "handc", "hac", "hcod", "hcache", "eachac", "eachc", "ohc", "llgc", "hht", "hdc", "llac", "hco", " hco", "thac", "handgc", " hcache", "Hdc", "htac", " hcc", "hce", "thco", "handcod", "htc", " hci", " hdc", "thce", "ohlc", "hci", " hcod", "ht", "htci", "hhc", " hac"], "pvinfo": ["pginco", "pvyinfo", " pvinmo", "pvininfo", "Pginfo", "Pvinato", " pvine", "pvinf", " pgininfo", "pcinato", "pvymo", "pgine", "pvinato", " pginf", "Pvinfo", " pvinfty", "pvinfty", "pbininfo", "piseninfo", "pgininfo", "pbine", "pvisinfo", "pvanfo", " pginmo", "pcininfo", "pginf", "pginfo", "pvise", "pbinf", "pcinfo", "Pvinco", " pginfty", "pvanco", "pcinco", "Pginato", "pginfty", "pvine", "pisenfo", "pbinfo", "pvaninfo", "pginmo", "pvisf", "pvyfo", "pginato", "pvyfty", "pvinmo", " pgine", " pvinf", "pisenmo", "Pgininfo", " pvininfo", " pginfo", "pvisfo", "pvanato", "pisenfty", "pvinco", "Pginco", "Pvininfo"]}}
{"project": "qemu", "commit_id": "1bcef683bf840a928d633755031ac572d5fdb851", "target": 0, "func": "void process_incoming_migration(QEMUFile *f)\n\n{\n\n    if (qemu_loadvm_state(f) < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        exit(0);\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    incoming_expected = false;\n\n\n\n    if (autostart) {\n\n        vm_start();\n\n    } else {\n\n        runstate_set(RSTATE_PRE_LAUNCH);\n\n    }\n\n}\n", "idx": 10194, "substitutes": {"f": ["fab", "tf", "fd", "bf", "fi", "fw", "file", "p", "rf", "fp", "fm", "cf", "d", "m", "l", "fb", "lf", "fa", "r", "fn", "t", "fr", "sf", "e", "b", "c", "h", "F", "fs", "fc", "af"]}}
{"project": "FFmpeg", "commit_id": "979bea13003ef489d95d2538ac2fb1c26c6f103b", "target": 0, "func": "static int rv40_decode_mb_info(RV34DecContext *r)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int q, i;\n\n    int prev_type = 0;\n\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n\n    int blocks[RV34_MB_TYPES] = {0};\n\n    int count = 0;\n\n\n\n    if(!r->s.mb_skip_run)\n\n        r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1;\n\n\n\n    if(--r->s.mb_skip_run)\n\n         return RV34_MB_SKIP;\n\n\n\n    if(r->avail_cache[6-1])\n\n        blocks[r->mb_type[mb_pos - 1]]++;\n\n    if(r->avail_cache[6-4]){\n\n        blocks[r->mb_type[mb_pos - s->mb_stride]]++;\n\n        if(r->avail_cache[6-2])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;\n\n        if(r->avail_cache[6-5])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;\n\n    }\n\n\n\n    for(i = 0; i < RV34_MB_TYPES; i++){\n\n        if(blocks[i] > count){\n\n            count = blocks[i];\n\n            prev_type = i;\n\n        }\n\n    }\n\n    if(s->pict_type == AV_PICTURE_TYPE_P){\n\n        prev_type = block_num_to_ptype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for P-frame\\n\");\n\n    }else{\n\n        prev_type = block_num_to_btype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for B-frame\\n\");\n\n    }\n\n    return 0;\n\n}\n", "idx": 10213, "substitutes": {"r": ["kr", "obj", "tr", "run", "u", "resource", "rb", "rs", "or", "err", "rec", "p", "o", "f", "ren", "d", "rw", "gr", "g", "m", "l", "ra", "attr", "mr", "rr", "usr", "rel", "j", "br", "n", "t", "rg", "rem", "rc", "rd", "v", "nr", "fr", "rh", "e", "b", "c", "h", "ro", "rt", "re", "sr", "w", "res", "er", "it", "z", "result", "ur", "rer", "vr", "R", "cr", "rar", "ar", "dr", "ret"], "s": ["ms", "vs", "ats", "span", "hs", "o", "d", "cs", "m", "ins", "session", "se", "y", "t", "sports", "os", "has", "b", "times", "sr", "w", "options", "ims", "ar", "settings", "tests", "gs", "sts", "g", "sv", "bs", "services", "als", "js", "less", "ss", "conf", "e", "sb", "scripts", "sc", "ls", "app", "state", "src", "sq", "spec", "sl", "qs", "a", "rs", "css", "as", "f", "words", "es", "ts", "n", "ctx", "styles", "sort", "sw", "sh", "ns", "er", "ions", "tes", "space", "ds", "p", "ps", "is", "j", "S", "its", "series", "v", "self", "c", "ed", "sn", "stats", "fs", "res", "st", "set", "sys", "parts"], "gb": ["py", "gg", "gif", "mb", "bf", "goo", "ch", "gm", "rb", "rs", "tg", "gs", "buf", "GB", "Gb", "pg", "g", "boxes", "bm", "gz", "sv", "cb", "ruby", "bs", "bytes", "yg", "bg", "storage", "eg", "gd", "phy", "ctx", "rg", "cfg", "ubis", "gc", "sb", "b", "kb", "gy", "cm", "bd", "csv", "bb", "gam", "by", "nb", "gt", "db", "ib", "bt", "cv", "img", "wb", "vg"], "q": ["quer", "sq", "u", "entry", "qq", "qs", "quick", "ch", "quit", "Q", "iq", "k", "p", "buf", "seq", "g", "pkg", "l", "quant", "limit", "qv", "qual", "quality", "qa", "queue", "qt", "question", "dq", "t", "qu", "count", "v", "conf", "ql", "que", "qi", "cache", "b", "c", "query", "lock", "h", "comment", "quote", "requ", "it", "z", "quest", "aq", "ue"], "i": ["sym", "id", "ai", "I", "me", "li", "ei", "uri", "init", "list", "ri", "p", "o", "sim", "f", "ind", "ui", "iter", "ip", "instance", "m", "l", "ki", "ti", "ic", "cli", "in", "index", "mi", "j", "series", "ix", "ma", "n", "y", "iu", "ci", "t", "count", "v", "zi", "phi", "xi", "multi", "qi", "b", "c", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "batch", "ini", "oi", "hi", "ji", "ii"], "blocks": ["ms", "amps", "users", "flows", "aps", "vs", "banks", "locks", "stores", "units", "qs", "frames", "types", "keys", "Blocks", "workers", "ensions", "modules", "bl", "games", "uploads", "offs", "lines", "pages", "guards", "block", "images", "boxes", "bits", "ins", "books", "heads", "ocks", "groups", "outs", "asks", "bs", "bytes", "chains", "values", "iques", "bys", "pres", "stones", "data", "views", "rows", "uses", "styles", "assets", "plugins", "limits", "loads", "mates", "pins", "times", "masters", "fs", "finals", "actions", "maps", "usters", "jobs", "versions", "days", "items", "builders"], "mb_skip_run": ["mb_no_runner", "mb_skiphasruns", "mb_skiphasround", "mb_no_runs", "mb_no_run", "mb_skip_pos", "mb_skip_cycle", "mb_skip_runs", "mb_skip_play", "mb_no_cycle", "mb_skip_round", "mb_no_play", "mb_skiphasplay", "mb_skiphasrun", "mb_skip__runs", "mb_skip_runner", "mb_skip__play", "mb_no_round", "mb_skip__pos", "mb_no_pos", "mb_skip__run"], "mb_type": [" MBlictag", " MB_name", " MB_format", "bb_time", "mbttype", "emb_type", "mbixtype", "mbttypes", "mb_model", "mb_name", "bb_type", "mb_time", "mg_type", "bb_types", "mbttime", "mbtbuffer", "mblicformat", "bb_buffer", "emb_rel", " MBlicformat", "mg_model", "emb_name", "mg_types", "mb_buffer", "mblictype", "mb_format", "mb_error", "mb_types", "mb_tag", "mblicname", "mbixerror", "mbixrel", " MB_type", " MB_tag", "mb_rel", " MBlicname", "mblictag", " MBlictype", "mbixname", "emb_error"], "mb_pos": ["mb__pos", "mb2Pos", "mbPoloc", "bb2pos", "mb_pi", "mbobjpost", "mb2type", "emb_po", "mb2pos", "mb_mon", "mb_Pos", "jpg_mon", "mb_pat", "mbobjpos", "emb_pro", "mb__loc", "mbacloc", "mb__pat", "bb2loc", "jpg_pose", "bb_loc", "bb_type", "bb_pos", "mbPopro", "emb_pat", "bb2type", "mbacPos", "emb_loc", "mb__po", "mb_px", "mb_post", "jpg_post", "mbactype", "mb_pose", "mbobjpose", "mb_loc", "mb_cond", "bb2Pos", "mb2loc", "emb_pi", "jpg_pos", "mb_pro", "emb_cond", "mbobjmon", "emb_px", "mbPopos", "emb_pos", "bb_Pos", "mbPopi", "mbacpos", "mb_po"], "mb_stride": ["mb_sprride", "mb_STRider", "mb_brpace", "mb_frime", "mb_brise", "mb_frim", "mb_Stride", "mbgstides", "mb_strid", "mb_sprpace", "mb_stid", "mb_strime", "mb_sysise", "mb_strider", "mb_strad", "mbgstrid", "mb_lenride", "mb_strides", "mb_suspride", "mb_bride", "mb_STRride", "mb_brime", "mb_brride", "mb_strim", "mbgstrride", "mb_spride", "mb_sprad", "mb_dride", "mb_lenide", "mb_drides", "mb_drride", "mb_Strid", "mb_brad", "mb_strpace", "mbgstid", "mb_drid", "mbgstride", "mb_syside", "mb_STRide", "mb_sysider", "mb_STRise", "mbgstide", "mb_strride", "mb_susppace", "mb_stide", "mb_brider", "mb_suspide", "mb_Strides", "mbgstrides", "mb_frride", "mb_brim", "mb_sysride", "mb_fride", "mb_lenim", "mb_strise", "mb_Strride", "mb_lenime", "mb_stides", "mb_suspad"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,\n\n                                        uint8_t *dst,\n\n                                        long width, long height,\n\n                                        long srcStride1, long srcStride2,\n\n                                        long srcStride3, long dstStride)\n\n{\n\n    x86_reg x;\n\n    long y,w,h;\n\n    w=width/2; h=height;\n\n    for (y=0;y<h;y++) {\n\n        const uint8_t* yp=src1+srcStride1*y;\n\n        const uint8_t* up=src2+srcStride2*(y>>2);\n\n        const uint8_t* vp=src3+srcStride3*(y>>2);\n\n        uint8_t* d=dst+dstStride*y;\n\n        x=0;\n\n#if COMPILE_TEMPLATE_MMX\n\n        for (;x<w-7;x+=8) {\n\n            __asm__ volatile(\n\n                PREFETCH\"   32(%1, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%2, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%3, %0)          \\n\\t\"\n\n                \"movq      (%1, %0, 4), %%mm0   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq         (%2, %0), %%mm1   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq         (%3, %0), %%mm2   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"movq            %%mm0, %%mm3   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq            %%mm1, %%mm4   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq            %%mm2, %%mm5   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"punpcklbw       %%mm1, %%mm1   \\n\\t\" /* U0U0 U1U1 U2U2 U3U3 */\n\n                \"punpcklbw       %%mm2, %%mm2   \\n\\t\" /* V0V0 V1V1 V2V2 V3V3 */\n\n                \"punpckhbw       %%mm4, %%mm4   \\n\\t\" /* U4U4 U5U5 U6U6 U7U7 */\n\n                \"punpckhbw       %%mm5, %%mm5   \\n\\t\" /* V4V4 V5V5 V6V6 V7V7 */\n\n\n\n                \"movq            %%mm1, %%mm6   \\n\\t\"\n\n                \"punpcklbw       %%mm2, %%mm1   \\n\\t\" /* U0V0 U0V0 U1V1 U1V1*/\n\n                \"punpcklbw       %%mm1, %%mm0   \\n\\t\" /* Y0U0 Y1V0 Y2U0 Y3V0*/\n\n                \"punpckhbw       %%mm1, %%mm3   \\n\\t\" /* Y4U1 Y5V1 Y6U1 Y7V1*/\n\n                MOVNTQ\"          %%mm0,  (%4, %0, 8)    \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 8(%4, %0, 8)    \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm2, %%mm6   \\n\\t\" /* U2V2 U2V2 U3V3 U3V3*/\n\n                \"movq     8(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U2 Y V2 Y U2 Y V2*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U3 Y V3 Y U3 Y V3*/\n\n                MOVNTQ\"          %%mm0, 16(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 24(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"movq            %%mm4, %%mm6   \\n\\t\"\n\n                \"movq    16(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm5, %%mm4   \\n\\t\"\n\n                \"punpcklbw       %%mm4, %%mm0   \\n\\t\" /* Y U4 Y V4 Y U4 Y V4*/\n\n                \"punpckhbw       %%mm4, %%mm3   \\n\\t\" /* Y U5 Y V5 Y U5 Y V5*/\n\n                MOVNTQ\"          %%mm0, 32(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 40(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm5, %%mm6   \\n\\t\"\n\n                \"movq    24(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U6 Y V6 Y U6 Y V6*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U7 Y V7 Y U7 Y V7*/\n\n                MOVNTQ\"          %%mm0, 48(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 56(%4, %0, 8)   \\n\\t\"\n\n\n\n                : \"+r\" (x)\n\n                : \"r\"(yp), \"r\" (up), \"r\"(vp), \"r\"(d)\n\n                :\"memory\");\n\n        }\n\n#endif\n\n        for (; x<w; x++) {\n\n            const long x2 = x<<2;\n\n            d[8*x+0] = yp[x2];\n\n            d[8*x+1] = up[x];\n\n            d[8*x+2] = yp[x2+1];\n\n            d[8*x+3] = vp[x];\n\n            d[8*x+4] = yp[x2+2];\n\n            d[8*x+5] = up[x];\n\n            d[8*x+6] = yp[x2+3];\n\n            d[8*x+7] = vp[x];\n\n        }\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n#endif\n\n}\n", "idx": 10233, "substitutes": {"src1": ["sr2", "sr0", "rcOne", "source2", "srOne", "rc1", "sourceOne", " srcOne", "sr1", " src0", "src0", "source1", "rc0", "rc2", "srcOne"], "src2": ["sr2", "src4", "source2", "rc1", "sr1", "source4", " src0", "src0", "source1", "rc0", "rc3", "rc2", " src4", "source0", "sr3", "source3", "rc4"], "src3": ["src4", "source2", "source03", "rc1", "source4", " src03", "rc03", "source1", "rc3", "rc2", " src4", "source3", "src03", "rc4"], "dst": ["ddstr", "dsts", "dtr", "rcr", " dsts", "dcr", "ddsts", "ddest", " dstr", "dddest", " dth", "dstr", "ldest", "rtr", "dth", "tth", " dcr", "lst", " dtr", "rst", "tcr", " ddest", "ddst", "ttr", "lsts", "tst", "rth", "lstr"], "height": ["depth", "grow", "he", "H", "gravity", "gh", "sky", "ty", "ch", "padding", "ht", "stroke", "bottom", "volume", "size", "th", "capacity", "window", "wh", "Height", "total", "html", "count", "radius", "zh", "hei", "shape", "headers", "kh", "ih", "crop", "hang", "density", "history", "high", "length", "inches"], "srcStride1": ["srcstride2", "srcStrip11", "srcStrib2", "srcStrip0", "srcStrride1", "srcStrride2", "srcstide11", "srcStrid0", "srcStide11", "srcStride0", "srcStrride0", "srcStrip2", "srcStrib1", "srcstide2", "srcStride11", "srcstride0", "srcstide1", "srcStrib0", "srcstide0", "srcStrid1", "srcStide1", "srcStrip1", "srcStide2", "srcStrid2", "srcstride11", "srcStide0", "srcstride1"], "srcStride2": ["srcstride2", "srcSterveTwo", "srcStideTwo", "srcStrride1", "srcStoe2", "srcStrride2", "srcSterve2", "srcstrideTwo", "srcStrideTwo", "srcstide4", "srcStoe3", "srcStr2", "srcStrip2", "srcstide2", "srcStoe1", "srcStr1", "srcStide3", "srcStride8", "srcStrride3", "srcStide8", "srcStride4", "srcstide1", "srcSterve1", "srcStr3", "srcStide1", "srcStr8", "srcStide4", "srcStrip1", "srcStoe8", "srcStide2", "srcSterve4", "srcstideTwo", "srcStripTwo", "srcstride4", "srcstride1", "srcStrride8", "srcStrip4"], "srcStride3": ["srcStrib2", "srcStend3", "srcStrib4", "srcStrride2", "srcSlrip1", "srcStrip3", "srcStrip8", "srcStrib03", "srcStride03", "srcSlride4", "srcStide43", "srcSlride1", "srcStrib43", "srcStrib1", "srcSlride3", "srcStrib8", "srcStrib3", "srcStr1", "srcStride8", "srcStide3", "srcStend2", "srcStrride3", "srcSlrip8", "srcStride4", "srcStr3", "srcSlrip4", "srcStrride03", "srcStrride43", "srcSlrip3", "srcStend43", "srcStide03", "srcStr8", "srcSlride8", "srcStrip1", "srcStride43", "srcStend03", "srcStide2", "srcStr4", "srcStrip4"], "dstStride": ["dstSTrip", "dstSlide", "dstRestide", "dstStide", "dndStrobe", "dstrRestrat", "dndStide", "dstrStide", "dstStrride", "dstSlride", "dstrStride", "dstStrrobe", "dndStrip", "dstStrat", "dstRestride", "dstStrip", "dndStrride", "dndStrrobe", "dstSTide", "dstrRestride", "dstrStrip", "dndStrrip", "dstStrobe", "dndStride", "dstrStrat", "dstRestrobe", "dstRestrip", "dstSlrat", "dstSlrip", "dstSTrobe", "dstrRestrip", "dstStrrat", "dstSTride", "dstRestrat", "dstStrrip", "dstrRestide"], "x": ["xp", "on", "xy", "u", "ct", "ident", "o", "m", "r", "row", "t", "check", "el", "tx", "mx", "at", "axis", "ex", "xd", "inx", " key", "ix", " tx", "xes", "xi", "ey", "e", " ax", "xt", "any", " index", "xx", "yx", "z", "batch", "xa", "no", "step", "k", " i", "f", " k", "dx", "l", "X", "i", "xxx", "index", "_", "rx", "n", "ctx", "px", " X", "crop", "ax", " xx", "column", " cx", "p", " e", " dx", "ox", "xc", "wx", "lat", "ext", "j", "v", "c", "fx", "max", "ux", "xf"], "y": ["key", "aily", "py", "yt", "xy", "ya", "axy", "sky", "ty", "ch", "vy", "ady", "yy", "yi", "wy", "p", "ay", "ry", "my", "oy", "ies", "i", "ye", "yer", "dy", "ky", "ys", "j", "ley", "yd", "icy", "t", "yr", "Y", "asy", "yo", "ey", "b", "ly", "ery", "ym", "sy", "gy", "uy", "iy", "any", "hey", "by", "yu", "yl", "ny", "cy"], "w": ["fw", "ww", "iw", "wk", "weight", "wi", "p", "we", "W", "ex", "rw", "wr", "m", "l", "wx", "win", "window", "wh", "en", "wa", "ew", "r", "wl", "n", "wn", "Width", "wd", "v", "e", "wt", "wp", "sw", "hw", "kw", "tw", "nw", "wb"], "h": ["hal", "he", "ph", "hr", "hm", "ch", "q", "ht", "k", "hs", "p", "o", "m", "l", "hd", "hl", "i", "length", "wh", "oh", "en", "hh", "ish", "n", "t", "v", "zh", "ha", "hei", "b", "c", "sh", "kh", "bh", "hw", "ih", "hang", "z", "high", "H"], "yp": ["py", "xp", "ipp", "typ", "rpm", "tp", "RP", "ty", "pp", "iw", "bp", "uper", "yy", "ept", "sp", "cp", "fp", "yn", "ip", "jp", "lip", "osp", "ep", "orp", "lp", "pb", "px", "esp", "ype", "Typ", "hip", "wp", "ym", "dp", "mp", "YP", "pa"], "up": ["ow", "op", "u", "ub", "upt", "uf", "UP", "Up", "au", "lu", "ui", "omp", "ip", "ap", "um", "ou", "ups", "im", "uph", "hip", "uc", "ump", "ul", "ur", "upp", "ua", "mp", "ue", "out"], "vp": ["tm", "xp", "vs", "imp", "hm", "rpm", "tp", "pp", "bp", "vv", "vc", "fp", "lv", "jp", "np", "qv", "vt", "lp", "pm", "wp", "dp", "rm", "vr", "dm", "mp", "VP", "vm", "nv", "vg"], "d": ["dd", "p", "o", "df", "da", "dx", "dc", "g", "pd", "m", "l", "dL", "D", "dn", "r", "j", "data", "n", "dq", "t", "v", "e", "b", "c", "di", "bd", "dp", "z", "db", "dict", "dh", "dm", "s", "dt", "ds", "dr", "out"]}}
{"project": "FFmpeg", "commit_id": "381e195b46d080aee1d9b05ef2b6b140e9463519", "target": 0, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n, i;\n\n    uint8_t *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    int32_t *dst_int32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        /* 2 samples are interleaved per block in PCM_DVD */\n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n\n        /* we process 40-bit blocks per channel for LXF */\n\n        sample_size = 5;\n\n\n\n    if (sample_size == 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid sample_size\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        if (buf_size < n) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n            return -1;\n\n        }else\n\n            buf_size -= buf_size % n;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(32, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(32, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; // sync flags are here\n\n          AV_WN16A(samples, av_reverse[(v >> 8) & 0xff] +\n\n                           (av_reverse[v & 0xff] << 8));\n\n          samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++) {\n\n                AV_WN16A(samples, bytestream_get_le16(&src2[c]));\n\n                samples += 2;\n\n            }\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            *samples++ = *src++ + 128;\n\n        }\n\n        break;\n\n#if HAVE_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(64, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(32, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(16, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(64, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(32, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(16, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif /* HAVE_BIGENDIAN */\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples += n * sample_size;\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            AV_WN16A(samples, x << 8);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            AV_WN16A(samples, s->table[*src++]);\n\n            samples += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n        }\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    case CODEC_ID_PCM_LXF:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        //unpack and de-planerize\n\n        for (i = 0; i < n; i++) {\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract low 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n\n            }\n\n\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract high 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n\n            }\n\n        }\n\n        src += n * avctx->channels * 5;\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "idx": 10244, "substitutes": {"avctx": ["ajjp", "evctx", "navjac", " avcontext", "vartx", "wavcfg", "avefc", "avconn", "wavca", "afcas", "avecontext", "evcontext", "vercu", " avhw", "averca", "avsys", "avesys", "avgp", "avcmd", "ajcu", "auctx", "vancas", "ajparams", "avmk", "avecas", "avecu", "avehandle", "afconfig", " avconf", "afhandle", "avparams", "vrcas", "varmk", "averctx", "avcmp", " avmk", "avetx", "afpkg", "avcas", "avepkg", "aftx", "ajkw", "wavctx", "avconf", "navctx", " avfc", "AVctx", "verctx", "avcontext", "vrhw", "afconn", "vrctx", "avercontext", "averkw", "avjp", "avhw", "ajctx", "avconfig", "aveconn", "avectx", "wavjp", "ajtx", "aveconfig", " avconn", "vancu", "vertx", "vercfg", "vercas", "aveparams", "avcfg", "afcfg", "wavconn", "averfc", " avtx", "aveca", "wavtx", "avcu", "ajjac", "ajcfg", "AVkw", "ajcas", "auparams", "wavconfig", "afctx", "varctx", "avekw", "AVtx", "abconf", "vrtx", "AVcontext", "abctx", "vercontext", "abca", "avecmd", "cvctx", " avca", "vrcu", "cvconn", "vanctx", "wavcmd", " avcfg", "ajsys", "aveconf", "cvcmd", "afcontext", "abcontext", "avjac", "augp", "wavpkg", "ajgp", "AVcfg", "afmk", "aucas", "avecfg", "avfc", "vrcfg", "evpkg", "averhw", " avpkg", "avhandle", " avcu", "varconn", "navca", "afjp", "afcu", "avecmp", "ajca", "wavjac", "navtx", " avkw", "vancfg", "aversys", "ajhandle", "avkw", "evtx", "wavcmp", "vrcontext", "avertx", "avegp", "avtx", "avpkg", "cvcmp", "avca", "avercu"], "data": ["Data", "empty", "id", "next", "map", "buffer", "text", "message", "a", "padding", "read", "image", "sample", "to", "area", "stream", "p", "value", "dev", "f", "bin", "frame", "pad", "d", "block", "m", "pos", "ata", "bits", "type", "ref", "length", "raw", "window", "bytes", "mu", "in", "package", "video", "t", "feed", "input", "dat", "w", "batch", "DATA", "name", "size", "out"], "data_size": ["data2length", "data_length", "data_range", " data_range", "data_Size", "data2range", " data_Size", " data_SIZE", "data2Size", "data6size", "data_SIZE", "data2size", " data_length", "data6Size", "data6range", "data6length"], "avpkt": ["avpbck", "ajpbck", "avpbmsg", "avpacket", "avPk", "avPuc", "ajpmsg", "avwpk", "averpkt", "ajpbmsg", "avtptx", " avPtx", "avlpkt", "avwpkt", "avppmsg", " avpmsg", "avopck", "avopkt", "avtpkt", "averlpacket", "avpuc", "ajpbkt", "avpck", "avPacket", "avpbkt", " avPmsg", "avPmsg", "avPck", "avPkt", "avpk", "avwpkg", "averpacket", "avopmsg", "averlpkt", "averlpkg", "averpkg", "avtpct", "avptx", " avpct", "avpbuc", "avppct", "averpk", "ajpkt", "avpct", "avPtx", "avpptx", " avPkt", "avlpk", "averlpk", "avlpkg", "avpmsg", "avwpacket", "ajpbuc", "avPct", "avppkt", " avPct", "avpkg", "avPkg", "avlpacket", "ajpck", "ajpuc", "avopuc", "avtpmsg", " avptx"], "buf": ["map", "buffer", "uf", "rb", "alloc", "p", "bin", "Buffer", "vec", "np", "pkg", "ref", "pos", "cb", "raw", "bytes", "txt", "mem", "queue", "r", "br", "box", "cap", "t", "ctx", "v", "cache", "b", "tmp", "cmd", "bh", "orig", "buff", "msg", "db", "cv", "img", "wb"], "s": ["sq", "spec", "a", "rs", "p", "gs", "o", "ps", "d", "g", "m", "r", "j", "S", "ss", "v", "e", "sb", "b", "h", "ns", "w", "conv", "ds", "sys"], "sample_size": ["sample1Size", "frame_function", "site_Size", "frame67global", "ample_type", " sample_Size", "site67size", "ample_count", "ample_weight", " sample_description", "sampleletSize", "sample10global", "sample67size", "site_group", " sample_speed", "sampleYSIZE", " sample_sized", "sample67speed", "sample_sized", "sampleletsum", "sample_type", "ample_size", " sample_sum", "sampleYdescription", "sample1group", "sample_count", "frame67size", "sampleletweight", "site67sized", "samplelydescription", "site67group", "sampleletsize", "samplelySIZE", "sample_weight", "sampleYfunction", "frame67function", "sampleletSIZE", "samplelettype", "sample_group", "sample_Size", "sample_SIZE", "sample10function", "sample2count", "frame_speed", " sample_type", "sampleYsize", "sampleYSize", "ample_Size", "sample10size", "sample_global", "sample_function", "sampleYsized", "samplelysize", "site67Size", "sample1sized", "sample67group", "sample10speed", "sampleletspeed", "sample67sized", "sample_sum", "sample2size", "frame_size", "sample_speed", "frame67speed", "samplelyfunction", "frame_global", " sample_function", "site_sized", "sample2Size", "sample67Size", " sample_SIZE", "sample1size", "site_size", "sample67global", "sample67function", "sampleYtype", "sample_description"], "c": ["ch", "k", "p", "f", "cp", "bc", "d", "dc", "g", "cs", "m", "cb", "cc", "t", "ci", "count", "v", "lc", "e", "b", "cn", "h", "nc", "cm", "x", "C", "co"], "n": ["len", "num", "na", "u", "net", "nan", "nm", "nl", "a", "k", "nu", "Ni", "p", "ng", "o", "an", "ne", "nt", "ni", "d", "normal", "m", "np", "l", "nia", "rn", "pos", "nn", "after", "mn", "en", "dn", "ln", "r", "j", "N", "y", "fn", "t", "new", "count", "v", "nr", "b", "cn", "un", "h", "sn", "ns", "w", "nc", "x", "nb", "z", " N", "no", "name", "nv", "size", "nw", "pn", "number"], "i": ["id", "I", "li", "p", "o", "d", "ip", "m", "l", "ic", "mi", "j", "ir", "ix", "y", "t", "ci", "v", "b", "bi", "di", "pi", "si", "it", "x", "ii"], "samples": ["insamples", " sizes", "rsamples", "tamples", "Sources", "Samples", "samps", "sources", "tamps", "damps", "tents", "rsamps", "sizes", "Samps", "jsamps", "insources", " samps", "jsizes", "jsamples", "Sizes", "insamps", "rsources", "sents", " sources", "tources", "ssizes", "insizes", "dents", "ssamps", "jsources", "ssamples", "ssources", "Sents", "rsizes", "dources", "damples"], "src": ["sq", "filename", "sl", "xff", "source", "rs", "req", "proc", "stream", "sub", "seq", "bin", "fp", "trans", "bc", "cur", "np", "attr", "ins", "cb", "ptr", "usr", "txt", "addr", "rl", "r", "rel", "cont", "its", "dest", "rc", "input", "sb", "b", "via", "comp", "tmp", "rect", "sn", "inst", "sr", "st", "sc", "img", "ur", "iv", "loc", "conv", "sys"], "src8": ["source8", "source24", "input2", "rc8", "input8", "rc2", "source16", "rc24", "src16", "source2", "input24", "input16", "rc16", "src24"], "src2": ["source8", "src1", "rc1", "rc8", "rc2", "source2", " src1", "source1"], "MAX_CHANNELS": ["MAX_CHANNES", "MAX_CHANKEL", "MAX_CHANDS", "MAX_ChANETS", "MAX_CHINELS", "MAX_CHANNDS", "MAX_CHABELS", "MAX_CHACELS", "MAX_CHANEL", "MAX_CHINES", "MAX_CHANES", "MAX_ChANNETS", "MAX_ChANES", "MAX_ChANNDS", "MAX_CHINDS", "MAX_ChANDS", "MAX_ChANELS", "MAX_CHANKELS", "MAX_ChANNELS", "MAX_CHABETS", "MAX_CHACEL", "MAX_CHANKETS", "MAX_ChANNES", "MAX_CHABEL", "MAX_CHACES", "MAX_CHINEL", "MAX_CHANKES", "MAX_CHACDS", "MAX_CHANELS", "MAX_ChANNEL", "MAX_CHANNEL", "MAX_CHANNETS", "MAX_CHABES", "MAX_ChANEL", "MAX_CHANETS"], "dst_int32_t": ["dst_int32_ts", "dst_int32_type", "dst_int8_t", "dst_int32_T", "dst_int8_ts", "dst_int8_type", "dst_int8_T"]}}
{"project": "FFmpeg", "commit_id": "253d0be6a1ecc343d29ff8e1df0ddf961ab9c772", "target": 0, "func": "static int parse_presentation_segment(AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size,\n\n                                      int64_t pts)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    int x, y, ret;\n\n\n\n    int w = bytestream_get_be16(&buf);\n\n    int h = bytestream_get_be16(&buf);\n\n\n\n    ctx->presentation.pts = pts;\n\n\n\n    av_dlog(avctx, \"Video Dimensions %dx%d\\n\",\n\n            w, h);\n\n    ret = ff_set_dimensions(avctx, w, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Skip 1 bytes of unknown, frame rate? */\n\n    buf++;\n\n\n\n    ctx->presentation.id_number = bytestream_get_be16(&buf);\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     state\n\n     *     palette_update_flag (0x80),\n\n     *     palette_id_to_use,\n\n     */\n\n    buf += 3;\n\n\n\n    ctx->presentation.object_number = bytestream_get_byte(&buf);\n\n    ctx->presentation.composition_flag = 0;\n\n    if (!ctx->presentation.object_number)\n\n        return 0;\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     object_id_ref (2 bytes),\n\n     *     window_id_ref,\n\n     */\n\n    buf += 3;\n\n    ctx->presentation.composition_flag = bytestream_get_byte(&buf);\n\n\n\n    x = bytestream_get_be16(&buf);\n\n    y = bytestream_get_be16(&buf);\n\n\n\n    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/\n\n\n\n    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);\n\n\n\n    if (x > avctx->width || y > avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",\n\n               x, y, avctx->width, avctx->height);\n\n        x = 0; y = 0;\n\n    }\n\n\n\n    /* Fill in dimensions */\n\n    ctx->presentation.x = x;\n\n    ctx->presentation.y = y;\n\n\n\n    return 0;\n\n}\n", "idx": 10253, "substitutes": {"avctx": [" avcontext", "ovcontext", "avefc", "avecontext", "avercmp", " avcf", "navcu", "avsys", "avercb", "avesys", "avcmd", "ajcu", "wavcp", "afcf", "ajcb", "averctx", "avcmp", "navkl", "avercfg", "avetx", "avetmp", "afpkg", "wavkl", "aftx", "abtx", "navcp", "abpkg", "wavctx", "navctx", "AVctx", "avcontext", "awcp", "ajtmp", "avercontext", "ajctx", "avectx", "ajtx", "afcmp", "avertmp", "avtmp", "avcfg", "ajcontext", " avtx", "averfc", "wavtx", "avcu", " avcmd", "ovcp", "ajcfg", "avcf", "afctx", "ovctx", "AVtx", "ajcmd", "avcb", "AVcontext", "abctx", "AVcp", "awcmp", " avcmp", "avecf", "wavfc", "wavcmd", " avcfg", "ajsys", "avecb", "afcontext", "wavcontext", "navpkg", "abcontext", "wavpkg", "awctx", " avcp", "navcontext", "avfc", "AVcmp", " avpkg", "avcp", " avcu", "avecmp", "awtx", "avkl", "navtx", "ovcu", "aversys", "afkl", "wavcmp", "avertx", "avtx", "avpkg", "avercu"], "buf": ["doc", "cam", "alloc", "proc", "func", "prop", "rw", "Buffer", "block", "progress", "desc", "queue", "data", "cap", "fam", "b", "alph", "cmd", "comm", "cv", "conv", "arr", "read", "uf", "rb", "ff", "keep", "bc", "args", "ptr", "bs", "uffer", "usr", "emb", "gen", "cast", "Buff", "ob", "vals", "batch", "pack", "img", "bf", "mb", "xff", "buffer", "mat", "bp", "vec", "cur", "ref", "tab", "raw", "window", "mem", "bg", "good", "fac", "broad", "db", "bar", "bag", "len", "aka", "begin", "p", "pool", "seq", "cf", "pkg", "cb", "bytes", "br", "pb", "v", "far", "aw", "ctr", "kw", "coord", "buff", "msg", "length", "wb"], "buf_size": ["buffer_len", "buffer_size", "buf_len", "buf_name", "buffer_scale", "buffer_name", "buf_scale"], "pts": [" ptids", "ports", "cts", "colls", "aptts", "prls", "ntS", "ctls", "ctts", "portts", "ptns", "ptt", "colns", " PTs", "ptls", "prns", " PTt", " PTS", "ptts", "ntts", "aptls", "ptids", "ptps", "colts", "nts", "ptS", "apts", "prs", "prts", "ntls", "aptps", "ntns", "portls", " ptS", "cols", " PTids", "ctps", "ntids", "portps", "ntt", " ptt"], "ctx": ["jac", "tm", "ck", "xp", "tx", "cmp", "abc", "config", "prefix", "ctrl", "crit", " cx", "tk", "req", "ct", "init", "proc", "iac", "kt", "cl", "pool", " context", "func", "cp", "cf", "nt", "xc", "bc", "dc", "act", "jp", "tc", "pkg", "np", "wx", "local", "cb", "ctl", "ia", "cc", "addr", "expr", "qt", "cond", "kl", "mc", "cas", "check", "ac", "lc", "conn", "cfg", "acl", "mk", "gc", "c", "anc", "cmd", "exec", "hw", "kw", "cm", "etc", "fc", "context", "comm", "co", "cv", "history", "loc", "conv", "ca"], "x": ["xp", "on", "xy", "tx", "id", "mx", "at", "mm", "p", "value", "o", "height", "ex", "ox", "xc", "dx", "xd", "size", "l", "wx", "lon", "m", "X", "i", "position", "length", "xs", "lat", "index", "rx", "ix", "data", "n", "im", "px", "v", "xi", " ax", "xt", "h", "w", "xx", "zx", "yx", "xml", "ax", "fx", "xa", "lex", " xx", "el", "ux", "xf"], "y": ["key", "yt", "py", "ity", "xy", "ya", "axy", "sky", "ty", "ch", "vy", "ady", "yy", "yi", "wy", "p", "o", "ay", "height", "ry", "yn", "oy", "my", "ies", "ye", "i", "yer", "dy", "lat", "scroll", "index", "ys", "j", "t", "Y", "v", "hot", "yo", "asy", "ey", "b", "c", "h", "ery", "uy", "sy", "ym", "gy", "sys", "fy", "iy", "ot", "er", "by", "it", "z", "table", "yl", "ny", "hy", "kit", "cy"], "ret": ["tf", "len", "tr", "num", "reset", "status", "got", "back", "err", "det", "nz", "RET", "p", "resp", "value", "f", "nt", "rev", "ref", "fun", "mt", "pret", "git", "cb", "def", "after", "vt", " Ret", "zero", "txt", "usr", "alt", "ter", "r", "j", "final", "t", "rem", "rets", "v", "deg", "repl", "val", "Ret", "xt", "red", "rt", "re", "elt", "res", "it", "result", "gt", "no", "ll", "ft", "dr", "out"]}}
{"project": "qemu", "commit_id": "39a7a362e16bb27e98738d63f24d1ab5811e26a8", "target": 0, "func": "void qemu_coroutine_delete(Coroutine *co_)\n\n{\n\n    CoroutineThreadState *s = coroutine_get_thread_state();\n\n    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);\n\n\n\n    if (s->pool_size < POOL_MAX_SIZE) {\n\n        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);\n\n        co->base.caller = NULL;\n\n        s->pool_size++;\n\n        return;\n\n    }\n\n\n\n    g_free(co->stack);\n\n    g_free(co);\n\n}\n", "idx": 10266, "substitutes": {"co_": ["fo_", "ico_", "CO_", "coe_"], "s": ["sq", "sl", "qs", "a", "ats", "q", "rs", "hs", "sp", "p", "gs", "sts", "o", "ps", "g", "cs", "m", "sv", "i", "so", "r", "is", "js", "S", "ss", "ts", "se", "n", "t", "state", "self", "v", "os", "sb", "b", "c", "sw", "h", "sa", "ns", "fs", "serv", "ls", "ims", "ds", "sys", "store"], "co": ["col", "oc", "cons", "obj", "ko", "aco", "con", "cmp", "fo", "ctrl", " Co", "coe", "ee", "cro", "o", " CO", "Co", "circ", "ne", "xc", "flo", "mo", "ano", "local", "fe", "cc", "so", "ce", "cal", "none", "row", "oo", "cod", "coll", "wo", "ci", "bo", "yo", "gc", "c", "copy", "ro", "can", "po", "oe", "nc", "cu", "fc", "coord", "CO", "cv", "lo", "no", "soc", "ico"], "pool_size": ["pool__size", "pool64len", "pool__value", "pool64max", "pool64count", "thread_size", "thread_max", "Pool_size", "pool_count", "Pool_name", "pool64size", "pool_value", "pool__name", "thread_len", "pool_name", "thread_count", "Pool_value", "pool_len", "pool_max", "pool__SIZE", "Pool_SIZE", "pool_SIZE"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 10268, "substitutes": {"a": ["ba", "era", "na", "la", "aj", "al", "at", "va", "aka", "ao", "ak", "as", "p", "ach", "o", "an", "f", "au", "am", "da", "aaa", "ae", "l", "ata", "i", "ab", "ia", "ea", "r", "apt", "ga", "ma", "alpha", "isa", "y", "t", "ac", "e", "b", "eas", "out", "A", "h", "sa", "w", "x", "att", "aa", "s", "oa", "aq", "ar", "ca"], "STATUS_PARAM": ["STATUS_PARam", "STATUS_PAREM", "STATUS_PEM", "STATUS_Fam", "STATUS_Pam", "STATUS_PARAMS", "STATUS_PAM", "STATUS_ARAM", "STATUS_AREM", "STATUS_PAMS", "STATUS_ARam", "STATUS_ARAMS", "STATUS_FEM", "STATUS_FAM", "STATUS_FAMS"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_tx_bufs(int tpm_fd,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        error_report(\"tpm_passthrough: error while transmitting data \"\n\n                     \"to TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n        goto err_exit;\n\n    }\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        error_report(\"tpm_passthrough: error while reading data from \"\n\n                     \"TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10269, "substitutes": {"tpm_fd": ["tmm_fd", "tcm_dir", "tcm_pid", "tcm_fd", "tpm__pid", "tmm_pid", "tpm_dir", "tpm_pid", "tcm_fp", "tpm__cond", "tpm_fp", "tcm_cond", "tmm_handle", "tmm_fp", "tpm_cond", "tpm__handle", "tpm_handle", "tpm__fd", "tcm_handle"], "in": ["doc", "inner", "on", "inc", "con", "add", "init", "or", "as", "p", "f", "bin", "ind", "ex", "ins", "i", "IN", "gin", "din", "en", "is", "data", "t", "ac", "old", "conf", "info", "input", "inf", "c", "rin", "it", "s", "vin", "inn"], "in_len": ["in55len", " in_ls", "in55lis", "in_lit", " in_length", "in_en", "tx_lt", "intlen", "in_length", "oin_len", "intlength", "tx_lim", "inetylim", "txetylt", "in55en", "oin_en", "inetylen", "in_lis", "intlim", "intlt", "in55lit", "inetylt", "oin_lit", "in_lt", "in_ls", "txetylim", "in_lim", "inetylength", "tx_len", "oin_lis", "txetylength", "txetylen", "tx_length"], "out": ["output", "on", "obj", "op", "off", "net", "con", "at", "ch", "io", "aos", "up", "end", "err", "or", "chan", "list", "to", "file", "p", "o", "OUT", "bin", "ex", "nt", "other", "outs", "client", "null", "ou", "txt", "Out", "ext", "data", "n", "t", "new", "conn", "old", "cache", "b", "c", "copy", "ot", "str", "w", "sys", "res", "by", "it", "set", "gt", "msg", "no", "name", "OU"], "out_len": ["conn_len", "conn64vec", "out_lf", "out_lan", " out2gl", "conn_vec", " out2le", " out_ln", "out_vec", "conn_Len", " out_lan", "conn64lf", "out_del", "out2len", "out_gl", "out64len", "out2le", " out_gl", " out_Len", "out2lan", " out_le", "out2gl", " out2lan", "out64lf", "out64Len", "out_Len", " out_del", "conn64len", "out_le", "out64vec", "conn_lf", "conn64Len", " out2len", "out_ln"], "ret": ["reset", "add", "format", "print", "reply", "ry", "cat", " Ret", "desc", "r", "row", "t", "rem", "deg", "rect", "cmd", "elt", "sr", "opt", "vet", "rm", "result", "ll", "arg", "arr", "tr", "status", "code", "RET", "buf", "iter", "sec", "jp", "pret", "usr", "ort", "ter", "try", "final", "aux", "rets", "Ret", "rt", "att", "get", "net", "mb", "url", "buffer", "back", "err", "resp", "nt", "ref", "inter", "def", "mem", "ts", "reg", "tmp", "cert", "gb", "round", "db", "ft", "mt", "len", "lt", "empty", "lit", "oret", "flag", "det", "fun", "addr", "alt", "ext", "cont", "j", "val", "re", "res", "ber", "set", "gt", " fut", "store"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,\n\n                        uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    target_phys_addr_t phys_addr;\n\n    target_ulong page;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        phys_addr = cpu_get_phys_page_debug(env, page);\n\n        /* if no physical page mapped, return an error */\n\n        if (phys_addr == -1)\n\n            return -1;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n\n        if (is_write)\n\n            cpu_physical_memory_write_rom(phys_addr, buf, l);\n\n        else\n\n            cpu_physical_memory_rw(phys_addr, buf, l, is_write);\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10278, "substitutes": {"env": ["doc", "vs", "ah", "map", "pe", "config", "ei", "ee", "eh", "end", "rb", "ev", "uv", "sp", "eng", "te", "ptr", "cb", "desc", "vt", "window", "shell", "txt", "en", "vm", "ctx", "conn", "conf", "v", "site", "environment", "e", "sw", "nc", "org", "context", "set", "exc", "nv", "viron"], "addr": ["align", "arr", "key", "art", "id", "address", "url", "map", "a", "add", "order", "req", "err", "sp", "hash", "p", "pad", "ld", "pg", "ip", "g", "rev", "pos", "ref", "attr", "ap", "ptr", "arch", "i", "lp", "adr", "ord", "mem", "index", "r", "rel", "row", "ix", "lag", "node", "ad", "t", "sha", "rc", "cmd", "ag", "elt", "start", "load", "res", "alias", "adj", "link", "x", "coord", "msg", "max", "loc", "offset", "ar", "dr", "mt", "store"], "buf": ["arr", "doc", " buffer", "mb", "map", "buffer", "text", "bu", "uf", "rb", "p", "bl", "seq", "pad", "iter", "bc", " buff", "rw", "block", "vec", "Buffer", "ref", "fb", "cb", "length", "raw", "bytes", "txt", "queue", "mem", "data", "br", "pb", "cap", "v", "cache", "b", "cmd", "h", "offset", "str", "Buff", "batch", "buff", "msg", "cv", "img", "bag", "out", "wb"], "len": ["lt", "lit", "la", "lim", "ll", "nl", "fl", "lan", "li", "lang", "Len", "err", "list", "seq", "ld", "iter", "d", "vec", "limit", "m", "gl", "late", "pos", "hl", "lon", "lf", "length", "lp", "en", "all", "mem", "ln", "rel", "data", "kl", "n", "dl", "t", "lc", "v", "pl", "val", "h", "offset", "elt", "msg", "ls", "el", "le", "L", "size"], "is_write": ["is_add", "iswebwrite", " is_connect", "is2written", "iswebwritten", " is_writ", "is2add", " is_only", " is_writer", "is_writer", "is_only", " is_written", " is_add", "iswebwrit", "is_weight", " is_weight", "is_writ", "is_connect", "is2writ", "is_written", "iswebadd", "is2write"], "l": ["ml", "lt", "lit", "la", "lb", "sl", "al", "nl", "fl", "lan", "li", "list", "p", "o", "f", "lu", "ld", "lam", "d", "lv", "gl", "limit", "m", "g", "hl", "i", "lf", "le", "lp", "en", "ell", "ln", "il", "r", "j", "kl", "n", "dl", "t", "tl", "v", "lc", "pl", "line", "b", " L", "c", "ly", "h", "w", "x", "z", "lis", "lay", "ls", "el", "lic", "lo", "ll", "L", "length"], "phys_addr": ["physnetvr", "mag_ack", "las___adr", "cpu_page", "phys___port", "mag_sta", "physacpage", "physacaddr", "phys__addr", "physikpage", "phys_sta", "physnetaddr", "phy_ptr", "phys_vr", "physical_address", "physipptr", "phys___address", "cpuikaddr", "phys_port", "healthnetmt", "phys2addr", "mag_area", "phys2adr", "las___port", "phys_address", "cpuikadr", "physptack", "phys___addr", "health_offset", "healthnetaddr", "phys_page", "cpuikpage", "phys__ord", "physical_ord", "las___addr", "physikadr", "physikaddr", "phys__adr", "mag_addr", "healthnetvr", "magptarea", "magptaddr", "phys_adr", "physical_adr", "physnetmt", "physptsta", "phys___adr", "physacadr", "physptarea", "physipref", "phys2page", "phys_ref", "physistaddress", "physipaddr", "phy_tab", "magptack", "physical_addr", "las___address", "magptsta", "physptaddr", "physiptab", "las_port", "las_adr", "health_addr", "phys_mt", "health_mt", "phys__address", "phy_addr", "physistaddr", "las_address", "phy_ref", "phys_ord", "physnetoffset", "phys_offset", "physistadr", "physistport", "health_vr", "phys_ack", "healthnetoffset", "cpu_adr", "cpu_addr", "phys_area", "phys_tab", "las_addr", "phys_ptr"], "page": ["key", "num", "id", "net", "address", "url", "me", "pp", "pointer", "base", "order", "bp", "image", "step", "Page", "p", "point", "sp", "pool", "number", "PA", "slot", "pages", "pg", "ip", "phase", "block", "ref", "phrase", "limit", "ptr", "i", "port", "window", "index", "r", "row", "j", "node", "perm", "v", "site", "pl", "line", "offset", "load", "link", "age", "disk", "le", "pid", "size", "pa"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq *irq, qemu_irq dma, omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = irq[0];\n\n    s->rxirq = irq[1];\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 10282, "substitutes": {"system_memory": ["System_storage", " system_storage", "System_memory", " system_media", " system_mem", "system_media", "System_mem", "system_storage", "System_media", "system_mem"], "base": ["id", "address", "buffer", "prefix", " bases", "based", "bp", " from", " Base", "bas", "p", " address", "eta", "domain", "ase", "m", " basis", "zero", " bas", " db", "bs", " erase", "server", "bound", "ma", "data", "root", " b", "self", " BASE", "e", "b", "out", "h", "bal", "re", " bound", "x", "space", "memory", "name", "Base", "size", "ASE", "sys"], "irq": ["irtqq", " irqs", "prq", "ibrq", "interqq", "ibrv", "irtq", "irv", "interquick", " irqi", "irquick", " ircharge", "iraqs", "ireqq", "preq", "interq", "pirv", "irqs", "ibrqs", "irteq", "iraqi", "prqq", "irev", "ibrqi", "irqi", "pircharge", " irv", "pirq", "irtquick", "ireq", "irav", "irecharge", "pirqq", "intereq", "prquick", " irqq", "irqq", "iraq", "ircharge"], "dma": ["dnma", "dnmac", "dmmac", "dmma", "Dmas", "sdhma", " Dma", "dmhma", " Dmas", " Dpa", "dmac", "dmmas", "dhma", "sdmas", "sdma", "dnmas", "dnhma", "dpa", "sdmac", "Dma", "Dpa", " dpa", " dmas", "dmas"], "clk": ["CLk", "blk", "clz", "blks", "CLks", " clz", "blj", " clks", "clj", "clks", "blz", " clj", "CLz", "CLj"], "s": ["ms", "vs", "ats", "hs", "o", "d", "m", "bits", "ins", "details", "r", "se", "y", "t", "os", "has", "b", "sa", "w", "comm", "ims", "ers", "ports", "settings", "gs", "sts", "changes", "g", "ies", "sv", "sam", "bs", "services", "als", "js", "less", "ss", "e", "sb", "z", "ls", "states", "state", "sq", "spec", "sl", "a", "rs", "izes", "l", "es", "i", "store", "ts", "n", "ns", "space", "ds", "out", "sync", " is", "p", "ps", "service", "save", "aws", "is", "j", "S", "its", "v", "c", "h", "stats", "fs", "set", "sys", "parts"]}}
{"project": "qemu", "commit_id": "66668d197fa40747e835e15617eda2f1bc80982f", "target": 0, "func": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    VncPalette *palette = &color_count_palette;\n\n    uint32_t bg = 0, fg = 0;\n\n    int colors;\n\n    int ret = 0;\n\n#ifdef CONFIG_VNC_JPEG\n\n    bool force_jpeg = false;\n\n    bool allow_jpeg = true;\n\n#endif\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n\n\n\n    vnc_tight_start(vs);\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vnc_tight_stop(vs);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n\n        double freq = vnc_update_freq(vs, x, y, w, h);\n\n\n\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n\n            allow_jpeg = false;\n\n        }\n\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n\n            force_jpeg = true;\n\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n\n        }\n\n    }\n\n#endif\n\n\n\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n\n                                 force_jpeg);\n\n    } else {\n\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n    }\n\n#else\n\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 10291, "substitutes": {"vs": ["ms", "forces", "Vs", "vy", "hs", "uv", "vp", "cs", "boxes", "bits", "ins", "heads", "fps", "details", "videos", "lbs", "os", "ears", "caps", "ims", "versions", "ports", "gets", "gs", "sts", "atts", "changes", "sv", "xs", "lists", "bs", "js", "ss", "ops", "sb", "ks", "vals", "ams", "ls", "ues", "otes", "vers", "helps", "tops", "qs", "names", "rs", "as", "VS", "ints", "lines", "docs", "dates", "es", "blogs", "vt", "terms", "pps", "ts", "views", "styles", "uds", "ns", "vr", "s", "vc", "ds", "iffs", "obs", "eps", "ps", "verts", "inv", "posts", "its", "v", "stats", "fs", "sys"], "x": ["xp", "op", "xy", "tx", "on", "mx", "at", "mm", "ct", "p", "ex", "ry", "ox", "dx", "xc", "xd", "ip", "m", "l", "wx", "act", "X", "i", "xs", "ic", "xxxx", "lat", "r", "try", "rx", "ix", "im", "create", "px", "v", "xi", "search", "xt", "c", "xx", "xml", "it", "z", "ax", "fx", "xa", "get", "el", "lex", "xf"], "y": ["key", "py", "yt", "xy", "ya", "axy", "et", "ty", "ch", "vy", "yy", "wy", "p", "ay", "ry", "yn", "oy", "my", "ies", "client", "i", "ye", "ia", "yer", "try", "ys", "j", "icy", "sys", "Y", "v", "hot", "asy", "ey", "b", "ery", "gy", "sy", "ym", "fy", "uy", "iy", "any", "ot", "by", "er", "it", "get", "yl", "ny", "hy", "cy"], "w": ["ow", "fw", "ww", "ch", "iw", "wal", "weight", "p", "we", "W", "ex", "f", "d", "rw", "wr", "th", "way", "m", "l", "win", "wh", "word", "window", "ew", "wa", "r", "wl", "n", "now", "t", "wn", "wd", "v", "aw", "b", "sw", "wt", "wp", "str", "hw", "kw", "rew", "z", "tw", "nw", "wb"], "h": ["ow", "ash", "hal", "he", "ph", "ah", "hr", "hm", "each", "ch", "or", "as", "ht", "k", "hs", "p", "hash", "height", "o", "size", "th", "m", "l", "hd", "hl", "length", "wh", "window", "oh", "ho", "hh", "ish", "r", "http", "html", "t", "count", "v", "info", "ha", "hei", "rh", "cache", "has", "b", "c", "sh", "bh", "kh", "hw", "ih", "it", "z", "hi", "head", "no", "history", "hz", "H"], "palette": ["plorset", "colorset", "colet", " pallette", "palestyle", "pallette", "proet", "filte", "plors", "colette", "schelette", "localors", "alte", "plette", "schete", " palgorithm", "Pallete", "locallette", "proette", "palgorithm", "palettes", "packte", "colte", "fillette", "prolete", "collete", " palestyle", "alette", "alettes", "filette", "scheestyle", "packette", "packettes", "collette", "palet", "Palet", "palorset", "colestyle", "packgorithm", "scheette", "palte", "Pallette", "algorithm", "pllette", "Palette", "filestyle", " palettes", "localorset", " palte", "alestyle", "palors", "localette", "allette", "pallete", "prolette"], "colors": [" coluers", "colers", "Colorset", "colograms", "colorset", "palals", "Colers", "paluers", "palners", "colients", "icolorset", "icolograms", "palor", "actners", "palograms", "palients", "actuers", "actors", " colograms", " colores", "icolor", " color", "icolals", "Colients", "palores", "coluers", "icolores", "palers", " colners", "colorors", " colers", "colours", " colorset", "colorals", "filorset", "palorset", "colores", "filor", "colorers", "Color", "actorset", "colners", "colals", "filores", "icolours", "Colores", "palours", "color", " colients", "palors", "colororset", "filors", " colours", "icolers", "icolors", "Colors"]}}
{"project": "qemu", "commit_id": "5238c88657d751e3acf3e953a9b11f5f24262f75", "target": 0, "func": "static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)\n\n{\n\n    uint32_t palcode;\n\n    int32_t disp21, disp16;\n\n#ifndef CONFIG_USER_ONLY\n\n    int32_t disp12;\n\n#endif\n\n    uint16_t fn11;\n\n    uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit;\n\n    uint8_t lit;\n\n    ExitStatus ret;\n\n\n\n    /* Decode all instruction fields */\n\n    opc = insn >> 26;\n\n    ra = (insn >> 21) & 0x1F;\n\n    rb = (insn >> 16) & 0x1F;\n\n    rc = insn & 0x1F;\n\n    real_islit = islit = (insn >> 12) & 1;\n\n    if (rb == 31 && !islit) {\n\n        islit = 1;\n\n        lit = 0;\n\n    } else\n\n        lit = (insn >> 13) & 0xFF;\n\n    palcode = insn & 0x03FFFFFF;\n\n    disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11;\n\n    disp16 = (int16_t)(insn & 0x0000FFFF);\n\n#ifndef CONFIG_USER_ONLY\n\n    disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20;\n\n#endif\n\n    fn11 = (insn >> 5) & 0x000007FF;\n\n    fpfn = fn11 & 0x3F;\n\n    fn7 = (insn >> 5) & 0x0000007F;\n\n    LOG_DISAS(\"opc %02x ra %2d rb %2d rc %2d disp16 %6d\\n\",\n\n              opc, ra, rb, rc, disp16);\n\n\n\n    ret = NO_EXIT;\n\n    switch (opc) {\n\n    case 0x00:\n\n        /* CALL_PAL */\n\n        ret = gen_call_pal(ctx, palcode);\n\n        break;\n\n    case 0x01:\n\n        /* OPC01 */\n\n        goto invalid_opc;\n\n    case 0x02:\n\n        /* OPC02 */\n\n        goto invalid_opc;\n\n    case 0x03:\n\n        /* OPC03 */\n\n        goto invalid_opc;\n\n    case 0x04:\n\n        /* OPC04 */\n\n        goto invalid_opc;\n\n    case 0x05:\n\n        /* OPC05 */\n\n        goto invalid_opc;\n\n    case 0x06:\n\n        /* OPC06 */\n\n        goto invalid_opc;\n\n    case 0x07:\n\n        /* OPC07 */\n\n        goto invalid_opc;\n\n    case 0x08:\n\n        /* LDA */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x09:\n\n        /* LDAH */\n\n        if (likely(ra != 31)) {\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(cpu_ir[ra], cpu_ir[rb], disp16 << 16);\n\n            } else {\n\n                tcg_gen_movi_i64(cpu_ir[ra], disp16 << 16);\n\n            }\n\n        }\n\n        break;\n\n    case 0x0A:\n\n        /* LDBU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld8u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0B:\n\n        /* LDQ_U */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x0C:\n\n        /* LDWU */\n\n        if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n            gen_load_mem(ctx, &tcg_gen_qemu_ld16u, ra, rb, disp16, 0, 0);\n\n            break;\n\n        }\n\n        goto invalid_opc;\n\n    case 0x0D:\n\n        /* STW */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st16, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0E:\n\n        /* STB */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st8, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x0F:\n\n        /* STQ_U */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 1);\n\n        break;\n\n    case 0x10:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x02:\n\n            /* S4ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x09:\n\n            /* SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0B:\n\n            /* S4SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x0F:\n\n            /* CMPBGE */\n\n            gen_cmpbge(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x12:\n\n            /* S8ADDL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1B:\n\n            /* S8SUBL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(tmp, tmp, lit);\n\n                    } else {\n\n                       tcg_gen_sub_i64(tmp, tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], tmp);\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                        tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x1D:\n\n            /* CMPULT */\n\n            gen_cmp(TCG_COND_LTU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x20:\n\n            /* ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x22:\n\n            /* S4ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x29:\n\n            /* SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2B:\n\n            /* S4SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 2);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x2D:\n\n            /* CMPEQ */\n\n            gen_cmp(TCG_COND_EQ, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* S8ADDQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_addi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_add_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* S8SUBQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv tmp = tcg_temp_new();\n\n                    tcg_gen_shli_i64(tmp, cpu_ir[ra], 3);\n\n                    if (islit) {\n\n                        tcg_gen_subi_i64(cpu_ir[rc], tmp, lit);\n\n                    } else {\n\n                        tcg_gen_sub_i64(cpu_ir[rc], tmp, cpu_ir[rb]);\n\n                    }\n\n                    tcg_temp_free(tmp);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], -lit);\n\n                    } else {\n\n                        tcg_gen_neg_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x3D:\n\n            /* CMPULE */\n\n            gen_cmp(TCG_COND_LEU, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x40:\n\n            /* ADDL/V */\n\n            gen_addlv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x49:\n\n            /* SUBL/V */\n\n            gen_sublv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x4D:\n\n            /* CMPLT */\n\n            gen_cmp(TCG_COND_LT, ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* ADDQ/V */\n\n            gen_addqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x69:\n\n            /* SUBQ/V */\n\n            gen_subqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x6D:\n\n            /* CMPLE */\n\n            gen_cmp(TCG_COND_LE, ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x11:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* AND */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_and_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x08:\n\n            /* BIC */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_andc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x14:\n\n            /* CMOVLBS */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x16:\n\n            /* CMOVLBC */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 1);\n\n            break;\n\n        case 0x20:\n\n            /* BIS */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_or_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* CMOVEQ */\n\n            gen_cmov(TCG_COND_EQ, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x26:\n\n            /* CMOVNE */\n\n            gen_cmov(TCG_COND_NE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x28:\n\n            /* ORNOT */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_ori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_orc_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* XOR */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_xor_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], lit);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x44:\n\n            /* CMOVLT */\n\n            gen_cmov(TCG_COND_LT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x46:\n\n            /* CMOVGE */\n\n            gen_cmov(TCG_COND_GE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x48:\n\n            /* EQV */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_xori_i64(cpu_ir[rc], cpu_ir[ra], ~lit);\n\n                    } else {\n\n                        tcg_gen_eqv_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ~lit);\n\n                    } else {\n\n                        tcg_gen_not_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        case 0x61:\n\n            /* AMASK */\n\n            if (likely(rc != 31)) {\n\n                uint64_t amask = ctx->tb->flags >> TB_FLAGS_AMASK_SHIFT;\n\n\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], lit & ~amask);\n\n                } else {\n\n                    tcg_gen_andi_i64(cpu_ir[rc], cpu_ir[rb], ~amask);\n\n                }\n\n            }\n\n            break;\n\n        case 0x64:\n\n            /* CMOVLE */\n\n            gen_cmov(TCG_COND_LE, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x66:\n\n            /* CMOVGT */\n\n            gen_cmov(TCG_COND_GT, ra, rb, rc, islit, lit, 0);\n\n            break;\n\n        case 0x6C:\n\n            /* IMPLVER */\n\n            if (rc != 31) {\n\n                tcg_gen_movi_i64(cpu_ir[rc], ctx->implver);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x12:\n\n        switch (fn7) {\n\n        case 0x02:\n\n            /* MSKBL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x06:\n\n            /* EXTBL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x0B:\n\n            /* INSBL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x01);\n\n            break;\n\n        case 0x12:\n\n            /* MSKWL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x16:\n\n            /* EXTWL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x1B:\n\n            /* INSWL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x22:\n\n            /* MSKLL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x26:\n\n            /* EXTLL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x2B:\n\n            /* INSLL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x30:\n\n            /* ZAP */\n\n            gen_zap(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x31:\n\n            /* ZAPNOT */\n\n            gen_zapnot(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x32:\n\n            /* MSKQL */\n\n            gen_msk_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x34:\n\n            /* SRL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shri_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shr_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x36:\n\n            /* EXTQL */\n\n            gen_ext_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x39:\n\n            /* SLL */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x3B:\n\n            /* INSQL */\n\n            gen_ins_l(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x3C:\n\n            /* SRA */\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    if (islit) {\n\n                        tcg_gen_sari_i64(cpu_ir[rc], cpu_ir[ra], lit & 0x3f);\n\n                    } else {\n\n                        TCGv shift = tcg_temp_new();\n\n                        tcg_gen_andi_i64(shift, cpu_ir[rb], 0x3f);\n\n                        tcg_gen_sar_i64(cpu_ir[rc], cpu_ir[ra], shift);\n\n                        tcg_temp_free(shift);\n\n                    }\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x52:\n\n            /* MSKWH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x57:\n\n            /* INSWH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x5A:\n\n            /* EXTWH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x03);\n\n            break;\n\n        case 0x62:\n\n            /* MSKLH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x67:\n\n            /* INSLH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x6A:\n\n            /* EXTLH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0x0f);\n\n            break;\n\n        case 0x72:\n\n            /* MSKQH */\n\n            gen_msk_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x77:\n\n            /* INSQH */\n\n            gen_ins_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        case 0x7A:\n\n            /* EXTQH */\n\n            gen_ext_h(ra, rb, rc, islit, lit, 0xff);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x13:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* MULL */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else {\n\n                    if (islit) {\n\n                        tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                    } else {\n\n                        tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                    }\n\n                    tcg_gen_ext32s_i64(cpu_ir[rc], cpu_ir[rc]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x20:\n\n            /* MULQ */\n\n            if (likely(rc != 31)) {\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                } else if (islit) {\n\n                    tcg_gen_muli_i64(cpu_ir[rc], cpu_ir[ra], lit);\n\n                } else {\n\n                    tcg_gen_mul_i64(cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x30:\n\n            /* UMULH */\n\n            {\n\n                TCGv low;\n\n                if (unlikely(rc == 31)){\n\n                    break;\n\n                }\n\n                if (ra == 31) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                    break;\n\n                }\n\n                low = tcg_temp_new();\n\n                if (islit) {\n\n                    tcg_gen_movi_tl(low, lit);\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], low);\n\n                } else {\n\n                    tcg_gen_mulu2_i64(low, cpu_ir[rc], cpu_ir[ra], cpu_ir[rb]);\n\n                }\n\n                tcg_temp_free(low);\n\n            }\n\n            break;\n\n        case 0x40:\n\n            /* MULL/V */\n\n            gen_mullv(ra, rb, rc, islit, lit);\n\n            break;\n\n        case 0x60:\n\n            /* MULQ/V */\n\n            gen_mulqv(ra, rb, rc, islit, lit);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x14:\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x04:\n\n            /* ITOFS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_s(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x0A:\n\n            /* SQRTF */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtf(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x0B:\n\n            /* SQRTS */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrts(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x14:\n\n            /* ITOFF */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_trunc_i64_i32(tmp, cpu_ir[ra]);\n\n                    gen_helper_memory_to_f(cpu_fir[rc], tmp);\n\n                    tcg_temp_free_i32(tmp);\n\n                } else\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n            }\n\n            break;\n\n        case 0x24:\n\n            /* ITOFT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_fir[rc], cpu_ir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x2A:\n\n            /* SQRTG */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtg(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x02B:\n\n            /* SQRTT */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_FIX) {\n\n                gen_fsqrtt(ctx, rb, rc, fn11);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x15:\n\n        /* VAX floating point */\n\n        /* XXX: rounding mode and trap are ignored (!) */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDF */\n\n            gen_faddf(ra, rb, rc);\n\n            break;\n\n        case 0x01:\n\n            /* SUBF */\n\n            gen_fsubf(ra, rb, rc);\n\n            break;\n\n        case 0x02:\n\n            /* MULF */\n\n            gen_fmulf(ra, rb, rc);\n\n            break;\n\n        case 0x03:\n\n            /* DIVF */\n\n            gen_fdivf(ra, rb, rc);\n\n            break;\n\n        case 0x1E:\n\n            /* CVTDG */\n\n#if 0 // TODO\n\n            gen_fcvtdg(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x20:\n\n            /* ADDG */\n\n            gen_faddg(ra, rb, rc);\n\n            break;\n\n        case 0x21:\n\n            /* SUBG */\n\n            gen_fsubg(ra, rb, rc);\n\n            break;\n\n        case 0x22:\n\n            /* MULG */\n\n            gen_fmulg(ra, rb, rc);\n\n            break;\n\n        case 0x23:\n\n            /* DIVG */\n\n            gen_fdivg(ra, rb, rc);\n\n            break;\n\n        case 0x25:\n\n            /* CMPGEQ */\n\n            gen_fcmpgeq(ra, rb, rc);\n\n            break;\n\n        case 0x26:\n\n            /* CMPGLT */\n\n            gen_fcmpglt(ra, rb, rc);\n\n            break;\n\n        case 0x27:\n\n            /* CMPGLE */\n\n            gen_fcmpgle(ra, rb, rc);\n\n            break;\n\n        case 0x2C:\n\n            /* CVTGF */\n\n            gen_fcvtgf(rb, rc);\n\n            break;\n\n        case 0x2D:\n\n            /* CVTGD */\n\n#if 0 // TODO\n\n            gen_fcvtgd(rb, rc);\n\n#else\n\n            goto invalid_opc;\n\n#endif\n\n            break;\n\n        case 0x2F:\n\n            /* CVTGQ */\n\n            gen_fcvtgq(rb, rc);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQF */\n\n            gen_fcvtqf(rb, rc);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQG */\n\n            gen_fcvtqg(rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x16:\n\n        /* IEEE floating-point */\n\n        switch (fpfn) { /* fn11 & 0x3F */\n\n        case 0x00:\n\n            /* ADDS */\n\n            gen_fadds(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x01:\n\n            /* SUBS */\n\n            gen_fsubs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x02:\n\n            /* MULS */\n\n            gen_fmuls(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x03:\n\n            /* DIVS */\n\n            gen_fdivs(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x20:\n\n            /* ADDT */\n\n            gen_faddt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x21:\n\n            /* SUBT */\n\n            gen_fsubt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x22:\n\n            /* MULT */\n\n            gen_fmult(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x23:\n\n            /* DIVT */\n\n            gen_fdivt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x24:\n\n            /* CMPTUN */\n\n            gen_fcmptun(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x25:\n\n            /* CMPTEQ */\n\n            gen_fcmpteq(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x26:\n\n            /* CMPTLT */\n\n            gen_fcmptlt(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x27:\n\n            /* CMPTLE */\n\n            gen_fcmptle(ctx, ra, rb, rc, fn11);\n\n            break;\n\n        case 0x2C:\n\n            if (fn11 == 0x2AC || fn11 == 0x6AC) {\n\n                /* CVTST */\n\n                gen_fcvtst(ctx, rb, rc, fn11);\n\n            } else {\n\n                /* CVTTS */\n\n                gen_fcvtts(ctx, rb, rc, fn11);\n\n            }\n\n            break;\n\n        case 0x2F:\n\n            /* CVTTQ */\n\n            gen_fcvttq(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3C:\n\n            /* CVTQS */\n\n            gen_fcvtqs(ctx, rb, rc, fn11);\n\n            break;\n\n        case 0x3E:\n\n            /* CVTQT */\n\n            gen_fcvtqt(ctx, rb, rc, fn11);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x17:\n\n        switch (fn11) {\n\n        case 0x010:\n\n            /* CVTLQ */\n\n            gen_fcvtlq(rb, rc);\n\n            break;\n\n        case 0x020:\n\n            if (likely(rc != 31)) {\n\n                if (ra == rb) {\n\n                    /* FMOV */\n\n                    if (ra == 31) {\n\n                        tcg_gen_movi_i64(cpu_fir[rc], 0);\n\n                    } else {\n\n                        tcg_gen_mov_i64(cpu_fir[rc], cpu_fir[ra]);\n\n                    }\n\n                } else {\n\n                    /* CPYS */\n\n                    gen_fcpys(ra, rb, rc);\n\n                }\n\n            }\n\n            break;\n\n        case 0x021:\n\n            /* CPYSN */\n\n            gen_fcpysn(ra, rb, rc);\n\n            break;\n\n        case 0x022:\n\n            /* CPYSE */\n\n            gen_fcpyse(ra, rb, rc);\n\n            break;\n\n        case 0x024:\n\n            /* MT_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_store_fpcr(cpu_env, cpu_fir[ra]);\n\n            } else {\n\n                TCGv tmp = tcg_const_i64(0);\n\n                gen_helper_store_fpcr(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n        case 0x025:\n\n            /* MF_FPCR */\n\n            if (likely(ra != 31)) {\n\n                gen_helper_load_fpcr(cpu_fir[ra], cpu_env);\n\n            }\n\n            break;\n\n        case 0x02A:\n\n            /* FCMOVEQ */\n\n            gen_fcmov(TCG_COND_EQ, ra, rb, rc);\n\n            break;\n\n        case 0x02B:\n\n            /* FCMOVNE */\n\n            gen_fcmov(TCG_COND_NE, ra, rb, rc);\n\n            break;\n\n        case 0x02C:\n\n            /* FCMOVLT */\n\n            gen_fcmov(TCG_COND_LT, ra, rb, rc);\n\n            break;\n\n        case 0x02D:\n\n            /* FCMOVGE */\n\n            gen_fcmov(TCG_COND_GE, ra, rb, rc);\n\n            break;\n\n        case 0x02E:\n\n            /* FCMOVLE */\n\n            gen_fcmov(TCG_COND_LE, ra, rb, rc);\n\n            break;\n\n        case 0x02F:\n\n            /* FCMOVGT */\n\n            gen_fcmov(TCG_COND_GT, ra, rb, rc);\n\n            break;\n\n        case 0x030:\n\n            /* CVTQL */\n\n            gen_fcvtql(rb, rc);\n\n            break;\n\n        case 0x130:\n\n            /* CVTQL/V */\n\n        case 0x530:\n\n            /* CVTQL/SV */\n\n            /* ??? I'm pretty sure there's nothing that /sv needs to do that\n\n               /v doesn't do.  The only thing I can think is that /sv is a\n\n               valid instruction merely for completeness in the ISA.  */\n\n            gen_fcvtql_v(ctx, rb, rc);\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x18:\n\n        switch ((uint16_t)disp16) {\n\n        case 0x0000:\n\n            /* TRAPB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x0400:\n\n            /* EXCB */\n\n            /* No-op.  */\n\n            break;\n\n        case 0x4000:\n\n            /* MB */\n\n            /* No-op */\n\n            break;\n\n        case 0x4400:\n\n            /* WMB */\n\n            /* No-op */\n\n            break;\n\n        case 0x8000:\n\n            /* FETCH */\n\n            /* No-op */\n\n            break;\n\n        case 0xA000:\n\n            /* FETCH_M */\n\n            /* No-op */\n\n            break;\n\n        case 0xC000:\n\n            /* RPCC */\n\n            if (ra != 31) {\n\n                if (use_icount) {\n\n                    gen_io_start();\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                    gen_io_end();\n\n                    ret = EXIT_PC_STALE;\n\n                } else {\n\n                    gen_helper_load_pcc(cpu_ir[ra], cpu_env);\n\n                }\n\n            }\n\n            break;\n\n        case 0xE000:\n\n            /* RC */\n\n            gen_rx(ra, 0);\n\n            break;\n\n        case 0xE800:\n\n            /* ECB */\n\n            break;\n\n        case 0xF000:\n\n            /* RS */\n\n            gen_rx(ra, 1);\n\n            break;\n\n        case 0xF800:\n\n            /* WH64 */\n\n            /* No-op */\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x19:\n\n        /* HW_MFPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mfpr(ra, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1A:\n\n        /* JMP, JSR, RET, JSR_COROUTINE.  These only differ by the branch\n\n           prediction stack action, which of course we don't implement.  */\n\n        if (rb != 31) {\n\n            tcg_gen_andi_i64(cpu_pc, cpu_ir[rb], ~3);\n\n        } else {\n\n            tcg_gen_movi_i64(cpu_pc, 0);\n\n        }\n\n        if (ra != 31) {\n\n            tcg_gen_movi_i64(cpu_ir[ra], ctx->pc);\n\n        }\n\n        ret = EXIT_PC_UPDATED;\n\n        break;\n\n    case 0x1B:\n\n        /* HW_LD (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr;\n\n\n\n            if (ra == 31) {\n\n                break;\n\n            }\n\n\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access (hw_ldl/p) */\n\n                gen_helper_ldl_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access (hw_ldq/p) */\n\n                gen_helper_ldq_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock (hw_ldl_l/p) */\n\n                gen_helper_ldl_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock (hw_ldq_l/p) */\n\n                gen_helper_ldq_l_phys(cpu_ir[ra], cpu_env, addr);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual PTE fetch (hw_ldl/v) */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual PTE fetch (hw_ldq/v) */\n\n                goto invalid_opc;\n\n                break;\n\n            case 0x6:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Incpu_ir[ra]id */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Longword virtual access (hw_ldl) */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Quadword virtual access (hw_ldq) */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Longword virtual access with protection check (hw_ldl/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LESL);\n\n                break;\n\n            case 0xB:\n\n                /* Quadword virtual access with protection check (hw_ldq/w) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_KERNEL_IDX, MO_LEQ);\n\n                break;\n\n            case 0xC:\n\n                /* Longword virtual access with alt access mode (hw_ldl/a)*/\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alt access mode (hw_ldq/a) */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Longword virtual access with alternate access mode and\n\n                   protection checks (hw_ldl/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LESL);\n\n                break;\n\n            case 0xF:\n\n                /* Quadword virtual access with alternate access mode and\n\n                   protection checks (hw_ldq/wa) */\n\n                tcg_gen_qemu_ld_i64(cpu_ir[ra], addr, MMU_USER_IDX, MO_LEQ);\n\n                break;\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1C:\n\n        switch (fn7) {\n\n        case 0x00:\n\n            /* SEXTB */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_BWX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (islit) {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int8_t)lit));\n\n                } else {\n\n                    tcg_gen_ext8s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                }\n\n            }\n\n            break;\n\n        case 0x01:\n\n            /* SEXTW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_BWX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], (int64_t)((int16_t)lit));\n\n                    } else {\n\n                        tcg_gen_ext16s_i64(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x30:\n\n            /* CTPOP */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctpop64(lit));\n\n                    } else {\n\n                        gen_helper_ctpop(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x31:\n\n            /* PERR */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_perr(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x32:\n\n            /* CTLZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], clz64(lit));\n\n                    } else {\n\n                        gen_helper_ctlz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x33:\n\n            /* CTTZ */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_CIX) {\n\n                if (likely(rc != 31)) {\n\n                    if (islit) {\n\n                        tcg_gen_movi_i64(cpu_ir[rc], ctz64(lit));\n\n                    } else {\n\n                        gen_helper_cttz(cpu_ir[rc], cpu_ir[rb]);\n\n                    }\n\n                }\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x34:\n\n            /* UNPKBW */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbw(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x35:\n\n            /* UNPKBL */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_unpkbl(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x36:\n\n            /* PKWB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pkwb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x37:\n\n            /* PKLB */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                if (real_islit || ra != 31) {\n\n                    goto invalid_opc;\n\n                }\n\n                gen_pklb(rb, rc);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x38:\n\n            /* MINSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x39:\n\n            /* MINSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3A:\n\n            /* MINUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3B:\n\n            /* MINUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_minuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3C:\n\n            /* MAXUB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxub8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3D:\n\n            /* MAXUW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxuw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3E:\n\n            /* MAXSB8 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsb8(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x3F:\n\n            /* MAXSW4 */\n\n            if (ctx->tb->flags & TB_FLAGS_AMASK_MVI) {\n\n                gen_maxsw4(ra, rb, rc, islit, lit);\n\n                break;\n\n            }\n\n            goto invalid_opc;\n\n        case 0x70:\n\n            /* FTOIT */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (likely(rc != 31)) {\n\n                if (ra != 31) {\n\n                    tcg_gen_mov_i64(cpu_ir[rc], cpu_fir[ra]);\n\n                } else {\n\n                    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n                }\n\n            }\n\n            break;\n\n        case 0x78:\n\n            /* FTOIS */\n\n            if ((ctx->tb->flags & TB_FLAGS_AMASK_FIX) == 0) {\n\n                goto invalid_opc;\n\n            }\n\n            if (rc != 31) {\n\n                TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                if (ra != 31) {\n\n                    gen_helper_s_to_memory(tmp1, cpu_fir[ra]);\n\n                } else {\n\n                    TCGv tmp2 = tcg_const_i64(0);\n\n                    gen_helper_s_to_memory(tmp1, tmp2);\n\n                    tcg_temp_free(tmp2);\n\n                }\n\n                tcg_gen_ext_i32_i64(cpu_ir[rc], tmp1);\n\n                tcg_temp_free_i32(tmp1);\n\n            }\n\n            break;\n\n        default:\n\n            goto invalid_opc;\n\n        }\n\n        break;\n\n    case 0x1D:\n\n        /* HW_MTPR (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            return gen_mtpr(ctx, rb, insn & 0xffff);\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1E:\n\n        /* HW_RET (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            if (rb == 31) {\n\n                /* Pre-EV6 CPUs interpreted this as HW_REI, loading the return\n\n                   address from EXC_ADDR.  This turns out to be useful for our\n\n                   emulation PALcode, so continue to accept it.  */\n\n                TCGv tmp = tcg_temp_new();\n\n                tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUAlphaState, exc_addr));\n\n                gen_helper_hw_ret(cpu_env, tmp);\n\n                tcg_temp_free(tmp);\n\n            } else {\n\n                gen_helper_hw_ret(cpu_env, cpu_ir[rb]);\n\n            }\n\n            ret = EXIT_PC_UPDATED;\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x1F:\n\n        /* HW_ST (PALcode) */\n\n#ifndef CONFIG_USER_ONLY\n\n        if (ctx->tb->flags & TB_FLAGS_PAL_MODE) {\n\n            TCGv addr, val;\n\n            addr = tcg_temp_new();\n\n            if (rb != 31) {\n\n                tcg_gen_addi_i64(addr, cpu_ir[rb], disp12);\n\n            } else {\n\n                tcg_gen_movi_i64(addr, disp12);\n\n            }\n\n            if (ra != 31) {\n\n                val = cpu_ir[ra];\n\n            } else {\n\n                val = tcg_temp_new();\n\n                tcg_gen_movi_i64(val, 0);\n\n            }\n\n            switch ((insn >> 12) & 0xF) {\n\n            case 0x0:\n\n                /* Longword physical access */\n\n                gen_helper_stl_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x1:\n\n                /* Quadword physical access */\n\n                gen_helper_stq_phys(cpu_env, addr, val);\n\n                break;\n\n            case 0x2:\n\n                /* Longword physical access with lock */\n\n                gen_helper_stl_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x3:\n\n                /* Quadword physical access with lock */\n\n                gen_helper_stq_c_phys(val, cpu_env, addr, val);\n\n                break;\n\n            case 0x4:\n\n                /* Longword virtual access */\n\n                goto invalid_opc;\n\n            case 0x5:\n\n                /* Quadword virtual access */\n\n                goto invalid_opc;\n\n            case 0x6:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x7:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x8:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0x9:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xA:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xB:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xC:\n\n                /* Longword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xD:\n\n                /* Quadword virtual access with alternate access mode */\n\n                goto invalid_opc;\n\n            case 0xE:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            case 0xF:\n\n                /* Invalid */\n\n                goto invalid_opc;\n\n            }\n\n            if (ra == 31) {\n\n                tcg_temp_free(val);\n\n            }\n\n            tcg_temp_free(addr);\n\n            break;\n\n        }\n\n#endif\n\n        goto invalid_opc;\n\n    case 0x20:\n\n        /* LDF */\n\n        gen_load_mem(ctx, &gen_qemu_ldf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x21:\n\n        /* LDG */\n\n        gen_load_mem(ctx, &gen_qemu_ldg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x22:\n\n        /* LDS */\n\n        gen_load_mem(ctx, &gen_qemu_lds, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x23:\n\n        /* LDT */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x24:\n\n        /* STF */\n\n        gen_store_mem(ctx, &gen_qemu_stf, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x25:\n\n        /* STG */\n\n        gen_store_mem(ctx, &gen_qemu_stg, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x26:\n\n        /* STS */\n\n        gen_store_mem(ctx, &gen_qemu_sts, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x27:\n\n        /* STT */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 1, 0);\n\n        break;\n\n    case 0x28:\n\n        /* LDL */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld32s, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x29:\n\n        /* LDQ */\n\n        gen_load_mem(ctx, &tcg_gen_qemu_ld64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2A:\n\n        /* LDL_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldl_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2B:\n\n        /* LDQ_L */\n\n        gen_load_mem(ctx, &gen_qemu_ldq_l, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2C:\n\n        /* STL */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st32, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2D:\n\n        /* STQ */\n\n        gen_store_mem(ctx, &tcg_gen_qemu_st64, ra, rb, disp16, 0, 0);\n\n        break;\n\n    case 0x2E:\n\n        /* STL_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 0);\n\n        break;\n\n    case 0x2F:\n\n        /* STQ_C */\n\n        ret = gen_store_conditional(ctx, ra, rb, disp16, 1);\n\n        break;\n\n    case 0x30:\n\n        /* BR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x31: /* FBEQ */\n\n        ret = gen_fbcond(ctx, TCG_COND_EQ, ra, disp21);\n\n        break;\n\n    case 0x32: /* FBLT */\n\n        ret = gen_fbcond(ctx, TCG_COND_LT, ra, disp21);\n\n        break;\n\n    case 0x33: /* FBLE */\n\n        ret = gen_fbcond(ctx, TCG_COND_LE, ra, disp21);\n\n        break;\n\n    case 0x34:\n\n        /* BSR */\n\n        ret = gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10295, "substitutes": {"ctx": ["jac", "work", "obj", "tx", "req", "ct", "kt", "Context", "cp", "xc", "act", "pkg", "tc", "np", "jp", "cb", "cc", "mem", "cas", "conn", "conf", "wd", "cfg", "setup", "cmd", "tmp", "hw", "kw", "KC", "cm", "sc", "fc", "context", "cv", "loc", "conv"], "insn": ["outsne", "INSns", "linsner", "resn", " insz", "itsgn", "intersnan", "csnan", " insnm", "pinsner", " insner", "itssn", "insh", "itsn", "pinsns", "linsn", "linsm", "asgn", "ainsn", "insv", "interssn", "itsner", "pinssn", "ainsns", "insne", "insns", "insnan", "itsh", "stsan", " insns", "linsgn", "timesne", "INSner", "csns", "cssn", "alsner", "statsne", "mssn", " inson", "esn", "intsns", "csm", "msn", "intssn", "esne", "intersh", "esan", "linssn", "intsm", "itsns", "insnn", "statsn", "msner", "asn", "bitsnn", "bitssn", "ainsv", "csh", "insan", "inssn", " inssn", "insner", "inson", "bitsns", "pinsv", "linsnn", "essn", "INSsn", "itsz", "intsn", "linson", "ainsan", "ressn", "outssn", "resnm", "statsgn", "pinsn", "alssn", "INSn", "alsv", "ainssn", "intersn", "stsne", "alsn", "ainsne", "resner", "timessn", "assn", "ason", "insgn", "insnm", "stsn", "insz", "linsv", "outsgn", "outsn", "bitsn", "linsz", "linsns", "insm", "stssn", "timesn", "timesgn", "itsnan", "itsv", "pinsnn", "msnm", "csn", " insgn", "statssn"], "palcode": ["palcycle", "plpage", "palode", "Palmode", "palpage", "palCode", "palcod", " palcod", "rolcat", "rolCode", "pacmode", " palcat", "calcat", "plance", " palCode", "pacCode", "pacpage", "plancode", "plce", "paccycle", "calcode", "rolcod", "pacce", "palcat", "palmode", "Palode", "palce", "rolcode", "planpage", "Palcode", "pacode", "plcycle", "plcode", " palmode", " palode", "calcod", "PalCode", "calCode", "paccode", "plancycle"], "disp21": ["dispp21", "desjp20", "desjp203", "dispa21", "disp32", "disjp21", "disjp203", " disp11", "disjp11", " disjp21", "desp203", "dispa20", "desjp21", "dispa203", "disop21", " disjp11", " disjp32", "disjp31", " disp31", "disp20", "dispp11", "desp20", "disnp11", "disnp20", "desjp11", "disjp20", " disp32", "disop11", "disp31", "disp11", "disop31", "dispp32", "disnp203", "desp21", "disjp32", " disjp31", "desp11", "disp203", "dispp31", "disop32", "dispa11", "disnp21"], "disp16": ["disperm12", "dislp162", "disvp16", "discp16", "DisP12", "desp16", "DisP16", "dislp16", "disp156", "Disp12", "Disp20", "disjp22", "disp22", "disvp22", "disp15", "descp16", "disjp16", "DisP22", "dislp12", "discp12", "descp21", "disP20", "discp21", "disp20", "disP12", "disP156", "DisP20", "descp162", "disperm16", "disP16", "descp12", "disvp20", "disjp15", "DisP15", "disP15", "disP21", "desp162", "disvp12", "disvp15", "Disp22", "disperm20", "disvp156", "DisP156", "Disp15", "Disp156", "desp12", "disjp12", "desp21", "discp162", "disperm156", "Disp16", "dislp21", "disP162", "disp162", "disP22"], "disp12": ["discp16", "DisP12", "desP16", "desp16", "disrep12", "DisP16", "disp17", "dispat16", "Disp12", "disP22", "dispData", "desPData", "disPData", "disp22", "dispat12", "despData", "disp72", "disP17", "DisP22", "discp22", "discp12", "discp72", "dispat22", "disP12", "disP16", "DisP72", "disP72", "desP17", "desP12", "dispp16", "desp17", "Disp72", "Disp22", "dispat72", "dispp12", "disrep16", "dispp17", "desp12", "disppData", "Disp16", "disrep17", "disrepData"], "fn11": ["fn2011", "fc12", "fnair", "pnair", "fn12", "fc7", "pn7", "cn101", "dn11", "dn31", "cn11", "fl11", "cn31", "pn11", " fn12", "dn101", "cn2011", " fn31", "fc11", "fn31", "dn2011", "fl12", "fn101", "tnair", " fn2011", "tn7", " fnair", "fl7", " fn101", "tn11"], "opc": ["plf", " opf", "opC", "apci", "pc", "opct", "opcache", "opci", " optac", "plc", "iopC", "opch", "iopcs", "oppc", " opcache", " opch", "OPC", "apac", " optci", "oplc", "iopc", "iopci", " opcs", "optf", "pf", "optc", "operf", "opf", "ppf", "optch", "OPcs", "operc", "optcache", "OPci", "opercache", "OPc", " opac", "pllc", "ppc", "ppct", "operch", " optpc", "appc", "plct", "apc", " opci", "pct", "opac", " optc", " opC", "pplc", "opcs", " oppc"], "ra": ["RA", "la", "ran", "rs", "ring", "as", "ras", "area", "ri", "rf", "au", "ara", "ria", "rn", "ruby", "mr", "rr", "usr", "dra", "r", "ta", "rl", "ir", "rx", "reg", "rd", "rou", "rap", "rom", "pr", "eas", "ror", "ro", "rt", "aria", "sr", "re", "orig", "tar", "ur", "raf", "co", "ru", "rage", "cr", "loc", "rar", "ar", "gra"], "rb": ["src", "lb", "rs", "ring", "rab", "rf", "rib", "rob", "rw", "rub", "fb", "ruby", "cb", "ab", "rr", "usr", "r", "rl", "RB", "br", "pb", "rg", "rd", "erb", "sb", "b", "reb", "ro", "re", "bb", "ob", "rm", "nb", "gb", "ib", "raf", "db", "ru", "vr", "rage", "rid", "wb"], "rc": ["src", "lb", "arc", "ck", "pc", "rs", "ras", "rec", "ec", "rf", "ry", "RC", "bc", "cur", "cs", "tc", "rn", "cb", "rr", "r", "rl", "rx", "rg", "rd", "irc", "c", "uc", "ro", "rt", "re", "sr", "roc", "sc", "fc", "raf", "cv", "ru", "cr"], "fpfn": ["bpconn", "lpfc", "fpfc", "lpf", "bpfn", "fpjack", "vpf", "fpf", "vpfc", "ulpbn", "vpbn", "lpconn", "lpbn", "ulpfc", "lpfn", "vpconn", "bpbn", "ulpfn", "vpjack", "fpbn", "ulpf", "fpconn", "vpfn", "bpjack", "lpjack"], "fn7": [" fn5", "tn709", "pn7", "dn11", "nm7", "pn11", "dn5", "pn709", "fn709", " fn709", " fn6", "nm11", "dn7", "tn7", "dn6", "nm6", "nm5", "fn6", "tn11", "fn5"], "islit": ["illite", "ioliter", "inelim", "snite", "slit", "sslic", "isalitted", "selmit", "sslite", "islmit", "sliter", "sellit", "isalitter", "sslitt", "isllit", "illitted", "slmit", "inelic", "illitter", "inellit", "isalite", "snic", "iplitter", "snit", "iolit", "islitted", "iolitted", "ineliter", "iplitted", "islim", "inelit", "islitt", "sllit", "inelitted", "isliter", "selit", "selim", "iollit", "iplit", "slitted", "iplite", "islite", "inelitt", "slim", "inelite", "isalit", "inelmit", "islitter", "illit", "islic", "snitt", "sslit"], "real_islit": ["real_islip", "real_islite", "real_islist", "real_flit", "real_ilist", "real_ilic", "real_ilit", "real_slite", "real_slist", "real_solite", "real_solit", "real_solic", "real_flist", "real_islic", "real_ilite", "real_flip", "real_slic", "real_solist", "real_slip", "real_ilip", "real_slit", "real_flite"], "lit": ["col", "len", "lt", "la", "lib", "lim", "fi", "id", "at", "lang", "init", "lu", "slot", "iter", "fail", "abl", "limit", "l", "let", "late", "def", "ref", "hl", "cb", "sal", "lp", "alt", "eval", "sat", "tl", "rot", "gen", "nat", "sel", "tip", "eral", "sil", "opt", "it", "lif", "lite", "loc", "mit"], "ret": ["lt", "pas", " RET", "status", "flag", "uf", "err", "nz", "RET", "resp", "nt", "rev", "jp", "ref", " Ret", "fun", "def", "mt", "pret", "vt", "txt", "alt", "try", "test", "sat", "rets", "gc", "Ret", "rt", "re", "elt", "res", "opt", "it", "att", "gt", "bt", " fut", "out"]}}
{"project": "FFmpeg", "commit_id": "53e5462040f6f7273fb6b0d7592eea1f5d26829f", "target": 0, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, long dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, int flags, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   int srcFormat, uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n    int32_t av_unused *mmx2FilterPos = c->chrMmx2FilterPos;\n\n    int16_t av_unused *mmx2Filter    = c->chrMmx2Filter;\n\n    int     av_unused canMMX2BeUsed  = c->canMMX2BeUsed;\n\n    void    av_unused *mmx2FilterCode= c->chrMmx2FilterCode;\n\n\n\n    if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE)\n\n        return;\n\n\n\n    if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) {\n\n        src1 += ALT32_CORR;\n\n        src2 += ALT32_CORR;\n\n    }\n\n\n\n    if (srcFormat==PIX_FMT_RGB48LE) {\n\n        src1++;\n\n        src2++;\n\n    }\n\n\n\n    if (c->hcscale_internal) {\n\n        c->hcscale_internal(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n#if COMPILE_TEMPLATE_MMX\n\n    // Use the new MMX scaler if the MMX2 one can't be used (it is faster than the x86 ASM one).\n\n    if (!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed))\n\n#else\n\n    if (!(flags&SWS_FAST_BILINEAR))\n\n#endif\n\n    {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n#if ARCH_X86 && CONFIG_GPL\n\n#if COMPILE_TEMPLATE_MMX2\n\n        int i;\n\n#if defined(PIC)\n\n        DECLARE_ALIGNED(8, uint64_t, ebxsave);\n\n#endif\n\n        if (canMMX2BeUsed) {\n\n            __asm__ volatile(\n\n#if defined(PIC)\n\n                \"mov          %%\"REG_b\", %6         \\n\\t\"\n\n#endif\n\n                \"pxor             %%mm7, %%mm7      \\n\\t\"\n\n                \"mov                 %0, %%\"REG_c\"  \\n\\t\"\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\"\n\n                \"mov                 %2, %%\"REG_d\"  \\n\\t\"\n\n                \"mov                 %3, %%\"REG_b\"  \\n\\t\"\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                \"xor          %%\"REG_a\", %%\"REG_a\"  \\n\\t\" // i\n\n                \"mov                 %5, %%\"REG_c\"  \\n\\t\" // src\n\n                \"mov                 %1, %%\"REG_D\"  \\n\\t\" // buf1\n\n                \"add              $\"AV_STRINGIFY(VOF)\", %%\"REG_D\"  \\n\\t\"\n\n                PREFETCH\"   (%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 32(%%\"REG_c\")             \\n\\t\"\n\n                PREFETCH\" 64(%%\"REG_c\")             \\n\\t\"\n\n\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n                CALL_MMX2_FILTER_CODE\n\n\n\n#if defined(PIC)\n\n                \"mov %6, %%\"REG_b\"    \\n\\t\"\n\n#endif\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (mmx2Filter), \"m\" (mmx2FilterPos),\n\n                \"m\" (mmx2FilterCode), \"m\" (src2)\n\n#if defined(PIC)\n\n                ,\"m\" (ebxsave)\n\n#endif\n\n                : \"%\"REG_a, \"%\"REG_c, \"%\"REG_d, \"%\"REG_S, \"%\"REG_D\n\n#if !defined(PIC)\n\n                ,\"%\"REG_b\n\n#endif\n\n            );\n\n            for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) {\n\n                //printf(\"%d %d %d\\n\", dstWidth, i, srcW);\n\n                dst[i] = src1[srcW-1]*128;\n\n                dst[i+VOFW] = src2[srcW-1]*128;\n\n            }\n\n        } else {\n\n#endif /* COMPILE_TEMPLATE_MMX2 */\n\n            x86_reg xInc_shr16 = (x86_reg) (xInc >> 16);\n\n            uint16_t xInc_mask = xInc & 0xffff;\n\n            __asm__ volatile(\n\n                \"xor %%\"REG_a\", %%\"REG_a\"               \\n\\t\" // i\n\n                \"xor %%\"REG_d\", %%\"REG_d\"               \\n\\t\" // xx\n\n                \"xorl    %%ecx, %%ecx                   \\n\\t\" // xalpha\n\n                ASMALIGN(4)\n\n                \"1:                                     \\n\\t\"\n\n                \"mov        %0, %%\"REG_S\"               \\n\\t\"\n\n                \"movzbl  (%%\"REG_S\", %%\"REG_d\"), %%edi  \\n\\t\" //src[xx]\n\n                \"movzbl 1(%%\"REG_S\", %%\"REG_d\"), %%esi  \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, (%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"movzbl    (%5, %%\"REG_d\"), %%edi       \\n\\t\" //src[xx]\n\n                \"movzbl   1(%5, %%\"REG_d\"), %%esi       \\n\\t\" //src[xx+1]\n\n                FAST_BILINEAR_X86\n\n                \"movw     %%si, \"AV_STRINGIFY(VOF)\"(%%\"REG_D\", %%\"REG_a\", 2)   \\n\\t\"\n\n\n\n                \"addw       %4, %%cx                    \\n\\t\" //xalpha += xInc&0xFFFF\n\n                \"adc        %3, %%\"REG_d\"               \\n\\t\" //xx+= xInc>>16 + carry\n\n                \"add        $1, %%\"REG_a\"               \\n\\t\"\n\n                \"cmp        %2, %%\"REG_a\"               \\n\\t\"\n\n                \" jb        1b                          \\n\\t\"\n\n\n\n/* GCC 3.3 makes MPlayer crash on IA-32 machines when using \"g\" operand here,\n\n   which is needed to support GCC 4.0. */\n\n#if ARCH_X86_64 && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n\n                :: \"m\" (src1), \"m\" (dst), \"g\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#else\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#endif\n\n                \"r\" (src2)\n\n                : \"%\"REG_a, \"%\"REG_d, \"%ecx\", \"%\"REG_D, \"%esi\"\n\n            );\n\n#if COMPILE_TEMPLATE_MMX2\n\n        } //if MMX2 can't be used\n\n#endif\n\n#else\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n#endif /* ARCH_X86 */\n\n    }\n\n    if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) {\n\n        int i;\n\n        //FIXME all pal and rgb srcFormats could do this convertion as well\n\n        //FIXME all scalers more complex than bilinear could do half of this transform\n\n        if(c->srcRange) {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (dst[i     ]*1799 + 4081085)>>11; //1469\n\n                dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; //1469\n\n            }\n\n        } else {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n                dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10308, "substitutes": {"c": ["con", "cmp", "abc", "pc", "config", "ch", "call", "cam", "ct", "enc", "p", "ec", "f", "cp", "cf", "d", "bc", "dc", "cs", "tc", "m", "cd", "cb", "unc", "cc", "ce", "cal", "cont", "mc", "t", "ci", "ctx", "ac", "rc", "lc", "v", "conf", "gc", "cache", "b", "cn", "com", "h", "anc", "cm", "w", "nc", "etc", "cu", "fc", "sc", "comm", "C", "co", "cv", "cr", "vc", "conv", "ca"], "dst": ["dsc", " dest", "brc", "dnt", "drest", "bst", "delt", " dnt", "Dst", "drc", "derc", "ddest", "adnt", "adST", " dST", "desc", "dlt", "blt", "dST", "adst", "dest", "grc", "gsc", "adest", "gst", "Ddest", " ddest", "DST", "drdest", "drST", "Dest", "glt", "bsc", "Dnt", "drst"], "dstWidth": ["dvW", "dndSize", "dStH", "dSTWidth", " dSTSize", "destW", "dvHeight", " destW", " destHeight", " dstH", "dndHeight", "destWidth", " dstHeight", " dstwidth", "destH", " dSTH", " destwidth", "dstW", "dndW", "destSize", "destHeight", "dSTwidth", "dndWidth", "dstH", " destWidth", " dSTWidth", " dstW", "dvWidth", "dSTH", "dmtwidth", "dmtHeight", " dstSize", "dStSize", "dSTSize", "dvSize", "dstHeight", "dstwidth", "dStHeight", "dStWidth", " dSTHeight", "dSTHeight", "destwidth", "dstSize", " destSize", "dmtWidth"], "src1": ["servOne", " src001", "rc001", "rcOne", "source2", " src3", "src3", "loc2", "rc1", "sourceOne", "locOne", " srcOne", "src01", " src0", "serv2", "sysOne", "sys2", "src0", " src01", "sys1", "source1", "rc0", "rc3", "rc2", "source01", "srcOne", "source0", "rc01", "serv1", "sys01", "source3", "source001", "loc1", "src001", "loc3"], "src2": ["srcTwo", "ser02", "sc1", "sr2", " srcTwo", "source2", " src3", "src3", "rc1", "sr02", "srctwo", "usrtwo", "source1", "sourceTwo", "rc3", "usr1", "usr256", "rc2", "ser2", "source02", "rcTwo", " src02", "src02", "rctwo", "rc02", "rc256", "ser1", " src256", "sr3", "scTwo", "sc2", "src256", "usr2", "source3", "sc02", " srctwo", "srTwo"], "srcW": ["rcN", "srcSize", "srcN", "locW", "sr2", "source2", " src3", "src3", " srcSize", "sourceSize", "rc1", "sourceN", "rcSize", "sr1", "rcW", "source1", " srcN", "rc3", "locN", " srcH", "srcH", " srcw", "rc2", "rcH", "sourcew", "srcw", "rcw", "sr3", "locH", "sourceW", "srW", "loc1"], "xInc": ["xtInc", "xtINC", " xExc", "dxINC", "XIncre", "wxINC", " xIncre", "XINC", "xINC", "yxInc", "dxInc", "xtExc", "XInc", "wxIns", "wxExc", "xIncre", "dxExc", "yxIncre", " xIns", "exInc", " xINC", "exINC", "xtIncre", "wxInc", "yxExc", "xExc", "exExc", "yxINC", "wxIncre", "xIns", "exIncre", "XIns", "dxIncre"], "flags": ["cons", "ports", "aps", "Flags", "comments", "acts", "locks", "frames", "ats", "flag", "bugs", "weights", "types", "goal", "ants", "ints", "pages", "cf", "FLAG", "points", "bits", "pins", "args", "heads", "members", "fps", "kind", "terms", "mask", "posts", "cond", "ts", "lag", "packages", "ags", "fields", "wcs", "limits", "tags", "products", "reports", "fs", "options", "vals", "faces", "actions", "features", "params", "parts"], "hChrFilter": ["hChlCode", "hChrFrame", "hCoroFrame", "hCoroFilter", "hCorrSearch", "hChrSearch", "hChoQuery", "hChrcFilter", "hChrcCode", "hChrQuery", "hCHrcFilter", "hCHrFrame", "hChoFilter", "func", "hCHrImage", "hChrImage", "hChoFrame", "hChrtSearch", "hCorrQuery", "hChlImage", "hChlFilter", "hCHrCode", "hChrtQuery", "hChdrFrame", "hChrbFilter", "hChrtFrame", "hCoroQuery", "_", "hCorrFrame", "hChlFrame", "hChoSearch", "hChrCode", "hChdrFilter", "hCoroSearch", "hCHrcFrame", "hChdrImage", "hCHrcCode", "hCHrcImage", "hChrbQuery", "WC", "hChrcFrame", "hChdrCode", "hChrtFilter", "hChrcImage", "hCHrFilter", "hCorrFilter", "conv", "hChrbFrame", "hChrbSearch"], "hChrFilterPos": ["hCharFilterSize", "hChrHeaderSize", "hChrHeaderCode", "hChlfilterSize", "hChrHandlerUser", "hChlFilterPos", "hChrHandlerPos", "hChrFilterUser", "hCharFilterCode", "hChrHandlerPosition", "hChrSortCode", "hChrfilterUser", "hChrSortSize", "hChrSortPos", "hChrfilterSize", "hCharHandlerSize", "hCharHandlerPos", "hChrfilterPos", "hChrHandlerCode", "hChrFormatPos", "hChrFilterCode", "hChlfilterUser", "hChrfilterPosition", "hChrFormatSize", "hChrFilterPosition", "hChrHeaderPos", "hChlfilterPos", "hChlFilterPosition", "hChlFilterSize", "hChlFilterUser", "hCharHandlerCode", "hChrFormatPosition", "hChrFormatUser", "hChlfilterPosition", "hChrHandlerSize", "hCharFilterPos"], "hChrFilterSize": ["hChrtFilterType", "hChrtFilterCode", "hChrBufferType", "hChrTransformData", "hChcBufferData", "hChrBlockCount", "hChrFilterType", "hChrtFilStyle", "hChcFilterCode", "hChrtFilType", "hChrFilCode", "hChrBufferStyle", "hChrtFilterStyle", "hChrBlockType", "hChrtFilSize", "hChcBufferSize", "hChrBufferCount", "hChrBlockSize", "hChrBlockData", "hChrFilterData", "hChrFilStyle", "hChcFilterSize", "hChrTransformSize", "hChrFilSize", "hChrTransformCount", "hChrFilterCode", "hChcBufferCount", "hChrFilType", "hChcFilterCount", "hChrBufferCode", "hChrBlockCode", "hChrtFilterSize", "hChcFilterData", "hChrBufferData", "hChrTransformCode", "hChrFilterStyle", "hChrBufferSize", "hChcBufferCode", "hChrtFilCode", "hChrFilterCount", "hChrBlockStyle"], "srcFormat": [" srcName", "srcWidth", "sourceformat", "srcType", "rcStyle", "sqFormat", "srForm", "rcVersion", " srcForm", " srcWidth", "sourceName", "srcVersion", "srStyle", "rcformat", "sourceVersion", "funcVersion", "stockType", "srName", "syncPath", " srcVersion", "sourceFormat", "rcCard", "srcForm", " srcPattern", "stockFormat", "stockPlan", "syncName", "srFormat", " srcPath", "scFormat", "sourcePlan", "funcFormat", "srcformat", "sqFilter", "sourceType", "funcFilter", "rcForm", "rcName", "rcType", "srcPattern", "rcFilter", "scWidth", "sqName", "rcWidth", "rcPath", "scType", "scName", " srcType", "stockformat", "rcPattern", "funcForm", "srcName", "rcFormat", "syncFormat", "srcPath", "rcPlan", "syncCard", "srcStyle", " srcFilter", "srcFilter", " srcCard", "sqPattern", "srcCard", "srcPlan", " srcStyle"], "formatConvBuffer": ["formatConvFilter", "formatconvtBuffer", "formatConjBuffer", "formatConuvAttribute", "formatConnvBuff", "formatRenvBuff", "formatEnvBytes", "formatConvtBytes", "formatConvertFlow", "formatConuvBuff", "formatRevBuff", "formatconvtPort", "formatConvBytes", "formatConuvBuffer", "formatConvtPort", "formatEnvFilter", "formatEnnvBuff", "formatConjAttribute", "formatConVBuffer", "formatConVBuff", "formatConvtAttribute", "formatEnvBuff", "formatEnjAttribute", "formatEnVBuff", "formatEnnvBuffer", "formatConjPort", "formatconvBuff", "formatConvertFilter", "formatEnVBuffer", "formatConVFilter", "formatEnnvFlow", "formatconvPort", "formatEnvAttribute", "formatConnvBuffer", "formatConvArray", "formatConvtFilter", "formatConnvFlow", "formatConuvFlow", "formatConvFlow", "formatConvAttribute", "formatConvertBuff", "formatEnVBytes", "formatRevBuffer", "formatRevArray", "formatconvBuffer", "formatEnvFlow", "formatRenvBuffer", "formatRenvArray", "formatconvtBuff", "formatConvertBytes", "formatConnvArray", "formatConvertArray", "formatConVArray", "formatConvBuff", "formatEnjBuffer", "formatConvtBuffer", "formatEnvBuffer", "formatConvtBuff", "formatConvPort", "formatConjBuff", "formatEnVFilter", "formatConVBytes", "formatEnjBuff", "formatConvertBuffer"], "pal": ["Pal", "png", "ph", "pas", "what", "al", "qq", "mat", "pp", "padding", "bat", "theme", "flat", "ass", "white", "isal", "ps", "pos", "quant", "local", "qual", "wh", "sal", "mask", "pill", "cal", "qt", "als", "alpha", "sav", " PAL", "conf", "pl", "val", "pol", "scale", "font", "color", "skin", "vals", "buff", "pack", "pid"], "mmx2FilterPos": ["mmx2FilterSize", "mmx2ChannelPos", "mmx2ChannelPosition", "mmx2HandlerPosition", "mmx2ChannelInfo", "mmx2HandlerPos", "mmx4BufferPos", "mmx4BufferPosition", "mmx2HandlerSize", "mmx2BufferInfo", "mmx2BufferPos", "mmx4FilterPosition", "mmx2HandlerInfo", "mmx4FilterSize", "mmx2ChannelSize", "mmx4FilterInfo", "mmx2BufferPosition", "mmx2FilterPosition", "mmx4BufferInfo", "mmx2BufferSize", "mmx2FilterInfo", "mmx4FilterPos", "mmx4BufferSize"], "mmx2Filter": ["mmX2Rule", "mmx022Block", "mmx4Filter", "mmx42Rule", "mmx022Rule", "mmX2Block", "mmX2Filter", "mmx2Block", "mmX4Filter", "mmX2filter", "mmx4filter", "mmx42Filter", "mmx42filter", "mmx4Block", "mmx2Rule", "mmx022Filter", "mmx42Block", "mmX4Block", "mmx2filter", "mmx022filter", "mmX4filter", "mmX4Rule", "mmx4Rule"], "mmx2FilterCode": ["mmx2FilterSize", "mmx02FilterStyle", "mmx2TestCode", "mmx02FilterMode", "mmx2BufferStyle", "mmx2ChannelStyle", "mmx02FilterCode", "mmx2TestMode", "mmx02FilterSize", "mmx2ChannelMode", "mmx2FilterStyle", "mmx2ChannelCode", "mmx2TestSize", "mmx2ChannelSize", "mmx02BufferSize", "mmx2BufferMode", "mmx2FilterMode", "mmx02BufferCode", "mmx2TestStyle", "mmx2BufferCode", "mmx2BufferSize", "mmx02BufferMode", "mmx02BufferStyle"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n", "idx": 10316, "substitutes": {"a": ["ba", "na", "la", "va", "at", "or", "as", "area", "p", "o", "an", "au", "da", "d", "aaa", "l", "m", "ata", "ae", "ea", "ia", "r", "ta", "alpha", "data", "ma", "n", "isa", "t", "ac", "v", "b", "c", "A", "sa", "w", "sta", "z", "aa", "oa", "ana", "ca"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)\n\n{\n\n   return pthread_equal(thread1->thread, thread2->thread);\n\n}\n", "idx": 10322, "substitutes": {"thread1": ["taskone", "comment1", "thread001", "commentOne", "Thread001", "Thread2", "comment2", " threadone", "task1", "ThreadOne", " thread001", "threadOne", "thread10", "record1", "task10", "record10", "Thread1", "record2", "comment001", "threadone", " threadOne", " thread10", "recordone", "task2"], "thread2": ["threadTwo", "system02", "process02", "thread02", "THTwo", " thread4", "system4", "TH1", " thread02", "process4", "TH2", "system1", " threadTwo", "TH02", "condition02", "condition2", "condition1", "process2", "conditionTwo", "process1", "thread4", "system2"]}}
{"project": "qemu", "commit_id": "1b27d7a1e8609b2eeb6238f2c629eb82217523f6", "target": 0, "func": "static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,\n\n                                                            uint32_t val)\n\n{\n\n    IVShmemState *s = opaque;\n\n\n\n    uint64_t write_one = 1;\n\n    uint16_t dest = val >> 16;\n\n    uint16_t vector = val & 0xff;\n\n\n\n    addr &= 0xfc;\n\n\n\n    IVSHMEM_DPRINTF(\"writing to addr \" TARGET_FMT_plx \"\\n\", addr);\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ivshmem_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ivshmem_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case DOORBELL:\n\n            /* check that dest VM ID is reasonable */\n\n            if ((dest < 0) || (dest > s->max_peer)) {\n\n                IVSHMEM_DPRINTF(\"Invalid destination VM ID (%d)\\n\", dest);\n\n                break;\n\n            }\n\n\n\n            /* check doorbell range */\n\n            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {\n\n                IVSHMEM_DPRINTF(\"Writing %\" PRId64 \" to VM %d on vector %d\\n\",\n\n                                                    write_one, dest, vector);\n\n                if (write(s->peers[dest].eventfds[vector],\n\n                                                    &(write_one), 8) != 8) {\n\n                    IVSHMEM_DPRINTF(\"error writing to eventfd\\n\");\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            IVSHMEM_DPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest);\n\n    }\n\n}\n", "idx": 10327, "substitutes": {"opaque": ["Opaque", "opc", "opaques", "opoid", " opatile", "Opatile", "obca", " opaques", " opoid", "OPaque", "Opaques", "iopacity", "Opc", " opc", "oboid", "obaque", " opacity", "OPc", " opca", "OPaques", "iopoid", "iopca", "opca", "obacity", "OPatile", "iopaque", "opatile", "opacity"], "addr": ["src", "arr", "align", "len", "obj", "tr", "tx", "id", "address", "map", "url", "arp", "cmp", "add", "Address", "code", "flag", "prefix", "rs", "err", "ar", "alloc", "var", "hash", "pad", "trans", "act", "rev", "pos", "gate", "inter", "attr", "mt", "hl", "ptr", "adr", "ord", "mem", "alt", "r", "data", "dest", "ad", "ctx", "ac", "rc", "v", "host", "cmd", "rt", "res", "tag", "x", "coord", "att", "dh", "loc", "offset", "state", "dr", "ret"], "val": ["vector", "lit", "xy", "tx", "num", "al", "address", "sol", "pt", "VAL", "valid", "range", "value", "p", "buf", "var", "dev", "resp", "slot", "ival", "vec", "grad", "Val", "def", "values", "vt", "alt", "mem", "bit", "eval", "index", "cal", "data", "ctx", "v", "conf", "pol", "bal", "elt", "sel", "stat", "serv", "vals", "it", "x", "item", "aval", "state", "vol", "arg", "ret"], "s": ["sq", "vs", "sl", "aunts", "qs", "ats", "q", "rs", "als", "hs", "p", "gs", "sts", "sp", "sm", "an", "ps", "ess", "changes", "m", "bits", "ies", "sv", "i", "ses", "sam", "ins", "bs", "aws", "r", "is", "js", "j", "S", "ss", "ts", "n", "se", "its", "y", "t", "ssl", "conf", "ties", "os", "sb", "c", "bis", "sw", "h", "sn", "ns", "stats", "fs", "serv", "comm", "sis", "ls", "ims", "ds", "sys", "store"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static inline void gen_outs(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (use_icount)\n\n        gen_io_start();\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_ESI);\n\n    if (use_icount)\n\n        gen_io_end();\n\n}\n", "idx": 10333, "substitutes": {"s": ["ms", "sq", "a", "rs", "as", "p", "gs", "sts", "o", "ps", "g", "cs", "m", "es", "i", "bs", "so", "r", "is", "js", "S", "ss", "ts", "n", "its", "t", "v", "os", "b", "c", "h", "sa", "ns", "stats", "w", "sc", "ls", "ds", "sys"], "ot": ["oc", " ol", "tt", "ota", "op", "mot", "net", "ott", "et", "at", "pt", "oot", "or", "iet", " dot", "p", "o", "ut", "nt", "iat", "ox", " net", "oid", "ots", "mt", "ote", "ic", "ou", "r", " os", "y", "t", "rot", "hot", "pot", "os", "og", "rt", "cot", "onet", "opt", "it", "dot", "gt", "OT", "iot", "oss", "ant", "out", "sys"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "void test_fcmp(double a, double b)\n\n{\n\n    long eflags, fpus;\n\n\n\n    fpu_clear_exceptions();\n\n    asm(\"fcom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fcom(%f %f)=%04lx \\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    fpu_clear_exceptions();\n\n    asm(\"fucom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fucom(%f %f)=%04lx\\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    if (TEST_FCOMI) {\n\n        /* test f(u)comi instruction */\n\n        fpu_clear_exceptions();\n\n        asm(\"fcomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fcomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n        fpu_clear_exceptions();\n\n        asm(\"fucomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fucomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n    }\n\n    fpu_clear_exceptions();\n\n    asm volatile(\"fxam\\n\"\n\n                 \"fstsw %%ax\\n\"\n\n                 : \"=a\" (fpus)\n\n                 : \"t\" (a));\n\n    printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700);\n\n    fpu_clear_exceptions();\n\n}\n", "idx": 10338, "substitutes": {"a": ["ow", "ah", "la", "ao", "o", "d", "m", "r", "y", "t", "ace", "sa", "w", "aa", "el", "ar", "era", "ami", "al", "at", "au", "aaa", "g", "ia", "ea", "en", "ga", "ma", "aux", "ac", "new", "e", "eas", "A", "sta", "att", "app", "am", "obj", "ai", "abc", "as", "area", "ach", "f", "ae", "admin", "ap", "i", "index", "apt", "n", "er", "oa", "ann", "out", "ca", "ba", "aj", "aka", "p", "an", "da", "active", "ab", "aff", "v", "aw", "c", "ed", "ing", "apa", "x", "name", "af"], "b": ["ba", "amb", "be", "u", "back", "base", "rb", "to", "p", "o", "f", "bin", "abb", "B", "d", "bc", "g", "m", "l", "other", "fb", "i", "ab", "bs", "r", "j", "br", "n", "y", "pb", "t", "eb", "new", "body", "v", "erb", "e", "sb", "c", "bis", "h", "reb", "bi", "w", "bb", "ob", "it", "x", "z", "nb", "ib", "db", "bar", "out", "wb"], "eflags": ["efliagn", "elflags", "eflagn", "efklags", "efflacks", "eflcamps", "eblagged", "explaps", "elflales", "eflcacks", "efinedlenates", "efnlags", "efdlaps", "eflsagged", "eflsates", "efdlagged", "explags", "efliags", "efdlamps", "efdlag", "eflsagn", "efdlinks", "eblcagged", "efliates", "efflamps", "efklugs", "eblags", "eflcags", "eflenugs", "efklamps", "eflsugs", "efliugs", "elfnlogs", "eblinks", "eflpinks", "efflags", "eflales", "elflpales", "efnlogs", "explcags", "explamps", "elflinks", "eflats", "eflsags", "efdlags", "eflenagn", "eblcinks", "elflamps", "eflacks", "efinedlagn", "efinedlenagn", "eflsinks", "eflag", "eblcag", "efinedlates", "eflenags", "efinedlags", "eflcinks", "elflugs", "explcaps", "eflpags", "eflpales", "elflpags", "eflinks", "eflcugs", "efhlags", "eflcats", "elfnlugs", "elfnlags", "efnlamps", "efdlacks", "eflsag", "eflcaps", "efhlinks", "explcacks", "eflcogs", "efinedlenags", "eflcag", "eflagged", "eflpats", "eflates", "eblag", "eblcags", "efinedlugs", "efhlales", "eflcales", "eflenates", "eflugs", "efinedlenugs", "explcamps", "eflcagged", "elflogs", "elfnlamps", "elflpats", "efhlats", "efklogs", "eflaps", "elflats", "eflamps", "efflaps", "eflogs", "efnlugs", "elflpinks", "explacks"], "fpus": ["FPus", "ppocus", "fpaus", "FPuses", "gpu", "gpus", "xpuses", "tpaus", "piros", "pircus", "fpsUS", "cpUS", "vpaus", "bpUS", "vpis", "fnus", "cpuses", "piris", "gpcus", "vpcus", "gpuses", "npcus", "bpu", "tpu", "npus", "gpos", "vpos", "FPcus", "bpus", "npuses", "fnaus", "piruses", "fpUS", "tpcus", "ppouses", "cpos", "FPu", "FPUS", "cpu", "piru", "tpos", "hluses", "fpsus", "npu", "fpis", "hlus", "ppoUS", "vpUS", "npUS", "cpis", "pirus", "vpus", "piraus", "fnu", "fncus", "pirUS", "fpsaus", "tpUS", "jpuses", "tpus", "vpu", "iopu", "fpos", "hlcus", "iopaus", "fpu", "fpcus", "tpis", "gpis", "gpUS", "jpcus", "cpcus", "jpu", "ppous", "iopcus", "xpUS", "bpcus", "fpuses", "fpscus", "vpuses", "jpus", "iopus", "hlu", "cpus", "xpcus", "xpus"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,\n\n                             hwaddr paddr, MemTxAttrs attrs, int prot,\n\n                             int mmu_idx, target_ulong size)\n\n{\n\n    CPUArchState *env = cpu->env_ptr;\n\n    MemoryRegionSection *section;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    uintptr_t addend;\n\n    CPUTLBEntry *te;\n\n    hwaddr iotlb, xlat, sz;\n\n    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;\n\n    int asidx = cpu_asidx_from_attrs(cpu, attrs);\n\n\n\n    assert_cpu_is_self(cpu);\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n\n\n    sz = size;\n\n    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);\n\n    assert(sz >= TARGET_PAGE_SIZE);\n\n\n\n    tlb_debug(\"vaddr=\" TARGET_FMT_lx \" paddr=0x\" TARGET_FMT_plx\n\n              \" prot=%x idx=%d\\n\",\n\n              vaddr, paddr, prot, mmu_idx);\n\n\n\n    address = vaddr;\n\n    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {\n\n        /* IO memory case */\n\n        address |= TLB_MMIO;\n\n        addend = 0;\n\n    } else {\n\n        /* TLB_MMIO for rom/romd handled below */\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n\n                                            prot, &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    te = &env->tlb_table[mmu_idx][index];\n\n\n\n    /* do not discard the translation in te, evict it into a victim tlb */\n\n    env->tlb_v_table[mmu_idx][vidx] = *te;\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n\n\n    /* refill the tlb */\n\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && cpu_physical_memory_is_clean(\n\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 10351, "substitutes": {"cpu": ["bench", "nic", "ck", "aco", "rpm", "pc", "tp", "gpu", "mx", "ilo", "socket", "upt", "processor", "gnu", "alloc", "nu", "proc", "java", "p", "cp", "pu", "linux", "cow", "instance", "jp", "process", "arch", "ka", "util", "mu", "core", "CPU", "clock", "mem", "cli", "server", "uda", "ctx", "uart", "conn", "ork", "gc", "apache", "cmd", "hw", "cu", "stat", "mac", "phys", "context", "memory", "vm", "pty", "sys"], "vaddr": ["vAddress", "varr", "vadded", "vcarr", " vrun", "vppad", "fadd", " vaddress", " vadded", " vadr", "vraddr", "pip", "vmaddr", "vcstore", "jaddr", "jhost", " vadd", "vphost", "vradr", "paddress", "vchost", "evaddr", "pAddress", "vcrun", "vadd", "uvip", "faddress", "vrun", "faddr", "vmAddress", "vcpad", "pstore", "vrptr", "prun", "vcaddr", "uvAddress", "vhost", "vref", "padd", "madd", "vpad", "vaddress", "evadded", "maddr", "vmadd", "vip", "jarr", "jpad", "vcadd", "vparr", "vmip", " vstore", "uvadd", "maddress", "vadr", "vptr", " vref", "vpaddr", " vptr", "pref", "vstore", "evadr", "evptr", "uvaddr", "fref", "vradded"], "paddr": ["pptr", "ipadd", "ppconn", "ipref", "ppadd", " pptr", "paddress", "vconn", "vadd", " pref", "haddress", "pconn", " paddress", " pconn", "ipaddr", "vref", "padd", "madd", "gptr", "vaddress", "maddr", "gadd", "haddr", "gconn", "mconn", "vptr", " padd", "mptr", "gaddr", "ipptr", "pref", "hptr", "ppaddr", "hadd"], "attrs": ["addrs", "attributes", "Attr", "attrd", " attps", "attachributes", "attachrs", " attributes", "attachres", "addrd", "addributes", "attr", " attr", "Attributes", " attres", "Attrs", "addr", "addres", "addps", " attrd", "Attps", "attres", "attachrd", "attps"], "prot": ["col", "platform", "tf", "vector", "chron", "password", "method", "typ", "status", "pat", "priority", "protection", "flag", "policy", "format", "ping", "height", "prop", "prototype", "Prot", "push", "pos", "type", "port", "tif", "inet", "crypt", "ext", "top", "ocol", "version", "header", "phy", "mode", "ssl", "rot", "period", "offset", "tag", "stat", " proto", " PROT", " protocol", "pro", "tz", "style"], "mmu_idx": ["mmu_idey", "mmu_pidb", "into", "mmu2Idv", "mmu2idb", "mmu2Idb", "ctl", "mmu_Idz", "mmu_tryy", "mmu_tryx", "mmu_inv", "mmu_ideb", "mmu_Idb", "mmu_idez", "mmu_idz", "mmu_tryxs", "ptr", "mmu_idxs", "mmu_inx", "mmu_idef", "mmu_idf", "mmu_Idxs", "mmu_Idf", "mmu_idv", "mmu_idb", "mmu_pidy", "mmu2idy", "mmu2Idx", "mmu2idv", "mmu2Idy", "_", "mmu_Idy", "mmu_idex", "exec", "mmu_iny", "mmu_Idv", "mmu_idev", "mmu_pidx", "mmu_tryz", "cont", "mmu_Idx", "mmu_pidv", "mmu2idx", "mmu_idy"], "size": ["page", "len", "empty", "small", "num", "send", "sum", "buffer", "network", "message", "too", "padding", "news", "city", "range", "area", "sp", "height", "south", "Size", "SIZE", "capacity", "pos", "type", "timeout", "gz", "bytes", "ize", "mem", "storage", "large", "share", "data", "total", "loss", "count", "zone", "cache", "shape", "sw", "scale", "sn", "fee", "pi", "si", "z", "space", "set", "time", "s", "max", "name", "esi", "offset", "length", "style", "number"], "env": ["era", "ef", "vs", "next", "ah", "obj", "net", "pe", "menu", "et", "buffer", "network", "policy", "ei", "eh", "end", "here", "manager", "web", "ev", "den", "export", "proc", "ec", "ve", "buf", "dev", "engine", "enter", "eur", "eni", "worker", "eng", "Environment", "ptr", "vt", "window", "ote", "en", " environment", "server", "core", "ew", "eg", "equ", "stage", "global", "esc", "ctx", "conn", "v", "esp", "environment", "ten", "e", "eu", "po", "oe", "er", "ent", "pee", "org", "context", "see", "db", "cv", "ner", "console", "esi", "viron"], "section": ["page", "key", "array", "entry", "part", "side", "network", "prefix", "channel", "feature", "settings", "course", "region", "portion", "setting", "range", "area", "module", "profile", "ment", "sub", "job", "pair", "sector", "sec", "instance", "second", "block", "tab", "container", "port", "element", "session", "mod", "establishment", "server", "Section", "sect", "row", "version", "ss", "header", "se", "connection", "test", "aux", "selection", "state", "ctx", "mode", "zone", "man", "site", "journal", "environment", "comment", "division", "option", "member", "sections", "definition", "tag", "table", "context", "set", "group", "ner", "description"], "index": ["page", "key", "ity", "success", "id", "num", "ice", "code", "order", "route", "axis", "IND", "value", "hash", "point", "error", "ind", "iter", "open", "instance", "location", "capacity", "pos", "zero", "position", "i", "ize", "connect", "row", "ix", "Index", "version", "level", "interface", "connection", "test", "count", "info", "date", "ion", "lock", "si", "x", "link", "context", "time", "initial", "loc", "offset", "length", "find", "number"], "address": ["command", "page", "password", "array", "ice", "map", "buffer", "a", "Address", "pointer", "message", "device", "path", "resource", "network", "code", "region", "route", "image", "order", "end", "area", "value", "p", "point", "hash", "ase", "location", "operation", "ip", "service", "position", "ptr", "port", "length", "adr", "addr", "reference", "attribute", "alpha", "interface", "action", "add", "ace", "ress", "shape", "prefix", "comment", "alias", "table", "context", "memory", "angle", "description", "offset", "distance"], "code_address": ["ode_address", "code_point", "create_address", "code_addr", "ode_addr", "code_index", "ode_location", "codelistaddress", "create_location", "create_point", "ode_index", "code_location", "codelistpoint", "code_memory", "codelistmemory", "codelistlocation", "create_memory"], "addend": ["addEnd", "Addstart", "adended", "attachender", "attachEND", "ADDEND", "adstart", "ADDend", " addr", "appending", " addstart", "appEND", "ADDender", "Addended", "AddEnd", "adr", "addr", "adend", "Addend", "attachend", "Addr", "appender", "addender", "addending", " addended", " addEnd", "addended", "adEnd", "attachending", "ADDending", "append", "addEND", "addstart"], "te": ["td", "ette", "je", "lete", "tr", "be", "ge", "tp", "pe", "ie", "me", "tre", "fo", "aste", "ve", "ne", "tle", "team", "ye", "ptr", "ite", "ti", "ste", "ce", "ter", "ta", "de", "ts", "se", "t", "ele", "ete", "TE", "e", "tone", "ke", "Te", "oe", "pee", "lex", "le", "ue"], "iotlb": ["hotlbs", "hotlb", "otlab", "ytlb", "iotl", "hotl", "otlb", "ytb", "motlab", "motlb", "otl", "iotb", "potb", "otlbs", "iotlbs", "motlbs", "hotlab", "ytlab", "otb", "potlbs", "motl", "ytlbs", "iotlab", "potlb", "potlab"], "xlat": ["xrat", "xformat", "ixptr", "txlat", "uxlat", "xxsat", "ylat", "ypat", "ixlat", "xptr", " xdat", "Xlat", "ixformat", "xsat", " xpat", "yLat", " xformat", "txLat", " xLat", "ixrat", "xxlat", "xpat", "XLat", "xdat", "txaddr", "xxrat", "uxrat", "xLat", "uxformat", "ixpat", "ydat", " xrat", "uxpat", " xsat", "xaddr", "Xaddr", "ixLat", " xaddr", " xptr", "ixdat", "ixsat", "xxptr"], "sz": [" sze", " sZ", "lsz", " siz", "lsze", "svgz", "SZ", "szi", "sviz", "psiz", "svze", "Sze", "psze", "sszi", "psz", "ssgz", "ssiz", "svz", " szi", "lsgz", "lsiz", "Szi", "getsiz", "getsZ", "Sz", "getsze", "sze", "psZ", "sgz", "siz", "getszi", "getsz", "ssz", "Siz", "ssze", "sZ", "ssZ"], "vtlb_index": ["vtlb_id", "vtlb__id", "vtlb_count", "vtld_size", "vtlb2index", "vtld__index", "vtld__size", "vtlb2size", "vtlb__count", "vtlb_size", "vtld__count", "vtlb__index", "vtld_id", "vtld__id", "vtlb__size", "vtld_count", "vtlb2count", "vtld_index", "vtlb2id"]}}
{"project": "qemu", "commit_id": "3a661f1eabf7e8db66e28489884d9b54aacb94ea", "target": 1, "func": "static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}", "idx": 10355, "substitutes": {"cipher": ["ctrypt", "cron", "Crypt", "Cipher", "cciph", "nciph", "Cain", "ccipher", " crypt", "Cron", "ccain", "unciper", "ncain", "ccpher", "ctain", "ncipher", "ncpher", "Ciper", "uncipher", "cain", "conoder", " coder", "crypt", " corp", "cpher", "curpher", "ciph", "corp", " ciph", "ctron", "uncrypt", "chiph", "curipher", "coniph", "ctipher", " cron", "uncoder", "conipher", "curiph", "ciper", "Coder", " ciper", " cain", "curain", "choder", "chipher", "chorp", "coder", "conorp"], "key": ["power", "xy", "id", "ice", "sky", " KEY", "air", "prefix", "code", "sign", "ch", "sum", "init", "Key", "ak", "keys", "or", "k", "p", "hash", "value", "ay", "pair", "ex", "ip", "KEY", "te", "type", "length", "ver", "token", "mask", "ce", "index", "chain", " Key", "data", "version", "n", "y", "node", "box", "ower", "state", "secret", "mk", "ey", "input", "lock", "ke", "query", "tip", "cert", "mac", "seed", "iv", "ek", "name", "size", "sk"], "nkey": [" nk", "nmfee", "Ndata", "cnkey", "nnKey", "ndata", "natke", "Nfree", "gnfee", "nfree", "nmdiff", "gnkey", "nKey", "nvfee", " nke", "nmpage", "gndiff", "nkeys", "natKey", "nvdiff", "gnpage", "ndiff", "nnfree", "Npage", "nnkey", "cndata", "Nke", "cnkeys", "fnkey", " npage", "NKey", "nvkey", "nndata", "Nkeys", "natk", "nk", "natkey", " nKey", " nfree", "fnKey", "fnpage", "nfee", "Nkey", "nmkey", "Nk", " ndata", " nkeys", "cnKey", "npage", "nvpage", "nke"], "errp": ["ererp", " erp", "ererpb", " errpa", " erpa", "lerbp", "errpb", " erpb", "ererP", "Erbp", "errbp", " errpb", "ererpa", " erP", "lerpb", "lerp", "Erpb", " errbp", " errP", "Erp", "errpa", "errP"], "ctxt": ["critrench", "enttx", "utxt", "catxt", "ctfx", "crittx", "utext", "entext", "curext", "uttxt", "ectext", "ctait", "ctresh", "secttxt", "actief", "critxt", "acttxt", "conttxt", "ecttxt", "context", "curxt", "actxt", "sectxt", "ectxt", "ctct", "ptext", "actext", "entxt", "ntxt", "nttx", "sectief", "CTtx", "CTief", "CTxt", "cxt", "ktext", "contxt", "nttxt", "kttx", "ctext", "ctrench", "critext", "actfx", "CTtxt", "ntct", "curtxt", "enttxt", "catresh", "sectext", "actait", "contresh", "actresh", "ectfx", "ctx", "uttx", "ectct", "kttxt", "ecttx", "ctief", "pttxt", "pttx", "ptait", "curtx", "cttxt", "ectait", "cext", "cttx", "ptxt", "actrench", "acttx", "CTct", "catext", "CText", "contrench", "ktxt", "cattxt", "conttx", "ptfx"]}}
{"project": "qemu", "commit_id": "f57ba05823b7c444133f0862077b45824a6a89b5", "target": 0, "func": "static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,\n\n                                    bool is_legacy)\n\n{\n\n    int ret;\n\n    VqInfoBlock info;\n\n    VqInfoBlockLegacy linfo;\n\n    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);\n\n\n\n    if (check_len) {\n\n        if (ccw.count != info_len) {\n\n            return -EINVAL;\n\n        }\n\n    } else if (ccw.count < info_len) {\n\n        /* Can't execute command. */\n\n        return -EINVAL;\n\n    }\n\n    if (!ccw.cda) {\n\n        return -EFAULT;\n\n    }\n\n    if (is_legacy) {\n\n        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        linfo.align = address_space_ldl_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(linfo.queue),\n\n                                           MEMTXATTRS_UNSPECIFIED,\n\n                                           NULL);\n\n        linfo.index = address_space_lduw_be(&address_space_memory,\n\n                                            ccw.cda + sizeof(linfo.queue)\n\n                                            + sizeof(linfo.align),\n\n                                            MEMTXATTRS_UNSPECIFIED,\n\n                                            NULL);\n\n        linfo.num = address_space_lduw_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(linfo.queue)\n\n                                          + sizeof(linfo.align)\n\n                                          + sizeof(linfo.index),\n\n                                          MEMTXATTRS_UNSPECIFIED,\n\n                                          NULL);\n\n        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);\n\n    } else {\n\n        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.index = address_space_lduw_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(info.desc)\n\n                                           + sizeof(info.res0),\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.num = address_space_lduw_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.avail = address_space_ldq_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(info.desc)\n\n                                          + sizeof(info.res0)\n\n                                          + sizeof(info.index)\n\n                                          + sizeof(info.num),\n\n                                          MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.used = address_space_ldq_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index)\n\n                                         + sizeof(info.num)\n\n                                         + sizeof(info.avail),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        ret = virtio_ccw_set_vqs(sch, &info, NULL);\n\n    }\n\n    sch->curr_status.scsw.count = 0;\n\n    return ret;\n\n}\n", "idx": 10364, "substitutes": {"sch": ["sche", "kr", "usb", "chid", "gh", "ssh", "ch", "tk", "chn", "wk", "sg", "hs", "sp", "sm", "ich", "gr", "th", "Sch", "cer", "arch", "isc", "ss", "ssl", "rh", "mk", "chip", "sh", "kh", "ih", "sc", "ech", "CH", "cr", "sd", "hz", "sk"], "ccw": ["ecwt", "icwt", "congword", "uccwt", "pcway", "accW", "ccfw", "uccw", "ccaow", "cwal", "ecd", " ccwp", " ccW", "ccaws", "czy", " gccwd", "czwt", "CCws", "cusway", "icword", " gccW", "ckW", "czow", "scwa", "ckwd", " ccway", "ecw", "cword", "ccwd", "cfwd", "scw", "czway", " ccword", "scword", "CCW", "ccd", "ccwp", "ccnw", " acW", "ctxware", "ccwa", "CCw", "ckow", "ccv", "ctxw", "ccafw", "ccwt", " acwd", " acw", "congwd", "cusw", "ccway", "ccware", "cusv", " ccwt", "czfw", "cusware", "ccy", "cwd", "ctxway", "ccwal", "ctxv", "czd", "cknw", "ckws", "CCwt", " ccwd", "accwd", "ccow", " acwa", "congw", "czw", "czwd", "icw", "accwa", "cfwt", "icwd", "ccW", "scwd", " gccw", " ccy", "pcwp", " ccware", "accws", "accwt", "cfnw", "pcw", " ccv", "czws", "cwa", "ecway", "congwt", "czwal", "accword", "pcwd", " ccd", " gccwa", "ckw", "cw", "ccword", "uccnw", " ccwa", " ccwal", "ckfw", "cfw", "accw", "uccwd", "ckwt", "czwp", "ccaw", "ccws", "cy"], "check_len": ["info_en", "check_ln", "checkitylif", "checkableLen", "check_compl", "info_len", "checkablelif", "checkableen", "infoablelen", "Check_compl", "check_Len", "infoablelif", "check_en", "checkityen", "checkityLen", "infoableLen", "infoableen", "check_lif", "info_lif", "checkablelen", "checkitylen", "Check_len", "info_Len", "Check_ln", "Check_Len"], "is_legacy": ["is_regACY", "is_genacy", "is_levitimate", "is_privacy", "is_levacy", "is_regantic", "is_Legical", "is_levince", "is_legince", "is_LegACY", "is_magical", "is_genACY", "is_privACY", "is_Legitimate", "is_regacy", "is_regitimate", "is_regince", "is_Legantic", "is_legical", "is_legACY", "is_privical", "is_magacy", "is_Legince", "is_Legacy", "is_genantic", "is_legitimate", "is_legantic", "is_magACY"], "ret": ["len", "tr", "lt", "reset", " RET", "status", "print", "RET", "resp", "nt", "rev", "ref", " Ret", "mt", "Return", "usr", "txt", "alt", "r", "cont", "rel", "try", "rets", "val", "Ret", "xt", "rt", "re", "elt", "res", "rm", "result", "gt", "ft", "out"], "info": ["doc", "py", "inner", "op", "num", "notice", "id", "ready", "fi", "status", "config", "fo", "where", "image", "init", "list", "iso", "f", "error", "iter", "ok", "note", "type", "def", "local", "ki", "i", "auth", "ti", "ote", "kind", "txt", "all", "mem", "index", "try", "is", "row", "details", "ist", "data", "test", "now", "ci", "check", " inf", "conf", "sort", " error", "unknown", "metadata", "cache", "about", "good", "inf", "query", "information", "help", "si", "stat", "tip", "it", "pi", "INFO", "full", "by", "time", "hi", "no", "history", "Info"], "linfo": ["lnfo", "lanaxy", "lnso", "olinfo", "linco", "lncho", "lninfo", "jinfo", "linvey", "jinso", "olinfe", "lnzz", "olinxf", "alingoo", "lanmo", "pinmo", " pinmo", "alinco", " pininfo", "linusr", "alinph", "linfi", "linsty", "cinusr", "jinfi", " lininfo", "kinso", "linoha", "alinxf", "lininfo", "lnfi", "linso", "olinco", "linxf", "linzz", "jinoha", " linfi", "lnco", "linfore", "kinaxy", "licgoo", "jincho", "jinprop", "kininfo", "lanso", "olinfore", " pinfo", "kinfi", "kinoha", "licfo", "livey", "linprop", " linso", "olinusr", "olinaxy", " linmo", "lnprop", "olincho", "linaxy", "cinvey", "lingo", "lifo", "kinmo", "lanfe", "cinfi", "licxf", "linph", "olinso", "olingoo", "alinfore", " linvey", "lanprop", "linw", "jinmo", "olinprop", "licfore", "linmo", "jingo", "pinfi", " pinw", "lnmo", "lango", "cincho", "olinfi", "cinfo", "lnw", " linzz", " linprop", "alinfo", "lnph", "alinfi", " linph", "lanfo", "olinzz", "olinph", "lanfi", "lnoha", "lingoo", "cinso", "lnvey", "olinmo", "olinvey", "linfe", "lincho", "pinfe", "jinsty", "liusr", " linw", "pinfo", "cinsty", "kinfo", "licho", "lnsty", " lingo"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n", "idx": 10370, "substitutes": {"client": ["command", "config", "prefix", "pattern", "web", "friend", "protected", "contact", "open", "util", "ce", "queue", "attribute", "row", "check", "ace", "cmd", "controller", "public", "key", "pat", "call", "code", "channel", "match", "server", "conn", "close", "force", "batch", "item", "debug", "app", "grid", "patch", "project", "template", "writer", "obj", "current", "net", "pc", "application", "form", "builder", "component", "local", "confirmed", "window", "term", "connect", "connection", "plugin", "info", "remote", "comment", "quote", "start", "out", "entry", "lib", "con", "google", "secure", "cell", "manager", "event", "Client", "list", "complete", "p", "cl", "sim", "handle", "cli", "core", "all", "collection", "self", "cache", "c", "query", "co", "response", "store"], "err": ["kr", "arr", "inner", "norm", "ah", "notice", "ch", "rs", "ev", "resp", "error", "ex", "iter", "aaa", "gr", " terr", "g", "cer", "attr", "later", "cb", "mr", "desc", "eor", "rr", "usr", "cli", "Er", "txt", "r", "br", "n", "conn", "self", "info", "fr", "cfg", "good", "mk", "die", "e", "eas", "der", "elt", "str", "oe", "fee", "er", "res", "fer", "result", "msg", "cr", "exc", "dr", "out"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return kvm_irqchip_assign_irqfd(s, fd, virq, true);\n\n}\n", "idx": 10374, "substitutes": {"s": ["sl", "q", "rs", "p", "sp", "sts", "gs", "f", "ps", "d", "es", "sv", "ses", "r", "is", "js", "j", "S", "ss", "ts", "n", "se", "t", "v", "os", "sb", "c", "h", "sa", "ns", "w", "fs", "st", "sc", "set", "sis", "space", "ds"], "fd": ["td", "fin", "dd", "fi", "bf", "fl", "ff", "df", "f", "fp", "fm", "ld", "d", "da", "flo", "fb", "ud", "lf", "fe", "tif", "fa", "dra", "fn", "dl", "rod", "dir", "FD", " fid", "du", "bd", "fs", "fc", "fed", "fx", "db", "sd", "ds"], "virq": ["iovq", "iovqq", "virtQ", "virtue", "pirue", " virue", "viru", "virtq", " virquire", "virtu", " virQ", "pirQ", "rivq", "virQ", "virquire", "rivquire", "iovue", " viru", "virqq", "pirq", "iovquire", " virqq", "piru", "rivue", "rivqq", "virue"]}}
{"project": "qemu", "commit_id": "cdbf6e165988ab9d7c01da03b9e27bb8ac0c76aa", "target": 0, "func": "static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n", "idx": 10385, "substitutes": {"chan": ["Ch", "xy", "tx", "con", "ch", "channel", "cam", "sch", "chn", "anon", "ct", "alloc", "proc", "rec", "ach", "an", "ich", "cp", "act", "canon", "cb", "arch", "win", "wh", "ctx", "Chan", "conn", "dir", "wcs", "mon", "c", "cmd", "can", "res", "serv", "opt", "msg", "CH", "conv", "ann", "sys"], "cond": [" obj", " exc", " Cond", " conditions", " timeout", " compressor", " transient", "pos", "condition", " obs", " instr", "Condition", " conflict", " code", " conditional", " bool", " error", " unconditional", " block", " compress", " interrupt", " err", " cursor", "Cond", " fut", " proc", " trap"], "opaque": ["bitoser", "ipque", " opula", "iopque", "oposer", "bitque", "opque", " Opque", "opent", "iopacity", " Opaque", " opartment", "bitent", " opascript", " opacity", "iopent", "ipacity", "ioposer", " Opula", "ipula", "ipartment", " opque", "iopartment", " Opascript", "ipascript", "opartment", "iopaque", "opascript", "opula", "ipent", "bitaque", "ipaque", "iposer", "opacity"], "chr": ["whlr", "whrc", "chre", "ichr", " chmr", "echar", " chl", "ichar", "echrb", "whr", " chrc", "chrar", "ichre", "echrs", "CHr", "chlr", "chmr", "schl", "whmr", " chrs", "ichrb", " chrar", "Chrs", "Char", "schrb", " chre", "schr", "chrs", "CHmr", "chl", "CHlr", "chrc", "Chr", "Chrar", "chrb", "Chl", "CHrc", " chrb", "schrar", "echre", "echr", " chlr", "Chrb"], "s": ["ms", "vs", "ats", "hs", "cs", "m", "bits", "ins", "details", "http", "se", "y", "t", "os", "b", "serv", "ims", "conv", "ports", "gets", "settings", "gs", "sts", "ess", "changes", "ies", "sv", "args", "ses", "bs", "services", "als", "less", "js", "ss", "sb", "sis", "ls", "syn", "sq", "spec", "sl", "qs", "a", "rs", "l", "es", "i", "store", "ts", "n", "sw", "ns", "ds", "eps", "ps", "so", "aws", "is", "series", "S", "its", "j", "ssl", "self", "search", "c", "bis", "h", "stats", "fs", "set", "sys", "parts"], "status": ["atus", "tr", "success", "id", "spec", "sync", "comments", "current", "code", "flag", "base", "summary", "err", "valid", "compl", "Status", "resp", "sp", "error", "reason", "cs", "active", "US", "progress", "vis", "wait", "in", "wa", "details", "pres", "js", "ss", "uses", "ssl", "esp", "gc", "c", "str", "stats", "res", "serv", "stat", "xml", "st", "sc", "result", "set", "msg", "STAT", "name", "state"], "bufptr": ["cvcount", "boxPtr", "rabprime", "vecdepth", "bufPtr", "cvctr", "bufferctr", "cvcoord", "bufpointer", "bufferpointer", "boxpointer", "buffpointer", "vecptr", "cvptr", "buffptr", "bedptr", "bedtrace", "bufferptr", "ufaddr", "propprime", "ufcoord", "cbctr", "vecaddr", "boxctr", "rabpt", "bufdepth", "cvdepth", "proppt", "bufferproc", "cvaddr", "bufaddr", "boxprime", "cbpointer", "bufproc", "cbptr", "cvproc", "bufctr", "rabtrace", "ufproc", "boxptr", "ufcount", "bufferPtr", "bufferprime", "buffercount", "proptrace", "bedprime", "ufPtr", "bedpt", "ufprime", "buftrace", "buffctr", "buffprime", "ufpointer", "bufcoord", "bufprime", "rabptr", "veccoord", "ufdepth", "bufpt", "cbprime", "propptr", "bufcount", "ufctr", "ufptr"]}}
{"project": "qemu", "commit_id": "a01d8cadadf4c0dad8fc5157ee56aea8ec323982", "target": 1, "func": "PCIBus *pci_prep_init(qemu_irq *pic)\n\n{\n\n    PREPPCIState *s;\n\n    PCIDevice *d;\n\n    int PPC_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(PREPPCIState));\n\n    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);\n\n\n\n    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);\n\n    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);\n\n\n\n    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);\n\n    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n", "idx": 10406, "substitutes": {"pic": ["nic", "py", "Pic", "spec", "pc", "fi", "lib", "id", "IC", "picture", "p", "sp", "ps", "fp", "mic", "jp", "i", "ic", "txt", "ig", "script", "magic", "icc", "pb", "ac", "ics", "c", "asc", "eric", "pi", "fc", "pict", "sc", " Pic", "Picture", "sys", "pa"], "s": ["ms", "events", "ats", "hs", "cs", "m", "ins", "details", "r", "im", "se", "y", "t", "os", "b", "ips", "sa", "w", "comm", "ims", "sd", "ar", "settings", "sp", "gs", "sts", "ex", "g", "sv", "ses", "sam", "bs", "js", "ss", "conf", "ops", "e", "sb", "z", "ls", "params", "sq", "spec", "sl", "qs", "a", "rs", "as", "l", "es", "i", "ts", "n", "sh", "ns", "ds", "q", "p", "an", "ps", "south", "so", "us", "aws", "pers", "is", "j", "S", "its", "v", "c", "h", "stats", "fs", "sys"], "d": ["td", "dd", "dos", "id", "fd", "send", "add", "end", "and", "to", "p", "o", "ind", "da", "dc", "dx", "g", "ld", "m", "l", "pd", "i", "mod", "D", "r", "md", "gd", "j", "de", "done", "n", "y", "ad", "t", "new", "v", "rd", "e", "b", "der", "c", "h", "di", "rest", "w", "bd", "er", "it", "dot", "z", "x", "db", "dict", "dh", "debug", "sd", "dt", "ds", "dr"], "PPC_io_memory": ["PPC_IO_storage", "PPC_no_message", "PPC_no_storage", "PPC_io_storage", "PPC_no_mem", "PPC_io2mem", "PPC_no2media", "PPC_no_memory", "PPC_io2media", "PPC_no2mem", "PPC_no2memory", "PPC_io_message", "PPC_IO_mem", "PPC_no2message", "PPC_io2memory", "PPC_io_media", "PPC_io2message", "PPC_IO_memory", "PPC_io_mem", "PPC_IO_media", "PPC_no_media"]}}
{"project": "FFmpeg", "commit_id": "6d24231e504f71a76a8fabe87c8d7cfa826da75a", "target": 0, "func": "static int raw_init_encoder(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = (AVFrame *)avctx->priv_data;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->codec_tag = findFourCC(avctx->pix_fmt);\n\n    return 0;\n\n}\n", "idx": 10410, "substitutes": {"avctx": ["wavtx", "afkw", "avekt", " avcontext", "avkt", "avepkg", "avejp", "avconn", "aftx", "avecontext", "afctx", "avereq", " avkt", "averca", " avpkg", "averconn", "avconf", "wavctx", "AVkt", "afkt", "awconf", "averparams", "awtx", "AVctx", "awcontext", "avreq", "avcontext", "avcmd", "afconn", "averkt", "avecmd", "averpkg", "avercontext", "averkw", "wavparams", "AVcmd", "avjp", "averconf", "avca", "AVpkg", "AVjp", "aveconn", " avconf", "avectx", "aveca", "avkw", "avparams", "averctx", "afcontext", "afparams", "wavcontext", "avertx", "AVreq", "avtx", "avpkg", "wavkw", " avjp", " avtx", "averreq", "avercmd", "afca", "avetx", "awctx"]}}
{"project": "FFmpeg", "commit_id": "14f3f3a1ad9aca7599bdaa399cdb8680c52dc696", "target": 1, "func": "static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb)\n\n{\n\n    v->res_rtm_flag = 1;\n\n    v->level = get_bits(gb, 3);\n\n    if(v->level >= 5)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Reserved LEVEL %i\\n\",v->level);\n\n    }\n\n    v->chromaformat = get_bits(gb, 2);\n\n    if (v->chromaformat != 1)\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_ERROR,\n\n               \"Only 4:2:0 chroma format supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->postprocflag = get_bits(gb, 1); //common\n\n\n\n    v->s.avctx->coded_width = (get_bits(gb, 12) + 1) << 1;\n\n    v->s.avctx->coded_height = (get_bits(gb, 12) + 1) << 1;\n\n    v->broadcast = get_bits1(gb);\n\n    v->interlace = get_bits1(gb);\n\n    if(v->interlace){\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced mode not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    v->tfcntrflag = get_bits1(gb);\n\n    v->finterpflag = get_bits1(gb);\n\n    get_bits1(gb); // reserved\n\n    v->psf = get_bits1(gb);\n\n    if(v->psf) { //PsF, 6.1.13\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Progressive Segmented Frame mode: not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    if(get_bits1(gb)) { //Display Info - decoding is not affected by it\n\n        int w, h, ar = 0;\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display extended info:\\n\");\n\n        w = get_bits(gb, 14);\n\n        h = get_bits(gb, 14);\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display dimensions: %ix%i\\n\", w, h);\n\n        //TODO: store aspect ratio in AVCodecContext\n\n        if(get_bits1(gb))\n\n            ar = get_bits(gb, 4);\n\n        if(ar == 15) {\n\n            w = get_bits(gb, 8);\n\n            h = get_bits(gb, 8);\n\n        }\n\n\n\n        if(get_bits1(gb)){ //framerate stuff\n\n            if(get_bits1(gb)) {\n\n                get_bits(gb, 16);\n\n            } else {\n\n                get_bits(gb, 8);\n\n                get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        if(get_bits1(gb)){\n\n            v->color_prim = get_bits(gb, 8);\n\n            v->transfer_char = get_bits(gb, 8);\n\n            v->matrix_coef = get_bits(gb, 8);\n\n        }\n\n    }\n\n\n\n    v->hrd_param_flag = get_bits1(gb);\n\n    if(v->hrd_param_flag) {\n\n        int i;\n\n        v->hrd_num_leaky_buckets = get_bits(gb, 5);\n\n        get_bits(gb, 4); //bitrate exponent\n\n        get_bits(gb, 4); //buffer size exponent\n\n        for(i = 0; i < v->hrd_num_leaky_buckets; i++) {\n\n            get_bits(gb, 16); //hrd_rate[n]\n\n            get_bits(gb, 16); //hrd_buffer[n]\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 10414, "substitutes": {"v": ["vs", "current", "u", "status", "va", "av", "vi", "q", "up", "ev", "vv", "ov", "uv", "p", "ve", "vc", "value", "f", "wire", "var", "dev", "lv", "vp", "g", "m", "l", "rev", "um", "sv", "qv", "detail", "vt", "ver", "en", "inv", "video", "j", "version", "n", "y", "view", "k", "t", "qu", "V", "vim", "cache", "env", "val", "b", "query", "er", "st", "pi", "it", "x", "z", "cv", "vr", "iv", "max", "vm", "nv", "conv", "tv"], "gb": ["tm", "gem", "xy", "range", "sg", "pg", "bits", "ruby", "storage", "html", "eb", "deg", "b", "rect", "kb", "gam", "nb", "ib", "cv", "gif", "gm", "uf", "rb", "gnu", "tg", "gs", "bc", "um", "args", "gz", "wb", "bs", "gd", "cz", "emb", "sb", "cm", " rgb", "bt", "img", "vg", "goo", "mb", "bf", "pc", "got", "ch", "GB", "Gb", "cd", "fb", "raw", "bg", "eg", "phy", "ctx", "rg", "erb", "verified", "bb", "db", "vm", "hog", "binary", "hub", "py", "gg", "lib", "mg", "cb", "bytes", "pb", "cfg", "gc", "csv", "buff", "gt", "sys"], "w": ["fw", "ww", "a", "mm", "iw", "wal", "weight", "wi", "we", "W", "wid", "ex", "d", "rw", "g", "l", "m", "wx", "win", "wh", "window", "en", "wa", "ew", "r", "wl", "n", "t", "wd", "man", "wp", "sw", "wt", "hw", "kw", "x", "z", "s", "nw", "wb"], "h": ["he", "ph", "hr", "hm", "ah", "u", "ch", " H", "q", "ht", "p", "hash", "height", "o", "f", "d", "g", "m", "l", "hd", "hl", "length", "wh", "oh", "ho", "en", "hh", "ish", "n", "html", "y", "ha", "change", "rh", "b", "c", "sh", "bh", "kh", "ih", "z", "hi", "history", "hz", "H", "dr"]}}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "int page_unprotect(target_ulong address, uintptr_t pc, void *puc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(addr, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 10416, "substitutes": {"address": ["command", "page", "password", "record", "resource", "network", "Address", "message", "add", "pointer", "order", "prefix", "path", "region", "range", "hash", "point", "domain", "ase", "location", "ip", "process", "position", "trace", "port", "length", "reference", "server", "attribute", "index", "ad", "interface", "directory", "date", "dress", "ace", "ress", "search", "host", "start", "alias", "memory", "description", "offset", "size", "number"], "pc": ["td", "oc", "arc", "pic", "pp", "pt", "bp", " PC", "proc", "ec", "cp", "bc", "dc", "xc", "pty", "cs", "tc", "ic", "cc", "lp", "cod", "isc", "pb", "mc", "ctx", "PC", "rc", "gc", "c", "uc", "asc", "nc", "cu", "fc", "sc", "vc", "pid", "pa"], "puc": ["paUC", "pauh", "tucc", "pucc", "iauc", "iuc", " pucc", "puh", "cpuc", " pauc", "pUC", "paucc", " pUC", "pauc", "cpUC", "tUC", "tauc", "cpucc", "cpuh", " puh", "iucc", "iUC", "tuc"], "prot": ["col", "platform", "td", "tf", "method", "tr", "num", "next", "typ", "fd", "pat", "tp", "fl", "net", "mat", "status", "mult", "pt", "format", "proc", "prop", "seq", "fp", " Prot", "Prot", "pkg", "np", "pos", "type", "bits", "ptr", "port", "txt", " Proto", "ext", " pref", "top", "ocol", "lag", " fmt", "version", "mobile", "ssl", "rot", "cmd", "eth", "flags", "tag", "stat", " proto", " protocols", " PROT", " protocol", "fc", "phys", " plat", "msg", "dh", "pro", " shr", "ret"], "p": ["page", "obj", "op", "ph", "tp", "pe", "part", "par", "pat", "pp", "pt", "policy", "a", "bp", "ping", "proc", "sp", "resp", "rep", "f", "post", "ps", "cp", "fp", "point", "d", "pg", "g", "jp", "m", "np", "ap", "pkg", "vp", "pd", "i", "progress", "local", "port", "parse", "lp", "pers", "pm", "j", "pb", "y", "P", "t", "v", "pr", "pl", "cache", "wp", "c", "pre", "w", "dp", "php", "z", "comm", "app", "mp", "pro", "patch", "out", "pa"], "host_start": [" host_art", "host_next", "host_begin", " host_st", "host00end", " host0end", "host09end", "host_length", "host0end", " host0start", "host00starting", "Host_size", "host0next", "host09start", "host_starting", "Host_begin", "Host_start", "Host_length", "host00art", "host_st", " host0next", "host_size", "host_key", "Host_key", "host0start", " host_starting", " host_next", "host09st", "host09next", "host_art", " host0st", "host00start", "Host_end", "host0st"], "host_end": ["localhost_end", "target_stop", "host_nd", " host_ent", "localhost_END", "target_ends", "host_max", "host_ending", "host_ends", "host_END", "host_ent", "localhost_nd", "host1ending", "host1END", "host_stop", " host_max", "host1nd", "host1end", "target_end", "target_start", "localhost_ending", " host_END"], "addr": ["ms", "on", "add", "end", "ng", "hl", "r", "wd", "ast", "ace", "cmd", "elt", "dh", "arr", "arp", "at", "iter", "rev", "gate", "ptr", "ix", "ac", "rt", "adj", "alias", "link", "att", "ls", "src", "obj", "id", "mb", "url", "Address", "order", "rs", "nz", "point", "gr", "ip", "pos", "ref", "ap", "points", "l", "inter", "i", "mem", "index", "ad", "ctx", "host", "sw", "ag", "hw", "start", "oad", "oa", "loc", "ret", "mt", "align", "ash", "aj", "ack", "dev", "pad", "pkg", "port", "adr", "handle", "alt", "ord", "lat", "md", "aff", "eth", "res", "x", "coord", "mac", "offset", "dr"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);\n\n}\n", "idx": 10429, "substitutes": {"dst": ["dsc", "rport", " dest", " dsc", "dsport", " dport", "ldsc", "dsst", "ldst", "ddest", "dsdest", "ldest", "dest", "lddest", "sest", "sdest", "rdest", "rst", "ssc", "dport", "rest", " ddest", "dsest", "sst"], "src": ["inner", "sl", "source", "rs", "trans", "cur", "np", "ins", "hl", "ptr", "gin", "txt", "in", "bg", "r", "rl", "dest", "dq", "impl", "rc", "input", "sb", "b", "ctr", "comp", "ipl", "sn", "rt", "str", "sr", "inst", "dist", "st", "sc", "ur", "s", "iv", "loc", "img", "sys"], "stride": [" strride", "dride", "sage", "side", "sride", "stid", "STRend", " strid", "divend", "divride", "Strend", "slide", " strider", "trider", "tride", "strride", "druse", "STRide", "divid", " strend", "strider", " strope", "slid", "sid", "stage", "struse", "strope", "strend", "trride", "Stride", "Struse", "strid", "STRuse", "Strride", "slend", " strage", "STRride", "divide", "stide", "drend", "drride", "slride", "slider", "strage", "trope", "slope"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int film_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 4)\n\n        return 0;\n\n\n\n    if (AV_RB32(&p->buf[0]) != FILM_TAG)\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 10449, "substitutes": {"p": ["art", "pc", "pat", "tp", "a", "pp", "q", "up", "post", "f", "ps", "cp", "d", "ip", "g", "pkg", "m", "process", "ap", "jp", "np", "press", "progress", "pa", "r", "pers", "j", "n", "pb", "ad", "t", "P", "v", "b", "c", "wp", "h", "pro", "w", "dp", "att", "mp", "pre", "pod"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,\n\n                       unsigned int size, int mem_index)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv taddr = tcg_temp_local_new();\n\n    TCGv tval = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    dc->postinc = 0;\n\n    cris_evaluate_flags(dc);\n\n\n\n    tcg_gen_mov_tl(taddr, addr);\n\n    tcg_gen_mov_tl(tval, val);\n\n\n\n    /* Store only if F flag isn't set */\n\n    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n    if (size == 1) {\n\n        tcg_gen_qemu_st8(tval, taddr, mem_index);\n\n    } else if (size == 2) {\n\n        tcg_gen_qemu_st16(tval, taddr, mem_index);\n\n    } else {\n\n        tcg_gen_qemu_st32(tval, taddr, mem_index);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */\n\n    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(tval);\n\n    tcg_temp_free(taddr);\n\n}\n", "idx": 10478, "substitutes": {"dc": ["oc", "doc", "tx", "pc", "DC", "iac", "ec", "rec", "df", "cp", "da", "bc", "xc", "d", "tc", "cs", "cd", "ctl", "cc", "mc", "ci", "ctx", "ac", "lc", "rc", "cfg", "conn", "gc", "c", "di", "cm", "nc", "dp", "fc", "disc", "sc", "comm", "dm", "dt", "ds", "dr", "ca"], "addr": ["src", "tr", "tx", "id", "address", "map", "nl", "arp", "at", "add", "alloc", "var", "act", "ip", "pkg", "pos", "ref", "attr", "hl", "ptr", "rr", "adr", "alt", "mem", "r", "ix", "n", "ad", "ctx", "conn", "rc", "wd", "ace", "host", "eth", "rt", "hw", "alias", "x", "oad", "oa", "loc", "offset", "dr", "mt"], "val": ["lt", "lit", "tx", "al", "VAL", "value", "var", "buf", "bl", "vc", "p", "dev", "label", "l", "ref", "Val", "vt", "util", "alt", "mem", "eval", "rel", "test", "t", "v", "pr", "pol", "bal", "rt", "serv", "vals", "el", "loc", "vol", "arg", "ret"], "size": ["len", "ity", "empty", "num", "notice", "small", "send", "sum", "message", "news", "area", "sp", "Size", "SIZE", "capacity", "scope", "dimension", "type", "zero", "ize", "mem", "index", "n", "now", "ci", "sha", "count", "zone", "iz", "sw", "sh", "scale", "sn", "sy", "member", "fee", "si", "equal", "set", "see", "sized", "ze", "max", "name", "space", "length", "style", "number"], "mem_index": ["memoryposition", "memtindex", "mem_free", " mem_Index", "memtposition", "memoryIndex", " mem_free", " mem_ind", "mem_position", "memzaddress", "mem2number", " mem_num", " mem_instance", "mem_instance", "memxnum", " mem_number", "mem2Index", "memxindex", "mem_number", "memxind", "mem_num", "mem2ind", "memoryinstance", "memtfree", "memoryindex", " mem_position", "mem_Index", "memxnumber", "memznum", "memzvalue", " mem_value", "memtIndex", "mem2index", " mem_address", "mem2num", "memzindex", "mem_value", "mem_address", "mem_ind", "mem2free", "mem2position"]}}
{"project": "qemu", "commit_id": "947858b0ba97f4ec097de667e45eff99212867c3", "target": 0, "func": "static void ide_trim_bh_cb(void *opaque)\n\n{\n\n    TrimAIOCB *iocb = opaque;\n\n\n\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n\n\n\n    qemu_bh_delete(iocb->bh);\n\n    iocb->bh = NULL;\n\n    qemu_aio_unref(iocb);\n\n}\n", "idx": 10480, "substitutes": {"opaque": ["Opaque", "iopque", "operaque", "OPiera", "opaques", "opque", "poplation", "catque", "iopaques", "iopity", "Opque", "OPlation", "cataque", "OPaque", "Opaques", "popiera", "oppaques", "Opiera", "operaques", "Oplation", "OPity", "operque", "OPaques", "Opity", "oppaque", "popque", "opity", "oppque", "iopaque", "OPque", "opiera", "oplation", "popaque", "cataques"], "iocb": ["aiocb", "ioggbc", "iocationbe", "iniocationbe", "iociber", "irocber", "iocber", "ioadB", "iokB", "pirocd", "ioadb", "iocc", "iocbe", "piocybj", "iocybj", "ivocg", "iocB", "iaconc", "ioconpb", "iniocbf", "iocifb", "airocv", "iircbf", "piocbj", "airocg", "eiocbc", "ioricalsb", "irocc", "ioconbc", "piocb", "ioggsb", "ioggb", "iocpb", "ioconb", "eioggbc", "eiocb", "ioricalbc", "iallocb", "iocationbc", "iiscb", "piocyb", "dioca", "iniocationb", "pirocber", "iircbe", "eioggb", "pirocfb", "irocg", "iocbj", "diocpb", "diocb", "iniocbc", "iniocationbc", "iaconb", "iallocpb", "ioricalb", "iocbd", "piocfb", "pioadb", "piocbar", "ioconc", "piocybar", "airocb", "iiscbb", "aiocv", "iocbb", "iocib", "irocpb", "iocationbf", "iniocbe", "irocbar", "piocB", "iorgb", "iaconpb", "iokbar", "ioconbf", "iircb", "iocsb", "iorgd", "eioggpb", "iorgfb", "iorgber", "iiscbd", "ioadbb", "pioadbd", "eiocpb", "iokbj", "pirocb", "diroca", "iocbc", "irocfb", "ioadd", "ioadbd", "iniocb", "irocbd", "iocid", "irocd", "iocv", "iocg", "iroca", "irocbj", "piocber", "irocB", "ioadv", "iiscB", "airocd", "ivocb", "aiocd", "iacona", "pioadB", "eioggsb", "piocbb", "iocona", "iocbf", "iircbc", "eiocsb", "ioggpb", "iokb", "diocc", "iocyb", "iocybar", "aiocg", "irocb", "iocyB", "irocbb", "dirocc", "ioconbe", "iocationb", "iocd", "dirocb", "ivocv", "iocfb", "iallocsb", "iallocbc", "iniocationbf", "ioricalpb", "dirocpb", "piocd", "ioca", "ioadg", "irocv", "piocbd", "ivocd", "pioadbb", "piocyB", "iocbar"]}}
{"project": "qemu", "commit_id": "ad11ad77748bdd8016370db210751683dc038dd6", "target": 0, "func": "static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n\n                            abi_long cmd, abi_long arg)\n\n{\n\n    void *argptr;\n\n    struct dm_ioctl *host_dm;\n\n    abi_long guest_data;\n\n    uint32_t guest_data_size;\n\n    int target_size;\n\n    const argtype *arg_type = ie->arg_type;\n\n    abi_long ret;\n\n    void *big_buf = NULL;\n\n    char *host_data;\n\n\n\n    arg_type++;\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        ret = -TARGET_EFAULT;\n\n        goto out;\n\n    }\n\n    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n\n    unlock_user(argptr, arg, 0);\n\n\n\n    /* buf_temp is too small, so fetch things into a bigger buffer */\n\n    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n\n    memcpy(big_buf, buf_temp, target_size);\n\n    buf_temp = big_buf;\n\n    host_dm = big_buf;\n\n\n\n    guest_data = arg + host_dm->data_start;\n\n    if ((guest_data - arg) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    guest_data_size = host_dm->data_size - host_dm->data_start;\n\n    host_data = (char*)host_dm + host_dm->data_start;\n\n\n\n    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n\n    switch (ie->host_cmd) {\n\n    case DM_REMOVE_ALL:\n\n    case DM_LIST_DEVICES:\n\n    case DM_DEV_CREATE:\n\n    case DM_DEV_REMOVE:\n\n    case DM_DEV_SUSPEND:\n\n    case DM_DEV_STATUS:\n\n    case DM_DEV_WAIT:\n\n    case DM_TABLE_STATUS:\n\n    case DM_TABLE_CLEAR:\n\n    case DM_TABLE_DEPS:\n\n    case DM_LIST_VERSIONS:\n\n        /* no input data */\n\n        break;\n\n    case DM_DEV_RENAME:\n\n    case DM_DEV_SET_GEOMETRY:\n\n        /* data contains only strings */\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        break;\n\n    case DM_TARGET_MSG:\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n\n        break;\n\n    case DM_TABLE_LOAD:\n\n    {\n\n        void *gspec = argptr;\n\n        void *cur_data = host_data;\n\n        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n        int spec_size = thunk_type_size(arg_type, 0);\n\n        int i;\n\n\n\n        for (i = 0; i < host_dm->target_count; i++) {\n\n            struct dm_target_spec *spec = cur_data;\n\n            uint32_t next;\n\n            int slen;\n\n\n\n            thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n\n            slen = strlen((char*)gspec + spec_size) + 1;\n\n            next = spec->next;\n\n            spec->next = sizeof(*spec) + slen;\n\n            strcpy((char*)&spec[1], gspec + spec_size);\n\n            gspec += next;\n\n            cur_data += spec->next;\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n        ret = -TARGET_EINVAL;\n\n        goto out;\n\n    }\n\n    unlock_user(argptr, guest_data, 0);\n\n\n\n    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (!is_error(ret)) {\n\n        guest_data = arg + host_dm->data_start;\n\n        guest_data_size = host_dm->data_size - host_dm->data_start;\n\n        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);\n\n        switch (ie->host_cmd) {\n\n        case DM_REMOVE_ALL:\n\n        case DM_DEV_CREATE:\n\n        case DM_DEV_REMOVE:\n\n        case DM_DEV_RENAME:\n\n        case DM_DEV_SUSPEND:\n\n        case DM_DEV_STATUS:\n\n        case DM_TABLE_LOAD:\n\n        case DM_TABLE_CLEAR:\n\n        case DM_TARGET_MSG:\n\n        case DM_DEV_SET_GEOMETRY:\n\n            /* no return data */\n\n            break;\n\n        case DM_LIST_DEVICES:\n\n        {\n\n            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };\n\n            int nl_size = 12; /* can't use thunk_size due to alignment */\n\n\n\n            while (1) {\n\n                uint32_t next = nl->next;\n\n                if (next) {\n\n                    nl->next = nl_size + (strlen(nl->name) + 1);\n\n                }\n\n                if (remaining_data < nl->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + nl_size, nl->name);\n\n                cur_data += nl->next;\n\n                remaining_data -= nl->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                nl = (void*)nl + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_DEV_WAIT:\n\n        case DM_TABLE_STATUS:\n\n        {\n\n            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n            int spec_size = thunk_type_size(arg_type, 0);\n\n            int i;\n\n\n\n            for (i = 0; i < host_dm->target_count; i++) {\n\n                uint32_t next = spec->next;\n\n                int slen = strlen((char*)&spec[1]) + 1;\n\n                spec->next = (cur_data - argptr) + spec_size + slen;\n\n                if (guest_data_size < spec->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + spec_size, (char*)&spec[1]);\n\n                cur_data = argptr + spec->next;\n\n                spec = (void*)host_dm + host_dm->data_start + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_TABLE_DEPS:\n\n        {\n\n            void *hdata = (void*)host_dm + host_dm->data_start;\n\n            int count = *(uint32_t*)hdata;\n\n            uint64_t *hdev = hdata + 8;\n\n            uint64_t *gdev = argptr + 8;\n\n            int i;\n\n\n\n            *(uint32_t*)argptr = tswap32(count);\n\n            for (i = 0; i < count; i++) {\n\n                *gdev = tswap64(*hdev);\n\n                gdev++;\n\n                hdev++;\n\n            }\n\n            break;\n\n        }\n\n        case DM_LIST_VERSIONS:\n\n        {\n\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n\n            int vers_size = thunk_type_size(arg_type, 0);\n\n\n\n            while (1) {\n\n                uint32_t next = vers->next;\n\n                if (next) {\n\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n\n                }\n\n                if (remaining_data < vers->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + vers_size, vers->name);\n\n                cur_data += vers->next;\n\n                remaining_data -= vers->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                vers = (void*)vers + next;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            ret = -TARGET_EINVAL;\n\n            goto out;\n\n        }\n\n        unlock_user(argptr, guest_data, guest_data_size);\n\n\n\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n\n        if (!argptr) {\n\n            ret = -TARGET_EFAULT;\n\n            goto out;\n\n        }\n\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n\n        unlock_user(argptr, arg, target_size);\n\n    }\n\nout:\n\n    if (big_buf) {\n\n        free(big_buf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10485, "substitutes": {"ie": ["je", "esi", "ice", "wife", "me", "io", "ei", "ee", "tie", "ipe", "ect", "eur", "ind", "exe", "ies", "ctl", "ite", "ia", "ine", "ig", "ce", "eg", "eddy", "IE", "de", "se", "ied", "iu", "ele", "dem", "ties", "icer", "e", "die", "ive", "ace", "sie", "addy", "oe", "er", "iy", "estate", "it", "ini", "driver", "ze", "ide", "dm", "el", "eve", "ji", "le", "ij"], "buf_temp": ["buf32ptr", "uf_tem", " buf_tmp", "buf_iter", "buf_ptr", "uf_tmp", "batch_emp", "buf_tmp", "buf_0", "batch32tem", "buf2iter", " buf_buffer", "buffer_tem", "uf_0", "buf2tem", "buffer_temp", "buf32temp", "buffer_tmp", "buffer_iter", "batch32ptr", "batch_temp", "buf_tem", "buf2temp", "buf_emp", "buf32tem", "uf_iter", "batch32temp", "batch_tem", "buf2tmp", "uf_temp", "batch_ptr", "buf32emp", " buf_ptr", "batch32emp", "buf_buffer"], "fd": ["ef", " fin", "id", "bf", " offset", " res", "f", " dev", " func", "d", "ref", " def", " af", " df", "fe", "t", "Ret", " resp", " sig", "res", " ev", "fc", " dst", " f", "pid", " proc", "af"], "cmd": ["command", "op", "Cmd", "code", "init", "ct", "cut", "bind", "buf", "cp", "nt", "cd", "type", "ptr", "desc", "kind", "addr", "md", "ctx", "wd", "gen", "dir", "host", "ctr", "target", "msg", "name"], "arg": ["arr", "doc", "key", "op", "arp", "call", "par", "flag", "add", "deb", "or", "err", "event", "ack", "p", "var", "prop", "argument", "field", "pg", "ok", "iter", "g", "admin", "ref", "inter", "attr", "args", "ptr", "ig", "addr", "ext", "in", "bit", "md", "mem", "Arg", "emb", "t", "new", "reg", "ang", "val", "target", "orig", "ag", "tag", "ob", "it", "param", "gt", "msg", "bar", "ar"], "argptr": ["artr", "argPtr", "argpad", " argpad", "jobj", " argcert", " argtr", "argsPtr", " argPtr", " argpr", "retptr", "varpointers", "retcert", "igptr", "aggpad", "opptr", "arrptr", "argspad", "mempointer", "jptr", "memptr", " argpt", "igpointer", " argobj", "jpr", " argpointer", "argcert", "oppointer", "optr", "varPtr", "arPtr", "argtr", "igpointers", "argpt", "varpointer", "argpr", "arpointer", "argspointer", "retPtr", "argobj", "arpointers", "argpointers", "arptr", "arrpointer", "mempt", " argpointers", "argsptr", "retpointer", "aggPtr", "mempointers", "arrobj", "opPtr", "aggpointer", "igpt", "arrpr", "aggptr", "jpointer", "argpointer", "varptr", "arcert"], "host_dm": ["hosteddir", "server_dt", " host_dom", "other_drm", " host2dev", "host5drm", " host2DM", " host_DM", "host2dem", " host_dev", "work_drm", "host_dir", " host_deb", "hostLdir", "host_dom", "server_dem", " host_dim", " host_dl", "host___dev", "other_dem", "other_nm", " host2mont", "host_drm", "host2dim", "host2dev", "host_dem", "host5dm", "hostMDM", "server_dm", " host_mont", "server_dim", "host5dx", "hostLdl", " hosteddir", "host_nm", " hosteddm", "hosteddl", " host_dem", "host_dl", "host_DM", "host_mont", "host___dm", "host_cm", "host___dem", "host2mont", " host_cm", " hosteddl", "work___dx", "host_dx", "host___dim", "work_dm", " host2dem", "host5dim", "host_dim", "hosteddm", "other_dm", "host_dt", "hostLdim", "hostMdm", "work_dim", " hosteddim", "work_dx", "work___dim", "host_dev", " host2dm", "work___drm", "host_deb", " host2dim", "host___DM", "host2DM", "work___dm", "hostMdem", " host_dir", "hosteddim", "host2dm", "host___drm", "hostMdev", "host2dx", "host___dx", "host2drm", "hostLdm"], "guest_data": ["guost7Data", "guestJdata", "guess_size", "guEST_value", "guest2Data", "guost7name", "guestedDATA", "guost_data", "guost_Data", "guest_Data", "guost_image", "guest7name", "guest2no", "guost7image", "guestJDATA", "guest_image", "guost7data", "guest7data", "guestJstart", "guest2name", "guess_data", "guEST2data", "guest2data", "guest_DATA", "guost_name", "guesttsize", "guest2image", "guEST2start", "guEST_DATA", "guest_value", "guesttvalue", "guestJno", "guesttno", "guest2DATA", "guEST2no", "guess_value", "guest2start", "guestedvalue", "guEST_data", "guest_name", "guest2size", "guest_no", "guess_no", "guEST_no", "guest7Data", "guesteddata", "guesttdata", "guest_size", "guest_start", "guEST_start", "guest2value", "guEST2DATA", "guest7image"], "guest_data_size": ["guest_data_length", "guest_data_name", "guest_block_SIZE", "guest_data_Size", "guest_block_length", "guest_data_sum", "guest_data_SIZE", "guest_block_Size", "guest_block_size"], "target_size": ["buffer_size", "target64string", "target32size", "buffer_type", "arget_Size", "arget_name", "targetvaltype", "target64speed", "target7Size", "arg32dim", "target_speed", "arg32speed", "target7size", "arg32size", "target_number", "targetvalsize", "target_string", "target64dim", "targetvaldim", "target_name", "arg_string", "target_type", "target7number", "Target_size", "target32dim", "arg_speed", "Target_Size", "arg_size", "target32string", "target64size", "target_news", "buffer_news", "arg32string", "arg_dim", "Target_number", "target32speed", "buffer_dim", "target_Size", "arget_size", "target_dim", "targetvalnews"], "arg_type": ["arg_Type", "argmmtype", "arg_TYPE", "arg_case", "tag_length", "argtype", "argttype", "target_count", "argtlength", "arg_t", "ig_type", "arg_label", "ig_group", "argmmlabel", "target_case", "target_name", "target_type", "arg_var", "arg_count", "target_label", "arg_name", "argmmcase", "tag_name", "ig_var", "arg_size", "ig_Type", "tag_type", "arg_length", "target_TYPE", "argtname", "arg_group", "argmmname", "target_t", "tag_ype", "arg_ype"], "ret": ["tr", "status", "jump", "flag", "err", "print", "nz", "RET", " ref", "resp", "f", "nt", "slot", "g", "rev", "ref", "def", "mt", "desc", "alt", "ext", "r", "try", "j", "ts", "t", "__", " flags", "reg", "gc", "val", "Ret", "red", "target", "eth", "rt", "re", "elt", "sys", "res", "rm", "x", "result", "att", "ft", "gt", "ll", "Return", "dr", "out"], "big_buf": ["fatPbuf", " big_uf", "fatPmem", "bigJbuffer", "big_uf", " big_buff", "big__buffer", "fat_uf", "biglybuf", "big_buffer", "big___buf", "big2buffer", "biglytemp", "bigPdata", " big_Buff", "big__buf", "big_buff", "big_tmp", "Big_buf", "Big_buff", "bigJbuf", "biglybuffer", "big2uf", "big__tmp", "fatPuf", "Big_uf", "bigPuf", "big2buf", " big_temp", "big_mem", "big___tmp", "big2buff", "bigPmem", "fat_buf", " big_tmp", "big___uf", "big_data", "fat_mem", "bigPtmp", " big_data", "big_Buff", " big_buffer", "biglyBuff", "Big_buffer", "bigPbuf", "bigJtemp", "fatPtmp", "bigJBuff", "big_temp", "fat_tmp", "big__data", "big___mem", "bigPbuffer"], "host_data": ["host_name", "host2name", "hub_name", "Host_data", "Host_name", "host_dir", "host2data", "Host_dir", "hub_DATA", "host_DATA", "hub_memory", "host2dir", "host_memory", "Host_done", "host_done", "host2done", "hub_data"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)\n\n{\n\n    InputStream        *ist = s->opaque;\n\n    DXVA2Context       *ctx = ist->hwaccel_ctx;\n\n    int                ret;\n\n\n\n    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_frame_copy_props(ctx->tmp_frame, frame);\n\n    if (ret < 0) {\n\n        av_frame_unref(ctx->tmp_frame);\n\n        return ret;\n\n    }\n\n\n\n    av_frame_unref(frame);\n\n    av_frame_move_ref(frame, ctx->tmp_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 10498, "substitutes": {"s": ["sq", "rs", "hs", "sp", "gs", "sts", "sg", "p", "ps", "sac", "ess", "g", "cs", "es", "sv", "i", "xs", "bs", "is", "js", "S", "ss", "its", "v", "os", "sb", "e", "c", "h", "sie", "ns", "fs", "set", "ls", "ds", "sys"], "frame": ["rame", "doc", "spec", "fi", "code", "message", "feature", "hide", "image", "base", "init", "sample", "file", "form", "profile", "point", "seq", "f", "cf", "block", "fram", "process", "ref", "face", "sequence", "fb", "def", "flow", "word", "zero", "window", "fe", "ce", "fact", "none", "ext", "chain", "video", "data", " Frame", "header", "iframe", "one", "Frame", "fr", "feat", "ence", "scene", "framework", "force", "piece", "context", "draw"], "ist": ["ert", "IST", "art", "iste", "ists", "isi", "IS", "ith", "et", "oci", "imet", "iop", "ind", "ess", "ust", "ic", "iss", "is", "isc", "its", "isting", "ous", "aci", "ik", "exist", "ast", "ive", "alist", "ism", "xt", "irst", "ost", "bh", "wp", "est", "osi", "ush", "ih", "ij", "it", "ift", "pect", "sys", "ird"], "ctx": ["jac", "tm", "obj", "ck", "tx", "cmp", "std", "ctrl", "crit", "bp", "req", "tk", "ct", "loc", "history", "kt", "wid", "cp", "cf", "nt", "bc", "iat", "scope", "pkg", "tc", "np", "wx", "jp", "cb", "desc", "ctl", "cc", "addr", "kl", "dl", "mc", "conn", "lc", "cfg", "mk", "gc", "ctr", "cmd", "ns", "nc", "kw", "cm", "cu", "context", "comm", "msg", "cv", "mom", "vc", "sys"], "ret": ["reset", "rier", "print", "reply", "ry", "cat", " Ret", "desc", "t", "rem", "deg", "cmd", "elt", "vet", "rm", "result", "ll", "arg", "arr", "tr", "pat", "code", "RET", " res", "iter", "prot", "pret", "after", "en", "usr", "txt", "ter", "try", "ben", "rets", "Ret", "xt", "rt", "net", "back", "err", "nz", "resp", "nt", "ref", "inter", "def", "reg", "it", "cert", "ft", "out", "mt", "len", "num", " RET", "det", "fun", "git", "alt", "ext", "expr", "cont", "j", "val", "re", "res", "ber", "gt", " fut", "sys"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,\n\n                    uint8_t *segment, uint8_t *ref, int layout)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (s->segmentation.update_map)\n\n        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);\n\n    else if (s->segmentation.enabled)\n\n        *segment = ref ? *ref : *segment;\n\n    mb->segment = *segment;\n\n\n\n    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;\n\n\n\n    if (s->keyframe) {\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,\n\n                                    vp8_pred16x16_prob_intra);\n\n\n\n        if (mb->mode == MODE_I4x4) {\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);\n\n        } else {\n\n            const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u;\n\n            if (s->mb_layout == 1)\n\n                AV_WN32A(mb->intra4x4_pred_mode_top, modes);\n\n            else\n\n                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);\n\n            AV_WN32A(s->intra4x4_pred_mode_left, modes);\n\n        }\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                vp8_pred8x8c_prob_intra);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {\n\n        // inter MB, 16.2\n\n        if (vp56_rac_get_prob_branchy(c, s->prob->last))\n\n            mb->ref_frame =\n\n                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */\n\n                                                      : VP56_FRAME_GOLDEN;\n\n        else\n\n            mb->ref_frame = VP56_FRAME_PREVIOUS;\n\n        s->ref_count[mb->ref_frame - 1]++;\n\n\n\n        // motion vectors, 16.3\n\n        decode_mvs(s, mb, mb_x, mb_y, layout);\n\n    } else {\n\n        // intra MB, 16.1\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);\n\n\n\n        if (mb->mode == MODE_I4x4)\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                s->prob->pred8x8c);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n        mb->partitioning     = VP8_SPLITMVMODE_NONE;\n\n        AV_ZERO32(&mb->bmv[0]);\n\n    }\n\n}\n", "idx": 10502, "substitutes": {"s": ["ms", "tm", "vs", "ats", "mm", "hs", "o", "cs", "m", "esm", "bits", "ins", "details", "r", "bound", "http", "se", "t", "sports", "mys", "os", "has", "b", "w", "comm", "ib", "ims", "sd", "ar", "sym", "settings", "gs", "sts", "ex", "changes", "g", "sv", "args", "ses", "sam", "bs", "js", "ss", "conf", "ops", "e", "sb", "sc", "ls", "app", "states", "mp", "am", "sq", "spec", "sl", "qs", "a", "rs", "as", "sub", "f", "l", "bm", "i", "ts", "n", "sw", "ns", "rest", "ds", "p", "sim", "ps", "mg", "us", "aws", "is", "series", "S", "its", "j", "v", "h", "stats", "fs", "sys", "parts"], "mb": ["ms", "mm", "em", "xb", "m", "jpg", "bound", "im", "eb", "irm", "b", "cmd", "kb", "bd", "orb", "ib", "memory", " MB", "arb", "mx", "rb", "bl", "job", "brain", "nob", "um", "sv", "mn", "bs", "emb", "sb", "ym", "mor", "ob", "mp", "byte", "iam", "ml", "amb", "norm", "bf", "orm", "nm", "ghost", "bp", "mar", "GB", "sm", "bm", "tab", "mem", "mc", "sh", "mob", "sbm", "bb", "gb", "db", "vm", "mt", "ebin", "embed", "BM", "sim", "fm", "mg", "members", "ab", "md", "pb", "v", "umb", "shape", "MB", "meg", "mop"], "mb_x": ["emb__wx", "mb__wx", "emb__x", "emb_ex", "emb__ex", "mb_width", "emb_y", "emb_wx", "mb_ex", "emb_z", "mb__y", "emb_x", "mb_z", "mb_wx", "emb_width", "emb__y", "MB_t", "MB_tx", "MB_y", "mb_t", "mb__ex", "mb__x", "MB_x", "mb_tx"], "mb_y": ["mb08x", "mb08y", "MB_yy", "mb8z", "mb8y", "mb08z", "mb_z", "mb_yy", "mb08yy", "mb8yy", "MB_y", "MB_x", "mb8x", "MB_z"], "segment": ["gement", "asegments", "ement", "asement", "segn", "SEgest", "vegn", " segn", "seagement", "segement", " segments", "schegent", "SEment", "sega", "schegment", "schegement", "seagest", " semission", " sement", " sega", "pegments", "asegment", "schegest", "legan", " segement", "tegment", "vegment", " segan", "gegment", "asegement", "pement", "lemission", "segm", "gegments", "pegn", "tegent", "SEgment", "vegments", "vemission", "tega", "lement", "schegments", "seagment", "seament", "pegm", "sement", "gega", "vegm", "legment", "vement", "semission", "segent", " segm", "egments", "segan", "egment", "pega", "schement", "egement", "vegan", "schega", " segent", "segments", "segest", "vega", "pegment", "tegments", "SEgement"], "ref": ["col", "page", "ef", "id", "map", "part", "bf", "buffer", "cmp", "req", "nav", "range", "p", "seq", "f", "rev", "g", "pos", "REF", "block", "inter", "tab", "parent", "raw", "term", "reference", "mem", "index", "Ref", "alt", "rel", "row", "snap", "br", "through", "pb", "reg", "conf", "physical", "remote", "b", "rt", "re", "tag", "diff", "link", "phys", "full", "only", "offset", "af"], "layout": ["tm", "delay", "display", "id", "draw", "board", "config", "Layout", "padding", "layer", "format", "settings", "join", "range", "height", "frame", "slot", " Layout", "location", "label", "def", "position", "flow", "loop", "params", "none", "scroll", "level", "lag", "margin", "mode", "lc", "shape", "scale", "lay", "phys", "density", "offset", "template", "style", "mt"], "c": ["u", "con", "cus", "a", "ch", "at", "ct", "p", "ec", "f", "cp", "cf", "bc", "dc", "xc", "g", "d", "cs", "l", "tc", "m", "cd", "cb", "unc", "cc", "cpp", "ce", "r", "cont", "chain", "n", "mc", "t", "ac", "ctx", "rc", "lc", "v", "conf", "gc", "e", "cache", "b", "cn", "com", "h", "uc", "cm", "w", "nc", "cu", "fc", "sc", "context", "C", "co", "cv", "vc", "ca"], "ref_frame": ["orig_range", "ref_block", "ref_range", "origpoblock", "refpostate", "refpoframe", "orig_state", "origpoframe", "refpoblock", "orig_block", "origporange", "ref_state", "orig_frame", "refporange", "origpostate"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)\n\n{\n\n    uint32_t op;\n\n\n\n    /* make sure instructions are on a halfword boundary */\n\n    if (ctx->pc & 0x1) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        ctx->bstate = BS_STOP;\n\n        return 2;\n\n    }\n\n\n\n    op = (ctx->opcode >> 10) & 0x3f;\n\n    /* Enforce properly-sized instructions in a delay slot */\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;\n\n\n\n        switch (op) {\n\n        case POOL32A:\n\n        case POOL32B:\n\n        case POOL32I:\n\n        case POOL32C:\n\n        case ADDI32:\n\n        case ADDIU32:\n\n        case ORI32:\n\n        case XORI32:\n\n        case SLTI32:\n\n        case SLTIU32:\n\n        case ANDI32:\n\n        case JALX32:\n\n        case LBU32:\n\n        case LHU32:\n\n        case POOL32F:\n\n        case JALS32:\n\n        case BEQ32:\n\n        case BNE32:\n\n        case J32:\n\n        case JAL32:\n\n        case SB32:\n\n        case SH32:\n\n        case POOL32S:\n\n        case ADDIUPC:\n\n        case SWC132:\n\n        case SDC132:\n\n        case SD32:\n\n        case SW32:\n\n        case LB32:\n\n        case LH32:\n\n        case DADDIU32:\n\n        case LWC132:\n\n        case LDC132:\n\n        case LD32:\n\n        case LW32:\n\n            if (bits & MIPS_HFLAG_BDS16) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        case POOL16A:\n\n        case POOL16B:\n\n        case POOL16C:\n\n        case LWGP16:\n\n        case POOL16F:\n\n        case LBU16:\n\n        case LHU16:\n\n        case LWSP16:\n\n        case LW16:\n\n        case SB16:\n\n        case SH16:\n\n        case SWSP16:\n\n        case SW16:\n\n        case MOVE16:\n\n        case ANDI16:\n\n        case POOL16D:\n\n        case POOL16E:\n\n        case BEQZ16:\n\n        case BNEZ16:\n\n        case B16:\n\n        case LI16:\n\n            if (bits & MIPS_HFLAG_BDS32) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    switch (op) {\n\n    case POOL16A:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));\n\n            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));\n\n            uint32_t opc = 0;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case ADDU16:\n\n                opc = OPC_ADDU;\n\n                break;\n\n            case SUBU16:\n\n                opc = OPC_SUBU;\n\n                break;\n\n            }\n\n\n\n            gen_arith(ctx, opc, rd, rs1, rs2);\n\n        }\n\n        break;\n\n    case POOL16B:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs = mmreg(uMIPS_RS(ctx->opcode));\n\n            int amount = (ctx->opcode >> 1) & 0x7;\n\n            uint32_t opc = 0;\n\n            amount = amount == 0 ? 8 : amount;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case SLL16:\n\n                opc = OPC_SLL;\n\n                break;\n\n            case SRL16:\n\n                opc = OPC_SRL;\n\n                break;\n\n            }\n\n\n\n            gen_shift_imm(ctx, opc, rd, rs, amount);\n\n        }\n\n        break;\n\n    case POOL16C:\n\n        gen_pool16c_insn(ctx, is_branch);\n\n        break;\n\n    case LWGP16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = 28;            /* GP */\n\n            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case POOL16F:\n\n        if (ctx->opcode & 1) {\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            /* MOVEP */\n\n            int enc_dest = uMIPS_RD(ctx->opcode);\n\n            int enc_rt = uMIPS_RS2(ctx->opcode);\n\n            int enc_rs = uMIPS_RS1(ctx->opcode);\n\n            int rd, rs, re, rt;\n\n            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };\n\n            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };\n\n            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };\n\n\n\n            rd = rd_enc[enc_dest];\n\n            re = re_enc[enc_dest];\n\n            rs = rs_rt_enc[enc_rs];\n\n            rt = rs_rt_enc[enc_rt];\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);\n\n        }\n\n        break;\n\n    case LBU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n            offset = (offset == 0xf ? -1 : offset);\n\n\n\n            gen_ld(ctx, OPC_LBU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LHU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_ld(ctx, OPC_LHU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LW16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SB16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_st(ctx, OPC_SB, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SH16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_st(ctx, OPC_SH, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SW16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case MOVE16:\n\n        {\n\n            int rd = uMIPS_RD5(ctx->opcode);\n\n            int rs = uMIPS_RS5(ctx->opcode);\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n        }\n\n        break;\n\n    case ANDI16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n", "idx": 10504, "substitutes": {"env": ["ef", "ah", "pe", "et", "config", "ei", "ee", "eh", "err", "manager", "enc", "ev", "erd", "proc", "ec", "buf", "dev", "te", "ptr", "her", "ep", "vt", "en", "equ", "ew", "eg", "esc", "conn", "v", "conf", "environment", "e", "sb", "eu", "er", "estate", "org", "context", "param", "ner", "viron"], "ctx": ["warn", "ck", "xp", "config", "prefix", "ct", "func", "kt", "ctl", "stack", "cc", "util", "check", "wcs", "cmd", "kb", "nc", "org", "context", "cv", "history", "conv", "tx", "cmp", "ctrl", "document", "init", "ind", "bc", "jp", "gz", "xs", "utils", "txt", "that", "conn", "conf", "setup", "cm", "sc", "work", "jac", "obj", "abc", "crit", "req", "resp", "cp", "nt", "iat", "scope", "tc", "timeout", "mem", "index", "mc", "px", "cn", "anc", "exec", "hw", "mom", "loc", "cl", "cf", "xc", "act", "pkg", "np", "wx", "cb", "today", "cfg", "gc", "shape", "wp", "kw", "cu", "x", "co", "tz", "sys"], "is_branch": ["is_brag", "is_balanch", "is_BRarc", "is_balranch", "is_brranch", "is_blanch", "is_blarc", "is_balag", "is_BRanch", "is_BRag", "is_blranch", "is_BRranch", "is_balarc", "is_blag", "is_brarc"], "op": ["oc", "xp", "oop", "ipp", "typ", "tp", "cmp", "arp", "pat", " cop", "sci", "pp", "gp", "up", " ip", "or", "iop", "p", "sp", "o", "rep", "cp", "omp", "ok", "iat", "ip", "hop", "pop", "opl", "jp", "ap", "pos", "osp", "type", "i", "oper", "ic", "ope", "bit", "Op", "top", "ype", "ops", "OP", "os", "comp", "yp", "pol", "rop", "cop", "ot", "operator", "opt", "mop"]}}
{"project": "FFmpeg", "commit_id": "ccb76ad91f2b97009b06c22ae1b2e0234dbf26ca", "target": 0, "func": "static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)\n\n{\n\n    int i;\n\n    int vlc    = get_bits1(&q->gb);\n\n    int start  = cplband[p->js_subband_start];\n\n    int end    = cplband[p->subbands - 1];\n\n    int length = end - start + 1;\n\n\n\n    if (start > end)\n\n        return;\n\n\n\n    if (vlc)\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);\n\n}\n", "idx": 10513, "substitutes": {"q": ["quer", "ck", "eq", "sq", "tx", "qq", "qs", "ch", "pp", "quit", "Q", "req", "gm", "iq", "k", "ve", "f", "cp", "ry", "g", "pkg", "qa", "qt", "r", "j", "question", "dq", "y", "t", "ctx", "qu", "conn", "v", "info", "conf", "self", "qi", "c", "query", "h", "quote", "w", "requ", "z", "comm", "quest", "aq"], "p": ["op", "pc", "tp", "pe", "part", "at", "pp", "pt", "bp", "sp", "post", "rep", "f", "cp", "ps", "fp", "pg", "d", "ip", "g", "jp", "m", "pkg", "ap", "vp", "np", "press", "local", "lp", "pm", "j", "pb", "P", "t", "v", "pl", "os", "b", "wp", "c", "h", "pro", "w", "dp", "er", "att", "s", "app", "pre", "pa"], "decouple_tab": ["decouple_ab", "decoupleBtab", "decouple2table", "decurry_trans", "decour_tab", "decrue_table", "decouple2port", "decrue_tab", "decouple_cart", "decour_cart", "decouple2tab", "decouple_trans", "decour_table", "decrue_port", "decurry_bag", "decurry_ab", "decouple_abs", "decouple_port", "decouple_bag", "decoupleBabs", "decoupleBtable", "decouple2Tab", "decouple_table", "decrue_Tab", "decoupleBcart", "decour_abs", "decouple_Tab", "decurry_tab"], "i": ["ms", "ami", "id", "ai", "I", "io", "me", "PI", "li", "ei", "init", "print", "iq", "span", "sim", "ind", "ui", "ni", "this", "ip", "g", "m", "l", "client", "ki", "ti", "ic", "cli", "in", "us", "mi", "is", "chain", "series", "im", "ix", "ski", "y", "t", "ci", "iu", "\u0438", "zi", "v", "phi", "xi", "gu", "qi", "multi", "c", "gi", "di", "bi", "start", "ij", "cgi", "pi", "si", "it", "x", "batch", "ini", "oi", "ji", "ims", "ii"]}}
{"project": "FFmpeg", "commit_id": "d1f3e475f9807b445ba37ff2fd23f71c4645de79", "target": 1, "func": "static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n", "idx": 10520, "substitutes": {"pkt": [" packet", "pnt", "ppnt", "placket", "cpacket", "Pst", "prkt", "ppkt", "pst", "Pnt", "ppck", "Pcmd", " pkg", " pst", " preq", "Preq", "spact", "Pkt", "cpnt", "pkg", "preq", " pcmd", "pracket", "plck", "met", " pnt", " pck", "cpct", " pet", "spet", "prst", "pck", "mkt", "packet", " pact", " pct", "spkt", "ppct", "ppacket", "perreq", "mact", "spkg", "cpkt", "pcmd", "prnt", "pact", "pet", "Packet", "plkt", "percmd", "peracket", "pct", "perkt", "mkg"], "pkt_data": ["pnt_def", "pnt_data", "pck_Data", "pck2Data", "pck2data", "pkt2Data", "pck_no", "pnt_dat", "pck_cache", "pkt_def", "pck_data", "pnt_map", "pkt_dat", "pkt2cache", "pkt_map", "pck2cache", "pck2no", "pkt2data", "pkt_cache", "pkt2no", "pkt_Data", "pkt_no"], "pts": ["posls", "ptruts", " cmdts", "ptxs", "pls", "poss", "aptts", "aptxs", "ntds", "plls", " ptts", "posxs", "ptls", " ptTs", "ptts", "points", "pointts", "ntts", "aptls", " ptrts", "ptps", "ptrds", " ptps", "posts", " cmdTs", "nts", "ntuts", " cmdps", "ptTs", "apts", "pointds", "ptrts", "ptds", " ptrs", "ptrs", " ptrTs", "pointuts", " ptrps", "plxs", "plts", "ptuts", " cmds"], "ret": ["len", "tr", "pas", " RET", "status", "et", "flag", "print", "det", "RET", "resp", "nt", "rev", "l", "ref", "mt", "after", " alt", "txt", "usr", "alt", "ter", "mem", "r", "cont", "j", "final", "t", "rets", "deg", "val", "Ret", "xt", "rt", "re", "elt", "res", "result", "set", "gt", "ft", "out"], "data": ["doc", "len", "art", "empty", "xy", "Data", "extra", "al", "map", "id", "buffer", "text", "message", "read", "format", "image", "and", "list", "valid", "p", "error", "bin", "nt", "da", "d", " DATA", "m", "ata", "def", "type", "raw", "window", "bytes", "json", "partial", "mu", "all", "mem", "details", "rel", "content", "row", "done", "n", "ATA", "body", "t", "new", "bus", "info", "aw", "good", "cache", "any", "dat", "rew", "results", "str", "options", "table", "result", "DATA", "name", "size", "out"]}}
{"project": "FFmpeg", "commit_id": "54b2d317ed99622efa07b10aca217e1a083105d9", "target": 0, "func": "static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){\n\n    int i,j,k,m;\n\n    double l2tab[256];\n\n\n\n    for(i=1; i<256; i++)\n\n        l2tab[i]= log2(i/256.0);\n\n\n\n    for(i=0; i<256; i++){\n\n        double best_len[256];\n\n        double p= i/256.0;\n\n\n\n        for(j=0; j<256; j++)\n\n            best_len[j]= 1<<30;\n\n\n\n        for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){\n\n            double occ[256]={0};\n\n            double len=0;\n\n            occ[j]=1.0;\n\n            for(k=0; k<256; k++){\n\n                double newocc[256]={0};\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        len -=occ[m]*(     p *l2tab[    m]\n\n                                      + (1-p)*l2tab[256-m]);\n\n                    }\n\n                }\n\n                if(len < best_len[k]){\n\n                    best_len[k]= len;\n\n                    best_state[i][k]= j;\n\n                }\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        newocc[    one_state[    m]] += occ[m]*   p ;\n\n                        newocc[256-one_state[256-m]] += occ[m]*(1-p);\n\n                    }\n\n                }\n\n                memcpy(occ, newocc, sizeof(occ));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10539, "substitutes": {"best_state": ["best_index", "selected_state", "orst_states", "bestipstate", "bestacstate", "bestipint", "bestvalpoint", "orst_state", "selected_index", "orst_int", "bestipstates", "bestvalindex", "bestacstates", "bestipnode", "bestvaltag", "bestvalstate", "best_tag", "selected_point", "bestacint", "bestacnode", "best_states", "orst_node", "best_point", "best_int", "best_node", "selected_tag"], "one_state": ["nodeplacestates", "one_size", "nodeplacestatus", "node_states", "oneplacestate", "nodeplacegroup", "oneplacegroup", "one_status", "oneplacestatus", "one_resource", "one___states", "node_status", "ome_state", "nodeplacestate", "one_states", "one_slice", "ome_resource", "ome_states", "node_group", "one___status", "oneplacestates", "node_state", "one___group", "ome_size", "one_group", "one___state", "one_job"], "i": ["u", "ie", "api", "print", "im", "y", "ci", "zi", "b", "gi", "pi", "oi", "hi", "ji", "ims", "ami", "I", "at", "li", "init", "ri", "ind", "g", "jp", "um", "ki", "ti", "ia", "mi", "try", "ix", "xi", "e", "multi", "qi", "si", "id", "ai", "ei", "f", "ui", "ip", "l", "ic", "in", "index", "n", "phi", "info", "start", "by", "it", "ini", "ii", "me", "io", "p", "this", "json", "cli", "is", "iu", "v", "ik", "di", "bi", "x", "ij"], "j": ["jac", "key", "je", "obj", "bj", "be", "tr", "ge", "aj", "ja", "jump", "J", "jc", "at", "u", "index", "li", "jo", "q", "p", "sp", "job", "bl", "o", "jit", "ind", "kid", "g", "jp", "l", "note", "block", "let", "bs", "json", "jj", "r", "try", "js", "uj", "br", "im", "n", "y", "jas", "jl", "v", "bo", "fr", "pr", "ion", "b", "lock", "h", "bi", "str", "adj", "oj", "next", "er", "by", "it", "z", "dj", "no", "ji", "kj", "out", "ij"], "k": ["key", "kr", "ck", "ko", "kick", "K", "q", "tk", "ak", "wk", "kt", "kan", "p", "an", "kid", "ku", "ok", "ark", "ki", "kind", "ka", "unk", "kl", "n", "y", "kn", "v", "ik", "mk", "uk", "c", "ke", "kh", "ijk", "kw", "ks", "z", "km", "ek", "kj", "sk", "kk"], "m": ["tm", "ms", "on", "mm", "em", "span", "o", "d", "arm", "month", "r", "im", "y", "t", "rem", "b", "rm", "hm", "mx", "gm", "wm", "g", "um", "mn", "mod", "mi", "M", "ym", "member", "cm", "z", "dm", "am", "min", "nm", "mat", "f", "sm", "l", "bm", "mr", "mask", "met", "mem", "n", "mc", "perm", "mk", "mid", "om", "mut", "module", "vm", "mt", "len", "num", "me", "q", "p", "an", "fm", "mo", "all", "md", "pm", "v", "c", "h", "mac", "km", "dr", "lem"], "l2tab": ["l3Tab", "l10Tab", "d2tab", "l4Tab", "l1ab", "l2lab", "l3tab", "l02lab", "l2ab", " l2ab", "l4ctrl", "l1ctl", "l10tab", " l1ab", " l2Tab", "l10ctr", "l4ctr", "l36Tab", " l3ab", "l2Tab", "d2ctrl", "d4Tab", "l10ab", "l36stab", "l3ab", " l3tab", "d2stab", "d2Tab", "l2ctr", "l022ab", "l022Tab", "d4stab", "l02ab", " l4ab", "l022tab", "l1ctr", " l2lab", " l1lab", "l02Tab", " l4ctr", "l2ctrl", "l36tab", "l2ctl", "l1ctrl", "l1lab", "l4ab", " l1tab", "l4tab", " l1Tab", "l3ctl", " l4tab", "l4lab", " l2ctr", "l02tab", "l1tab", " l4Tab", "l2stab", " l3Tab", "d4tab", "l36ctrl", "l022ctl", " l2ctl", "d4ctrl", "l1stab", "l4stab", "l1Tab", " l3ctl"], "best_len": ["best5state", " best_length", "best_length", " best2state", "best__state", "best_compl", "best2length", "best5Len", "best_size", "best2Len", " best_Len", "better_val", "best_dist", "best_val", "best_Len", "best_den", "best2val", "best5len", "best__size", "better_compl", "better_den", "better_len", "better_dist", "better_size", "best2len", "best__val", "better_Len", "best5length", " best2Len", "better_state", "best__len", "best2compl", " best2len", "best2state", " best2length"], "occ": ["inc", "usc", "each", "config", "mult", "or", "proc", "rec", "eor", "cc", "rox", "rd", "pl", "alph", "cre", "times", "nc", "ocr", "org", "result", "aug", "ll", "arr", "fl", "rown", "cor", "ec", "circ", "sec", "mu", "cal", "ac", "oe", "ob", "roc", "fre", "oc", "acc", "cum", "abc", "err", "resp", "cur", "rn", "design", "fe", "ffe", "mc", "inf", "exc", "loc", "cons", "obs", "con", "ords", "seq", "cf", "ok", "opl", "ord", "cont", "clus", "coll", "comb", "ctr", "Occ", "ro", "give", "fc", "coord", "buff", "co"], "newocc": ["Neworg", "oldorg", "newcirc", "oldrec", " newcirc", "newcur", "NEWocc", "newOcc", "oldinc", "NewOcc", "createOcc", "createfe", "Newfe", " newinc", "Newrec", "oldOcc", "Newinc", "NEWrec", "NEWOcc", " newcur", "Newocc", "newfe", " newOcc", " neworg", " newrec", "Newcirc", "createrec", "newrec", " newfe", "oldcirc", "oldocc", "Newcur", "NEWcur", "createocc", "neworg", "newinc"]}}
{"project": "FFmpeg", "commit_id": "ff486c0f7f6b2ace3f0238660bc06cc35b389676", "target": 0, "func": "static int get_pcm(HEVCContext *s, int x, int y)\n\n{\n\n    int log2_min_pu_size = s->sps->log2_min_pu_size;\n\n    int x_pu             = x >> log2_min_pu_size;\n\n    int y_pu             = y >> log2_min_pu_size;\n\n\n\n    if (x < 0 || x_pu >= s->sps->min_pu_width ||\n\n        y < 0 || y_pu >= s->sps->min_pu_height)\n\n        return 2;\n\n    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];\n\n}\n", "idx": 10547, "substitutes": {"s": ["ms", "sq", "vs", "ares", "qs", "gets", "ats", "a", "rs", "hs", "p", "gs", "sts", "ps", "g", "cs", "m", "ains", "ins", "es", "sv", "ses", "sam", "bs", "aws", "r", "less", "is", "js", "S", "ss", "ts", "n", "details", "t", "its", "v", "conf", "self", "ops", "e", "os", "sb", "b", "c", "sw", "h", "sa", "ns", "w", "fs", "comm", "ls", "ims", "ds", "parts"], "x": ["xp", "xy", "tx", "mx", "a", " cx", "p", "ex", "ox", "dx", "xc", "xd", "m", "l", "wx", "X", "i", "xs", "inx", "rx", "ix", "px", "v", "xi", "xt", "sw", "h", "w", "xx", "yx", "xml", "ax", "fx", "el", "xe", "xf"], "y": ["key", "py", "yt", "xy", "axy", "sky", "ty", "ch", "vy", "yy", "yi", "wy", "p", "height", "ay", "ry", "g", "oy", "my", "ies", "i", "ye", "iny", "j", "t", "Y", "v", "ey", "b", "ly", "uy", "ery", "sy", "gy", "fy", "h", "iy", "by", "z", "ny", "cy"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int h264_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    int ret;\n\n    const uint8_t *new_extradata;\n\n    int new_extradata_size;\n\n\n\n    h->flags = avctx->flags;\n\n    h->setup_finished = 0;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\nout:\n\n    if (buf_size == 0) {\n\n        H264Picture *out;\n\n        int i, out_idx;\n\n\n\n        h->cur_pic_ptr = NULL;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f->key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            ret = output_frame(h, pict, out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n\n\n    new_extradata_size = 0;\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n\n                                            &new_extradata_size);\n\n    if (new_extradata_size > 0 && new_extradata) {\n\n        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,\n\n                                       &h->ps, &h->is_avc, &h->nal_length_size,\n\n                                       avctx->err_recognition, avctx);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size);\n\n    if (buf_index < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        buf_size = 0;\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            return 0;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        ff_h264_field_end(h, &h->slice_ctx[0], 0);\n\n\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||\n\n                                   h->next_output_pic->recovered)) {\n\n            if (!h->next_output_pic->recovered)\n\n                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;\n\n\n\n            ret = output_frame(h, pict, h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    }\n\n\n\n    assert(pict->buf[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 10554, "substitutes": {"avctx": ["avetmp", " avcp", "navcontext", "vrkw", " avhandle", " avcontext", "avepkg", "ajjac", "ajcfg", " avtmp", "avecfg", "avecontext", " avcb", " avproc", " avpkg", "avhandle", "vrsetup", "avcp", "ajpkg", "navctx", "avcb", "avproc", "avcontext", "navcb", "vrctx", "savcontext", " avkw", "avercontext", "averhandle", "averkw", "aversetup", "navtmp", "savproc", "ajhandle", "ajctx", " avsetup", "aveproc", "avectx", "avkw", "savcp", " avcfg", "avecb", "avsetup", "averctx", "avtmp", " avjac", "savctx", "vrcontext", "avecp", "averjac", "avjac", "avcfg", "avpkg", "ajcontext"], "data": ["doc", "obj", "Data", "empty", "pic", "next", "png", "pat", "record", "buffer", "text", "message", "a", "padding", "format", "image", "read", "picture", "form", "p", "value", "f", "bin", "frame", "pad", "d", "size", "act", "media", "images", "ata", "def", "raw", "window", "bytes", "video", "content", "rel", "snap", "body", "t", "ctx", "intel", "feed", "feat", "action", "input", "dat", "str", "res", "batch", "img", "DATA", "name", "offset", "length"], "got_frame": ["Got_frame", "got___frame", "fetched_fr", "got___channel", "got_frames", "got_channel", "got___fr", "fetched_frames", "got_Frame", "got_event", "fetched___frame", "Got_point", "fetched___channel", "Got_event", "Got_Frame", "got___frames", "fetched_frame", "fetched___frames", "fetched___fr", "fetched_channel", "got_fr", "got_point"], "avpkt": ["avpacket", "avpackct", "avcpct", "avcompacket", "avcptt", "afpkt", " avpmsg", "avopkt", " avpmit", "avPkt", "avopmsg", "avpackett", "afopnt", "afopkt", " avcpkt", " avpet", "avPet", "avopnt", "avcpdt", "avpmit", "avcpet", " avptt", "avdmit", "avopdt", " avcpqt", "avcpqt", " avopacket", "afpnt", "avcpacket", "avppnt", "avpnt", "avPtt", " avpacket", "avcpnt", "avopmit", "avpmsg", "avppkt", " avPett", "avcpkt", "avdacket", " avopmsg", "afpdt", "avpadkt", "avPacket", "avptt", "afpacket", "avpett", " avpct", "avpadmit", "avpdt", " avpett", " avopmit", "avcompkt", "avpackkt", " avcpet", "avopacket", "avPct", " avPct", "avdmsg", "avppdt", "avcompet", " avpqt", "avcpett", "avpacktt", "afopdt", " avcpacket", " avPtt", "avpadacket", "avppacket", "avpqt", "avPqt", "avdkt", "avcompqt", "avpct", "avPett", " avPkt", " avopkt", "avpadmsg", "avpet", "afopacket"], "buf": ["arr", "doc", "buffer", "uf", "cam", "err", "p", "seq", "vec", "np", "ref", "cb", "ptr", "raw", "txt", "mem", "br", "cap", "ctx", "v", "b", "tmp", "cmd", "dat", "buff", "msg", "cv", "img"], "h": ["hal", "he", "H", "ah", "hm", "tx", "hr", "ph", "gh", "ch", "hook", "q", "eh", "here", "go", "HH", "end", "k", "hs", "p", "hash", "o", "f", "this", "th", "g", "l", "m", "hd", "hl", "oh", "hh", "handle", "mem", "hp", "http", "j", "y", "t", "ctx", "phi", "v", "uh", "info", "ha", "self", "rh", "cache", "host", "b", "c", "sh", "bh", "kh", "hw", "w", "ih", "help", "his", "it", "hi", "dh", "s", "history", "hz", "ht"], "pict": ["png", "pic", "Pic", "pas", "fi", "avi", "fig", "cam", "pdf", "picture", "kt", "p", "act", "np", "capt", "pit", "txt", "Pict", "fn", " feat", "phy", "shit", "ctx", "photo", "info", "feat", "qi", "ot", " pic", "piece", "phys", "camera", "buff", "Picture", "lot", "img", "ht"], "ret": ["len", "tr", "lit", "reset", "net", "et", "at", "back", "err", "print", "det", "nz", "RET", "resp", "over", "gov", "reply", "ry", "nt", "response", "rev", "del", "ref", "fun", "mt", "def", " Ret", "after", "usr", "alt", "ter", "plain", "try", "r", "cont", "t", "rem", "rets", "reg", "deg", "not", "backed", "gc", "val", "Ret", "red", "cmd", "rt", "re", "elt", "res", "ber", "it", "rm", "result", "att", "gt", "ll", "ft", "dr"], "new_extradata": ["new_exracaton", "new_extracata", "new_extracaton", "new_extradaton", "new_extredata", "new_exraddata", "new_extradATA", "new_extrecata", "new_exradaton", "new_extraraton", "new_extrecaton", "new_interrecdata", "new_extrdata", "new_exradata", "new_exracdata", "new_interraddata", "new_exreddata", "new_extrarATA", "new_extrATA", "new_interrecata", "new_extrandata", "new_exredata", "new_exredaton", "new_interradaton", "new_extrata", "new_extraton", "new_interrecaton", "new_extredATA", "new_exracata", "new_interradATA", "new_extraddata", "new_interrecATA", "new_interradata", "new_exredATA", "new_exracATA", "new_extrecATA", "new_extrandATA", "new_extreddata", "new_extracATA", "new_extrandaton", "new_extrecdata", "new_exradATA", "new_extredaton", "new_extracdata", "new_extranddata", "new_extrarata", "new_extrardata"], "new_extradata_size": ["new_extradatum_len", "new_extradata_name", "new_extradata2name", "new_extradata_max", "new_extradatum_size", "new_extradatum_space", "new_extraddata_size", "new_extradata_SIZE", "new_extradATA_SIZE", "new_extraddata_offset", "new_extradata_Size", "new_extradata_offset", "new_extradatum_Size", "new_extradata_len", "new_extraddata_Size", "new_extradATA_name", "new_extradATA_Size", "new_extradATA_size", "new_extradata2SIZE", "new_extradata2size", "new_extradata2Size", "new_extradATA_max", "new_extradata_count", "new_extraddata_SIZE", "new_extradATA_count", "new_extradata_space"], "out": ["chan", "update", "cam", "end", "o", "OUT", "again", "t", "check", "b", "cmd", "ot", "w", "ent", "opt", "result", "conv", "ht", "vol", "output", "status", "at", "aos", "init", "bool", "ex", "g", "outs", "null", "after", "ou", "txt", "that", "video", "new", "one", "conn", "conf", "no", "img", "obj", "png", "pic", "ch", "image", "err", "go", "file", "point", "f", "error", "timeout", "in", "n", "ctx", "tmp", "from", "can", "it", "off", "to", "p", "client", "tif", "Out", "all", "j", "v", "not", "cfg", "cache", "c", "res", "help", "co"], "i": ["u", "span", "m", "them", "im", "y", "t", "ci", "zi", "gi", "cgi", "iy", "pi", "slice", "oi", "hi", "ji", "ims", "ami", "status", "record", "I", "li", "uri", "init", "ri", "ind", "ni", "g", "ki", "ti", "mi", "try", "ix", "xi", "multi", "qi", "e", "si", "batch", "id", "ai", "ei", "go", "k", "point", "f", "ui", "ip", "my", "ic", "in", "index", "chain", "n", "mc", "\u0438", "phi", "info", "gu", "remote", "it", "ini", " bi", "ii", "me", "io", "q", "to", "p", "sim", "cli", "is", "j", "iu", "di", "bi", "x", " ii", " j", "ij"], "out_idx": ["out_Idx", "out_Idix", "out_midz", "out_idv", "out_endy", "out_Idy", "out_dbix", "out_midx", "out_endx", "out_midxs", "out_idix", "out_inz", "out_Idex", "out_sidv", "out_idy", "out_idc", "out_endz", "out_dbx", "out_idex", "out_sidxs", "out_Idc", "out_idxs", "out_inx", "out_idz", "out_Idz", "out_dbex", "out_inex", "out_iny", "out_endex", "out_midv", "out_midix", "out_dbc", "out_midy", "out_sidx", "out_sidz"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)\n\n{\n\n    if (bin < 7) {\n\n        if ((b0 + 256) == b1)\n\n            a = 384;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else if (bin < 20) {\n\n        if ((b0 + 256) == b1)\n\n            a = 320;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else {\n\n        a = FFMAX(0, a - 128);\n\n    }\n\n\n\n    return a;\n\n}\n", "idx": 10556, "substitutes": {"a": ["na", "la", "u", "ao", "o", "d", "m", "fa", "data", "y", "t", "b", "sa", "w", "result", "aa", "ar", "era", "at", "va", "au", "aaa", "g", "ia", "ea", "qa", "ta", "ga", "ma", "alpha", "ac", "e", "A", "sta", "z", "xa", "aq", "am", "acc", "abc", "err", "as", "area", "ae", "l", "ap", "i", "trace", "ava", "sha", "action", "from", "oa", "out", "ca", "ba", "off", "aj", "aka", "to", "p", "an", "da", "act", "ata", "ab", "all", "wa", "j", "v", "c", "aaaa", "h", "apa", "pa"], "b0": ["v1", "biskg", "wb0", "bg140", "bops", "obj000", "gbZero", "nameZero", "gb195", "embfunc", "bma", "y0", "b195", "emb000", "bgkg", "name0", "bin1", "binma", "vma", "val0", "bg3", "bis000", "bb3", "valable", "bb000", "bin140", "yma", "bZero", "wb9", "bin3", "bin0", "gb9", "b9", "embable", "gb0", "y1", "wbZero", "name9", "b000", "vops", "bi000", "name195", "bb140", "b140", "bikg", "objfunc", "bfunc", "bin000", "v0", "biable", "bgable", "bi0", "bisable", "objable", "val000", "bable", "valfunc", "yops", "bg000", "bg0", "obj0", "bis0", "bkg", "b3", "binops", "wb195", "bb0", "emb0"], "b1": ["b64", " b11", "v1", "wb0", "a2", "bb2", "wb2", "bOne", "gb64", "bb1", "wb1", " b3", "ba1", "wb64", "v3", "bb3", "gb11", "b2", "gbOne", "bb64", "gb2", "b9", "a3", "ba2", "v2", " b9", "v0", "b11", "gb3", "a1", "a0", "bbOne", "gb1", "bb9", " b2", "baOne", "bb11", "b3", " b64", "ba64", "v9", "bb0"], "bin": ["on", "len", "num", "inner", "png", "pc", "lib", "ebin", "part", "ran", "or", "obin", "hash", "fun", "bits", "i", "win", "IN", "gin", "bn", "mix", "in", "bit", "ln", "sun", "version", "ix", "n", "box", "comb", "scan", "abin", "big", "class", " bins", "ion", "mon", "b", "un", "bi", "rin", "pin", "by", "nb", "border", "tar", "pack", "spin", " Bin", "gain", "byte", "size", "binary"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n                                      long width, long height,\n\n                                      long lumStride, long chromStride, long srcStride)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y+=2) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \"pcmpeqw                 %%mm7, %%mm7       \\n\\t\"\n\n            \"psrlw                      $8, %%mm7       \\n\\t\" // FF,00,FF,00...\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(4)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // U0V0 U0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // UVUV UVUV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(0)\n\n\n\n            MOVNTQ\"                  %%mm2, (%1, %%\"REG_a\", 2)  \\n\\t\"\n\n\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(12)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq                    %%mm2, %%mm4       \\n\\t\" // YUYV YUYV(12)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // U0V0 U0V0(8)\n\n            \"psrlw                      $8, %%mm2       \\n\\t\" // U0V0 U0V0(12)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm4       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm2, %%mm1       \\n\\t\" // UVUV UVUV(8)\n\n            \"packuswb                %%mm4, %%mm3       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm3, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"movq                    %%mm0, %%mm2       \\n\\t\" // UVUV UVUV(0)\n\n            \"movq                    %%mm1, %%mm3       \\n\\t\" // UVUV UVUV(8)\n\n            \"psrlw                      $8, %%mm0       \\n\\t\" // V0V0 V0V0(0)\n\n            \"psrlw                      $8, %%mm1       \\n\\t\" // V0V0 V0V0(8)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // U0U0 U0U0(0)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // U0U0 U0U0(8)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // VVVV VVVV(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // UUUU UUUU(0)\n\n\n\n            MOVNTQ\"                  %%mm0, (%3, %%\"REG_a\")     \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, (%2, %%\"REG_a\")     \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        __asm__ volatile(\n\n            \"xor                 %%\"REG_a\", %%\"REG_a\"   \\n\\t\"\n\n            \".p2align                    4              \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\" 64(%0, %%\"REG_a\", 4)              \\n\\t\"\n\n            \"movq       (%0, %%\"REG_a\", 4), %%mm0       \\n\\t\" // YUYV YUYV(0)\n\n            \"movq      8(%0, %%\"REG_a\", 4), %%mm1       \\n\\t\" // YUYV YUYV(4)\n\n            \"movq     16(%0, %%\"REG_a\", 4), %%mm2       \\n\\t\" // YUYV YUYV(8)\n\n            \"movq     24(%0, %%\"REG_a\", 4), %%mm3       \\n\\t\" // YUYV YUYV(12)\n\n            \"pand                    %%mm7, %%mm0       \\n\\t\" // Y0Y0 Y0Y0(0)\n\n            \"pand                    %%mm7, %%mm1       \\n\\t\" // Y0Y0 Y0Y0(4)\n\n            \"pand                    %%mm7, %%mm2       \\n\\t\" // Y0Y0 Y0Y0(8)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // YYYY YYYY(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm0,  (%1, %%\"REG_a\", 2) \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n#else\n\n        long i;\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            udst[i]     = src[4*i+1];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n            vdst[i]     = src[4*i+3];\n\n        }\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n        }\n\n#endif\n\n        udst += chromStride;\n\n        vdst += chromStride;\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(EMMS\"       \\n\\t\"\n\n                     SFENCE\"     \\n\\t\"\n\n                     :::\"memory\");\n\n#endif\n\n}\n", "idx": 10564, "substitutes": {"src": ["lb", "tr", "filename", "lib", "syn", "sl", "usc", "source", "rs", "sub", "RC", "rol", "ins", "hl", "chrom", "stack", "usr", "addr", "in", "lat", "ser", "rl", "rx", "dest", "scan", "rc", "sur", "input", "sb", "rect", "sw", "ipl", "ost", "sn", "rt", "inst", "sr", "start", "dist", "st", "origin", "sc", "ur", "strike", "loc", "img", "rid", "sys"], "ydst": ["dyST", "yxstack", "ydSt", "ydbl", "dystart", "ytbl", "bdsta", "ldst", "ldstr", "dyset", "eysten", "dysta", "ytstack", "dyst", "bdset", "eddySt", "eybl", "dystr", "ldset", "bdST", "eddystr", "ytsten", "dySt", "yxst", "bdst", "ldST", "ldsta", "ldstart", "eystack", "eddyst", "ydST", "ydstack", "ydstart", "ydstr", "yxbl", "eyst", "ydset", "ytst", "yxsten", "ydsta", "ldSt", "ydsten", "eddystart"], "udst": ["udnd", "odnd", "udsta", "vdost", "ddsta", "ldsc", "udset", "ldst", "ddost", "udost", "odsc", "vdsta", "ubset", "udsc", "udrc", "upnd", "odrc", "ldrc", "ddset", "uprc", "upst", "ubst", "upsc", "ldnd", "ddst", "ubsta", "vdset", "ubost", "odst"], "vdst": ["vdsc", "vdST", "xdist", "xdST", "hdstop", "vdest", "udstop", "hdist", "hdST", "ovstop", "udest", "udist", "xdst", "udsc", "ovst", "vdist", "ovest", "ovST", "hdest", "vdstop", "xdsc", "hdst", "hdsc", "udST"], "height": ["depth", "he", "H", "gravity", "ty", "resolution", "padding", "build", "ht", "stroke", "hs", "bottom", "graph", "size", "th", "capacity", "window", "wh", "Height", "row", "rows", "count", "radius", "zh", "hei", "shape", "above", "h", "ows", "w", "ih", "density", "max", "history", "high", "length", "inches", "hub"], "lumStride": ["lumsRestr", "lumsStide", "lumsStr", "lumRestride", "lumStrride", "lumFormro", "lumRestide", "lumFormride", "lumRestr", "lumenStride", "lumenStro", "lumenStr", "lumSTride", "lumStrro", "lumenFormro", "lumsStride", "lumStr", "lumsRestro", "lumStrr", "lumsRestride", "lumStro", "lumSTr", "lumFormr", "lumenFormr", "lumsStro", "lumstride", "lumstr", "lumsRestide", "lumRestro", "lumenFormride", "lumStide", "lumSTro", "lumstide", "lumstro"], "chromStride": ["chromRestrip", " chromStrrip", " chromStrd", "chromRestride", "chromSTide", " chromStrip", "chromStrrip", " chromStrride", "chromSTrd", " chromStrrd", "chromStrrd", "chromSTride", "chromStrd", "chromStrip", "chromSTrip", " chromStide", "chromRestrd", "chromStrride", "chromStide", "chromRestide"], "srcStride": ["srcStide", "srcRestrid", "srcStro", "srcStrrid", "srcSTide", "srcStrides", "srcSTides", "srcSTride", "srcRestride", "srcStides", "srcStrro", "srcEstrid", "rcStrides", "srcStrid", "rcStrro", "srcEstride", "rcStro", "chromStrrid", "srcRestause", "srcStrride", "srcRestide", "srcSTro", "chromStause", "srcStause", "rcStides", "rcStride", "srcEstause", "chromStrid", "chromStrride", "chromStide", "srcRestides", "srcRestro", "srcStrause", "rcStide", "rcStrride", "srcEstide", "chromStrause"], "y": ["col", "key", "aily", "py", "yt", "ya", "axy", "sky", "ty", "ch", "vy", "hy", "ady", "yy", "yi", "p", "ay", "yn", " Y", "m", "my", "ies", "dy", "index", "ys", " x", "j", "ley", "t", "yr", "Y", "count", "asy", "ey", "b", "yp", "h", "ym", "gy", "sy", "ly", "w", "iy", "hey", "by", "x", "z", " cy", "yl", "ny", " j", " my", "out", "cy"]}}
{"project": "qemu", "commit_id": "2119882c7eb7e2c612b24fc0c8d86f5887d6f1c3", "target": 0, "func": "static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n\n                                                  const char *name,\n\n                                                  BlockDriverState **pbs,\n\n                                                  AioContext **paio,\n\n                                                  Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvDirtyBitmap *bitmap;\n\n    AioContext *aio_context;\n\n\n\n    if (!node) {\n\n        error_setg(errp, \"Node cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    if (!name) {\n\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    bs = bdrv_lookup_bs(node, node, NULL);\n\n    if (!bs) {\n\n        error_setg(errp, \"Node '%s' not found\", node);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n\n    if (!bitmap) {\n\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n\n        goto fail;\n\n    }\n\n\n\n    if (pbs) {\n\n        *pbs = bs;\n\n    }\n\n    if (paio) {\n\n        *paio = aio_context;\n\n    } else {\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return bitmap;\n\n\n\n fail:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 10583, "substitutes": {"node": ["NAME", "key", "num", "id", "address", "nm", "source", "path", "code", "network", "uri", "device", "image", "hash", "standard", "error", "nt", "normal", "component", "instance", "label", "process", "note", "type", "object", "np", "Node", "desc", "parent", "ref", "kind", "local", "holder", "addr", "server", "none", "index", "oid", "description", "station", "data", "n", "root", "connection", "handler", "fn", "entity", "self", "tree", "primary", "remote", "shape", "host", "production", "tmp", "title", "target", "arn", "peer", "link", "ode", "context", "msg", "odes", "number"], "name": ["NAME", "key", "filename", "id", "nm", "part", "path", "prefix", "code", "names", "base", "named", "file", "nam", "value", "error", "normal", "label", "block", "m", "type", "ame", "local", " Name", "word", "parent", "none", "create", "data", "version", "n", "new", "info", "b", "comment", "title", "ns", "w", "alias", "Name", "no", "size"], "pbs": ["pubs", " pbos", "bns", "pcs", "bbs", "jbos", "Pns", "pbm", " pcs", "pbos", "hbs", "hbm", "pns", "jbm", "Pcs", "pjs", " pbes", " pBS", "jubs", "bcs", " pjs", "hubs", "jbs", "Pjs", "Pbs", "pbes", " pubs", "bBS", "hbos", " pns", " pbm", "bbes", "Pbes", "pBS", "PBS", "bjs"], "paio": ["jac", "oc", "ucc", "arc", "acc", "aco", "ah", "obj", "auc", "con", "cmp", "anti", "oci", "aos", "ct", "aic", "alloc", "ack", "ec", "except", "iat", "act", "cur", "unc", "cc", "cont", "esa", "annot", "cap", "aux", "ac", "ci", "cas", "ctx", "acl", "comp", "anc", "asa", "nc", "cu", "sic", "fc", "sc", "co", "uca", "cv", "ca"], "errp": [" erpun", "rerf", "ererp", " erp", " erpost", "ererping", "illerp", "rerping", "illerpg", " erpoint", " errpa", "diepa", "errorpc", "rrping", "rerp", "errpost", "illerpost", "eorpc", "errorpoint", " errping", "dieping", "eorp", "rrp", "ererpun", "erP", "ererpc", "errpun", "errpc", " erping", "erp", "ererpa", " erP", "ererf", "errpoint", "errorp", "illerpun", "eorpoint", "errping", "ererpre", "diep", "ererpost", "errpa", "errpre", "errpg", "ererpoint", " erpg", "errorpre", "errP", "rrP", "rerpa", "rrpa", "rrpoint", "ererpg", "erping", "rrf", "erpoint", "eorpre", "errf"], "bs": ["abilities", "obs", "aps", "vs", "banks", "acts", "cks", "blocks", "base", "aos", "bp", "rs", "bas", "Bs", "gs", "bl", "bes", "sts", "bles", "ps", "bc", "BS", "cs", "boxes", "outs", "bits", "es", "bys", "bytes", "bing", "uts", "als", "js", "its", "ts", "bos", "pb", "eb", "bps", "lbs", "ubs", "ubis", "sb", "b", "bed", "caps", "bis", "bh", "ns", "stats", "fs", "res", "ks", "bb", "vals", "nos", "gb", "ls", "s", "vers", "hz", "ds"], "bitmap": ["itpack", "BITMap", "blockmap", " bitstream", "BITmap", "bandMAP", "bitmaps", "BITnative", "BITMAP", "blockstream", "bandMap", "itMap", "BitMap", "Bitmap", " bitap", " bitmaps", "Bitmaps", "bytemap", "Bitap", "itmap", " bitnative", "itm", "bitstream", "bitm", "itmaps", "bitMap", "bandnative", " bitpack", "blockmaps", "Bitstream", " bitm", "bytem", "bitpack", "bytepack", "bandmap", " bitMAP", "bitnative", " bitMap", "itap", "bitMAP", "bitap", "byteap"], "aio_context": ["aive_context", "aiol_scope", "aio2resource", "aio_scope", "aio_choice", "aive_support", "aiop_ctx", "aiop_scope", "aio_resource", "aIO_ctx", "aio_status", "aio_mask", "aive_Context", "aiop_context", "aIO_Context", "aIO_resource", "aive_mask", "aio_ctx", "aio___support", "aIO_status", "aIO_context", "aio2ctx", "aive_ctx", "aio_cache", "aiol_choice", "aive_document", "aio___Context", "aiop_cache", "aio___context", "aio2context", "aio_document", "aiooctx", "aio_Context", "aio_request", "aiol_request", "aioodocument", "aio___mask", "aive_scope", "aiooscope", "aio2status", "aioocontext", "aiol_context", "aio_support"]}}
{"project": "qemu", "commit_id": "446f16a6906e9d05aa9ce0dde727d4f731a89298", "target": 1, "func": "void ppce500_init(MachineState *machine, PPCE500Params *params)\n\n{\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    PCIBus *pci_bus;\n\n    CPUPPCState *env = NULL;\n\n    uint64_t loadaddr;\n\n    hwaddr kernel_base = -1LL;\n\n    int kernel_size = 0;\n\n    hwaddr dt_base = 0;\n\n    hwaddr initrd_base = 0;\n\n    int initrd_size = 0;\n\n    hwaddr cur_base = 0;\n\n    char *filename;\n\n    hwaddr bios_entry = 0;\n\n    target_long bios_size;\n\n    struct boot_info *boot_info;\n\n    int dt_size;\n\n    int i;\n\n    /* irq num for pin INTA, INTB, INTC and INTD is 1, 2, 3 and\n\n     * 4 respectively */\n\n    unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4};\n\n    qemu_irq **irqs, *mpic;\n\n    DeviceState *dev;\n\n    CPUPPCState *firstenv = NULL;\n\n    MemoryRegion *ccsr_addr_space;\n\n    SysBusDevice *s;\n\n    PPCE500CCSRState *ccsr;\n\n\n\n    /* Setup CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"e500v2_v30\";\n\n    }\n\n\n\n    irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        PowerPCCPU *cpu;\n\n        CPUState *cs;\n\n        qemu_irq *input;\n\n\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n        cs = CPU(cpu);\n\n\n\n        if (!firstenv) {\n\n            firstenv = env;\n\n        }\n\n\n\n        irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n        input = (qemu_irq *)env->irq_inputs;\n\n        irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT];\n\n        irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT];\n\n        env->spr_cb[SPR_BOOKE_PIR].default_value = cs->cpu_index = i;\n\n        env->mpic_iack = params->ccsrbar_base +\n\n                         MPC8544_MPIC_REGS_OFFSET + 0xa0;\n\n\n\n        ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500);\n\n\n\n        /* Register reset handler */\n\n        if (!i) {\n\n            /* Primary CPU */\n\n            struct boot_info *boot_info;\n\n            boot_info = g_malloc0(sizeof(struct boot_info));\n\n            qemu_register_reset(ppce500_cpu_reset, cpu);\n\n            env->load_info = boot_info;\n\n        } else {\n\n            /* Secondary CPUs */\n\n            qemu_register_reset(ppce500_cpu_reset_sec, cpu);\n\n        }\n\n    }\n\n\n\n    env = firstenv;\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n    machine->ram_size = ram_size;\n\n\n\n    /* Register Memory */\n\n    memory_region_allocate_system_memory(ram, NULL, \"mpc8544ds.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    dev = qdev_create(NULL, \"e500-ccsr\");\n\n    object_property_add_child(qdev_get_machine(), \"e500-ccsr\",\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    ccsr = CCSR(dev);\n\n    ccsr_addr_space = &ccsr->ccsr_space;\n\n    memory_region_add_subregion(address_space_mem, params->ccsrbar_base,\n\n                                ccsr_addr_space);\n\n\n\n    mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[0], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[1], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    /* General Utility device */\n\n    dev = qdev_create(NULL, \"mpc8544-guts\");\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    /* PCI */\n\n    dev = qdev_create(NULL, \"e500-pcihost\");\n\n    qdev_prop_set_uint32(dev, \"first_slot\", params->pci_first_slot);\n\n    qdev_prop_set_uint32(dev, \"first_pin_irq\", pci_irq_nrs[0]);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        sysbus_connect_irq(s, i, mpic[pci_irq_nrs[i]]);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Register spinning region */\n\n    sysbus_create_simple(\"e500-spin\", params->spin_base, NULL);\n\n\n\n    if (cur_base < (32 * 1024 * 1024)) {\n\n        /* u-boot occupies memory up to 32MB, so load blobs above */\n\n        cur_base = (32 * 1024 * 1024);\n\n    }\n\n\n\n    if (params->has_mpc8xxx_gpio) {\n\n        qemu_irq poweroff_irq;\n\n\n\n        dev = qdev_create(NULL, \"mpc8xxx_gpio\");\n\n        s = SYS_BUS_DEVICE(dev);\n\n        qdev_init_nofail(dev);\n\n        sysbus_connect_irq(s, 0, mpic[MPC8XXX_GPIO_IRQ]);\n\n        memory_region_add_subregion(ccsr_addr_space, MPC8XXX_GPIO_OFFSET,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n\n\n        /* Power Off GPIO at Pin 0 */\n\n        poweroff_irq = qemu_allocate_irq(ppce500_power_off, NULL, 0);\n\n        qdev_connect_gpio_out(dev, 0, poweroff_irq);\n\n    }\n\n\n\n    /* Platform Bus Device */\n\n    if (params->has_platform_bus) {\n\n        dev = qdev_create(NULL, TYPE_PLATFORM_BUS_DEVICE);\n\n        dev->id = TYPE_PLATFORM_BUS_DEVICE;\n\n        qdev_prop_set_uint32(dev, \"num_irqs\", params->platform_bus_num_irqs);\n\n        qdev_prop_set_uint32(dev, \"mmio_size\", params->platform_bus_size);\n\n        qdev_init_nofail(dev);\n\n        s = SYS_BUS_DEVICE(dev);\n\n\n\n        for (i = 0; i < params->platform_bus_num_irqs; i++) {\n\n            int irqn = params->platform_bus_first_irq + i;\n\n            sysbus_connect_irq(s, i, mpic[irqn]);\n\n        }\n\n\n\n        memory_region_add_subregion(address_space_mem,\n\n                                    params->platform_bus_base,\n\n                                    sysbus_mmio_get_region(s, 0));\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (machine->kernel_filename) {\n\n        kernel_base = cur_base;\n\n        kernel_size = load_image_targphys(machine->kernel_filename,\n\n                                          cur_base,\n\n                                          ram_size - cur_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    machine->kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base += kernel_size;\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (machine->initrd_filename) {\n\n        initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK;\n\n        initrd_size = load_image_targphys(machine->initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    machine->initrd_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = initrd_base + initrd_size;\n\n    }\n\n\n\n    /*\n\n     * Smart firmware defaults ahead!\n\n     *\n\n     * We follow the following table to select which payload we execute.\n\n     *\n\n     *  -kernel | -bios | payload\n\n     * ---------+-------+---------\n\n     *     N    |   Y   | u-boot\n\n     *     N    |   N   | u-boot\n\n     *     Y    |   Y   | u-boot\n\n     *     Y    |   N   | kernel\n\n     *\n\n     * This ensures backwards compatibility with how we used to expose\n\n     * -kernel to users but allows them to run through u-boot as well.\n\n     */\n\n    if (bios_name == NULL) {\n\n        if (machine->kernel_filename) {\n\n            bios_name = machine->kernel_filename;\n\n        } else {\n\n            bios_name = \"u-boot.e500\";\n\n        }\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL,\n\n                         1, ELF_MACHINE, 0);\n\n    if (bios_size < 0) {\n\n        /*\n\n         * Hrm. No ELF image? Try a uImage, maybe someone is giving us an\n\n         * ePAPR compliant kernel\n\n         */\n\n        kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL,\n\n                                  NULL, NULL);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load firmware '%s'\\n\", filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Reserve space for dtb */\n\n    dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n\n\n    dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n\n                                       initrd_base, initrd_size,\n\n                                       kernel_base, kernel_size);\n\n    if (dt_size < 0) {\n\n        fprintf(stderr, \"couldn't load device tree\\n\");\n\n        exit(1);\n\n    }\n\n    assert(dt_size < DTB_MAX_SIZE);\n\n\n\n    boot_info = env->load_info;\n\n    boot_info->entry = bios_entry;\n\n    boot_info->dt_base = dt_base;\n\n    boot_info->dt_size = dt_size;\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n", "idx": 10594, "substitutes": {"machine": ["command", "power", "password", "net", "computer", "me", "network", "message", "base", "device", "image", "manager", "company", "iso", "engine", "sim", "frame", "domain", "mass", "instance", "component", "m", "process", "note", "this", "model", "shell", "server", "monitor", "chain", "series", "magic", "owner", "node", "connection", "handler", "mode", "direction", "zone", "Machine", "metadata", "host", "achine", "comment", "agent", "money", "alias", "link", "module", "vm", "database", "state", "template"], "params": ["sym", "AMS", "spec", "par", "mm", "names", "settings", "types", "keys", "eters", "ps", "Par", "Parameters", "m", "images", "members", "json", "details", "scan", "ctx", "conf", "properties", " parameters", "pi", "ams", "param", "ds"], "address_space_mem": ["address_space2mem", "address_sp2reg", "address_sp_memory", "address_space2reg", "address_sp2mem", "address_sp2memory", "address_space2ref", "address_sp_reg", "address_space2memory", "address_sp_ref", "address_space_memory", "address_sp_mem", "address_sp2ref", "address_space_reg", "address_space_ref"], "ram": ["gram", "mb", "mm", "cam", "em", "region", "Mem", "alloc", "range", "bin", "ra", "RAM", "sam", "mem", "mode", "dem", "reg", "rem", "conf", "ro", "res", "serv", "memory", "disk", "vm", "rom", "am", "iam"], "pci_bus": ["pci8block", "pci_queue", "pci_base", "pico_queue", "pci__bus", "pci8queue", "pci__block", "pci__base", "pci8base", "pci_block", "pico_base", "pci__queue", "pico_block", "pico_bus", "pci8bus"], "env": ["era", "obj", "vs", "ef", "next", "entry", "net", "me", "et", "ie", "end", "em", "err", "erd", "ev", "enc", "den", "proc", "manager", "ec", "ve", "buf", "worker", "ne", "eng", "scope", "instance", "cur", "process", "ds", "port", "window", "ea", "en", "session", "ext", "mem", "ew", "equ", "server", "node", "esc", "ctx", "ele", "conn", "v", "conf", "info", "event", "environment", "ey", "e", "cache", "tmp", "cmd", "agent", "hw", "w", "sys", "er", "ent", "org", "context", "el", "ner", "vm", "nv", "state", "viron"], "loadaddr": ["packattr", "packptr", "ockaddr", "loadmem", "ockattr", "packaddr", "loadptr", "packmem", " loadattr", "loadattr", "ockptr", " loadptr", " loadmem", "ockmem"], "filename": ["src", "command", "tty", "fd", "bf", "nm", "fi", "username", "socket", "prefix", "write", "config", "buffer", "File", "asm", "file", "fp", "files", "location", "label", "ame", "txt", "family", "fn", "journal", "fr", "cmd", "fs"], "bios_size": ["bio_info", "bio_name", "bio_size", "bio_count", "bios8name", "bios_name", "bios8info", "bios_info", "bios_count", "bios8count", "bios8size"], "boot_info": ["bootedstate", "start_settings", "boot_INFO", " boot_INFO", "boot_information", "boot_state", "boot2info", "boot2INFO", "bootfieldstate", "bootfieldinfo", "booteddata", "boot_data", "bootedsettings", "bootfieldsettings", " boot_information", "start_info", "bootedinfo", "bootfielddata", "boot2information", "boot_settings", "start_data", "start_state"], "dt_size": ["dk_scale", "dt_time", "dt_scale", "dk_range", "dk_time", "dt_range", "dk_size"], "i": ["key", "id", "ai", "status", "I", "me", "li", "ei", "q", "counter", "k", "p", "o", "sim", "f", "ind", "ui", "ip", "g", "m", "l", "ti", "ic", "in", "mi", "index", "r", "j", "im", "ix", "n", "y", "t", "ci", "iu", "phi", "v", "zi", "xi", "gu", "multi", "qi", "b", "c", "h", "gi", "bi", "di", "ij", "pi", "si", "it", "x", "z", "ini", " ii", "hi", "ji", "ims", " j", "ii"], "pci_irq_nrs": ["pci_irq_pws", "pci_irq_pRS", "pci_irq_pls", "pci_irq_numrs", "pci_irq_Nrs", "pci_irq_Nws", "pci_irq_nws", "pci_irq_NRS", "pci_irq_numls", "pci_irq_numws", "pci_irq_Nls", "pci_irq_nRS", "pci_irq_prs", "pci_irq_nls", "pci_irq_numRS"], "irqs": ["irches", "ibrews", "pirches", "iorqs", "ibrxes", " irqu", "iorqi", "ibrps", "ierews", "rirq", " irxes", "iriq", " irews", "ierps", "rirqs", "iriqs", "rirqq", "pirqs", "irxes", "ibrqs", "ibrques", "rirqu", "irps", "mirews", "pirques", "ierques", "mirqi", "pirews", " irques", "iorques", "mirqs", " irches", "irqi", " irq", "irqu", "mirques", "pirq", "pirqu", "iriqu", "pirxes", "iorq", "pirqq", "pirqi", " irqq", "irqq", "ierqs", "irq", "irews", "iriches", "mirq", " irps", "irques"], "mpic": ["mphik", "mphic", "mmic", "mpIC", "cpIC", "mphIC", "mphics", "mmik", "mpik", "mmIC", "cpik", "cpic", "mmics", "cpics", "mpics"], "dev": ["doc", "vs", "device", "cam", "ev", "proc", "ve", "adv", "def", "ver", "mem", "md", "dem", "conn", "DEV", "v", "gen", "Dev", "hw", "w", "res", "serv", "disk", "iv", "app", "vo", "ds", "sys"], "firstenv": ["secondnode", "startenc", " firstedge", "latestenvironment", "onlyconn", "secondenv", "startenvironment", "startconn", "latestnode", "onlyedge", "latestenv", "firstconn", "onlyenv", "firstenvironment", "latestconn", "onlyenvironment", " firstconn", "Firstenv", " firstenvironment", " firstenc", "startenv", "firstedge", "Firstconn", " firstnode", "Firstenc", "firstnode", "secondconn", "startedge", "secondenvironment", "firstenc"], "ccsr_addr_space": ["ccsr_addr2space", "ccsr_address_base", "ccsr_addr_range", "ccsr_address_range", "ccsr_addr2range", "ccsr_addr2base", "ccsr_address_sp", "ccsr_address_space", "ccsr_addr_base", "ccsr_addr_sp", "ccsr_addr2sp"], "s": ["spec", "socket", "rs", "p", "gs", "ps", "d", "g", "m", "bs", "js", "S", "ss", "n", "t", "v", "os", "e", "b", "sb", "c", "h", "ns", "w", "fs", "ds", "sys"], "ccsr": ["cttr", "ctsr", "cctr", "cccr", "ctcr", "ccr", "cfsr", "csr", "cftr", "cfcr", "cr", "cfr", "ctr"], "cpu": ["ck", "nic", "aco", "cum", "net", "pc", "cmp", "gpu", "computer", "prof", "socket", "ilo", "mx", "processor", "device", "cam", "loader", "alloc", "proc", "ec", "pu", "cp", "worker", "linux", "cow", "process", "pixel", "mu", "core", "CPU", "mem", "clock", "crypt", "us", "uda", "ctx", "uart", "conn", "ork", "gc", "cache", "c", "comp", "cmd", "cn", "uu", "hw", "cu", "php", "sc", "mac", "cv", "vm"], "cs": ["vs", "cks", "rs", "css", "proc", "ec", "ps", "CS", "cp", "tc", "ins", "cc", "bs", "ys", "js", "ix", "ts", "ctx", "cas", "wcs", "os", "caps", "c", "acs", "ns", "cms", "fs", "ks", "csv", "sc", "ls", "ds", "sys"], "input": ["output", "shift", "inner", "select", "config", "buffer", "source", "add", "text", "image", "q", "Input", "event", "child", "form", "error", "act", "process", "active", "local", "flow", "raw", "json", "qa", "in", "queue", "index", "qt", "import", "data", "dq", " inputs", "query", "cmd", "initial", "table", "it", "context", "get", "att", "head", "history", "state", "out"]}}
{"project": "FFmpeg", "commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "target": 1, "func": "static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n", "idx": 10609, "substitutes": {"s": ["sq", "vs", "qs", "a", "ats", "rs", "hs", "p", "gs", "sts", "ps", "cs", "ains", "ins", "es", "sv", "ses", "bs", "aws", "r", "is", "js", "less", "S", "ss", "ts", "n", "its", "erences", "t", "ctx", "v", "self", "e", "sb", "b", "os", "c", "h", "acs", "ns", "stats", "w", "fs", "serv", "comm", "ls", "ims", "ds", "sys", "parts"], "rc_rice_param": ["rc_rice__tag", "rc_cost_dep", "rc_rice_params", "rc_rice_aram", "rc_riceproparams", "rc_race_type", "rc_riceetydim", "rc_riceeterremove", "rc_riceetydep", "rc_rice__dim", "rc_riceproaram", "rc_riceeterparam", "rc_cost_tag", "rc_rice_field", "rc_resource_num", "rc_rice_option", "rc_riceproparam", "rc_cost_option", "rc_rice_dep", "rc_rice__param", "rc_rice67perm", "rc_cost_param", "rc_rice67tag", "rc_rice_remove", "rc_rice67param", "rc_resource_param", "rc_cost_remove", "rc_resource_params", "rc_rice67field", "rc_race_param", "rc_risk_field", "rc_race_params", "rc_race_aram", "rc_riceeteroption", "rc_rice_dim", "rc_risk_tag", "rc_rice_num", "rc_riceetytag", "rc_risk_param", "rc_risk_perm", "rc_rice_weight", "rc_riceetyparam", "rc_riceprotype", "rc_rice_tag", "rc_cost_dim", "rc_rice__dep", "rc_resource_weight", "rc_rice_type", "rc_riceeterparams", "rc_cost_params", "rc_rice_perm"], "last_coeff_abs_level_remaining": ["last_coeff_abs_level_brained", "last_coeff_abs_level_brains", "last_coeff_abs_level_relain", "last_coeff_abs_level_relaining", "last_coeff_abs_level_brain", "last_coeff_abs_level_relained", "last_coeff_abs_level_Remain", "last_coeff_abs_level_resain", "last_coeff_abs_level_resaining", "last_coeff_abs_level_braining", "last_coeff_abs_level_resains", "last_coeff_abs_level_remained", "last_coeff_abs_level_Remained", "last_coeff_abs_level_Remains", "last_coeff_abs_level_remain", "last_coeff_abs_level_remains", "last_coeff_abs_level_Remaining", "last_coeff_abs_level_resained"], "i": ["ms", "ai", "fi", "I", "io", "me", "ie", "li", "ei", "uri", "q", "init", "PI", "p", "point", "sim", "ind", "ui", "iter", "ip", "g", "m", " pi", "ki", "ti", "ic", "cli", "in", "mi", "index", "MI", "j", "im", "ix", "y", "t", "ci", "iu", "\u0438", "zi", "v", "phi", "xi", "gu", "multi", "qi", "c", "gi", "di", "bi", "pi", "si", "it", "x", "ini", " ii", "uli", "oi", "hi", "ims", "asi", "ii"], "prefix": ["reset", "format", "pattern", "print", "span", "post", "word", "pi", "foo", "pre", "key", "next", "address", "status", "path", "network", "weight", "ind", "circ", "iter", "none", "magic", "ix", "alpha", "version", "fix", "radius", "scale", "missing", "alias", "batch", "rank", "distance", "number", "min", "err", "area", "point", "timeout", "local", "sequence", "term", "index", "dirty", "chain", "zone", "master", "major", "start", "module", "bridge", "len", "password", "priority", "wrapper", "pointer", "padding", "base", "ring", "pace", "p", "pad", "ox", "domain", "hop", "label", "pkg", "zero", "position", "root", "division", "x", "coord", "max", "offset", "length"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_hls_window(AVFormatContext *s, int last)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    int i, ret = 0;\n\n    char buf[1024];\n\n\n\n    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n\n                              &s->interrupt_callback, NULL)) < 0)\n\n        goto fail;\n\n\n\n    avio_printf(seg->pb, \"#EXTM3U\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-VERSION:3\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time);\n\n    avio_printf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n                FFMAX(0, seg->number - seg->size));\n\n\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n           FFMAX(0, seg->number - seg->size));\n\n\n\n    for (i = FFMAX(0, seg->number - seg->size);\n\n         i < seg->number; i++) {\n\n        avio_printf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time);\n\n        if (seg->entry_prefix) {\n\n            avio_printf(seg->pb, \"%s\", seg->entry_prefix);\n\n        }\n\n        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);\n\n        if (ret < 0) {\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        avio_printf(seg->pb, \"%s\\n\", buf);\n\n    }\n\n\n\n    if (last)\n\n        avio_printf(seg->pb, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n\n    avio_closep(&seg->pb);\n\n    return ret;\n\n}\n", "idx": 10620, "substitutes": {"s": ["ms", "sq", "spec", "a", "ats", "rs", "as", "sg", "p", "gs", "sts", "hs", "sp", "f", "ps", "g", "cs", "sv", "es", "sam", "scl", "aws", "r", "js", "j", "S", "ss", "ts", "n", "se", "its", "t", "conf", "v", "self", "os", "b", "c", "h", "acs", "ns", "stats", "w", "fs", "serv", "comm", "set", "ls", "ds", "sys"], "last": ["best", "empty", "next", "current", "never", "send", "show", "slave", "prev", "region", "list", "valid", "first", "stable", "push", "active", "local", "Last", "all", "las", "global", "leaf", "final", "latest", " Last", "reverse", "sort", "cast", "since", "gc", "ast", "close", "ctr", "any", "est", "rest", "st", "full", "max", "nd"], "seg": ["keG", "parseg", "adeag", "seeg", "pseg", "vegn", "psegu", "selem", "soag", "soig", "scheG", "seage", "adegu", "seG", "sew", "SEgs", "sev", "segm", "sech", "seabg", "psereg", "soma", "sleg", "slev", "sedg", "sedgc", "schemsg", "vej", "pseG", " sev", "seagu", "vege", "seagn", "sealeg", "psegt", "segc", "SEj", "seaig", "selet", "seagt", "seach", "sedag", " sej", "segen", "sege", "scheg", "sexig", "psegn", "seager", " sew", " seq", " segen", "SEgn", "sego", "parseger", "seags", "slema", " segn", "parselet", "sexG", "schelem", "seagc", "scheeg", "seaad", "seger", " elegen", "psegm", " seger", " sege", "schegm", "scheig", "schech", "sema", "parseerg", "perg", "segate", "sedgate", " seh", "seew", " segs", "sedbg", "schej", "psegs", " seged", "seag", "seaG", "slemsg", " elegs", "parseged", "segs", "psege", "pergment", "sedgs", "schem", "parsege", "seig", "parsegment", "seaq", "pselem", "seged", "sexgate", "parseleg", "sedgn", "psemsg", "gej", "pseeg", "seareg", "pseag", "segment", "seam", "adeger", "SEeg", "sedmsg", "schegen", "slereg", "seerg", "veg", "sexgn", "sexbg", "sexad", "parsegn", " elegn", "parsech", "pseerg", "schelet", "schev", "sead", "seago", "sedq", "sexged", " eleg", "geg", "seagment", "vegs", "sogu", " seeg", "sedleg", "pseig", "somsg", "sederg", "psej", " segment", "schegs", "perleg", "sem", "perag", " seG", "seaged", "psev", "sej", "seagm", "keged", "semsg", "seaeg", "seaag", "sedig", "sogen", "segn", "SEgm", "pseleg", "seegn", "soreg", "seegs", "sexg", "parseig", "geq", "vegen", "seq", "sebg", "sealet", "sog", "seagen", "SEG", "SEg", "psema", "seaw", "sereg", "soge", "scheq", "pseq", "seav", "gev", "parsev", "sexgc", "seah", "pseh", "psem", "kead", "sedge", " segm", "segu", "slem", "keg", "seagate", "sogm", "sedgment", "sealem", "adeg", " sereg", "segt", "schegt", "sedgo", " sem", "psegment", "sexgo", "soger", "seh", "seleg"], "i": ["id", "u", "ai", "I", "me", "li", "ei", "q", " I", "k", "ri", "p", "o", "sim", "ind", "ui", "iter", "ni", "ip", "m", "l", "ret", "ki", "ti", "ic", "cli", "us", "in", "mi", "index", "j", "im", "ix", "n", "y", "t", "ci", "iu", "phi", "v", "zi", "xi", "multi", "qi", "gi", "di", "bi", "ij", "pi", "si", "slice", "it", "x", "z", "ini", " ii", "oi", "hi", "ims", " j", "ii", "tim"], "buf": ["tr", " buffer", "off", "nm", "buffer", "text", "uf", "rb", "err", "seq", "iter", "bc", "rw", "Buffer", "cur", "ref", "fb", "ret", "cb", "tab", "raw", "window", "bytes", "txt", "queue", "mem", "br", "data", "pb", "box", "cap", "ctx", "new", "v", "b", "tmp", "cmd", "h", "str", "w", "temp", "Buff", "result", "batch", "buff", "msg", "cv", "img", "out", "wb"]}}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 10640, "substitutes": {"a": ["ba", "na", "la", " sa", "aj", "al", " the", "at", "va", "aka", " it", "as", "area", "p", "o", "an", "f", "am", "aaa", "da", "d", "ae", "m", "l", " la", " af", "i", "ab", " an", "ia", "ta", "ga", "ma", "alpha", "isa", "t", "ac", "v", " l", "e", "val", "c", "A", "sa", "sta", " pa", " as", " A", "x", "aa", "oa", "ar", "ca"], "b": ["ba", "be", "lib", "bf", "rb", "p", "bes", "B", "bc", "d", "g", "m", "l", "fb", "i", "ab", "bs", "bg", "r", "j", "blue", "br", "n", "y", "emb", "eb", "v", "e", "c", "bis", "bi", "bb", "z", "nb", "ib", "db"]}}
{"project": "qemu", "commit_id": "4871b51b9241b10f4fd8e04bbb21577886795e25", "target": 1, "func": "static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n", "idx": 10648, "substitutes": {"expected": [" expectation", "command", "key", " required", "ordered", "current", "pe", " found", "config", "read", "announced", "message", "et", "pecting", "match", "event", "pattern", "received", "allowed", "valid", "EXP", "end", " e", "sent", "actual", "report", "ex", "def", " expects", "pected", "seen", "example", "hello", "test", "data", "needed", " unexpected", "old", "v", " inspected", "matched", "e", "ed", "found", "reported", "est", "fake", "claimed", "force", " desired", "style", "result", " expecting", "cv", "pect", "ped", " expect", "required"], "measured": ["mesasured", "peasuring", "peasures", " measuring", "memasuring", "measuring", "memasures", "mesasuring", "peasured", " measures", "peasure", "seasured", "mesasures", " measure", "omeasured", "measure", "seasure", "measures", "omeasures", "memasured", "omeasure", "omeasuring", "memasure", "seasuring", "seasures", "mesasure"], "cmd": ["col", "command", "obj", "send", "call", "buffer", "text", "code", "Cmd", "ch", "std", "q", "req", "pt", "init", "ct", "cut", "bind", "resp", "buf", "cp", "ind", "cf", "act", "program", "g", "pkg", "find", "control", "cd", "fun", "args", "cb", "def", "raw", "txt", "handle", "cli", "ext", "mem", "md", "qt", "addr", "data", "test", "dq", "ctx", "conn", "cfg", "mk", "ctr", "c", "tmp", "exec", "str", "help", "force", "batch", "comm", "msg", "out", "mt"]}}
{"project": "FFmpeg", "commit_id": "b4886795108e319a5b3a88370e90207d9c15a01e", "target": 1, "func": "static int decode_frame_byterun1(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height ; y++) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { //PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM\n\n        for(y = 0; y < avctx->height ; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(row, avctx->width, buf, buf_end);\n\n        }\n\n    } else { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n        for (y = 0; y < avctx->height ; y++) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);\n\n            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 10665, "substitutes": {"avctx": ["abcp", "ajjp", "wavcfg", "navjac", " avcontext", "vartx", "wavca", "avecontext", "avercmp", "navcpu", "avsys", "avcmd", "wavcp", "verreq", " avsetup", "ajreq", "aftmp", "averctx", "avcmp", "avejac", "afdl", "avetx", "avetmp", "afpkg", " avctl", "avepkg", "aftx", "abtx", "ajdl", "avereq", "devctx", "avectl", "abpkg", "wavctx", "ajpkg", "avcpu", "navctx", "AVctx", "verctx", "avcontext", "avercontext", "varcpu", "verctl", "avjp", "ajctx", "avectx", "wavjp", "varpkg", "avecpu", "ajtx", "afcmp", "abkt", "avertmp", "avtmp", "vertx", "avcfg", "afcfg", "ajcontext", "wavsetup", " avtx", "devpkg", "aveca", "wavtx", "avcu", "avkt", "avejp", " avcmd", "avctl", " avreq", "afctx", "varctx", "AVtx", "AVcontext", "abctx", "avecmd", "devcpu", "wavcu", "devtx", " avcmp", "wavcmd", " avcfg", "ajsys", "wavctl", "afcontext", "wavcontext", "wavreq", " avcpu", "avjac", "abcontext", "avedl", "navpkg", "avdl", "wavpkg", "wavsys", "afca", " avcp", "avekt", "averjp", "avecfg", "AVcmp", " avkt", " avpkg", "avcp", "afjp", "ajcp", "afcu", "avecmp", "ajca", "avreq", "averpkg", "abjp", "aversetup", "avsetup", "wavcmp", " avjac", "abcfg", "avertx", "avecp", "avtx", "avpkg", " avjp", " avsys", "avca", "avercu"], "data": ["len", "Data", "empty", "id", "next", "pieces", "extra", "map", "part", "entry", "buffer", "text", "message", "read", "padding", "device", "image", "end", "p", "value", "f", "bin", "frame", "pad", "error", "name", "d", "da", "block", "m", "ata", "def", "bits", "values", "zero", "length", "raw", "window", "bytes", "mu", "r", "chain", "rel", "done", "header", "ad", "body", "t", "mode", "info", "cache", "line", "b", "query", "initial", "dat", "rew", "str", "start", "table", "batch", "DATA", "debug", "no", "content", "offset", "size"], "data_size": ["data_len", "buf_length", "data_length", "buf_len", "buf_pos", "data__len", "data__size", "buf_size", "data__length", "data_pos", "data__pos"], "avpkt": ["avpywd", "avpacket", "avPction", "avpconn", "averpkt", "avcpct", "avlprt", "avpadwd", "averpiddt", "wavpconn", "avjpacket", "avcpwk", "avopkt", "averpcmd", "wavdacket", "wavdconn", "avpakg", "iverlpkt", "avwkt", "wavdkt", "avPkt", "avopmsg", "awpett", "avdwd", "avdpacket", "avpwd", "avdpnet", "avpacmd", "avdprt", "awpth", "avwpkt", "averpidacket", "averpidwp", "wavwpet", "awcpkt", "iverprt", "avpaddt", "avpidkt", "avcpth", "wavpet", "avpadwp", "avpckt", "avetpct", "iverlpnet", "avepkt", "avtpwk", "avwpacket", "avpmsg", "avjpct", "awpct", "avdpkt", "averpwd", "avopwd", "avcpkt", "averpdt", "avdacket", "wavdwd", "avepwk", "avcpconn", "avpaacket", "avpaet", "avetpkt", "avtpkt", "avjpkt", "avpadkt", "avPacket", "avwpet", "avPmsg", "awpacket", "avpanet", "avpiddt", "iverpkg", "averpacket", "avpcet", "avprt", "iverlpkg", "avpcmd", "avpykt", "avpett", "wavwpacket", "awpmsg", "iverpkt", "avpwp", "avpdt", "awpction", "avjpwd", "avpwk", "avPth", "avdpmsg", "avopction", "averpywd", "avepconn", "avwct", "awcpct", "wavwpkt", "avdpkg", "avopacket", "avdconn", "avPct", "avepct", "avetpwk", "avpth", "avpction", "wavpacket", "avcpett", "avdpction", "avpycmd", "avpet", "averpwp", "avlpkt", "averpykt", "avwth", "wavpkt", "awopacket", "avtpconn", "avpidacket", "avpadcmd", "avpidwp", "avjpconn", "avlpnet", "avtpct", "avwpdt", "avpcacket", "awpkt", "avdkt", "averpycmd", "averpidkt", "awopction", "awcpth", "avjpwk", "avwett", "avpnet", "avpct", "iverlprt", "avpakt", "awopmsg", "avPett", "avpawd", "avopconn", "avpart", "avlpkg", "iverpnet", "awopkt", "avetpconn", "avpkg", "wavpwd", "avwpwp", "avpadacket", "awcpett"], "s": ["ms", "sq", "vs", "spec", "ares", "qs", "a", "ats", "settings", "rs", "hs", "p", "gs", "sts", "sm", "ps", "ess", "g", "cs", "bits", "ins", "sv", "i", "ses", "sam", "args", "scl", "bs", "es", "aws", "is", "js", "less", "S", "ss", "ts", "its", "als", "details", "t", "ctx", "sports", "r", "v", "conf", "ops", "os", "sb", "b", "c", "sw", "h", "ns", "stats", "w", "fs", "actions", "comm", "ls", "tes", "ims", "ds", "sys"], "buf": ["arr", "len", "empty", "tr", "off", "lim", "map", "buffer", "text", "uf", "cam", "err", "alloc", "bl", "pool", "cp", "bc", "Buffer", "vec", "block", "ref", "limit", "pkg", "pos", "cb", "ptr", "port", "raw", "bytes", "window", "queue", "mem", "r", "br", "cap", "ctx", "rc", "b", "tmp", "cmd", "Buff", "batch", "buff", "msg", "bar", "cv", "max", "conv"], "buf_end": ["buf2begin", "buff2ends", "buf_ends", "buf2end", "buf_begin", "buff2end", "buf_start", "buf2ends", "buff2start", "buff_end", "buff_start", "buff_begin", "buff2begin", "buff_ends", "buf2start"], "y": ["col", " ty", "any", "key", "py", "yt", "xy", "ate", "ya", "axy", "sky", "ty", "ch", "vy", "ady", "yy", "wy", " ly", " i", "ach", "p", "ay", "sim", "height", "ind", "ry", "ip", "oy", "my", "ies", "i", "ye", "yer", "iny", "dy", "ys", "j", "icy", "sat", "t", "yr", "Y", "hot", "asy", "iz", "ey", "b", "h", "uy", "gy", "ot", "ym", "ly", "sys", "sy", "iy", "hey", "fy", "by", "yx", "x", "z", "tiny", "story", "yl", "ny", "kit", "cy"], "plane": ["depth", "mate", "cube", "pe", "priority", "fl", "flag", "pse", "plate", "plot", "slave", "axis", "rise", "pan", "stroke", "flat", "profile", "ve", "white", "half", " Plane", "normal", "pose", "straight", "way", "late", "gate", "planes", "face", "flow", "lane", "port", "panel", "place", "anes", "cone", "ker", "ane", "pen", "mode", "zone", "bo", "line", "clip", "heading", "du", "animate", "mail", "pipe", "slice", " planes", "pa"], "res": ["arr", "render", "fin", "reset", "pas", "status", "resource", "resolution", "rs", "req", "err", "alloc", "ras", "proc", "resp", "hash", "rep", "rek", "Res", "ps", "gr", "rev", "vec", "ref", "def", "progress", "json", "mem", "pres", "RES", "r", "rel", "details", "plain", "expr", "js", "ser", "rem", "rc", "reg", "fr", "pr", "ress", "val", "der", "red", "results", "des", "re", "rest", "fs", "ber", "serv", "vals", "rss", "resh", "result", "msg", " Res", "rez", "content", "dr", "out", "ret"], "row": ["ow", "col", "key", "tr", "entry", "record", "rown", "rs", "cell", "pair", "ry", "pad", "frame", "iter", "th", "way", "block", "pos", "pixel", "ptr", "tab", "port", "ver", "r", "rows", "roll", "node", "oom", "rot", "line", "rect", "ro", "Row", "item", "co", "bar", "our"]}}
{"project": "FFmpeg", "commit_id": "29d2dc59f973f9495c703b4cab17ded5c24ab3e8", "target": 1, "func": "int alloc_picture(MpegEncContext *s, Picture *pic, int shared){\n\n    const int big_mb_num= s->mb_stride*(s->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11\n\n    const int mb_array_size= s->mb_stride*s->mb_height;\n\n    const int b8_array_size= s->b8_stride*s->mb_height*2;\n\n    const int b4_array_size= s->b4_stride*s->mb_height*4;\n\n    int i;\n\n\n\n    if(shared){\n\n        assert(pic->data[0]);\n\n        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);\n\n        pic->type= FF_BUFFER_TYPE_SHARED;\n\n    }else{\n\n        int r;\n\n\n\n        assert(!pic->data[0]);\n\n\n\n        r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic);\n\n\n\n        if(r<0 || !pic->age || !pic->type || !pic->data[0]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %d %d %p)\\n\", r, pic->age, pic->type, pic->data[0]);\n\n            return -1;\n\n        }\n\n\n\n        if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (stride changed)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if(pic->linesize[1] != pic->linesize[2]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (uv stride mismatch)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        s->linesize  = pic->linesize[0];\n\n        s->uvlinesize= pic->linesize[1];\n\n    }\n\n\n\n    if(pic->qscale_table==NULL){\n\n        if (s->encoding) {\n\n            CHECKED_ALLOCZ(pic->mb_var   , mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mb_mean  , mb_array_size * sizeof(int8_t))\n\n        }\n\n\n\n        CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check\n\n        CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))\n\n        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))\n\n        pic->mb_type= pic->mb_type_base + s->mb_stride+1;\n\n        if(s->out_format == FMT_H264){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 2;\n\n        }else if(s->out_format == FMT_H263 || s->encoding || (s->avctx->debug&FF_DEBUG_MV) || (s->avctx->debug_mv)){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 3;\n\n        }\n\n        if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)\n\n        }\n\n        pic->qstride= s->mb_stride;\n\n        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))\n\n    }\n\n\n\n    /* It might be nicer if the application would keep track of these\n\n     * but it would require an API change. */\n\n    memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);\n\n    s->prev_pict_types[0]= s->pict_type;\n\n    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && s->prev_pict_types[pic->age] == B_TYPE)\n\n        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.\n\n\n\n    return 0;\n\nfail: //for the CHECKED_ALLOCZ macro\n\n    return -1;\n\n}\n", "idx": 10670, "substitutes": {"s": ["ms", "vs", "parts", "ats", "sg", "hs", "d", "cs", "m", "ins", "details", "http", "se", "y", "t", "sports", "mys", "ties", "os", "b", "sa", "str", "w", "comm", "ims", "conv", "eds", "ports", "settings", "news", "sql", "sp", "gs", "sts", "g", "ies", "sv", "ses", "mods", "xs", "sam", "bs", "plays", "less", "js", "ss", "conf", "sb", "si", "sc", "sis", "ls", "app", "sq", "spec", "sl", "aunts", "qs", "a", "rs", "as", "sac", "es", "ts", "n", "views", "styles", "ctx", "sw", "results", "ns", "space", "ds", "eps", "p", "sim", "uploads", "ps", "south", "this", "aws", "pres", "is", "snap", "j", "S", "its", "v", "https", "c", "h", "stats", "fs", "csv", "st", "stat", "sys", "store"], "pic": ["doc", "photos", "op", "par", "pp", "feature", "cam", "print", "proc", "kt", "peg", "prop", "rep", "mic", "pg", "parse", "jpg", "pr", "pl", "str", "eric", "pin", "pi", "pro", "vol", "virt", "phot", "Pic", "sci", "ping", "sp", "cro", "jp", "sam", "capt", "pit", "txt", "magic", "ac", "feat", "temp", "spr", "phys", "Picture", "mp", "syn", "pid", "img", "draw", "jac", "png", "spec", "pc", "image", "picture", "ic", "pick", "kl", "phy", "like", "ctx", "px", "perm", "anc", "piece", "pict", "pty", "style", "py", "lib", "pse", "pan", "iac", "p", "sim", "ps", "pkg", "Pict", "pres", "shot", "snap", "script", "photo", "gc", "cache", "pot", "wp", "mac", "agic", "pa"], "shared": ["bare", "mb", "safe", "shadow", "linked", "sp", "associated", "same", "sec", "ram", "stable", "g", "local", "acked", "Sh", "parent", "raw", "broken", "checked", "dirty", "bound", "stock", "global", "owner", "needed", "hidden", "exclusive", "visible", "basic", "ed", "sh", "used", "copy", "sharing", "loaded", "restricted", "only", "locked", "ared", "bar", "private", "share", "required", "store"], "i": ["fi", "I", "p", "f", "ip", "g", "m", "l", "ti", "ia", "j", "ir", "im", "y", "t", "ci", "phi", "v", "b", "h", "di", "pi", "si", "it", "x", "z", "ii"], "r": ["arr", "hr", "u", "rb", "rs", "q", "err", "range", "ri", "p", "f", "d", "rw", "g", "m", "l", "attr", "mr", "rr", "rate", "rel", "br", "n", "t", "rg", "rat", "rc", "rd", "v", "fr", "nr", "pr", "b", "c", "h", "reb", "rt", "re", "sr", "w", "res", "er", "x", "z", "result", "rad", "R", "cr", "rar", "dr"]}}
{"project": "FFmpeg", "commit_id": "fa5dacce143f3fbe8eac14d5a99e926b2787e9e6", "target": 1, "func": "static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\n    if (get_bits(&ctx->gb, 5) != 0x1F) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\n        return -1;\n    ctx->prev_frame_type = ctx->frame_type;\n    ctx->frame_type      = get_bits(&ctx->gb, 3);\n    if (ctx->frame_type >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\n        return -1;\n    ctx->frame_num = get_bits(&ctx->gb, 8);\n    if (ctx->frame_type == FRAMETYPE_INTRA) {\n        ctx->gop_invalid = 1;\n        if (decode_gop_header(ctx, avctx))\n            return -1;\n        ctx->gop_invalid = 0;\n    if (ctx->frame_type != FRAMETYPE_NULL) {\n        ctx->frame_flags = get_bits(&ctx->gb, 8);\n        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\n        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n        /* skip unknown extension if any */\n        if (ctx->frame_flags & 0x20)\n            skip_hdr_extension(&ctx->gb); /* XXX: untested */\n        /* decode macroblock huffman codebook */\n        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\n            return -1;\n        skip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\n    align_get_bits(&ctx->gb);\n    return 0;", "idx": 10671, "substitutes": {"ctx": ["tm", "warn", "ck", "xp", "prefix", "ct", "proc", "func", "kt", "ctl", "cc", "check", "wd", "ork", "wcs", "cmd", "nc", "context", "cv", "lex", "history", "conv", "td", "tx", "cmp", "ctrl", "cookie", "tk", "height", "dc", "jp", "note", "xs", "kind", "ka", "txt", "qa", "jj", "that", "aux", "ac", "conn", "conf", "rt", "cm", "etc", "batch", "work", "jac", "obj", "pc", "abc", "crit", "req", "resp", "cp", "nt", "tc", "cd", "def", "timeout", "index", "kl", "dl", "px", "lc", "anc", "tmp", "exec", "ns", "hw", "loc", "ann", "ca", "iac", "tz", "cf", "xc", "act", "pkg", "np", "wx", "cb", "addr", "expr", "rc", "cfg", "acl", "gc", "ctr", "wp", "kw", "cu", "stat", "gt", "co", "btn", "inst", "sys"], "avctx": [" avctl", "avetmp", "wavtx", "evctx", " avcontext", "avejp", "avepkg", "avctl", "aftx", "ajthread", "evcmp", "AVcmp", "ivtx", "avecontext", "vrpkg", "evcontext", "afctx", "AVtx", "wavctx", "avcpu", "ivcontext", "ajcpu", " avthread", "afjp", "AVctx", "AVcontext", "avthread", "avcontext", "vrctx", "avethread", "averpkg", "ivctx", "vrheight", "avjp", " avcmp", "ajctx", "ivctl", "avectx", "avecpu", "averheight", "avertmp", "wavctl", "averctx", "avheight", "avcmp", "avtmp", "evtx", "wavcontext", "afcontext", " avcpu", "avtx", "avpkg", "ajcontext", "aveheight", " avtx", " avjp", "vrtmp", "avetx"]}}
{"project": "FFmpeg", "commit_id": "64f7db554ee83846f207e82a08946a6a5a6acfe2", "target": 1, "func": "static int mpegts_write_header(AVFormatContext *s)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    MpegTSWriteStream *ts_st;\n\n    MpegTSService *service;\n\n    AVStream *st, *pcr_st = NULL;\n\n    AVDictionaryEntry *title, *provider;\n\n    int i, j;\n\n    const char *service_name;\n\n    const char *provider_name;\n\n    int *pids;\n\n    int ret;\n\n\n\n    if (s->max_delay < 0) /* Not set by the caller */\n\n        s->max_delay = 0;\n\n\n\n    // round up to a whole number of TS packets\n\n    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;\n\n\n\n    ts->tsid = ts->transport_stream_id;\n\n    ts->onid = ts->original_network_id;\n\n    /* allocate a single DVB service */\n\n    title = av_dict_get(s->metadata, \"service_name\", NULL, 0);\n\n    if (!title)\n\n        title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;\n\n    provider      = av_dict_get(s->metadata, \"service_provider\", NULL, 0);\n\n    provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME;\n\n    service       = mpegts_add_service(ts, ts->service_id,\n\n                                       provider_name, service_name);\n\n\n\n    if (!service)\n\n        return AVERROR(ENOMEM);\n\n\n\n    service->pmt.write_packet = section_write_packet;\n\n    service->pmt.opaque       = s;\n\n    service->pmt.cc           = 15;\n\n\n\n    ts->pat.pid          = PAT_PID;\n\n    /* Initialize at 15 so that it wraps and is equal to 0 for the\n\n     * first packet we write. */\n\n    ts->pat.cc           = 15;\n\n    ts->pat.write_packet = section_write_packet;\n\n    ts->pat.opaque       = s;\n\n\n\n    ts->sdt.pid          = SDT_PID;\n\n    ts->sdt.cc           = 15;\n\n    ts->sdt.write_packet = section_write_packet;\n\n    ts->sdt.opaque       = s;\n\n\n\n    pids = av_malloc_array(s->nb_streams, sizeof(*pids));\n\n    if (!pids) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* assign pids to each stream */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n\n\n        ts_st = av_mallocz(sizeof(MpegTSWriteStream));\n\n        if (!ts_st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        st->priv_data = ts_st;\n\n\n\n        ts_st->user_tb = st->time_base;\n\n        avpriv_set_pts_info(st, 33, 1, 90000);\n\n\n\n        ts_st->payload = av_mallocz(ts->pes_payload_size);\n\n        if (!ts_st->payload) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        ts_st->service = service;\n\n        /* MPEG pid values < 16 are reserved. Applications which set st->id in\n\n         * this range are assigned a calculated pid. */\n\n        if (st->id < 16) {\n\n            ts_st->pid = ts->start_pid + i;\n\n        } else if (st->id < 0x1FFF) {\n\n            ts_st->pid = st->id;\n\n        } else {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Invalid stream id %d, must be less than 8191\\n\", st->id);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        if (ts_st->pid == service->pmt.pid) {\n\n            av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        for (j = 0; j < i; j++) {\n\n            if (pids[j] == ts_st->pid) {\n\n                av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        pids[i]                = ts_st->pid;\n\n        ts_st->payload_pts     = AV_NOPTS_VALUE;\n\n        ts_st->payload_dts     = AV_NOPTS_VALUE;\n\n        ts_st->first_pts_check = 1;\n\n        ts_st->cc              = 15;\n\n        /* update PCR pid by using the first video stream */\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            service->pcr_pid == 0x1fff) {\n\n            service->pcr_pid = ts_st->pid;\n\n            pcr_st           = st;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_AAC &&\n\n            st->codec->extradata_size > 0) {\n\n            AVStream *ast;\n\n            ts_st->amux = avformat_alloc_context();\n\n            if (!ts_st->amux) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ts_st->amux->oformat =\n\n                av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? \"latm\" : \"adts\",\n\n                                NULL, NULL);\n\n            if (!ts_st->amux->oformat) {\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (!(ast = avformat_new_stream(ts_st->amux, NULL))) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ret = avcodec_copy_context(ast->codec, st->codec);\n\n            if (ret != 0)\n\n                goto fail;\n\n            ast->time_base = st->time_base;\n\n            ret = avformat_write_header(ts_st->amux, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_OPUS) {\n\n            ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate;\n\n        }\n\n    }\n\n\n\n    av_freep(&pids);\n\n\n\n    /* if no video stream, use the first stream as PCR */\n\n    if (service->pcr_pid == 0x1fff && s->nb_streams > 0) {\n\n        pcr_st           = s->streams[0];\n\n        ts_st            = pcr_st->priv_data;\n\n        service->pcr_pid = ts_st->pid;\n\n    } else\n\n        ts_st = pcr_st->priv_data;\n\n\n\n    if (ts->mux_rate > 1) {\n\n        service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->sdt_packet_period      = (ts->mux_rate * SDT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->pat_packet_period      = (ts->mux_rate * PAT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n\n\n        if (ts->copyts < 1)\n\n            ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE);\n\n    } else {\n\n        /* Arbitrary values, PAT/PMT will also be written on video key frames */\n\n        ts->sdt_packet_period = 200;\n\n        ts->pat_packet_period = 40;\n\n        if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (!pcr_st->codec->frame_size) {\n\n                av_log(s, AV_LOG_WARNING, \"frame size not set\\n\");\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * 512);\n\n            } else {\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size);\n\n            }\n\n        } else {\n\n            // max delta PCR 0.1s\n\n            // TODO: should be avg_frame_rate\n\n            service->pcr_packet_period =\n\n                ts_st->user_tb.den / (10 * ts_st->user_tb.num);\n\n        }\n\n        if (!service->pcr_packet_period)\n\n            service->pcr_packet_period = 1;\n\n    }\n\n\n\n    ts->last_pat_ts = AV_NOPTS_VALUE;\n\n    ts->last_sdt_ts = AV_NOPTS_VALUE;\n\n    // The user specified a period, use only it\n\n    if (ts->pat_period < INT_MAX/2) {\n\n        ts->pat_packet_period = INT_MAX;\n\n    }\n\n    if (ts->sdt_period < INT_MAX/2) {\n\n        ts->sdt_packet_period = INT_MAX;\n\n    }\n\n\n\n    // output a PCR as soon as possible\n\n    service->pcr_packet_count = service->pcr_packet_period;\n\n    ts->pat_packet_count      = ts->pat_packet_period - 1;\n\n    ts->sdt_packet_count      = ts->sdt_packet_period - 1;\n\n\n\n    if (ts->mux_rate == 1)\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate VBR, \");\n\n    else\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate %d, \", ts->mux_rate);\n\n    av_log(s, AV_LOG_VERBOSE,\n\n           \"pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\\n\",\n\n           service->pcr_packet_period,\n\n           ts->sdt_packet_period, ts->pat_packet_period);\n\n\n\n    if (ts->m2ts_mode == -1) {\n\n        if (av_match_ext(s->filename, \"m2ts\")) {\n\n            ts->m2ts_mode = 1;\n\n        } else {\n\n            ts->m2ts_mode = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&pids);\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st    = s->streams[i];\n\n        ts_st = st->priv_data;\n\n        if (ts_st) {\n\n            av_freep(&ts_st->payload);\n\n            if (ts_st->amux) {\n\n                avformat_free_context(ts_st->amux);\n\n                ts_st->amux = NULL;\n\n            }\n\n        }\n\n        av_freep(&st->priv_data);\n\n    }\n\n\n\n    for (i = 0; i < ts->nb_services; i++) {\n\n        service = ts->services[i];\n\n        av_freep(&service->provider_name);\n\n        av_freep(&service->name);\n\n        av_freep(&service);\n\n    }\n\n    av_freep(&ts->services);\n\n    return ret;\n\n}\n", "idx": 10672, "substitutes": {"s": ["ms", "vs", "sq", "spec", "arts", "ares", "qs", "a", "ats", "socket", "rs", "als", "tests", "hs", "p", "gs", "sts", "sp", "ps", "south", "changes", "g", "cs", "m", "ins", "sv", "args", "ses", "bs", "services", "aws", "less", "js", "details", "S", "ss", "n", "its", "is", "series", "t", "sports", "y", "v", "sets", "https", "conf", "ops", "os", "sb", "b", "c", "h", "ns", "stats", "fs", "serv", "comm", "ls", "tes", "ims", "ds", "ers", "sys", "parts"], "ts": ["ms", "tm", "vs", "ats", "fts", "hs", "TS", "Ts", "cs", "uts", "t", "wcs", "tis", "os", "wt", "times", "options", "opt", "ims", "td", "ports", "tt", "aps", "tr", "tx", "tp", "types", "tests", "gs", "sts", "outs", "ots", "sv", "xs", "utils", "bs", "txt", "ta", "js", "als", "that", "test", "ics", "ops", "att", "ls", "asts", "pt", "rs", "nt", "trans", "tc", "points", "vt", "tags", "ets", "ns", "tes", "ds", "mt", "arts", "lt", "ty", "ps", "TPS", "its", "tl", "tn", "stats", "fs", "gt", "tz", "sys"], "ts_st": ["ts_std", "ts_sta", "ds_sta", "ds_ste", "ts_ste", "ds_std", "ds_st"], "service": ["command", "tt", "spec", "Service", "ice", "status", "sl", "entry", "lib", "resource", "ty", "secure", "section", "image", "file", "sp", "task", "response", "component", "instance", "way", "process", "type", "my", "git", "sv", "sam", "port", "services", "so", "server", "function", "storage", "ser", "attribute", "data", "se", "test", "interface", "t", "ssl", "sort", "info", "tree", "query", "comment", "sn", "library", "sr", "serv", "table", "item", "module", "name", "vc", "statement", "state", "store"], "st": ["tt", "sl", "std", "spect", "St", "ct", "stream", "sp", "sts", "nt", "stable", "sv", "ste", "so", "stage", "ss", "ist", "se", "dest", "t", "sw", "ST", "sn", "str", "est", "rest", "mt"], "pcr_st": ["pcr2const", "pcr_stream", "pcr_std", "pcm_st", "pcr2st", "pcr_const", "pcm_const", "pcr2std", "pcr2stream", "pcm_stream", "pcm_std"], "title": ["jury", "key", "tt", "filename", "id", "chapter", "status", "town", "username", "prefix", "section", "format", "summary", "meta", "profile", "hash", "TIT", "normal", "label", "phrase", "tle", "type", "ame", "note", "itled", "hd", "token", "term", "alt", "details", "displayText", "medium", "alpha", "test", "version", "header", "Title", "itles", "t", "total", "data", "html", "unknown", "metadata", "primary", "basic", "nat", "tele", "comment", "master", "subject", "alias", "tel", "pole", "att", "itle", "lead", "important", "description", "name", "template", "role"], "provider": ["proviler", "whereider", "rovide", "provicator", "prison", "proice", "provice", "provendor", "proicator", "servison", "pricator", "roviler", "whereIDER", "proader", "pride", "prader", "whereiler", "provide", "divider", "perice", "pericator", "prifier", "avison", "veroser", "prendor", "provoser", "provison", "provifier", "divoser", "divIDER", "rovIDER", "perider", "servider", "whereide", "avice", "perader", "avendor", "avider", "divifier", "servendor", "provIDER", "verider", "provader", "veride", "proider", "divide", "diviler", "verifier", "proser", "prider", "price", "rovider"], "i": ["ami", "id", "u", "ai", "I", "io", "li", "ei", "p", "o", "ind", "ui", "ip", "m", "in", "us", "mi", "index", "jj", "im", "ix", "n", "t", "ci", "\u0438", "v", "xi", "multi", "qi", "gi", "di", "bi", "ij", "pi", "si", "x", "ini", " ii", "oi", "ji", "ii"], "j": ["aj", "ja", "jump", "J", "jc", "li", "q", "k", "p", "ii", "o", "f", "ni", "g", "jp", "l", "m", "pos", "jj", "js", "n", "v", "b", "it", "x", "z", "ji", "ij"], "service_name": ["resource_type", "sectionNamename", "section_value", "serviceNamename", "section_id", "process_comment", "section_Name", "resource_Name", "service_Name", "process_common", "sectionNameName", "service_value", "process_name", "service_common", "serviceNamevalue", "serviceablecommon", "serviceNamecommon", "serviceablecomment", "sectionNamevalue", "serviceablename", "service_description", "process_value", "serviceNamecomment", "resource_description", "service_id", "serviceNameid", "serviceablevalue", "sectionNameid", "section_name", "resource_name", "serviceNameName", "service_comment", "service_type"], "provider_name": ["providerablenote", "provicerablecomment", "provistryablenote", "provicer_name", "provide_name", "provicer_number", "provicerabledefault", "provistryablename", "provistryablecomment", "provider_comment", "provistry_comment", "provistryablecap", "provicerablename", "provicer_comment", "provider_Name", "provider_id", "providerablecomment", "provistry_note", "provider_number", "provide_id", "provicerablenumber", "provider_default", "providerablename", "provide_Name", "provicer_default", "provistry_cap", "providerablenumber", "provider_cap", "provistry_name", "provider_note", "providerablecap", "providerabledefault"], "pids": ["cpents", "piders", " pips", "psids", "ppips", "toids", "pads", "psires", "moids", "ppires", "cpoids", "cpiders", " pid", "tips", "psoids", "ppoids", "mads", " pockets", "pents", "mids", "pockets", "miders", "pips", "tid", " pires", "cpids", " piders", "psads", " pents", " poids", "ppockets", "ppids", "psents", "tids", "poids", "cpads", "ppid", "psockets", "pires", "pid", " pads"], "ret": ["len", "lit", "reset", "status", "back", "err", "RET", "resp", "ry", "nt", "jp", "true", "mt", "alt", "ter", "mem", "r", "try", "t", "mel", "rem", "rets", "val", "Ret", "rt", "re", "elt", "res", "opt", "it", "result", "att", "get", "gt", "ll", "ft", "out"]}}
{"project": "FFmpeg", "commit_id": "15ccaa344c4f645ae791aafecdef3d886e196127", "target": 1, "func": "void dct32(INTFLOAT *out, const INTFLOAT *tab)\n\n{\n\n    INTFLOAT tmp0, tmp1;\n\n\n\n    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,\n\n             val8 , val9 , val10, val11, val12, val13, val14, val15,\n\n             val16, val17, val18, val19, val20, val21, val22, val23,\n\n             val24, val25, val26, val27, val28, val29, val30, val31;\n\n\n\n    /* pass 1 */\n\n    BF0( 0, 31, COS0_0 , 1);\n\n    BF0(15, 16, COS0_15, 5);\n\n    /* pass 2 */\n\n    BF( 0, 15, COS1_0 , 1);\n\n    BF(16, 31,-COS1_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 7, 24, COS0_7 , 1);\n\n    BF0( 8, 23, COS0_8 , 1);\n\n    /* pass 2 */\n\n    BF( 7,  8, COS1_7 , 4);\n\n    BF(23, 24,-COS1_7 , 4);\n\n    /* pass 3 */\n\n    BF( 0,  7, COS2_0 , 1);\n\n    BF( 8, 15,-COS2_0 , 1);\n\n    BF(16, 23, COS2_0 , 1);\n\n    BF(24, 31,-COS2_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 3, 28, COS0_3 , 1);\n\n    BF0(12, 19, COS0_12, 2);\n\n    /* pass 2 */\n\n    BF( 3, 12, COS1_3 , 1);\n\n    BF(19, 28,-COS1_3 , 1);\n\n    /* pass 1 */\n\n    BF0( 4, 27, COS0_4 , 1);\n\n    BF0(11, 20, COS0_11, 2);\n\n    /* pass 2 */\n\n    BF( 4, 11, COS1_4 , 1);\n\n    BF(20, 27,-COS1_4 , 1);\n\n    /* pass 3 */\n\n    BF( 3,  4, COS2_3 , 3);\n\n    BF(11, 12,-COS2_3 , 3);\n\n    BF(19, 20, COS2_3 , 3);\n\n    BF(27, 28,-COS2_3 , 3);\n\n    /* pass 4 */\n\n    BF( 0,  3, COS3_0 , 1);\n\n    BF( 4,  7,-COS3_0 , 1);\n\n    BF( 8, 11, COS3_0 , 1);\n\n    BF(12, 15,-COS3_0 , 1);\n\n    BF(16, 19, COS3_0 , 1);\n\n    BF(20, 23,-COS3_0 , 1);\n\n    BF(24, 27, COS3_0 , 1);\n\n    BF(28, 31,-COS3_0 , 1);\n\n\n\n\n\n\n\n    /* pass 1 */\n\n    BF0( 1, 30, COS0_1 , 1);\n\n    BF0(14, 17, COS0_14, 3);\n\n    /* pass 2 */\n\n    BF( 1, 14, COS1_1 , 1);\n\n    BF(17, 30,-COS1_1 , 1);\n\n    /* pass 1 */\n\n    BF0( 6, 25, COS0_6 , 1);\n\n    BF0( 9, 22, COS0_9 , 1);\n\n    /* pass 2 */\n\n    BF( 6,  9, COS1_6 , 2);\n\n    BF(22, 25,-COS1_6 , 2);\n\n    /* pass 3 */\n\n    BF( 1,  6, COS2_1 , 1);\n\n    BF( 9, 14,-COS2_1 , 1);\n\n    BF(17, 22, COS2_1 , 1);\n\n    BF(25, 30,-COS2_1 , 1);\n\n\n\n    /* pass 1 */\n\n    BF0( 2, 29, COS0_2 , 1);\n\n    BF0(13, 18, COS0_13, 3);\n\n    /* pass 2 */\n\n    BF( 2, 13, COS1_2 , 1);\n\n    BF(18, 29,-COS1_2 , 1);\n\n    /* pass 1 */\n\n    BF0( 5, 26, COS0_5 , 1);\n\n    BF0(10, 21, COS0_10, 1);\n\n    /* pass 2 */\n\n    BF( 5, 10, COS1_5 , 2);\n\n    BF(21, 26,-COS1_5 , 2);\n\n    /* pass 3 */\n\n    BF( 2,  5, COS2_2 , 1);\n\n    BF(10, 13,-COS2_2 , 1);\n\n    BF(18, 21, COS2_2 , 1);\n\n    BF(26, 29,-COS2_2 , 1);\n\n    /* pass 4 */\n\n    BF( 1,  2, COS3_1 , 2);\n\n    BF( 5,  6,-COS3_1 , 2);\n\n    BF( 9, 10, COS3_1 , 2);\n\n    BF(13, 14,-COS3_1 , 2);\n\n    BF(17, 18, COS3_1 , 2);\n\n    BF(21, 22,-COS3_1 , 2);\n\n    BF(25, 26, COS3_1 , 2);\n\n    BF(29, 30,-COS3_1 , 2);\n\n\n\n    /* pass 5 */\n\n    BF1( 0,  1,  2,  3);\n\n    BF2( 4,  5,  6,  7);\n\n    BF1( 8,  9, 10, 11);\n\n    BF2(12, 13, 14, 15);\n\n    BF1(16, 17, 18, 19);\n\n    BF2(20, 21, 22, 23);\n\n    BF1(24, 25, 26, 27);\n\n    BF2(28, 29, 30, 31);\n\n\n\n    /* pass 6 */\n\n\n\n    ADD( 8, 12);\n\n    ADD(12, 10);\n\n    ADD(10, 14);\n\n    ADD(14,  9);\n\n    ADD( 9, 13);\n\n    ADD(13, 11);\n\n    ADD(11, 15);\n\n\n\n    out[ 0] = val0;\n\n    out[16] = val1;\n\n    out[ 8] = val2;\n\n    out[24] = val3;\n\n    out[ 4] = val4;\n\n    out[20] = val5;\n\n    out[12] = val6;\n\n    out[28] = val7;\n\n    out[ 2] = val8;\n\n    out[18] = val9;\n\n    out[10] = val10;\n\n    out[26] = val11;\n\n    out[ 6] = val12;\n\n    out[22] = val13;\n\n    out[14] = val14;\n\n    out[30] = val15;\n\n\n\n    ADD(24, 28);\n\n    ADD(28, 26);\n\n    ADD(26, 30);\n\n    ADD(30, 25);\n\n    ADD(25, 29);\n\n    ADD(29, 27);\n\n    ADD(27, 31);\n\n\n\n    out[ 1] = val16 + val24;\n\n    out[17] = val17 + val25;\n\n    out[ 9] = val18 + val26;\n\n    out[25] = val19 + val27;\n\n    out[ 5] = val20 + val28;\n\n    out[21] = val21 + val29;\n\n    out[13] = val22 + val30;\n\n    out[29] = val23 + val31;\n\n    out[ 3] = val24 + val20;\n\n    out[19] = val25 + val21;\n\n    out[11] = val26 + val22;\n\n    out[27] = val27 + val23;\n\n    out[ 7] = val28 + val18;\n\n    out[23] = val29 + val19;\n\n    out[15] = val30 + val17;\n\n    out[31] = val31;\n\n}\n", "idx": 10699, "substitutes": {"out": ["output", "obj", "io", "ch", "list", "p", "var", "o", "OUT", "buf", "pos", "outs", "ou", "txt", "Out", "in", "j", "t", "new", "os", "tmp", "cmd", "str", "w", "serv", "table", "batch", "OU"], "tab": ["obj", "acc", "tr", "tx", "lib", "ctrl", "cell", "var", "seq", "ind", "circ", "nt", "cur", "ref", "ab", "terms", "txt", "term", "cont", "pb", "ctx", "ctr", "tmp", "table", "Tab", " tmp", "ij"], "tmp0": ["mp1", " tmp6", "tmp6", "mp0", "td0", "mp6", "tmp5", "td6", "td5", "mp5", "td1", " tmp5"], "tmp1": ["temp1", " tmp4", "temp2", "tmp5", "tmp4", "temp5", "temp4", " tmp2", "txt4", "tmp2", "txt2", " tmp5", "txt1", "txt5"], "val0": ["valid0", "py9", "py1", "valid9", "py0", "py20", "valid20", "valid1"], "val1": ["value11", "test01", "value1", "test11", "test1", "val01", "value01", " val01"], "val2": ["VALtwo", "valTwo", "val02", "cho02", "choTwo", " valTwo", "VAL02", "VALTwo", "cho2", "valtwo", "VAL2", " valtwo", " val02", "chotwo"], "val3": ["item3", "item11", "item4", "eval3", "eval03", "eval4", "val03", "item03", "eval11", " val03"], "val4": ["val44", "valid3", "valid6", "eval44", "eval3", "eval4", "eval6", "valid4", " val44", "valid44"], "val5": ["al25", "eval45", "val45", "al15", " val45", "al5", "eval5", "eval15", "al45", "eval25"], "val6": ["rel06", "cal06", "vol26", "vol6", "cal26", "rel16", "val06", "vol16", "rel6", "rel26", "vol06", "cal16", "cal6"], "val7": ["try7", "eval17", "value17", "value77", "val77", "try07", "try77", "eval77", "val07", "try17", "eval07", "value07", "value7", "eval7"], "val8": ["dim15", "vol9", "cho15", "vol18", "dim9", "vol15", "vol8", "cho8", "cho18", "dim18", "cho9", "dim8"], "val9": [" val09", "val99", "cal19", "Val19", " val99", "cal99", "cal9", "Val99", "cal09", "val09", "Val09", "Val9"], "val10": ["vol14", "it10", "it12", "it14", "vol12", "vol11", "it11", "vol10"], "val11": ["valid11", "eval17", "eval14", "valid12", "valid14", "eval11", "valid17", "eval12"], "val12": ["id15", "id16", "vol12", "vol11", "vol15", "eval16", "id11", "id12", "vol16", "eval11", "eval15", "eval12"], "val13": ["dim13", "eval13", "eval17", "dim16", "dim17", "dim07", "def13", "val07", "eval16", "eval07", "def17", "def07", "def16"], "val14": ["value15", "value14", "value17", "vol14", "li17", "vol15", "li15", "li14", "li16", "vol17", "vol16", "value16"], "val15": ["valid30", "eval17", "valid12", "vol12", "eval30", "vol15", "valid15", "vol17", "valid17", "eval15", "eval12", "vol30"], "val16": ["test16", "test17", "eval17", "vol18", "vol15", "eval18", "eval16", "vol17", "vol16", "eval15", "test15", "test18"], "val17": ["valid16", "eval07", "eval17", "valid27", "value17", "value07", "valid07", "val07", "value27", "eval16", "valid17", "value16", "eval27"], "val18": ["item23", "item19", "eval19", "valid48", "eval48", "valid18", "eval18", "eval23", "item18", "val48", "valid19", "item48", "valid23"], "val19": ["vol24", "vol19", "item23", "item19", "eval17", "eval19", "item24", "item17", "eval24", "vol23", "vol17", "eval23"], "val20": ["vol60", "test60", "vol19", "eval10", "eval20", "test19", "eval19", "val60", "test10", "test20", "eval60", "vol20", "vol10"], "val21": ["dim21", "dim22", "ul23", "rel23", "rel28", "rel21", "ul21", "ul28", "dim28", "rel22", "ul22", "dim23"], "val22": ["cal28", "all28", "vol22", "all21", "vol26", "cal26", "vol21", "cal22", "all22", "vol28", "all26", "cal21"], "val23": ["ver23", "ver3", "vol26", "eval3", "vol3", "vol25", "eval23", "ver25", "vol23", "eval26", "ver26", "eval25"], "val24": ["al29", "item23", "al27", "item24", "al24", "al23", "item29", "item27"], "val25": ["test26", "val34", "item25", "test34", "item34", "item26", "test27", "test25", "item27", " val34"], "val26": ["valid30", "ival30", "valid25", "eval19", "valid26", "eval30", "ival19", "eval26", "ival25", "valid19", "ival26", "eval25"], "val27": ["eval25", "VAL25", "VAL27", "VAL29", "eval26", "eval29", "eval27", "VAL26"], "val28": [" val38", "eval28", "def29", "def38", "def23", "def28", "eval29", "val38", "eval38", "eval23"], "val29": ["val39", "eval39", "ival39", "eval28", "ival28", "ival27", "ival29", "eval29", "eval27", " val39"], "val30": ["ul30", "ul29", "val34", "VAL29", "ul31", "VAL31", "VAL30", "VAL34", "ul34", " val34"], "val31": ["valid34", "valid31", "valid28", "val34", "valid27", "al28", "bl28", "bl31", "al31", "al34", "bl34", "bl27", "al27"]}}
{"project": "qemu", "commit_id": "3558f8055f37a34762b7a2a0f02687e6eeab893d", "target": 0, "func": "static inline void gen_op_movl_seg_T0_vm(int seg_reg)\n\n{\n\n    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);\n\n    tcg_gen_st32_tl(cpu_T[0], cpu_env, \n\n                    offsetof(CPUX86State,segs[seg_reg].selector));\n\n    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);\n\n    tcg_gen_st_tl(cpu_T[0], cpu_env, \n\n                  offsetof(CPUX86State,segs[seg_reg].base));\n\n}\n", "idx": 10721, "substitutes": {"seg_reg": ["seg2register", "segment_Reg", "segin_num", "sep_rec", "seg_msg", "seg_num", "seg_Reg", "segin_register", "seg__reg", "seg2num", "seg__num", "seg__rec", "sep_reg", "segment_msg", "segin_reg", "seg__Reg", "seg__register", "seg2reg", "segment_reg", "seg_rec", "seg_register", "sep_Reg"]}}
{"project": "FFmpeg", "commit_id": "5a446bc88e49cc6400d0c646ca1eb540a727c9de", "target": 1, "func": "static void vc1_v_overlap_c(uint8_t* src, int stride)\n\n{\n\n    int i;\n\n    int a, b, c, d;\n\n    int d1, d2;\n\n    int rnd = 1;\n\n    for(i = 0; i < 8; i++) {\n\n        a = src[-2*stride];\n\n        b = src[-stride];\n\n        c = src[0];\n\n        d = src[stride];\n\n        d1 = (a - d + 3 + rnd) >> 3;\n\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n\n\n        src[-2*stride] = a - d1;\n\n        src[-stride] = b - d2;\n\n        src[0] = c + d2;\n\n        src[stride] = d + d1;\n\n        src++;\n\n        rnd = !rnd;\n\n    }\n\n}\n", "idx": 10723, "substitutes": {"src": ["usc", "proc", "vp", "ins", "hl", "stack", "ser", "rl", "r", "scan", "check", "str", "sr", "ij", "slice", "result", "ur", "conv", "tr", "tp", "source", "rb", "RC", "iter", "bc", "sec", "rob", "ptr", "usr", "txt", "rel", "aux", "sur", "sb", "comp", "rt", "sc", "ls", "img", "syn", "look", "spec", "sl", "url", "rs", "req", "err", "stream", "sub", "th", "cur", "unc", "supp", "impl", "sw", "bb", "s", "iv", "loc", "vc", "arc", "lib", "sync", "secure", "ack", "pkg", "np", "cb", "addr", "dest", "ssl", "rc", "gc", "input", "ctr", "via", "bh", "sn", "load", "stats", "st", "ul", "stat", "fc", "inst", "sys"], "stride": [" strride", "stided", "driverride", " strid", "drider", "strine", "scoperide", "stringided", " strider", "stringade", "striden", "strride", "STRgrade", "strider", "strension", " strade", "STRension", "privine", "slice", "provride", "drride", "stockride", "driveriden", "provice", "stringid", "stockiden", "arrided", "STRiden", "strade", "stiding", "frride", "strend", "striding", "strice", "frider", "prividing", "stine", "STRride", "slride", "STRider", "arrider", "arride", "dride", "frend", "slided", "slide", "stringide", "provide", "STRide", "stension", "STRiding", "scopeension", "STRend", "driveride", "strgrade", "arrride", "privride", "STRided", "scopeide", "drivergrade", "privide", "slid", "stockgrade", "STRice", "strid", "fride", "slade", " strided", "STRine", "scopeided", "stockide", "strided", "stide", "drend"], "i": [" m", "ai", "status", "I", "at", "me", "li", "ie", "init", " I", "print", "p", "o", "sim", "ex", "ind", "ui", " n", "ip", "m", "l", " multi", "ti", "ic", "ish", "us", "mi", "index", "is", " x", "im", "ix", "j", "n", "iu", "ci", "phi", "v", "xi", "e", "multi", "qi", "bi", "di", "pi", "si", "it", "x", "batch", "ini", " ii", " bi", " j", "out", "ii"], "a": ["ba", " ca", "na", "la", "aj", "ai", "va", "at", "ao", "up", "ak", "as", "area", "p", "ach", "o", "an", "au", "am", "aaa", "da", "l", "ae", "ata", "ap", "ab", "ia", "ea", " ba", "aff", "ta", "ga", "ma", "alpha", "ac", "ace", "e", "A", "h", "sa", "w", " at", "apa", "xa", "aa", "app", "oa", "ar", "ca", "pa"], "b": ["ba", "be", "u", "bf", "ub", "back", "bu", "base", "rb", "p", "bl", "f", "B", "bc", "g", "l", "fb", "ab", "cb", "bs", "r", "j", "br", "n", "y", "ad", "eb", "v", "bo", "e", "sb", "h", "bi", "bb", "ob", "by", "nb", "z", "gb", "ib", "db", "bar", "s", "wb"], "c": ["col", "u", "con", "code", "ch", "ct", "cut", "ec", "p", "f", "cp", "cf", "dc", "cat", "bc", "g", "cs", "tc", "cd", "l", "m", "cb", "cc", "ce", "r", "chain", "cod", "cont", "ad", "ac", "ci", "rc", "lc", "e", "cn", "uc", "h", "cm", "w", "fc", "sc", "z", "C", "co", "cr", "ca"], "d": ["td", "dd", "dos", "be", "u", "p", "o", "dev", "f", "df", "ld", "da", "dc", "dx", "g", "l", "m", "cd", "sd", "D", "dn", "dra", "r", "md", "de", "n", "ad", "t", "dom", "v", "dir", "e", "ed", "du", "h", "dat", "di", "w", "bd", "diff", "z", "db", "s", "dh", "nd", "dt", "ds", "dr"], "d1": ["D3", " d10", "l2", "l14", "dn14", "dh001", "l0", "dh0", "l9", "p1", "dt10", "D2", "dn2", " d0", "p9", "dn3", "dt1", " daj", "dtaj", "r1", "p3", "l001", "dh3", "d14", "D1", "p2", " d9", "d10", "dh1", "dt2", "raj", "d9", "d001", "l3", " d3", "d0", "d3", "l1", "r10", "daj", "dn1", "r2", " d001", "D14"], "d2": ["dtwo", "D3", "l2", "D21", "D02", "xtwo", "x1", "D2", "d21", " d0", "dt02", "d02", "da2", " dtwo", "D1", " d02", " d21", "x3", "dt2", "D0", "ltwo", "l3", " d3", "d0", "d3", "x2", "l1", "Dtwo", "da21", "da0", "da1"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n", "idx": 10727, "substitutes": {"d": ["idd", "td", "dd", "id", "fd", "amd", "send", "add", "q", "and", "ct", "p", "o", "dev", "f", "df", "ind", "od", "ld", "da", "dc", "dx", "g", "m", "pd", "nd", "cd", "hd", "admin", "did", "mod", "dn", "D", "details", "md", "ord", "gd", "de", "j", "done", "n", "y", "ad", "dl", "rd", "e", "ed", "red", "du", "di", "dat", "w", "bd", "dump", "ard", "z", "db", "dm", "dh", "debug", "sd", "dt", "draw", "ds", "dr"], "alloc": ["oc", "empty", "cmp", "oca", "init", "req", "go", "ack", "buf", "dev", "pool", "nt", "slot", "iat", "gr", "pkg", "pos", "ref", "zero", "raw", "util", "urg", "rac", "all", "mem", "inv", "aux", "ac", "ctx", "reg", "info", "gc", "fat", "cmd", "hw", "res", "cu", "org", "usage", "access", "loc", "vol", "sys"], "entry": ["command", "key", "id", "RY", "address", "record", "ie", "q", "or", "cell", "event", "counter", "ident", "field", "insert", "ry", "enter", "nt", "slot", "error", "inter", "def", "zero", "attr", "ptr", "port", "rance", "window", "index", "try", "r", "row", "attribute", "import", "data", "ries", "needed", "connection", "se", "cont", "count", "info", "action", "e", "ace", "query", "cmd", "vid", "ent", "ient", "x", "seed", "space", "it", "Entry", "name", "offset", "size"], "vector": ["command", "tr", "address", "buffer", "feature", "device", "counter", "ar", "history", "ve", "var", "value", "shock", "iter", "sector", "variable", "size", "vec", "sequence", "sv", "detail", "serial", "port", "relation", "window", "ver", "index", "clock", "ser", "row", "translation", "version", "header", "direction", "v", "V", "gradient", "ensor", "action", "ion", "transform", "expression", "ror", "product", "controller", "x", "ctors", "driver", "vr", "description", "response", "conv", "length", "Vector", "material", "number"], "control": ["command", "shift", "success", "status", "config", "ctrl", "trl", "lr", "cell", "contact", "form", "value", "critical", "controlled", "normal", "capacity", "vec", "rol", "label", "sequence", "ctl", "shell", "filter", "hold", "handle", "clock", "bit", "cont", "scroll", "script", "index", "version", "data", "check", "rc", "forward", "ctr", "cmd", "Control", "controller", "sc", "driver", "card", "high"], "addr": ["prefix", "add", "uv", "attr", "arch", "r", "t", "cmd", "elt", "w", "aug", "ar", "arg", "arr", "art", "address", "arp", "at", "init", "asm", "g", "gate", "gz", "ptr", "urg", "ix", "aux", "rt", "adj", "alias", "atom", "debug", "state", "obj", "id", "a", "Address", "order", "req", "err", "k", "point", "hash", "nt", "ip", "l", "pos", "ref", "admin", "i", "ad", "now", "host", "sw", "ag", "db", "vr", "loc", "ret", "align", "off", "aj", "q", "ack", "p", "pad", "act", "hop", "pkg", "np", "adr", "handle", "ord", "alt", "inv", "aff", "v", "ress", "eth", "res", "x", "coord", "msg", "offset", "dr"]}}
{"project": "qemu", "commit_id": "d279279e2b5cd40dbcc863fb66a695990f304077", "target": 1, "func": "static void gen_rdhwr(DisasContext *ctx, int rt, int rd)\n\n{\n\n    TCGv t0;\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* The Linux kernel will emulate rdhwr if it's not supported natively.\n\n       Therefore only check the ISA in system mode.  */\n\n    check_insn(ctx, ISA_MIPS32R2);\n\n#endif\n\n    t0 = tcg_temp_new();\n\n\n\n    switch (rd) {\n\n    case 0:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cpunum(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 1:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_synci_step(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 2:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cc(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 3:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_ccres(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 29:\n\n#if defined(CONFIG_USER_ONLY)\n\n        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#else\n\n        /* XXX: Some CPUs implement this in hardware.\n\n           Not supported yet. */\n\n#endif\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"rdhwr\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 10730, "substitutes": {"ctx": ["jac", "tm", "ck", "obj", "xy", "tx", "cmp", "qq", "prefix", "std", " cx", "req", "ct", "func", "kt", "cl", "resp", "height", "Context", "cp", "nt", "cf", "xc", "iat", "bc", "act", "pkg", "tc", "jp", "wx", "np", "cb", "unc", "ctl", "stack", "cc", "ka", "txt", "handle", "ppo", "qt", "js", "cas", "conn", "wd", "info", "cfg", "wcs", "gc", "ctr", "c", "anc", "cmd", "cn", "setup", "kb", "hw", "nc", "kw", "cm", "cpu", "cu", "sc", "context", "fx", "cv", "history", "work", "ca"], "rt": ["tt", "yt", "lt", "fin", "tx", "net", "pt", "rb", "rs", "ct", "wind", "wit", "ri", "RT", "rf", "rec", "unit", "nt", "ut", "rw", "wr", "ret", "rn", "hd", "ptr", "vt", "rr", "ti", "txt", "adr", "lat", "rl", "r", "try", "rx", "root", "rat", "rc", "rot", "fr", "pr", "rh", "feat", "rect", "wt", "rin", "dist", "sys", "res", "rm", "it", "gt", "round", "vr", "bt", "nd", "dt", "rid", "mt"], "rd": ["td", "rust", "dd", "hr", "rb", "rs", "ct", "ri", "od", "ld", "d", "wr", "rw", "xd", "cd", "ud", "rn", "rr", "rend", "md", "r", "rg", "rc", "rh", "red", "cmd", "ped", "mid", "ro", "hyd", "bd", "rss", "RD", "rm", "cr", "nd", "rid", "sd", "ird"], "t0": ["tau", "tbase", "t\t", "vt050", "t256", "set0", "kt\t", "tcMac", "p7", "tInfo", "gZero", "dtZero", "T1", "dt1", "detInfo", "ut050", "time0", "t528", " t8", "tfunc", "t2", "tMac", "tanet", "tcZero", "dt7", " t528", " t050", "kt780", "str0", "tnull", "TZero", "str780", "vtfunc", "dt0", "str\t", "g0", " t2", " tZero", "Tnet", "tcfunc", "stZero", "tanull", "td256", "detMac", "to528", "p0", " tbase", " tnet", "kt0", "p3", " t1", "tcthis", "pt0", "ta256", "tc256", "to255", "T3", "kt8", "dt2", "t780", "to0", "pt528", " t7", "st0", "tc0", "timeZero", "tcInfo", "td0", "ptZero", "det0", "taZero", "T7", "T0", "kt050", "timeInfo", "ct0", "utfunc", " tau", "set780", "tZero", "ktbase", "t8", "t1", "setMac", "detZero", "tcbase", "gInfo", "T2", "tc780", "timeau", "tcau", "tcnull", "tdthis", "ta0", " tInfo", "ct\t", "tdnull", "t255", "t7", "tnet", "ut0", "tthis", "strMac", "p2", "vt0", "tc8", "gMac", "pt255", " t3", "tc050", "ct780", "toZero", " t255", "t3", "tathis", "t050"]}}
{"project": "qemu", "commit_id": "af01492755b82ccaf0d15014477b34ba3ea643fc", "target": 1, "func": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n", "idx": 10735, "substitutes": {"dev": ["usb", "doc", "hid", "obj", "dd", "off", "spec", "priv", "sky", "pt", "device", "cam", "go", "ev", "det", "proc", "devices", "ve", " Dev", "buf", "adv", "home", "pad", "nt", "d", " device", "def", "dis", "serial", "desc", "raw", "ver", "window", "mem", "md", "de", "data", "ad", "ctx", "dem", "DEV", "new", "v", "info", "conf", "conn", "unknown", "tech", "Dev", "cmd", "h", "Device", "des", "hw", "w", "debug", "sd", "pro", "stick", "out", "sys"], "errp": ["errP", " errP", " errps", "Erp", "Erps", "errps", "erP", "ErP", "erps", "erp"], "s": ["sq", "spec", "sl", "qs", "sol", "ats", "rs", "as", "hs", "sp", "gs", "sts", "ps", "g", "l", "sv", "es", "ses", "sam", "i", "bs", "so", "services", "aws", "is", "js", "pers", "S", "ss", "ts", "n", "y", "se", "t", "self", "v", "sb", "b", "c", "sa", "ns", "stats", "si", "set", "sis", "ls", "syn", "ds", "su", "sys", "store"]}}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "static int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n\n{\n\n    RangeCoder *c = &fs->c;\n\n    uint8_t state[CONTEXT_SIZE];\n\n    unsigned ps, i, context_count;\n\n    memset(state, 128, sizeof(state));\n\n\n\n    if (fs->ac > 1) {\n\n        for (i = 1; i < 256; i++) {\n\n            fs->c.one_state[i]        = f->state_transition[i];\n\n            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];\n\n        }\n\n    }\n\n\n\n    fs->slice_x      = get_symbol(c, state, 0) * f->width;\n\n    fs->slice_y      = get_symbol(c, state, 0) * f->height;\n\n    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;\n\n    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n\n\n    fs->slice_x     /= f->num_h_slices;\n\n    fs->slice_y     /= f->num_v_slices;\n\n    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;\n\n    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n\n    if ((unsigned)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n    if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < f->plane_count; i++) {\n\n        PlaneContext *const p = &fs->plane[i];\n\n        int idx               = get_symbol(c, state, 0);\n\n        if (idx > (unsigned)f->quant_table_count) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        p->quant_table_index = idx;\n\n        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n\n        context_count = f->context_count[idx];\n\n\n\n        if (p->context_count < context_count) {\n\n            av_freep(&p->state);\n\n            av_freep(&p->vlc_state);\n\n        }\n\n        p->context_count = context_count;\n\n    }\n\n\n\n    ps = get_symbol(c, state, 0);\n\n    if (ps == 1) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 1;\n\n    } else if (ps == 2) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 0;\n\n    } else if (ps == 3) {\n\n        f->cur->interlaced_frame = 0;\n\n    }\n\n    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);\n\n    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);\n\n\n\n    if (av_image_check_sar(f->width, f->height,\n\n                           f->cur->sample_aspect_ratio) < 0) {\n\n        av_log(f->avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n\n               f->cur->sample_aspect_ratio.num,\n\n               f->cur->sample_aspect_ratio.den);\n\n        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10738, "substitutes": {"f": ["fal", "fo", "func", "m", "flow", "fa", "t", "fr", "w", "fee", "fit", "al", "call", "fl", "uf", "ff", "fff", "g", "um", "lf", "cal", "conf", "sf", "e", "z", "fab", "tf", "ef", "fw", "bf", "form", "df", "l", "ref", "fb", "fe", "_", "info", "fuel", "inf", "fac", "diff", "fed", "ft", "fd", "fi", "flag", "rf", "fp", "cf", "fm", "all", "cont", "of", "v", "h", "F", "fc", "full", "fx", "buff", "xf"], "fs": ["ms", "vs", "ats", "weights", "fts", "hs", "cs", "bits", "FS", "fps", "videos", "fields", "fr", "wcs", "os", "ips", "alls", "fee", "ims", "ums", "cells", "ports", "frames", "uf", "settings", "gs", "sts", "bc", "files", "outs", "args", "utils", "bs", "services", "js", "ss", "aux", "rets", "ics", "sf", "fits", "ows", "vals", "faces", "features", "ls", "tf", "flows", "fw", "bf", "qs", "rs", "df", "fb", "eks", "orts", "terms", "aints", "ts", "views", "ags", "reads", "ns", "s", "ds", "iffs", "obs", "alf", "fd", "fi", "fp", "cf", "fm", "bytes", "posts", "its", "ils", "uses", "irs", "Fs", "gc", "stats", "flags", "fc", "actions", "steps", "sys", "xf"], "c": ["u", "con", "pc", "config", "a", "ch", "code", "cus", "cam", "ct", "ec", "o", "cl", "cp", "cf", "xc", "dc", "bc", "g", "cat", "cs", "m", "tc", "l", "ae", "cd", "cb", "unc", "cc", "ce", "r", "chain", "cont", "icc", "n", "mc", "t", "ci", "ctx", "ac", "count", "v", "lc", "conf", "rc", "cache", "e", "gc", "b", "cn", "uc", "h", "com", "comp", "cm", "nc", "cu", "fc", "sc", "mac", "z", "context", "C", "co", "s", "cv", "cr", "ca"], "state": ["config", "print", "range", "post", "block", "m", "cs", "storage", "data", "t", "str", "slice", "result", "user", "history", "size", "output", "key", "ate", "status", "al", "resource", "code", "init", "job", "STATE", " states", "request", "test", "version", "node", "new", "count", "close", "rule", " State", "seed", "states", "role", "spec", "id", "buffer", "stroke", "area", "component", "scope", "l", "type", "local", "sequence", "State", "_", "index", "n", "zone", "info", "start", "er", "it", "s", "space", "style", "out", "pointer", "base", "q", "list", "port", "handle", "is", "root", "commit", "cache", "lock", "h", "tag", "stat", "st", "name", "length", "store"], "ps": [" rows", "aps", " ip", " pc", " sp", "fp", " ss", " states", " ops", "cs", " pi", "ptr", "bytes", " pos", " flags", " seq", "PS", "ops", "ips", " points", " PS", " pp", " cs", "s", " cp", " parent", "pa"], "i": ["key", "ami", "id", "ai", "I", "me", "PI", "li", "ei", "uri", "q", "init", "print", "list", "span", "ri", "ii", "point", "sim", "ex", "ind", "o", "ui", "iter", "name", "ip", "g", "m", "ki", "ti", "ic", "cli", "in", "us", "index", "mi", "chain", "is", "j", "ir", "ix", "im", "try", "n", "iu", "ci", "\u0438", "phi", "zi", "info", "xi", "gu", "multi", "qi", "remote", "gi", "bi", "di", "pi", "si", "er", "it", "mac", "batch", "ini", "oi", "ji", "ims", "ij"], "context_count": ["context_c", " context_c", "context1name", " context_name", " context_cache", "context1c", "context_cache", "context1cache", "context_name", "context1count"], "p": ["op", "u", "pc", "a", "at", "o", "pair", "cp", "d", "g", "m", "l", "ap", "pos", "port", "lp", "r", "j", "n", "P", "t", "v", "e", "h", "pa"]}}
{"project": "qemu", "commit_id": "b60fae32ff33cbaab76d14cc5f55b979cf58516d", "target": 1, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                            sizeof(diag_501), 0) ||\n\n        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,\n\n                            sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10741, "substitutes": {"cs": ["ms", "aps", "Cs", "pc", "cus", "cks", "rs", "css", "ct", "hs", "sts", "CS", "cp", "ps", "cf", "bc", "ins", "bs", "cc", "iss", "ce", "js", "ys", "ss", "ts", "ix", "ci", "ctx", "lc", "wcs", "gc", "ctr", "c", "cn", "acs", "ns", "cm", "fs", "nc", "ks", "sc", "fc", "ces", "ls", "s", "ims", "vc", "ds"], "bp": ["xp", "ipp", "bj", "pc", "tp", "arp", "bf", "pp", "gp", "p", "sp", "cp", "BP", "fp", "bc", "vp", "jp", "np", "lip", "fb", " BP", "ep", "cb", "bn", "lp", "bs", "bsp", "bg", "hp", "br", "pb", "eb", "isp", "bps", "sb", "b", "wp", "bh", "kb", "ijk", "bi", "dp", "bb", "ump", "php", "nb", "ib", "db", "bt", "pa"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n", "idx": 10744, "substitutes": {"rdma_ram_block": ["rdma_ramacBlock", "rdma_rom_Block", "rdma_mem_lock", "rdma_rom_block", "rdma_ram__data", "rdma_mem_bl", "rdma_ramacdata", "rdma_ram__Block", "rdma_ramacblocks", "rdma_rom_data", "rdma_rom_blocks", "rdma_ram_blocks", "rdma_mem_block", "rdma_ram_data", "rdma_ramacblock", "rdma_ram_lock", "rdma_ram_Block", "rdma_ram__block", "rdma_ram__blocks", "rdma_ram_bl"], "i": ["ami", " wi", "ai", "I", "li", " I", " di", "k", "ri", " e", " k", "m", "l", " pi", "ti", " key", " ti", " init", " h", "mi", " im", "j", " vi", "iu", "t", "zi", " l", " v", "phi", "v", " mi", "xi", "qi", " hi", "multi", "gi", " c", "bi", " index", "di", " info", "ij", "pi", "si", " mu", " err", " bi", "oi", "hi", " j", "ii"]}}
{"project": "FFmpeg", "commit_id": "a1e093a6fb324612266d40e3168a14f58adab265", "target": 0, "func": "static int decode_element(AVCodecContext *avctx, void *data, int ch_index,\n\n                          int channels)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;\n\n    uint32_t output_samples;\n\n    int i, ch;\n\n\n\n    skip_bits(&alac->gb, 4);  /* element instance tag */\n\n    skip_bits(&alac->gb, 12); /* unused header bits */\n\n\n\n    /* the number of output samples is stored in the frame */\n\n    has_size = get_bits1(&alac->gb);\n\n\n\n    alac->extra_bits = get_bits(&alac->gb, 2) << 3;\n\n    bps = alac->sample_size - alac->extra_bits + channels - 1;\n\n    if (bps > 32) {\n\n        av_log(avctx, AV_LOG_ERROR, \"bps is unsupported: %d\\n\", bps);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* whether the frame is compressed */\n\n    is_compressed = !get_bits1(&alac->gb);\n\n\n\n    if (has_size)\n\n        output_samples = get_bits_long(&alac->gb, 32);\n\n    else\n\n        output_samples = alac->max_samples_per_frame;\n\n    if (!output_samples || output_samples > alac->max_samples_per_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid samples per frame: %d\\n\",\n\n               output_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!alac->nb_samples) {\n\n        /* get output buffer */\n\n        alac->frame.nb_samples = output_samples;\n\n        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n    } else if (output_samples != alac->nb_samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sample count mismatch: %u != %d\\n\",\n\n               output_samples, alac->nb_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    alac->nb_samples = output_samples;\n\n    if (alac->direct_output) {\n\n        for (ch = 0; ch < channels; ch++)\n\n            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];\n\n    }\n\n\n\n    if (is_compressed) {\n\n        int16_t lpc_coefs[2][32];\n\n        int lpc_order[2];\n\n        int prediction_type[2];\n\n        int lpc_quant[2];\n\n        int rice_history_mult[2];\n\n\n\n        decorr_shift       = get_bits(&alac->gb, 8);\n\n        decorr_left_weight = get_bits(&alac->gb, 8);\n\n\n\n        for (ch = 0; ch < channels; ch++) {\n\n            prediction_type[ch]   = get_bits(&alac->gb, 4);\n\n            lpc_quant[ch]         = get_bits(&alac->gb, 4);\n\n            rice_history_mult[ch] = get_bits(&alac->gb, 3);\n\n            lpc_order[ch]         = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = lpc_order[ch] - 1; i >= 0; i--)\n\n                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);\n\n        }\n\n\n\n        if (alac->extra_bits) {\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                if(get_bits_left(&alac->gb) <= 0)\n\n                    return -1;\n\n                for (ch = 0; ch < channels; ch++)\n\n                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);\n\n            }\n\n        }\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],\n\n                            alac->nb_samples, bps,\n\n                            rice_history_mult[ch] * alac->rice_history_mult / 4);\n\n            if(ret<0)\n\n                return ret;\n\n\n\n            /* adaptive FIR filter */\n\n            if (prediction_type[ch] == 15) {\n\n                /* Prediction type 15 runs the adaptive FIR twice.\n\n                 * The first pass uses the special-case coef_num = 31, while\n\n                 * the second pass uses the coefs from the bitstream.\n\n                 *\n\n                 * However, this prediction type is not currently used by the\n\n                 * reference encoder.\n\n                 */\n\n                lpc_prediction(alac->predict_error_buffer[ch],\n\n                               alac->predict_error_buffer[ch],\n\n                               alac->nb_samples, bps, NULL, 31, 0);\n\n            } else if (prediction_type[ch] > 0) {\n\n                av_log(avctx, AV_LOG_WARNING, \"unknown prediction type: %i\\n\",\n\n                       prediction_type[ch]);\n\n            }\n\n            lpc_prediction(alac->predict_error_buffer[ch],\n\n                           alac->output_samples_buffer[ch], alac->nb_samples,\n\n                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        for (i = 0; i < alac->nb_samples; i++) {\n\n            if(get_bits_left(&alac->gb) <= 0)\n\n                return -1;\n\n            for (ch = 0; ch < channels; ch++) {\n\n                alac->output_samples_buffer[ch][i] =\n\n                         get_sbits_long(&alac->gb, alac->sample_size);\n\n            }\n\n        }\n\n        alac->extra_bits   = 0;\n\n        decorr_shift       = 0;\n\n        decorr_left_weight = 0;\n\n    }\n\n\n\n    if (channels == 2 && decorr_left_weight) {\n\n        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,\n\n                           decorr_shift, decorr_left_weight);\n\n    }\n\n\n\n    if (alac->extra_bits) {\n\n        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,\n\n                          alac->extra_bits, channels, alac->nb_samples);\n\n    }\n\n\n\n    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {\n\n    switch(alac->sample_size) {\n\n    case 16: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n        }}\n\n        break;\n\n    case 24: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                alac->output_samples_buffer[ch][i] <<= 8;\n\n        }}\n\n        break;\n\n    }\n\n    }else{\n\n        switch(alac->sample_size) {\n\n        case 16: {\n\n            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 24: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 32: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10750, "substitutes": {"avctx": [" avcontext", "avconn", "avecontext", "averconfig", " avcc", "avsys", "ivcontext", "afkt", "avesys", "auctx", "vctl", "afconfig", "aukl", "averctx", "actcc", "avejac", "ajconn", " avctl", "afpkg", "avepkg", "wavctx", "avcontext", "averxc", "actconn", "afconn", "ivctx", "avercontext", "aveContext", "cvxc", "avjp", "ajctx", "ivctl", "cvcontext", "avekl", "avectx", "avconfig", "aveconn", "aveconfig", " avconn", "ajcc", "actcontext", " avtx", "averkl", "avejp", "avkt", "ajjac", "avctl", "afctx", "actobj", "averconn", "actjac", "vcontext", "ausys", "aveobj", "cvctx", "avxc", "avobj", "wavcontext", "avjac", "wavpkg", " avobj", "avcc", "vjac", "avekt", "averjp", " avxc", " avpkg", "ivjac", "averkt", "wavContext", " avContext", "avkl", "averpkg", "aversys", "aujp", "actctx", "cvtx", " avjac", "avertx", "avtx", "avpkg", "avContext", "vctx"], "data": ["output", "Data", "buffer", "text", "message", "a", "channel", "image", "stream", "value", "p", "buf", "o", "bin", "d", "block", "ata", "def", "raw", "window", "bytes", "input", "dat", "w", "batch", "DATA", "response", "out"], "ch_index": ["channel_ind", "channel_index", "ch2index", "channel_num", "ch_num", "ch2ind", "ch_ind", "ch_slice", "channel_slice", "ch2slice", "ch2num"], "channels": ["chopes", "echunks", " champs", "ichunks", " chains", " chunks", "tchannels", "tchunks", "Chunks", "achannels", "chunks", "ichannels", "cannels", "Channels", "tchars", "chains", "tchapters", "ichamps", "ichanches", "Champs", "achapters", "cunks", "chapters", " chanches", " chopes", "champs", "echains", "achars", "echannels", "cains", "achunks", "echopes", "chanches", "Chanches", "copes", "chars", "capters", "cars"], "alac": ["eliac", "valact", "attac", "ulica", "dalacc", "salach", "allAc", "alerac", "elacc", "malact", "aljac", "calic", "balax", " alAC", "elac", "calacl", "salam", "stalact", " aljac", "aliacc", "ialac", "attic", "aliAC", "calAc", "salAC", "flacs", "malAc", "isalacl", "alace", "talact", "aliac", "talAC", "aliam", "salacc", "balacc", "aliax", "valac", "stalac", "palacl", "malac", "allacl", "alerAC", "ulac", " alacc", "balsac", "talsac", "balacl", "aldac", "alica", "ulsac", " alact", "realac", "realic", "attiac", "aliace", "palacc", "malacc", "allacet", "flacc", "aldact", "talAc", "realact", "flac", "alax", "alacs", "palac", "amace", "palace", "allact", "calAC", "stalsac", "daljac", "amacl", "dalac", "talac", "alacl", "alAC", "caljac", "caliac", "attacc", "isalacc", "balact", "aracet", "aliacer", "alacc", "stalam", "arac", "amacc", "valacc", "balac", "stalic", "balam", "malic", "halAC", "attacl", "allam", "alic", "malsac", "attact", "alact", "stalacc", "balic", "salac", "staliac", "malAC", "ialacc", "aliic", " alacl", "alacer", "salacl", "aract", "balAC", "isalac", "ulact", "isalic", "aldica", "calac", "alacet", "halac", "salic", "dalacs", "amac", " alam", "ialax", "aric", "halact", "alAc", "aliact", "dalacl", "malacl", "aliacs", "aliach", "calacer", "realacet", "allic", "calacc", "stalach", "alam", "elic", "allAC", " aliac", " alic", " alax", "aliacl", "maliac", "saliac", "flacl", "alsac", "aldsac", "ialic", "allax", "daliac", "balAc", "aliiac", "stalica", "allacc", "allac", "talacc", "alach", "allacer", "halAc", "salact"], "has_size": [" has_sized", "has__size", "groups_sized", " has_Size", "has_length", "groups_size", "has_error", "has_Size", "has_small", "Has_size", "Has_Size", "has__Size", "groups_Size", " has_small", "has__small", "Has_length", "has_sized", "groups_error", "has__sized"], "bps": ["amps", "tops", "aps", "flows", "beta", "rots", "tp", "ats", "places", "eps", "bp", "los", "weights", "gs", "jobs", "ps", "phones", "tips", "points", "bits", "pins", "planes", "fps", "fixes", "bys", "xs", "bytes", "bs", "pps", "rate", "TPS", "posts", "its", "nets", "grades", "lbs", "ops", "plugins", "cats", "hops", "ips", "caps", "bis", "issues", "fs", "clips", "ls", "steps", "rates", "hz", "allows", "parts"], "is_compressed": ["is_compressor", "is_ompression", "is_cressor", "is_ompressed", "is_cressed", "is_buffressor", "is_cress", "isPcompression", "isPcompressed", "is_compress", "is_composed", "is_Compressor", "isPompression", "is_expression", "is_buffressed", "is_omposed", "is_buffress", "is_expressor", "is_exposed", "is_Compress", "isPompressed", "is_ompressor", "is_cression", "is_buffression", "is_expressed", "isPompressor", "is_Compressed", "isPcomposed", "is_compression", "is_Compression", "isPomposed", "isPcompressor", "is_Composed"], "decorr_shift": ["decorr_pad", "decorr___shift", "decor_offset", "decorr___pad", "decor_share", "decorr___share", "decorr_share", "decor_pad", "decor_shift", "decorr___offset", "decorr_offset"], "decorr_left_weight": ["decorr_left_width", "decorr_shift_weights", "decorr_leftnessweights", "decorr_leftnesswidth", "decorr_left_weights", "decorr_shift_width", "decorr_shift_weight", "decorr_leftnessshift", "decorr_shift_shift", "decorr_leftnessweight", "decorr_left_shift"], "ret": ["tf", "len", "tr", "reset", "uf", "summary", "RET", "resp", "reply", "f", "nt", "jp", "ref", "mt", "def", "txt", "alt", "mem", "ext", "aux", "mel", "new", "rem", "rets", "repl", "not", "val", "Ret", "tmp", "rt", "elt", "rew", "re", "res", "str", "it", "result", "img", "gt", "ll", "dt", "ft", "out"], "output_samples": ["output\u05bcsinounds", "output_ninks", "output_esucks", "output_genases", "output\u05bcsinlements", "output\u05bcsounds", "output_sounds", "output_tones", "output_examples", "output_symales", "output\u05bcsinamples", "output_pamples", "outputptsamples", "output_Sales", "output_csappings", "output_genodes", "output_tamples", "output_exlements", "output_symucks", "outputptsakes", "output_iamples", "output_nactly", "output_tactly", "output_eamps", "output_pamps", "output_exounds", "output_nutes", "output_svamps", "output_symims", "output_itsases", "output_saveamples", "output_csizes", "output_iakes", "output_sesinks", "output_csonents", "output_sinks", "outputptsaveakes", "output_itsonents", "output_wsales", "output_sales", "output_sesamps", "output_saveples", "output_sases", "output\u05bcsamps", "output_symamples", "output_genamples", "output_genonents", "output_ponents", "output_svamples", "output_sinamples", "output_itsodes", "output_nakes", "output\u05bcslements", "output_bamples", "output_sinlements", "output\u05bcsinamps", "output_csases", "outputptsaveamples", "output_sizes", "output_schanges", "output_wschanges", "output_eonents", "output\u05bcsamples", "output_nonents", "output_sakes", "output_sactly", "output_namples", "output_sinounds", "output_sesappings", "output_saveakes", "output_sesamples", "output_bamps", "output_bales", "output_namps", "output_symchanges", "output_svizes", "output_iples", "output_nappings", "output_nples", "output_tamps", "output_iamps", "output_csones", "output_sucks", "output_Samples", "output_nounds", "output_csinks", "output_Sounds", "output_nucks", "output_saveamps", "output_insamps", "output_csodes", "output_insones", "output_wsamples", "output_csamps", "output_sples", "output_Samps", "output_csamples", "output_examps", "output_symamps", "output_insamples", "output_nizes", "output_symutes", "output_eamples", "output_wsims", "output_esamps", "output_sappings", "output_eounds", "output_tizes", "outputptsamps", "output_slements", "output_sodes", "output_esutes", "output_sones", "output_esamples", "outputptsaveples", "output_samps", "output_Slements", "outputptsples", "output_sutes", "output_insizes", "output_pounds", "output_sims", "outputptsaveamps", "output_itsamples", "output_svactly", "output_sinamps", "output_sonents"], "i": ["ai", "I", "li", "q", "p", "ind", "ip", "m", "l", "ti", "mi", "index", "j", "ix", "y", "ci", "phi", "v", "b", "c", "bi", "pi", "si", "it", "x", "set", "ii"], "ch": ["col", "atch", "Ch", "uch", "kr", "chid", "ph", "hr", "gh", "pc", "channel", "q", "chan", "sch", "cor", "chn", "cell", "child", "k", "cut", "ach", "cl", "ay", "ich", "cp", "ind", "anch", "th", "cs", "cb", "wh", "cht", "cho", "br", "y", "ac", "count", "zh", "och", "mk", "chip", "chat", "c", "sh", "h", "kh", "bh", "cm", "bot", "tch", "ech", "x", "att", "batch", "CH", "ble", "ht", "sk"]}}
{"project": "FFmpeg", "commit_id": "57cc1ad35fd488c7a879661498f6f3508038d5a9", "target": 0, "func": "static av_always_inline float quantize_and_encode_band_cost_template(\n\n                                struct AACEncContext *s,\n\n                                PutBitContext *pb, const float *in,\n\n                                const float *scaled, int size, int scale_idx,\n\n                                int cb, const float lambda, const float uplim,\n\n                                int *bits, int BT_ZERO, int BT_UNSIGNED,\n\n                                int BT_PAIR, int BT_ESC)\n\n{\n\n    const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    const float  Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float CLIPPED_ESCAPE = 165140.0f*IQ;\n\n    int i, j, k;\n\n    float cost = 0;\n\n    const int dim = BT_PAIR ? 2 : 4;\n\n    int resbits = 0;\n\n    const float  Q34 = sqrtf(Q * sqrtf(Q));\n\n    const int range  = aac_cb_range[cb];\n\n    const int maxval = aac_cb_maxval[cb];\n\n    int off;\n\n\n\n    if (BT_ZERO) {\n\n        for (i = 0; i < size; i++)\n\n            cost += in[i]*in[i];\n\n        if (bits)\n\n            *bits = 0;\n\n        return cost * lambda;\n\n    }\n\n    if (!scaled) {\n\n        abs_pow34_v(s->scoefs, in, size);\n\n        scaled = s->scoefs;\n\n    }\n\n    quantize_bands(s->qcoefs, in, scaled, size, Q34, !BT_UNSIGNED, maxval);\n\n    if (BT_UNSIGNED) {\n\n        off = 0;\n\n    } else {\n\n        off = maxval;\n\n    }\n\n    for (i = 0; i < size; i += dim) {\n\n        const float *vec;\n\n        int *quants = s->qcoefs + i;\n\n        int curidx = 0;\n\n        int curbits;\n\n        float rd = 0.0f;\n\n        for (j = 0; j < dim; j++) {\n\n            curidx *= range;\n\n            curidx += quants[j] + off;\n\n        }\n\n        curbits =  ff_aac_spectral_bits[cb-1][curidx];\n\n        vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];\n\n        if (BT_UNSIGNED) {\n\n            for (k = 0; k < dim; k++) {\n\n                float t = fabsf(in[i+k]);\n\n                float di;\n\n                if (BT_ESC && vec[k] == 64.0f) { //FIXME: slow\n\n                    if (t >= CLIPPED_ESCAPE) {\n\n                        di = t - CLIPPED_ESCAPE;\n\n                        curbits += 21;\n\n                    } else {\n\n                        int c = av_clip(quant(t, Q), 0, 8191);\n\n                        di = t - c*cbrtf(c)*IQ;\n\n                        curbits += av_log2(c)*2 - 4 + 1;\n\n                    }\n\n                } else {\n\n                    di = t - vec[k]*IQ;\n\n                }\n\n                if (vec[k] != 0.0f)\n\n                    curbits++;\n\n                rd += di*di;\n\n            }\n\n        } else {\n\n            for (k = 0; k < dim; k++) {\n\n                float di = in[i+k] - vec[k]*IQ;\n\n                rd += di*di;\n\n            }\n\n        }\n\n        cost    += rd * lambda + curbits;\n\n        resbits += curbits;\n\n        if (cost >= uplim)\n\n            return uplim;\n\n        if (pb) {\n\n            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);\n\n            if (BT_UNSIGNED)\n\n                for (j = 0; j < dim; j++)\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)\n\n                        put_bits(pb, 1, in[i+j] < 0.0f);\n\n            if (BT_ESC) {\n\n                for (j = 0; j < 2; j++) {\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {\n\n                        int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191);\n\n                        int len = av_log2(coef);\n\n\n\n                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);\n\n                        put_bits(pb, len, coef & ((1 << len) - 1));\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (bits)\n\n        *bits = resbits;\n\n    return cost;\n\n}\n", "idx": 10765, "substitutes": {"s": ["sq", "spec", "qs", "a", "ats", "rs", "as", "sg", "p", "gs", "sts", "an", "hs", "ps", "g", "pkg", "cs", "ins", "es", "sv", "ses", "sam", "scl", "bs", "fps", "aws", "less", "http", "js", "S", "ss", "its", "n", "ts", "is", "t", "ssl", "sort", "v", "ops", "e", "sb", "c", "sw", "h", "sa", "ns", "stats", "w", "fs", "ls", "ds", "sys"], "pb": ["lb", "pc", "tp", "bf", "uf", "bp", "rb", "tk", "p", "xb", "cp", "fp", "BP", "kB", "vp", "pkg", "np", "tc", "bm", "lp", "bps", "sb", "wp", "bh", "nb", "cv", "mp", "conv", "pa"], "in": ["In", "inner", "len", "min", "inc", "id", "con", "sum", "add", "init", "ani", "sample", "range", "p", "bin", "ind", "m", "l", "local", "ins", "gin", "IN", "raw", "din", "ic", "en", "inv", "bit", "mem", "is", "data", "scan", "ac", "v", "input", "val", "inf", "nin", "c", "rin", "isin", "it", "vin", "out", "inn"], "scaled": [" unscalled", "scaling", "Scale", " unscached", "Scaped", " scale", "pscaled", "ascalled", "SCalled", "ascale", "escaling", "ascached", " unscaled", "Scalled", " unscattered", "scalled", "Scaling", "scaped", "ascaled", "SCaling", "scattered", "Scaled", "SCale", "escale", "pscaling", "escalled", " unscaped", " scalled", " unscale", "pscattered", " unscaling", "scale", " scached", "Scattered", "pscaped", "escaled", "SCaled", "scached"], "size": ["shift", "len", "small", "empty", " sizes", "num", "send", "range", "span", "area", "sp", "height", "Size", "name", "SIZE", "dimension", "m", "scope", "capacity", "zero", "win", "ize", "mem", "large", "im", "n", "mode", "count", "zone", "shape", "dim", "c", "sw", "scale", "sn", "fee", "si", "slice", "sc", "time", "max", "ose", "space", "length", "out"], "scale_idx": ["scale_ideindex", "scaleEidentxc", "scale_idpx", "scale_iny", "scale_identxc", "scale_idepx", "scale_idxs", "scaleEidx", "scaleEidindex", "scale_idxc", "scale_inxs", "scale_identindex", "scaleEidentx", "scale_idX", "scale_idexc", "scale_uidx", "scale_midX", "scale_midxe", "scale_uidxe", "scale_idexs", "scale_sidxc", "scaleEidxc", "scale_uidX", "scale_inx", "scaleEidpx", "scaleEidentindex", "scale_idex", "scale_identpx", "scale_inxc", "scaleEidentpx", "scale_identx", "scale_midx", "scale_sidpx", "scale_idey", "scale_sidx", "scale_idy", "scale_sidindex", "scale_idindex", "scale_idxe"], "cb": ["lb", "ck", "callback", "beta", "CB", "bf", "cmp", "fi", "ctrl", "rb", "cell", "cale", "iq", "fine", "func", "cp", "abb", "cf", "bc", "dc", "tc", "cd", "cc", "cli", "cod", "ctx", "ci", "lc", "cfg", "gc", "sb", "b", "ctr", "c", "dim", "cmd", "CU", "kb", "cn", "nc", "crop", "bb", "cu", "sc", "fc", "nb", "coord", "gb", "db", "cv", "vc", "wb"], "lambda": ["factor", "lb", "sq", "shift", "beta", "appa", "bf", "step", "func", "eta", "Delta", "lu", "lam", "da", "cf", "grad", "fun", "shr", "length", "mu", "function", "alpha", "kl", "dB", "phi", "sf", "pha", "wt", "lux", "scale", "kw", "dist", "elta", "etc", "z", "partial", "igma", "vol", "delay", "xf"], "uplim": ["fuplims", "fuplim", "fuppim", "uppim", "uplib", "fuplist", "ublim", "fuplib", "fuppims", "uiplims", "uppib", "ublib", "fuppist", "uplims", "uppims", "uiplib", "uppist", "uiplist", "ublist", "uplist", "uiplim", "ublims", "fuppib"], "bits": ["obs", "pieces", "units", "bf", "bands", "frames", "blocks", "weights", "keys", "bool", "jobs", "offs", "ps", "ints", "hz", "words", "pos", "points", "planes", "heads", "xs", "bytes", "bs", "bit", "its", "rows", "ones", "bps", "nets", "ops", "limits", "b", "bis", "flags", "fs", "vals", "checks", "ions", "features", "ims", "offset", "items", "parts"], "BT_ZERO": ["BT_HONE", "BT_SCERO", "BT_ZZero", "BT__SERO", "BT__ZOW", "BT_SCONE", "BT_SONE", "BT_SERO", "BT_NERO", "BT__ZONE", "BT__SOW", "BT_ZE", "BT_ZOW", "BT_SCETA", "BT_ZIZero", "BT__SONE", "BT_ZONE", "BT_ZETA", "BT_USERO", "BT_ZIONE", "BT_HOW", "BT__ZERO", "BT_USOW", "BT_NONE", "BT_NZero", "BT__ZE", "BT__SE", "BT_HERO", "BT_SE", "BT_USE", "BT_SOW", "BT_NETA", "BT_SCZero", "BT_ZIETA", "BT_USONE", "BT_HE", "BT_ZIERO"], "BT_UNSIGNED": ["BT_UnIGNABLE", "BT_UNAGING", "BT_UNAGED", "BT_ULCAPID", "BT_UNCAPING", "BT_UNIGNED", "BT_UNIGNID", "BT_UnIGNAL", "BT_UNSAAL", "BT_UNSPECENT", "BT_UNSIGNID", "BT_ULCAPING", "BT_UNPORTABLE", "BT_UNSIGNENT", "BT_UNSSed", "BT_UnSIGNED", "BT_UNIGNENT", "BT_ULSIGNED", "BT_UnIGNENT", "BT_UnSIGNAL", "BT_UNCAPed", "BT_UnSIGNIFIED", "BT_UNIGNIFIED", "BT_UNSSIFIED", "BT_UNPORTAL", "BT_UnSIGNENT", "BT_UNPORTED", "BT_ULCAPed", "BT_ULSIGNID", "BT_UNSAed", "BT_UNSIGNIFIED", "BT_UNSIGNING", "BT_UNPORTed", "BT_UNSIGNed", "BT_UNSAED", "BT_UNSPECIFIED", "BT_UNCAPED", "BT_UNSIGNABLE", "BT_UNSIGNAL", "BT_UnSIGNABLE", "BT_UNSPECED", "BT_UNAGID", "BT_UNSSENT", "BT_UNSAABLE", "BT_UNIGNING", "BT_ULCAPED", "BT_UnIGNIFIED", "BT_UNIGNABLE", "BT_UnIGNED", "BT_UNAGed", "BT_UnIGNed", "BT_UNSSED", "BT_ULSIGNed", "BT_UnSIGNed", "BT_UNCAPID", "BT_UNIGNed", "BT_UNSPECed", "BT_UNIGNAL", "BT_ULSIGNING"], "BT_PAIR": ["BT_CLAORD", "BT_HAIR", "BT_NEIRED", "BT_PAIL", "BT_AIRED", "BT_PIL", "BT_PAIM", "BT_AIM", "BT_PIR", "BT_SAIR", "BT_NEILL", "BT_PORD", "BT_AILL", "BT_CLAIR", "BT_HAIRED", "BT_HAIM", "BT_PINTER", "BT_NEIM", "BT_CLAINTER", "BT_PAIRED", "BT_AIR", "BT_PAINTER", "BT_NEIR", "BT_PAILL", "BT_PAORD", "BT_SAORD", "BT_CLAIL", "BT_HAILL", "BT_SAIL", "BT_SAINTER"], "BT_ESC": ["BT_PSCAP", "BT_BSE", "BT_RESCD", "BT_ESCD", "BT_RESC", "BT_BSCD", "BT_ESCAP", "BT_RESCAP", "BT_PSCD", "BT_BSC", "BT_ESE", "BT_RESE", "BT_BSCAP", "BT_PSE", "BT_PSC"], "i": ["ami", "id", "ai", "status", "I", "ie", "me", "li", "ei", "q", "print", "ri", "p", "ii", "point", "f", "sim", "ind", "ui", "iter", "ip", "g", "m", "l", "ki", "ti", "ic", "cli", "mi", "r", "try", "chain", "index", "ix", "im", "n", "y", "is", "t", "ci", "iu", "zi", "v", "info", "xi", "e", "multi", "b", "qi", "gi", "bi", "pi", "si", "it", "x", "batch", "ini", "oi", "hi", "ji", "ij"], "j": ["jac", "key", "je", "obj", "bj", "tr", "next", "aj", "ja", "jump", "jc", "J", "ie", "pt", "jo", "q", "p", "ng", "o", "job", "jit", "ind", "g", "jp", "l", "m", "other", "json", "jj", "index", "try", "js", "uj", "br", "n", "y", "jas", "jl", "v", "b", "c", "ijk", "bi", "adj", "oj", "it", "z", "att", "dj", " dj", "ji", "kj", "ij"], "k": ["key", "u", "K", "q", "ak", "p", "o", "ok", "g", "m", "ki", "ka", "r", "n", "y", "ac", "v", "ik", "mk", "b", "w", "it", "x", "z", "max", "sk", "ij"], "off": ["command", "shift", "obj", "on", "Off", "alf", "op", " offset", "eff", "offer", "end", "ff", "ack", "ov", " Off", "o", "dev", "point", "error", "offs", "before", "pad", "height", "f", "ok", "OFF", "ref", "pos", "def", "attr", "after", "raw", "window", "ext", "mem", "loss", "total", "wo", "t", "of", "opp", "aux", "Offset", "down", "check", "bo", "over", "cmd", "low", "from", "load", "ot", "kw", "start", "opt", " OFF", "loc", "offset", "out"], "vec": ["vector", "nv", "norm", "xy", "len", "cmp", "eff", "init", "err", "loc", "ve", "var", "buf", "seq", "act", "ref", "ver", "val", "fac", "res", "vals", "sc", "rad", "cv", "iv", "vc", "conv"], "quants": [" quats", "inquANT", "QUANT", "QUats", "aquants", " quANT", "QUants", "QUant", "aquant", "quANT", "aquANT", "quant", "inquants", "inquats", "quats", " quant", "inquant", "aquats"], "curbits": [" culpitations", " curbists", "curbedals", "crobit", "culpitations", "turbedals", "cobbits", "cribits", "cobbists", "cibits", "turbits", "curbedITS", "curbITS", "turbedits", "curbats", "culpits", " culpits", "culpists", "cibats", "crobists", "cibals", "curbedits", "cribats", "turbedITS", "cobbitations", "crobitations", "turbats", "turbals", " curbit", "turbITS", "curbitations", "curbit", " curbitations", "cibITS", "cribITS", "curbedats", "curbals", "cobbit", " culpists", "culpit", "crobits", "curbists", "cribals", "turbedats", " culpit"]}}
{"project": "FFmpeg", "commit_id": "ba571f6b4d15a998d6fde387509cd84177fccd96", "target": 0, "func": "static void event_loop(VideoState *cur_stream)\n\n{\n\n    SDL_Event event;\n\n    double incr, pos, frac;\n\n\n\n    for(;;) {\n\n        double x;\n\n        SDL_WaitEvent(&event);\n\n        switch(event.type) {\n\n        case SDL_KEYDOWN:\n\n            if (exit_on_keydown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n            switch(event.key.keysym.sym) {\n\n            case SDLK_ESCAPE:\n\n            case SDLK_q:\n\n                do_exit(cur_stream);\n\n                break;\n\n            case SDLK_f:\n\n                toggle_full_screen(cur_stream);\n\n                break;\n\n            case SDLK_p:\n\n            case SDLK_SPACE:\n\n                if (cur_stream)\n\n                    toggle_pause(cur_stream);\n\n                break;\n\n            case SDLK_s: //S: Step to next frame\n\n                if (cur_stream)\n\n                    step_to_next_frame(cur_stream);\n\n                break;\n\n            case SDLK_a:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);\n\n                break;\n\n            case SDLK_v:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);\n\n                break;\n\n            case SDLK_t:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);\n\n                break;\n\n            case SDLK_w:\n\n                if (cur_stream)\n\n                    toggle_audio_display(cur_stream);\n\n                break;\n\n            case SDLK_LEFT:\n\n                incr = -10.0;\n\n                goto do_seek;\n\n            case SDLK_RIGHT:\n\n                incr = 10.0;\n\n                goto do_seek;\n\n            case SDLK_UP:\n\n                incr = 60.0;\n\n                goto do_seek;\n\n            case SDLK_DOWN:\n\n                incr = -60.0;\n\n            do_seek:\n\n                if (cur_stream) {\n\n                    if (seek_by_bytes) {\n\n                        if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){\n\n                            pos= cur_stream->video_current_pos;\n\n                        }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){\n\n                            pos= cur_stream->audio_pkt.pos;\n\n                        }else\n\n                            pos = avio_tell(cur_stream->ic->pb);\n\n                        if (cur_stream->ic->bit_rate)\n\n                            incr *= cur_stream->ic->bit_rate / 8.0;\n\n                        else\n\n                            incr *= 180000.0;\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, pos, incr, 1);\n\n                    } else {\n\n                        pos = get_master_clock(cur_stream);\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)(incr * AV_TIME_BASE), 0);\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            break;\n\n        case SDL_MOUSEBUTTONDOWN:\n\n            if (exit_on_mousedown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n        case SDL_MOUSEMOTION:\n\n            if(event.type ==SDL_MOUSEBUTTONDOWN){\n\n                x= event.button.x;\n\n            }else{\n\n                if(event.motion.state != SDL_PRESSED)\n\n                    break;\n\n                x= event.motion.x;\n\n            }\n\n            if (cur_stream) {\n\n                if(seek_by_bytes || cur_stream->ic->duration<=0){\n\n                    uint64_t size=  avio_size(cur_stream->ic->pb);\n\n                    stream_seek(cur_stream, size*x/cur_stream->width, 0, 1);\n\n                }else{\n\n                    int64_t ts;\n\n                    int ns, hh, mm, ss;\n\n                    int tns, thh, tmm, tss;\n\n                    tns = cur_stream->ic->duration/1000000LL;\n\n                    thh = tns/3600;\n\n                    tmm = (tns%3600)/60;\n\n                    tss = (tns%60);\n\n                    frac = x/cur_stream->width;\n\n                    ns = frac*tns;\n\n                    hh = ns/3600;\n\n                    mm = (ns%3600)/60;\n\n                    ss = (ns%60);\n\n                    fprintf(stderr, \"Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \\n\", frac*100,\n\n                            hh, mm, ss, thh, tmm, tss);\n\n                    ts = frac*cur_stream->ic->duration;\n\n                    if (cur_stream->ic->start_time != AV_NOPTS_VALUE)\n\n                        ts += cur_stream->ic->start_time;\n\n                    stream_seek(cur_stream, ts, 0, 0);\n\n                }\n\n            }\n\n            break;\n\n        case SDL_VIDEORESIZE:\n\n            if (cur_stream) {\n\n                screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0,\n\n                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);\n\n                screen_width = cur_stream->width = event.resize.w;\n\n                screen_height= cur_stream->height= event.resize.h;\n\n            }\n\n            break;\n\n        case SDL_QUIT:\n\n        case FF_QUIT_EVENT:\n\n            do_exit(cur_stream);\n\n            break;\n\n        case FF_ALLOC_EVENT:\n\n            video_open(event.user.data1);\n\n            alloc_picture(event.user.data1);\n\n            break;\n\n        case FF_REFRESH_EVENT:\n\n            video_refresh(event.user.data1);\n\n            cur_stream->refresh=0;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 10767, "substitutes": {"cur_stream": ["cur_time", " cur_monitor", "curmlsession", "cur_Stream", "curtsystem", "srclystream", "curpysocket", "curLmonitor", "curmmruntime", "curitylog", "var_thread", "cur_form", "cur_network", "dev_wrapper", "rev_console", "curplethread", " cur_console", "curdbstream", "cur_list", "curptnode", "curpythread", "curmyiterator", "curpleparent", "curplerow", "curdbthread", " cur_list", "var_row", "curopstage", " cur_system", "cur_clean", "curlymonitor", " cur_thread", "cur_socket", "curpleruntime", "cur\u064elist", "cur_parent", "cont_post", "curlywindow", "curmypost", "cur_system", "curmlconsole", "curtstream", "curopconsole", "curdbrow", "curLstream", "tmp_stream", "pre_stream", "curpystream", "new_stream", "curplesystem", "cont__Stream", "cur_thread", "curitythread", "curopstream", "form_remote", "cont_Stream", "curdbsource", "cur2store", "curptconsole", "tmp_parent", "curmynetwork", "form_stream", "curLsystem", "curityloop", "curlystage", "cur\u05bcloop", "cur_row", "curLsource", "ctr_stream", "current_state", "cur_log", "cur_window", "rev_iterator", "cur\u05bcthread", "curlythread", "cur_status", "varplestream", "curplesession", "current_stream", "cont_stream", "cur\u064elevel", "cur2state", "cur_user", "ctr_system", "curlystream", "newplestream", "curpysystem", "cur_transform", "cont__console", " Cur_thread", "cur_store", "src_runtime", "currently_system", " cur_level", "newpleconsole", "currentlymyStream", "curmlclean", "origmmstream", "cur_console", "src_stream", " Curdthread", "currentlymysystem", "curdsystem", "cur_monitor", " cur_post", "etc_stream", "tmpplestatus", "src_window", "curplestream", "curityconsole", "varplesource", "curdstream", "cur\u05bcstream", "cur_remote", "curtsource", "curmystream", "cur_session", "form_source", "cur__stream", "origmmuser", "newplesession", "curmysystem", "orig_source", "new_session", "cur_draw", "srclystage", "curitystream", " Curdsystem", "dev_transform", "tmpplewindow", " cur_window", "curtStream", "cur_post", "new_console", "newpleclean", "srclywindow", " cur_status", "origmmsource", "curLthread", "cur_level", "cur_source", "currently_stream", "currently_Stream", "etc_port", "curmlstream", "cur2stream", "curplestatus", "tmp_window", "curlysocket", " Curdstream", "curpysource", "cur\u064estream", "currentlymynetwork", "currently_network", "cur\u05bctime", "ctr_port", "curpleconsole", "curntserver", "curlyruntime", "curitylist", "curlysystem", "cur_port", "cur_wrapper", "curmmsource", "pre_draw", "cont_console", "dev_window", " cur_server", "curmyStream", "curpleuser", "rev_peer", "current_stage", "curmmstream", "form_thread", "pre_port", "curdthread", "curmypeer", "var_stream", " Cur_stream", "rev_stream", "cont__post", "origmmruntime", "orig_user", "src_stage", "curplesource", "curtuser", "cur_state", "tmpplestream", "curptpeer", "curLwindow", "cont__stream", "curntstatus", "currentlymystream", "curmytransform", "curmyconsole", "varplerow", "cur_runtime", "curitytime", "curpleclean", "cur__post", "curtnetwork", "cur2stage", "srclyruntime", "curptiterator", "curplewindow", "current_store", "curitylevel", "curityport", "orig_stream", "cur_node", " cur_source", "curpleport", "cur_stage", " cur_loop", " cur_form", "tmp_status", "cur__console", " Cur_socket", "ctr_console", "pre_console", "curLremote", "curntstream", "varplethread", "cur_peer", " cur_time", "dev_stream", " cur_stage", " cur_node", "cur_server", "curdsocket", " Cur_system", "curtruntime", "tmppleparent", "curpyrow", "etc_console", "curptstage", "curmmuser", " cur_transform", "curptstream", "cur__Stream", "cur_loop", " Curdsocket", "curntstage", "curopnode", "new_clean", "cur_iterator", "orig_runtime", "var_source", "etc_log"], "event": ["command", "shift", "empty", "address", "config", "message", "channel", "flag", "ee", "image", "q", "ev", "ack", "complete", "ec", "except", "task", "argument", "error", "vent", "pair", "ind", "ex", "eng", "frame", "block", "process", "other", "object", "press", "eor", "request", "word", "window", "term", "ce", "cal", "attribute", "ext", "mem", "all", "index", "function", "se", "handler", "commit", "self", "info", "change", "e", "input", "Event", "via", "cmd", "ent", "context", "age", "msg", "pack", "escape", "exc", "state", "arg"], "incr": ["explar", "ecr", " incra", "collra", "incrd", " incrd", "incer", " incar", "INCrd", " incrc", " incsr", "incrate", "incrar", "incra", "INCr", "ecsr", "Incr", " incorr", "explr", "incar", "circorr", " incer", " inccr", "incsr", "Incrd", " incrar", " incrate", "circr", "declrc", "INCer", "seqcr", "declr", "declar", "circar", "expr", "respra", "expra", "seqrc", "seqr", "exprc", "incorr", "respar", "collr", "collcr", "ecrc", "explrar", "Incer", "incrc", "circrar", "respr", "declsr", "explorr", "collrc", "expar", "Incrate", "inccr", "INCrate", "ecar", "seqra", "resprc"], "pos": ["col", "doc", "len", "op", "xy", "spec", "off", "POS", "pc", "part", "con", "num", "pt", "seek", "axis", "resp", "point", "p", "seq", "buf", "Pos", "ps", "slot", "trans", "pose", "limit", "ref", "position", "port", "lat", "index", "rel", "cond", "px", "rot", "zone", "conf", "pr", "os", "val", "tmp", "pro", "offset", "pre", "po", "start", "pi", "no", "name", "loc", "pid"], "frac": ["acc", "callback", "xff", "repeat", "call", "format", "cell", "err", "area", "fun", "cb", "fps", "raw", "rel", "rc", "fr", "clip", "fac", "scale", "load", " fraction", "crop", "fx", "round", "max", "timer", "percent"], "x": ["xy", "tx", " cx", "ct", "f", "ex", "d", "dx", "xc", "m", "X", "i", "xs", "rx", "y", "t", "px", "v", "xi", "e", "xt", "w", "xml", "z", "fx", "xe", "xf"]}}
{"project": "FFmpeg", "commit_id": "7effbee66cf457c62f795d9b9ed3a1110b364b89", "target": 1, "func": "static int sox_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    int ret, size;\n\n\n\n    if (url_feof(s->pb))\n\n        return AVERROR_EOF;\n\n\n\n    size = SOX_SAMPLES*s->streams[0]->codec->block_align;\n\n    ret = av_get_packet(s->pb, pkt, size);\n\n    if (ret < 0)\n\n        return AVERROR(EIO);\n\n\n    pkt->stream_index = 0;\n\n    pkt->size = ret;\n\n\n\n    return 0;\n\n}", "idx": 10772, "substitutes": {"s": ["ms", "events", "sq", "vs", "qs", "a", "ats", "hs", "p", "gs", "sts", "ex", "ps", "g", "cs", "ins", "ses", "bs", "aws", "r", "is", "js", "S", "its", "ts", "n", "ss", "t", "v", "conf", "b", "c", "bis", "h", "ns", "stats", "w", "fs", "comm", "ls", "ims", "conv", "ds", "sys", "parts"], "pkt": ["wconn", " packet", "pnt", "ppnt", "het", "compnt", "wacket", "hck", "Pnt", "ppkt", "hacket", "compkg", "spnt", " pkg", "ppkg", "Pkt", "pkg", "opet", "Pct", " pqt", "spqt", "pqt", "opacket", "opkt", " pnt", "wnt", " pck", "pconn", " pet", "hkt", "compct", "pck", " pconn", "packet", " pct", "spkt", "Pconn", "spkg", "Pkg", "Packet", "pet", "wkt", "compkt", "opck", "pct", "ppqt"], "ret": ["len", "tr", "num", "reset", "et", "sum", "back", "std", "uf", "nz", "RET", "resp", "sp", "buf", "reply", "ne", "nt", "sec", "rev", "ref", " Ret", "def", "inter", "fun", "mt", "desc", "ptr", "bytes", " alt", "txt", "alt", "ter", "ord", "ext", "cont", "mem", "j", "t", "rem", "rets", "v", "deg", "count", "arg", "val", "Ret", "xt", "ctr", "cmd", "dim", "rt", "re", "elt", "res", "ber", "result", "gt", "ft", "out"], "size": ["len", "sq", "small", "min", "num", "empty", "send", "nl", "sum", "read", "buffer", "format", "news", "end", "summary", "span", "area", "value", "sent", "height", "Size", "name", "SIZE", "g", "capacity", "l", "limit", "type", "pos", "bytes", "ize", "mem", "scroll", "storage", "data", "loss", "n", "se", "total", "body", "sha", "count", "zone", "shape", "dim", "scale", "sn", "fee", "si", "space", "z", "speed", "see", "memory", "max", "sd", "offset", "length", "number"]}}
{"project": "FFmpeg", "commit_id": "d094052c8e8a036666ac02bfc52bf221ad39e4c8", "target": 1, "func": "static av_cold int svq1_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVQ1Context * const s = avctx->priv_data;\n\n\n\n    dsputil_init(&s->dsp, avctx);\n\n    avctx->coded_frame= (AVFrame*)&s->picture;\n\n\n\n    s->frame_width = avctx->width;\n\n    s->frame_height = avctx->height;\n\n\n\n    s->y_block_width = (s->frame_width + 15) / 16;\n\n    s->y_block_height = (s->frame_height + 15) / 16;\n\n\n\n    s->c_block_width = (s->frame_width / 4 + 15) / 16;\n\n    s->c_block_height = (s->frame_height / 4 + 15) / 16;\n\n\n\n    s->avctx= avctx;\n\n    s->m.avctx= avctx;\n\n\n    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));\n\n    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));\n\n    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));\n\n    h263_encode_init(&s->m); //mv_penalty\n\n\n\n    return 0;\n\n}", "idx": 10773, "substitutes": {"avctx": [" avcontext", "ovcontext", "avconn", "avecontext", " avcf", "afkt", "avcmd", "avercam", "avercpu", "navjp", "averctx", "avcmp", "ajcam", "ajconn", "ovjp", "avetx", " avctl", "aftx", "Avconn", "wavctx", "avcpu", "navctx", "AVctx", "svctx", "avcontext", "wavcf", "Avctx", "avercontext", "avjp", "avhw", "ajctx", "cvcontext", "avekl", "avectx", "ajtx", " avconn", "afcmp", "aptx", "avcfg", "ajcontext", "afcfg", " avtx", "ajcf", "aveca", "wavtx", "avkt", " avcmd", "avcf", "avctl", "avcam", "afctx", "ovctx", "AVtx", "averconn", "avecam", "ajcmd", "ajcpu", "AVcontext", "abctx", "ajkl", "apca", "cvctx", "afjac", " avca", "svkt", "AVctl", " avcmp", "svcontext", "wavcmd", "svcmp", " avcfg", "Avtx", "ovhw", "wavctl", "afcontext", "wavcontext", " avcpu", "avjac", "afcam", "abcontext", "apctx", "navcontext", "Avcontext", "apcontext", "avecfg", " avkt", "cvjac", "navhw", " avcam", "avkl", "abjp", " avkl", "cvtx", " avjac", "avertx", "avtx", "abhw", "avca"], "s": ["ms", "vs", "ats", "hs", "d", "m", "cs", "bits", "ins", "details", "ids", "t", "sports", "os", "sa", "w", "comm", "ims", "sd", "rates", "ares", "ar", "ers", "ports", "gets", "settings", "tests", "gs", "sts", "ess", "changes", "g", "ies", "sv", "args", "sam", "ses", "mods", "bs", "less", "js", "als", "ss", "conf", "ads", "ops", "sb", "ows", "sc", "ls", "states", "params", "sq", "locks", "sl", "aunts", "qs", "rs", "as", "ants", "sac", "l", "es", "i", "ts", "n", "views", "styles", "ags", "sw", "ns", "ds", "comments", "eps", "ords", "p", "uploads", "ps", "south", "aws", "is", "S", "its", "self", "v", "https", "c", "h", "acs", "stats", "fs", "actions", "set", "sys", "parts"]}}
{"project": "qemu", "commit_id": "d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 10801, "substitutes": {"ad": ["art", "dd", "aud", "al", "arp", "a", "add", "end", "and", "ack", "adv", "ay", "dev", "od", "ind", "pad", "an", "ld", "d", "post", "admin", "cd", "ud", "inter", "ab", "mod", "adr", "addr", "ord", "md", "Ad", "ac", "conn", "wd", "ads", "ace", "AD", "play", "ag", "adj", "adi", "quad", "ard", "ax", "att", "rad", "ada", "ade", "aq", "ann", "pod"], "sglist": [" sgnists", " sgniste", "sbliste", " sgllist", "sblists", " sglists", " sgnist", "sgelists", "sgllist", " sgnlist", "sgnist", "sgliste", "sgnists", " sgliste", "sgeliste", "sblist", "sbllist", "sgnlist", "sglists", "sgelist", "sgniste", "sgellist"], "offset": ["shift", "len", "off", "reset", "entry", "address", "buffer", "pointer", "padding", "base", "seek", "range", "to", "sp", "point", "o", "error", "offs", "pad", "slot", "location", "pos", "ptr", "position", "length", "mask", "addr", "index", "bound", "top", "row", "ta", "amount", "skip", "Offset", " offsets", "count", "from", "origin", "start", "slice", "set", "loc", "size", "upper"], "cmd": ["col", "command", "op", "send", "cmp", "call", "config", "ctrl", "Cmd", "req", "news", "cor", "ct", "cp", "nt", "cf", "cat", "cur", "pkg", "cd", "def", "auth", "ctl", "cc", "cli", "md", "cont", "cod", "ctx", "conn", "check", "conf", "cfg", "good", "mk", "ctr", "c", "help", "comm", "msg"], "prdt": ["pardt", "sprdm", "Prmt", "sprDT", " prtf", " prtt", "prcat", "sprcat", " prcat", "prtt", "sprmt", "pritry", "pritc", "sprtt", "partry", "Prdm", "Prcat", "Prdt", "Prdat", " prtry", "partf", "prtc", "prmt", " prtc", " prdat", " prDT", "PrDT", "Prtt", "prtry", "prdm", "sprdat", "prDT", "prdat", " prdm", "sprdt", "prtf", "pridt", "partc", " prmt", "pritf"], "i": ["ms", "ami", "id", "u", "ai", "fi", "I", "me", "a", "ie", "li", "ei", "yi", "k", "ri", "p", "o", "sim", "f", "ind", "ui", "iter", "ip", "m", "l", "ki", "port", "ti", "cli", "in", "mi", "index", "r", "j", "im", "ix", "n", "y", "t", "ci", "iu", "phi", "v", "zi", "info", "xi", "e", "multi", "qi", "c", "gi", "bi", "di", "pi", "si", "it", "x", "ini", " ii", "item", "oi", "hi", "ji", "ims", "ii"], "tbl_entry_size": ["tbl_Entry_index", "tbl_Entry_len", "tbl_Entry_size", "tbl_entry_index", "tbl_entry_length", "tbl_entry_Size", "tbl_Entry_Size", "tbl_entry_len", "tbl_Entry_length"], "bus": ["board", "config", "base", "device", "bid", "BUS", "bind", "proc", "book", "buf", "dev", "mount", "cat", "way", "pos", "Bus", "gate", "pod", "port", "kind", "bs", "cc", "loop", "handle", "us", "chain", "boot", "box", "interface", "os", "host", "b", "lock", "serv", "bug", "alias", "driver", "proxy", "vc", "state", "bridge"], "qbus": ["dqBus", "qBUS", "dqBUS", "dqbal", "iqBUS", " qBUS", "qBus", "qbal", "iqBus", " qBus", "iqbal", "dqbus", " qbal", "iqbus"], "tbl": ["ktbt", " tpl", "trie", "Tbt", "tpl", "itBL", "tBL", " trie", "itrie", "Tbl", " tBL", "lBL", "itpl", "ktpl", "itbl", "tbt", "ktbl", " tbt", "lrie", "lbl", "Tpl", "lpl"]}}
{"project": "FFmpeg", "commit_id": "9b6aafba6c06ef62783dd5e9c5ed668f3a095128", "target": 1, "func": "static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,\n\n                                                uint8_t *dest_y,\n\n                                                uint8_t *dest_cb,\n\n                                                uint8_t *dest_cr,\n\n                                                int field_based,\n\n                                                int bottom_field,\n\n                                                int field_select,\n\n                                                uint8_t **ref_picture,\n\n                                                h264_chroma_mc_func *pix_op,\n\n                                                int motion_x, int motion_y,\n\n                                                int h, int mb_y)\n\n{\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,\n\n        uvsx, uvsy;\n\n    const int lowres     = s->avctx->lowres;\n\n    const int op_index   = FFMIN(lowres, 2);\n\n    const int block_s    = 8>>lowres;\n\n    const int s_mask     = (2 << lowres) - 1;\n\n    const int h_edge_pos = s->h_edge_pos >> lowres;\n\n    const int v_edge_pos = s->v_edge_pos >> lowres;\n\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n\n\n    // FIXME obviously not perfect but qpel will not work in lowres anyway\n\n    if (s->quarter_sample) {\n\n        motion_x /= 2;\n\n        motion_y /= 2;\n\n    }\n\n\n\n    if (field_based) {\n\n        motion_y += (bottom_field - field_select) * (1 << lowres - 1);\n\n    }\n\n\n\n    sx = motion_x & s_mask;\n\n    sy = motion_y & s_mask;\n\n    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);\n\n    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);\n\n        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);\n\n        uvsrc_x = src_x >> 1;\n\n        uvsrc_y = src_y >> 1;\n\n    } else if (s->out_format == FMT_H261) {\n\n        // even chroma mv's are full pel in H261\n\n        mx      = motion_x / 4;\n\n        my      = motion_y / 4;\n\n        uvsx    = (2 * mx) & s_mask;\n\n        uvsy    = (2 * my) & s_mask;\n\n        uvsrc_x = s->mb_x * block_s + (mx >> lowres);\n\n        uvsrc_y =    mb_y * block_s + (my >> lowres);\n\n    } else {\n\n        mx      = motion_x / 2;\n\n        my      = motion_y / 2;\n\n        uvsx    = mx & s_mask;\n\n        uvsy    = my & s_mask;\n\n        uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);\n\n        uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);\n\n    }\n\n\n\n    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;\n\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n\n\n    if ((unsigned) src_x >  h_edge_pos - (!!sx) - 2 * block_s ||\n\n        (unsigned) src_y > (v_edge_pos >> field_based) - (!!sy) - h) {\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,\n\n                                s->linesize, 17, 17 + field_based,\n\n                                src_x, src_y << field_based, h_edge_pos,\n\n                                v_edge_pos);\n\n        ptr_y = s->edge_emu_buffer;\n\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n            uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize;\n\n            s->dsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            ptr_cb = uvbuf;\n\n            ptr_cr = uvbuf + 16;\n\n        }\n\n    }\n\n\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f.data\n\n    if (bottom_field) {\n\n        dest_y  += s->linesize;\n\n        dest_cb += s->uvlinesize;\n\n        dest_cr += s->uvlinesize;\n\n    }\n\n\n\n    if (field_select) {\n\n        ptr_y   += s->linesize;\n\n        ptr_cb  += s->uvlinesize;\n\n        ptr_cr  += s->uvlinesize;\n\n    }\n\n\n\n    sx = (sx << 2) >> lowres;\n\n    sy = (sy << 2) >> lowres;\n\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n        uvsx = (uvsx << 2) >> lowres;\n\n        uvsy = (uvsy << 2) >> lowres;\n\n        pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n        pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n    }\n\n    // FIXME h261 lowres loop filter\n\n}\n", "idx": 10836, "substitutes": {"s": ["ms", "sq", "spec", "aunts", "qs", "a", "ats", "rs", "as", "hs", "p", "gs", "sts", "an", "ex", "ps", "changes", "g", "cs", "m", "ins", "sv", "es", "ses", "i", "fps", "scl", "aws", "less", "js", "details", "S", "ss", "ts", "n", "its", "se", "t", "ctx", "sports", "v", "conf", "e", "os", "b", "sb", "c", "sw", "times", "ns", "stats", "w", "csv", "stat", "sc", "comm", "webkit", "set", "ls", "ims", "space", "ds", "sys"], "dest_y": ["dest__x", "destamex", " dest_cy", "dest_x", "dest_gy", "dest__cy", "destamegy", " dest_gy", "dest_cy", " dest_x", "dest__gy", "destamey", "destamecy", "dest__y"], "dest_cb": ["dest_cm", "src_cm", "src_ctrl", "dest_rb", "dest_ctrl", "src_cb", "src_rb"], "dest_cr": ["dest_cd", "dest_ctr", "src_cr", "dest__ctr", "dest__cb", "dest2ctr", "src_cd", "dest2cd", "src_cb", "src_ctr", "dest__cd", "dest2cr", "dest2cb", "dest__cr"], "field_based": ["field_base", "fieldityfaced", "fieldvalbacked", "field___base", "fielderBased", "FIELD_base", "field_backed", "FIELD_based", "Field_bal", "field_required", "Field_based", "field_Based", "fieldlybal", "fieldvalhidden", "FIELD_Based", "Field_base", "field___based", "field2base", "fieldlybased", "field_hidden", "fieldityBased", "field_handled", "fielderbased", "fielditybased", "Field_Based", "field2bal", "fieldvalbase", "field_led", "field___handled", "fieldityselect", "field2Based", "field2based", " field_Based", "field_bal", "fieldlybase", "FIELD_led", "field_faced", "fieldlyBased", "FIELD_hidden", "fieldvalrequired", "fielderselect", "FIELD_handled", "fielderfaced", "FIELD_required", "field___Based", "FIELD_backed", " field_faced", "fieldvalbased", "fieldvalled"], "bottom_field": ["bottom___key", "body_fields", "bottomlyfields", "bodylylength", "bodylygravity", "body_gravity", "bottom_length", "base_field", "base_key", "body_field", "bottom_fields", "bottom_f", "bodylyfields", "bottom_key", "bottomlyfield", "bodylyfield", "bottom_gravity", "bottom___f", "bottomlygravity", "bottomlylength", "base_f", "body_length", "bottom___field"], "field_select": [" field_selected", "fieldNamesel", " field_lect", "fieldNameselect", "field08selection", " field_edit", "field_edit", "field_sel", "fieldNameedit", "field_selected", "field_selection", " field_sel", " field_selection", "field08selected", "field08lect", "field08select", "fieldNameselected", "field_lect"], "ref_picture": [" ref_image", " ref__picture", "refjmemory", "ref_memory", " ref__image", "refjpicture", "refjimage", "refjpic", "ref2picture", "ref2memory", "ref__picture", "ref__pic", " ref__pic", "ref__image", " ref__memory", "ref2pic", " ref_memory", " ref_pic", "ref_image", "ref_pic", "ref2image", "ref__memory"], "pix_op": ["pixels2info", "pixels2oper", "pixchop", "pix2oper", "pix2pos", "pixels_oper", "pix2op", "pix_info", "pix_pos", "pixels_op", "pixels_pos", "pixels_info", "pix_oper", "pixchoper", "pixels2op", "pix2info", "pixels2pos", "pixchinfo", "pixchpos"], "motion_x": ["motion_____yx", "motion__x", "memory_x", "move_x", "motion_____ax", "motion__y", "motion00ox", " motion_ox", "motion______ax", " motion_xi", "motion______x", " motion__xi", " motion__x", "move_ex", " motion__ix", " motion_rx", "motion_ix", " motion__y", "motionureax", "fire08px", "memoryureax", "fire_xd", "motion_xi", "motion_xd", "motionurex", "fire08x", "motion00x", "motion_rx", "motion______yx", "motion______mix", "fire_x", "motion__ix", "fire08xd", "fire_px", "memory_mix", "motion_px", "motion00ix", "memoryureyx", "motion_____mix", "memoryurex", "motion_on", "memoryuremix", "motion__xi", "motionureyx", "motion_____x", "motion_ax", "motion_yx", "motion08px", "memory_ax", " motion_ix", "motion_ex", "motion_ox", "move_on", "move_y", "motion_mix", "motion08xd", "motion00rx", "motion08x", "memory_yx", "motionuremix"], "motion_y": ["motion_yl", "mission_d", "motion67iy", "motion_ey", "mission_____Y", "movie_yy", "motion_Y", "motion08y", "mission67iy", "movie_iy", "mission_ch", "motion_ym", "mission_____ch", "motion_ry", "motion_ch", "mission_iy", "motion_d", "motion08yl", "motion_b", "mission_____y", "motion_____Y", "motion_____ry", "motion_iy", " motion_b", "motion_yy", "motion_yt", "motion___iy", "error_ym", " motion_yy", "motion67y", "error_yl", "mission_b", "motion_____y", "error08yl", "error08y", "motion67d", "mission_ry", "motion67ry", "error_y", "error08ym", "mission67ry", " motion_ym", "mission_Y", "motion___y", "movie_yt", "mission67d", "mission_ey", "mission_y", "motion___yt", "mission67y", "motion___yy", "error_x", "error08x", "movie_y", "mission_____ry", "motion08x", "motion08ym", "motion_____ch"], "h": ["ch", "q", "k", "hs", "p", "height", "f", "d", "m", "l", "i", "hh", "n", "y", "t", "v", "ha", "e", "b", "c", "hw", "w", "ih", "it", "x", "z", "H"], "mb_y": ["mbgy", "db08cy", "mb_b", "embixsy", "mb08b", "db_b", "mbixsy", "mb_ys", "mbixys", "mboxz", "mbixny", "emb_y", "db08z", "db08y", "mb_ny", "mbixy", "mb08y", "db_z", "emb_sy", "embixy", "embixny", "mbgsy", "embixys", "mb08z", "mb_z", "mb_sy", "mbgny", "mboxcy", "mb08cy", "mboxny", "mbgys", "db_y", "mboxb", "db_cy", "mb_cy", "mboxsy", "emb_ys", "db08b", "mboxy", "mboxys", "emb_ny"], "ptr_y": ["tmp_y", "ptr______y", "ptr_yi", "tmp_yi", "ptr_cy", "ptr______gy", "ptr___gy", "ptr______yi", "ptr______cy", "tmp_gy", "tmp_cy", "ptr_gy", "ptr___yi", "ptr___y", "ptr___cy"], "ptr_cb": ["ref_wb", "ptr___rb", "ptrtcb", "ref_rb", "ptrtrb", "ptr___ca", "ptr_rb", "ref_ca", "ptr_wb", "ptrtwb", "ptrtca", "ref_cb", "ptr___cb", "ptr___wb", "ptr_ca"], "ptr_cr": ["ref_ctr", "ptr55cr", "ptr55dr", "ptrTcr", "ptr_ctr", "ptrTcrop", "ptrTctr", "ref_cr", "ptr_crop", "ptrTdr", "ptr55ctr", "ptr_dr", "ref_dr", "ref_crop", "ptr55crop"], "mx": ["ms", "ml", "xp", "xy", "mm", "nz", "ex", "xc", "mo", "wx", "mr", "mn", "xs", "mph", "mi", "rx", "ma", "px", "xi", "mk", "ey", "xx", "zx", "yx", "fx", "lex", "xe", "ux"], "my": ["ms", "sym", "py", "xy", "sky", "ty", "mm", "yy", "ry", "mic", "mis", "mn", "ky", "mi", "md", "ma", "phy", "mk", "mid", "ym", "gy", "fy", "ery", "xx", "yx", "ny", "cy"], "src_x": ["rc_x", "src__wx", "rc_z", "source_wx", "rc_y", "source_y", "src_X", "src__y", "rc_ex", "source_ex", "source_x", "src__ex", "src__x", "src_z", "src_wx", "rc_X", "src_ex"], "src_y": ["dest_x", "src_py", "dest_h", "src_Y", "src_ny", "src_yy", "dest_Y", " src_yy", "src_h", " src_ny", " src_py"], "uvsrc_x": ["uvsrc_xy", "uvsrc_rx", "uvst_ex", "uvst_x", "uvsource_x", "uvsource_y", "uvsource_xy", "uvsrc_ex", "uvst_rx"], "uvsrc_y": ["uvsecure_x", "uvsecure_ys", "uvsrc_b", "uvsrc_ys", "uvsecure_b", "uvsecure_y"], "uvlinesize": ["uulinesize", "uvlimitsization", "uvlinesource", "uulinesource", "uxlinesization", "uvtimesization", "uulinesen", "uulinesiz", "uvinesource", "uvlineizer", "uulinsiz", "uvlinsource", "uvpagesource", "uvlineize", "uvinesen", "uvlineiz", "uxlinesize", "uvlinesizer", "uvlimitsize", "uxtimesize", "uxlinesizer", "uxlinesiz", "uvlinesization", "uvpagesiz", "uxtimesizer", "uvtimesiz", "uvlimitsiz", "uvlinsiz", "uvinesiz", "uvinesize", "uvpagesen", "uvlimitsizer", "uvlinesen", "uvtimesize", "uulinsen", "uvtimesizer", "uvlinsen", "uulinsource", "uxtimesiz", "uvpagesize", "uvlineization", "uvlinsize", "uvlinesiz", "uxtimesization", "uulinsize"], "linesize": ["linsiz", "netsize", "dosization", "inesization", "losize", "inesize", "netsization", " linesiz", "inesizer", "losiz", "boardsization", "boardssize", "linsIZE", "storesization", "losized", "linesiz", "ineszie", "daysize", "storesize", "inesiz", "losization", "storessize", "linesization", "netsiz", "linesizer", "dosized", "daysized", "lineszie", "boardsizer", "dayssize", "dosize", "inesIZE", " lineszie", "storesizer", "netsized", "inesized", "linszie", "boardsize", " linesIZE", "dossize", "linesIZE", "linsize", "inessize", "daysization", "linessize", "linesized"], "sx": ["swx", "tsz", "lsz", "rsy", "insxi", "insz", " sxi", "lsxc", "tsxc", "rsx", "lsrx", "sxi", "ssxc", "tsx", "insy", "ssxx", "ssfx", "ssrx", "lsfx", "sfx", "lsx", "rsz", " sz", "sswx", "sz", "lsxx", "insx", "sxc", "sxx", "srx", "tsxx", "rsxi", "lswx", "ssz", "ssx"], "sy": ["sym", "py", "san", "sq", "sky", "ty", "pse", "cy", "yy", "ay", "sm", "Sy", "ry", "south", "SY", "sv", "ky", "dy", "mi", "ys", "sid", "ss", "y", "icy", "phy", "she", "tsy", "ey", "sty", "ly", "ery", "sa", "gy", "uy", "fy", "si", "ony", "ny", "syn", "sys"], "uvsx": [" uvsix", "uidsix", "uvsim", "umsX", "uidsx", "uhsize", " uvsim", "uidsX", "uhsock", " uversock", "uidsim", "uvsix", " uvsw", " ucsim", "uversize", "ucsX", " ucsX", " uvsock", "umsix", "uvsock", "uversock", " ucsix", "uhsx", " ucsx", " uversw", "ufsock", "umsim", "uhsw", "uvsw", "uversw", " uvsX", " uversx", "ucsix", "uversx", "uvsX", "umsx", "ufsize", "ufsw", " uvsize", "uvsize", " uversize", "ucsim", "ufsx", "ucsx"], "uvsy": ["uesm", "uesym", "uvser", "ucfy", "uvcy", "uumsm", "uumsy", "uumser", "uefy", "uucy", "uusym", "UVsy", "uusm", "uvsym", "ucsm", "uvsm", "UVsm", "UVcy", "ucsym", "ucsy", "uumcy", "uesy", "uvfy", "uusy", "UVser", "uuser", "uufy"]}}
{"project": "FFmpeg", "commit_id": "1178868683d25c0f358b0364eb55f69b563b24f3", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf      = avpkt->data;\n\n    unsigned int   buf_size = avpkt->size;\n\n    const uint8_t *buf_end  = buf + buf_size;\n\n\n\n    const AVPixFmtDescriptor *desc;\n\n    EXRContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr;\n\n\n\n    int i, x, y, stride, magic_number, version, flags, ret;\n\n    int w = 0;\n\n    int h = 0;\n\n    unsigned int xmin   = ~0;\n\n    unsigned int xmax   = ~0;\n\n    unsigned int ymin   = ~0;\n\n    unsigned int ymax   = ~0;\n\n    unsigned int xdelta = ~0;\n\n\n\n    int out_line_size;\n\n    int bxmin, axmax;\n\n    int scan_lines_per_block;\n\n    unsigned long scan_line_size;\n\n    unsigned long uncompressed_size;\n\n\n\n    unsigned int current_channel_offset = 0;\n\n\n\n    s->channel_offsets[0] = -1;\n\n    s->channel_offsets[1] = -1;\n\n    s->channel_offsets[2] = -1;\n\n    s->channel_offsets[3] = -1;\n\n    s->bits_per_color_id = -1;\n\n    s->compr = -1;\n\n\n\n    if (buf_size < 10) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Too short header to parse\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_number = bytestream_get_le32(&buf);\n\n    if (magic_number != 20000630) { // As per documentation of OpenEXR it's supposed to be int 20000630 little-endian\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic number %d\\n\", magic_number);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    version = bytestream_get_byte(&buf);\n\n    if (version != 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported version %d\\n\", version);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    flags = bytestream_get_le24(&buf);\n\n    if (flags & 0x2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Tile based images are not supported\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    // Parse the header\n\n    while (buf < buf_end && buf[0]) {\n\n        unsigned int variable_buffer_data_size;\n\n        // Process the channel list\n\n        if (check_header_variable(avctx, &buf, buf_end, \"channels\", \"chlist\", 38, &variable_buffer_data_size) >= 0) {\n\n            const uint8_t *channel_list_end;\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            channel_list_end = buf + variable_buffer_data_size;\n\n            while (channel_list_end - buf >= 19) {\n\n                int current_bits_per_color_id = -1;\n\n                int channel_index = -1;\n\n\n\n                if (!strcmp(buf, \"R\"))\n\n                    channel_index = 0;\n\n                else if (!strcmp(buf, \"G\"))\n\n                    channel_index = 1;\n\n                else if (!strcmp(buf, \"B\"))\n\n                    channel_index = 2;\n\n                else if (!strcmp(buf, \"A\"))\n\n                    channel_index = 3;\n\n                else\n\n                    av_log(avctx, AV_LOG_WARNING, \"Unsupported channel %.256s\\n\", buf);\n\n\n\n                while (bytestream_get_byte(&buf) && buf < channel_list_end)\n\n                    continue; /* skip */\n\n\n\n                if (channel_list_end - * &buf < 4) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                current_bits_per_color_id = bytestream_get_le32(&buf);\n\n                if (current_bits_per_color_id > 2) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Unknown color format\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                if (channel_index >= 0) {\n\n                    if (s->bits_per_color_id != -1 && s->bits_per_color_id != current_bits_per_color_id) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"RGB channels not of the same depth\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    s->bits_per_color_id  = current_bits_per_color_id;\n\n                    s->channel_offsets[channel_index] = current_channel_offset;\n\n                }\n\n\n\n                current_channel_offset += 1 << current_bits_per_color_id;\n\n                buf += 12;\n\n            }\n\n\n\n            /* Check if all channels are set with an offset or if the channels\n\n             * are causing an overflow  */\n\n\n\n            if (FFMIN3(s->channel_offsets[0],\n\n                       s->channel_offsets[1],\n\n                       s->channel_offsets[2]) < 0) {\n\n                if (s->channel_offsets[0] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing red channel\\n\");\n\n                if (s->channel_offsets[1] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing green channel\\n\");\n\n                if (s->channel_offsets[2] < 0)\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing blue channel\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            buf = channel_list_end;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"dataWindow\", \"box2i\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            xmin = AV_RL32(buf);\n\n            ymin = AV_RL32(buf + 4);\n\n            xmax = AV_RL32(buf + 8);\n\n            ymax = AV_RL32(buf + 12);\n\n            xdelta = (xmax-xmin) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"displayWindow\", \"box2i\", 34, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            w = AV_RL32(buf + 8) + 1;\n\n            h = AV_RL32(buf + 12) + 1;\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"lineOrder\", \"lineOrder\", 25, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (*buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Doesn't support this line order : %d\\n\", *buf);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"pixelAspectRatio\", \"float\", 31, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            avctx->sample_aspect_ratio = av_d2q(av_int2float(AV_RL32(buf)), 255);\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        } else if (check_header_variable(avctx, &buf, buf_end, \"compression\", \"compression\", 29, &variable_buffer_data_size) >= 0) {\n\n            if (!variable_buffer_data_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if (s->compr == -1)\n\n                s->compr = *buf;\n\n            else\n\n                av_log(avctx, AV_LOG_WARNING, \"Found more than one compression attribute\\n\");\n\n\n\n            buf += variable_buffer_data_size;\n\n            continue;\n\n        }\n\n\n\n        // Check if there is enough bytes for a header\n\n        if (buf_end - buf <= 9) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        // Process unknown variables\n\n        for (i = 0; i < 2; i++) {\n\n            // Skip variable name/type\n\n            while (++buf < buf_end)\n\n                if (buf[0] == 0x0)\n\n                    break;\n\n        }\n\n        buf++;\n\n        // Skip variable length\n\n        if (buf_end - buf >= 5) {\n\n            variable_buffer_data_size = get_header_variable_length(&buf, buf_end);\n\n            if (!variable_buffer_data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Incomplete header\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            buf += variable_buffer_data_size;\n\n        }\n\n    }\n\n\n\n    if (s->compr == -1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing compression attribute\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (buf >= buf_end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incomplete frame\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    buf++;\n\n\n\n    switch (s->bits_per_color_id) {\n\n    case 2: // 32-bit\n\n    case 1: // 16-bit\n\n        if (s->channel_offsets[3] >= 0)\n\n            avctx->pix_fmt = AV_PIX_FMT_RGBA64;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB48;\n\n        break;\n\n    // 8-bit\n\n    case 0:\n\n        av_log_missing_feature(avctx, \"8-bit OpenEXR\", 1);\n\n        return AVERROR_PATCHWELCOME;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown color format : %d\\n\", s->bits_per_color_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (s->compr) {\n\n    case EXR_RAW:\n\n    case EXR_RLE:\n\n    case EXR_ZIP1:\n\n        scan_lines_per_block = 1;\n\n        break;\n\n    case EXR_ZIP16:\n\n        scan_lines_per_block = 16;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Compression type %d is not supported\\n\", s->compr);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        ff_thread_release_buffer(avctx, &s->picture);\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    // Verify the xmin, xmax, ymin, ymax and xdelta before setting the actual image size\n\n    if (xmin > xmax || ymin > ymax || xdelta != xmax - xmin + 1 || xmax >= w || ymax >= h) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Wrong sizing or missing size information\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (w != avctx->width || h != avctx->height) {\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    }\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    bxmin = xmin * 2 * desc->nb_components;\n\n    axmax = (avctx->width - (xmax + 1)) * 2 * desc->nb_components;\n\n    out_line_size = avctx->width * 2 * desc->nb_components;\n\n    scan_line_size = xdelta * current_channel_offset;\n\n    uncompressed_size = scan_line_size * scan_lines_per_block;\n\n\n\n    if (s->compr != EXR_RAW) {\n\n        av_fast_padded_malloc(&s->uncompressed_data, &s->uncompressed_size, uncompressed_size);\n\n        av_fast_padded_malloc(&s->tmp, &s->tmp_size, uncompressed_size);\n\n        if (!s->uncompressed_data || !s->tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if ((ret = ff_thread_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    // Zero out the start if ymin is not 0\n\n    for (y = 0; y < ymin; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    // Process the actual scan line blocks\n\n    for (y = ymin; y <= ymax; y += scan_lines_per_block) {\n\n        uint16_t *ptr_x = (uint16_t *)ptr;\n\n        if (buf_end - buf > 8) {\n\n            /* Read the lineoffset from the line offset table and add 8 bytes\n\n               to skip the coordinates and data size fields */\n\n            const uint64_t line_offset = bytestream_get_le64(&buf) + 8;\n\n            int32_t data_size;\n\n\n\n            // Check if the buffer has the required bytes needed from the offset\n\n            if ((line_offset > buf_size) ||\n\n                (s->compr == EXR_RAW && line_offset > avpkt->size - xdelta * current_channel_offset) ||\n\n                (s->compr != EXR_RAW && line_offset > buf_size - (data_size = AV_RL32(avpkt->data + line_offset - 4)))) {\n\n                // Line offset is probably wrong and not inside the buffer\n\n                av_log(avctx, AV_LOG_WARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y);\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    ptr_x = (uint16_t *)ptr;\n\n                    memset(ptr_x, 0, out_line_size);\n\n                }\n\n            } else {\n\n                const uint8_t *red_channel_buffer, *green_channel_buffer, *blue_channel_buffer, *alpha_channel_buffer = 0;\n\n\n\n                if (scan_lines_per_block > 1)\n\n                    uncompressed_size = scan_line_size * FFMIN(scan_lines_per_block, ymax - y + 1);\n\n                if ((s->compr == EXR_ZIP1 || s->compr == EXR_ZIP16) && data_size < uncompressed_size) {\n\n                    unsigned long dest_len = uncompressed_size;\n\n\n\n                    if (uncompress(s->tmp, &dest_len, avpkt->data + line_offset, data_size) != Z_OK ||\n\n                        dest_len != uncompressed_size) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during zlib decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                } else if (s->compr == EXR_RLE && data_size < uncompressed_size) {\n\n                    if (rle_uncompress(avpkt->data + line_offset, data_size, s->tmp, uncompressed_size)) {\n\n                        av_log(avctx, AV_LOG_ERROR, \"error during rle decompression\\n\");\n\n                        return AVERROR(EINVAL);\n\n                    }\n\n                }\n\n\n\n                if (s->compr != EXR_RAW && data_size < uncompressed_size) {\n\n                    predictor(s->tmp, uncompressed_size);\n\n                    reorder_pixels(s->tmp, s->uncompressed_data, uncompressed_size);\n\n\n\n                    red_channel_buffer   = s->uncompressed_data + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = s->uncompressed_data + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = s->uncompressed_data + xdelta * s->channel_offsets[3];\n\n                } else {\n\n                    red_channel_buffer   = avpkt->data + line_offset + xdelta * s->channel_offsets[0];\n\n                    green_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[1];\n\n                    blue_channel_buffer  = avpkt->data + line_offset + xdelta * s->channel_offsets[2];\n\n                    if (s->channel_offsets[3] >= 0)\n\n                        alpha_channel_buffer = avpkt->data + line_offset + xdelta * s->channel_offsets[3];\n\n                }\n\n\n\n                for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n\n                    const uint8_t *r, *g, *b, *a;\n\n\n\n                    r = red_channel_buffer;\n\n                    g = green_channel_buffer;\n\n                    b = blue_channel_buffer;\n\n                    if (alpha_channel_buffer)\n\n                        a = alpha_channel_buffer;\n\n\n\n                    ptr_x = (uint16_t *)ptr;\n\n\n\n                    // Zero out the start if xmin is not 0\n\n                    memset(ptr_x, 0, bxmin);\n\n                    ptr_x += xmin * desc->nb_components;\n\n                    if (s->bits_per_color_id == 2) {\n\n                        // 32-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n\n                        }\n\n                    } else {\n\n                        // 16-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n\n                        }\n\n                    }\n\n\n\n                    // Zero out the end if xmax+1 is not w\n\n                    memset(ptr_x, 0, axmax);\n\n\n\n                    red_channel_buffer   += scan_line_size;\n\n                    green_channel_buffer += scan_line_size;\n\n                    blue_channel_buffer  += scan_line_size;\n\n                    if (alpha_channel_buffer)\n\n                        alpha_channel_buffer += scan_line_size;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    // Zero out the end if ymax+1 is not h\n\n    for (y = ymax + 1; y < avctx->height; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 10842, "substitutes": {"avctx": [" avctl", "avetmp", " avcp", "avcu", "ajjp", "avesetup", "avercu", " avcontext", "averjp", "averrx", "avctl", " avtmp", "aftx", "avecontext", "avercmp", "afctx", "awrx", "averconfig", "averctl", "AVtx", "awjac", "avcp", "afjp", "AVctx", "AVcontext", "verctx", "AVtmp", "avcontext", "vercontext", "vrctl", "avergc", "vrctx", "avgc", "ajconfig", "verctl", "avecu", "aversetup", "awcmp", "avjp", "afrx", "awcu", "afconfig", "ajctx", "ajgc", "ajsetup", "avconfig", "avectx", "ajtx", "afctl", "vercp", "afcmp", "avrx", "awsetup", "avsetup", "averctx", "afgc", "ajctl", "avcmp", "avtmp", "vrcp", "vrcontext", "averjac", "afsetup", "awconfig", "avertx", "avtx", "avjac", "avejac", " avtx", "avetx", "awctx"], "data": ["Data", "next", "current", "empty", "map", "record", "buffer", "text", "message", "padding", "read", "pointer", "image", "join", "to", "area", "value", "stream", "file", "bin", "frame", "pad", "audio", "d", "block", "ata", "def", "length", "raw", "window", "bytes", "json", "family", "package", "video", "t", "action", "input", "reader", "dat", "form", "table", "batch", "DATA", "name", "offset", "size", "out"], "got_frame": ["got_offset", "got_state", "got___frame", "got___channel", "gotgroffset", "got_channel", "gotgrchannel", "gotgrframe", "got___offset", "got___state", "received_frame", "gotgrstate", "received_channel", "received_state", "received_offset"], "avpkt": ["afpkg", "avcpkt", "avpacket", "avpmt", "AVcpst", "AVpmt", "avewpkt", "avppst", "avwpkt", "avepcs", "avcpux", "afpkt", "avjpacket", "avcpst", "avdpux", "avjpkt", "AVcpmt", "avwpct", "avewpnt", "avpbkt", "avPkt", "avwpkg", "avpbnt", "afpacket", "afcpkg", "AVpacket", "afcpux", "afpux", "avppacket", "avcpkg", "AVcpacket", "avwpnt", "avcpacket", "avdpacket", "avPnt", "avpnt", "avppmt", "avewpcs", "avjpmt", "avpbct", "afcpkt", "avpux", "afcpacket", "avcpmt", "avpct", "avwpcs", "AVpkt", "avepnt", "avepkt", "avpst", "avwpacket", "avjpst", "avdpkg", "avdpkt", "AVcpkt", "avPct", "avepct", "avPcs", "avppkt", "AVpst", "avpkg", "avwpux", "avpbcs", "avpcs", "avewpct"], "buf": ["doc", "len", "next", "off", "map", "xff", "buffer", "uf", "bp", "rb", "cam", "err", "alloc", "proc", "bl", "pool", "bag", "seq", "pad", "bc", "Buffer", "vec", "pkg", "ref", "block", "cur", "pos", "limit", "cb", "window", "bytes", "txt", "queue", "mem", "br", "box", "cap", "t", "ctx", "emb", "count", "v", "ctr", "cmd", "h", "batch", "buff", "comm", "msg", "bar", "cv", "pack", "max", "loc", "img", "length"], "buf_end": ["buf_ends", "buf_start", "buffer_ends", "buf_offset", "buffer_start", "buffer_offset", "buffer_end"], "desc": ["col", "doc", "tx", "cmp", "Desc", "crit", "cam", "enc", "rec", "ec", "sub", "dev", "dc", "def", "attr", "esc", "rc", "dir", "comp", "cmd", "asc", "des", "dist", "res", "sc", "description", "conv"], "s": ["ms", "sq", "vs", "tx", "spec", "status", "qs", "source", "ats", "settings", "rs", "summary", "as", "gs", "sp", "sts", "ps", "d", "changes", "cs", "service", "ins", "sv", "es", "utils", "bs", "services", "details", "is", "js", "j", "S", "ss", "ts", "n", "its", "se", "t", "styles", "v", "ops", "storage", "os", "sb", "c", "sw", "h", "sa", "ns", "stats", "w", "fs", "results", "st", "set", "comm", "ls", "space", "ds", "sys"], "picture": ["command", "icon", "password", "pic", "status", "fi", "buffer", "path", "policy", "message", "feature", "format", "image", "document", "file", "profile", "point", "frame", "fp", "program", "media", "screen", "pid", "family", "friendly", "video", "share", "photo", "pen", "info", "query", "stat", "piece", "pict", "camera", "context", "Picture", "description", "img", "pa"], "p": ["op", "pic", "pc", "par", "pp", "per", "sp", "f", "cp", "ps", "ip", "jp", "m", "pkg", "np", "ap", "lp", "j", "pb", "P", "t", "v", "c", "mp", "pa"], "ptr": ["arr", "tr", "pc", "buffer", "pointer", "err", "seek", "alloc", "sp", "pad", "pointers", "rev", "cur", "np", "ref", "attr", "addr", "cont", "rel", "br", "ctx", "rc", "pr", "rect", "ctr", "sc", "conv", "dr"], "i": ["id", "I", "base", "k", "ii", "o", "f", "ip", "m", "l", "index", "j", "ix", "ci", "v", "xi", "e", "c", "bi", "pi", "si", "it", "ij"], "x": ["col", "key", "xp", "xy", "tx", "path", "axis", "ex", "ox", "dx", "xc", "pos", "m", "X", "xs", "lat", "index", "rx", "ix", "px", "xi", "w", "time"], "y": ["key", "yt", "xy", "axy", "ty", "ch", "yy", "height", "yn", "m", "my", "type", "ye", "dy", "ys", "n", "t", "Y", "ey", "h", "ym", "sy", "iy", "yl"], "stride": ["sprue", "slue", "strue", "strides", "strope", "sprides", "sprope", "tride", "spride", "true", "slides", "trope", "slide", "slope", "trides"], "magic_number": [" magic_no", " magic_code", " magic_notation", "magic\u05bcno", "magic7number", " magic_byte", "magic7no", "magicetyblock", "magic_block", "magic_name", "magic_byte", "magic7umber", "mag_block", "magic\u05bcnotation", "magicetynumber", "magic\u05bcnumber", "mag_sequence", "magicicaloperator", "magicicalnumber", "magicicalno", "mag_notation", "magic_operator", "magic\u05bcbyte", " magic_name", "magicetynotation", "magic_code", "magic_notation", "magic_no", " magic_operator", "mag_number", "magic_umber", "magicetysequence", "magic7operator", "magicicalumber", "magic_sequence", " magic_umber"], "version": ["depth", "vector", "power", "vert", "status", "part", "code", "section", "feature", "order", "format", "value", "hash", "fish", "wire", "iso", "name", "sector", "program", "type", "sequence", "position", "serial", "length", "quality", "Version", "ver", "server", "family", "index", "package", "VER", "magic", "browser", "connection", "mode", "VERSION", "latest", "direction", "v", "ison", "class", "about", "release", "major", "option", "product", "scale", "supported", "tag", "vision", "driver", "usage", "description", "vers", "versions", "conv", "size", "python", "number"], "flags": ["abilities", "events", "comments", "Flags", "locks", "errors", "frames", "flag", "bugs", "weights", "settings", "types", "ps", "ints", "phones", "FLAG", "bits", "members", "heads", "args", "pins", "terms", "mask", "details", "notes", "posts", "magic", "styles", "fields", "grades", "ags", "levels", "wcs", "limits", "doms", "tags", "properties", "reports", "stats", "fs", "codes", "options", "finals", "faces", "actions", "features", "states", "rates", "versions", "missions"], "ret": ["len", "num", "reset", "status", "buffer", "match", "RET", "resp", "rev", "jp", "ref", "txt", "alt", "mem", "details", "ext", "rel", "deg", "val", "Ret", "res", "result", "out"], "out_line_size": ["out_pixel_length", "out_line_Size", "out_pixel_Size", "out_pixel_number", "out_pixel_size", "out_line_number", "out_line_length"], "bxmin": ["bwmin", "bdxmin", "cbwreq", "cbwmin", "bexmod", "bdxmod", "bexmin", "bexreq", "bwreq", "bxstart", "cbxreq", "bxmod", "cbxmod", "cbxstart", "bwstart", "bexstart", "cbwstart", "bwmod", "cbxmin", "bdxstart", "bxreq", "bdxreq", "cbwmod"], "axmax": ["oxMax", "xMax", "axmin", "dxmax", "axgt", "dxgt", "xmax", "dxmin", "axMax", "dxMax", "xgt", "oxmin", "xmin", "oxmax", "oxgt"], "scan_lines_per_block": ["scan_lines_per_pixel", "scan_lines_PER_block", "scan_lines_per_line", "scan_lines_PER_line", "scan_lines_per_type", "scan_lines_PER_type", "scan_lines_PER_pixel"], "scan_line_size": ["scan_block_length", "scan_block_SIZE", "scan_line_SIZE", "scan_line_number", "scan_block_size", "scan_line_length", "scan_block_number"], "uncompressed_size": ["uncompressededmessage", "uncompression_message", "uncompressededSIZE", "uncompressed_SIZE", "uncompression_size", "uncompressededsize", "uncompressededdata", "uncompression_SIZE", "uncompression_data", "uncompressed_data", "uncompressed_message"]}}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static void csrhci_reset(struct csrhci_s *s)\n\n{\n\n    s->out_len = 0;\n\n    s->out_size = FIFO_LEN;\n\n    s->in_len = 0;\n\n    s->baud_delay = NANOSECONDS_PER_SECOND;\n\n    s->enable = 0;\n\n    s->in_hdr = INT_MAX;\n\n    s->in_data = INT_MAX;\n\n\n\n    s->modem_state = 0;\n\n    /* After a while... (but sooner than 10ms) */\n\n    s->modem_state |= CHR_TIOCM_CTS;\n\n\n\n    memset(&s->bd_addr, 0, sizeof(bdaddr_t));\n\n}\n", "idx": 10847, "substitutes": {"s": ["ms", "events", "ports", "sq", "vs", "spec", "locks", "sync", "sl", "qs", "gets", "ats", "eps", "rs", "als", "tests", "as", "hs", "gs", "sts", "ps", "sac", "changes", "cs", "ies", "sv", "ins", "ses", "es", "bs", "store", "aws", "details", "is", "js", "less", "S", "ss", "ts", "its", "y", "pers", "se", "ops", "ads", "os", "sb", "reads", "b", "bis", "acs", "ns", "stats", "fs", "set", "comm", "ls", "ims", "space", "ds", "ers", "parts"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tunsigned i;\n\n\tunsigned num_pixels = src_size >> 1;\n\n\t\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 10849, "substitutes": {"src": ["sq", "usc", "sl", "source", "secure", "ch", "rs", "stream", "sub", "files", "sec", "screen", "supp", "usr", "in", "ser", "rl", "dest", "impl", "scan", "check", "rc", "sur", "input", "sb", "ipl", "sn", "sel", "load", "sr", "inst", "st", "sc", "gb", "ur", "s", "iv", "our", "img", "sys"], "dst": ["dnd", "Dst", "drc", "Drc", "dbl", "ddest", "darc", "daST", " dST", "bdST", "bddest", "bdnd", "dST", " dbl", "dabl", " dnd", "dast", "bdst", "Dbl", " drc", " ddest", "disnd", "disdest", "DST", "disST", "disst"], "src_size": [" src_ize", "src_shape", "sb_size", "src__ize", "sb_shape", "src_Size", "src_offset", "src__Size", "sb_offset", "src_ize", "src_dimension", " src_Size", "sb_dimension", "src__size"], "i": ["id", "ai", "status", "I", "me", "a", "li", "ei", "uri", "print", "ri", "p", "sim", "ex", "ind", "ui", "ip", "jp", "m", "l", "ki", "ti", "ic", "json", "cli", "us", "mi", "index", "is", "j", "im", "ix", "series", "n", "y", "iu", "ci", "\u0438", "zi", "phi", "info", "ik", "xi", "multi", "qi", "e", "used", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "batch", "ini", " ii", " bi", "ji", "name", " j", "asi", "ii"], "b": ["ba", "be", "u", "bf", "a", "back", "base", "rb", "p", "f", "bin", "B", "d", "bc", "l", "m", "fb", "cb", "bs", "bg", "bound", "j", "br", "n", "body", "t", "v", "bo", "e", "sb", "c", "bis", "h", "bi", "w", "bb", "ob", "by", "nb", "gb", "db", "wb"], "g": ["ge", "gg", "gh", "u", "gre", "gp", "gm", "go", "tg", "p", "gs", "f", "pg", "mg", "gr", "d", "l", "m", "ger", "G", "ig", "bg", "eg", "gd", "j", "ga", "rg", "gray", "fg", "reg", "gen", "gu", "gc", "e", "c", "gi", "gam", "gb", "gt", "group", "green"], "r": ["u", "rb", "rs", "err", "range", "ri", "p", "f", "d", "gr", "l", "m", "attr", "mr", "rate", "usr", "term", "rl", "rel", "br", "n", "t", "rg", "rat", "rc", "rd", "reg", "fr", "pr", "e", "rect", "c", "ro", "rt", "re", "sr", "w", "res", "rm", "ur", "vr", "R", "cr", "rar", "ar", "dr", "out"], "rgb": ["mrgd", "srgt", "rgg", "rii", "ggt", "rgt", " Rbb", "rhtml", "urgg", " drgb", "rbb", " rbb", " rgc", " drbb", " rval", " drhtml", "urGB", " Rhtml", " rhtml", "srgc", "reimg", "rcgb", " rgt", "rval", " Rgb", "rcg", "recgb", "regg", "recimg", "urgb", " rimg", " rg", "rgc", " rgg", " rii", "rgd", "srgb", "recGB", "ggc", "rg", "reg", "rcgg", "mrgb", "regb", " rgd", "ggb", " rGB", "recgg", "urimg", "mrval", "rcimg", "ggd", "mrii", "rGB", "rimg", "srgd", "srii", "srval"]}}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n", "idx": 10857, "substitutes": {"netdev": ["etcam", "NETdevice", "NetDev", " netDev", " netdriver", "NETDEV", "networkDev", "NETdev", "natcam", "webdev", "etdev", "Netdev", " netcam", "netdevice", "netcam", "navdevice", "NETdriver", "etdevice", "natdev", "webDEV", "natver", "natdevice", "netDEV", " netdevice", "etver", "webdevice", "navdriver", "webdriver", "netver", "navDEV", "Netdriver", "networkdriver", "navdev", "netdriver", " netver", "networkdev", "netDev"], "name": ["NAME", "key", "id", "net", "nm", "part", "quick", "path", "prefix", "me", "names", "base", "news", "named", "file", "nam", "p", "ident", "error", "normal", "ip", "pkg", "admin", "type", "ame", "local", "common", "word", "term", "family", "mem", "in", "package", "n", "cap", "one", "info", "comment", "cmd", "title", "str", "Name", "user", "no"], "peer": ["shared", "inner", "pc", "pe", "socket", "buffer", "channel", "per", "proc", "p", "pool", "enter", "worker", "established", "component", "instance", "scope", "pkg", "cer", "local", " Peer", "ptr", "parent", "server", "package", "chain", "owner", "node", "ker", "ctx", "ssl", "remote", "target", "member", "er", "context", "public", "private", "soc", "pro", "pod"], "errp": [" errpp", "rrpg", "errorr", "errr", "rrpe", " erp", " errps", "errorpa", "errpe", "err", "erpa", " errpa", "tracer", " erpress", "rrr", "Erpe", "errorP", " errpg", "rrp", "erP", "errpp", " erps", "ErP", "erp", "traceP", "errorp", "Err", " errpress", "errps", " errr", " errP", "Erp", "errpress", "errpa", "tracepp", "errpg", "rrps", " erpg", "errP", "rrpress", "rrP", "tracep", "erpp", " errpe"], "queues": ["quesubes", "fluers", "quasks", "queries", "quesines", "quue", "Queues", " queue", "queures", "qums", "queubes", " queubes", "boues", "QueUES", "Queuers", "quesUES", "Queures", "quesries", "quries", " queumers", "ques", "quesums", "quued", " Queures", "queumers", "flues", " queures", "flries", "quesasks", "Queums", "queue", "quumers", "Queue", "boumers", "boue", "queUES", "quines", "quubes", " Queuers", " queines", " queued", "quues", "quesvers", "quevers", "quesued", "queuers", "que", "queines", " Queues", "queasks", "quesues", "quesuers", " Queue", " queries", "quvers", "qUES", "queued", " queuers", "quesumers", "queums", "quesue", "flasks", "bovers", "quuers"], "vhost_user_opts": ["vhost_user_ps", "vhost_user_popTS", "vhost_user_pros", "vhost_user_opt", "vhost_user_OPs", "vhost_user_setts", "vhost_user_popts", "vhost_user_OPTS", "vhost_user_proters", "vhost_user_sets", "vhost_user_opcs", "vhost_user_tops", "vhost_user_optters", "vhost_user_pcs", "vhost_user_setms", "vhost_user_prots", "vhost_user_OPrs", "vhost_user_popps", "vhost_user_proTS", "vhost_user_prors", "vhost_user_OPters", "vhost_user_props", "vhost_user_sett", "vhost_user_prs", "vhost_user_OPms", "vhost_user_OPt", "vhost_user_opps", "vhost_user_procs", "vhost_user_topts", "vhost_user_opters", "vhost_user_OPts", "vhost_user_oprs", "vhost_user_topms", "vhost_user_opTS", "vhost_user_topt", "vhost_user_OPcs", "vhost_user_pts", "vhost_user_ops", "vhost_user_pops", "vhost_user_setps", "vhost_user_optt", "vhost_user_opms", "vhost_user_optts", "vhost_user_optps", "vhost_user_OPps"], "chr": [" chp", "ichr", " chmr", "chsr", "ichrs", "chmr", "thrs", " chrs", "ichrb", " chc", "Chrs", " chrd", "thr", "shr", "chrs", "Chp", "shc", "ichp", "ichrg", "chers", "Chr", "shrg", "Chsr", "chrb", "thrd", "chrg", " chrg", "ichsr", "cher", "ichmr", " chrb", "ichc", "chp", "chrd", "cherb", "Chrb", "cherd", "chc", " chsr", "thrb", "shmr"]}}
{"project": "FFmpeg", "commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "target": 1, "func": "static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10868, "substitutes": {"gb": ["gg", "gh", "mb", "bf", "gif", "arb", "google", "gm", "rb", "tg", "ng", "gs", "GB", "Gb", "pg", "g", "fb", "git", "cb", "yg", "bg", "eg", "gd", "eb", "vd", "rg", "fg", "ctx", "cfg", "gu", "gc", "sb", "kb", "bb", "nb", "buff", "db", "gt", "bt", "vm", "vg"], "value": ["vector", "buffer", "code", "message", "format", "image", "feature", "weight", "VAL", "valid", "p", "buf", "widget", "field", "unit", "report", "wire", "variable", "block", "process", "type", "sequence", "values", "position", "trace", "function", "package", "bit", "attribute", "property", "index", "version", "data", "total", "commit", "v", "self", "VALUE", "action", "input", "b", "Value", "w", "x", "result", "memory", "description", "content", "byte", "state", "number"], "series": ["ms", "windows", "spec", "prime", "species", "config", "frames", "blocks", "axis", "ints", "Series", "images", "sers", "pins", "sequence", "values", "chains", "groups", "ses", "terms", "bytes", "chain", " Series", "ties", "strings", "eries", "times", "stats", "codes", "IES", "si", "slice", "options", "nos", "seconds", "sis", "steps", "states", "sys", "parts"], "i": ["ms", "id", "ai", "status", "I", "io", "me", "li", "uri", "p", "ii", "o", "sim", "f", "ind", "point", "ui", "ip", "m", "l", "ti", "ic", "us", "bit", "mi", "index", "is", "j", "im", "ix", "n", "y", "t", "ci", "iu", "\u0438", "zi", "v", "info", "phi", "xi", "multi", "e", "b", "h", "gi", "bi", "di", "pi", "si", "by", "it", "x", "batch", "ini", "z", "hi", "spin", "ji", "ims", "ij"], "val": ["arr", "obj", "lit", "num", " Val", "tx", "al", "text", "pt", "base", "VAL", "valid", "p", "var", "bl", "dev", "bin", "mint", "vec", "rol", "l", "ref", "Val", "vt", " bit", "bs", "cal", "bit", "eval", "als", "rel", "data", "test", "t", "ctx", "reg", "v", " v", "V", "pr", "pl", "b", "bal", "elt", "res", "ul", "vals", "it", "x", "z", " vec", " valid", "vol", "ret"], "bits": ["obs", "vs", "rots", "units", "status", "gets", "ats", "blocks", "frames", "weights", "keys", "gs", "bles", "ps", "words", "ints", "changes", "dates", "pos", "points", "outs", "pins", "ots", "values", "orts", "ins", "heads", "xs", "bytes", "bs", "terms", "bit", "als", "js", "its", "ts", "rows", "ids", "bps", "nets", "ops", "os", "limits", "ims", "ips", "tags", "bis", "ns", "stats", "flags", "codes", "vals", "checks", "nos", "ions", "s", "states", "jobs", "length", "items", "parts"]}}
{"project": "FFmpeg", "commit_id": "09ce5519f3b44873ac242e9a2f89db7d459de532", "target": 1, "func": "static void check_add_res(HEVCDSPContext h, int bit_depth)\n\n{\n\n    int i;\n\n    LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);\n\n    LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);\n\n\n\n    for (i = 2; i <= 5; i++) {\n\n        int block_size = 1 << i;\n\n        int size = block_size * block_size;\n\n        ptrdiff_t stride = block_size << (bit_depth > 8);\n\n        declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);\n\n\n\n        randomize_buffers(res0, size);\n\n        randomize_buffers2(dst0, size);\n\n        memcpy(res1, res0, sizeof(*res0) * size);\n\n        memcpy(dst1, dst0, size);\n\n\n\n        if (check_func(h.add_residual[i - 2], \"add_res_%dx%d_%d\", block_size, block_size, bit_depth)) {\n\n            call_ref(dst0, res0, stride);\n\n            call_new(dst1, res1, stride);\n\n            if (memcmp(dst0, dst1, size))\n\n                fail();\n\n            bench_new(dst1, res1, stride);\n\n        }\n\n    }\n\n}\n", "idx": 10869, "substitutes": {"h": ["he", "ph", "ah", "H", "hm", "ch", "q", "here", "k", "p", "f", "m", "l", "hl", "oh", "handle", "hh", "hp", "n", "t", "ctx", "v", "uh", "rh", "host", "b", "c", "sh", "bh", "kh", "hw", "ih", "help", "dh", "ht"], "bit_depth": ["bitlymode", "bit_mode", "bit_Depth", "bit2Depth", " bit_deep", " bit2depth", "bitlystore", "bit2deep", "bit2depth", " bit2Depth", "bit32depth", "bit_store", "bit_deep", "bit_complex", "bitlydeep", " bit_store", "batch_depth", "bit32value", "bit_value", "bitlydepth", "batch_device", "bit32device", " bit2deep", "bit_device", " bit_mode", "bit32complex", " bit_Depth", "batch_value", "batch_complex"], "i": ["id", "ai", "fi", "I", "me", "a", "li", "ei", "uri", "init", " I", "print", "iq", "k", "ri", "p", "sim", "f", "ind", "ui", "d", "ip", "m", "l", "ti", "ic", "in", "mi", "index", "is", "j", "im", "ix", "n", "y", "iu", "ci", "t", "phi", "v", "zi", "xi", "multi", "qi", "b", "bi", "di", "pi", "si", "by", "it", "x", "ini", " ii", " bi", "oi", " j", "ii"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *errp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}\n", "idx": 10875, "substitutes": {"data": ["Data", "empty", "spec", "next", "map", "join", "device", "format", "step", "to", "form", "p", "unit", "error", "da", "d", "ata", "def", "raw", "window", "json", "mu", "mem", "rel", "done", "accept", "t", "bus", "info", "input", "reader", "dat", "rew", "res", "table", "batch", "result", "context", "DATA", "initial"], "unused": [" uninitialized", "unchecked", "UNused", "unalchecked", "unaluse", "uninitialized", "UNuse", " unuse", "unalinitialized", "unuse", "UNinitialized", "unalused", " unchecked", "UNchecked"], "tmp": ["tm", "src", "arr", "tt", "obj", "xy", "mb", "rb", "err", "Temp", "uv", "p", "sp", "buf", "var", "nt", "rw", "mint", "vp", "pkg", "np", "m", "attr", "ptr", "sam", "vt", "txt", "mem", "snap", "perm", "t", "ctx", "aux", "old", "mk", "rt", "temp", "etc", "mut", "nb", "MP", "buff", "imm", "cv", "mp", "emp", "nv", "img"], "errp": ["erpre", "ferpo", "errr", "rrpt", "ererp", "ferpc", "errpt", "err", "lrpy", "rrpc", "attrp", " errpy", "attrpc", "attrpa", "errpo", "rrp", "ererP", "ererr", "rrpy", "erP", "errpc", "erp", "ferpa", " errpre", "ererpre", " errr", " errP", "rrpo", "errpre", "ferp", "errpa", "errP", "rrpa", "errpy", "lrpt", " errpt", "lrp", "attrpo"], "v": ["nv", "vs", "vert", "u", "vy", "av", "vi", "q", "ev", "vv", "uv", "p", "f", "vp", "g", "m", "l", "sv", "i", "vis", "vt", "ver", "j", "y", "t", "V", "b", "c", "h", "w", "it", "x", "cv", "vr", "iv", "vm", "vc", "conv", "tv"]}}
{"project": "qemu", "commit_id": "a9321a4d49d65d29c2926a51aedc5b91a01f3591", "target": 0, "func": "void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)\n\n{\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR4 update: CR4=%08x\\n\", (uint32_t)env->cr[4]);\n\n#endif\n\n    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=\n\n        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {\n\n        tlb_flush(env, 1);\n\n    }\n\n    /* SSE handling */\n\n    if (!(env->cpuid_features & CPUID_SSE))\n\n        new_cr4 &= ~CR4_OSFXSR_MASK;\n\n    if (new_cr4 & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    env->cr[4] = new_cr4;\n\n}\n", "idx": 10877, "substitutes": {"env": ["vs", "ah", "menu", "config", "end", "vv", "proc", "uv", "enter", "eng", "vp", "block", "desc", "qt", "cmd", "nc", "ent", "context", "cv", "era", "et", "tk", "ec", "ve", "buf", "Environment", "en", "server", "outer", "esc", "conn", "conf", "environment", "e", "app", "door", "ender", "nv", "obj", "policy", "req", "err", "enc", "ev", "engine", "worker", "cur", "def", "vt", "window", "shell", "equ", "EN", "ctx", "die", "exec", "er", "console", "exc", "timer", "entry", "extra", "eh", "here", "manager", "erd", "ack", "dev", "En", "chart", "pkg", "expr", "ew", "v", "ten", "po", "response", "viron"], "new_cr4": ["new_r_", "new_rc04", "new_Cr4", "new_rc4", "new_Crfour", "new__crfour", "new_tr04", "new_sr04", "new_cr_", "new_cr44", "new_r4", "new_rfour", "new_Cr2", "new_cm04", "new_cd44", "new_sr8", "new_cdfour", "new_cr2", "new_r2", "new_pr2", "new__cr_", "new__rc2", "new_rc44", "new_rc2", "new_ctrfour", "new_cm4", "new_crfour", "new__rcfour", "new_Cr04", "new_pr4", "new_pr8", "new_tr4", "new_cd04", "new_sr4", "new__cr4", "new__rc_", "new_cm2", "new_ctr4", "new_ctr2", "new_cr8", "new_ctr3", "new__cr2", "new_cm_", "new_sr2", "new_rc_", "new_Cr44", "new_tr2", "new_rcfour", "new__rc4", "new_cmfour", "new_cr3", "new_pr04", "new_cm8", "new_cd4", "new_rc3", "new_cr04", "new_Cr3"]}}
{"project": "qemu", "commit_id": "ffad4116b96e29e0fbe892806f97c0a6c903d30d", "target": 0, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 10899, "substitutes": {"arg": ["doc", "op", "arp", "config", "call", "cell", "event", "ack", "job", "ay", "argument", "pg", "g", "admin", "ref", "ark", "args", "cand", "parse", "ig", "mem", "cal", "md", "ma", "Arg", "ad", "emb", "mer", "ac", "reg", "ang", "mark", "cmd", "agent", "og", "ag", "tag", "param", "ax", "loc", "ar"], "snapshot": ["sysshot", "Snapshot", "apaction", "sysvol", "Snapvol", "Snapaction", "snapvol", "sysaction", "apvol", "apshot", "sysshots", "Snapshots", "snapaction", "apshots", "snapshots"], "opaque": ["ipque", "ipatile", "pacity", "operaque", "opient", "ipaque", "opaques", "OPacity", "opque", "oppient", "OPaque", "oque", "operacity", "oaque", "oppaques", "operaques", "oacity", "ipacity", "paque", "oppacity", "oppaque", "oatile", "OPatile", "paques", "operient", "OPque", "pient", "opatile", "opacity"], "buf": ["doc", "map", "alloc", "proc", "prop", "pg", "rw", "Buffer", "block", "attr", "desc", "queue", "r", "data", "cap", "b", "cmd", "orig", "cv", "history", "conv", "arr", "tr", "filename", "read", "path", "code", "uf", "rb", "init", "iter", "bc", "args", "txt", "dir", "Buff", "batch", "bt", "img", "src", "obj", "array", "buffer", "err", "var", "cp", "cur", "ref", "def", "window", "ctx", "bus", "tmp", "ba", "text", "base", "p", "pool", "seq", "bin", "act", "pkg", "np", "cb", "bytes", "br", "box", "rc", "cfg", "ctr", "buff", "msg"], "file": ["page", "filename", "array", "board", "buffer", "path", "io", "code", "base", "device", "channel", "resource", "ile", "File", "f", "unit", "volume", "files", "block", "limit", "position", "port", "le", "family", "queue", "chain", "header", "connection", "body", "bus", "dir", "line", "fat", "stat", "table", "link", "db", "disk", "name", "vol", "number"], "devname": ["deviceword", "volname", "diskname", "divaddr", "evtype", "devicebase", "DevName", "devicedef", "busword", "devgroup", "devdef", "devtype", "Devnames", "busName", "privName", "evName", "devbase", "devicename", "privpath", "devstr", "devName", "diskName", "busbase", "busname", "divdef", "evgroup", "devaddr", "devword", "volword", "devpath", "propname", "propName", "volName", "divtype", "divstr", "volgroup", "evpath", "privgroup", "proptype", "volpath", "devnames", "divName", "privname", "deviceName", "devicenames", " devName", "propstr", "volbase", " devnames", "diskaddr", "diskdef", "evname", "deviceaddr", "evstr", "Devname", "divname"], "serial": ["Serial", "num", "device", "proc", "ident", "iso", "error", "sector", "label", "phone", "port", "util", "ser", "security", "version", "mode", "bus", "unknown", "ion", "comment", "controller", "speed", "driver", "description", "loc", "vol", "number"], "mediastr": ["mediestr", "mediestar", "mediaserrip", "mediaserructure", "medustructure", "mediestructure", "medastructure", "medastrip", "mediastructure", "medustr", "mediaserar", "medustar", "medastar", "mediaserr", "medastr", "mediestrip", "mediastrip", "mediustructure", "mediustr", "mediastar", "mediustrip", "mediustar", "medustrip"], "type": ["command", "op", "id", "typ", "category", "pe", "language", "ty", "where", "message", "policy", "format", "ping", "types", "role", "event", "list", "TYPE", "instance", "position", "parent", "relation", "kind", " family", "ver", "family", "all", "top", "rel", "create", "Type", "test", "interface", "like", "t", "view", "ype", "class", "change", "copy", "title", "rule", "time", " TYPE", "state", "style"], "media": ["command", "pic", "category", "language", "io", "movie", "message", "policy", "device", "image", "history", "area", "picture", "meta", "volume", "medi", "relation", "util", "storage", "medium", "communication", "browser", "version", "magic", "Media", "interface", "mode", "metadata", "production", "reader", "option", "library", "camera", "memory", "module", "content", "gallery", "style", "material", "bridge"], "bus_id": ["bus_ID", "bus2pid", "block_id", " bus2ids", "bus2ID", " bus2id", "bus_name", "busgit", " bus_ident", " bus2ID", "block_kid", "box_ID", "buszident", "bus2id", "bus_ids", "box_name", "bus_Id", " bus_pid", "busgname", "box_id", "buszid", "buszkid", " bus_ids", "bus_kid", "busgID", " bus_ref", "block_Id", "bus_pid", "bus_ref", "block_ident", "busgid", " bus2pid", " bus_ID", "buszId", "bus_ident", "bus2ids", "box_it", "bus_it"], "unit_id": ["bus_ID", " unit_type", "unit_type", "unit_status", " unit_ids", "unit_ids", "unit2type", "bus_name", "unit_ID", "unit2id", "unit_name", " unit_status", " unit_ID", " unit_ident", "unit2status", "unit2ID", "unit_ident"], "cyls": ["cyols", "styols", "cyles", "syols", "lyols", "syles", "tyles", "tyls", "cyl", "lyles", "styjs", "styles", " cyrs", "tyrs", "tyl", "syrs", "lyls", "lyjs", "syjs", "styls", "cyrs", " cyl", "syl", " cyles", "cyjs", "syls"], "heads": ["tops", "ashes", "locks", "aunts", "cks", "blocks", "tails", "workers", "HEAD", "sticks", "uploads", "offs", "pages", "docs", "outs", "relations", "links", " Heads", "rows", "views", "mins", "bots", "roots", "sets", "ads", "headed", "limits", "reads", "loads", "hops", "headers", "masters", "maps", "head", "hours", "aches", "uns", "helps"], "secs": [" secns", " seccs", " secss", "Secls", "secns", "divls", "sqs", "sectcs", " secls", "secss", "sqls", "sqss", "sqns", "Seccs", "divs", "secS", "sectS", "sectls", " secS", "sects", "divss", "seccs", "SecS", "divns", "secls", "Secs"], "translation": ["command", "Translation", "tr", "language", "source", "message", "padding", "lang", "settings", "lation", "lations", "trans", "normal", "location", "operation", "late", "utils", "relation", "util", "using", "family", "rating", "communication", "version", "generation", "selection", "direction", "ion", "transform", "binding", "comment", "heading", "alias", "options", "creation", "usage", "description", "history", "versions", "conv"], "bdrv": ["bdrvs", " bdrV", "bldV", "bderv", "bldv", " bdrm", "bldvs", " bdrvs", " bderm", " bderV", "bdrm", " bderv", "bdrV", "bldm", "bsrvs", "bsrV", "bderm", " bdervs", "bsrv", "bderV", "bdervs", "bsrm"], "drv": [" drm", "derp", "derm", " drvs", "derv", "srp", "dervs", "srvs", "drvs", "drm", "srm", " drp", "srv", "drp"], "machine": ["command", "network", "policy", "device", "image", "manager", "meta", "engine", "volume", "domain", "variable", "instance", "m", "parent", "model", "storage", " machines", "chain", "magic", "owner", "connection", "interface", "handler", "mc", "mobile", "mode", "Machine", "host", "achine", "mob", "target", "mobi", "link", "memory", "disk", "module", "vm", "state", "template"], "max_devs": ["max_vols", "max_evs", "max_devts", "max_devms", "max_evS", "max_devions", "max_defions", "max_volions", "max_Devts", "max_devds", "max_Devds", "max_ptts", "max_volS", "max_defS", "max_evions", "max_pts", "max_devS", "max_evds", "max_Devms", "max_evms", "max_DevS", "max_defs", "max_ptds", "max_evts", "max_Devs", "max_volms"], "index": ["page", "key", "num", "id", "address", "status", "code", "order", "axis", "error", "ind", "location", "instance", "stable", "pos", "position", "i", "loop", "connect", "version", "Index", "level", "connection", "interface", "count", "info", "action", "lock", "comment", "x", "link", "context", "speed", "access", "loc", "offset", "size"], "cache": ["oc", "acc", "comments", "sync", "Cache", "cmp", "map", "config", "con", "code", "toc", "module", "hash", "volume", "cycle", "cover", "capacity", "dc", "limit", "timeout", "cc", "session", "ached", "scan", "ac", "check", "count", "rc", "gc", "c", "comment", "lock", "option", "scale", "master", "force", "cu", "co", "debug", "max", "ache", "aches"], "bdrv_flags": ["bdrve_limits", "bdrv__flags", "bdrve_flags", "bdrv_flag", "bdrv_limits", "bdrv__stats", "bdrv__flag", "bdrve_flag", "bdrv__limits", "bdrv_stats", "bdrve_stats"], "onerror": ["ierror", "asterrored", "onerrr", "rerrr", "asterror", "ierrr", "asterrr", "rerROR", "rerrored", "onerrored", "onerROR", "rerror", "ierrored", "asterROR", "ierROR"], "drives_table_idx": ["drives_table_Idxs", "drives_table_Idindex", "drives_table_indx", "drives_table_indnum", "drives_table_Idx", "drives_table_idindex", "drives_table_Idnum", "drives_table_indindex", "drives_table_idxs", "drives_table_idnum", "drives_table_indxs"], "str": ["arr", "key", "doc", "obj", "tr", "spec", "priv", "cmp", "status", "buffer", "text", "par", "vol", "format", "rs", "Str", "err", "enc", "list", "bool", "proc", "sp", "var", "p", "ps", "trans", "attr", "def", "ptr", "desc", "raw", "parse", "txt", "usr", "ext", "expr", "r", "cont", "chain", "try", "br", "data", "fr", "cfg", "ctr", "exec", "inst", "nick", "orig", "res", "er", "st", "msg", "STR", "String", "name", "conv", "ar", "dr", "out"], "params": ["AMS", "comments", "spec", "units", "cmp", "errors", "config", "par", "names", "settings", "types", "keys", "list", "proc", "p", "ps", "changes", "files", "pos", "pins", "attr", "args", "values", "json", "data", "conf", "cfg", "ops", "strings", "headers", "tags", "tmp", "flags", "options", "ams", "vals", "actions", "param", "s", "name", "conv"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n", "idx": 10914, "substitutes": {"fd": ["td", "fin", " fin", "dd", "dos", "id", "fi", "bf", "socket", "ffff", "ff", "file", "stream", "df", "f", "fp", "da", "d", "pos", "fb", "ud", "hd", " df", "fe", "port", "lf", "fa", "ln", "dl", "rd", "fr", "dir", "FD", " fid", "du", "fs", "fee", "fc", "fed", " f", "disk", "sd", " fut", "pid", "ds"], "err": ["kr", "obj", "ef", "norm", "Error", "rs", "or", "erd", "ev", "resp", "buf", "error", "ex", "aaa", "ox", " terr", "attr", "rn", "eor", "mr", "cand", "rr", "usr", "aer", "Er", "r", "rc", "fr", "e", "die", "eas", "der", "elt", "fee", "er", "ocr", "coord", "msg", "ez", "ner", "cr", "exc", "ar"], "opaque": ["opsasus", "popvious", "oplaque", "oiera", "opaques", "opque", "oasus", "ipaques", "oplasus", "opvious", "opsaque", "oplvious", "opasus", "oque", "opliera", "oaque", "opsiera", "oplacity", "popaques", "ipacity", "oplaques", "ipvious", "popacity", "oplque", "opsque", "opiera", "popaque", "ipaque", "opacity"], "s": ["sq", "spec", "sl", "qs", "a", "settings", "rs", "hs", "gs", "sts", "an", "ps", " ss", "ess", "g", "m", "l", "cs", "sv", "es", "sam", "bs", "iss", "details", "als", "is", "j", "S", "ss", "ts", "n", "se", "js", "less", "y", "ssl", "mos", "v", "sb", "b", "sw", "bis", "h", "ns", "stats", "z", "set", "sis", "comm", "ls", "ds", "sys", "store"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *pict, int *got_packet)\n\n{\n\n    LJpegEncContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    const int width  = avctx->width;\n\n    const int height = avctx->height;\n\n    const int mb_width  = (width  + s->hsample[0] - 1) / s->hsample[0];\n\n    const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0];\n\n    int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE;\n\n    int ret, header_bits;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        max_pkt_size += width * height * 3 * 3;\n\n    else {\n\n        max_pkt_size += mb_width * mb_height * 3 * 4\n\n                        * s->hsample[0] * s->vsample[0];\n\n    }\n\n    if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", max_pkt_size);\n\n        return ret;\n\n    }\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n\n\n    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,\n\n                                   s->matrix);\n\n\n\n    header_bits = put_bits_count(&pb);\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        ret = ljpeg_encode_bgr(avctx, &pb, pict);\n\n    else\n\n        ret = ljpeg_encode_yuv(avctx, &pb, pict);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(&pb, header_bits);\n\n\n\n    flush_put_bits(&pb);\n\n    pkt->size   = put_bits_ptr(&pb) - pb.buf;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10950, "substitutes": {"avctx": ["vaaddr", " avcontext", "avconn", " avtmp", "avecontext", "avercmp", "averconfig", "jamcontext", "navcu", " avcc", "avcmd", "avaddr", "ravcc", "avecu", "averctx", "avcmp", "averjac", "avejac", "avercfg", "avetx", "afpkg", "devjac", "jamctx", "jamcu", "aftx", "vacfg", "devctx", "wavctx", "ajpkg", "navctx", "wavcc", "AVctx", "savct", "avcontext", "aveaddr", "avercontext", "savconn", "AVpkg", "ajctx", "avconfig", "avectx", "ajtx", "aveconfig", "aveclient", " avconn", "avertmp", "avcheck", "avtmp", "averaddr", "savctx", "avcfg", "devcmp", " avtx", "avercmd", "wavtx", "avcu", "ajjac", " avcmd", "avcam", "wavconfig", "afctx", "apconn", "AVtx", "avecam", "ravctx", "AVcontext", "ravcam", "ajclient", "apct", "afjac", "navtmp", "avct", "avecheck", "vactx", "afcontext", "avercc", "avclient", "wavcontext", "avjac", "wavpkg", "ajcmp", "avcc", "apctx", "navcontext", "apcontext", "avecfg", "avecc", "jamtx", " avpkg", " avcu", "avecmp", " avcam", "savcontext", "averpkg", "avercheck", "afcmd", "devclient", "wavcmp", " avct", "vacheck", "avertx", "avtx", "avpkg", "ravcontext", "avercu"], "pkt": ["lpet", " packet", "pnt", "wpett", "lpkt", "wacket", "cpacket", "wpnt", "lpacket", "petx", "Pnt", "pdu", "lpnt", "apacket", "wdu", " pett", "spacket", "ppt", "Pkt", " pdu", "spact", "wpkt", "Pct", "cpet", " pnt", "wnt", "wpacket", "pent", "wpkl", "cpct", " pet", "wpdu", "spet", "wett", "packet", " pact", " pct", "wppt", "spkt", "Pact", "pett", "ptx", "wpt", "cpkt", " ppt", "peacket", "pekt", "apkt", "apnt", "wkt", "wkl", "Packet", "pkl", "pet", "pact", "pct", "aptx", "Pet", " ptx", " pkl"], "pict": ["png", "mot", "pic", "Pic", "gif", "fi", "sci", "pas", "pt", "fig", "cam", " tum", "picture", "kt", "p", "act", "def", "capt", "txt", "pub", " img", "Pict", "pai", "pres", "cont", "isch", " feat", "phy", "ctx", "conf", "hot", "feat", " picture", "fat", "rect", "eric", " pic", "stat", "phys", "fx", "camera", " crap", "Picture", "pain", "img", "ht"], "got_packet": ["got_packset", "got_presetime", "got_buck_", "got_packsetime", "got_pres_", "got_presacket", "got_pack_", "got_bucket", "got_buckacket", "got_packetime", "got_pick_", "got_packsacket", "got_presets", "got_packacket", "got_buckets", "got_bucketime", "got_preset", "got_packsets", "got_packets"], "s": ["sq", "spec", "sl", "ares", "aunts", "qs", "a", "ats", "rs", "hs", "p", "gs", "sts", "an", "sp", "ex", "ps", "ants", "ess", "changes", "d", "g", "cs", "l", "m", "ins", "sv", "es", "ses", "sam", "scl", "bs", "details", "aws", "less", "js", "r", "S", "ss", "ts", "its", "j", "y", "t", "ctx", "styles", "sports", "v", "conf", "os", "sb", "has", "ims", "c", "sh", "sw", "bis", "h", "ns", "stats", "fs", "serv", "stat", "sc", "comm", "ls", "sd", "ds", "sys"], "pb": ["lb", "apy", "cam", "proc", "func", "prop", "pg", "vp", " buf", "pub", "eb", "pl", "b", "PB", "cv", "td", "bj", "tp", "uf", "rb", "bolt", "tk", "ping", "tg", "sp", "buf", "rob", "jp", "wb", "bs", "emb", "sb", "bot", "dp", "batch", "pack", "mp", "patch", "pod", "pic", "pas", "pc", "pt", "bp", "resp", " np", "cp", " PB", "tab", "pac", "ctx", "px", "erb", "tmp", " proto", "peer", "gb", "pak", "db", "py", " mp", "p", "pool", "ps", "BP", "pkg", "np", "cb", "ab", "orp", "lp", "tap", "wp", "bh", "kw", "stab", "buff", "sys", "pa"], "ret": ["reset", "jump", "print", "prop", "ry", " Ret", "desc", "r", "t", "mel", "rem", "deg", "cmd", "elt", "vet", "rm", "result", "ll", "arg", "arr", "fin", "tr", "status", "RET", "value", "rev", "pret", "usr", "ern", "ter", "try", "rets", "Ret", "rt", "att", "tf", "pas", "back", "resp", "hash", "nt", "ref", "def", "mem", "plain", "reg", "class", "it", "cert", "ft", "out", "mt", "len", "lit", "success", " RET", "flag", "det", "fun", "alt", "ext", "cont", "gc", "val", "re", "res", "ber", "gt", "Return"], "header_bits": [" header_details", "header_bytes", " header_its", "header_properties", " header_bit", "header_flags", " header_properties", " header_bytes", " header_bugs", "header_its", " header_flags", "header_bit", "header_bugs", "header_details"]}}
{"project": "FFmpeg", "commit_id": "27bcf55f459e038e81f09c17e72e6d44898b9015", "target": 1, "func": "int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterLink *outlink = buffer_filter->outputs[0];\n\n    int ret;\n\n\n\n    if (c->picref) {\n\n        av_log(buffer_filter, AV_LOG_ERROR,\n\n               \"Buffering several frames is not supported. \"\n\n               \"Please consume all available frames before adding a new one.\\n\"\n\n            );\n\n        //return -1;\n\n    }\n\n\n\n    if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n\n        AVFilterContext *scale = buffer_filter->outputs[0]->dst;\n\n        AVFilterLink *link;\n\n        char scale_param[1024];\n\n\n\n        av_log(buffer_filter, AV_LOG_INFO,\n\n               \"Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name,\n\n               picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name);\n\n\n\n        if (!scale || strcmp(scale->filter->name, \"scale\")) {\n\n            AVFilter *f = avfilter_get_by_name(\"scale\");\n\n\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n\n            if ((ret = avfilter_open(&scale, f, \"Input equalizer\")) < 0)\n\n                return ret;\n\n\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\", c->w, c->h, c->sws_param);\n\n            if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n            scale->outputs[0]->time_base = scale->inputs[0]->time_base;\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        } else if (!strcmp(scale->filter->name, \"scale\")) {\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\",\n\n                     scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n\n            scale->filter->init(scale, scale_param, NULL);\n\n        }\n\n\n\n        c->pix_fmt = scale->inputs[0]->format = picref->format;\n\n        c->w       = scale->inputs[0]->w      = picref->video->w;\n\n        c->h       = scale->inputs[0]->h      = picref->video->h;\n\n\n\n        link = scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    c->picref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,\n\n                                          picref->video->w, picref->video->h);\n\n    av_image_copy(c->picref->data, c->picref->linesize,\n\n                  picref->data, picref->linesize,\n\n                  picref->format, picref->video->w, picref->video->h);\n\n    avfilter_copy_buffer_ref_props(c->picref, picref);\n\n\n\n    return 0;\n\n}\n", "idx": 10962, "substitutes": {"buffer_filter": ["bridgeitylock", "batch_context", "buffergfil", "package_stream", "bufferlyfilter", "bufferptresult", " buffer_trigger", "bufferopblock", "bridge_test", "buffer_context", "batch___info", "buffer_test", "scalegerror", "buffer_info", "scale_filter", "bufferopfilter", " buffer2find", "bufferptdriver", "buffer_Filter", "bufferptformat", "batch_filter", "buffer_driver", "buffer64filter", "buffer2filter", "packageopfilter", "batch_info", "bufferlycontext", "bufferptcontainer", "bufferptlist", "buttonptlist", "buttonptformat", "bufferopcontainer", "scalegfil", "packageopcontainer", "bridgeityfilter", "buffer_find", "bufferpttrigger", " buffer__find", "bridgeityformat", "buffer___context", "bridgeitytest", "bridge_lock", "button_list", " buffer__filter", " buffer_result", " buffer2fil", "bufferptblock", "buffer__filter", "buffergfilter", "buffer2Filter", "bufferletformat", "buffer__find", "button_format", "bufferlyload", "buttonptfilter", " buffer_stream", "scalegactivate", "buffergerror", "bufferopstream", "buffer_trigger", "buffer64find", "buttonptdriver", "package_block", "batch___load", "packageopstream", "buffer_stream", "buffer___info", "buffer_list", "buffer2find", " buffer_Filter", "batch___context", " buffer2filter", "bufferletfilter", " buffer_find", "buffergactivate", "buffer2fil", "buffer64fil", " buffer_format", "button_filter", "batch_load", "bufferptfilter", "bufferlyinfo", "bufferletresult", "buffer__format", "bufferitytest", "scale_fil", "buffer_container", "bridge_format", "bufferlettrigger", "buffer_format", " buffer_fil", "package_container", "bufferityformat", "scale_error", "batch___filter", "button_driver", " buffer2Filter", "bufferitylock", "buffer_lock", "buffer_load", "buffer___filter", "packageopblock", "buffer__stream", "buffer_error", "buffer64Filter", "buffer_block", "bufferptstream", " buffer__stream", "scale_activate", "bufferityfilter", "buffer_fil", " buffer__format", "scalegfilter", "package_filter", "buffer_result", "buffer___load", "bridge_filter", "buffer_activate"], "picref": ["pngref", "nicRef", " picmb", "camref", "icref", "nicre", "picrel", "icrf", " picre", "pcob", "pcro", "pinrel", "piconly", "pinarg", "pinrange", "pireference", "nicref", "picre", "icRef", "pngreference", "pcreference", "camreference", "acreference", "camonly", "picfirst", "pinrf", "pcref", "pegreference", "pinre", "panrf", "panref", "picarg", " picro", "panarg", "picRef", " picdiff", "pngfirst", "pegref", "acob", "picob", "nicob", "picreq", "panreference", "pinreq", "picmb", "icreference", "nicarg", "nicro", " picob", "pegfirst", "pinconf", " picrel", "pegonly", "picro", "pimb", " picreference", "nicreq", "pinref", "camfirst", " picconf", "picconf", "pirange", "icreq", "piref", "picrf", "acref", "pinmb", "nicdiff", "picreference", "icarg", "pngonly", "icconf", "pinreference", " picrange", "pinRef", "acrel", "pindiff", "pinob", "picrange", "picdiff", "nicreference", " picRef"], "c": ["u", "config", "cam", "ct", "rec", "circle", "d", "cat", "cs", "m", "cc", "ce", "t", "ci", "nc", "w", "context", "comm", "cv", "conv", "cmp", "call", "ctrl", "ec", "bc", "dc", "g", "ac", "count", "conf", "comp", "cm", "etc", "sc", "draw", "current", "pc", "abc", "cp", "cur", "tc", "l", "i", "container", "ic", "chain", "n", "mc", "ctx", "lc", "cn", "anc", "uc", "com", "can", "vc", "ca", "arc", "comments", "con", "p", "cf", "this", "cb", "cont", "coll", "rc", "v", "gc", "cache", "h", "cu", "fc", "C", "co"], "outlink": ["outline", "OUTlink", "OUTLink", "inlink", " outLink", "inLink", "outLink", " outline", "OUTline"], "ret": ["reset", "jump", "format", "print", "ry", "cat", " Ret", "progress", "t", "mel", "rem", "irm", "deg", "elt", "rm", "result", "ll", "arr", "tr", "status", "RET", "iter", "rev", "usr", "txt", "try", "rets", "Ret", "rt", "att", "pas", "net", "url", "nl", "back", "err", "valid", "resp", "nt", "ref", "def", " alt", "mem", "last", "__", "reg", "it", "ft", "out", "mt", "success", " RET", "Alt", "flag", "complete", "det", "pass", "del", "alt", "cont", "not", "gc", "val", "mail", "re", "res", "full", "gt", "Return"], "scale": ["config", "feature", "cam", "screen", "parse", "ser", "create", "allow", "data", "se", "scan", "slice", "ale", "conv", "size", "share", "ice", "use", "Scale", "call", "status", "channel", "average", "match", "init", "cale", "score", "g", "rate", "ize", "server", "video", "alpha", "radius", "cast", "alias", "si", "xml", "sc", "draw", "acc", "spec", "image", "valid", "sample", "error", "scope", "l", "raw", "sale", "mask", "filter", "forge", "sort", "info", "remote", "transform", "can", "grade", "sche", "sync", "base", "iso", "sim", "service", "save", "all", "super", "sup", "series", "coll", "total", "site", "cache", "gc", "scene", "query", "fc", "fx", "set", "center", "rage", "sys", "store"], "link": ["status", "path", "base", "match", "Link", "linked", "error", "tile", "label", "l", "type", "relation", "rel", "node", "scan", "info", "action", "line", "transform", "lock", "load", "slice", "set", "le", "loc", "ink"], "scale_param": ["scale_params", "scale_min", " scale_params", "scale_comment", "scaleerattribute", "cale2name", "scale2min", "scalepyvar", "cale2param", "scale2params", "scale_attribute", "scale_index", "scale2param", "scale2cal", "scale2name", " scale2params", " scale2min", "cale2var", "scalepycal", " scale2param", "scaleerparam", "cale_var", "scalepyname", "cale_param", " scale2index", "scale_name", " scale_min", "scale2var", "cale_params", "cale2params", "scaleerstring", "scale_cal", "scale2index", "cale_attribute", "cale_string", "scale_var", "scalepyparam", "cale2cal", " scale_index", "cale_comment", "scaleerparams", "cale2comment", "cale_cal", "cale_name", "scale_string", "scale2comment"], "f": ["tf", "fw", "fi", "bf", "fl", "fo", "file", "p", "fp", "cf", "g", "l", "m", "i", "conv", "fa", "filter", "fn", "t", "fg", "v", "fr", "sf", "e", "b", "fac", "h", "F", "w", "fs", "fc", "ft", "xf"]}}
{"project": "FFmpeg", "commit_id": "9568b2e425f127031ddc91dd78cb9b9f2cae206d", "target": 1, "func": "int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n                                         H264ParamSets *ps, int bit_length)\n{\n    AVBufferRef *pps_buf;\n    const SPS *sps;\n    unsigned int pps_id = get_ue_golomb(gb);\n    PPS *pps;\n    int qp_bd_offset;\n    int bits_left;\n    int ret;\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    pps_buf = av_buffer_allocz(sizeof(*pps));\n    if (!pps_buf)\n        return AVERROR(ENOMEM);\n    pps = (PPS*)pps_buf->data;\n    pps->data_size = gb->buffer_end - gb->buffer;\n    if (pps->data_size > sizeof(pps->data)) {\n        av_log(avctx, AV_LOG_WARNING, \"Truncating likely oversized PPS \"\n               \"(%\"SIZE_SPECIFIER\" > %\"SIZE_SPECIFIER\")\\n\",\n               pps->data_size, sizeof(pps->data));\n        pps->data_size = sizeof(pps->data);\n    memcpy(pps->data, gb->buffer, pps->data_size);\n    pps->sps_id = get_ue_golomb_31(gb);\n    if ((unsigned)pps->sps_id >= MAX_SPS_COUNT ||\n        !ps->sps_list[pps->sps_id]) {\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", pps->sps_id);\n    sps = (const SPS*)ps->sps_list[pps->sps_id]->data;\n    if (sps->bit_depth_luma > 14) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Invalid luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n    } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Unimplemented luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n        ret = AVERROR_PATCHWELCOME;\n    pps->cabac             = get_bits1(gb);\n    pps->pic_order_present = get_bits1(gb);\n    pps->slice_group_count = get_ue_golomb(gb) + 1;\n    if (pps->slice_group_count > 1) {\n        pps->mb_slice_group_map_type = get_ue_golomb(gb);\n        av_log(avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n        switch (pps->mb_slice_group_map_type) {\n        case 0:\n#if 0\n    |       for (i = 0; i <= num_slice_groups_minus1; i++)  |   |      |\n    |           run_length[i]                               |1  |ue(v) |\n#endif\n            break;\n        case 2:\n#if 0\n    |       for (i = 0; i < num_slice_groups_minus1; i++) { |   |      |\n    |           top_left_mb[i]                              |1  |ue(v) |\n    |           bottom_right_mb[i]                          |1  |ue(v) |\n    |       }                                               |   |      |\n#endif\n            break;\n        case 3:\n        case 4:\n        case 5:\n#if 0\n    |       slice_group_change_direction_flag               |1  |u(1)  |\n    |       slice_group_change_rate_minus1                  |1  |ue(v) |\n#endif\n            break;\n        case 6:\n#if 0\n    |       slice_group_id_cnt_minus1                       |1  |ue(v) |\n    |       for (i = 0; i <= slice_group_id_cnt_minus1; i++)|   |      |\n    |           slice_group_id[i]                           |1  |u(v)  |\n#endif\n            break;\n    pps->ref_count[0] = get_ue_golomb(gb) + 1;\n    pps->ref_count[1] = get_ue_golomb(gb) + 1;\n    if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) {\n        av_log(avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n    qp_bd_offset = 6 * (sps->bit_depth_luma - 8);\n    pps->weighted_pred                        = get_bits1(gb);\n    pps->weighted_bipred_idc                  = get_bits(gb, 2);\n    pps->init_qp                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->init_qs                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->chroma_qp_index_offset[0]            = get_se_golomb(gb);\n    pps->deblocking_filter_parameters_present = get_bits1(gb);\n    pps->constrained_intra_pred               = get_bits1(gb);\n    pps->redundant_pic_cnt_present            = get_bits1(gb);\n    pps->transform_8x8_mode = 0;\n    memcpy(pps->scaling_matrix4, sps->scaling_matrix4,\n           sizeof(pps->scaling_matrix4));\n    memcpy(pps->scaling_matrix8, sps->scaling_matrix8,\n           sizeof(pps->scaling_matrix8));\n    bits_left = bit_length - get_bits_count(gb);\n    if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) {\n        pps->transform_8x8_mode = get_bits1(gb);\n        decode_scaling_matrices(gb, sps, pps, 0,\n                                pps->scaling_matrix4, pps->scaling_matrix8);\n        // second_chroma_qp_index_offset\n        pps->chroma_qp_index_offset[1] = get_se_golomb(gb);\n        if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) {\n    } else {\n        pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0];\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0],\n                   sps->bit_depth_luma);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1],\n                   sps->bit_depth_luma);\n    init_dequant_tables(pps, sps);\n    if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        pps->chroma_qp_diff = 1;\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(avctx, AV_LOG_DEBUG,\n               \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\");\n    remove_pps(ps, pps_id);\n    ps->pps_list[pps_id] = pps_buf;\n    return 0;\nfail:\n    av_buffer_unref(&pps_buf);\n    return ret;", "idx": 10971, "substitutes": {"gb": ["tm", "py", "obj", "gg", "gif", "mb", "bf", "pc", "gh", "buffer", "io", "gm", "gp", "uf", "rb", "rs", "hub", "sg", "tg", "gs", "buf", "GB", "Gb", "cp", "hz", "pg", "bc", "g", "np", "bm", "fb", "gz", "attr", "cb", "bn", "bs", "bg", "storage", "eg", "gd", "pm", "pb", "eb", "ctx", "rg", "vg", "cfg", "gc", "sb", "b", "tmp", "kb", "gy", "cm", "sys", "bb", "nb", "img", "buff", "db", "gt", "cv", "bt", "vm", "hog", "wb", "bridge"], "avctx": [" avctl", " avcp", "avesetup", "mediacp", " avcontext", "savreq", "avctl", "avconn", "avertc", " avgc", "avcpp", " avreq", "avecontext", "avereq", "avetc", "averctl", "avectl", "avecpp", "navcmd", "averca", "averconn", "savgc", "avcp", "navctx", "avcmd", "avreq", "avcontext", "avercp", "mediactx", "avergc", "avecmd", "aversc", "avercontext", "avgc", "avtc", "mediacontext", "aversetup", "avca", "avercpp", " avsetup", "navcpp", "avesc", "mediagc", "avectx", "savca", "aveconn", "avsc", "navsc", " avconn", "avsetup", "averctx", "navreq", "navtc", "savctx", "avegc", "averreq", "avercmd", "aveca"], "ps": ["abilities", "ms", "amps", "ports", "aps", "ists", "ats", "pp", "pt", "places", "eps", "ppa", "pse", "css", "Ps", "gs", "sts", "pes", "dates", "cs", "ies", "ins", "fps", "ups", "posts", "pres", "pers", "js", "plays", "als", "ples", "ts", "its", "ands", "mys", "PS", "ops", "ips", "caps", "alls", "ets", "times", "ks", "checks", "mp", "ims", "ds", "params", "parts"], "bit_length": [" bit_padding", " bit64size", "bit_len", " bit64length", "bit64size", "bit_padding", "bit42padding", "bit42len", " bit64padding", "bit64length", " bit_len", "bit64padding", "bit_size", " bit64len", "bit42size", " bit_size", "bit42length", "bit64len"], "pps_buf": ["pps2vec", "pps_vec", "pp_alloc", "pps_fg", "pps_alloc", "pps_buffer", "pps_obj", "pps2uf", "pp_buff", "ps_uf", "pps___buff", "pp_fg", "pp_vec", "pps2alloc", "pps_cb", "pps2buffer", "pps___obj", "pps2buff", "ps_cb", "pps___buf", "pp_uf", "pp_obj", "pps___fg", "ps_buf", "pp_buffer", "pps_uf", "pp_buf", "pps2buf", "pps_buff"], "sps": ["splays", "osPS", "iseps", "spers", "lsfs", "SPS", "Sples", "wsPS", "dspe", "spped", "ssps", "ospe", "msps", "asPS", "isPS", "sips", "desplays", " sips", "isplays", " seps", "Spped", " spers", "msplays", "sales", "isips", " sPS", "nsps", "ssPS", "asples", "sts", "usps", "isps", "nsls", "osps", "spar", "usips", "sfs", "spe", "usPS", "lsts", " splays", "wsps", "nsPS", "sspped", "dsPS", "wspar", "desPS", "sls", "ospers", " sfs", "sspar", "asls", "usales", "Spar", "sPS", " sales", "dsps", "dspers", " sts", "lsps", "Sps", "Sls", "asps", "desps", " spe", "msPS", "mseps", "seps", "sples", "lsPS", "desips", "nsples", "wspped"], "pps": ["xp", "forces", "vs", "rpm", "pp", "fps", "pots", "fixes", "mph", "ups", "details", "oops", "makes", "pl", "hops", "ears", "ips", "caps", "alls", "times", "checks", "ports", "aps", "AMS", "dd", "acts", "stuff", "pport", "drops", "phones", "changes", "PP", "opa", "ppers", "mos", "PS", "ops", "ks", "ls", "mp", "kk", "apps", "params", "tops", "pt", "ppa", "rs", "words", "ews", "points", "ppe", "ppings", "opp", "bps", "px", "isp", "clips", "alks", "phis", "eps", "balls", "pkg", "papers", "forms", "ppo", "pres", "posts", "dds", "OPS", "stats", "ppy", "php", "fx", "facts", "parts"], "qp_bd_offset": ["qp_bin_shift", "qp_bd_shift", "qp_bdxshift", "qp_bdxoffset", "qp_bdptno", "qp_bdxoff", "qp_bdptoff", "qp_bin_off", "qp_bd_no", "qp_bd_off", "qp_bdxno", "qp_bin_no", "qp_bdptshift", "qp_bdptoffset", "qp_bin_offset"], "bits_left": [" bits_len", " bits_right", "bits_right", " bits_needed", "bits_len", "bits_needed"], "ret": ["et", "flag", "format", "print", "RET", "resp", "prop", "nt", "Return", "def", "ruby", "alt", "mem", "plain", "total", "rem", "val", "Ret", "rt", "pert", "result", "set", "ll", "ft"]}}
{"project": "qemu", "commit_id": "a52b2cbf218d52f9e357961acb271a98a2bdff71", "target": 1, "func": "static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)\n\n{\n\n    trace_qxl_spice_monitors_config(qxl->id);\n\n    if (replay) {\n\n        /*\n\n         * don't use QXL_COOKIE_TYPE_IO:\n\n         *  - we are not running yet (post_load), we will assert\n\n         *    in send_events\n\n         *  - this is not a guest io, but a reply, so async_io isn't set.\n\n         */\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->guest_monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(\n\n                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,\n\n                    0));\n\n    } else {\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n        if (qxl->max_outputs) {\n\n            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,\n\n                                                qxl->max_outputs);\n\n        }\n\n#endif\n\n        qxl->guest_monitors_config = qxl->ram->monitors_config;\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->ram->monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n\n                                          QXL_IO_MONITORS_CONFIG_ASYNC));\n\n    }\n\n}\n", "idx": 10974, "substitutes": {"qxl": ["qrexlam", "qxisl", " qexl", "aqxylam", " qexli", "qrosslp", "queryxls", "updatexl", "queuexla", "qxyL", " qxle", "qxydl", "qxyl", "quxd", "qxili", "qtryl", "quexL", "iqxli", "qxeslen", " qxli", "queryxsl", "qnzl", "qinxl", "queryuxl", "qtryli", "iqxpli", "queuexil", "qxlan", "quexlin", "quxsl", "qxflan", "qmxsl", "qpxl", "qxpl", "qixli", "queryuxls", "qaxl", "quxflan", "qxla", "queuexlen", "qxsl", "queinxlp", "quxll", "cachexxll", "quxlor", " qexle", "qxxl", "qnzle", "quxl", "aqxdl", "qtxln", "updatexile", "quuxd", " qexL", "quxli", "iqxpl", "cachexll", "quxlan", "iqxpla", "qxlen", "aqxydl", "qtxls", "quxfll", "cachexle", "qxesl", " qxL", "quexl", "qxpli", "qexls", "qxal", "qrexl", " qxlen", "cachexxls", "qxxls", "cachexxl", "qxyle", "qrxl", " qxls", "qfxly", "iqxl", "qexle", "quexly", "qtxla", "quxfli", "qfxL", "qaxlin", "qxali", "qinxlp", "queryxl", "qxpla", "qxesla", "qxyly", " qtxls", "qxli", "qxll", "qxyln", "qxfli", "qtrylan", "queryuxsl", "queuexl", "queuexila", "qxls", "qmxls", "qxyli", "qxylam", " qxylen", " qtxL", "qmxl", "qrossl", "qrxlin", "queinxl", "aqxlam", "qxila", "qxals", "qexl", "qtxli", "qxL", "qrxll", "cachexxle", "quxfl", " qtxl", "qtryll", "qtxlam", "qfxl", "qmxlen", "queuexilen", "qtxle", " qxyli", "qxlin", "aqxyln", "qxd", "qxile", "qixln", "iqxla", "qrexdl", "qxala", "qxlp", "quexlp", "aqxyli", "qxfl", "qxiL", "qrosslor", "qnzL", "qxpls", "qrxle", "updatexiL", "iqxls", "qxlor", "qtxl", "qnzli", "qrxls", "aqxln", "qxly", "queryuxlen", "qexL", "updatexL", "qxfll", "qxilen", "cachexls", " qxyl", "qinxL", "qxdl", "qixl", "quxlin", "qxxll", "qpxL", "qexdl", "aqxyl", "qxylor", "quxls", "qrxdl", "qxylp", "qxil", "qexlin", "qinxly", "quxlp", "qaxdl", "qxln", "quxlen", "qxle", "qpxls", "queinxL", "qtxL", "qfxlp", "quuxl", "queinxly", "qtxdl", "iqxpls", "quxdl", "aqxli", "aqxl", "qrossd", "qxils", "qaxls", "updatexle", "qexli", "quuxlp", "qxlam", "qxyd", "quexls", "updatexil", "qxylen", "qrxL", "qxyls", "quexdl", "qtxlen", "qtxll", "qxyla", "qxxle", "queryxlen", "cachexl", "quuxlor"], "replay": ["preplayer", "replays", "preplaying", "creplays", "replaying", " replays", " replaying", "creplaying", "creplay", "preplay", "Replaying", "rerplaying", "rerPlay", "crePlay", "recPlay", "replayer", "recplaying", "rerplay", "Replay", "rePlay", "recplayer", "prePlay", " rePlay", "rerplays", "Replayer", "recplay", "RePlay"]}}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "func": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n", "idx": 10982, "substitutes": {"n": ["on", "obj", "na", "num", "norm", "net", "nm", "nl", "gn", "network", "names", "anon", "and", "nu", "form", "ng", "p", "an", "ren", "ne", "nt", "yn", "nor", "d", "g", "name", "np", "note", "l", "local", "rn", "m", "i", "nn", "mn", "en", "dn", "ln", "hn", "j", "N", "fn", "node", "wn", "conn", "tn", "nr", "v", "conf", "cache", "cn", "c", "h", "unn", "sn", "ns", "ot", "adj", "cdn", "nb", "comm", "el", "no", "nd", "nv", "nw", "pn"], "status": ["atus", "current", "spec", "net", "code", "prefix", "network", "at", "ping", "weight", "Status", "resp", "p", "f", "error", "size", "cs", "active", "type", "i", "enabled", "test", "version", "node", "y", "t", "check", "info", "sw", "scale", "str", "w", "res", "stat", "xml", "tag", "st", "x", "result", "sc", "msg", "s", "no", "name", "state", "out"], "vdev": ["evdes", "vreg", "evdevice", "wval", " vdef", "vDEV", "vcev", "svdef", "vtech", "vctech", "vcdes", "waddr", " vdes", "vcdev", " vval", "evtech", " vaddr", "vraddr", "vcreg", " vreg", "vdevice", "wdev", "vval", "mdef", "vaddr", "svDEV", "evdev", " vtech", "vrdev", " vDEV", " vdevice", "evev", "mDEV", "vev", "vrdevice", " vev", "svdevice", "mdev", "vdef", "evreg", "vdes", "vcdevice", "vrval", "mdevice", "svdev", "wdevice"], "nc": ["nic", "nec", "sync", "pc", "nl", "gn", "cus", "ct", "enc", "ng", "ne", "nt", "yn", "bc", "dc", "xc", "nor", "ni", "cs", "tc", "np", "rn", "cb", "nn", "mn", "ic", "cc", "dn", "hn", "fn", "neck", "mc", "ctx", "conn", "nr", "gc", "c", "cn", "anc", "cmd", "sn", "ns", "NC", "nih", "cu", "disc", "phys", "nb", "cv", "nv", "nw", "pn"], "r": ["kr", "arr", "hr", "u", "lr", "q", "rb", "rs", "err", "p", "rf", "f", "d", "g", "m", "l", "attr", "i", "mr", "rr", "rate", "_", "br", "t", "rg", "rat", "rc", "rd", "nr", "repl", "pr", "c", "red", "h", "ro", "rt", "re", "sr", "w", "res", "er", "x", "result", " err", "ur", "rad", "vr", "R", "cr", "rar", "ar", "dr", "out"]}}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static void spapr_cpu_core_host_initfn(Object *obj)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);\n\n    char *name = g_strdup_printf(\"%s-\" TYPE_POWERPC_CPU, \"host\");\n\n    ObjectClass *oc = object_class_by_name(name);\n\n\n\n    g_assert(oc);\n\n    g_free((void *)name);\n\n    core->cpu_class = oc;\n\n}\n", "idx": 10984, "substitutes": {"obj": ["bj", "xy", "obs", "typ", "Obj", "go", "alloc", "resp", "o", "ex", "nt", "act", "instance", "np", "ref", "object", "obo", "attr", "kind", "txt", "js", "j", "y", "ctx", "conn", "bo", "os", "tmp", "cmd", "bh", "ot", "hw", "po", "ob", "onet", "it", "opt", "org", "ht"], "core": ["ge", "ready", "pc", "feature", "init", "go", "ve", "ec", "cp", "ox", "cycle", "process", "ome", "cer", "common", "port", "ce", "node", "Core", "ac", "conn", "rc", "one", "cast", "primary", "gc", "wp", "copy", "ro", "cop", "po", "oe", "cpu", "ore", "force", "ob", "co", "ain", "cr", "cy"], "name": ["NAME", "key", "len", "id", "nm", "me", "path", "prefix", "names", "base", "up", "named", "k", "nam", "var", "o", "ex", "label", "ref", "type", "ame", "def", "common", "word", "lat", "mem", "ma", "data", "n", "root", "cap", "t", "one", "new", "class", "sen", "c", "cn", "title", "ns", "str", "w", "Name", "no", "space", "size", "out"], "oc": ["ucc", "oco", "nic", "aco", "pc", "oci", "ct", "alloc", "toc", "ec", "o", "bc", "dc", "oid", "cs", "osc", "unc", "orp", "ic", "cc", "OC", "erc", "isc", "ocate", "ac", "rc", "yo", "gc", "c", "anc", "uc", "og", "voc", "ot", "nc", "ocr", "ob", "roc", "co", "oss", "ico"]}}
{"project": "FFmpeg", "commit_id": "892fc83e88a20f9543c6c5be3626712be7a2e6f2", "target": 0, "func": "static void init_block_mapping(Vp3DecodeContext *s) \n\n{\n\n    int i, j;\n\n    signed int hilbert_walk_y[16];\n\n    signed int hilbert_walk_c[16];\n\n    signed int hilbert_walk_mb[4];\n\n\n\n    int current_fragment = 0;\n\n    int current_width = 0;\n\n    int current_height = 0;\n\n    int right_edge = 0;\n\n    int bottom_edge = 0;\n\n    int superblock_row_inc = 0;\n\n    int *hilbert = NULL;\n\n    int mapping_index = 0;\n\n\n\n    int current_macroblock;\n\n    int c_fragment;\n\n\n\n    signed char travel_width[16] = {\n\n         1,  1,  0, -1, \n\n         0,  0,  1,  0,\n\n         1,  0,  1,  0,\n\n         0, -1,  0,  1\n\n    };\n\n\n\n    signed char travel_height[16] = {\n\n         0,  0,  1,  0,\n\n         1,  1,  0, -1,\n\n         0,  1,  0, -1,\n\n        -1,  0, -1,  0\n\n    };\n\n\n\n    signed char travel_width_mb[4] = {\n\n         1,  0,  1,  0\n\n    };\n\n\n\n    signed char travel_height_mb[4] = {\n\n         0,  1,  0, -1\n\n    };\n\n\n\n    debug_vp3(\"  vp3: initialize block mapping tables\\n\");\n\n\n\n    /* figure out hilbert pattern per these frame dimensions */\n\n    hilbert_walk_y[0]  = 1;\n\n    hilbert_walk_y[1]  = 1;\n\n    hilbert_walk_y[2]  = s->fragment_width;\n\n    hilbert_walk_y[3]  = -1;\n\n    hilbert_walk_y[4]  = s->fragment_width;\n\n    hilbert_walk_y[5]  = s->fragment_width;\n\n    hilbert_walk_y[6]  = 1;\n\n    hilbert_walk_y[7]  = -s->fragment_width;\n\n    hilbert_walk_y[8]  = 1;\n\n    hilbert_walk_y[9]  = s->fragment_width;\n\n    hilbert_walk_y[10]  = 1;\n\n    hilbert_walk_y[11] = -s->fragment_width;\n\n    hilbert_walk_y[12] = -s->fragment_width;\n\n    hilbert_walk_y[13] = -1;\n\n    hilbert_walk_y[14] = -s->fragment_width;\n\n    hilbert_walk_y[15] = 1;\n\n\n\n    hilbert_walk_c[0]  = 1;\n\n    hilbert_walk_c[1]  = 1;\n\n    hilbert_walk_c[2]  = s->fragment_width / 2;\n\n    hilbert_walk_c[3]  = -1;\n\n    hilbert_walk_c[4]  = s->fragment_width / 2;\n\n    hilbert_walk_c[5]  = s->fragment_width / 2;\n\n    hilbert_walk_c[6]  = 1;\n\n    hilbert_walk_c[7]  = -s->fragment_width / 2;\n\n    hilbert_walk_c[8]  = 1;\n\n    hilbert_walk_c[9]  = s->fragment_width / 2;\n\n    hilbert_walk_c[10]  = 1;\n\n    hilbert_walk_c[11] = -s->fragment_width / 2;\n\n    hilbert_walk_c[12] = -s->fragment_width / 2;\n\n    hilbert_walk_c[13] = -1;\n\n    hilbert_walk_c[14] = -s->fragment_width / 2;\n\n    hilbert_walk_c[15] = 1;\n\n\n\n    hilbert_walk_mb[0] = 1;\n\n    hilbert_walk_mb[1] = s->macroblock_width;\n\n    hilbert_walk_mb[2] = 1;\n\n    hilbert_walk_mb[3] = -s->macroblock_width;\n\n\n\n    /* iterate through each superblock (all planes) and map the fragments */\n\n    for (i = 0; i < s->superblock_count; i++) {\n\n        debug_init(\"    superblock %d (u starts @ %d, v starts @ %d)\\n\",\n\n            i, s->u_superblock_start, s->v_superblock_start);\n\n\n\n        /* time to re-assign the limits? */\n\n        if (i == 0) {\n\n\n\n            /* start of Y superblocks */\n\n            right_edge = s->fragment_width;\n\n            bottom_edge = s->fragment_height;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * s->fragment_width;\n\n            hilbert = hilbert_walk_y;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = -1;\n\n\n\n        } else if (i == s->u_superblock_start) {\n\n\n\n            /* start of U superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->u_fragment_start - 1;\n\n\n\n        } else if (i == s->v_superblock_start) {\n\n\n\n            /* start of V superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->v_fragment_start - 1;\n\n\n\n        }\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 4;\n\n\n\n            /* fragment is now at the start of a new superblock row */\n\n            current_fragment += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through all 16 fragments in a superblock */\n\n        for (j = 0; j < 16; j++) {\n\n            current_fragment += hilbert[j];\n\n            current_height += travel_height[j];\n\n\n\n            /* check if the fragment is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_fragments[mapping_index] = current_fragment;\n\n                debug_init(\"    mapping fragment %d to superblock %d, position %d\\n\", \n\n                    s->superblock_fragments[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_fragments[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no fragment\\n\", \n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the superblock <-> macroblock mapping; iterate through\n\n     * all of the Y plane superblocks to build this mapping */\n\n    right_edge = s->macroblock_width;\n\n    bottom_edge = s->macroblock_height;\n\n    current_width = 0;\n\n    current_height = 0;\n\n    superblock_row_inc = s->macroblock_width;\n\n    hilbert = hilbert_walk_mb;\n\n    mapping_index = 0;\n\n    current_macroblock = -1;\n\n    for (i = 0; i < s->u_superblock_start; i++) {\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 2;\n\n\n\n            /* macroblock is now at the start of a new superblock row */\n\n            current_macroblock += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through each potential macroblock in the superblock */\n\n        for (j = 0; j < 4; j++) {\n\n            current_macroblock += hilbert_walk_mb[j];\n\n            current_height += travel_height_mb[j];\n\n\n\n            /* check if the macroblock is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_macroblocks[mapping_index] = current_macroblock;\n\n                debug_init(\"    mapping macroblock %d to superblock %d, position %d\\n\",\n\n                    s->superblock_macroblocks[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_macroblocks[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no macroblock\\n\",\n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width_mb[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the macroblock <-> fragment mapping */\n\n    current_fragment = 0;\n\n    current_macroblock = 0;\n\n    mapping_index = 0;\n\n    for (i = 0; i < s->fragment_height; i += 2) {\n\n\n\n        for (j = 0; j < s->fragment_width; j += 2) {\n\n\n\n            debug_init(\"    macroblock %d contains fragments: \", current_macroblock);\n\n            s->all_fragments[current_fragment].macroblock = current_macroblock;\n\n            s->macroblock_fragments[mapping_index++] = current_fragment;\n\n            debug_init(\"%d \", current_fragment);\n\n\n\n            if (j + 1 < s->fragment_width) {\n\n                s->all_fragments[current_fragment + 1].macroblock = current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = current_fragment + 1;\n\n                debug_init(\"%d \", current_fragment + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if (i + 1 < s->fragment_height) {\n\n                s->all_fragments[current_fragment + s->fragment_width].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) {\n\n                s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width + 1;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            /* C planes */\n\n            c_fragment = s->u_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            c_fragment = s->v_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            debug_init(\"\\n\");\n\n\n\n            if (j + 2 <= s->fragment_width)\n\n                current_fragment += 2;\n\n            else \n\n                current_fragment++;\n\n            current_macroblock++;\n\n        }\n\n\n\n        current_fragment += s->fragment_width;\n\n    }\n\n}\n", "idx": 10992, "substitutes": {"s": ["ms", "sym", "sq", "spec", "qs", "source", "ats", "settings", "rs", "sg", "p", "gs", "sts", "hs", "ex", "ps", "south", "cs", "es", "sv", "ses", "scl", "bs", "aws", "less", "js", "S", "ss", "its", "n", "ts", "se", "is", "state", "v", "conf", "ops", "e", "os", "sb", "c", "sw", "h", "bis", "ns", "fs", "space", "comm", "ls", "conv", "ds", "sys"], "i": ["ai", "I", "li", "ri", "p", "f", "m", "l", "ic", "mi", "r", "is", "n", "y", "iu", "ci", "v", "b", "c", "h", "bi", "ij", "pi", "si", "x", " ii", "ii"], "j": ["je", "aj", "ja", "jump", "J", "jc", "q", "k", "p", "ii", "f", "g", "jp", "l", "m", "jj", "r", "js", "n", "jl", "v", "b", "bi", "z", "ji", "kj", "ij"], "hilbert_walk_y": ["hilbert_walk_store", "hilbert_walk10Y", "hilbert_look_y", "hilbert_walk__y", "hilbert_walk_yx", "hilbert_move_ey", "hilbert_walkableY", "hilbert_node_Y", "hilbert_step_e", "hilbert_walkablex", "hilbert_look\u0430yu", "hilbert_look\u0430store", "hilbert_walk__yy", "hilbert_look_x", "hilbert_look_yu", "hilbert_watch___y", "hilbert_loopYY", "hilbert_walk_by", "hilbert_nodeableY", "hilbert_loop_Y", "hilbert_loop_yer", "hilbert_walk10ey", "hilbert_walk_e", "hilbert_player10yo", "hilbert_watch_x", "hilbert_walk_yer", "hilbert_move_yy", "hilbert_walk\u0430store", "hilbert_player10y", "hilbert_walk0yer", "hilbert_walk__x", "hilbert_play_ys", "hilbert_step_ey", "hilbert_walk__Y", "hilbert_walk_hot", "hilbert_player10Y", "hilbert_walk_ys", "hilbert_walk\u0430y", "hilbert_look\u0430y", "hilbert_walkerx", "hilbert_step_x", "hilbert_loopYy", "hilbert_walkptstore", "hilbert_walk17x", "hilbert_nodeableyer", "hilbert_node_x", "hilbert_walk17cy", "hilbert_walk10base", "hilbert_read_Y", "hilbert_walkYyer", "hilbert_walk\u0430yu", "hilbert_play_y", "hilbert_walkererhot", "hilbert_watch_yx", "hilbert_read_base", "hilbert_watch___cy", "hilbert_walk_yd", "hilbert_walkYy", "hilbert_nodeabley", "hilbert_nodeablex", "hilbert_walk_cy", "hilbert_walk__oy", "hilbert_walk_iy", "hilbert_walkerye", "hilbert_walker_ye", "hilbert_walk_yo", "hilbert_watch___x", "hilbert_walker_hot", "hilbert_node_y", "hilbert_play_by", "hilbert_walk17y", "hilbert_walk10yo", "hilbert_step_Y", "hilbert_walkYpy", "hilbert_walkpty", "hilbert_play_Y", "hilbert_walkerhot", "hilbert_walk___y", "hilbert_walk10y", "hilbert_player_ey", "hilbert_walkptyu", "hilbert_walk__ey", "hilbert_walkableyer", "hilbert_watch_y", "hilbert_player10ey", "hilbert_player_Y", "hilbert_walkererye", "hilbert_walk0Y", "hilbert_watch_cy", "hilbert_loop_y", "hilbert_read_y", "hilbert_walkabley", "hilbert_walker_y", "hilbert_step_y", "hilbert_loopYyer", "hilbert_walk_ey", "hilbert_walk_yy", "hilbert_walk0py", "hilbert_watch___yx", "hilbert_walk17yx", "hilbert_walkererx", "hilbert_walkptx", "hilbert_walk_yu", "hilbert_look\u0430x", "hilbert_node_yer", "hilbert_walk_py", "hilbert_walk\u0430x", "hilbert_walk___x", "hilbert_walker_x", "hilbert_look_store", "hilbert_walk__e", "hilbert_loop_py", "hilbert_walk___yx", "hilbert_move_y", "hilbert_walkery", "hilbert_player_yo", "hilbert_read_x", "hilbert_walk_base", "hilbert_walk_x", "hilbert_player_y", "hilbert_walkableoy", "hilbert_walk0y", "hilbert_walkYY", "hilbert_walk_Y", "hilbert_walk___cy", "hilbert_walk10x", "hilbert_walkerery", "hilbert_walk_ye", "hilbert_walk_oy", "hilbert_move_oy", "hilbert_loopYpy"], "hilbert_walk_c": ["hilbert_step_cs", "hilbert_walk_cm", "hilbert_walk_cs", "hilbert_step_m", "hilbert_step_cm", "hilbert_walk_m", "hilbert_step_c"], "hilbert_walk_mb": ["hilbert_walk_b", "hilbert_move_b", "hilbert_walk2emb", "hilbert_move_emb", "hilbert_move_mm", "hilbert_walk_mm", "hilbert_walk2b", "hilbert_move_mb", "hilbert_walk2mb", "hilbert_walk_emb", "hilbert_walk2mm"], "hilbert": ["hillbit", "Hilber", "hailbe", "hillber", "Hilbe", "hoolbert", "hillbe", "hillbert", "hailbert", "Hailber", "hailber", "Hailbit", "hoolber", "hilbit", "hoolbe", "Hailbert", "Hilbert", "hilber", "Hilbit", "hoolbit", "hilbe", "hailbit", "Hailbe"], "current_macroblock": ["current_acroblock", "current_macroidblock", "current_macrofield", "current_macroidfield", "current_macromrow", "current_macroidrow", "current_acroidrow", "current_macrosrow", "current_macrorow", "current_macromblock", "current_acroidfield", "current_acroidblock", "current_macrosfield", "current_acrorow", "current_acrofield", "current_macromfield", "current_macrosblock"], "c_fragment": ["c_pragmented", "c_fragggment", "c_fraggments", "c_frangments", "c_frigment", "c_franggment", "c_friggment", "c_fragmented", "c_pragments", "c_fragments", "c_prigment", "c_frangment", "c_praggment", "c_frigments", "c_fraggmented", "c_frigmented", "c_priggment", "c_pragment", "c_prigmented", "c_prigments", "c_frangmented", "c_fraggment"], "travel_width": ["travel_score", "travel67score", "travel_memory", "travelalscore", "travelalwidth", "travel67width", " travel_length", " travel_score", "travelallength", "travelalmemory", " travel_memory", "travel_length", "travel67memory", "travel67length"], "travel_height": ["travel_memory", " travel_cy", "travel_cy", " travel_length", " travel_memory", "travel_length"], "travel_width_mb": ["travel_width_mm", "travel_radius_mg", "travel_width_MB", "travel_radius_mb", "travel_radius_mm", "travel_radius_MB", "travel_width_mg"], "travel_height_mb": ["travel_height_mm", "travel_height_cr", "travel_height42mb", "travel_length_cr", "travel_length_mm", "travel_height42cr", "travel_height42mm", "travel_length_mb", "travel_length_low", "travel_height42low", "travel_height_low"], "mapping_index": ["mapped_index", "mapping__num", "mapped_num", "mapped_cycle", "mapped_row", "mapping__index", "mapping_cycle", "mapping_row", "mapping__cycle", "mapping__row", "mapping_num"], "current_fragment": ["current_friggment", "current_franchgment", "current_frigment", "current_frigments", "current_pragments", "current_pragmented", "current_prangment", "current_franchments", "current_franchment", "current_praggment", "current_fraggment", "current_prangmented", "current_frigmented", "current_frangment", "current_franggment", "current_prangments", "current_frangmented", "current_frangments", "current_pragment", "current_pranggment", "current_fragmented", "current_franchmented", "current_fragments"]}}
{"project": "qemu", "commit_id": "9a78eead0c74333a394c0f7bbfc4423ac746fcd5", "target": 0, "func": "void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; m68k_cpu_defs[i].name; i++) {\n\n        (*cpu_fprintf)(f, \"%s\\n\", m68k_cpu_defs[i].name);\n\n    }\n\n}\n", "idx": 10999, "substitutes": {"f": ["tf", "fd", "fi", "fw", "fl", "a", "fo", "uf", "q", "ff", "file", "form", "p", "rf", "o", "fp", "cf", "d", "g", "m", "l", "fb", "fe", "fa", "r", "j", "fn", "t", "v", "fr", "sf", "e", "b", "c", "h", "F", "w", "fs", "fc", "fx", "s"], "cpu_fprintf": ["cpu_vprint", "cpu_vprintf", "cpu_vformat", "cpu_mformat", "cpu_fformat", "cpu_mprintf", "cpu_vmt", "cpu_fmt", "cpu_mprint", "cpu_dmt", "cpu_dprintf", "cpu_dformat", "cpu_fprint", "cpu_mmt", "cpu_dprint"], "i": [" m", "id", "ai", "I", "li", "ei", "uri", "init", " I", " di", "ri", "p", "sim", " li", "ind", "ui", "ni", "ip", "m", "my", " pi", "ki", "ti", " multi", "ic", "json", " si", "cli", " ti", "mi", "index", " Li", "j", "im", "ix", "ma", "y", "collection", "iu", "ci", "\u0438", "zi", "v", "phi", "info", "xi", "remote", "e", "multi", "qi", "c", "gi", "di", "bi", "pi", "si", "it", "x", "z", "ini", " ii", " bi", "oi", "s", "ims", " j", "asi", "ii"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,\n\n                              PCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(dev->bus);\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n        return 0;\n\n    }\n\n\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, bsel, slot);\n\n    } else {\n\n        disable_device(s, bsel, slot);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11016, "substitutes": {"s": ["sq", "obj", "spec", "sync", "qs", "rs", "hs", "p", "gs", "sts", "sp", "o", "sm", "ps", "south", "cs", "es", "sv", "ses", "sam", "bs", "session", "so", "r", "is", "js", "http", "S", "ss", "ts", "n", "t", "ssl", "v", "conf", "self", "ops", "os", "sb", "b", "c", "h", "ns", "stats", "fs", "stat", "set", "comm", "ls", "ds", "sys"], "dev": ["doc", "dd", "device", "end", "go", "cam", "ev", "det", "proc", "p", "var", "ve", "pad", "nt", "d", "def", "cand", "ver", "mem", "md", "develop", "de", "data", "ad", "phy", "dem", "DEV", "conn", "v", "wd", "der", "Dev", "cmd", "Device", "des", "hw", "w", "serv", "debug", "app", "vo", "stick", "out"], "state": ["output", "next", "ate", "status", "al", "pe", "show", "source", "policy", "or", "event", "print", "role", "range", "p", "hash", "post", "STATE", "ne", "future", "th", "scope", "powered", "l", "note", "type", "te", "size", "trace", " stated", "function", "State", "r", "is", "ss", "test", "se", "new", "check", "count", "zone", "ace", "close", "ed", "start", "tag", "st", "operator", "see", "states", "are", "name", "no", "style", "mt", "store"]}}
{"project": "FFmpeg", "commit_id": "af8aa846fa5b9f2c7dcde451c872426528b8b561", "target": 0, "func": "static void frame_start(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n\n\n    MPV_frame_start(s, s->avctx);\n\n    ff_er_frame_start(s);\n\n\n\n    assert(s->linesize && s->uvlinesize);\n\n\n\n    for(i=0; i<16; i++){\n\n        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n    for(i=0; i<4; i++){\n\n        h->block_offset[16+i]=\n\n        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+16+i]=\n\n        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n\n\n    /* can't be in alloc_tables because linesize isn't known there.\n\n     * FIXME: redo bipred weight to not require extra buffer? */\n\n    if(!s->obmc_scratchpad)\n\n        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);\n\n\n\n//    s->decode= (s->flags&CODEC_FLAG_PSNR) || !s->encoding || s->current_picture.reference /*|| h->contains_intra*/ || 1;\n\n}\n", "idx": 11026, "substitutes": {"h": ["ow", "he", "H", "hm", "ah", "ph", "hr", "current", "ch", "HH", "eh", "k", "hs", "p", "hash", "o", "th", "m", "hd", "hl", "her", "ho", "oh", "hh", "hp", "http", "v", "rh", "cache", "host", "b", "c", "sh", "sw", "bh", "kh", "hw", "w", "ih", "dh", "enh", "el", "history", "hz", "ht"], "s": ["ms", "vs", "ats", "hs", "o", "cs", "m", "ins", "session", "r", "se", "t", "sports", "wcs", "os", "has", "b", "times", "w", "comm", "ims", "conv", "sp", "gs", "sts", "bes", "ess", "changes", "g", "sv", "ses", "bs", "als", "js", "less", "ss", "sb", "des", "sc", "ls", "sq", "spec", "sl", "aunts", "qs", "a", "ssh", "css", "rs", "as", "f", "th", "es", "ts", "n", "styles", "ags", "sw", "sh", "ns", "tes", "ds", "eps", "p", "ps", "aws", "is", "j", "S", "its", "ssl", "v", "c", "stats", "fs", "st", "sys", "parts"], "i": [" m", "ie", "print", "m", " pi", " multi", " x", "im", "y", "t", "ci", "zi", " v", " mi", "gi", "eu", "iii", "eric", "pi", "oi", "hi", "ji", "ims", "asi", "ami", "status", "I", "at", "li", "uri", "init", "ri", "ex", "ind", "jp", "um", "ki", "ti", "ia", " ti", "mi", "ix", "xi", "multi", "qi", "si", " ni", "ori", "id", "ai", "ei", "vi", "err", " li", "ui", "ip", "ic", " si", "in", "\u0438", "phi", "info", "gu", " p", "it", "ini", " bi", "ii", "me", "io", "q", " I", "to", "p", "sim", " n", "this", "cli", "us", "il", "is", "j", "iu", "v", "ik", "di", "bi", "x", " ii", "set", " j", "ij"]}}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}", "idx": 11046, "substitutes": {"dev": ["hid", "obj", "tr", "off", "priv", "board", "sky", "av", "pt", "device", "end", "go", "cam", "ev", "nav", "devices", "p", "ach", "ve", "var", "od", "ind", "pad", "nt", "d", "adv", " device", "g", "th", "def", "serial", "port", "ver", "mem", "develop", "md", "cho", "de", "data", "ad", "dem", "DEV", "conn", "v", "gu", "env", "Dev", "sh", "h", "eth", "di", "des", "w", "hw", "serv", "pi", "db", "app", "sd"], "bmdma_bar": ["bmdda2car", "bmdma_car", "bmdda_car", "bmdda_var", "bmdmaptbar", "bmdma_batch", "bmdma2var", "bmdda2bar", "bmdmaptbuf", "bmdMa_car", "bmdda_buf", "bmdmaptvar", "bmdma2buf", "bmdma_buf", "bmdda2buf", "bmdma2bar", "bmdmaptcar", "bmdMa_bar", "bmdma_var", "bmdma2car", "bmdMa_batch", "bmdda2var", "bmdda_bar"], "ide_bar": ["ide_bart", "ide___bar", "ide_consumer", "ide_cart", "idi_batch", "ine__bar", "ide2or", "ine_consumer", "ine_car", "ine_default", "idemybart", "ine__cart", "ide__consumer", "ipeixbar", "ide_default", "idi_car", "ideixgood", "ine__consumer", "ide__cart", "ide__car", "idemyconsumer", "ine_group", "ide_bill", "idemycart", "ide__batch", "ide__bill", "ipeixgood", "ipe_bar", "ide2good", "ide_car", "ide__bart", "idemybar", "ideixor", "ide_good", "ide_group", "ipeixor", "ideixbar", "ide2bar", "ide_button", "ideixbutton", "idi_bar", "ipe_button", "ine__bart", "ide___bill", "ide_batch", "ide__bar", "ipe_or", "ide_or", "ine_cart", "idi_bill", "ide2button", "ipe_good", "ine_bar", "ide___car", "ipeixbutton", "ine_bart", "ide___batch"]}}
{"project": "qemu", "commit_id": "895b00f62a7e86724dc7352d67c7808d37366130", "target": 1, "func": "void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}", "idx": 11070, "substitutes": {"handle": ["obj", "hand", "id", "use", "status", "draw", "path", "wrapper", "pointer", "bind", "file", "hash", "pad", "oid", "ref", "note", "ptr", "Handle", "eno", "handled", "hold", "index", "handler", "ctx", "sha", "ha", "gc", "close", "lock", "sh", "cmd", "h", "hw", "ih", "help", "result", "get", "angle", "le", "pid", "size", "ca"], "errp": ["arrp", "errpad", " erp", "ptrpy", "errorpy", " errps", "errorpa", "arrpa", "erpa", " errpy", " errpa", "erpad", "errorps", " erpa", "errpo", " ern", "ptrpa", "erp", "ern", "errorpo", " errpad", "errorp", "arrps", "errps", "errn", "ptrp", "errpa", " erpad", "arrpo", "errpy", " errpo", " errn"], "gfh": ["gefH", " gsfha", "gevh", "gcfhr", "gvhr", " gfhd", "gcfph", "gcfh", "gbfih", "gtfih", "gefp", "gfyhd", "gvH", "gfxh", "gfhd", "gsfh", "gdfh", "gdfhd", "gtfh", "getfih", "getfh", "gfp", "gsfhd", "gfph", "gfyha", "gsfih", "gefhr", "gdfha", "gtfp", " gsfhd", "gefih", "gcfH", "gfxH", " gfha", "gbfp", "gvph", "gefoh", "gsfha", "gfxph", "gfH", "gevhr", "gevph", "getfp", "gfxhr", "gbfoh", " gsfh", "gefh", "gfhr", "gsfoh", "getfoh", "gtfoh", "gbfh", "gfoh", "gfyh", "gfih", "gsfp", "gevH", "gvh", "gfha", "gefph"], "fh": ["hhandle", "Fh", " fc", "Fht", "fch", " fch", "cfhandle", "ffh", "ffoh", "ffht", "Fc", "lfsh", "fish", "cfch", " fsh", " fht", "cfph", "ffhandle", "ffsh", "cfh", "fiph", "fih", "hh", "ffc", " foh", "hch", " fhandle", "fsh", "Fhandle", "hph", "ffbh", " fph", "Foh", "fht", "foh", "fph", "hsh", "Fbh", "fc", " fbh", "fth", "lfph", "hth", "lfth", "fhandle", "fith", "lfh", "Fsh", "fbh"], "ret": ["ert", "fin", "len", "lt", "tr", "reset", "status", "back", "flag", "err", "print", "det", "nz", "RET", "resp", "nt", "del", "fun", "mt", " Ret", "inter", "def", " alt", "alt", "ter", "cont", "done", "t", "rem", "rets", "deg", "not", "val", "Ret", "rt", "re", "elt", "res", "rm", "result", "att", "gt", "ll"]}}
{"project": "FFmpeg", "commit_id": "c9aab8a123c0bcf6adeab390db1ec783326456ca", "target": 0, "func": "static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture * const ref1 = &h->ref_list[1][0];\n\n    int j, old_ref, rfield;\n\n    int start= mbafi ? 16                      : 0;\n\n    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];\n\n    int interl= mbafi || s->picture_structure != PICT_FRAME;\n\n\n\n    /* bogus; fills in for missing frames */\n\n    memset(map[list], 0, sizeof(map[list]));\n\n\n\n    for(rfield=0; rfield<2; rfield++){\n\n        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){\n\n            int poc = ref1->ref_poc[colfield][list][old_ref];\n\n\n\n            if     (!interl)\n\n                poc |= 3;\n\n            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed\n\n                poc= (poc&~3) + rfield + 1;\n\n\n\n            for(j=start; j<end; j++){\n\n                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {\n\n                    int cur_ref= mbafi ? (j-16)^field : j;\n\n                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;\n\n                    if(rfield == field || !interl)\n\n                        map[list][old_ref] = cur_ref;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11080, "substitutes": {"h": ["he", "H", "hm", "ah", "each", "q", "eh", "k", "hs", "p", "hash", "f", "g", "m", "l", "hd", "hl", "i", "her", "oh", "hh", "handle", "hp", "http", "y", "t", "v", "rh", "e", "host", "b", "c", "sh", "kh", "bh", "hw", "w", "ih", "help", "his", "it", "x", "comm", "history", "hz", "ht"], "map": ["clear", "Map", "use", "cmp", "collect", "config", "code", "add", "match", "print", "pan", "file", "form", "sp", "hash", "cp", "pad", "ip", "block", "m", "process", "ap", "bm", "save", "window", "en", "mask", "filter", "mem", "view", "cap", "scan", "conf", "cast", "mk", "cache", "shape", "tap", "copy", "scale", "master", "load", "make", "table", "rm", "link", "result", "set", "maps", "pack", "app", "dict", "max", "MAP", "share", "mp", "ape", "bridge"], "list": ["len", "lt", "array", "id", "spec", "status", "source", "code", "path", "li", "base", "range", "flat", "form", "p", "point", "pair", "nt", "label", "block", "ref", "l", "def", "m", "note", "type", "null", "parent", "word", "lists", "LIST", "stack", "json", "i", "all", "filter", "index", "details", "chain", "List", "cont", "ist", "level", "test", "html", "dl", "new", "count", "v", "tree", "not", "detail", "str", "st", "ul", "table", "single", "link", "batch", "set", "listed", "result", "dict", "name", "pre", "out"], "field": ["col", "key", "shift", "len", "depth", "id", "bf", "flag", "format", "end", "ff", "file", "p", "value", "number", "f", "pad", "error", "ield", "size", "label", "type", "attr", "zero", "fe", "word", "term", "function", "index", "Field", "row", "FIELD", "fix", "t", "fields", "v", "count", "good", "comment", "present", "rule", "start", "tag", "fc", "x", "table", "name", "offset", "length", "xf"], "colfield": ["COLdisplay", "colvariable", "propdisplay", "COLvariable", "attrpixel", "propfield", "rolcomponent", "colradio", "Colfield", "COLradio", "charkey", "colvalue", "prophandler", "charFIELD", " colkey", "Colkey", "reffield", "colkey", "coldisplay", "refdisplay", " colFIELD", "refvariable", " colvalue", "colhandler", "Colvalue", "COLpixel", "colFIELD", "rolradio", "COLfield", "COLcomponent", "charvalue", "attrradio", "rolfield", "charfield", "propvariable", "attrcomponent", "rolpixel", "COLhandler", "colpixel", "colcomponent", "refhandler", "attrfield", "ColFIELD"], "mbafi": ["mmafa", "mbafa", "mmfi", "bbifa", "kbatha", "ambiera", "mtafi", "kbafa", "mbiera", "nobafi", "gbafi", "kbafi", "bbiana", "bbafa", "bbafi", "nobafa", "mtiana", "bbfi", "MBfi", "gbafa", "MBafi", "nobifi", "mpafi", "MBifi", "mmelia", "MBiana", "mtifi", "mtafa", "mtatha", "mbfi", "nobifa", "ambelia", "mbatha", "gbatha", "mmiana", "ambafa", "mmafi", "mmias", "mbifi", "mtias", "mpafa", "mbias", "kbifi", "mbifa", "mpiana", "mpelia", "ambafi", "mmiera", "mbiana", "mbelia", "bbifi", "gbifi", "mpias", "mpifi", "mpiera", "mmifi", "kbifa"], "s": ["ms", "sl", "a", "ats", "settings", "rs", "css", "hs", "p", "gs", "sts", "sp", "ps", "g", "cs", "m", "sv", "i", "session", "is", "js", "S", "ss", "ts", "n", "t", "styles", "v", "wcs", "os", "sb", "c", "sh", "sw", "spe", "ns", "stats", "w", "fs", "sections", "sn", "serv", "set", "ls", "ims", "ds", "sys"], "ref1": ["refs", "map0", "referenceOne", "Ref2", "rel2", " refs", "map1", "reference0", "Ref1", "rel1", "refOne", "ref0", "references", "reference1", "ref2", "Refs", "reference2", " refOne", "map2", "mapOne", " ref2", "relOne", " ref0", "rel0", "Ref0"], "j": ["jac", "key", "je", "obj", "bj", "tr", "aj", "ja", "jump", "J", "jc", "pt", "jo", "q", "req", "k", "p", "ng", "o", "job", "f", "jit", "ind", "kid", "d", "g", "jp", "pos", "note", "l", "m", "i", "json", "jj", "index", "r", "js", "uj", "br", "ix", "n", "y", "t", "jl", "v", "bo", "fr", "b", "ijk", "start", "oj", "adj", "er", "it", "x", "z", "dj", "ji", "kj", "ij"], "old_ref": [" old_int", "oldenref", " old_err", "old_col", "older_err", "old_err", "old_num", "oldencol", "oldenseq", "oldxint", "curenseq", "older_Ref", "curenref", "old__int", "old_reference", "older_range", "cur_pos", "oldxnum", " old_Ref", "older_loc", "old_cond", "older_cond", "old__num", "old_range", "old__ref", "old__rel", "older_pos", "cur_ref", "cur_col", "curencol", " old_rel", "old_pos", "older_ref", "oldxref", "old_seq", "cur_seq", "old_rel", " old_loc", " old_reference", "oldenpos", "oldxrel", "old_loc", "old_Ref", "curenpos", "old_int", " old_num"], "rfield": ["srsim", "rarkey", "rarforce", " rchild", "Rfield", "srfield", "Rfunction", " rdistance", "rarchild", "rarrule", "Rdistance", "rforce", "rField", "srfunction", "rchild", "rlabel", "rvalue", " rlen", "rdistance", "archild", "Rforce", "srversion", "Rtag", "artag", "rlen", "rfunction", "rbField", "srrule", "rarversion", "srField", " rfunction", "rarfield", "rkey", "RField", "rbsim", "Rlen", "Rversion", "Rsim", "rbfunction", "rarbyte", "srforce", "rarvalue", "Rbyte", "Rrule", "arkey", "Rvalue", "srlen", "rrule", " rtag", "rtvalue", "rtfield", "srdistance", "Rlabel", "rsim", "rtField", " rvalue", "rarfunction", "rtag", "rbfield", " rbyte", "arfield", "rversion", " rlabel", "rarField", "rtlabel", "rartag", "rbyte", " rkey", " rField"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_frame_duration(int *pnum, int *pden,\n\n                                   AVFormatContext *s, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        *pnum = st->codec.frame_rate_base;\n\n        *pden = st->codec.frame_rate;\n\n        if (pc && pc->repeat_pict) {\n\n            *pden *= 2;\n\n            *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 11084, "substitutes": {"pnum": ["pannum", "PNumb", "panue", "panenum", "gnum", "penumb", "bnUM", "pnhum", "PNum", "gnUM", "PNnum", "penom", "penum", "cnue", "gnom", "pnUM", "panums", "penUM", "wnump", "pinums", "penam", "panumer", "pnumber", "gnue", "snumb", "snum", "cnom", "pinum", "pnump", "penump", "pnom", "penumber", "penumer", "pnue", "wnum", "bnum", "pinumb", "penums", "pinnum", "panhum", "pnenum", "bnumb", "panom", "pinump", "pnumer", "pnnum", "panumb", "gnam", "gnumb", "panumber", "cnum", "pinhum", "snumber", "gnums", "wnumb", "pnums", "pnam", "bnam", "snenum", "pnumb", "PNhum", "gnumer", "wnums", "panum", "cnums", "penenum"], "pden": [" pdon", "Pdn", "mlen", "qdal", "Pdal", "pdon", " parden", "parden", "jden", "pDen", "qDen", "qdon", " pDen", "mdn", "Pdes", "pararden", "jlen", "Pdon", " pdal", "jdn", "npDen", " plen", "PDen", "npden", " pdes", "pdal", "mdon", "qden", "nden", "marden", "jarden", "ndon", "pdes", "plen", "ndn", "npdes", "parDen", "pardn", "pdn", "Pden", "mden", " pdn", "Parden"], "s": ["spec", "sl", "sp", "gs", "p", "ps", "d", "g", "cs", "m", "sv", "sam", "ss", "ts", "se", "t", "v", "e", "sb", "sw", "c", "h", "sa", "w", "fs", "sc", "ds"], "st": ["td", "src", "tt", "art", "obj", "sl", "status", "et", "std", "pt", "St", "ct", "step", "sp", "cl", "sts", "standard", "nt", "ut", "ld", "th", "stable", "stop", "l", "mt", "sv", "ust", "ste", "so", "usr", "storage", "stage", "ist", "ts", "ss", "pb", "se", "t", "ctx", "fr", "stru", "ast", "sty", "sw", "ST", "irst", "ost", "rt", "est", "rest", "sta", "str", "sc", "nd", "inst", "spect"], "pc": ["amps", "pic", "pas", "pe", "cmp", "tp", "pat", "pp", "pt", "tk", "ct", "proc", "p", "amp", "cp", "ps", "mic", "bc", "dc", "vp", "pd", "cs", "tc", "jp", "psc", "ic", "cc", "lp", "pm", "icc", "pb", "mc", "pac", "ctx", "PC", "lc", "pr", "rh", "c", "wp", "anc", "nc", "pi", "cu", "sc", "fc", "mp", "vc", "pn", "pa"], "pkt": [" packet", "prekg", "pdu", "prokg", "pingcgi", " pkg", "proacket", "pswk", " pdu", " pcgi", "pkg", "produ", "prekt", "pingkt", "preacket", "prokt", "packet", "pwk", "pingwk", "pcgi", " pwk", "pskt", "pscgi", "pingdu", "predu", "psdu"], "frame_size": ["framelysize", "movielexnum", "movie_style", "frameedsize", "frame_loss", "frameablesource", "movie_num", "frameedloss", "frame_duration", "framevalsize", "movielexstyle", "framelyduration", "data_loss", "dataedfee", "dataedcache", "face_name", "frameLstyle", "movielexsize", "face_space", "frameLlocation", "faceablesize", "frame_style", "frame64name", "framelexnum", "frameedfee", "frameLnum", " frame_duration", "frameablesize", "frameedcache", "frame_source", "frame67size", "frame67num", "frameablespace", "frame_cache", "framelystorage", "frameLsize", "movie_location", "frame_location", "frame64source", "frame64space", "data_fee", "faceablesource", "dataedsize", "framevalduration", "framevalstorage", "frame_num", "movie_size", " frame_storage", "frameablename", "framelexstyle", "framelexsize", "face_source", "frame_name", "data_cache", "frame_fee", "faceablespace", "frame67style", "face_size", "frame_storage", "frame67location", "frame_space", "framelexlocation", "data_size", "faceablename", "dataedloss", "frame64size", "movielexlocation"]}}
{"project": "qemu", "commit_id": "ecbddbb106114f90008024b4e6c3ba1c38d7ca0e", "target": 1, "func": "static int os_host_main_loop_wait(int64_t timeout)\n{\n    GMainContext *context = g_main_context_default();\n    GPollFD poll_fds[1024 * 2]; /* this is probably overkill */\n    int select_ret = 0;\n    int g_poll_ret, ret, i, n_poll_fds;\n    PollingEntry *pe;\n    WaitObjects *w = &wait_objects;\n    gint poll_timeout;\n    int64_t poll_timeout_ns;\n    static struct timeval tv0;\n    fd_set rfds, wfds, xfds;\n    int nfds;\n    /* XXX: need to suppress polling by better using win32 events */\n    ret = 0;\n    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {\n        ret |= pe->func(pe->opaque);\n    }\n    if (ret != 0) {\n        return ret;\n    }\n    FD_ZERO(&rfds);\n    FD_ZERO(&wfds);\n    FD_ZERO(&xfds);\n    nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds);\n    if (nfds >= 0) {\n        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);\n        if (select_ret != 0) {\n            timeout = 0;\n        }\n        if (select_ret > 0) {\n            pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds);\n        }\n    }\n    g_main_context_prepare(context, &max_priority);\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n    for (i = 0; i < w->num; i++) {\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n    }\n    if (poll_timeout < 0) {\n        poll_timeout_ns = -1;\n    } else {\n        poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS;\n    }\n    poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);\n    qemu_mutex_unlock_iothread();\n    g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);\n    qemu_mutex_lock_iothread();\n    if (g_poll_ret > 0) {\n        for (i = 0; i < w->num; i++) {\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n        }\n        for (i = 0; i < w->num; i++) {\n            if (w->revents[i] && w->func[i]) {\n                w->func[i](w->opaque[i]);\n            }\n        }\n    }\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n        g_main_context_dispatch(context);\n    }\n    return select_ret || g_poll_ret;\n}", "idx": 11113, "substitutes": {"timeout": ["tt", "frequency", "status", "buffer", "io", "policy", "resolution", "Timeout", "event", "poll", "error", "slot", "service", "tc", "window", "wait", "uration", "server", "dt", "r", "script", "ts", "t", "state", "v", "period", "option", "options", "opt", "seconds", "watch", "time", "duration", "response", "timer", "size", "tv", "out", "params"], "context": ["command", "current", "address", "language", "config", "resource", "network", "buffer", "wrapper", "message", "document", "event", "contact", "Context", "instance", "location", "condition", "awareness", "request", "parent", "window", "reference", "background", "index", "ce", "package", "translation", "connection", "ctx", "environment", "cache", "host", "c", "setup", "subject", "information", "sc", "memory", "foundation", "private", "center", "history"], "poll_fds": ["poll2fcs", "poll_cld", "poll_rfds", "poll_fmds", "poll2fds", "poll_xfixtures", "poll_fifld", "poll1xfds", "poll_fns", "poll_frs", "poll_fullbs", "poll1fds", "poll1xfixtures", "poll2cars", "poll_ffrs", "poll_fortcs", "poll_fdbs", "poll_rfuds", "poll_fdods", "poll_fixtures", "poll____fortds", "poll_fmaders", "poll2fns", "poll_fdds", "poll_fullds", "poll_faders", "poll_fdixtures", "poll_fortds", "poll_rfos", "poll_cars", "poll_fmaults", "poll_caults", "poll_fifos", "poll_fods", "poll_fortaders", "poll1fbs", "poll_ffds", "poll_xfaults", "poll_fld", "poll2fods", "poll_crs", "poll_caders", "poll_fullaults", "poll____fds", "poll_xfds", "poll1xfbs", "poll____fortcs", "poll_fifrs", "poll_nds", "poll_fdaults", "poll_rfrs", "poll_xfbs", "poll____faders", "poll1faults", "poll_fifuds", "poll_fifcs", "poll_fos", "poll_fars", "poll2fars", "poll_fuds", "poll2frs", "poll1fixtures", "poll_fortaults", "poll_ccs", "poll____fcs", "poll____faults", "poll_fullixtures", "poll1xfaults", "poll2ccs", "poll____fortaults", "poll_fbs", "poll_fifds", "poll_ffcs", "poll_nns", "poll_fmcs", "poll_ncs", "poll_cds", "poll2cds", "poll_nods", "poll2crs", "poll_ffars", "poll_faults", "poll____fortaders", "poll_fdns", "poll_fcs", "poll_fdcs"], "g_poll_ret": ["g_oll_return", "g_poll_val", "g_poll2val", "g_poll_Ret", "g_oll_ret", "g_poll2return", "g_poll2ret", "g_oll_Ret", "g_poll2Ret", "g_oll_val", "g_pollsRet", "g_poll_return", "g_pollsval", "g_pollsreturn", "g_pollsret"], "ret": ["len", "tr", "select", "lt", "reset", "fd", "fi", "success", "got", "status", "lit", "back", "flag", "err", "RET", "over", "nt", "ref", "mt", " Ret", "inter", "pret", "def", "txt", "alt", "mem", "ter", "r", "try", "ext", "j", "last", "t", "new", "rem", "tn", "rets", "reg", "deg", "repl", "not", "gc", "val", "Ret", "rt", "re", "elt", "res", "opt", "vet", "rm", "result", "gt", "dt", "ft", "out"], "i": ["ami", "id", "ai", "fi", "I", "me", "io", "li", "ei", "init", "p", "o", "point", "sim", "ind", "ui", "ip", "m", "l", "inter", "ki", "ti", "ic", "cli", "us", "index", "mi", "chain", "j", "ir", "ix", "im", "n", "y", "iu", "ci", "\u0438", "phi", "zi", "info", "xi", "gu", "e", "multi", "qi", "gi", "bi", "di", "ij", "si", "pi", "it", "x", "batch", "ini", "oi", "hi", "ji", "ims", "ii"], "n_poll_fds": ["n_poll_vcs", "n_poll_drs", "n_poll_fbs", "n_poll_dds", "n_poll_fmys", "n_poll_vrs", "n_poll_fys", "n_poll_fcrs", "n_poll_fdcs", "n_poll_fgs", "n_poll_funcs", "n_poll_fns", "n_poll_dgs", "n_poll_ftds", "n_poll_crs", "n_poll_dbs", "n_poll_vns", "n_poll_fdds", "n_poll_cros", "n_poll_fros", "n_poll_vds", "n_poll_fmists", "n_poll_fists", "n_poll_cgs", "n_poll_fends", "n_poll_cds", "n_poll_cbs", "n_poll_fdns", "n_poll_fenys", "n_poll_frs", "n_poll_flers", "n_poll_funrs", "n_poll_fmlers", "n_poll2frs", "n_poll_fdrs", "n_poll_funds", "n_poll2fgs", "n_poll_cns", "n_poll_ftlers", "n_poll2fbs", "n_poll_ftists", "n_poll_funros", "n_poll_fenists", "n_poll_fcs", "n_poll2fds", "n_poll_cuds", "n_poll_fccs", "n_poll_fcds", "n_poll_ccs", "n_poll_fuds", "n_poll_fcuds", "n_poll_ftys", "n_poll_fenlers", "n_poll_fmds"], "pe": ["je", "py", "he", "ice", "tp", "pp", "pse", "aste", "nce", "per", "p", "ve", "peg", "cp", "ps", "pes", "ase", "PE", "pd", "ae", "te", "ep", "fe", "pri", "parse", "le", "ste", "peak", "ppe", "ce", "ope", "pex", "se", "pb", "ele", "pei", "que", "pl", "e", "este", "ke", "ple", "spe", "oe", "pet", "pee", "peer", "see", "ze", "ale", "lex", "xe", "Pe", "ped", "ape", "ue", "pa"], "w": ["wall", "fw", "iw", "wal", "q", "wi", "p", "we", "W", "rw", "wr", "g", "wx", "word", "wh", "window", "writer", "wait", "wa", "ew", "wl", "saw", "y", "v", "aw", "wcs", "wp", "wt", "sw", "wat", "wine", "hw", "kw", "tw", "work", "nw", "wb"], "poll_timeout": ["poll_policy", "poll_sleep", "poll67delay", " poll_period", "query_time", "query67delay", "poll67timeout", "search_size", "query_delay", "poll32delay", "poll2delay", "poll67sleep", "search_policy", "poll32timeout", "poll2sleep", "query67sleep", "poll2time", "query67timeout", "query_timeout", "poll2timeout", "search_Timeout", "poll_delay", "poll67time", " poll_timer", " poll_delay", "poll_period", "query67time", "query_sleep", "poll32period", "poll32timer", "poll_time", "poll_timer", "search_timeout", "poll_size", "poll_Timeout"], "poll_timeout_ns": ["poll_timeout_ins", "poll_timeout_mins", "poll_delay_ins", "poll_out_ns", "poll_out_ms", "poll_out_mins", "poll_delay_ms", "poll_timeout_NS", "poll_timeout_ms", "poll_timeout_ds", "poll_delay_ns", "poll_delay_ds", "poll_out_NS"], "tv0": ["tfno", "tt0", " tv1", "tf0", "ttno", "tvno", "sec0", "tvds", "sec6", "tt2", "tt1", "tt6", "tv6", "TV6", " tvval", "tv2", "tf1", "TV2", "tvval", "tfval", " tvno", "tv1", "TV0", "secds", "ttds", "TVds", "sec2", "ttval"], "rfds": ["sfcs", "xfns", "rafxs", "rafdes", "rfs", "rafls", "xfs", "xfcs", "fws", "fwients", "rafers", "rafjs", "rfargs", "rafvals", "rfcs", "xfxs", "fgers", "sfds", "fgs", "fwxs", "rafargs", "fwls", "rnvals", "fwers", "fwrs", "fgds", "rncs", "rnds", "rfxs", "fgls", "rfers", "rafcs", "rafrs", "rfjs", "rfients", "rafns", "xfdes", "fwjs", "rfrs", "xfrs", "rfns", "fgargs", "fwvals", "rafds", "rfls", "rfvals", "fgients", "fwds", "fwcs", "fwargs", "rnjs", "rafs", "fgcs", "rfdes", "sfdes", "rafients", "sfns"], "wfds": ["wvds", "wxfrs", "rwfords", "wufdays", "wsfrs", "wfsrs", "rwfds", "wrfd", "wdfds", "wufrs", "wfdays", "rwfd", "wsfcs", "wxfDS", "ewfds", "rwvds", "wxfcs", "ewfDS", "ewfws", "wfsDS", "rwvords", "rwxfds", " Wfdays", "wvords", "wrfuds", "wfsws", "ewfrs", "wfuds", " Wufks", "wxfuds", "wwds", "ewfdays", "wwks", "wxfws", "wxfds", "wrfds", "wxfdays", "ewxfdays", "wcfrs", "wcfds", "wfDS", "wvd", "wwws", "wsfd", "ewxfDS", "wfd", "rwxfrs", "wxfd", "wfsds", "wfks", " Wfds", "wvDS", " Wufrs", "rwfcs", "rwxfcs", "wdfdays", "wcfcs", "wxfords", "wfords", "rwxfd", "wrfDS", " Wufdays", "wfcs", "wdfDS", "rwfrs", "rwfDS", "ewxfds", "wufds", "wrfords", " Wufds", "wufks", " Wfks", "rwvDS", "wsfds", "wfrs", "rwvd", "wdfuds", "wfws", "ewfuds", " Wfrs", "ewxfuds", "wxfks", "ewxfws", "wwdays", "ewxfrs", "wwDS", "wcfd", "wrfdays", "wwrs"], "xfds": ["sfargs", "ffieldDS", "sfcs", "xfns", "cfDS", "fwns", "xfants", "xfcs", "fifds", "fxDS", "sfps", "cfns", "fifeds", "fwDS", "xfda", "fifands", "fxps", "sfds", "rfeds", "rfps", "fwrs", "fwda", "xfargs", "xfeds", "fxdds", "fifdds", "xfdds", "cfands", "fifda", "fifns", "cfrs", "fifcs", "fifps", "fwants", "xfps", "fwands", "fifargs", "fxrs", "fxants", "fxns", "xfrs", "cfds", "xfands", "ffieldants", "rfdds", "xfDS", "fwps", "fwds", "fxds", "fwdds", "cfda", "fwcs", "fwargs", "ffielddds", "ffieldds", "fxeds"], "nfds": [" nfids", "nfdns", " nxfcs", "nfdids", " nxfd", "nffods", "ncfrs", "nxfcs", "nfoods", "ncfd", "nrfds", "nfays", "nbfcs", "nfd", "nfwats", "nrfrs", "nxfds", " nfd", " nfcs", "ncfcs", "ndrs", "nfdods", " nfats", "nfids", "ndns", " nfrs", "nrfd", "nxfrs", " nfdds", "nxfd", "nxfns", "ndods", " ncfds", " nfays", "nbfdds", "nfods", "nfoays", "nfwdds", "nffds", " ncfods", "ncfays", "nfats", " nfods", "nxfods", "ncfods", "nfdcs", " nxfrs", " nxfods", " ncfcs", "nfns", " nxfns", "nfrs", "nfcs", " nxfds", "ncfds", "nxfdds", "nfwds", " nfns", " ncfays", "ncfdds", "nffcs", "nffays", " nxfids", "ndds", "nbfats", "nfdds", " nxfdds", "nxfids", "nrfdds", "nfwcs", "nfdrs", "nfocs", "nfwrs", "nbfds", "nfwids"]}}
{"project": "qemu", "commit_id": "a89d89d3e65800fa4a8e00de7af0ea8272bef779", "target": 1, "func": "int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (drv->bdrv_snapshot_delete) {\n\n        return drv->bdrv_snapshot_delete(bs, snapshot_id);\n\n    }\n\n    if (bs->file) {\n\n        return bdrv_snapshot_delete(bs->file, snapshot_id);\n\n    }\n\n    return -ENOTSUP;\n\n}\n", "idx": 11117, "substitutes": {"bs": ["ms", "obs", "vs", "bf", "qs", "cks", "aos", "bp", "rs", "bas", "hs", "gs", "bes", "sts", "bles", "ps", "bc", "BS", "cs", "bm", "bits", "bn", "bytes", "bsp", "bing", "uts", "aus", "irms", "js", "its", "ss", "ts", "pb", "bos", "lbs", "bps", "ubs", "ubis", "sb", "bis", "ns", "sbm", "fs", "bd", "ks", "blog", "ls", "hz", "ds"], "snapshot_id": ["snapcut_code", "snapshot_name", "snapshot_ident", "snapshot_d", "snapcut_string", "snapshotWid", "snapshot_string", "snapreenshot_ident", "snapshotuuname", "snapshotWstring", "snapshotOcode", "snapreenshot_name", "snapcut_id", "snapreenshot_ID", "snapshotOd", "snapshotOstring", "snapshot_ID", "snapshotWd", "snapreenshot_Id", "snapshot_code", "snapshotOid", "snapshotuuId", "snapshotWcode", "snapshotuuid", "snapcut_d", "snapshot_Id", "snapreenshot_id", "snapshotuuident"], "drv": [" drvr", "drf", "rdr", " drvs", " drf", "rdv", "parvd", " drh", "Drvr", "vrvr", "ldh", " drr", "DRvs", "parr", "drva", "Drw", "Drv", "drw", "hrvr", "drvs", "drm", "srm", "drvr", "srv", "rdm", " drm", " drw", "Drf", "vrh", "rdvd", "drvd", "drh", "vrw", "Drva", "drch", " drch", "ldv", "hrva", "vrf", "parf", "vrv", "hrf", "DRh", "Drh", "ldvs", "rdch", "drr", "hrv", "parv", "ldvr", "srch", "DRvr", "rdf", "vrva", "srvd", "DRv", " drvd"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint32_t val;\n\n\n\n    val = bswap32(cpu_inl(addr & IOPORTS_MASK));\n\n    return val;\n\n}\n", "idx": 11126, "substitutes": {"opaque": ["opcode", "iopac", "iopus", "ospac", "ospus", " opac", " opcode", "ospaque", "iopaque", " opus", "opac", "ospcode", "iopcode", "opus"], "addr": ["align", "arr", "tx", "address", "url", "arp", "at", "add", "Address", "prefix", "rs", "err", "alloc", "to", "p", "ident", " address", "pad", "slot", "act", "hop", "rol", "pos", "ref", "attr", "zero", "ptr", "adr", "ord", "mem", "r", "ix", "n", "ad", "ace", "host", "cmd", "offset", "alias", "x", "coord", "dh", "loc", "work", "dr", "mt"], "val": [" eval", " VAL", " bl", "lit", " Val", "al", "sl", "fi", "fl", " arg", "pt", " value", "valid", "VAL", "value", " al", "p", "resp", "bl", "buf", "slot", "ival", "abl", "vec", "l", "Val", " el", "vt", "util", "all", "mem", "eval", "als", "il", "data", "t", "v", " v", "pl", "pal", "pol", "bal", "sel", "elt", " ret", "serv", "ul", "vals", "it", "x", "z", " vec", "aval", "out", "ret"]}}
{"project": "qemu", "commit_id": "5dafc53f1fb091d242f2179ffcb43bb28af36d1e", "target": 0, "func": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n\n\n    if (f->is_writable)\n\n        return;\n\n    if (f->is_file) {\n\n        fseek(f->outfile, f->buf_offset, SEEK_SET);\n\n        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);\n\n        if (len < 0)\n\n            len = 0;\n\n    } else {\n\n        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,\n\n                         f->buf, IO_BUF_SIZE);\n\n        if (len < 0)\n\n            len = 0;\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = len;\n\n    f->buf_offset += len;\n\n}\n", "idx": 11127, "substitutes": {"f": ["fab", "tf", "fal", "ef", "alf", "fd", "fw", "fi", "bf", "fl", "fo", "flag", "uf", "q", "ct", "ff", "file", "form", "p", "rf", "proc", "df", "fp", "cf", "fm", "d", "iter", "g", "l", "m", "fb", "ret", "i", "fe", "lf", "all", "ext", "r", "j", "y", "t", "of", "ac", "v", "info", "fr", "sf", "good", "conf", "e", "b", "inf", "c", "fac", "h", "exec", "F", "w", "fs", "fee", "etc", "fc", "it", "x", "full", "z", "s", "el", "ft", "af"], "len": ["add", " al", "hl", "ln", " fmt", "html", "t", "deg", " dist", "elt", "el", "ll", "conv", " ell", "fin", "lim", "cmp", "fl", "sp", "wid", "gl", "limit", "lon", "lf", " el", "en", " fn", "rel", " rot", "repl", "count", "comp", "ls", " ll", "syn", " msg", "nl", "lan", "mat", "err", "valid", "compl", "resp", "ld", "nt", "vec", "l", "pos", "n", "dl", "mil", " vec", "ann", "ret", "lit", "lt", "lib", "Len", "list", " ans", "seq", "label", "del", "pkg", "fun", "lp", " repl", "bytes", "alt", "all", " lib", "cod", "cont", "coll", "tl", "rot", "val", "full", "msg", "length"]}}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void net_hub_check_clients(void)\n\n{\n\n    NetHub *hub;\n\n    NetHubPort *port;\n\n    NetClientState *peer;\n\n\n\n    QLIST_FOREACH(hub, &hubs, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QLIST_FOREACH(port, &hub->ports, next) {\n\n            peer = port->nc.peer;\n\n            if (!peer) {\n\n                fprintf(stderr, \"Warning: hub port %s has no peer\\n\",\n\n                        port->nc.name);\n\n                continue;\n\n            }\n\n\n\n            switch (peer->info->type) {\n\n            case NET_CLIENT_DRIVER_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_DRIVER_USER:\n\n            case NET_CLIENT_DRIVER_TAP:\n\n            case NET_CLIENT_DRIVER_SOCKET:\n\n            case NET_CLIENT_DRIVER_VDE:\n\n            case NET_CLIENT_DRIVER_VHOST_USER:\n\n                has_host_dev = 1;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic) {\n\n            warn_report(\"vlan %d with no nics\", hub->id);\n\n        }\n\n        if (has_nic && !has_host_dev) {\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    hub->id);\n\n        }\n\n    }\n\n}\n", "idx": 11128, "substitutes": {"hub": ["bro", "uber", "ube", "lib", "board", "ub", "wrapper", "hook", "build", "web", "home", "hyper", "sub", "pool", "job", "igh", "hop", "rub", "client", "hd", "bs", "util", "pub", "Hub", "loop", "server", "handle", "hold", "http", "row", "box", "pb", "connection", "bus", "hover", " hubs", "ubs", "bang", "conn", "feed", "host", "project", "b", "h", "bh", "plug", "hole", "hw", "band", "bug", "org", "driver", "gb", "ib", "hi", "proxy", "wire", "grid", "hog", "hy", "bridge"], "port": ["eport", "Port", "ports", "page", "net", "pc", "socket", "message", "pt", "channel", "device", "ping", "range", "p", "point", "pool", "ve", "cp", "service", "client", "pod", "ver", "ort", "server", "PORT", "http", "version", "test", "connection", "interface", "phy", "plugin", "pr", "player", "host", "fat", "target", "porter", "serv", "group", "proxy", "vr", "bridge", "state"], "peer": ["next", "pc", "pe", "tp", "socket", "part", "wrapper", "message", "channel", "device", "ping", "offer", "manager", "bean", "older", "p", "point", "pool", "sp", "worker", "ne", "caster", "component", "instance", "consumer", "scope", "type", "client", "cer", "local", "parent", "ver", "ger", "holder", "server", "ter", "package", "that", "rel", "outer", "owner", "actor", "node", "connection", "ker", "handler", "entity", "metadata", "remote", "player", "host", "primary", "reader", "target", "member", "er", "context", "group", "user", "vr", "soc", "pro", "state", "pod"]}}
{"project": "FFmpeg", "commit_id": "c4e554701ec27b31b1b6396130b8bb2aaa0d4ad0", "target": 0, "func": "DVDemuxContext* dv_init_demux(AVFormatContext *s)\n\n{\n\n    DVDemuxContext *c;\n\n\n\n    c = av_mallocz(sizeof(DVDemuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->vst = av_new_stream(s, 0);\n\n    c->ast[0] = av_new_stream(s, 0);\n\n    if (!c->vst || !c->ast[0])\n\n        goto fail;\n\n    av_set_pts_info(c->vst, 64, 1, 30000);\n\n    av_set_pts_info(c->ast[0], 64, 1, 30000);\n\n\n\n    c->fctx = s;\n\n    c->ast[1] = NULL;\n\n    c->ach = 0;\n\n    c->frames = 0;\n\n    c->abytes = 0;\n\n    c->audio_pkt[0].size = 0;\n\n    c->audio_pkt[1].size = 0;\n\n    \n\n    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;\n\n    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;\n\n    c->vst->codec.bit_rate = 25000000;\n\n    \n\n    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;\n\n    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;\n\n   \n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; \n\n    \n\n    return c;\n\n    \n\nfail:\n\n    if (c->vst)\n\n        av_free(c->vst);\n\n    if (c->ast[0])\n\n        av_free(c->ast[0]);\n\n    av_free(c);\n\n    return NULL;\n\n}\n", "idx": 11140, "substitutes": {"s": ["sq", "spec", "a", "ats", "settings", "rs", "as", "ar", "p", "gs", "sts", "f", "ps", "d", "g", "cs", "l", "m", "ins", "es", "i", "ses", "sv", "conv", "bs", "r", "is", "js", "less", "S", "ss", "ts", "its", "t", "ctx", "v", "os", "sb", "b", "h", "ns", "stats", "w", "fs", "options", "sc", "ls", "ims", "space", "ds", "sys"], "c": ["u", "config", "ct", "d", "cs", "m", "cc", "ce", "t", "ci", "check", "b", "nc", "comm", "cv", "cmp", "call", "ec", "bc", "dc", "g", "cal", "ac", "conf", "comp", "cm", "etc", "sc", "cr", "current", "pc", "abc", "a", "ch", "err", "enc", "k", "f", "cp", "cur", "l", "tc", "cd", "unc", "ic", "chain", "n", "mc", "ctx", "lc", "cn", "anc", "com", "uc", "can", "vc", "ca", "arc", "comments", "con", "p", "cl", "cf", "xc", "cb", "cont", "coll", "rc", "v", "self", "gc", "cache", "h", "cu", "fc", "C", "co"]}}
{"project": "qemu", "commit_id": "cb2e28780c7080af489e72227683fe374f05022d", "target": 0, "func": "static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int bytes, BdrvRequestFlags flags)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {0};\n\n    int ret = 0;\n\n    bool need_flush = false;\n\n    int head = 0;\n\n    int tail = 0;\n\n\n\n    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);\n\n    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,\n\n                        bs->bl.request_alignment);\n\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                    MAX_WRITE_ZEROES_BOUNCE_BUFFER);\n\n\n\n    assert(alignment % bs->bl.request_alignment == 0);\n\n    head = offset % alignment;\n\n    tail = (offset + bytes) % alignment;\n\n    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);\n\n    assert(max_write_zeroes >= bs->bl.request_alignment);\n\n\n\n    while (bytes > 0 && !ret) {\n\n        int num = bytes;\n\n\n\n        /* Align request.  Block drivers can expect the \"bulk\" of the request\n\n         * to be aligned, and that unaligned requests do not cross cluster\n\n         * boundaries.\n\n         */\n\n        if (head) {\n\n            /* Make a small request up to the first aligned sector. For\n\n             * convenience, limit this request to max_transfer even if\n\n             * we don't need to fall back to writes.  */\n\n            num = MIN(MIN(bytes, max_transfer), alignment - head);\n\n            head = (head + num) % alignment;\n\n            assert(num < max_write_zeroes);\n\n        } else if (tail && num > alignment) {\n\n            /* Shorten the request to the last aligned sector.  */\n\n            num -= tail;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_write_zeroes) {\n\n            num = max_write_zeroes;\n\n        }\n\n\n\n        ret = -ENOTSUP;\n\n        /* First try the efficient write zeroes operation */\n\n        if (drv->bdrv_co_pwrite_zeroes) {\n\n            ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,\n\n                                             flags & bs->supported_zero_flags);\n\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n\n                need_flush = true;\n\n            }\n\n        } else {\n\n            assert(!bs->supported_zero_flags);\n\n        }\n\n\n\n        if (ret == -ENOTSUP) {\n\n            /* Fall back to bounce buffer if write zeroes is unsupported */\n\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n\n\n\n            if ((flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n\n                /* No need for bdrv_driver_pwrite() to do a fallback\n\n                 * flush on each chunk; use just one at the end */\n\n                write_flags &= ~BDRV_REQ_FUA;\n\n                need_flush = true;\n\n            }\n\n            num = MIN(num, max_transfer);\n\n            iov.iov_len = num;\n\n            if (iov.iov_base == NULL) {\n\n                iov.iov_base = qemu_try_blockalign(bs, num);\n\n                if (iov.iov_base == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n                memset(iov.iov_base, 0, num);\n\n            }\n\n            qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n\n\n\n            /* Keep bounce buffer around if it is big enough for all\n\n             * all future requests.\n\n             */\n\n            if (num < max_transfer) {\n\n                qemu_vfree(iov.iov_base);\n\n                iov.iov_base = NULL;\n\n            }\n\n        }\n\n\n\n        offset += num;\n\n        bytes -= num;\n\n    }\n\n\n\nfail:\n\n    if (ret == 0 && need_flush) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n", "idx": 11141, "substitutes": {"bs": ["abilities", "lb", "obs", "vs", "ashes", "banks", "rots", "qs", "cks", "ats", "aos", "bp", "css", "hs", "gs", "bl", "bes", "bles", "sts", "ps", "bc", "BS", "cs", "boxes", "bm", "bits", "outs", "fps", "bn", "bing", "uts", "aus", "aws", "als", "js", "is", "its", "ts", "bos", "pb", "ils", "lbs", "bps", "ubs", "ads", "ops", "ubis", "sb", "b", "bis", "bh", "bi", "ns", "stats", "bd", "fs", "bb", "vals", "actions", "aks", "blog", "ls", "bt", "ims", "hz", "ds", "sys"], "offset": ["shift", "num", "off", "reset", "id", "address", "bf", "et", "buffer", "prefix", "pointer", "padding", "base", "order", "end", "seek", "alloc", "point", "o", "error", "offs", "pad", "slot", "location", "block", "pos", "ref", "oid", "zero", "position", "length", "window", "unk", "addr", "onto", "index", "bound", "attribute", "root", "Offset", "transform", "origin", "ot", "start", "alias", "slice", "onet", "batch", "set", "loc", "size", "out"], "bytes": ["ms", "len", "pieces", "units", "mb", "errors", "gets", "frames", "blocks", "izes", "gs", "buf", "words", "offs", "pages", "files", "lines", "ally", "SIZE", "pointers", "pos", "outs", "bits", "values", "es", "heads", "length", "terms", "its", "total", "rows", "ones", "runs", "bps", "nets", "count", "reads", "os", "loads", "ips", "elt", "abytes", "ns", "options", "faces", "nos", "Bytes", "seconds", "memory", "ions", "s", "tes", "byte", "size", "items", "parts"], "flags": ["tops", " styles", " Flags", "aps", "Flags", "comments", "locks", "parts", "flag", "bugs", "weights", "settings", "gnu", "fts", "rs", "types", "ps", "atts", " flock", "files", "FLAG", "bits", "heads", "args", "fps", "orts", "utils", "mods", "terms", "mask", "uts", "details", "posts", "ts", "lag", "ags", "fields", "sets", "ops", "wcs", "limits", "tags", "properties", "fits", "fs", "codes", "options", "vals", "faces", "actions", " fleets", "rates", "ds", "xf"], "drv": ["vrg", "drf", "derm", "drive", "derf", "rvr", "rdv", "dervs", "derj", "derver", "vrvr", "drve", "drg", "derw", "drj", "derv", "drvs", "drm", "driv", "srm", "rv", "drvr", "srv", " drm", "vrm", "drver", "srve", "srver", "dervr", "rdvr", "rg", "srvr", " drver", "srj", "drim", "drivs", "vrv", "derve", "rdj", "srf", "rm", "srvs", "srw", "derg", " drw", "rdf", "drw"], "qiov": ["Qiev", "qiop", "Qiov", "dqiop", "dqiev", "qiv", "iqiop", "dqiv", "iqiev", "iqiov", "iqiv", "Qiop", "dqiov", "Qiv", "qiev"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_put_be32s(f, &q->queue[i]);\n\n\n\n    qemu_put_sbe32s(f, &q->next);\n\n    qemu_put_sbe32s(f, &q->priority);\n\n}\n", "idx": 11142, "substitutes": {"f": ["tf", "fd", "fw", "bf", "fi", "a", "fo", "uf", "enc", "ff", "file", "form", "p", "rf", "o", "fp", "cf", "fm", "d", "g", "l", "m", "fb", "lf", "fa", "r", "j", "fn", "y", "t", "ac", "v", "fr", "sf", "e", "b", "c", "fac", "h", "F", "w", "fs", "fc", "x", "full", "fx", "z", "ft", "af", "xf"], "q": ["sq", "eq", "ck", "u", "qq", "quick", "ch", "pt", "quit", "Q", "req", "iq", "p", "cl", "ve", "d", "gr", "g", "pkg", "qa", "all", "queue", "qt", "r", "dq", "y", "t", "qu", "v", "conf", "que", "qi", "c", "query", "w", "requ", "z", "comm", "msg", "quest", "aq", "ue"], "i": [" m", "ami", "id", "u", "ai", "fi", "I", "me", "io", "li", "init", " I", " di", "wi", "p", "ri", "sim", " li", "ind", "ex", "ui", "m", "my", "sequence", " pi", "ki", "ti", " multi", "ic", "mu", "cli", " ti", "mi", "index", "is", "in", "j", "im", "ix", "y", "iu", "ci", "zi", "v", "phi", " mi", "xi", "gu", "multi", "qi", "gi", "di", "bi", "ij", "pi", "si", "it", "x", " err", " ii", " bi", "ini", "hi", " ni", "ims", "asi", "ii"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)\n\n{\n\n    uint32_t entry;\n\n    EHCIQueue *q;\n\n    int reload;\n\n\n\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    q = ehci_find_queue_by_qh(ehci, entry);\n\n    if (NULL == q) {\n\n        q = ehci_alloc_queue(ehci, async);\n\n    }\n\n    q->qhaddr = entry;\n\n    q->seen++;\n\n\n\n    if (q->seen > 1) {\n\n        /* we are going in circles -- stop processing */\n\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n        q = NULL;\n\n        goto out;\n\n    }\n\n\n\n    get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n    ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh);\n\n\n\n    if (q->async == EHCI_ASYNC_INFLIGHT) {\n\n        /* I/O still in progress -- skip queue */\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n        goto out;\n\n    }\n\n    if (q->async == EHCI_ASYNC_FINISHED) {\n\n        /* I/O finished -- continue processing queue */\n\n        trace_usb_ehci_queue_action(q, \"resume\");\n\n        ehci_set_state(ehci, async, EST_EXECUTING);\n\n        goto out;\n\n    }\n\n\n\n    if (async && (q->qh.epchar & QH_EPCHAR_H)) {\n\n\n\n        /*  EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */\n\n        if (ehci->usbsts & USBSTS_REC) {\n\n            ehci_clear_usbsts(ehci, USBSTS_REC);\n\n        } else {\n\n            DPRINTF(\"FETCHQH:  QH 0x%08x. H-bit set, reclamation status reset\"\n\n                       \" - done processing\\n\", q->qhaddr);\n\n            ehci_set_state(ehci, async, EST_ACTIVE);\n\n            q = NULL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n#if EHCI_DEBUG\n\n    if (q->qhaddr != q->qh.next) {\n\n    DPRINTF(\"FETCHQH:  QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\",\n\n               q->qhaddr,\n\n               q->qh.epchar & QH_EPCHAR_H,\n\n               q->qh.token & QTD_TOKEN_HALT,\n\n               q->qh.token & QTD_TOKEN_ACTIVE,\n\n               q->qh.next);\n\n    }\n\n#endif\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    if (reload) {\n\n        set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    }\n\n\n\n    if (q->qh.token & QTD_TOKEN_HALT) {\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n\n\n    } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) {\n\n        q->qtdaddr = q->qh.current_qtd;\n\n        ehci_set_state(ehci, async, EST_FETCHQTD);\n\n\n\n    } else {\n\n        /*  EHCI spec version 1.0 Section 4.10.2 */\n\n        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);\n\n    }\n\n\n\nout:\n\n    return q;\n\n}\n", "idx": 11143, "substitutes": {"ehci": ["ehcli", "ehoci", "ethercin", "ekcgi", "khoci", "ahcos", "phydi", "etherdi", "ekcin", "erci", "cmdcu", "drmcgi", "etherco", "ehco", "khcci", "khchain", "eshdi", "ethercci", "ethercu", "ahci", "etherli", "ahcu", "ercos", "ekci", "ohco", "ahli", "drmcli", "ekchain", "cmdcci", "orthcci", "ohci", "phycci", "ethcgi", "etherci", "drmcci", "ahdi", "ohdi", "ethni", "cmdci", "cmdoci", "eshco", "orthcli", "ethcit", "eshni", "ahco", "ekcit", "etheroci", "ehcin", "eshcu", "ekcci", " ehcu", " ehchain", "engcli", "ehcos", "erni", "ehcit", " ehcci", "ehdi", "ehcgi", "ohcli", "eshcci", "ethercgi", "ethcos", "eshcos", "engci", "ehli", " ehcos", "ercci", "ekoci", "phycli", "phyco", "orthco", "ohli", "ahoci", "ehchain", "drmci", "khci", "phyci", "eshcli", "ehni", "ahcli", " ehoci", "ethcli", "ethci", "ehcu", "eshci", "ohcci", "orthci", "ahcci", "ehcci", "engcci", "ethcin", "ethercit", "ethcci", "engcgi"], "async": ["facsync", "Aschron", "asersync", "asnic", "asyyn", "maschron", "massync", "anync", "ASyn", "acNC", "asSync", " asunc", "alnic", "facync", " Asynchronous", "lassync", "lasynchronous", "masynchronous", " asyn", " Assync", "ASync", "facyn", " aschron", "rasync", "asyline", " asday", "assync", "anyn", "asunc", "Assync", "lasyn", "rasunc", "acunc", "Asday", "alync", "asyync", " asline", " AsSync", "ASsync", "masync", "ASNC", "asyn", "lasync", "ansync", "rassync", " Async", "asersynchronous", "anynchronous", " asSync", "aschron", "acync", "asersday", "Asynchronous", "alsync", "Async", " asynchronous", " asNC", "ASline", "asday", "acsync", "aserssync", "acyn", "AsSync", "asynchronous", "Asyn", " asnic", "rasyn", "alyn", "facnic", " assync", "ASynchronous", "asline", "asNC", "asysync"], "entry": ["existent", "key", "look", "id", "RY", "address", "record", "path", "pointer", "join", "or", "match", "cell", "print", "hash", "insert", "enter", "ry", "nt", "slot", "way", "inter", "ptr", "qa", "adr", "addr", "queue", "index", "try", "ary", "rent", "row", "import", "ries", "needed", "dq", "directory", "rc", "nr", "search", "tmp", "query", "ly", "kh", "str", "member", "alias", "ent", "ient", "it", "link", "escape", "Entry", "offset", "angle"], "q": ["ck", "u", "quit", "o", "ry", "pg", "d", "m", "queue", "qt", "r", "question", "y", "view", "t", "qu", "check", "w", "comm", "cv", "gm", "think", "Q", "ping", "ve", "g", "qv", "qa", "dq", "conf", "que", "ql", "qi", "e", "z", "get", "item", "aq", "ue", "sq", "qs", "ch", "pt", "req", "iq", "k", "f", "l", "my", "local", "i", "window", "info", "comment", "quote", "quest", "quer", "eq", "fresh", "qq", "quick", "p", "ox", "pkg", "quant", "client", "inv", "j", "v", "cache", "c", "query", "lock", "h", "requ", "msg", "le", "store"], "reload": ["reloads", " Reloader", " Reloads", " Reload", "reeloader", " reloads", "replay", "reeload", "reeloads", "reloader", " replay", "reeplay", " Replay", " reloader"], "seen": ["shown", "documented", "there", "hid", "ordered", "awaited", "kept", "standing", "sofar", "linked", "received", "registered", "sent", "known", "seeing", "marked", "recorded", "ered", "common", "written", "numbered", "saw", " unseen", "done", "views", "represented", "zi", "far", "visible", "since", "found", "used", "verified", "connected", "see", "killed", "served"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static void omap_rtc_reset(struct omap_rtc_s *s)\n\n{\n\n    struct tm tm;\n\n\n\n    s->interrupts = 0;\n\n    s->comp_reg = 0;\n\n    s->running = 0;\n\n    s->pm_am = 0;\n\n    s->auto_comp = 0;\n\n    s->round = 0;\n\n    s->tick = qemu_get_clock(rt_clock);\n\n    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));\n\n    s->alarm_tm.tm_mday = 0x01;\n\n    s->status = 1 << 7;\n\n    qemu_get_timedate(&tm, 0);\n\n    s->ti = mktimegm(&tm);\n\n\n\n    omap_rtc_alarm_update(s);\n\n    omap_rtc_tick(s);\n\n}\n", "idx": 11167, "substitutes": {"s": ["ms", "vs", "spec", "locks", "sync", "sl", "comments", "qs", "ats", "sol", "rs", "as", "hs", "p", "gs", "sts", "an", "sm", "ps", "sac", "changes", "lines", "rates", "cs", "ins", "sv", "ies", "ses", "mods", "xs", "es", "bs", "store", "services", "utils", "params", "aws", "details", "is", "js", "als", "S", "ss", "ts", "se", "y", "its", "less", "t", "ops", "ads", "ears", "sb", "os", "b", "sw", "h", "results", "ns", "stats", "fs", "z", "comm", "ls", "tes", "ims", "ds", "ers", "sys", "parts"], "tm": ["td", "ms", " time", "tt", "tr", " mc", "tx", "hm", "tp", "nm", "map", "mm", "gm", "tic", "tk", "em", " te", " TM", "tz", "sm", "sim", "mint", " timer", " mt", "m", " td", "tc", "attr", "te", "wx", "mr", "ti", "txt", "mem", " ti", "md", "mi", " im", "tem", "qt", "dt", "ts", "htm", "mc", "t", "tn", "tis", "TM", "tmp", " ts", " tim", "temp", "cu", " mem", " tem", "rm", "him", "time", "tu", "mp", "ims", "timer", " tc", " tmp", "tv", "mt", "tim"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void tosa_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    PXA2xxState *mpu;\n\n    TC6393xbState *tmio;\n\n    DeviceState *scp0, *scp1;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa255\";\n\n\n\n    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);\n\n\n\n    memory_region_init_ram(rom, NULL, \"tosa.rom\", TOSA_ROM, &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n    tmio = tc6393xb_init(address_space_mem, 0x10000000,\n\n            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));\n\n\n\n    scp0 = sysbus_create_simple(\"scoop\", 0x08800000, NULL);\n\n    scp1 = sysbus_create_simple(\"scoop\", 0x14800040, NULL);\n\n\n\n    tosa_gpio_setup(mpu, scp0, scp1, tmio);\n\n\n\n    tosa_microdrive_attach(mpu);\n\n\n\n    tosa_tg_init(mpu);\n\n\n\n    tosa_binfo.kernel_filename = kernel_filename;\n\n    tosa_binfo.kernel_cmdline = kernel_cmdline;\n\n    tosa_binfo.initrd_filename = initrd_filename;\n\n    tosa_binfo.board_id = 0x208;\n\n    arm_load_kernel(mpu->cpu, &tosa_binfo);\n\n    sl_bootparam_write(SL_PXA_PARAM_BASE);\n\n}\n", "idx": 11193, "substitutes": {"machine": ["command", "power", "me", "message", "device", "image", "cell", "manager", "history", "iso", "engine", "sim", "domain", "instance", "hard", "m", "process", "smart", "gate", "model", "shell", "hello", "server", "monitor", "chain", "node", "connection", "keeper", "handler", "mode", "mc", "dem", "check", "zone", "Machine", "host", "achine", "money", "controller", "cpu", "mac", "link", "module", "vm", "space", "state", "template", "green"], "cpu_model": ["pixel_model", "cpuityimage", "cpu_relation", "pu_type", "cpu_class", "pu_brand", "pixel_class", "cpu_label", "pu_image", "cpu_link", "cpuwarerelation", "pu_label", "pu_mode", "cpuitymode", "cpuwaretype", "pixel_label", "cpu_image", "cpuitybrand", "pixel_link", "pu_model", "cpu_mode", "cpu_type", "cpuitymodel", "cpuwaremode", "pu_relation", "cpuwaremodel", "cpu_brand"], "kernel_filename": ["kernel___fn", "kernel32username", "kernelityfilename", "ernel_file", "kernel___command", "kernel___filename", "kernel___via", "kernel___uri", "ernel_Filename", "kernel_location", "kernel32fn", "ernel_username", " kernel_fn", "kernelityfile", "ernel_command", "kernel___username", "ernel_nom", "kernel_file", " kernel_via", "kernel_nom", "kernel32filename", " kernel_username", "kernel_uri", "kernel_Filename", "kernel_fn", "ernel_filename", "ernel_uri", "kernel_via", "kernelphpfile", "kernelphpcommand", "ernel_location", "kernel32via", "kernel_username", "kernelityFilename", "kernel___file", "kernelitynom", "kernelphpfilename", "kernelphpuri", "kernel_command"], "kernel_cmdline": ["kernel_controlline", "kernel_paylines", "kernel_cmdine", "kernel_cmdword", "kernel_catcall", "kernel_mdcall", "kernel_commandle", "kernel_mdline", "kernel_cssLine", "kernel_payle", "kernel_cmdlines", "kernel_mdword", "kernel_cssline", "kernel_controline", "kernel_cmdle", "kernel_commandine", "kernel_catLine", "kernel_mdLine", "kernel_commandline", "kernel_catline", "kernel_extle", "kernel_cssword", "kernel_payline", "kernel_commandcall", "kernel_controllines", "kernel_cmdcall", "kernel_commandword", "kernel_commandlines", "kernel_extline", "kernel_cmdLine", "kernel_commandLine", "kernel_extlines", "kernel_extine"], "initrd_filename": ["initrd__files", "initrd_module", "initara_module", "initrd_Filename", "initrb_file", "initrdaphsource", "initrd___module", "initrb_string", "initrd___source", "initrd_creation", "initrd_where", "initrd__where", "initrd_username", "initrd_function", "initrs_filename", "initrd___database", "initrdptfile", "initrs_creation", "initrdaphfunction", "initrb_database", "initrr_filename", "initrdaphfilename", "initrd___filename", "initrs_Filename", "initrr_files", "initara_filename", "initrdaphmodule", "initrs_file", "initrd__username", "initara_source", "initrr_where", "initrd___function", "initrdptdatabase", "initrdptstring", "initrd___file", "initrd_files", "initara_function", "initrr_username", "initrb_filename", "initrd_file", "initrd_string", "initrd_source", "initrd___string", "initrdptfilename", "initrd_database", "initrd__filename"], "address_space_mem": ["address_space5mem", "address_space5rom", "address_area_memory", "address_area_ram", "address_space_rom", "address_area_mem", "address_space_memory", "address_space5ram", "address_space_Mem", "address_space_buf", "address_space_ref", "address_space_ram"], "rom": ["roma", "rain", "tm", "gem", "mm", "rim", "prom", "ran", "rs", "region", "ri", "rep", "rib", "rob", "ram", "ra", "bm", "chrom", "drm", "mr", "sam", "usr", "arm", "mem", "ros", "im", "ROM", "rg", "reg", "rem", "irm", "dem", "com", "ro", "mor", "sem", "cm", "sr", "res", "cpu", "serv", "rm", "rum", "ru", "cr", "prem", "rar", "gra"], "mpu": ["mpui", "ppi", "MPu", "scpu", "umu", "mmU", "cppu", "MPo", "mtui", "pppu", "MPU", "mmu", "mtu", "ampus", "mto", "popu", "MPpu", "ppcu", "mmus", "cpU", "ampu", "ampui", "mmo", "cpiu", "poptu", "pmtu", "mpa", "mtiu", "sciu", "popuu", "cpi", "mpus", "mtpu", "ppu", "mppu", "mtU", "mpi", "mtus", "scu", "mpiu", "ppuu", "scus", "mpcu", "mmpu", "umus", "ppU", "scui", "pmcu", "pmuu", "ampa", "mpU", "pptu", "pmu", "umiu", "cpui", "MPi", "cpu", "mta", "cpa", "MPus", "mptu", "mpo", "mpuu", "cpus", "popcu", "umpu", "mmiu"], "tmio": ["mtotor", "tmiol", "tmient", "tomo", "mmao", "tnient", "tomao", "vtio", "mmo", "tcii", "pmii", "tnii", "tno", "mmio", "mtio", "vtotor", "mtiol", "pmao", "pmiol", "vtiol", "tcio", "tomient", "tmo", "tniol", "pmIO", "tnio", "pmotor", "tomio", "pmio", "mtIO", "tmIO", "tmii", "tnao", "tciol", "vtIO", "mmient", "tmotor", "tcao", "tmao"], "scp0": ["scp8", "scvp1", "scvpzero", "scyp2", " scvp0", "scop1", "scapzero", "scvp0", "scop080", "scu1", " scpzero", "scpi0", "scpafrom", "scsp2", "scpi8", "scypfrom", "scap0", "scvp00", "scpi080", "scanp2", "scpa0", " scop8", "scjp8", "scanp0", " scop0", " scp8", "scp080", "scpa2", " scp080", "scuzero", "scop8", "scop0", "scap00", "scjp080", "scanyp0", " scop1", "scanyp2", "scpzero", "scspfrom", " scvp1", "scsp0", "scap1", "scu0", "scp00", " scvp00", "scjp0", " scp00", "scjp1", "scu00", "scyp0", "scpi1", "scanypfrom", "scpfrom", "scanpfrom", " scvpzero", " scop080", "scp2"], "scp1": [" scsp1", "escpOne", "scsp11", "scp9", "scpe0", " scsp0", "scop1", "escap4", "scap4", "scop9", "scspOne", "scsp2", "escp2", "scsp1", " scsp11", "scop11", "scpa9", "escap2", "scpa0", " scp9", "escp1", "scpOne", "scap2", "scpc9", "scm4", " scop9", "scop0", "scm2", "escp4", "scmOne", "scpa1", "scsp4", "scp4", "escapOne", " scop1", "scpe1", "scp11", "scpc0", "scsp0", "scap1", "scpc1", "scapOne", "scm1", " scp11", " scop0", "scp2", "escap1", "scpe11"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n", "idx": 11202, "substitutes": {"ibs": ["ibh", "IBsol", "obs", "ibsc", "iamjs", "ijs", "IBfs", "IBjs", "iams", "ijjs", "ibfs", "ijfs", " ibsc", "ippsol", "ribsc", "ippjs", "ribd", "obd", " ibh", "iamsol", "IBh", " ibfs", "ribs", "ibjs", "obfs", " ibd", "ipps", "ribfs", "IBs", "ijh", "ibsol", " ibjs", "obsc", "ibd"], "cmd": ["command", "op", "off", "send", "cmp", "call", "config", "pay", "ctrl", "Cmd", "crit", "news", "req", "ct", "iq", "bind", "form", "job", "seq", "prop", "cp", "act", "pkg", "grad", "cd", "control", "rn", "args", "def", "desc", "ctl", "auth", "raw", "cb", "cli", "ext", "md", "cont", "cod", "ctx", "check", "forge", "conf", "cfg", "good", "ctr", "exec", "once", "force", "batch", "comm", "msg", "nd", "patch", "mt"], "cmd_len": ["cmd_lon", "cmd_ls", "cmd_ref", " cmd_lon", "cmd__ref", "cmd__len", " cmd_ref", " cmd_ls", "cmd__lon", "cmd__ls"], "rsp": ["Rsp", "wsw", "Rpc", "rdpc", "wps", " rsw", " rresp", "rresp", " rps", "rdsp", "rpc", "rdsw", " rpc", "rsw", "rps", " rp", "rp", "wsp", "Rp", "wp", "rdresp", "Rresp", "Rps", "Rsw"], "rsp_len": ["rsp2gen", "rsp_ls", "rsp2len", "rpt_ls", "rsp2ls", "rpt_len", "rsp_gen", "rsp2size", "rpt_gen", "rpt_size", "rsp_size"], "max_rsp_len": ["max_rresp_len", "max_rsp2Len", "max_rsp2length", "max_rsp_gen", "max_rsp_length", "max_rresp_length", "max_rsp2len", "max_rsp_Len", "max_rsp2gen", "max_rresp_Len", "max_rresp_gen"], "sens": ["cents", "Sensor", "Sent", "iseng", "gens", "Sens", "soss", "Soss", " sent", "seens", "Sends", "psensor", "isoss", "sent", "Seng", "teng", "isent", "sans", "seng", "ceng", "tents", "seans", "sENS", "isends", "cens", " sents", "SENS", "seENS", "gENS", "tENS", "gans", " sENS", "sents", "Sans", "tends", "tens", "isans", " soss", " seng", "pENS", "pens", "seensor", "gents", " sans", "sensor", "isens", "pans", "tans", "psents", "psent", "pensor", "tent", " sensor", "cent", "psens", "Sents", "sends"]}}
{"project": "qemu", "commit_id": "b45c03f585ea9bb1af76c73e82195418c294919d", "target": 1, "func": "struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n", "idx": 11235, "substitutes": {"base": ["key", "id", "address", "mb", "buffer", "prefix", "a", " bases", "based", "bas", "bind", "area", "range", "p", "f", "domain", "ase", "ip", "cycle", "m", "l", "ref", "pos", "null", "i", "store", "handle", "server", "bit", "index", "bound", "n", "se", "y", "v", "b", "out", "c", "h", "offset", "re", "Base", "res", "pi", "x", "set", "memory", "name", "space", "size", "kit", "ASE", "sys", "pa"], "irq": ["irtqq", "ircqu", " irqs", " irch", "iriquant", "ircqi", "ironch", " irqu", "ironqi", "ibrq", "IRQ", "pirch", "nirq", "IRq", "irtqs", "iriq", "nirqi", "irtq", " irqi", "IRqi", "irch", "arqu", "irquant", "arQ", "irqs", "mirqq", "arqi", "ibrqq", "mirch", "mirqs", "ibrqi", "iriqq", "ironqu", "irqi", "IRqu", "irQ", "irqu", "ircQ", "pirqu", "pirq", "ibrquant", "arq", "ircq", "ironq", "iriqi", "pirqi", "nirquant", " irqq", "irqq", "mirq", "nirqq", "irtch"], "fclk": ["flasskg", " fflke", "fClkr", "fllk", "fmlke", "fklk", " fclj", "fblj", "fllp", "fblk", "fplke", " fclp", " fclke", "fmlk", "fklp", " fllke", "fmlck", "fplk", " fclck", "fclke", "fflkr", "fflck", " fflk", "fClck", " fplj", "fflj", "fplp", " fllck", "fblp", "fclkr", "fklke", "flasske", "fblke", " fclkg", " fflkr", " fclkr", "fsclck", " fflck", "fllck", "fsclke", "fsclk", " fllk", "fflp", "fclkg", "fplj", "fclp", "fclck", " fplkg", " fplke", "fClke", " fplp", "fllke", "fflke", "fClk", "fblkg", "flassk", "fflk", "fclj", " fplk", "fsclp", "fplkg", "fmlkr", " fllp", "fklck"], "iclk": ["iclcke", "ircrlq", "ircrlch", "ircrlke", "irclk", "icdlq", "ircrlk", "icdlch", "iclcch", "icdlk", "iclq", "icrlch", "iclck", "icdlke", "irclke", "iclcq", "iclke", "irclq", "icrlq", "iclch", "icrlk", "irclch", "icrlke"], "txdma": ["txnMA", "rtnma", "txsdMA", "rtnMA", "txnmas", "txnma", "rtdia", "rtdma", "txvdia", "txsdia", "rtdMA", "txsdma", "txsdmas", "txvdmas", "txnia", "txdmas", "txvdma", "txdia", "txvdMA", "rtnmas", "rtdmas", "txdMA", "rtnia"], "rxdma": ["rdxma", "rxdMA", "rldmas", "rvdMA", "rdxda", "rxdda", "rxdmas", "txdda", "rvdda", "rldMA", "tdxMA", "rldma", "txdmas", "rldda", "rdxmas", "rdxMA", "tdxma", "rvdma", "tdxmas", "rvdmas", "txdMA", "tdxda"], "label": ["key", "brand", "id", "bel", "cell", "role", "els", "unit", "slot", "block", "l", "type", "local", "control", "desc", "serial", "layout", "ell", "lab", "abel", "annot", "val", "comment", "pal", "LAB", "Label", "alias", "tag", "link", "group", "msg", "el", "description", "name", "loc", "style"], "chr": ["echar", "Chdr", " chdr", "CHar", "echrs", "CHr", " chrs", "Chrs", "Char", "echrd", " chrd", "Chrd", "chdr", "chrs", "CHdr", "CHrs", "Chr", "echr", "chrd"], "s": ["ms", "ports", "vs", "spec", "ists", "sl", "status", "gets", "a", "qs", "ats", "source", "settings", "rs", "tests", "as", " is", "izes", "p", "gs", "sts", " os", "f", "ps", "d", "changes", "g", "m", "cs", "l", "ins", "es", "i", "save", "bs", "services", "details", "r", "pers", "js", "j", "S", "ss", "ts", "is", "its", "se", "t", "sports", " sets", "v", "os", "sb", "b", "c", "h", "acs", "ns", "stats", "w", "fs", "set", "comm", "ls", "states", "space", "ds", "ers", "store"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)\n\n{\n\n    VHDDynDiskHeader *dyndisk_header =\n\n        (VHDDynDiskHeader *) buf;\n\n    size_t block_size, num_bat_entries;\n\n    int i;\n\n    int ret = -EIO;\n\n\n\n    // Write the footer (twice: at the beginning and at the end)\n\n    block_size = 0x200000;\n\n    num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512);\n\n\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    // Write the initial BAT\n\n    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    memset(buf, 0xFF, 512);\n\n    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n\n        if (write(fd, buf, 512) != 512) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    // Prepare the Dynamic Disk Header\n\n    memset(buf, 0, 1024);\n\n\n\n    memcpy(dyndisk_header->magic, \"cxsparse\", 8);\n\n\n\n    /*\n\n     * Note: The spec is actually wrong here for data_offset, it says\n\n     * 0xFFFFFFFF, but MS tools expect all 64 bits to be set.\n\n     */\n\n    dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL);\n\n    dyndisk_header->table_offset = be64_to_cpu(3 * 512);\n\n    dyndisk_header->version = be32_to_cpu(0x00010000);\n\n    dyndisk_header->block_size = be32_to_cpu(block_size);\n\n    dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries);\n\n\n\n    dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));\n\n\n\n    // Write the header\n\n    if (lseek(fd, 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    if (write(fd, buf, 1024) != 1024) {\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 11268, "substitutes": {"fd": ["td", "fin", "dd", "fi", "bf", "fl", "buffer", "io", "std", "uf", "ff", "file", "stream", "form", "func", "dev", "df", "f", "fp", "ld", "d", "ud", "fb", "hd", "ptr", "gz", "ctl", "lf", "window", "cb", "fa", "handle", "eg", "gd", "actor", "cond", "fn", "dl", "handler", "ctx", "fax", "fr", "dir", "feat", "FD", " fid", "fat", "elt", "fs", "fc", "fed", "buff", "db", "sd", "dt", "pid", "ds", "vol"], "buf": ["doc", "cam", "alloc", "proc", "rw", "Buffer", "block", "attr", "desc", "queue", "data", "cap", "BU", "b", "cmd", "kb", "orig", "w", "foo", "cv", "arr", "tr", "uf", "rb", "ff", "bl", "iter", "bc", "ptr", "uffer", "txt", "Buff", "ob", "batch", "pack", "bt", "img", "obj", "fw", "bf", "buffer", "bu", "var", "vec", "cur", "ref", "fb", "tab", "raw", "window", "bg", "ctx", "good", "tmp", "it", "db", "bar", "bag", "out", "aka", "bin", "act", "pkg", "cb", "bytes", "cont", "br", "pb", "box", "v", "cache", "buff", "msg", "wb"], "total_sectors": ["total_seves", "total_specs", "total_serctors", "total_selements", "total_spellers", "total_serves", "total_vellers", "total_vectors", "total_serors", "total_sellers", "total_pseors", "total_veves", "total_psellers", "total_psectors", "total_psecs", "total_velements", "total_serlements", "total_vecs", "total_veors", "total_seors", "total_speors", "total_spectors", "total_secs"], "dyndisk_header": ["dyndiff_module", "dyndisk_buffer", "dyndiskityhead", "dyndiskdbaverage", "dyndiff_head", "dyndisk_manager", "dyndiskitymanager", "dyndiskmopmanager", "dyndiff_headers", "dyndiskityheader", "dyndiff_writer", "dyndiff_average", "dyndiff_data", "dyndisk_headers", "dyndiff_wrapper", "dyndisk__buffer", "dyndiskmopheader", "dyndiff_header", "dyndiff_handler", "dyndisk_head", "dyndiff_buffer", "dyndisk_list", "dyndisk_wrapper", "dyndiff_Header", "dyndisk_writer", "dyndisk__head", "dyndisk_magic", "dyndisk_average", "dyndisk_handler", "dyndisk_info", "dyndiskdbheader", "dyndiff_info", "dyndisk_profile", "dyndiskmopmagic", "dyndiskityhandler", "dyndisk_data", "dyndisk__header", "dyndisk__list", "dyndiskdbhead", "dyndiff_manager", "dyndiskmophead", "dyndisk_module", "dyndiff_magic", "dyndisk_Header", "dyndiff_list", "dyndiff_profile", "dyndiskdbmodule"], "block_size": ["blockPsize", "disk_description", " block_name", "block_cache", "block_height", "block_description", "blocklySize", "blocklysize", "Block_window", "disk_SIZE", "block_Size", "Block_size", "Block_SIZE", "block_name", "block_window", "disk_count", "blockPSize", "blocklysource", "disk_size", "line_Size", "block_start", " block_SIZE", "block_source", "blocklySIZE", "line_cache", "line_size", "blockPstart", "Block_source", "Block_Size", " block_start", "line_height", " block_Size", "block_SIZE", "block_count"], "num_bat_entries": ["num_bat_entues", "num_bat_matues", "num_bat_sentires", "num_bat_Entires", "num_bat_matries", "num_bat_entsries", "num_bat_entsrys", "num_bat_series", "num_bat_Entriers", "num_bat_entryries", "num_bat_Entories", "num_bat_Entresses", "num_bat_Entarts", "num_bat_matrys", "num_bat_entories", "num_bat_seories", "num_bat_entryies", "num_bat_Entrys", "num_bat_entsresses", "num_bat_ntrys", "num_bat_sentries", "num_bat_Entry", "num_bat_Entues", "num_bat_sentues", "num_bat_entryarts", "num_bat_entryrys", "num_bat_enties", "num_bat_entrys", "num_bat_addresses", "num_bat_Enties", "num_bat_entires", "num_bat_addries", "num_bat_ntries", "num_bat_seresses", "num_bat_entsories", "num_bat_ntry", "num_bat_matires", "num_bat_ntriers", "num_bat_entriers", "num_bat_addriers", "num_bat_entarts", "num_bat_sentrys", "num_bat_entresses", "num_bat_addrys", "num_bat_Entries", "num_bat_entry", "num_bat_serys"], "i": ["u", "ai", "I", "me", "li", "q", "print", "k", "p", "sim", "ex", "ind", "f", "ui", "ip", "g", "m", "l", "ki", "ti", "in", "mi", "index", "chain", "try", "j", "im", "ix", "n", "y", "t", "ci", "iu", "phi", "v", "info", "zi", "xi", "multi", "qi", "b", "c", "h", "gi", "bi", "di", "pi", "si", "by", "it", "x", "ini", "ii"]}}
{"project": "qemu", "commit_id": "b9c532903fa528891c0eceb34ea40a0c47bfb5db", "target": 0, "func": "static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count < 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        return snap_count;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n", "idx": 11303, "substitutes": {"bs": ["ms", "obs", "vs", "aos", "bp", "rs", "hs", "bes", "bl", "gs", "ps", "bc", "BS", "cs", "bits", "us", "aus", "js", "ss", "ts", "its", "pb", "lbs", "ubs", "os", "sb", "b", "bis", "bh", "ns", "fs", "ls", "ds"], "psn_tab": ["psn___cell", "psn___buf", "psns_reg", "psn___map", "psn_buf", "psn____reg", "psn_map", "psns_tab", "psn___reg", "psn_reg", "psns_Tab", "psn_Tab", "psn____Tab", "psns_map", "psn____map", "psns_cell", "psn___tab", "psn____tab", "psns_buf", "psn___Tab", "psn_cell"], "s": ["vs", "rs", "hs", "sp", "p", "gs", "sts", "ps", " ss", "cs", "ins", "sv", "is", "js", "less", "S", "ss", "ts", "its", "t", "v", "os", "sb", "b", "c", "h", "sn", "ns", "stats", "fs", "ls", "ds", "sys"], "sn_info": ["honjlink", "connect_information", "nn__info", " sn_success", "connect_success", "sn7info", "snistname", " sn_comment", "sn_success", "snobjlist", "sn_link", "sn_INFO", "sn__INFO", "nn__INFO", "pn_info", "sn_fo", " sn_state", "nn__list", "snistinformation", "sn_state", "snap_info", "snap_information", "nn__type", "sn_list", "sn_information", "honjinfo", "sn__list", "snmddetails", "connect_info", "hon_info", "snjlink", "sn7type", "cn_info", "honjname", "sn_name", "syn_count", "sn_check", "sn_details", "sn__info", "snjname", "syn_details", "hon_link", "sn__fo", "sn_count", "pn_check", "syn_info", "nn_list", "snjinformation", "hon_name", " sn_fo", "sn8details", "snobjfo", "honjinformation", "sn8type", "snmdinfo", "connect_inf", "syn_fo", "sn7list", "cn_inf", "cn_details", "pn_INFO", "sn__type", "sn_inf", "sn8INFO", "sn7INFO", "nn_type", "syn_INFO", "syn_list", "snobjinfo", "nn_info", " sn_inf", "snjinfo", "pn_fo", "snistinfo", "syn_type", "sn8info", "snmdinf", "nn_INFO", "sn_comment", " sn_INFO", "sn__comment", "snobjcount", "hon_information", "sn_type"], "sn_tab": ["sn_db", "sn_abs", "sn_lab", "sn__buf", "snjabs", "sn8Tab", "snap_db", "snxabs", "sn__db", "snap_tab", "Sn_bag", "nlaxyctrl", "snaxytab", "Sn_tmp", "snap_Tab", "sn_buf", "sn_tmp", "sn__tab", "nl_Tab", "sn_Tab", "snaxylab", "sn__Tab", "sn__bag", "sn_track", "nn_tab", "sn8ctrl", "snjtab", "nl_lab", "snxtab", "nlaxytab", "nn_abs", "snaxyTab", "sn_bag", "sn8tab", "sn__tmp", "snxinfo", "sn8lab", "nl_tab", "snjlab", "sn__track", "nlaxyTab", "nn_info", "snjinfo", "snap_track", "nl_ctrl", "Sn_tab", "snaxyctrl", "snxlab", "Sn_buf", "nlaxylab", "sn_ctrl", "nn_lab"], "i": ["ie", "m", "im", "y", "t", "ci", "zi", " mi", "gi", "pi", "slice", "hi", "ji", "ims", "ami", "status", "I", "li", "init", "ri", "ex", "ind", "ki", "ti", " ti", "mi", "ix", "xi", "e", "multi", "qi", "si", "batch", " ni", "ai", "ei", "iq", "k", "point", "f", "ui", "ip", "l", "ic", " si", "in", "index", "n", "\u0438", "phi", "info", "remote", "it", "ini", " bi", "ii", "me", "p", "sim", "json", "cli", "is", "j", "series", "iu", "v", "c", "h", "di", "bi", "x", " ii", " j", "ij"], "snap_count": ["snap_counter", "snapCountCount", "spanjcurrent", "ap_info", "snap___cmd", "snap1status", "sn_status", " snap_len", "nav64count", "snap_total", "snap_check", "snap32Count", "snap_Count", "snap32counter", "snap64current", "snap_ct", "snap64entry", " snap_list", " snap_cycle", "snitycache", "capt64len", "snap32count", "ap_nb", "span_counter", "snap32cycle", "snap64total", "nav_num", "snap_info", "snap_cache", "sn_list", "snap___data", "spanjentry", "snap64counter", " snap_flag", " snap_ct", "snap_status", "sn_cache", "snapptnum", "snap_cycle", "span_count", "capt64total", "snapXcount", "snap64count", "snapptdata", "nav_count", "sn_check", "snapptcount", "ap_count", "snap_cell", "spanjcount", "capt64num", "spanjcounter", "nav_cmd", "snap32cache", "snapjentry", "snap_entry", "capt_len", "snapXct", "snapCountct", "snapitystatus", "snap64num", "snap32current", "snitystatus", "snap___num", "sn_count", "snap_data", " snap_Count", "span_current", "snap1count", "snapitycount", "capt64count", "snapXCount", "snap32entry", "snap_cmd", "capt_num", " snap_cell", "capt_count", "snap___count", "snapptcmd", "sn_sum", "nav64cmd", "snap_flag", "snitycount", "snap64len", "nav64num", "snap64data", "snapjcount", "snapjcurrent", "snap_current", "nav64data", "snap1cache", "snap32check", "nav_data", "snapXlen", "ap_sum", "snap_sum", "snapCountcount", "snapitycache", "snitycheck", "snap_num", "sn_Count", "snapCountlen", "snap64cmd", "capt_total", "span_entry", "snap32list", "snapjcounter", "snap_len", "snap_nb", "snapitycheck", "snap1check", "snap32status", "snap_list"], "snaps": ["snapats", "nacs", "Snap", "swapped", " snacs", "slats", "cnapped", "nats", "cnaps", "snims", " snims", " snap", "napped", "swps", "slops", "sneps", "synops", "snops", "swops", "snapaps", "snapes", "snps", "swacs", "slps", "swims", "synapes", "nops", "swaps", "Snapses", "synapses", "syneps", "snapamps", "Snaps", "slaps", "reshacs", "nnops", "nnapes", "slapes", "nnats", "Snamps", " snps", "napses", "cnap", "reshaps", "slacs", "swapses", "namps", "snap", " snamps", "swap", "synats", "Sneps", "cnats", "nnaps", " snapses", "nap", "snamps", "snats", "reshats", "naps", "swats", "snapims", " snats", "snapped", "swamps", "reshamps", " sneps", "Snats", " snops", "snacs", "synaps", "snapses"], "snap_name": [" snap_info", " snap2resource", "snap_time", "snap_word", "snJtype", "snapJtype", "snappttype", "sn_type", "snapjname", "sn_word", "snapjword", "snapjinfo", "snap2word", "snJtext", "snappttext", "sn_text", "snap_base", "snapamename", "snapameresource", "snapamelabel", "snap2resource", "snap2label", "snap_resource", " snap2info", "snapameinfo", "sn_base", "snap2name", "snap_type", "sn_name", " snap_resource", "snapptbase", "snap_text", "snapJtext", " snap2label", "snap2time", "snap2info", "snapjtime", "snapJbase", " snap2name", "snapptname", "snap_label", "sn_time", "snapJname", " snap_label", "snap_info", "snJname", "snJbase"]}}
{"project": "qemu", "commit_id": "62c58ee0b24eafb44c06402fe059fbd7972eb409", "target": 0, "func": "static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,\n\n                                 MMUAccessType access_type, ARMMMUIdx mmu_idx,\n\n                                 hwaddr *phys_ptr, int *prot, uint32_t *fsr)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    bool is_user = regime_is_user(env, mmu_idx);\n\n    int n;\n\n    int matchregion = -1;\n\n    bool hit = false;\n\n\n\n    *phys_ptr = address;\n\n    *prot = 0;\n\n\n\n    /* Unlike the ARM ARM pseudocode, we don't need to check whether this\n\n     * was an exception vector read from the vector table (which is always\n\n     * done using the default system address map), because those accesses\n\n     * are done in arm_v7m_load_vector(), which always does a direct\n\n     * read using address_space_ldl(), rather than going via this function.\n\n     */\n\n    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */\n\n        hit = true;\n\n    } else if (m_is_ppb_region(env, address)) {\n\n        hit = true;\n\n    } else if (pmsav7_use_background_region(cpu, mmu_idx, is_user)) {\n\n        hit = true;\n\n    } else {\n\n        for (n = (int)cpu->pmsav7_dregion - 1; n >= 0; n--) {\n\n            /* region search */\n\n            /* Note that the base address is bits [31:5] from the register\n\n             * with bits [4:0] all zeroes, but the limit address is bits\n\n             * [31:5] from the register with bits [4:0] all ones.\n\n             */\n\n            uint32_t base = env->pmsav8.rbar[n] & ~0x1f;\n\n            uint32_t limit = env->pmsav8.rlar[n] | 0x1f;\n\n\n\n            if (!(env->pmsav8.rlar[n] & 0x1)) {\n\n                /* Region disabled */\n\n                continue;\n\n            }\n\n\n\n            if (address < base || address > limit) {\n\n                continue;\n\n            }\n\n\n\n            if (hit) {\n\n                /* Multiple regions match -- always a failure (unlike\n\n                 * PMSAv7 where highest-numbered-region wins)\n\n                 */\n\n                *fsr = 0x00d; /* permission fault */\n\n                return true;\n\n            }\n\n\n\n            matchregion = n;\n\n            hit = true;\n\n\n\n            if (base & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region base\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, base, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n            if ((limit + 1) & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region limit\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, limit, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!hit) {\n\n        /* background fault */\n\n        *fsr = 0;\n\n        return true;\n\n    }\n\n\n\n    if (matchregion == -1) {\n\n        /* hit using the background region */\n\n        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);\n\n    } else {\n\n        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);\n\n        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);\n\n\n\n        if (m_is_system_region(env, address)) {\n\n            /* System space is always execute never */\n\n            xn = 1;\n\n        }\n\n\n\n        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);\n\n        if (*prot && !xn) {\n\n            *prot |= PAGE_EXEC;\n\n        }\n\n        /* We don't need to look the attribute up in the MAIR0/MAIR1\n\n         * registers because that only tells us about cacheability.\n\n         */\n\n    }\n\n\n\n    *fsr = 0x00d; /* Permission fault */\n\n    return !(*prot & (1 << access_type));\n\n}\n", "idx": 11316, "substitutes": {"env": ["vs", "ah", "config", "end", "proc", "uv", "enter", "eng", "vp", "esm", "queue", "t", "eco", "cmd", "eu", "serv", "org", "context", "cv", "era", "ami", "et", "network", "init", "email", "docker", "Environment", "ptr", "en", "server", "conn", "conf", "environment", "e", "eas", "estate", "nv", "state", "obj", "wall", "net", "runner", "ev", "cp", "worker", "vt", "window", "shell", "ctx", "sw", "kh", "hw", "er", "vm", "exc", "here", "event", "erd", "home", "dev", "eni", "pkg", "np", "te", "v", "esp", "st", "kernel", "set", "msg", "disk", "center", "ner", "viron"], "address": ["command", "resource", "network", "buffer", "Address", "pointer", "base", "message", "route", "path", "prefix", "order", "device", "region", "uri", "image", "range", "point", "a", "error", "domain", "ase", "location", "ip", "operation", "process", "condition", "type", " Address", "ptr", "position", "trace", "port", "request", "i", "adr", "addr", "reference", "attribute", "index", "r", "interface", "execute", "date", "action", "shape", "host", "ace", "target", "alias", "x", "memory", "private", "description", "name", "offset", "number"], "access_type": ["access_info", "access2Type", "access_Type", "Access_info", "accessTypetype", "accessTypeaddress", "accessTypeType", "accessTypeinfo", "access2info", "Access_Type", "access2type", "access_address", "access2address", "Access_address", "Access_type"], "mmu_idx": ["mmu_iny", "mmu_midci", "mmu2midx", "mmu_Idv", "mmu_idz", "mmu2idp", "mmu2midv", "mmu_idey", "mmu_dy", "mmu_inci", "mmu_inz", "mmu2idv", "mmu_idexc", "mmu_idxc", "mmu_dx", "mmu_idg", "mmu2midp", "mmu_idci", "mmu_indexx", "mmu_midv", "mmu_lastx", "mmu_inx", "mmu2idci", "mmu_Idg", "mmu_Idy", "mmu_Idx", "mmu_dg", "mmu_Idz", "mmu_idex", "mmu_lastp", "mmu_lastv", "mmu_idep", "mmu_inv", "mmu_Idp", "mmu_idp", "mmu_midx", "mmu_ideg", "mmu_indexxc", "mmu_indexg", "mmu_inp", "mmu2idx", "mmu_lastci", "mmu_idv", "mmu_idy", "mmu2midci", "mmu_dv", "mmu_indexp", "mmu_idez", "mmu_midp"], "phys_ptr": ["phys_desc", "physlyhandle", "phys_ref", "phys__addr", "phy_addr", "physical_ref", "physlyptr", "phys__ptr", "phy_ptr", "physlypointers", "physical_addr", "physical_desc", "phy_handle", "phys__pointers", "phy_pointers", "physlyaddr", "phys_handle", "physical_ptr", "phys__handle", "phys_pointers", "phys_addr"], "prot": ["platform", "col", "tf", "chron", "method", "password", "typ", "net", "pc", "pat", "priority", "status", "lan", "fd", "channel", "mult", "format", "ping", "pattern", "slot", "iat", "Prot", "type", "ptr", "port", "tif", "addr", "ext", "ocol", "version", "phy", "mode", "rot", "virtual", "eth", "pro", "stat", "dt", "tz"], "fsr": ["FSr", "fsvr", "resR", "FSvr", "wssr", "tsr", "FSR", "mssr", "resr", "fsR", "wsrb", "ssR", "FSrb", "fsrb", "fssr", "tsR", "wsR", "fsrs", "resrs", "msR", "FSrs", "ssr", "resvr", "FSsr", "sssr", "msr", "ressr", "ssrb", "msrs", "wsr", "tsvr", "tssr"], "cpu": ["nic", "net", "pc", "mx", "gpu", "tp", "runner", "socket", "prof", "processor", "device", "cam", "bean", "alloc", "nu", "proc", "p", "cp", "pu", "linux", "ram", "ip", "machine", "process", "np", "jp", "arch", "ka", "mu", "core", "CPU", "mem", "clock", "addr", "node", "ctx", "conn", "gc", "cn", "c", "hw", "nc", "cu", "onet", "phys", "cv", "vm", "sys"], "n": ["on", "na", "span", "ng", "o", "d", "m", "nn", "ln", "r", "y", "t", "b", "ot", "w", "nc", "nb", " N", "next", "nan", "network", "ren", "ni", "g", "note", "mn", "en", "fn", "node", "new", "conn", "count", "un", "z", "no", "number", "min", "names", "non", "k", " i", "ne", "nt", "nor", "l", "pos", "i", "in", "index", "N", "nr", "remote", "cn", "ns", "it", "nw", "out", "len", "num", "gn", "base", "nu", "p", "an", "np", "dn", "j", "wn", "v", "c", "h", "sn", "x", "name"]}}
{"project": "qemu", "commit_id": "7e55d65c56a03dcd2c5d7c49d37c5a74b55d4bd6", "target": 1, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 11328, "substitutes": {"s": ["sq", "rs", "p", "sp", "sts", "o", "f", "ps", "d", "m", "es", "sv", "ses", "i", "bs", "iss", "r", "is", "j", "S", "ss", "ts", "n", "t", "os", "sb", "e", "b", "c", "h", "ns", "fs", "ds", "sys"], "pdu": ["pcdu", "pcu", "dpdu", "wpbur", "pde", "ipde", "pclu", "plu", "pcdef", " psu", "pu", " puu", "pingbur", "dptu", "padu", " pbur", "dpsu", "palu", "psu", "puu", "iptu", " plu", "padef", "wpdu", "pau", "pingsu", "ptu", "wpuu", " pdef", "pbur", "wpsu", "pinguu", "ipsu", "pdef", "ipdu", " pde", " pu", "pingdu", " ptu", "dpde"], "fidp": ["fmidP", "flidphp", "faidnp", "cIdp", "fridnp", "flhotphp", "fardpad", "fIdg", "cidp", "faidpd", "cIdg", "lfidj", "foidp", "fmidg", "fridj", "fhotpa", "flidp", "foidpd", "fhotpad", "lfidpd", "fbidpa", "fIdp", "fadP", "flidpa", "fadg", "fbidpad", "fidnp", "cidg", "fidpy", "fadpy", "fridp", "lfaidnp", "lfaidpd", "fidpd", "cIdP", "fmidp", "fidpad", "lfidnp", "flidpad", "flhotpad", "fardpa", "flhotp", "fidj", "fIdpy", "fmidpy", "fardp", "lfaidj", "fhotp", "faidp", "faidj", "fIdP", "foidj", "fardphp", "fidP", "fidphp", "fbidphp", "flhotpa", "fbidp", "lfidp", "lfaidp", "foidnp", "cIdpy", "fidpa", "fadp", "fidg", "fhotphp", "cidpy", "cidP", "fridpd"], "off": ["shift", "on", "op", "Off", "reset", "empty", "bf", " offset", "et", "offer", "end", "ff", " Off", "over", "o", "buf", "ex", "offs", "dev", "pad", "ok", "OFF", "block", "pos", "fun", "ref", "attr", "after", "raw", "addr", "ext", "now", "t", "of", "new", "aux", "Offset", "cmd", "from", "start", " OFF", "set", "offset", "out"], "max_count": ["maxitymax", "maxptcount", " max_counter", "max_Count", "maxCount", "max_size", "maxingsum", "maxfulCount", " max_size", "maxingonly", "maxfulcount", "maxingcount", " max_ount", "maxingCount", "maxCcount", "max_sum", " max_Count", " max_max", "maxityCount", " max_only", "max_counter", "maxitysize", "max_ount", "maxitycounter", "maxfulonly", "maxityount", "max_only", "maxptmax", "maxCsize", " max_sum", "max_max", "maxfulsum", "maxptcounter", "maxitycount", "maxptCount"], "err": ["warn", "beta", "ah", "lr", "or", "alloc", " Err", "eor", "rr", "r", "margin", "fr", "cmd", "str", "elt", "fee", "fer", "result", "org", "rar", "hz", "size", "arr", "kr", "notice", "status", "cmp", "code", "buf", "ind", "iter", "aaa", "score", "cer", "gz", "ptr", "usr", "aer", "txt", "Er", "dy", "none", "try", "outer", "server", "js", "yr", "count", "conf", "e", "eas", "oe", "cr", "ier", "state", "norm", "hr", "errors", "ei", "order", "req", "css", "go", "resp", "error", "late", "type", "ered", "later", "mr", "trace", "probably", "plain", "die", "er", "diff", "rss", "peer", "timer", "len", "extra", "Error", "here", "erer", "addr", "core", "br", "cfg", "ctr", "res", "coord", "msg", "ner", "offset", "length", "dr", "sys"], "read_count": ["reading_cmd", "readCountc", "readptoffset", "reading_code", "read67count", "readable_count", "read_this", "readableCount", "read_cont", "error_count", "reading_count", "Read_count", "read00Count", "reading_offset", "read_c", "readitythis", "read_data", "readptcount", "readlencmd", "readablenot", "read_cmd", "read_not", "readitycounter", "readablelength", " read_length", "read_log", "read_counter", "user67count", "read_Count", "errorablecounter", "reading_rate", "readingptcount", "user_not", "readptlen", "readitycmd", "reading_data", "read_length", "user67len", "user_len", "read_time", "Read_cmd", " read_Count", "Read_Count", "read64data", "read_num", "user_count", "readable_length", "readityoffset", "readingptoffset", "error_counter", "readitylog", "error_log", "read00rate", "readptcmd", "readlenCount", "read_rate", "errorablecount", "readablecounter", "readitycount", "readingptcode", "readablelen", "errorablelog", "readablenum", "reading00data", "reading_Count", "reading00count", "readingptcmd", "read00count", "readptnum", "readablethis", "readitycode", "user67not", "reading00rate", "read_code", "readlencount", "readptcode", "readable_cont", " read_time", "read00data", "readCounttime", "read_len", " read_c", "user_num", "read67not", "read_offset", "readCountcount", "readptnot", "readablelog", "read64rate", "error_this", "user67num", "reading00Count", "readablecount", "read64count", "read67num", "errorablethis", "readabletime", "read64Count", "read67len"], "xattr_len": ["xatt_len", "xatt_size", "xattr_vec", "xatt_length", "xatt_vec", "xattribute_elt", "xattribute2Len", "xattr_length", "xattribute2len", "xattr_val", "xattr_size", "xattribute_val", "xatt_Len", "xattribute2elt", "xattr_Len", "xattribute_len", "xatt_val", "xattribute2val", "xattr2vec", "xattr2Len", "xattr2elt", "xattr_elt", "xattribute_Len", "xattr2len", "xattr2val"], "v": ["vs", "u", "va", "av", "q", "ov", "uv", "p", "o", "f", "d", "mint", "vp", "g", "m", "l", "sv", "i", "vt", "ver", "r", "volt", "j", "n", "y", "t", "V", "e", "b", "c", "h", "w", "x", "vr", "vm", "nv", "conv", "tv"], "elem": [" elev", "inelement", "selem", "notelement", "elems", " emm", " element", "seem", "semm", "sele", "notelem", "pemm", "nelement", "neem", "inelems", "nelem", "noteelement", "eem", "neelement", "belement", "element", "inelev", "pele", " elems", "pelem", "velement", "beelement", "ele", "eelement", "velev", "peem", "belem", "emm", "velem", "velems", " eem", " ele", "beem", "noteem", "elev", "inelem"]}}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n", "idx": 11334, "substitutes": {"bs": ["obs", "vs", "bf", "qs", "cks", "aos", "bp", "rs", "bas", "hs", "gs", "bl", "bes", "sts", "bc", "BS", "cs", "boxes", "bm", "outs", "bits", "bing", "iss", "uts", "aus", "js", "ss", "bos", "its", "ts", "lbs", "bps", "ubs", "ubis", "sb", "b", "bis", "bh", "bi", "ns", "fs", "bb", "blog", "ls", "ds"], "sector_num": ["sector_orig", "sectoritymon", " sector_index", " sector_orig", " sector_mon", "sector_mon", "sector_number", " sector_number", " sector_nb", "sectoritynb", "sectorityindex", "sectorityorig", "sectoritynumber", "sector_nb", "sectoritynum", "sector_index"], "buf": ["doc", "map", "buffer", "text", "uf", "aka", "rb", "err", "enc", "ff", "proc", "seq", "prop", "bin", "rw", "Buffer", "block", "vec", "cat", "ref", "cb", "tab", "raw", "window", "bytes", "queue", "mem", "data", "br", "box", "pb", "cap", "new", "b", "cmd", "Buff", "batch", "result", "buff", "msg", "pack", "cv", "img", "bag", "wb"], "nb_sectors": ["nb_beors", "nb_velements", "nb_begments", "nb_enseors", "nb_serers", "nb_sergments", "nb_seors", "nb_ensectors", "nb_serors", "nb_veors", "nb_pelements", "nb_pegments", "nb_selements", "nb_berers", "nb_serlements", "nb_ensegments", "nb_vectors", "nb_serctors", "nb_enserers", "nb_bectors", "nb_vegments", "nb_pectors", "nb_segments", "nb_peors", "nb_verers"], "ret": ["ert", "len", "tr", "status", "flag", "rs", "print", "det", "RET", "resp", "f", "nt", "rev", "l", "ref", "inter", " alt", "txt", "ern", "alt", "ter", "ext", "r", "cont", "ts", "t", "rem", "rets", "gc", "val", "Ret", "xt", "rt", "re", "res", "result", "set", "gt", "ll", " fut", "ft", "out", "mt"], "s": ["ms", "sq", "spec", "sl", "qs", "a", "ats", "rs", "sp", "gs", "sts", "ps", " ss", "ess", "g", "cs", "ins", "ses", "sam", "iss", "is", "js", "less", "S", "ss", "ts", "its", "als", "j", "conf", "os", "bis", "h", "ns", "stats", "w", "fs", "serv", "sis", "ls", "ims", "ds", "sys"]}}
{"project": "qemu", "commit_id": "968fc24d843c9e9b24231ca1960b47ef2fc724ea", "target": 1, "func": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,\n\n                         uint8_t *dst, int dlen)\n\n{\n\n    uint32_t zrun_len = 0, nzrun_len = 0;\n\n    int d = 0, i = 0;\n\n    long res, xor;\n\n    uint8_t *nzrun_start = NULL;\n\n\n\n    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %\n\n               sizeof(long)));\n\n\n\n    while (i < slen) {\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] == new_buf[i]) {\n\n            zrun_len++;\n\n            i++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed */\n\n        if (!res) {\n\n            while (i < slen &&\n\n                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {\n\n                i += sizeof(long);\n\n                zrun_len += sizeof(long);\n\n            }\n\n\n\n            /* go over the rest */\n\n            while (i < slen && old_buf[i] == new_buf[i]) {\n\n                zrun_len++;\n\n                i++;\n\n            }\n\n        }\n\n\n\n        /* buffer unchanged */\n\n        if (zrun_len == slen) {\n\n            return 0;\n\n        }\n\n\n\n        /* skip last zero run */\n\n        if (i == slen) {\n\n            return d;\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, zrun_len);\n\n\n\n        zrun_len = 0;\n\n        nzrun_start = new_buf + i;\n\n\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] != new_buf[i]) {\n\n            i++;\n\n            nzrun_len++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed, use of 32-bit long okay */\n\n        if (!res) {\n\n            /* truncation to 32-bit long okay */\n\n            long mask = (long)0x0101010101010101ULL;\n\n            while (i < slen) {\n\n                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);\n\n                if ((xor - mask) & ~xor & (mask << 7)) {\n\n                    /* found the end of an nzrun within the current long */\n\n                    while (old_buf[i] != new_buf[i]) {\n\n                        nzrun_len++;\n\n                        i++;\n\n                    }\n\n                    break;\n\n                } else {\n\n                    i += sizeof(long);\n\n                    nzrun_len += sizeof(long);\n\n                }\n\n            }\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, nzrun_len);\n\n        /* overflow */\n\n        if (d + nzrun_len > dlen) {\n\n            return -1;\n\n        }\n\n        memcpy(dst + d, nzrun_start, nzrun_len);\n\n        d += nzrun_len;\n\n        nzrun_len = 0;\n\n    }\n\n\n\n    return d;\n\n}\n", "idx": 11359, "substitutes": {"old_buf": ["func", " old_buffer", "old_vec", "olditybuff", "olditybuf", "old_uf", "old_buffer", "oldityrb", "oldJbin", "old_arr", " old_buff", "old_bin", "new_rb", "bool", "bl", "new_vec", "old__vec", "new_bin", " old_arr", "new_msg", "old__queue", "new_batch", "old_pool", "olditybuffer", "_", "old_queue", "oldJbuf", "new_buffer", "old_buff", "oldJbuffer", "old_batch", "old_rb", "old__buffer", " old_pool", "new_queue", "old__buf", "oldJqueue", "oldJbatch", "new_buff", "old_msg", " old_uf"], "new_buf": ["newgrqueue", "new_cv", "new___buff", "old_data", " new_queue", " new_buffer", "old_vec", "old_uf", "old_buffer", "new_uf", "old_bin", "new___data", "new___buffer", "new_vec", " new_buff", "new___Buff", "new_bin", "re_cache", "re_buf", "newptbuf", "new_cache", "new___vec", "newgrbuffer", "re_buff", "newptdoc", "old_cv", "newptqueue", "newptbuffer", "newptcache", "old_Buff", "new_data", "new_doc", "new___buf", "new_Buff", "newgrbuf", "newgrbuff", "new_buffer", "old_buff", "new___bin", "new_queue", "re_queue", " new_doc", "new_buff", "newptbuff"], "slen": ["Slang", "mlen", "klen", " slens", "Slem", "Slenum", "SLoen", "SLength", "islang", "splatten", "kllen", "shem", "Slen", "splend", "shent", "mlent", "sslend", "slEN", "slength", "spleng", "islenum", "Slatten", "ssllen", "leng", "Slun", "klatten", "selatten", "mlatten", "SlEN", "sleng", "slan", "sslan", "SLatten", "slun", "isleng", "shang", "islens", "SLens", "splength", "splens", "scheoen", "loen", "islem", "splEN", "SLEN", "splen", "sslem", "shatten", "sslatten", "shenum", "sslens", "selens", "sloen", "islen", "slent", "slang", "sllen", "Sllen", "splem", " slength", "latten", "slend", "sploen", "SLeng", "splan", "slenum", "len", "selen", "mlun", "shun", "ssleng", "shend", "klEN", "seloen", "scheatten", "sslen", "SLen", "shen", "shan", "scheen", "Slend", "shoen", "isloen", " slEN", "slem", "ssloen", "slatten", "slens", "scheens", "sslEN", "Slent", "islatten"], "dst": ["dsts", "dnd", "Dsts", "sdsts", "sdnd", " dest", "Dst", "ddest", "newbr", "dST", "newST", "dest", " dnd", "Dnd", "newst", "sdST", "sdest", "sddest", "sdst", "Ddest", " ddest", "Dest", "DST", "dbr", "Dbr", "newsts", "sdbr"], "dlen": ["dfl", "DLen", "Dcmp", "endLen", " dLen", " dlength", "dlength", "rcmp", "xcmp", "Dlength", "dcmp", "xLen", "nlen", "endfl", "rlen", "xlen", "nLen", "rLen", "nlength", " dfl", "Dlen", "nsl", "xlength", "hLen", "hsl", "rlength", "dLen", " dsl", "hlength", "Dfl", "endlen", "hlen", "dsl"], "res": ["ms", "vs", "reset", "d", "m", "cs", "bits", "ins", "progress", "details", "r", "successful", "rem", "os", "has", "times", "reed", "result", "pre", "vol", "arr", "status", "resource", "init", "ri", "rev", "yes", "ver", "clean", "rel", "js", "cond", "final", "new", "vals", " Res", "resources", " residual", "id", "prime", "req", "rs", "err", "resp", "gr", "ref", "def", "confirmed", "mask", "RES", "chain", "reg", "remote", "red", "results", "ns", "rest", "resh", "nil", "out", "ret", "windows", "cons", "fresh", "success", " RES", "sol", "resolution", "base", "p", "Res", "ps", "us", "expr", "pres", "j", "ress", "val", "re", " compress", "rez", "max", "dr", "sys"], "xor": ["zor", "xors", "xxori", "axori", "xxor", "ixmor", "ixore", " xors", "ixor", "zore", "axor", "xmor", "wxorer", "axorm", "zOR", "xore", " xorer", "ixOR", " xorm", " Xore", " xOR", "xorm", "wxOR", "axOR", "xorer", " xore", " Xors", "wxor", "xori", "rxOR", "zmor", " xmor", " Xor", "xxorm", "rxore", " Xorer", "xOR", " xori", "xxOR", "rxor", "rxors", "wxore", "wxors"], "nzrun_start": ["nzRun_size", "nzrun_begin", "nzRun_end", "nzrunptbegin", "nzrunptsize", "nzrunptstart", "nzrun_end", "nzRun_len", "nzrunptend", "nzRun_begin", "nzrun_size", "nzrunptlen", "nzRun_start"], "i": ["ami", "id", "ai", "fi", "I", "io", "me", "ie", "li", "ei", "uri", "init", "ri", "p", "o", "iri", "ind", "ui", "iter", "d", "iat", "ip", "m", "l", "ki", "ti", "ic", "ia", "cli", "in", "mi", "index", "is", "j", "im", "ix", "ma", "n", "y", "iu", "ci", "t", "\u0438", "phi", "zi", "info", "xi", "qi", "multi", "b", "c", "h", "gi", "di", "bi", "iii", "ij", "si", "pi", "it", "x", "ini", "item", "oi", "hi", "s", "ji", "ims", "ori", "ii"], "zrun_len": ["zrunner_dl", "zrun0len", "zrun_buf", "zrun0loc", "zrunptln", "zrun_num", "zran_compl", "zran_Len", "zrun__limit", "zrun_ln", "zrunnerxloc", "zrunnerxlen", "zrunptnum", "zrun_Len", "zrunxloc", "zrunxdl", "zrun67elt", "zrunner_loc", "zrunner_start", "zran_ln", "zrunner_len", "zrunptLen", "zrun_limit", "zrun_val", "zrun67Len", "zrun_compl", "zrun__ln", "zrun0dl", "zran_num", "zran_limit", "zrun_dl", "zrun_set", "zrunnerxstart", "zrun_start", "zrun__compl", "zrun_elt", "zrun_loc", "zrunnerxdl", "zrun_la", "zrunptlen", "zrunxlen", "zrun67la", "zrunxstart", "zrun0start", "zrun__len", "zrun67len", "zran_len"], "nzrun_len": ["nzrun2len", "nzru_mem", "nzru_len", "nzname_buf", "nzrun_lim", "nzrun_Len", "nzrun_mem", "nzrun_buf", "nzname_gen", "nzname_len", "nzrun2gen", "nzname_num", "nzrun2num", "nzrun2buf", "nzrun_num", "nzrun_gen", "nzru_Len", "nzru_lim"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static av_cold void init_atrac3_transforms(ATRAC3Context *q) {\n\n    float enc_window[256];\n\n    int i;\n\n\n\n    /* Generate the mdct window, for details see\n\n     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */\n\n    for (i=0 ; i<256; i++)\n\n        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;\n\n\n\n    if (!mdct_window[0])\n\n        for (i=0 ; i<256; i++) {\n\n            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);\n\n            mdct_window[511-i] = mdct_window[i];\n\n        }\n\n\n\n    /* Initialize the MDCT transform. */\n\n    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);\n\n}\n", "idx": 11361, "substitutes": {"q": ["sq", "ck", "eq", "tx", "u", "qq", "qs", "Q", "iq", "p", "o", "f", "g", "cc", "qa", "qt", "dq", "t", "qu", "rc", "v", "qi", "query", "h", "w", "x", "z", "cv"], "enc_window": ["validallheight", "enc_stack", "validalldevice", "enc12windows", "enc8height", "encallwindow", "encallheight", "enc___windows", "enc_windows", "enc8window", "enc_vector", "enc12tree", "enc2buffer", "enc_device", "ENC_stack", "enc7window", "enc8device", "enc2device", "enc___stack", "encallstorage", "encalldevice", "valid_storage", "enc___device", "enc_height", "valid_device", "ec_stack", " enc_win", "ec_width", "ec_table", " enc_data", "ENC_buffer", "enc_profile", "enc_data", "enc12data", "enc___window", "enc___width", "enc2window", "ec_profile", "enc_table", "enc12window", "enc7vector", "enc8storage", "enc___storage", "enc_storage", "enc7table", "ec_buffer", "enc_width", "ENC_device", "enc_buffer", "valid_window", "enc_win", "enc2stack", "enc_tree", "enc7stack", "ENC_window", "enc___buffer", "ec_window", "enc___height", "valid_height", "ec_windows", "validallstorage", "validallwindow", " enc_tree", " enc_windows", "ec_vector"], "i": ["u", "print", "o", "m", "im", "y", "t", "ci", "zi", "gi", "pi", "oi", "hi", "ji", "ims", "key", "ami", "status", "I", "at", "source", "li", "uri", "ri", "ex", "ind", "g", "jp", "ki", "ti", " ti", "mi", "try", "ix", "one", " ki", "xi", "e", "multi", "qi", "si", "id", "ai", "ei", "err", "point", "f", " li", "ui", "ip", "l", "es", "ic", "in", "index", "chain", "like", "\u0438", "phi", "info", "it", "ini", " bi", "s", "ii", "fi", "me", "io", " I", "to", "p", "sim", "client", "cli", "us", "is", "j", "iu", "v", "ik", "h", "bi", "di", "x", " ii", " j", "dr", "ij"]}}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_resize(DisplayChangeListener *dcl,\n\n                      DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    cairo_format_t kind;\n\n    int stride;\n\n\n\n    DPRINTF(\"resize(width=%d, height=%d)\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n", "idx": 11368, "substitutes": {"dcl": ["dnCL", "dsc", "dfl", "defl", " dsc", "dnfl", "dCL", "decl", "desc", "dncl", " dfl", "deCL", " dCL", "dnsc"], "ds": ["ods", "vs", "dos", "dd", "ists", "qs", "ats", "eps", "DS", "rs", "hs", "dies", "gs", "sts", "dev", "ps", "ants", "ld", "da", "d", "dx", "ysis", "cs", "pd", "def", "hd", "args", "desc", "xs", "bs", "Ds", "md", "qt", "ys", "js", "asi", "ss", "ts", "its", "dq", "dl", "vd", "irs", "rets", "dds", "ads", "ops", "os", "der", "iris", "ims", "cmd", "uds", "ns", "des", "ows", "sta", "dat", "ks", "dp", "db", "ls", "tes", "edes", "sd", "dt", "eds", "sys"], "s": ["ms", "vs", "ats", "hs", "d", "ysis", "cs", "m", "ins", "details", "se", "t", "os", "b", "sa", "w", "comm", "ims", "eds", "ports", "gets", "gs", "sts", "changes", "g", "ies", "sv", "ses", "sam", "bs", "services", "plays", "less", "js", "als", "ss", "conf", "ops", "sb", "z", "ls", "sq", "obj", "spec", "sl", "qs", "a", "rs", "as", "l", "i", "terms", "store", "ts", "n", "styles", "sw", "ns", "eps", "q", "p", "ps", "south", "so", "is", "j", "S", "its", "v", "c", "h", "stats", "fs", "set", "sys", "parts"], "kind": ["key", "method", "brand", "kg", "id", "spec", "what", "part", "kick", "stuff", "sch", "k", "func", "kt", "ind", "kid", "reason", " kinds", "instance", "pkg", "need", "type", "def", "smart", "desc", " Kind", "family", "pick", "index", "dk", "magic", "data", "needed", "interface", "like", "mode", "info", "dir", "metadata", "mk", "shape", "ke", "cmd", "from", "division", "str", "nick", "kw", "school", "tag", "kernel", "choice", "font", "rank", "context", "Kind", "cost", "sk", "name", "work", "style"], "stride": ["brider", "strue", " strride", " strape", "divride", "strine", "charride", "striope", "slide", " strider", "slue", "trider", "charides", "tride", "strride", "true", "divider", "bride", "striride", "strider", " strope", "strope", " strides", "striide", "brine", "charope", "charide", "slape", "striides", "sline", "divide", "brue", "strape", "slride", "divape", "slider", "trine", "strides"], "req": ["sq", "eq", "require", "qq", " q", "quire", "crit", "q", "err", "iq", "resp", "seq", "ind", " requ", "ps", "gr", "pkg", "jp", "ref", "wx", "request", "desc", "tab", "rr", "urg", "usr", "expr", "Requ", "qt", "r", "mem", " fr", "j", "cond", "needed", "dq", "aux", "ctx", "esp", "fr", "good", "ctr", " resp", "cmd", "fy", "rt", "dist", "res", "requ", "msg", "rez", "quest", " gr", "required"], "sx": ["lfx", "six", " spx", "Spx", "rsy", " sxd", " sfx", "desx", "atspx", "spx", "insz", "lix", "ssy", "rsrx", "svx", "svpx", "lx", "rsx", "Sx", "insy", "sxd", "insrx", "svxd", "Sfx", "ssrx", "sfx", "atsx", "rsz", "atsix", "sz", "desix", " six", "lpx", "svfx", "desfx", "insx", "ssz", "srx", "svix", "Six", "atsxd", "despx", "ssx"], "sy": ["sche", "sym", "py", "san", "na", "fi", "sky", "mx", "ty", "pse", "cy", "ady", "wy", "yy", "Sy", "sm", "south", "ry", "SY", "cs", "psy", "nn", "shell", "dy", "ln", "ys", "sid", "ss", "se", "y", "icy", "sat", "she", "asy", "sf", "pha", "ey", "tsy", "sty", "sb", "ly", "ery", "uy", "fy", "sa", "si", "ony", "ny", "syn", "sys"]}}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)\n\n{\n\n    LM32JuartState *s = LM32_JUART(d);\n\n    unsigned char ch = jtx & 0xff;\n\n\n\n    trace_lm32_juart_set_jtx(s->jtx);\n\n\n\n    s->jtx = jtx;\n\n    if (s->chr) {\n\n\n\n        qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n    }\n\n}", "idx": 11381, "substitutes": {"d": ["dd", "p", "o", "dev", "f", "da", "dx", "g", "del", "m", "l", "i", "D", "dn", "r", "md", "j", "de", "data", "done", "n", "y", "t", "v", "e", "b", "c", "h", "di", "dat", "w", "x", "z", "dm", "sd", "dt", "ds", "dr"], "jtx": ["jty", "qx", "jjta", "jjtr", " jti", "dtr", "dtx", "dti", "jfx", "jti", " jfx", "jtxt", "jx", "jjx", "jjtrans", "ujx", "jjtx", "Jty", "gtrans", "Jtxt", " jty", "qty", " jtr", "jta", "gtx", "qtxt", "ujtx", "gtext", " jx", "Jtx", " jtrans", "Jtrans", "jtext", " jtext", "jtr", "jjti", "ujtrans", "jtrans", "jjty", " jtxt", "dta", "Jtext", "ujty", "qtx", "Jx", " jta", "Jfx", "gfx"], "s": ["ms", "sq", "vs", "spec", "sl", "qs", "source", "sol", "ats", "rs", "hs", "p", "gs", "sts", "ex", "ps", " ss", "ess", "cs", "ins", "sv", "es", "ses", "sam", "bs", "iss", "sand", "less", "js", "als", "S", "ss", "ts", "is", "se", "has", "sb", "b", "c", "bis", "sw", "h", "ns", "stats", "fs", "set", "sis", "comm", "ls", "states", "ds", "sys", "store"]}}
{"project": "FFmpeg", "commit_id": "3df2be9fa7365646f22a93cfde1e4097467f498e", "target": 1, "func": "static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n\n                                    AVPacket *pkt, uint64_t display_duration)\n\n{\n\n    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',')\n\n        layer = ++ptr;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',') {\n\n        int64_t end_pts = pkt->pts + display_duration;\n\n        int sc = matroska->time_scale * pkt->pts / 10000000;\n\n        int ec = matroska->time_scale * end_pts  / 10000000;\n\n        int sh, sm, ss, eh, em, es, len;\n\n        sh = sc/360000;  sc -= 360000*sh;\n\n        sm = sc/  6000;  sc -=   6000*sm;\n\n        ss = sc/   100;  sc -=    100*ss;\n\n        eh = ec/360000;  ec -= 360000*eh;\n\n        em = ec/  6000;  ec -=   6000*em;\n\n        es = ec/   100;  ec -=    100*es;\n\n        *ptr++ = '\\0';\n\n        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;\n\n        if (!(line = av_malloc(len)))\n\n            return;\n\n        snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\",\n\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);\n\n        av_free(pkt->data);\n\n        pkt->data = line;\n\n        pkt->size = strlen(line);\n\n    }\n\n}\n", "idx": 11383, "substitutes": {"matroska": ["matroa", " matrosa", "matrosko", "matraska", "matrosha", "matroha", "macrosha", "matrisa", "macroska", " matrasko", " matrosha", "matrotsko", "matrosky", "matrotsaka", "matrosa", "matroky", "matriska", "matrisaka", "matrosaka", "macroaka", "matrisha", "matrotska", "macrosky", "matroaka", "matrasa", "matroko", "macroky", " matrasha", "macroka", "matrisky", "matroka", " matrasa", "matrisko", "macroha", " matrosko", "matrasko", "macrosko", "matrotsha", "macroko", "matrasky", "macrosaka", "matrasha", " matraska"], "pkt": [" packet", "opconn", "paix", "pant", "pnt", "ppnt", "prent", "prekg", "cpacket", "Pnt", "ppkt", "ppet", "twk", " pkg", "cpnt", "Pkt", "pkg", "Pct", "opnt", "tnt", "cpet", "Pck", "prekt", "tkt", "opacket", "opkt", " pnt", "preacket", "tet", "tacket", "pconn", " pck", " pet", "pck", " pconn", "packet", "pakt", " pct", "Pix", "pwk", "ppacket", "cpwk", "Pconn", "cpkt", "paacket", " pwk", "pix", "Packet", "pet", "pact", " pix", "Pwk", "pct", "pack", "Pet", "tkg"], "display_duration": ["play_runtime", "display_Duration", " display2length", " display2status", "display2Duration", " display_Duration", "displayutionposition", "display2status", "display2length", "displayutionDuration", "displayutionruntime", "play_duration", "display2duration", "play_position", " display_status", "displayutionduration", " display_length", " display2duration", "displayutionstatus", "display_length", "display_status", "displayutionlength", " display2Duration", "display_position", "display_runtime"], "line": ["lin", "dd", "pe", "nl", "call", "path", "code", "text", "buffer", "base", "train", "cell", "list", "Line", "cl", "frame", "lines", "iter", "eline", "cat", "label", "block", "l", "detail", "word", "ine", "ln", "row", "data", "se", "header", "n", "fr", "lock", "query", "cmd", "comment", "str", "link", "LINE", "lay", "ide", "user", "el", "lo", "le", "liner", "out", "mt"], "layer": ["depth", "id", "pc", "part", "ayer", "buffer", "lvl", "section", "device", "padding", "channel", "source", "lr", "loc", "lan", "file", "kt", "field", "pair", "ld", "tile", "lv", "size", "label", "block", "l", "vel", "type", "hl", "lp", "ayers", "ln", "wl", "level", "kl", "header", "pen", "lc", "tag", "lay", "batch", "Layer", "name", "dt", "offset", "length"], "ptr": ["warn", "lr", "print", "proc", "rep", "attr", "hl", "desc", "row", "rd", "deg", "fr", "pr", "pl", "rect", "cmd", "elt", "str", "pert", "arr", "depth", "tr", "next", "address", "tp", "sp", "buf", "ind", "iter", "sec", "jp", "pend", "try", "rel", "ix", "dq", "pen", "dig", "Ptr", "debug", "pod", "src", "obj", "hr", "prime", "pc", "nl", "buffer", "pt", "err", "point", "inters", "ld", "th", "push", "cur", "pos", "ref", "inter", "trace", " pointer", "dep", "assert", "dra", "forth", "ts", "kl", "der", "offset", "peer", "vr", "iv", "loc", "off", "pointer", "begin", "p", "pair", "pad", "fp", "pointers", "port", "lp", "adr", "addr", "expr", "cont", "pers", "br", "ctr", "eth", "tip", "coord", "DEP", "inst", "length", "dr"], "end": ["fin", "empty", "entry", "send", "add", "endif", "begin", "ff", "END", "dev", "pad", "End", "iter", "eng", "stop", "ep", "win", "ended", "window", "en", "pend", "edge", "rend", "all", "ell", "ext", "bound", "dest", "last", "ad", "ending", "e", "mid", "hend", "est", "start", "rest", "ent", "set", "head", "max", "nd", "ender", "append"], "sh": ["ksh", "shift", "sq", "ph", "sl", "ssh", "ch", "osh", "sch", "hs", "sp", "cl", "igh", "th", "cs", "sv", "hl", "Sh", "shr", "bs", "cc", "ish", "hel", "se", "sha", "zh", "sw", "h", "kh", "sn", "sy", "hw", "esh", "ih", "sr", "si", "sc", "x", "z", "resh", "SH", "ls", "s", "sd", "size", "sk"], "sm": ["ms", "hem", "tm", "sym", "sl", "ch", "gm", "sch", "sp", "sim", "mg", "m", "esm", "cs", "sv", "SM", "sam", "mn", "arm", "mem", "mi", "md", "mph", "mc", "sb", "ims", "sw", "ism", "ym", "sn", "sa", "sem", "sbm", "sy", "sr", "si", "sc", "rm", "dm", "s", "mp", "sd", "sk", "mt"], "ss": ["ms", "sq", "vs", "mes", "sl", "ssh", "pse", "css", "sch", "rs", "sp", "ass", "sim", "ess", "cs", "sv", "bs", "cc", "iss", "ys", "js", "se", "SS", "ness", "ress", "sw", "ism", "sn", "sy", "sem", "sa", "sr", "est", "ns", "si", "sc", "rss", "ls", "s", "oss", "sd", "ds", "sys"], "eh": ["uth", "hem", "ef", "he", "ph", "ah", "hr", "me", "ch", "ei", "sch", "eman", "ev", "Oh", "oen", "ec", "ach", "igh", "eng", "eor", "ep", "hl", "her", "ea", "oh", "en", "drm", "arm", "ern", "expr", "mem", "eg", "hp", "erm", "eb", "e", "ears", "der", "h", "eth", "kh", "exec", "eric", "oe", "ih", "er", "ech", "resh", "ek", "lem"], "em": ["hem", "mes", "et", "me", "ch", "pse", "ev", "ec", "ex", "eng", "ess", "esm", "ems", "um", "mn", "emin", "en", "ell", "arm", "iem", "mem", "mi", "eg", "emi", "pm", "tem", "im", "erm", "ema", "EM", "e", "ism", "ym", "sem", "om", "eme", "er", "imm", "el", "mp", "emp", "lem"], "es": ["ES", "mes", "et", "ats", "eps", "css", "els", "ec", "bes", "ex", "ps", "Es", "ess", "cs", "ese", "esm", "exe", "ems", "ies", "ses", "emin", "en", "eg", "is", "als", "ales", "nes", "enes", "se", "js", "ele", "esp", "xes", "rees", "e", "ed", "ets", "ns", "des", "eds", "eu", "er", "ests", "ces", "ees", "ls", "s", "tes", "ens", "ers", "eks"], "len": ["ml", "fin", "fd", "sl", "nl", "fl", "lan", "li", "Len", "err", "sp", "cl", "ne", "yn", "ld", "nt", "vec", "l", "vel", "pos", "lf", "length", "le", "lp", "ell", "en", "mem", "ln", "wl", "kl", "n", "dl", "mil", "lc", "pl", "val", "offset", "elt", "str", "fc", "L", "ls", "el", "ll", "loc", "syn", "size"]}}
{"project": "qemu", "commit_id": "2a0c46da967e5dc8cfe73b1b6fe7a1600c04f461", "target": 0, "func": "send_msg(\n\n    VSCMsgType type,\n\n    uint32_t reader_id,\n\n    const void *msg,\n\n    unsigned int length\n\n) {\n\n    VSCMsgHeader mhHeader;\n\n\n\n    qemu_mutex_lock(&socket_to_send_lock);\n\n\n\n    if (verbose > 10) {\n\n        printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\",\n\n               type, reader_id, length, length);\n\n    }\n\n\n\n    mhHeader.type = htonl(type);\n\n    mhHeader.reader_id = 0;\n\n    mhHeader.length = htonl(length);\n\n    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));\n\n    g_byte_array_append(socket_to_send, (guint8 *)msg, length);\n\n    g_idle_add(socket_prepare_sending, NULL);\n\n\n\n    qemu_mutex_unlock(&socket_to_send_lock);\n\n\n\n    return 0;\n\n}\n", "idx": 11400, "substitutes": {"type": ["command", "key", "id", "typ", "spec", "address", "status", "pe", "tp", "ty", "buffer", "message", "source", "format", "ping", "event", "role", "types", "file", "p", "value", "error", "size", "TYPE", "scope", "ico", "year", "sequence", "position", "length", "kind", "ver", "family", "index", "Type", "test", "version", "y", "total", "t", "sort", "info", "ype", "class", "shape", "otype", "title", "rule", "tag", "link", "game", "time", "name", "state", "style", "number"], "reader_id": ["writer_seq", "reader___info", "writer_id", "reader_pid", "reader___pid", "reader_seq", " reader_info", "reader_ids", "reader___ids", "reader_side", "reader____seq", "reader2id", "writer_ids", "writer_side", "reader___id", "reader_Id", " reader_Id", "reader____id", "reader____ids", "reader2Id", " reader_ids", " reader_pid", "reader_info", "reader____side", "reader2ids"], "msg": ["ms", "doc", "id", "send", "text", "message", "gm", "q", "event", "p", "gs", "buf", "seq", "frame", "mg", "g", "pkg", "m", "gz", "Msg", "args", "raw", "bytes", "txt", "mem", "md", "data", "body", "t", "v", "b", "cmd", "og", "str", "batch", "get", "mess", "out"], "mhHeader": [" mvNumber", "mhTree", "smihHeader", "mhType", " mhtheader", "mhdHeader", "smhHeader", "mohContent", "mhtField", "mwHead", "mhpColumn", "mhrContent", "mhtHeader", "smhBody", "mHHeader", " mwHead", " mhtHeader", "mihLine", "mwOwner", "mhdNumber", "mzField", "mohHeader", "mHNumber", "mhtheader", "mahHeader", " mhheader", "mzHead", "mhmHeader", " mwOwner", "mhLine", "mahLine", " mhType", " mhField", " mhHead", "mhrType", "mohType", "mHComment", " mhtHead", "mhdheader", " mhColumn", "mhdField", " mvComment", "mohOwner", "smihLine", "mihHeader", "mhComment", " mhTree", "mvHeader", "mvNumber", "mohTree", "mwTree", "mhOwner", " mhComment", "mhContent", "mhdTree", "mhmLine", "mihBody", "mhheader", " mwTree", "mvComment", "mhrHeader", "mzheader", " mwContent", "mhtHead", "mahColumn", "mohHead", " mhLine", "mhrHead", " mvHead", "mwHeader", " mhOwner", "smihBody", "mhField", "mhdHead", " mwHeader", " mhNumber", "mhpHeader", " mhContent", "mwContent", "mhBody", "mzHeader", " mwType", "mHHead", "mhHead", "mahHead", "mhmBody", "mwType", " mvHeader", "mhdComment", "mhNumber", " mhtField", "mhpHead", "mhColumn", "mhdOwner", "mhpLine", "smhLine", "mvHead"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){\n\n    int i, j;\n\n    int dc = (((dctcoef*)block)[0] + 32) >> 6;\n\n    pixel *dst = (pixel*)_dst;\n\n    stride >>= sizeof(pixel)-1;\n\n    for( j = 0; j < 4; j++ )\n\n    {\n\n        for( i = 0; i < 4; i++ )\n\n            dst[i] = av_clip_pixel( dst[i] + dc );\n\n        dst += stride;\n\n    }\n\n}\n", "idx": 11423, "substitutes": {"_dst": ["_daest", "_daST", " _Ddest", "___idct", "_fbr", " _Dst", "_fst", "_idct", " _DST", "_Dsrc", "_fsrc", "_dST", " _ddest", "_DST", "_dsrc", " _Dest", "_dast", "_dest", "_dct", "_Dct", "___dst", "_idsrc", "___dbr", "___idsrc", "_fct", "_idbr", "___dsrc", "_ddest", "_dadest", "_dbr", "___dct", " _dest", "___idbr", "___idst", "_Dbr", "_idst", "_Dest", "_Dst", " _dST", "_Ddest"], "block": ["lib", "sync", "map", "part", "config", "buffer", "blocks", "channel", "device", "image", "proc", "hash", "bl", "cl", "field", "bin", "frame", "label", "ref", "type", "object", "pixel", "word", "mask", "filter", "Block", "chain", "row", "box", "check", "line", "lock", "load", "link", "group", "pack", "BL", "byte"], "stride": ["specend", " strride", "strime", "stice", "stime", "relope", "stend", "stides", "relategy", "strride", "Strope", "STRide", "strade", " strend", "specade", " strope", "STRope", "Strice", "strope", "STRime", "relide", "relice", "strend", "specides", " strade", "specide", " strides", "strice", "Stride", "stategy", "stade", " strime", "stope", "strategy", "STRride", "stide", "Strategy", "strides"], "i": ["ami", "id", "u", "ai", "I", "at", "ie", "me", "li", "io", "PI", "q", "uri", "iq", "ri", "p", "ii", "o", "f", "ex", "ind", "point", "ui", "iter", "sim", "ip", "g", "m", "l", "my", "ki", "ti", "ic", "ia", "ish", "in", "mi", "index", "is", "chain", "im", "ix", "y", "iu", "ci", "\u0438", "zi", "v", "ik", "xi", "qi", "multi", "b", "c", "h", "gi", "di", "bi", "iy", "pi", "si", "it", "x", "ini", "ji", "ij"], "j": ["obj", "bj", "ge", "aj", "ja", "jump", "J", "jc", "at", "jo", "q", "init", "k", "p", "ii", "o", "f", "jit", "sim", "ind", "job", "ne", "Ja", "g", "jp", "l", "m", "bs", "json", "jj", "r", "try", "js", "uj", "im", "br", "n", "t", "jl", "v", "fr", "bo", "pr", "b", "c", "bi", "oj", "it", "x", "z", "dj", "s", "ji", "jack", "kj", "ij"], "dst": [" dost", "dsts", "dessts", "desdest", "Dsts", "desst", "drast", "idbr", " dict", "Dst", "dpr", " dsts", "ldst", "dbl", "ddest", "idict", "drabr", "Dict", " dout", " dST", "ldpr", "dST", " dbl", "Dout", "dobl", "idst", "lddest", "dout", "sdST", "Dbl", " dbr", "draost", "idout", "ldsts", " dpr", "sdst", "despr", "sdost", " ddest", "dosts", "draST", "dbr", "dost", "Dbr", "dict", "dobr", "sdbr"]}}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt,\n\n                             const AVFrame *pict, int *got_packet)\n\n{\n\n    const AVFrame *const p = pict;\n\n    const int near         = avctx->prediction_method;\n\n    PutBitContext pb, pb2;\n\n    GetBitContext gb;\n\n    uint8_t *buf2 = NULL;\n\n    uint8_t *zero = NULL;\n\n    uint8_t *cur  = NULL;\n\n    uint8_t *last = NULL;\n\n    JLSState *state;\n\n    int i, size, ret;\n\n    int comps;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n\n        avctx->pix_fmt == AV_PIX_FMT_GRAY16)\n\n        comps = 1;\n\n    else\n\n        comps = 3;\n\n\n\n    if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 +\n\n                               AV_INPUT_BUFFER_MIN_SIZE)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    buf2 = av_malloc(pkt->size);\n\n    if (!buf2)\n\n        goto memfail;\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n    init_put_bits(&pb2, buf2, pkt->size);\n\n\n\n    /* write our own JPEG header, can't use mjpeg_picture_header */\n\n    put_marker(&pb, SOI);\n\n    put_marker(&pb, SOF48);\n\n    put_bits(&pb, 16, 8 + comps * 3); // header size depends on components\n\n    put_bits(&pb, 8, (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8);  // bpp\n\n    put_bits(&pb, 16, avctx->height);\n\n    put_bits(&pb, 16, avctx->width);\n\n    put_bits(&pb, 8, comps);          // components\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);     // component ID\n\n        put_bits(&pb, 8, 0x11);  // subsampling: none\n\n        put_bits(&pb, 8, 0);     // Tiq, used by JPEG-LS ext\n\n    }\n\n\n\n    put_marker(&pb, SOS);\n\n    put_bits(&pb, 16, 6 + comps * 2);\n\n    put_bits(&pb, 8, comps);\n\n    for (i = 1; i <= comps; i++) {\n\n        put_bits(&pb, 8, i);   // component ID\n\n        put_bits(&pb, 8, 0);   // mapping index: none\n\n    }\n\n    put_bits(&pb, 8, near);\n\n    put_bits(&pb, 8, (comps > 1) ? 1 : 0);  // interleaving: 0 - plane, 1 - line\n\n    put_bits(&pb, 8, 0);  // point transform: none\n\n\n\n    state = av_mallocz(sizeof(JLSState));\n\n    if (!state)\n\n        goto memfail;\n\n\n\n    /* initialize JPEG-LS state from JPEG parameters */\n\n    state->near = near;\n\n    state->bpp  = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8;\n\n    ff_jpegls_reset_coding_parameters(state, 0);\n\n    ff_jpegls_init_state(state);\n\n\n\n    ls_store_lse(state, &pb);\n\n\n\n    zero = last = av_mallocz(p->linesize[0]);\n\n    if (!zero)\n\n        goto memfail;\n\n\n\n    cur  = p->data[0];\n\n    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 8);\n\n            t    = last[0];\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_GRAY16) {\n\n        int t = 0;\n\n\n\n        for (i = 0; i < avctx->height; i++) {\n\n            ls_encode_line(state, &pb2, last, cur, t, avctx->width, 1, 0, 16);\n\n            t    = *((uint16_t *)last);\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 0; j < 3; j++) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    } else if (avctx->pix_fmt == AV_PIX_FMT_BGR24) {\n\n        int j, width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 2; j >= 0; j--) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    }\n\n\n\n    av_freep(&zero);\n\n    av_freep(&state);\n\n\n\n    /* the specification says that after doing 0xff escaping unused bits in\n\n     * the last byte must be set to 0, so just append 7 \"optional\" zero-bits\n\n     * to avoid special-casing. */\n\n    put_bits(&pb2, 7, 0);\n\n    size = put_bits_count(&pb2);\n\n    flush_put_bits(&pb2);\n\n    /* do escape coding */\n\n    init_get_bits(&gb, buf2, size);\n\n    size -= 7;\n\n    while (get_bits_count(&gb) < size) {\n\n        int v;\n\n        v = get_bits(&gb, 8);\n\n        put_bits(&pb, 8, v);\n\n        if (v == 0xFF) {\n\n            v = get_bits(&gb, 7);\n\n            put_bits(&pb, 8, v);\n\n        }\n\n    }\n\n    avpriv_align_put_bits(&pb);\n\n    av_freep(&buf2);\n\n\n\n    /* End of image */\n\n    put_marker(&pb, EOI);\n\n    flush_put_bits(&pb);\n\n\n\n    emms_c();\n\n\n\n    pkt->size   = put_bits_count(&pb) >> 3;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n    return 0;\n\n\n\nmemfail:\n\n    av_packet_unref(pkt);\n\n    av_freep(&buf2);\n\n    av_freep(&state);\n\n    av_freep(&zero);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 11427, "substitutes": {"avctx": ["devcontext", " avcontext", "autx", "avconn", "aujac", "avecontext", " avhw", "wavconf", "avcmd", "auctx", "aucmd", "averconf", "ajcb", "auvoc", "avervoc", "averctx", "avcmp", "averjac", "avetx", " avctl", " avvoc", " avcv", "avvoc", "aftx", "Avconn", "devctx", "avconf", "wavctx", "Avcmp", "AVctx", "afconn", "avcontext", "Avctx", "avercontext", "averkw", "devcfg", "avhw", "ajctx", "avercv", "avectx", "ajtx", " avconn", "afcmp", "avcfg", "afcfg", " avtx", "avercmd", "wavtx", " avcmd", "ajcfg", "avctl", "afctx", " avcb", "averctl", "avekw", "AVtx", "averconn", "avcb", "AVcontext", "avecmd", "afjac", "devtx", "AVctl", " avcmp", "wavcmd", " avcfg", "avecb", "avcv", "auconn", "afcontext", "avjac", "Avcontext", "auctl", "AVconf", "avecfg", "averhw", "afhw", " avkw", "afcmd", "AVcmd", "AVcv", "avkw", "avertx", "avtx"], "pkt": [" packet", "pnt", "cix", "dnt", "Pnt", "apacket", "mct", " pkg", "wpkg", "Pkt", "dacket", " pvc", "Pct", "cct", "pkg", "wpkt", "Pck", "macket", "ckt", "mix", "apct", " pnt", "mvc", " pck", "wpacket", "pconn", "pck", " pconn", "packet", "mkt", "wpvc", " pct", "dck", "Pix", "cacket", "Pconn", "pvc", "pix", "apkt", "Packet", "apnt", "dkt", "mconn", "Pkg", " pix", "pct", "apix", "mkg"], "pict": ["phot", "png", "pic", "Pic", "pas", "fi", "gif", "avi", "pt", "cam", "fen", "picture", "kt", "prop", "fp", "iat", "act", "vp", "jp", "pkg", "fps", "capt", "pit", "pai", "Pict", "pres", "phy", "ctx", "feat", "pl", "stat", "phys", "Picture", "lot", "pain", "img"], "got_packet": ["got_payett", "got_ppett", "got_packett", "got_pkt", "got_payets", "got_packkt", "got_payet", "got_pets", "got_paykt", "got_ppkt", "got_pet", "got_pett", "got_ppet", "got_ppets", "got_packets"], "p": ["pic", "pc", "par", "pp", "pt", "f", "cp", "fp", "vp", "jp", "m", "pd", "ap", "pkg", "lp", "P", "t", "pen", "pr", "pl", "c", "pro", "pid", "pn", "pa"], "pb": ["td", "lb", "py", "bj", "pic", "pas", "typ", "pc", "tp", "bf", "ub", "mb", "pp", "pt", "uf", "gp", "bp", "rb", "tk", "ping", "bolt", "proc", "tg", "kt", "xb", "amp", "resp", "buf", "cp", "pg", "vp", "jp", "pkg", "np", "fb", "pod", "cb", "ab", "tab", "orp", "lp", "bs", "plain", "root", "emb", "eb", "ctx", "px", "pl", "sb", "b", "wp", "tmp", "cmd", "verb", "sys", "bot", "dp", "bb", "PB", "peer", "nb", "db", "msg", "cv", "public", "mp", "vm", "pro", "wb", "pa"], "pb2": ["pblet", "pkg1", "pbb", "jp1", "jplet", "cv1", "pb3", "p1", "cv2", "bufb", "pkg3", "p3", "cv3", "buflet", "plet", "jp2", "p2", "pb1", "pkg2", "jpb", "buf1"], "gb": ["gh", "bf", "gm", "uf", "sg", "tg", "gs", "GB", "Gb", "g", "cb", " GB", " db", " rg", "bg", "gd", " bu", " gui", "gc", " eg", "sb", "kb", " gif", " gu", " storage", "gt", "db", " rgb", "cv"], "buf2": ["uf1", "buf3", "buffer2", " buf02", "buff02", "buffer1", "pb1", "buff2", " buf0", "buff3", "buf1", "uf3", "buf0", "uf0", "buffer3", "buffer02", "uf2", "pb0", "uf02", "buf02", " buf3", "buff1", " buf1"], "zero": ["empty", "na", "me", "prefix", "null", "window", "mask", "ket", "none", "dirty", "index", "ta", "ma", "total", "root", "final", "one", "good", "comment", "major", "zer", "scale", "fee", "sc", "equal", "initial"], "cur": ["num", "con", "cmp", "quick", "cor", "ct", "prev", "err", "buf", "rev", "ptr", "desc", "pri", "ser", "cont", "row", "final", "rc", "cache", "ctr", "mid", "tmp", "res", "serv", "sc", "msg", "cv", "cr", "dr"], "last": ["next", "num", "base", "end", "prev", "list", "range", "first", "stable", "stop", "Last", "tail", "total", "final", "latest", "old", "reg", "cache", "close", "low", "master", "str", "est", "rest", "dist", "start", "st", "full", "max"], "state": ["next", "tx", "status", "config", "code", "ch", "err", "event", "list", "STATE", "error", "act", "type", "te", "progress", "port", "State", "test", "info", "tag", "stat", "st", "result", "msg", "states", "name", "style"], "i": ["ms", "ami", "id", "ai", "I", "io", "ie", "me", "li", "ei", " I", "iq", "o", "sim", "ind", "ui", "iter", "ip", "m", "ki", "ti", "ic", "in", "mi", "index", "is", "im", "ix", "n", "y", "t", "ci", "iu", "zi", "phi", "xi", "gu", "multi", "qi", "e", "c", "gi", "bi", "di", "iii", "ij", "pi", "si", "it", "x", "ini", " ii", " bi", "hi", "ims", "ii"], "size": ["depth", "len", "small", "send", "address", "sum", "buffer", "format", "weight", "sp", "height", "sent", "Size", "ui", "SIZE", "dimension", "capacity", "pos", "window", "ize", "bytes", "mem", "storage", "index", "data", "n", "body", "big", "count", "iz", "shape", "dim", "c", "scale", "sn", "start", "fee", "si", "speed", "space", "set", "head", "name", "offset", "length"], "ret": ["arr", "tf", "fin", "len", "tr", "success", "reset", "back", "flag", "err", "RET", "resp", "value", "buf", "nt", "iter", "rev", "ref", "fun", "mt", "def", " Ret", "txt", "alt", "mem", "try", "cont", "final", "t", "rem", "rets", "reg", "repl", "gc", "val", "Ret", "tmp", "red", "rt", "re", "elt", "res", "it", "result", "gt", "ll", "out"], "comps": ["quredits", "collpps", "COMples", " comonents", "quops", "commpps", "comres", "comrs", "temres", " comrs", "comples", "commups", " comales", "proPS", "commplets", " coms", "Comports", "conps", "coms", "compps", "reports", "commps", "compcs", "commres", "COMs", "COMps", "commales", "collples", "qups", "collPS", " compps", "COMPS", " comports", "speports", "comports", "comales", "comonents", "temps", "conpps", "repps", "COMales", "commrs", "speps", "ComPS", "compops", "COMrs", "compredits", "Coms", "comPS", "compups", "speonents", "commops", "propps", "commports", "temups", "comredits", " comPS", "concs", "Comps", "commorts", "compplets", "collps", "quplets", "compres", "COMcs", "comops", "spepps", "comcs", "commcs", "comorts", "comppps", "reonents", "COMpps", " comcs", "reps", "COMports", "complets", "props", "temorts", "comups", "proples", "conports", "compports", "commredits"]}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "void ff_vc1_decode_blocks(VC1Context *v)\n\n{\n\n\n\n    v->s.esc3_level_length = 0;\n\n    if (v->x8_type) {\n\n        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);\n\n\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n    } else {\n\n        v->cur_blk_idx     =  0;\n\n        v->left_blk_idx    = -1;\n\n        v->topleft_blk_idx =  1;\n\n        v->top_blk_idx     =  2;\n\n        switch (v->s.pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            if (v->profile == PROFILE_ADVANCED)\n\n                vc1_decode_i_blocks_adv(v);\n\n            else\n\n                vc1_decode_i_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            if (v->p_frame_skipped)\n\n                vc1_decode_skip_blocks(v);\n\n            else\n\n                vc1_decode_p_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            if (v->bi_type) {\n\n                if (v->profile == PROFILE_ADVANCED)\n\n                    vc1_decode_i_blocks_adv(v);\n\n                else\n\n                    vc1_decode_i_blocks(v);\n\n            } else\n\n                vc1_decode_b_blocks(v);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 11428, "substitutes": {"v": ["button", "command", "on", "vs", "u", "cam", "vv", "uv", "d", "lv", "vp", "m", "r", "y", "html", "view", "t", "qu", "vim", "env", "b", "w", "cv", "conv", "vol", "tv", "vert", "va", "av", "ve", "value", "g", "rev", "um", "sv", "qv", "ver", "en", "video", "version", "get", "att", "nv", "ch", "vi", "ev", "ov", "form", "f", "l", "i", "vt", "window", "n", "V", "it", "s", "vr", "iv", "vm", "vc", "vector", "q", "p", "dev", "inv", "j", "cache", "val", "c", "h", "x", "wire"]}}
{"project": "FFmpeg", "commit_id": "8ce803db51a28eb662b6271b2b223e0312bdb3d2", "target": 1, "func": "paint_mouse_pointer(XImage *image, struct x11_grab *s)\n\n{\n\n    int x_off = s->x_off;\n\n    int y_off = s->y_off;\n\n    int width = s->width;\n\n    int height = s->height;\n\n    Display *dpy = s->dpy;\n\n    XFixesCursorImage *xcim;\n\n    int x, y;\n\n    int line, column;\n\n    int to_line, to_column;\n\n    int image_addr, xcim_addr;\n\n\n\n    xcim = XFixesGetCursorImage(dpy);\n\n\n\n    x = xcim->x - xcim->xhot;\n\n    y = xcim->y - xcim->yhot;\n\n\n\n    to_line = FFMIN((y + xcim->height), (height + y_off));\n\n    to_column = FFMIN((x + xcim->width), (width + x_off));\n\n\n\n    for (line = FFMAX(y, y_off); line < to_line; line++) {\n\n        for (column = FFMAX(x, x_off); column < to_column; column++) {\n\n            xcim_addr = (line - y) * xcim->width + column - x;\n\n\n\n            if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel\n\n                image_addr = ((line - y_off) * width + column - x_off) * 4;\n\n\n\n                image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);\n\n                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);\n\n                image->data[image_addr+2] = (unsigned char)(xcim->pixels[xcim_addr] >> 16);\n\n            }\n\n        }\n\n    }\n\n\n\n    XFree(xcim);\n\n    xcim = NULL;\n\n}\n", "idx": 11433, "substitutes": {"dpy": ["sdpy", "bpic", "sdpi", "dsgb", "dmp", "cpm", "cpic", "sdpm", "wgb", "dpty", " dgb", "nmp", "cpi", "dpor", "bpy", " dpty", "bpm", "cpy", "npor", "dspy", " dmp", "npy", "dsmy", "sdpic", "dpm", "dpic", "bpi", "sdgb", "dspty", "wpy", "sdmy", "ngb", " dpor", "dmy", "wmp", "dgb", "dpi", " dmy", "sdpty", "wpor"], "xcim": ["octima", "xbimm", "occimm", "xcimus", "ctximi", "pscim", "mcm", "lcima", "conimm", "wxima", "xbif", "occim", "cmpimp", "ccim", "xaimal", "conim", "xdimi", "zxam", "occimal", "xcimm", "vcrim", "ctxim", "cnif", "xcit", "cpimp", "wxim", "xcam", "cmpime", "mcimus", "webkitim", "zxil", "rcimi", "pscrim", "conimus", "cuim", "xcm", "bcm", "funcimus", "xaif", "webkitimus", "xaim", "cpil", "xcimp", "conif", "cmpil", "webkitrim", "xdm", "ctxrim", "rcim", "xfim", "vcif", "webkitimg", "mcif", "xdimm", "mcimal", "vcimal", "octsim", "xaimus", "funcif", "confimm", "lcim", "conrim", "funcim", "lciro", "occime", "abcim", "xciro", "vcimm", "xcrim", "xcimal", "pcil", "bcim", "pscimm", "vcit", "xdimal", "confit", "xfiro", "xdime", "bcimus", "cmpim", "cnimus", "xcimg", "xaaram", "funcimm", "cuam", "pcim", "occimus", "etcrim", "cpim", "xcimi", "vcimi", "xcif", "abcimus", "wxsim", "cnim", "xbim", "xdimus", "xcsim", "bcimal", "rcimal", "confimal", "zximm", "zxime", "etcimm", "cuimm", "vcimus", "xfimm", "ccimus", "xcil", "xdim", "ctximus", "confif", "zxiro", "ccimm", "confimus", "ccif", "ctximm", "cnimm", "lcam", "xfil", "lcimm", "etcim", "vcim", "xbimus", "xaimg", "xarim", "pscimus", "xcaram", "xfam", "lcsim", "octim", "xfimus", "octimm", "mcimm", "cuaram", "confim", "xcime", "mcim", "zximus", "funcit", "xfimi", "abcimg", "etcimus", "xfaram", "lcil", "confimi", "zxim", "ctximal", "funcimal", "cpime", "xaam", "pcimp", "rcimm", "pcime", "abcrim", "xcima", "wximm", "xaimm"], "x": ["col", "lin", "on", "xp", "xy", "tx", "ice", "at", "nex", "image", "ile", "p", "o", "height", "ex", "ry", "ox", "dx", "xc", "g", "l", "wx", "m", "lon", "X", "i", "length", "xs", "ine", "en", "lat", "ln", "index", "row", "im", "ix", "rx", "n", "j", "t", "px", "v", "xi", "e", "xt", "c", "ly", "h", "w", "xx", "yx", "xml", "z", "fx", "xa", "el", "le", "angle", "xf"], "y": ["col", "page", "key", "py", "yt", "on", "xy", "ya", "axy", "sky", "ty", "ch", "vy", "cell", "yy", "wy", "p", "height", "ay", "o", "ry", "l", "year", "my", "m", "ies", "ye", "i", "yer", "row", "j", "ys", "n", "t", "Y", "v", "hot", "yo", "asy", "ey", "b", "c", "ly", "ym", "h", "sy", "gy", "ery", "w", "uy", "iy", "yx", "by", "z", "yl", "ny", "cy"], "line": ["col", "page", "lin", "on", "entry", "pe", "record", "ie", "path", "code", "section", "image", "li", "cell", "range", "stroke", "Line", "file", "point", "frame", "iter", "tile", "eline", "label", "block", "l", "pixel", "position", "port", "word", "ine", "loop", "ln", "index", "row", "try", "chain", "level", "n", "se", "node", "entity", "lock", "pipe", "LINE", "link", "lay", "ide", "lo", "le", "style"], "column": ["col", "output", "page", "command", "rain", "key", "display", "cloud", "category", "day", "custom", "pointer", "section", "channel", "format", "cell", "pattern", "Column", "axis", "widget", "point", "height", "field", "slot", "variable", "dimension", "label", "character", "condition", "block", "year", "client", "component", "position", "word", "umn", "function", "index", "attribute", "chain", "row", "letter", "property", "header", "margin", "connection", "collection", "directory", "paragraph", "zone", "forward", "c", "csv", "crop", "table", "piece", "cy", "number"], "to_line": ["to67lines", "too__lines", "toplaceline", "to__lines", " to_row", "to_row", "to_file", "too__Line", "max_lin", "too__line", "max_file", "to__node", "toplacerow", "to67line", "to__row", "to__line", "toplacelink", " to_node", "to67file", "to67lin", "to__Line", "too_lin", "to_Line", "to_link", "to__lin", "to_lin", "max_lines", "to__link", "to_lines", "too_line", "too__lin", "too_lines", "too_Line", "max_line", "toplacenode", " to_link", "to_node"], "to_column": ["toplacesquare", "to_attribute", " to_Column", "to_row", "to__column", "toplacecolumn", "to__property", " to_character", "to__cell", " to_cell", "to_cell", " to_square", "TO_column", "to_property", "TO_row", " to_property", "toplaceproperty", "to_Column", "to_character", "to_square", "to__square", "TO_Column", "toplacecell", "TO_attribute"], "image_addr": ["image___addr", " image_ord", "image_ser", "picture_obj", "picture_dir", " image_ptr", "image_err", "image_ip", " image_ip", "sequence_addr", "image_ptr", "image__ptr", "image__offset", "image___obj", " image_offset", "picture_ser", "image__adr", "image_adr", "image_dir", " image_err", "image__addr", "image___dir", "sequence_offset", "sequence_row", "picture_addr", "image_offset", "sequence_adr", " image_adr", "image_row", "image_obj", "image_ord"], "xcim_addr": ["xcim__address", "xcimus_src", "xcim_mt", "xcim_src", "xcimus_ad", "xcrim_ord", "xcem_loc", "xcimus_arr", "xcrim_mt", "xcim_arr", "xcem_ptr", "xcim5loc", "xcrim_attr", "xcrim_addr", "xcig_off", "xcim_data", "xcem_addr", "xcim_off", "xcim_loc", "xcim__err", "xcem_data", "xcrim_address", "xcim_add", "xcig_ptr", "xcimus_addr", "xcim5data", "xcim_ord", "xcim_attr", "xcim5addr", "xcim__addr", "xcim_ext", "xcig_ext", "xcim5ptr", "xcim_ad", "xcim_address", "xcig_addr", "xcimus_add", "xcim__attr", "xcim_err", "xcimus_attr", "xcim_ptr", "xcrim_err"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static uint64_t boston_platreg_read(void *opaque, hwaddr addr,\n\n                                    unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint32_t gic_freq, val;\n\n\n\n    if (size != 4) {\n\n        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);\n\n        return 0;\n\n    }\n\n\n\n    switch (addr & 0xffff) {\n\n    case PLAT_FPGA_BUILD:\n\n    case PLAT_CORE_CL:\n\n    case PLAT_WRAPPER_CL:\n\n        return 0;\n\n    case PLAT_DDR3_STATUS:\n\n        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;\n\n    case PLAT_MMCM_DIV:\n\n        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;\n\n        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;\n\n        return val;\n\n    case PLAT_BUILD_CFG:\n\n        val = PLAT_BUILD_CFG_PCIE0_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE1_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE2_EN;\n\n        return val;\n\n    case PLAT_DDR_CFG:\n\n        val = s->mach->ram_size / G_BYTE;\n\n        assert(!(val & ~PLAT_DDR_CFG_SIZE));\n\n        val |= PLAT_DDR_CFG_MHZ;\n\n        return val;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,\n\n                      addr & 0xffff);\n\n        return 0;\n\n    }\n\n}\n", "idx": 11439, "substitutes": {"opaque": [" ophole", "obaques", "OPosit", "oaques", "oca", "opaques", "opque", "oppca", "ohole", "oosit", " opaques", "OPaque", "oque", "oaque", "opposit", "obaque", "ophole", "opca", "oppaque", " opque", "oatile", "OPatile", "oppatile", "obque", "OPca", "obhole", "oposit", "opatile"], "addr": ["align", "arr", "work", "src", "ash", "id", "tx", "address", "map", "arp", "prefix", "add", "Address", "a", "rs", "ack", "alloc", "hash", " address", "wid", "pad", "act", "hop", "ip", "pos", "ref", "np", "attr", "rn", "inter", "ptr", "arch", "gate", "adr", "alt", "mem", "ord", "r", "aff", "ix", "ad", "ctx", "rc", "v", "host", "cmd", "rt", "hw", "res", "alias", "coord", "loc", "offset", "dr"], "size": ["grow", "len", "shift", "small", "num", "notice", "empty", "send", "address", "sum", "message", "padding", "sp", "Size", "SIZE", "capacity", "g", "l", "type", "ize", "mem", "data", "n", "body", "count", "shape", "e", "dim", "c", "sh", "scale", "sn", "false", "start", "fee", "x", "space", "z", "sized", "ze", "max", "name", "offset", "length", "sd", "number"], "s": ["sq", "a", "q", "rs", "hs", "p", "gs", "o", "sp", "sts", "ps", "sac", "g", "m", "ies", "sv", "i", "ses", "ins", "es", "bs", "r", "is", "js", "S", "ss", "ts", "t", "ssl", "v", "os", "sb", "e", "b", "c", "h", "ns", "stats", "fs", "ls", "ds"], "gic_freq": ["gic_frch", "gic_Freqs", "gic_Freek", "gic_Frez", "gic_frq", "gic_req", "gic_frqs", "gic67frez", "gic_Frereq", "gic_Frech", "gic_fech", "gic67fastqs", "gic67fastreq", "gic_reek", "gic_Freq", "gic2frch", "gic_frereq", "gic_feqs", "gic_rez", "gic67frereq", "gic_freqs", "gic_FreQ", "gic2frqs", "gic_frech", "gic2freq", "gic_frez", "gic_fastq", "gic_fastreq", "gic67freq", "gic2frech", "gic67fastq", "gic_freek", "gic2frq", "gic_fastqs", "gic_fastz", "gic_freQ", "gic2freqs", "gic67freqs", "gic67fastz", "gic_reQ", "gic_feq"], "val": ["ee", "func", "prop", "slot", "util", "eval", "pr", "pl", "pal", "bal", "elt", "str", "serv", "opt", "el", "vol", "arr", "key", "tx", "al", "VAL", "bool", "value", "ve", "buf", "bl", "fail", "rol", "pret", "ver", "cal", "als", "rel", "alpha", "test", "cond", "echo", "new", "vals", "item", "lev", "obj", "sl", "pt", "crit", "err", "valid", "compl", "resp", "point", "var", "ival", "vec", "grad", "l", "Val", "def", "pos", "local", "ref", "vt", "cho", "kl", "ctx", "it", "aval", "loc", "ret", "len", "num", "lib", "dev", "all", "alt", "expr", "il", "v", "Value", "pol", "sel", "res", "ul", "x", "msg"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int avfilter_register(AVFilter *filter)\n\n{\n\n    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)\n\n        return -1;\n\n\n\n    registered_avfilters[next_registered_avfilter_idx++] = filter;\n\n    return 0;\n\n}\n", "idx": 11444, "substitutes": {"filter": ["page", "Filter", "spec", "entry", "map", "call", "resource", "channel", "feature", "match", "fire", "event", "list", "file", "form", "profile", "before", "f", "report", "cf", "block", "ref", "term", "package", "attribute", "test", "check", "sort", "v", "transform", "search", "query", "rule", "table", "batch", "fil", "only", "apply", "find"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n", "idx": 11449, "substitutes": {"errp": [" erpid", "errP", "erpid", " errP", " erP", "errpid", " erp", "erP", " errpid", "erp"]}}
{"project": "qemu", "commit_id": "eefff991d059d299b917627d2a95bce34d2f97f3", "target": 1, "func": "int load_snapshot(const char *name, Error **errp)\n\n{\n\n    BlockDriverState *bs, *bs_vm_state;\n\n    QEMUSnapshotInfo sn;\n\n    QEMUFile *f;\n\n    int ret;\n\n    AioContext *aio_context;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        error_setg(errp,\n\n                   \"Device '%s' is writable but does not support snapshots\",\n\n                   bdrv_get_device_name(bs));\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_all_find_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Device '%s' does not have the requested snapshot '%s'\",\n\n                   bdrv_get_device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11455, "substitutes": {"name": ["on", "prefix", "format", "range", "m", "word", "package", "create", "data", "t", "tree", "b", "cmd", "str", "w", "size", "NAME", "key", "run", "filename", "path", "resource", "sp", "null", "ma", "version", "new", "one", "title", "missing", "alias", "get", "no", "current", "id", "nm", "part", "a", "names", "order", "named", "file", "error", "admin", "ref", "type", "ame", "def", "local", "in", "mem", "n", "old", "info", "cn", "sw", "ns", "out", "base", "p", "dev", "normal", "label", "common", "snap", "v", "Name"], "errp": ["rrpe", "errwp", "eorp", "rrp", "riskp", "errper", "aerp", " errpat", "arrap", "herpp", "aercp", "errpoint", "errcp", "errps", " errP", "errpa", "rrps", "eorpat", "errP", "errorap", "scorep", "ierp", "arrp", "scoreP", "arrwp", "errpatch", "ermpoint", "scorepat", "derpp", "crp", "arrper", "derd", "riskpp", "errping", "derp", "rrpress", "rrpart", "aerpart", "arrping", "acerping", "rrper", "eorper", " errpp", "errpe", "ierpatch", "eorping", "errorpart", "ermpa", "errorps", "ierpa", "crap", "errpp", "diepoint", "aerps", "errap", "crpat", "arrpart", "errorp", "errpart", "errpress", "diep", "rrcp", "errorwp", "rrpp", "rrpat", "errpat", "ermpatch", "acerpart", "herp", "rrd", "diepa", "rrping", "acerp", "riskpat", "riskP", "diepatch", "scorepp", "acerpress", "arrpat", "ermp", "derpe", "herd", "errd", "herpe", "ierpoint", "errorpat", "errorcp", "crwp", "arrpress"], "bs": ["lb", "obs", "aps", "vs", "ists", "aos", "bp", "rs", "bas", "bes", "bl", "gs", "ps", "bc", "BS", "cs", "boxes", "bm", "bits", "bn", "bg", "las", "als", "js", "its", "bos", "ts", "pb", "boot", "lbs", "bps", "ubs", "ubis", "os", "sb", "b", "bis", "bh", "ns", "bi", "fs", "bb", "gb", "blog", "ls", "bt", "s", "oss", "vers", "hz", "sys"], "bs_vm_state": ["bs_nvgrstate", "bs_vmgrtype", "bs_vd_info", "bs_vm_info", "bs_nvgrstatus", "bs_vd_state", "bs_vmptstates", "bs_vmptstart", "bs_virtual_state", "bs_nvptstate", "bs_nvptstart", "bs_nv_type", "bs_nv_status", "bs_vm_port", "bs_vmgrstatus", "bs_vm2state", "bs_vm_status", "bs_vm2State", "bs_VM_State", "bs_VM_info", "bs_vm2port", "bs_nvpttype", "bs_virtual_State", "bs_vmpttype", "bs_vmgrstate", "bs_vm_State", "bs_nvptstates", "bs_vm_start", "bs_vmptstate", "bs_virtual_start", "bs_VM_port", "bs_vm_tag", "bs_VM_state", "bs_vm2resource", "bs_vm_states", "bs_nv_start", "bs_virtual_status", "bs_nv_state", "bs_vm_type", "bs_nv_states", "bs_virtual_tag", "bs_vm_resource", "bs_nvgrtype", "bs_vd_resource", "bs_vm2info"], "sn": ["sq", " sc", " sv", "na", "sl", "nm", "nl", "gn", "fl", "sol", " syn", "nex", "Sn", " Sn", " scr", "sp", "sm", "su", "nd", "nt", " ss", "np", "rn", "sv", "nn", "sam", "ern", "ln", "snap", " sr", "n", "fn", "SN", "kn", "tn", "nr", "sb", "cn", "sh", "sw", "ns", "sa", "sr", "spe", "spr", "si", "stat", "st", " SN", " cs", "sc", "sk", "sd", "syn", " sw"], "f": ["fab", "tf", "ef", "u", "fd", "fi", "bf", "fw", "fo", "buffer", "uf", "ff", "file", "p", "rf", "fp", "cf", "fm", "d", "elf", "l", "m", "fb", "lf", "fe", "fa", "r", "fn", "t", "v", "fr", "sf", "e", "b", "c", "h", "F", "w", "fs", "fc", "x", "fx", "s", "af", "xf"], "ret": ["ert", "reset", "format", "end", "print", "reply", "ry", "slot", " Ret", "desc", "t", "rem", "rect", "cmd", "elt", "str", "vet", "rm", "result", "nb", "ll", "fin", "tr", "run", "status", "code", "RET", "value", "RT", "rev", "after", "usr", "txt", "server", "ter", "try", "fn", "ben", "new", "rets", "Ret", "rt", "att", "get", "no", "number", "id", "net", "nm", "back", "summary", "err", "nz", "resp", "ne", "nt", "ref", "inter", "def", "plain", "last", "reg", "remote", "cert", "it", "ft", "out", "mt", "len", "num", "success", " RET", "det", "del", "cb", "addr", "alt", "ext", "expr", "script", "not", "val", "re", "res", "ber", "gt", "description"], "aio_context": ["aive_context", "aio_pointer", "aian_Context", "aive_support", "aogo_context", "aIO_ctx", "aIO_support", "aio_information", "aive_Context", "aio_text", "aogo_text", "aio_ctx", "aio_translation", "aogo_support", "aian_information", "aIO_context", "aive_ctx", "aio_window", "aogo_window", "aio_Context", "aian_pointer", "aian_context", "aIO_translation", "aio_support"], "mis": ["ms", "emis", "pas", "mes", "mx", "mm", "sim", "mic", "mo", "jp", "m", "mt", "mas", "oses", "dis", "mr", "mn", "mal", "miss", "mu", "mi", "las", "ias", "pm", "uj", "ma", "mc", "mos", "Mis", "tis", "MS", "mor", "cms", "cm", "isin", "mus", "sis", "dj", "sys", "mit"]}}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,\n\n                                             ptrdiff_t buf_stride,\n\n                                             ptrdiff_t src_stride,\n\n                                             int block_w, int block_h,\n\n                                             int src_x, int src_y, int w, int h)\n\n{\n\n    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,\n\n                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,\n\n                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);\n\n}\n", "idx": 11468, "substitutes": {"buf": ["tr", "tx", "map", "buffer", "uf", "aka", "ff", "var", "bl", "seq", "bc", "Buffer", "block", "vec", "ref", "cb", "ptr", "window", "queue", "mem", "br", "dest", "cap", "ctx", "rc", "v", "wd", "b", "Buff", "broad", "batch", "buff", "db", "pack", "cv", "img"], "src": ["sq", "syn", "sl", "source", "rs", "stream", "sub", "sec", "cur", "sing", "ins", "ptr", "raw", "supp", "urg", "usr", "ser", "r", "rl", "sup", "dest", "rc", "sur", "input", "sb", "ctr", "sn", "sel", "sr", "st", "sc", "img", "ur", "s", "iv", "inst", "uns", "sys"], "buf_stride": ["buf_drider", "buf_Strride", "buf_bride", "buf_brider", "buf_descider", "buf_brride", "buf_strride", "buf_trides", "buf_descope", "buf_Strade", "buf_drope", "buf_drides", "buf_strope", "buf_drride", "buf_trride", "buf_strider", "buf_Strides", "buf_drade", "buf_brope", "buf_strides", "buf_trade", "buf_tride", "buf_Stride", "buf_descide", "buf_dride", "buf_descride", "buf_strade"], "src_stride": ["src_Strider", "src_Strides", "src_sage", "src_decide", "src_decider", "src_divide", "src_strides", "src_sension", "src_rider", "src_Strride", "src_strension", "src_decride", "src_side", "src_Stride", "src_divride", "src_decension", "src_sride", "src_rride", "src_ride", "src_decides", "src_decage", "src_rides", "src_divension", "src_strride", "src_strider", "src_strage", "src_divage"], "block_w": ["block1W", "block1nw", "blockxnw", " block_wx", "block_W", "blocklywidth", " block_W", "block1wx", "blocklyW", "block1w", "blockxw", "block_b", "blockxW", "blocklyw", " block_nw", "Block_width", "block_wx", "blocklyb", "Block_b", "block_nw", "Block_W", "Block_w", "blockxwx", "block_width"], "block_h": ["block_hl", "block0y", "block_y", "block7hh", "blockablehl", " block_hl", " block_y", "block7hz", "block_hz", " block_hz", "block0hl", "block0h", "blockableh", " block_hh", "block_hh", "blockabley", "block7h"], "src_x": ["rc_x", "rc_y", "src64x", "src64y", "src64h", " src_ix", "rc_ix", "src_ix", "src_h", "rc_h", "src64ix"], "src_y": ["rc_x", "rc_ny", "rc_z", "src_ya", "rc_y", "src_Y", "src_ny", "rc_Y", "src_z", "rc_ya"], "w": ["ow", "fw", "iw", "p", "W", "wid", "rw", "wr", "m", "l", "wx", "win", "window", "wh", "wa", "ew", "r", "wl", "wo", "wn", "wd", "v", "aw", "b", "wp", "wt", "hw", "kw", " W", "x", "z", "nw", "wb"], "h": ["hal", "he", "ph", "hm", "ah", "hr", "q", "ht", "p", "hash", "height", "g", "m", "l", "hd", "hl", "ho", "oh", "hh", "ish", "j", "y", "v", "uh", "ha", "rh", "b", "c", "sh", "kh", "bh", "ih", "x", "z", "hi", "head", "high", "H"]}}
{"project": "FFmpeg", "commit_id": "a1a32fdb0ee63783d06c63b7d90bb382eea356ce", "target": 1, "func": "static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m)\n\n{\n\n    char *tx3g_ptr = avctx->extradata;\n\n    int i, box_size, font_length;\n\n    int8_t v_align, h_align;\n\n    int style_fontID;\n\n    StyleBox s_default;\n\n\n\n    m->count_f = 0;\n\n    m->ftab_entries = 0;\n\n    box_size = BOX_SIZE_INITIAL; /* Size till ftab_entries */\n\n    if (avctx->extradata_size < box_size)\n\n        return -1;\n\n\n\n    // Display Flags\n\n    tx3g_ptr += 4;\n\n    // Alignment\n\n    h_align = *tx3g_ptr++;\n\n    v_align = *tx3g_ptr++;\n\n    if (h_align == 0) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_LEFT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_LEFT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_LEFT;\n\n    }\n\n    if (h_align == 1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_CENTER;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_CENTER;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_CENTER;\n\n    }\n\n    if (h_align == -1) {\n\n        if (v_align == 0)\n\n            m->d.alignment = TOP_RIGHT;\n\n        if (v_align == 1)\n\n            m->d.alignment = MIDDLE_RIGHT;\n\n        if (v_align == -1)\n\n            m->d.alignment = BOTTOM_RIGHT;\n\n    }\n\n    // Background Color\n\n    m->d.back_color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // BoxRecord\n\n    tx3g_ptr += 8;\n\n    // StyleRecord\n\n    tx3g_ptr += 4;\n\n    // fontID\n\n    style_fontID = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n    // face-style-flags\n\n    s_default.style_flag = *tx3g_ptr++;\n\n    m->d.bold = s_default.style_flag & STYLE_FLAG_BOLD;\n\n    m->d.italic = s_default.style_flag & STYLE_FLAG_ITALIC;\n\n    m->d.underline = s_default.style_flag & STYLE_FLAG_UNDERLINE;\n\n    // fontsize\n\n    m->d.fontsize = *tx3g_ptr++;\n\n    // Primary color\n\n    m->d.color = AV_RB24(tx3g_ptr);\n\n    tx3g_ptr += 4;\n\n    // FontRecord\n\n    // FontRecord Size\n\n    tx3g_ptr += 4;\n\n    // ftab\n\n    tx3g_ptr += 4;\n\n\n\n    m->ftab_entries = AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n\n\n        box_size += 3;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp = av_malloc(sizeof(*m->ftab_temp));\n\n        if (!m->ftab_temp) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        m->ftab_temp->fontID = AV_RB16(tx3g_ptr);\n\n        tx3g_ptr += 2;\n\n        font_length = *tx3g_ptr++;\n\n\n\n        box_size = box_size + font_length;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp->font = av_malloc(font_length + 1);\n\n        if (!m->ftab_temp->font) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(m->ftab_temp->font, tx3g_ptr, font_length);\n\n        m->ftab_temp->font[font_length] = '\\0';\n\n        av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp);\n\n        if (!m->ftab) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        tx3g_ptr = tx3g_ptr + font_length;\n\n    }\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n        if (style_fontID == m->ftab[i]->fontID)\n\n            m->d.font = m->ftab[i]->font;\n\n    }\n\n    return 0;\n\n}\n", "idx": 11488, "substitutes": {"avctx": [" avcp", "Avcontext", " avcontext", "ovcontext", "aftx", "Avcp", "avecontext", "ovctx", "afctx", "avcp", "avecmp", "svctx", "verctx", "avcontext", "vercontext", " avconfig", "Avconfig", "ovtx", "Avctx", " avcmp", "verconfig", "svcontext", "avconfig", "svcmp", "avectx", "vercp", "afcmp", "afcontext", "avcmp", "ovcmp", "avtx", " avtx", "svtx", "avetx"], "m": ["ms", "tm", "min", "hm", "nm", "me", "mm", "mat", "gm", "message", "em", "p", "an", "sm", "wm", "fm", "d", "media", "g", "esm", "bm", "um", "mr", "mn", "mod", "mask", "them", "met", "mi", "md", "pm", "j", "im", "n", "mc", "t", "perm", "mode", "rem", "v", "man", "mk", "b", "dim", "c", "M", "h", "mail", "cm", "om", "rm", "mac", "item", "msg", "dm", "s", "km", "module", "vm", "am", "mt", "mean"], "tx3g_ptr": ["tx3d_desc", "tx3gc_pert", "tx3j_ptr", "tx3gc_ptr", "tx3sg_ptr", "tx3group_iter", "tx3goxaddr", "tx3g_dep", "tx3d_len", "tx3g___ptr", "tx3d_ctr", "tx3g64addr", "tx3g__addr", "tx3g__tp", "tx3goxpert", "tx3g___pointer", "tx3d_peer", "tx3g__pad", "tx3g_rep", "tx3gc_pers", "tx3gc_pointer", "tx3j__ptr", "tx3sg_addr", "tx3g4ptr", "tx3goxptr", "tx3g_pert", "tx3group_ped", "tx3g_tr", "tx3g7ped", "tx3d_tr", "tx3j_rep", "tx3g___pert", "tx3group7ped", "tx3j__tp", "tx3g_ser", "tx3gMemlen", "tx3g_iter", "tx3g_peer", "tx3d_inst", "tx3sg_dep", "tx3g__tr", "tx3g_ped", "tx3g__peer", "tx3group7ptr", "tx3g7iter", "tx3g__pointer", "tx3d_pad", "tx3j__tr", "tx3g_len", "tx3j_tr", "tx3gMemPtr", "tx3g_pointer", "tx3d_ptr", "tx3sg_pointer", "tx3g64inst", "tx3g4ser", "tx3j__rep", "tx3d_ser", "tx3g__rep", "tx3g___iter", "tx3d_ped", "tx3g___ped", "tx3goxinst", "tx3j_tp", "tx3gMemptr", "tx3g_pad", "tx3g7pointer", "tx3d_Ptr", "tx3group7iter", "tx3g_ctr", "tx3g_addr", "tx3g7ptr", "tx3g_tp", "tx3g__ctr", "tx3d_pointer", "tx3g64ptr", "tx3g4pointer", "tx3group_pointer", "tx3g_Ptr", "tx3g64pert", "tx3g_desc", "tx3g__Ptr", "tx3g_inst", "tx3g__ptr", "tx3g___pers", "tx3group7pointer", "tx3group_ptr", "tx3gMempointer", "tx3g_pers", "tx3d_pert", "tx3g4Ptr", "tx3d_addr"], "i": ["I", "ei", " di", "p", "o", "f", " fi", "ip", "ti", " ti", "r", "ta", "j", "t", "v", " v", "e", "b", "c", " c", "di", "er", "si", "it", " bi", " f", " ni", " j"], "box_size": ["box_scale", " box1SIZE", " box_length", "box2SIZE", " box_SIZE", "box2scale", "box_shape", " box1scale", "box2shape", "box1SIZE", " box_scale", " box2length", "box1length", " box2scale", " box2SIZE", "box_length", " box_shape", "box_SIZE", "box2length", " box1size", "box1size", " box1length", " box2shape", "box2size", "box1scale", " box2size"], "font_length": ["fontletlen", "font_size", "fontletsize", " font_size", "fontletdepth", "font_depth", " font_depth", "font_len", "fontletlength", " font_len"], "v_align": ["v_aligned", "v_rang", "vmyalign", "vmmalign", "v_fill", "v8align", "V_al", "v0play", "h_nav", "vmyskip", "version_block", "vv_play", "v_move", "nv_match", "h_fill", "v__offset", "h_ign", "var_direction", "vmmfill", "vPadjust", "vv___adj", "vmmnav", "v_loc", "vPblock", "h_offset", "v_direction", "cv_label", "iv_ign", "vcPignore", "v_play", "v0adj", "h_angle", "vcPadjust", "v_block", "vmyrank", "v0alter", "vmyadjust", "vPignore", "var_align", "qv_align", "v___adj", "vc_align", "vcPalign", "vc_ignore", "v_rank", "v8angle", "v_alter", "v_aff", "version_cmp", "iv_align", "vc_adjust", "V_align", "nv_align", "v___play", "v_angle", "cv_rang", "vmydirection", "vPnav", "vv_adj", "iv_move", "vPloc", "vPrang", "vmyignore", "v_nav", "var_fill", "qv_repeat", "v_cmp", "v0align", "vv___alter", "vPalign", "v_layout", "vv_alter", "var_rank", "vv___align", "v__align", "qv_offset", "h_aligned", "v_adjust", "vPlabel", "cv_align", "vmmaligned", "v8length", "nv_layout", "v_length", "iv_aff", "v_offset", "v__ign", "v_ign", "vPcmp", "vmyfill", "vv_align", "v_repeat", "V_length", "version_align", "vPskip", "v___alter", "cv_loc", "vPfill", "v_skip", "vv___play", "v_match", "qv_nav", "v___align", "v_label", "vc_skip", "v_al", "v8al", "vPaligned", "v_ignore", "vcPskip", "v__angle", "V_angle", "v_adj", "version_adjust", "nv_skip"], "h_align": ["hmmangle", "hhPaff", "hh_aff", "hh_aug", "hhPaligned", "hmmalign", "h_ign", "hhPaug", "v_direction", "H_aligned", " h_ign", "h_angle", "h_aug", "h__ign", "h_sign", "h_direction", "h9align", "h__aligned", "v_angle", " h_sign", "h__angle", "hmmdirection", "hhPalign", "hh_align", "h9format", "h9aligned", "h9num", "h_adj", "v_layout", "h_aligned", "h_aff", "hPaug", "hPaligned", "h_format", "hPaff", "hh_aligned", "h_num", "H_num", "hmmlayout", "h__align", "H_format", "hPalign", "h_layout", " h_adj", " h_aligned", " h_angle", "H_align"], "style_fontID": ["style_faceType", "style_textIDs", "style_familyIDs", "style_FontID", "style_FontIDs", "style_textName", "style_fontType", "style_fontid", "style_familyID", "style_sheetIDs", "style_textid", "style_FontName", "style_familyType", "style_FontType", "style_sheetid", "style_sheetName", "style_textID", "style_fontIDs", "style_faceID", "style_familyName", "style_faceIDs", "style_faceName", "style_fontName", "style_Fontid", "style_sheetID"], "s_default": ["solydef", "s_best", "s_def", "sptcurrent", "s_FAULT", " s_FAULT", "solydefault", " s_Default", "s____new", "s____default", "s___def", "s_current", "solyforce", "s_Default", "ts_def", "s_force", "sptFAULT", "s_new", " s_current", "ds_default", "s_primary", "ts_force", "s___default", "sptDefault", "s____Default", "sptdefault", "s___force", " sptdefault", " sptFAULT", "s___best", " s_new", "ts_default", "ds_best", "s___primary", " sptcurrent", " sptDefault", "ds_primary"]}}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n", "idx": 11501, "substitutes": {"chr": ["echar", "Chdr", "echrb", "chsr", " chdr", "chedr", "echrs", "inchrs", " chrs", "inchr", "Chrs", "Char", "cheor", "chdr", "chrs", " chor", "chers", "Chr", "Chsr", "chrb", "cher", " chrb", "inchrb", "inchsr", "echr", "chor", "Chor", "Chrb", "echsr"], "mouse": ["ms", "key", "mallow", "Mouse", "hand", " me", "mate", "address", "mx", "menu", "me", "cookie", "pointer", "write", "where", "ping", "oused", "go", "print", "sample", "ime", "focus", "voice", "mass", "domain", "mo", "m", " microphone", "my", "local", "press", "shell", "hello", "server", "none", "mi", "MI", "de", "ma", "mc", "ole", "hover", "che", "remote", "yahoo", "mmm", "paste", "click", "query", "master", "mor", "fake", " mice", " gorilla", " cursor", "memory", "user", "console", " clay", "le", "ouse"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_init_main_loop(void)\n\n{\n\n    int ret;\n\n\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_init_sigbus();\n\n\n\n    return qemu_event_init();\n\n}\n", "idx": 11516, "substitutes": {"ret": ["arr", "len", "tr", "lt", "lit", "reset", " RET", "oret", "et", "got", "back", "flag", "leg", "print", "det", "bool", "RET", "compl", "nt", "iter", "ref", " Ret", "Return", "mt", "git", "pret", "def", " jet", " alt", "txt", "alt", "ter", "ext", "try", "cont", "ts", "t", "rem", "rets", "reg", "deg", "val", "Ret", "red", "rt", "re", "elt", "res", "pet", "vet", "rm", "cert", "result", "it", "gt", "set", "get", "ft", "out"]}}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n", "idx": 11524, "substitutes": {"tmpenv": [" tmpbuf", "dirtyvar", "tempvar", "mptmp", " tmpvar", "mpenv", "tempen", "tmptmp", "mintvar", "dirtyconn", "mintenv", "imgvar", "mpv", "temptmp", "permdev", "tempconn", "dirtyenvironment", "cmpconn", "dirtyenv", "mkvar", "tmpbuf", "txtenv", "txttmp", "mpbuf", "tempbuf", "permenv", "cmpenvironment", "txtv", "tmpconn", "mkenvironment", "mpdev", "cmpvar", "tempv", "txtbuf", "mkenv", "imgenv", "permbuf", " tmpenvironment", "tempenvironment", "mken", "tmpv", "tmpenvironment", " tmpdev", "cmpenv", "tmpen", "imgen", "mintenvironment", "imgenvironment", "permenvironment", "mpenvironment", "tmpvar", "tempenv", "tmpdev"], "envvar": ["environmentprop", "entityvariable", "envar", " envvariable", "environmentlist", "environmentvar", "entitypack", "envprop", "environmentfunc", "enerprop", "namevar", " envfunc", " envname", "vvar", " envval", "envprev", "envpack", "envval", "envlist", " envprop", "envname", "enname", "enerver", "enval", "vver", "namevariable", "entityvar", "envver", "entityval", "tenvar", "envariable", "nameval", "tenVar", " envpack", " envver", " envVar", "enerprev", "namepack", "environmentprev", "enver", "enerfunc", "vname", " envprev", "tenval", "enervar", "envvariable", "enerlist", "envfunc", "environmentver", "enVar", "tenvariable", "envVar", " envlist"], "envsave": [" envssave", "enlinesav", " envalsave", "enpsare", "encsave", "enpsaves", " envsav", "encsaves", "envalsav", " encssave", " encsave", "envalsave", "encsare", "enlinessave", "encssave", " envalsaves", "envssave", "enfsave", " envalsaver", " encsaver", " envsaved", "envsav", "envalsaver", " encsare", " envsaves", "envsaved", "envalssave", "enpsaver", "envsare", "encsaver", "enpsave", "enpssave", "envalsaved", " encsaved", " envsaver", "envsaves", "encsaved", "envsaver", "enfsaver", " encsav", "enfssave", " envsare", "enfsare", "encsav", "enlinesaved", " envalssave", "enlinesave", "envalsaves"]}}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int avi_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    unsigned char tag[5];\n\n    unsigned int flags = 0;\n\n    const int stream_index = pkt->stream_index;\n\n    int size               = pkt->size;\n\n    AVIContext *avi     = s->priv_data;\n\n    AVIOContext *pb     = s->pb;\n\n    AVIStream *avist    = s->streams[stream_index]->priv_data;\n\n    AVCodecParameters *par = s->streams[stream_index]->codecpar;\n\n\n\n    while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE &&\n\n           pkt->dts > avist->packet_count) {\n\n        AVPacket empty_packet;\n\n\n\n        av_init_packet(&empty_packet);\n\n        empty_packet.size         = 0;\n\n        empty_packet.data         = NULL;\n\n        empty_packet.stream_index = stream_index;\n\n        avi_write_packet(s, &empty_packet);\n\n    }\n\n    avist->packet_count++;\n\n\n\n    // Make sure to put an OpenDML chunk when the file size exceeds the limits\n\n    if (pb->seekable &&\n\n        (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) {\n\n        avi_write_ix(s);\n\n        ff_end_tag(pb, avi->movi_list);\n\n\n\n        if (avi->riff_id == 1)\n\n            avi_write_idx1(s);\n\n\n\n        ff_end_tag(pb, avi->riff_start);\n\n        avi->movi_list = avi_start_new_riff(s, pb, \"AVIX\", \"movi\");\n\n    }\n\n\n\n    avi_stream2fourcc(tag, stream_index, par->codec_type);\n\n    if (pkt->flags & AV_PKT_FLAG_KEY)\n\n        flags = 0x10;\n\n    if (par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avist->audio_strm_length += size;\n\n\n\n    if (s->pb->seekable) {\n\n        int err;\n\n        AVIIndex *idx = &avist->indexes;\n\n        int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE;\n\n        int id = idx->entry % AVI_INDEX_CLUSTER_SIZE;\n\n        if (idx->ents_allocated <= idx->entry) {\n\n            if ((err = av_reallocp(&idx->cluster,\n\n                                   (cl + 1) * sizeof(*idx->cluster))) < 0) {\n\n                idx->ents_allocated = 0;\n\n                idx->entry          = 0;\n\n                return err;\n\n            }\n\n            idx->cluster[cl] =\n\n                av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry));\n\n            if (!idx->cluster[cl])\n\n                return -1;\n\n            idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE;\n\n        }\n\n\n\n        idx->cluster[cl][id].flags = flags;\n\n        idx->cluster[cl][id].pos   = avio_tell(pb) - avi->movi_list;\n\n        idx->cluster[cl][id].len   = size;\n\n        idx->entry++;\n\n    }\n\n\n\n    avio_write(pb, tag, 4);\n\n    avio_wl32(pb, size);\n\n    avio_write(pb, pkt->data, size);\n\n    if (size & 1)\n\n        avio_w8(pb, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 11527, "substitutes": {"s": ["ports", "sq", "aps", "tp", "qs", "a", "ats", "settings", "rs", "bp", "sg", "p", "gs", "sts", "sp", "ex", "ps", "changes", "g", "pkg", "cs", "vp", "ins", "sv", "es", "ses", "fps", "args", "i", "bs", "aws", "is", "js", "j", "S", "ss", "ts", "n", "its", "t", "ctx", "sports", "conf", "self", "v", "ops", "os", "sb", "b", "c", "h", "sa", "ns", "stats", "times", "fs", "w", "sc", "actions", "comm", "sis", "ls", "app", "ims", "ds", "sys"], "pkt": [" packet", "pnt", "wpnt", "pkat", "dnt", "Pnt", "ppkt", "pdu", "apacket", "spnt", "spacket", "ppt", "Pkt", " pdu", "wpkt", "Pct", " pkat", "spdu", "tnt", "tkt", "dpt", "ckt", " pnt", "apct", "wpacket", "tacket", "cnt", "apkat", "packet", "cdu", " pct", "cacket", "spkt", "ddu", "ppct", "ppacket", "tdu", " ppt", "apkt", "Packet", "dkt", "ppkat", "pct", "wpct", "Ppt", "Pdu"], "tag": ["key", "id", "prefix", "flag", "channel", "message", "event", "stream", " Tag", "buf", "var", "field", "seq", "peg", "pad", "pair", "cat", "pos", "type", " TAG", "attr", "txt", "row", "data", "ix", "node", "ad", "mode", "ac", "Tag", "rc", "sw", "tags", "ag", "start", "stat", "tar", "msg", "pack", "head", "name", "offset", "length", "dr", "TAG"], "avi": ["jac", "py", "ami", "ave", "ogg", "gg", "ai", "ja", "av", "vi", "news", "cam", "nav", "pan", "opus", "wi", "VI", "eni", "abba", "au", "ui", "oti", "aaa", "media", "vp", "ano", "afi", "ata", "opa", "wiki", "ia", "txt", "pai", "mi", "video", "pheus", "oga", "wav", "roo", "ifa", "arf", "sav", "riot", " av", "feat", "kat", "eas", "apache", "alist", "bis", "avan", "aaaa", "audi", "sa", "ag", "jam", "aria", "mobi", "aver", "pi", "adi", "oi", "dit", "iv", "gra"], "pb": ["td", "py", "apy", "bj", "typ", "pc", "tp", "ub", "mb", "buffer", "pp", "gp", "pt", "uf", "bp", "rb", "tk", "pan", "proc", "tg", "p", "sp", "buf", "pool", "resp", "cp", "ps", "fp", "pg", "prototype", "prot", "vp", "jp", "pkg", "np", "tc", "sv", "cb", "conv", "tab", "lp", "bs", "pub", "txt", "snap", "eb", "ctx", "new", "conn", "pl", "sb", "b", "wp", "pause", "sys", "dp", "pi", "stab", "PB", "phys", "nb", "buff", "db", "cv", "mp", "soc", "pro", "patch", "wb", "pa"], "avist": ["awiste", "varert", "savister", "avalist", "ajIST", "aviste", " avists", "ravister", "awist", "averist", "savert", "AVIST", "aveert", "savistent", "avistant", "savists", "aveistent", "ajistant", "avisted", " avister", "avalister", "AVists", "avert", "savisted", "varistent", "varisted", "ravist", "AVist", "savist", "ajdist", "awIST", "averIST", "avistent", " avdist", " avistant", "ravistic", "ajists", "savistant", "avistic", "avists", "avister", "AViste", "awists", "ajist", " aviste", " avIST", "raviste", "avdist", "aveisted", "averists", "varist", "avalistic", "avaliste", " avistic", "aveist", "ajister", "averdist", "avIST"], "par": ["ph", "tx", "pas", "pic", "pc", "cmp", "arp", "part", "war", "pp", "ran", "decl", "req", "cam", "prep", "per", "proc", "rec", "p", "var", "kar", "rep", "prop", "cp", "ps", "Par", "jp", "pkg", "def", "pri", "parse", "pard", "rel", "kat", "comp", "pol", "pre", "pi", "param", "tar", "mp", "pro", "rar", "ar", "dr", "arg", "params", "pa"], "empty_packet": ["empty_masket", "empty_mixline", "empty_packline", "empty_maskette", "empty_packpoint", "empty_packageacket", "empty_packe", "empty_pet", "empty_paleter", "empty_packageET", "empty_pickline", "empty_pacette", "empty_mixet", "empty_Packet", "empty_payant", "empty_Packetting", "empty_pacpoint", "empty_packageline", "empty_maskET", "empty_PackET", "empty_palpet", "empty_packET", "empty_codant", "empty_pickets", "empty_palacket", "empty_octet", "empty_pET", "empty_prese", "empty_code", "empty_buckET", "empty_bucket", "empty_payacket", "empty_palet", "empty_packets", "empty_packageetting", "empty_pacET", "empty_octacket", "empty_packageet", "empty_preset", "empty_packeter", "empty_codacket", "empty_packel", "empty_bucketting", "empty_packetting", "empty_buckpet", "empty_mixets", "empty_picket", "empty_pel", "empty_pickette", "empty_packant", "empty_bucketer", "empty_packageets", "empty_packacket", "empty_mixET", "empty_packpet", "empty_Packacket", "empty_payet", "empty_pickET", "empty_octpet", "empty_payET", "empty_presant", "empty_payel", "empty_codet", "empty_packette", "empty_paye", "empty_pickpoint", "empty_pickel", "empty_maskpoint", "empty_octeter", "empty_buckacket", "empty_presacket", "empty_pacet", "empty_pickacket"], "packet_count": ["packacket_id", "packet__total", "packet_counter", "packacket_Count", "packet_id", "packacket_total", "packet_length", "packacket_count", "packacket_length", "packet__counter", "packet__Count", "packet__count", "packet_Count", "packet_total", "packacket_counter"], "err": ["Error", "code", "flag", " ptr", "resp", "ach", " res", "error", "act", "pos", "type", "ptr", "rr", "usr", " next", "r", "count", " error", "e", "line", " score", " fid", " resp", "str", " ok", "oe", "er", "coord"], "idx": ["obj", "cmp", "indxes", " ridex", "identex", "fp", " idch", " ridx", "identx", " riddx", "indxd", " idxes", "identxd", " idxd", "index", "cont", "_", " idn", "indn", "identn", " iddx", "iddx", "idch", " idex", "indch", "new", "idex", "c", " ridch", "identxes", "indx", "idxes", "inddx", "idxd", "idn"], "entry": ["existent", "key", "next", "id", "quick", "ie", "or", "counter", "meta", "ident", "enter", "ry", "error", "ex", "instance", "inter", "element", "index", "try", "row", "connection", "view", "new", "directory", "count", "nr", "exclusive", "primary", "mid", "query", "low", "member", "ent", "link", "result", "Entry"]}}
{"project": "FFmpeg", "commit_id": "0d021cc8b30a6f81c27fbeca7f99f1ee7a20acf8", "target": 0, "func": "static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)\n\n{\n\n    if (err != CUDA_SUCCESS) {\n\n        av_log(avctx, AV_LOG_FATAL, \">> %s - failed with error code 0x%x\\n\", func, err);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 11529, "substitutes": {"avctx": ["avekt", "avkt", " avcontext", " avgc", "wavca", "avecontext", " avkt", "wavctx", "AVctx", "AVcontext", "wavContext", " avContext", "avcontext", "wavgc", "AVca", "avgc", " avca", "avectx", "wavkt", "wavcontext", "avegc", "AVContext", "avContext", "avca"], "err": ["kr", "arr", "inner", "norm", "off", "ah", "status", "cmp", "Error", "code", "lr", "rb", "req", "rs", "ev", "proc", "resp", "ec", "buf", "error", "ex", "ERROR", "cur", "cer", "attr", "cb", "unc", "desc", "rr", "usr", "addr", "Er", "r", "n", "ctx", "rc", "nr", "e", "die", "c", "cmd", "fee", "res", "er", "diff", "result", "coord", "rank", "msg", "cv", "ner", "cr", "exc", "sys"], "func": ["lambda", "doc", "obj", "callback", "spec", "tx", "con", "proc", "var", "task", "f", "cf", "act", "pkg", "fun", "attr", "args", "cb", "unc", "cc", "util", "function", "package", "fn", "aux", "ctx", "impl", "cast", "comp", "fac", "cmd", "exec", "kw", "fc", "mac", "grid", "conv", "sys"]}}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    const AVCodec *dec;\n\n    char val_str[128];\n\n    const char *s;\n\n    AVRational sar, dar;\n\n    AVBPrint pbuf;\n\n\n\n    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);\n\n\n\n    print_int(\"index\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        const char *profile = NULL;\n\n        dec = dec_ctx->codec;\n\n        if (dec) {\n\n            print_str(\"codec_name\", dec->name);\n\n            if (!do_bitexact) {\n\n                if (dec->long_name) print_str    (\"codec_long_name\", dec->long_name);\n\n                else                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        } else {\n\n            print_str_opt(\"codec_name\", \"unknown\");\n\n            if (!do_bitexact) {\n\n                print_str_opt(\"codec_long_name\", \"unknown\");\n\n            }\n\n        }\n\n\n\n        if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile)))\n\n            print_str(\"profile\", profile);\n\n        else\n\n            print_str_opt(\"profile\", \"unknown\");\n\n\n\n        s = av_get_media_type_string(dec_ctx->codec_type);\n\n        if (s) print_str    (\"codec_type\", s);\n\n        else   print_str_opt(\"codec_type\", \"unknown\");\n\n        print_q(\"codec_time_base\", dec_ctx->time_base, '/');\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        print_str(\"codec_tag_string\",    val_str);\n\n        print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            print_int(\"width\",        dec_ctx->width);\n\n            print_int(\"height\",       dec_ctx->height);\n\n            print_int(\"has_b_frames\", dec_ctx->has_b_frames);\n\n            sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL);\n\n            if (sar.den) {\n\n                print_q(\"sample_aspect_ratio\", sar, ':');\n\n                av_reduce(&dar.num, &dar.den,\n\n                          dec_ctx->width  * sar.num,\n\n                          dec_ctx->height * sar.den,\n\n                          1024*1024);\n\n                print_q(\"display_aspect_ratio\", dar, ':');\n\n            } else {\n\n                print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n\n                print_str_opt(\"display_aspect_ratio\", \"N/A\");\n\n            }\n\n            s = av_get_pix_fmt_name(dec_ctx->pix_fmt);\n\n            if (s) print_str    (\"pix_fmt\", s);\n\n            else   print_str_opt(\"pix_fmt\", \"unknown\");\n\n            print_int(\"level\",   dec_ctx->level);\n\n            if (dec_ctx->timecode_frame_start >= 0) {\n\n                char tcbuf[AV_TIMECODE_STR_SIZE];\n\n                av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start);\n\n                print_str(\"timecode\", tcbuf);\n\n            } else {\n\n                print_str_opt(\"timecode\", \"N/A\");\n\n            }\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            s = av_get_sample_fmt_name(dec_ctx->sample_fmt);\n\n            if (s) print_str    (\"sample_fmt\", s);\n\n            else   print_str_opt(\"sample_fmt\", \"unknown\");\n\n            print_val(\"sample_rate\",     dec_ctx->sample_rate, unit_hertz_str);\n\n            print_int(\"channels\",        dec_ctx->channels);\n\n\n\n            if (dec_ctx->channel_layout) {\n\n                av_bprint_clear(&pbuf);\n\n                av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout);\n\n                print_str    (\"channel_layout\", pbuf.str);\n\n            } else {\n\n                print_str_opt(\"channel_layout\", \"unknown\");\n\n            }\n\n\n\n            print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            if (dec_ctx->width)\n\n                print_int(\"width\",       dec_ctx->width);\n\n            else\n\n                print_str_opt(\"width\",   \"N/A\");\n\n            if (dec_ctx->height)\n\n                print_int(\"height\",      dec_ctx->height);\n\n            else\n\n                print_str_opt(\"height\",  \"N/A\");\n\n            break;\n\n        }\n\n    } else {\n\n        print_str_opt(\"codec_type\", \"unknown\");\n\n    }\n\n    if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) {\n\n        const AVOption *opt = NULL;\n\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n\n            uint8_t *str;\n\n            if (opt->flags) continue;\n\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n\n                print_str(opt->name, str);\n\n                av_free(str);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n\n    else                                          print_str_opt(\"id\", \"N/A\");\n\n    print_q(\"r_frame_rate\",   stream->r_frame_rate,   '/');\n\n    print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/');\n\n    print_q(\"time_base\",      stream->time_base,      '/');\n\n    print_ts  (\"start_pts\",   stream->start_time);\n\n    print_time(\"start_time\",  stream->start_time, &stream->time_base);\n\n    print_ts  (\"duration_ts\", stream->duration);\n\n    print_time(\"duration\",    stream->duration, &stream->time_base);\n\n    if (dec_ctx->bit_rate > 0) print_val    (\"bit_rate\", dec_ctx->bit_rate, unit_bit_per_second_str);\n\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n\n    if (nb_streams_frames[stream_idx])  print_fmt    (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n\n    if (do_show_data)\n\n        writer_print_data(w, \"extradata\", dec_ctx->extradata,\n\n                                          dec_ctx->extradata_size);\n\n\n\n    /* Print disposition information */\n\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n\n    } while (0)\n\n\n\n    if (do_show_stream_disposition) {\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n\n    PRINT_DISPOSITION(DUB,              \"dub\");\n\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n\n    writer_print_section_footer(w);\n\n    }\n\n\n\n    show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n\n    fflush(stdout);\n\n}\n", "idx": 11535, "substitutes": {"w": ["write", "iw", "wal", "p", "we", "f", "W", "d", "rw", "wr", "g", "m", "l", "wx", "word", "wh", "window", "ew", "r", "wa", "n", "t", "v", "man", "self", "b", "c", "wp", "sw", "h", "wt", "hw", "kw", "x", "z", "writer", "nw", "wb"], "fmt_ctx": ["fmtPcontext", "fmt_rec", "ffm_context", "ffm_ctx", "fmt_cp", "ffm_tx", "fmtPctx", "fmt_obj", "ffm_cp", "flt_rec", "flt_context", "fmtPobj", "flt_ctx", "fmtPrec", "fmt_context", "flt_obj", "fmt_tx"], "stream_idx": ["stream_ridy", "stream_ridxf", "stream_indxf", "stream_ridx", "stream_ridxc", "stream_idg", "stream_indy", "stream_indg", "stream_iny", "stream_idn", "stream_idxf", "stream_idy", "stream_indn", "stream_inx", "stream_indx", "stream_indxc", "stream_idxc", "stream_inn", "stream_ing"], "in_program": ["in_video", "inmaybescript", "inplaceprogram", " in_Program", "in_embed", "inplaceresource", "inplacescript", "inmaybeProgram", "inplaceProgram", "inplaceembed", " in_script", "in_resource", " in_resource", " in_embed", "in_Program", "in_script", "inmaybeprogram", " in_video", "inmaybevideo", "inplacevideo"], "stream": ["sche", "sl", "each", "path", "sign", "REAM", "channel", "message", "hook", "wrapper", "download", "decl", "read", "ream", "seek", "valid", "ack", "form", "ec", "dev", "cf", "open", "Stream", "instance", "sam", "raw", "window", "clean", "chain", "row", "video", "data", "accept", "view", "feed", "transform", "host", "sw", "reader", "uu", "iterator", "serv", "ocr", "sc", "context", "time", "console", "draw", "length", "spect", "store"], "dec_ctx": ["dec5obj", "dec_kw", "Dec_handle", "dec_obj", "dec___pkg", "decolyctx", "dec2context", "dec_context", "decolytx", "dec___act", "decolyconn", "dec2cmp", "Dec_context", "dec2pop", "dec5list", "decptctx", "dec5kw", "dec5pop", "decl_ctx", "decl_obj", "Dec_tx", "dec2tx", "ec_obj", "Dec_kw", "dec_cmp", "Dec_act", "ec_context", "dec_pkg", "dec2conn", "dec___ctx", " dec_obj", " dec2cmp", "decptkw", "Dec_list", "ec_conn", "ec_cmp", " dec_pop", "dec_handle", "dec_pop", " dec_cmp", "ec_loc", "dec_list", "dec_act", " dec2obj", "ec_req", "ec_handle", "decl_tx", "dec2ctx", "dec_req", " dec2ctx", "dec5tx", "Dec_pkg", "decolycmp", "ec_ctx", "ec_kw", "dec___tx", "dec2obj", "ec_tx", "decpttx", "dec_conn", "dec_tx", "dec5cmp", "decl_context", "Dec_ctx", "dec5ctx", "decptcontext", "dec_loc", " dec2pop", "decptobj", "decpthandle"], "val_str": ["vals2res", "valpytxt", "val2res", "val9string", "vals2string", " val2int", "val2br", "val_buf", "valpystr", " val_arr", " val2Str", " val_txt", "val_int", "val2txt", "valPdef", "vals2def", "val2st", "val_st", "val_def", "val_arr", "valPbuf", " val_br", "vals2arr", "val2string", "valPstr", "vals_string", "val9def", "vals_def", " val_Str", "val2buf", "vals_arr", "val_res", " val_string", "val2arr", "val_Str", "vals_res", "val2int", " val2str", "val2Str", "val_br", " val2string", " val2txt", " val2arr", "val2str", "valPstring", "val2def", "valpyarr", "val9str", "valpyStr", "vals2str", "vals_st", " val_int", "vals_buf", "vals2buf", "vals_str", "val9buf", "val_txt", "val_string", " val2br", "vals2st"], "s": ["sq", "spec", "u", "sl", "gets", "a", "ats", "q", "rs", "hs", "p", "sp", "gs", "sts", "ps", "g", "m", "l", "cs", "ins", "sv", "i", "sam", "bs", "so", "r", "js", "series", "S", "ss", "ts", "n", "its", "t", "v", "https", "os", "b", "c", "h", "sa", "stats", "spe", "ns", "fs", "si", "sc", "set", "ls", "ims", "space", "ds"], "sar": ["svra", "Sra", "sra", "tra"], "dar": ["platform", "pas", "lan", "par", "star", "mar", "ara", "da", "car", "ram", "def", "rac", "pard", "family", "ta", "series", "PAR", "primary", "der", "dim", "AR", "mac", "camera", "raf", "pro", "rar", "ar", "dr"], "pbuf": ["spbuffer", "opuf", "opbuffer", "pbuff", "opbuf", " pbuff", "rbuff", "tbuffer", "opbuff", " pbuffer", "ruf", "pbuffer", "rbuf", "rbuffer", "spuf", "puf", " puf", "spbuff", "tbuff", "tuf", "spbuf", "tbuf"], "profile": ["platform", "key", "depth", "display", "filename", "prime", "ph", "gpu", "prof", "buffer", "username", "source", "policy", "pse", "PRO", "summary", "feature", "path", "sample", "history", "picture", "proc", "p", "pool", "prop", "frame", "slot", "program", "component", "vp", "character", "screen", "type", "face", "local", "port", "relation", "parent", "family", "property", "soc", "phy", "pen", "pr", "pl", "kh", "pro", "option", "cpu", "alias", "tag", "style", "context", "usage", "group", "user", "description", "name", "performance", "Profile", "role"]}}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n\n                            const uint32_t *quant) {\n\n    int coeff, i, n;\n\n    int8_t ac;\n\n    uint8_t dc = get_bits(gb, 8);\n\n\n\n    // block not coded\n\n    if (dc == 255)\n\n\n\n\n    // number of non-zero coefficients\n\n    coeff = get_bits(gb, 6);\n\n    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n\n\n\n\n    // normally we would only need to clear the (63 - coeff) last values,\n\n    // but since we do not know where they are we just clear the whole block\n\n    memset(block, 0, 64 * sizeof(DCTELEM));\n\n\n\n    // 2 bits per coefficient\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 2);\n\n        if (ac == -2)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 4 bits per coefficient\n\n    ALIGN(4);\n\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 4);\n\n        if (ac == -8)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 8 bits per coefficient\n\n    ALIGN(8);\n\n    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 8);\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    PUT_COEFF(dc);\n\n    return 1;\n\n}", "idx": 11543, "substitutes": {"gb": ["py", "gg", "goo", "mb", "bf", "google", "sky", "gh", "pc", "gif", "gm", "sync", "gp", "rb", "hub", "sg", "tg", "gs", "gov", "GB", "Gb", "ry", "pg", "bc", "mg", "g", "bm", "cb", " GB", "server", "bg", "eg", "gd", "bitcoin", "pb", "html", "phy", "gue", "ctx", "ssl", "rg", "cfg", "gu", "gc", "sb", "kb", "ym", "hw", "arb", "bb", "nb", "img", "gt", "db", "ib", "bt", "msg", "bridge", "hog", "sys", "vg"], "block": ["ml", "obj", "map", "buffer", "ch", "blocks", "base", "q", "axis", "list", "cl", "bl", "field", "bin", "unit", "bc", "ref", "bm", "local", "type", "zero", "lp", "mem", "Block", "chain", "row", "data", "box", "pb", "new", "cache", "b", "lock", "un", "set", "group", "pack", "BL", "byte", "out"], "scan": ["doc", "op", "pc", "map", "call", "sum", "feature", "form", "ach", "seq", "bin", "mic", "act", "tc", "ad", "cas", " dc", "rc", "cache", "scale", "fee", "sc", "mac", "aa", "access", "ann", "sys"], "quant": ["doc", "depth", "sq", "acc", "spec", "inc", "quick", "mult", "q", "form", "Quant", "cur", "desc", "wait", "util", "dq", "final", "frac", " dc", "good", "qi", "comp", "fac", "query", "comment", "dat", "ent", "quad", "draw"], "coeff": ["Coeffic", "foef", " Coefficient", "yeseff", "coeef", "COff", "coverage", "coff", "coneff", "yeseffic", "coeffic", " coef", "coxeffic", " Coff", " Coeff", "conefficient", "COverage", "foeffic", "coefficient", "COef", "COeff", "coxef", "coxeff", " coff", "COefficient", "coeverage", "Coef", " coefficient", "yesef", " Coef", "foeff", "foefficient", "coxefficient", "Coefficient", "Coeff", "converage", "conff", "yesff", "coeeff", " coeffic", "conef", "Coff", "COeffic", "coef"], "i": ["ai", "I", "k", "p", "f", "ind", "g", "m", "l", "ic", "index", "mi", "j", "ix", "y", "t", "ci", "v", "b", "c", "bi", "ij", "pi", "si", "x", "ii"], "n": ["len", "na", "num", "nan", "nm", "nl", "k", "p", "ne", "nt", "ni", "m", "l", "nn", "mn", "N", "fn", "count", "nr", "nat", "cn", "c", "sn", "ns", "nc", "nb", "no", "pn"], "ac": ["jac", "oc", "doc", "acc", "aco", "auc", "pc", "abc", " acc", "cam", " cac", "aca", "iac", "ec", "ach", "func", "ex", "mic", "sac", "bc", "dc", "act", "ip", "attr", "unc", "ic", "cc", "rac", "fa", "erc", "alpha", "mc", "pac", "cas", "cap", "acl", "cache", "ace", "c", "fac", "uc", "anc", "acs", "ric", "cu", "gam", "fc", "AC", "mac", "it", "Ac", "app", "aa", "vc", " lac", "ca"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n", "idx": 11546, "substitutes": {"t0": ["time01", "time1", "tc01", "v1", "dt0", " t2", " t9", "tc0", "p1", "p0", "th6", "t6", "T1", "T0", "th9", "t7", "T9", " tzero", "v2", "time0", "lt0", "lt7", "t2", "tzero", "p2", "t01", "T6", "v0", "dt7", "timeKey", "t9", " t6", "dtzero", "th0", "th1", "tKey", "tc1", "T01", "TKey", "tcKey", "ltzero", " t7"], "t1": ["tt0", "T2", "v1", " t2", " t9", "tc0", "p1", "T10", "tc2", "p0", " t10", "v3", "T1", "tt1", "T0", "Tone", "tt9", "pt3", "tOne", "pt0", "T9", " tone", "t10", "v2", "t2", "p2", "v0", "tone", "t9", "v9", " t3", "T3", "TOne", "p10", "vOne", "tt3", "t3", "tc1", "pt1", "tcOne", "ttone", "pt2"], "rd": ["td", "src", "rust", "dd", "rid", "hr", "tr", "fd", "rb", "rs", "ri", "rf", "rax", "ind", "ld", "d", "rw", "dx", "xd", "rob", "ra", "rn", "ptr", "rr", "rend", "dra", "r", "rl", "gd", "rx", "md", "rod", "rg", "reg", "rc", "new", "fr", "rh", "red", "rt", "re", "rm", "RD", "rer", "ru", "cr", "nd", "ds", "dr", "ird"], "tmp": ["tm", "td", "src", "tf", "tt", "py", "tr", "obj", "dd", "cmp", "mb", "tp", "buffer", "mm", "pp", "pt", "rb", "tk", "err", "proc", "sp", "rf", "resp", "nt", "nd", "rw", "pkg", "tc", "np", "jp", "attr", "gz", "null", "ptr", "sam", "vt", "rr", "txt", "r", "snap", "tem", "test", "data", "pb", "perm", "t", "ctx", "new", "tn", "rc", "v", "mk", "cache", "copy", "false", "rt", "temp", "etc", "st", "table", "rm", "nb", "tar", "buff", "db", "cv", "bt", "mp", "emp", "pro", "tz", "tv", "ret"]}}
{"project": "FFmpeg", "commit_id": "6722e564a82bac471d92b02550b5017c09b539ba", "target": 0, "func": "static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n\n{\n\n    if (buf_size < 13)\n\n        return AVERROR_INVALIDDATA;\n\n    if (memcmp(buf, \"FLV\", 3))\n\n        return AVERROR_INVALIDDATA;\n\n    buf      += 13;\n\n    buf_size -= 13;\n\n    while (buf_size >= 11 + 4) {\n\n        int type = buf[0];\n\n        int size = AV_RB24(&buf[1]) + 11 + 4;\n\n        if (size > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n        if (type == 8 || type == 9) {\n\n            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n\n                return AVERROR_INVALIDDATA;\n\n            os->extra_packet_sizes[os->nb_extra_packets] = size;\n\n            os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n\n            if (!os->extra_packets[os->nb_extra_packets])\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n\n            os->nb_extra_packets++;\n\n        } else if (type == 0x12) {\n\n            if (os->metadata)\n\n                return AVERROR_INVALIDDATA;\n\n            os->metadata_size = size - 11 - 4;\n\n            os->metadata      = av_malloc(os->metadata_size);\n\n            if (!os->metadata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->metadata, buf + 11, os->metadata_size);\n\n        }\n\n        buf      += size;\n\n        buf_size -= size;\n\n    }\n\n    if (!os->metadata)\n\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n\n}\n", "idx": 11553, "substitutes": {"os": ["ms", "dos", "reset", "mes", "o", "cs", "oid", "ans", "bits", "oos", "oops", "ones", "ands", "wcs", "ast", "OS", "ips", "ost", "ot", "options", "ims", "ports", "rots", "et", "at", "aos", "los", "bs", "plays", "js", "ss", "mos", "ops", "eas", "ows", "des", "ks", "ls", "oss", "otes", "mot", "css", "ants", "pos", "oS", "ns", "om", "rss", "ions", "ds", "oses", "windows", "obs", "io", "soft", "ack", "ps", "ok", "ox", "oids", "ros", "is", "bos", "loss", "boot", "Os", "acs", "stats", "cms", "fs", "res", "osi", "ons", "ose", "sys"], "buf": ["doc", "end", "alloc", "uv", "func", "prop", "Buffer", "block", "cat", "desc", "queue", "data", "cap", "env", "b", "cmd", "foo", "cv", "arr", "tr", "next", "read", "code", "uf", "rb", "iter", "bc", "limit", "ptr", "txt", "count", "cast", "que", "Buff", "ob", "batch", "pack", "bt", "img", "page", "buffer", "bp", "req", "err", "var", "cp", "vec", "cur", "ref", "raw", "window", "mem", "now", "tmp", "quote", "start", "bb", "bar", "len", "off", "aka", "p", "seq", "pkg", "cb", "port", "bytes", "addr", "br", "pb", "box", "rc", "v", "cache", "ctr", "h", "coord", "buff", "msg", "max", "length"], "buf_size": ["tab_size", "uf_Size", "uf_length", "uf_name", "buf_name", "buf_sent", " buf_max", "buf5SIZE", "buf_length", "bufptsize", "buf5sent", "buf_set", " buf_Size", "buf_num", "tab_ize", "tab5ize", " buf_member", "tab_SIZE", "tab5SIZE", " buf_len", "bufptsource", "bufptmax", "uf_set", "bufptSize", "buf_range", "buf_len", "tab5size", "buf_max", " buf_num", "buf_source", "buf_member", "tab_sent", "uf_ize", "buf_ize", " buf_source", "uf_SIZE", "buf_Size", "buf_SIZE", "buf5size", "uf_range", "tab5sent", "buf5ize", "uf_size"], "nb_extra_packets": ["nb_extra_packses", "nb_extra_peet", "nb_extra_itemsETS", "nb_extra_packseters", "nb_extra_itemset", "nb_extra_pents", "nb_extra_offsets", "nb_extra_offstons", "nb_extra_packETS", "nb_extra_preseters", "nb_extra_buckETS", "nb_extra_packet", "nb_extra_packset", "nb_extra_packeters", "nb_extra_presers", "nb_extra_offsents", "nb_extra_packers", "nb_extra_presents", "nb_extra_packstons", "nb_extra_popets", "nb_extra_buckessions", "nb_extra_offsETS", "nb_extra_peETS", "nb_extra_packtons", "nb_extra_popages", "nb_extra_preset", "nb_extra_pETS", "nb_extra_bucketers", "nb_extra_popet", "nb_extra_packents", "nb_extra_itemsets", "nb_extra_mixes", "nb_extra_itemstons", "nb_extra_popces", "nb_extra_pets", "nb_extra_peessions", "nb_extra_preses", "nb_extra_packsages", "nb_extra_packes", "nb_extra_packsces", "nb_extra_mixers", "nb_extra_exages", "nb_extra_packages", "nb_extra_peets", "nb_extra_packsers", "nb_extra_mixets", "nb_extra_buckets", "nb_extra_pet", "nb_extra_presETS", "nb_extra_offset", "nb_extra_packessions", "nb_extra_bucket", "nb_extra_mixet", "nb_extra_exets", "nb_extra_presets", "nb_extra_exces", "nb_extra_packsets", "nb_extra_packces", "nb_extra_packsessions", "nb_extra_packsETS", "nb_extra_exet"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n    __get_user(regs->CP0_EPC, &sc->sc_pc);\n\n\n\n    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);\n\n    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);\n\n\n\n    for (i = 1; i < 32; ++i) {\n\n        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);\n\n    }\n\n\n\n    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);\n\n    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);\n\n    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);\n\n    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);\n\n    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);\n\n    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);\n\n    {\n\n        uint32_t dsp;\n\n        __get_user(dsp, &sc->sc_dsp);\n\n        cpu_wrdsp(dsp, 0x3ff, regs);\n\n    }\n\n\n\n    for (i = 0; i < 32; ++i) {\n\n        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);\n\n    }\n\n\n\n    return err;\n\n}\n", "idx": 11566, "substitutes": {"i": ["u", "ie", "o", "m", "im", "y", "t", "ci", "zi", "gi", "pi", "oi", "ji", "ims", "history", "ami", "I", "li", "uri", "init", "fire", "ri", "ex", "ind", "g", "ti", "mi", "ix", "xi", "multi", "qi", "e", "any", "si", "batch", "id", "ai", "ei", "go", "iq", "point", "f", "ui", "ip", "my", "ic", "in", "index", "chain", "\u0438", "phi", "info", "gu", "remote", "it", "ini", "ii", "me", "io", "q", "list", "complete", "p", "sim", "this", "port", "json", "cli", "us", "j", "iu", "v", "bi", "di", "php", "x", "mac", " ii", " j"], "dsp": ["dnsp", "dnlp", "llp", "dnbsp", "rdsi", " dbsp", "dbsp", "dsi", "lSP", " dlp", "rdSP", " dsi", "dSP", "dsw", "dspe", " dSP", " dspe", "rdsp", " dsw", "rdsw", "dnSP", "dnsi", "dlp", "rdspe", "nsp", "nSP", "rdlp", "nsw", "lbsp", "lsp", "nspe"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_block_to_card(SDHCIState *s)\n\n{\n\n    int index = 0;\n\n\n\n    if (s->prnsts & SDHC_SPACE_AVAILABLE) {\n\n        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n            s->norintsts |= SDHC_NIS_WBUFRDY;\n\n        }\n\n        sdhci_update_irq(s);\n\n        return;\n\n    }\n\n\n\n    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n        if (s->blkcnt == 0) {\n\n            return;\n\n        } else {\n\n            s->blkcnt--;\n\n        }\n\n    }\n\n\n\n    for (index = 0; index < (s->blksize & 0x0fff); index++) {\n\n        sd_write_data(s->card, s->fifo_buffer[index]);\n\n    }\n\n\n\n    /* Next data can be written through BUFFER DATORT register */\n\n    s->prnsts |= SDHC_SPACE_AVAILABLE;\n\n\n\n    /* Finish transfer if that was the last block of data */\n\n    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n            ((s->trnmod & SDHC_TRNS_MULTI) &&\n\n            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n        s->norintsts |= SDHC_NIS_WBUFRDY;\n\n    }\n\n\n\n    /* Generate Block Gap Event if requested and if not the last block */\n\n    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&\n\n            s->blkcnt > 0) {\n\n        s->prnsts &= ~SDHC_DOING_WRITE;\n\n        if (s->norintstsen & SDHC_EISEN_BLKGAP) {\n\n            s->norintsts |= SDHC_EIS_BLKGAP;\n\n        }\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n}\n", "idx": 11592, "substitutes": {"s": ["ms", "events", "vs", "parts", "ats", "span", "hs", "cs", "m", "esm", "bits", "details", "r", "se", "y", "t", "sports", "os", "ears", "b", "w", "serv", "comm", "ims", "ers", "ports", "gets", "source", "tests", "gs", "sts", "ex", "changes", "ies", "sv", "args", "ses", "mods", "xs", "bs", "services", "less", "js", "als", "ss", "conf", "sb", "z", "ls", "states", "params", "sq", "obj", "qs", "rs", "err", "as", "es", "i", "terms", "in", "ts", "n", "sw", "ns", "er", "ds", "comments", "sync", "eps", "p", "an", "uploads", "ps", "south", "service", "us", "aws", "is", "S", "its", "v", "search", "bis", "h", "acs", "stats", "fs", "stat", "set", "sys", "store"], "blkcnt": ["blkcaught", "blkfcount", "blkcachent", "blkgncent", "blkscst", "blkgcaught", "blkCtx", "blkdcount", "blkctx", "blckCnt", "blkcent", "blkCgt", "blkcount", "blkscnt", "blksCount", "blkncaught", "blkncounters", "blkfcnc", "blkcounters", "blkcuraught", "blknnc", "blknnt", "blkgcounters", "blkmount", "blckcgt", "blkntx", "blkcountount", "blkdcnt", "blkcountnc", "blksCnc", "blkcacheaught", "blkdcnc", "blkCst", "blkcurnt", "blknount", "blkcacheent", "blkcst", "blksCnt", "blkfcst", "blksctx", "blkcurounters", "blckcnc", "blkgncaught", "blckcnt", "blkCnt", "blkcountnt", "blksCtx", "blkncnt", "blkdcgt", "blkcurent", "blkcgt", "blkgcnt", "blkmnt", "blckCnc", "blkscnc", "blkcnc", "blckCount", "blkcacheounters", "blkmnc", "blckCgt", "blkgcent", "blkncent", "blkscount", "blckcount", "blkcountst", "blkgncounters", "blkCount", "blkgncnt", "blkCnc", "blkmgt", "blksCst", "blkfcnt"], "index": ["key", "select", "num", "empty", "prime", "ice", "address", "buffer", "where", "column", "thread", "update", "seek", "axis", "IND", "point", "ex", "ind", "error", "eight", "open", "instance", "label", "location", "condition", "pos", "capacity", "face", "zero", "position", "i", "length", "loop", "mix", "handle", "connect", "row", "Index", "ix", "level", "connection", "check", "count", "date", "primary", "EX", "lock", "alias", "x", "context", "set", "time", "head", "max", "loc", "offset", "size", "foot", "find", "number"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=qcow2\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}\n", "idx": 11608, "substitutes": {"s": ["ms", "ports", "sq", "vs", "sync", "sl", "qs", "a", "ats", "q", "rs", " is", "hs", "p", "gs", "sp", "sts", "sm", "sub", "ps", "changes", "d", "g", "cs", "m", "l", "sv", "i", "ses", "sam", "es", "bs", "so", "r", "less", "js", "is", "S", "ss", "ts", "n", "y", "its", "j", "t", "v", "sb", "b", "c", "sh", "sw", "h", "sa", "ns", "stats", "fs", "comm", "set", "ls", "sd", "ds", "su"], "cli": ["command", "qq", "path", "ctrl", "prefix", "li", "uri", "tk", "iq", "nu", "p", "cl", "seq", "lu", "fp", "ui", "ni", "cp", "prot", "ip", "tc", "client", "gz", "exe", "i", "cb", "ctl", "shell", "txt", "cci", "mi", "qt", "phy", "ci", "lc", "cfg", "chip", "multi", "c", "cmd", "bi", "cm", "cgi", "eric", "cu", "pi", "ls", "hi", "ii", "ico"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n", "idx": 11624, "substitutes": {"as": ["ms", "asha", "pas", "nas", "ares", "AS", "a", "ats", "aos", "ars", "rs", "ak", "ar", "asm", "ras", "ass", "ps", "sac", "ase", "ins", "mas", "auth", "bs", "us", "aus", "las", "aws", "ias", "js", "is", "ts", "asis", "ais", "asar", "ast", "os", "has", "sa", "ns", "acs", "asia", "As", "ask", "sis", "s", "oss", "ds", "am", "sys", "pa"], "d": ["dd", "dos", "amd", "fd", "dr", "p", "o", "od", "ld", "ded", "mad", "g", "pd", "da", "del", "dc", "m", "l", "dis", "i", "did", "D", "dn", "dra", "md", "gd", "de", "n", "ad", "dl", "e", "b", "c", "du", "dx", "des", "di", "dat", "bd", "w", "disc", "dot", "db", "ade", "dh", "dj", "nd", "ds", "sd"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "mst_fpga_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\treturn s->leddat1;\n\n\tcase MST_LEDDAT2:\n\n\t\treturn s->leddat2;\n\n\tcase MST_LEDCTRL:\n\n\t\treturn s->ledctrl;\n\n\tcase MST_GPSWR:\n\n\t\treturn s->gpswr;\n\n\tcase MST_MSCWR1:\n\n\t\treturn s->mscwr1;\n\n\tcase MST_MSCWR2:\n\n\t\treturn s->mscwr2;\n\n\tcase MST_MSCWR3:\n\n\t\treturn s->mscwr3;\n\n\tcase MST_MSCRD:\n\n\t\treturn s->mscrd;\n\n\tcase MST_INTMSKENA:\n\n\t\treturn s->intmskena;\n\n\tcase MST_INTSETCLR:\n\n\t\treturn s->intsetclr;\n\n\tcase MST_PCMCIA0:\n\n\t\treturn s->pcmcia0;\n\n\tcase MST_PCMCIA1:\n\n\t\treturn s->pcmcia1;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_readb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \" \\n\", addr);\n\n\t}\n\n\treturn 0;\n\n}\n", "idx": 11631, "substitutes": {"s": ["ats", "o", "d", "m", "ins", "ocks", "r", "rows", "t", "ands", "os", "alls", "w", " results", "ents", "rates", "resses", "ums", "ers", "eds", " values", "ports", "acts", "gs", "sts", "g", "outs", "ies", "umps", "als", "js", "erences", "ss", "sets", "e", "sb", "ests", "ls", "itions", "aces", "sq", "ists", "a", "rs", " ads", "izes", "ants", "i", "ts", "ations", "n", "ails", "ns", "ions", "ds", "aches", "ments", "iffs", "ords", "p", "ps", " returns", "ains", " outputs", "j", "S", "ries", "its", " sets", "ches", "v", "ves", "c", "h", " parts", "fs", "parts"]}}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix_ide_initfn(PCIIDEState *d)\n\n{\n\n    uint8_t *pci_conf = d->dev.config;\n\n\n\n    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode\n\n    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);\n\n\n\n    qemu_register_reset(piix3_reset, d);\n\n\n\n    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);\n\n\n\n    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);\n\n\n\n    pci_piix_init_ports(d);\n\n\n\n    return 0;\n\n}\n", "idx": 11635, "substitutes": {"d": ["dd", "dos", "fd", "q", "nd", "p", "o", "dev", "ind", "ld", "da", "dx", "dc", "g", "pd", "m", "l", "del", "did", "dn", "D", "ord", "r", "md", "j", "de", "done", "n", "dl", "ad", "t", "dom", "v", "e", "b", "c", "h", "di", "dat", "w", "bd", "des", "db", "dict", "dm", "dh", "s", "sd", "dt", "ds", "dr"], "pci_conf": ["pki_conf", "pcm_conn", "pcm_cfg", "pki_config", "pci_conn", "pct_conf", "pcm_conf", "pct_con", "pci__config", "pci_map", "pci_con", "pki_map", "pci_config", "pki_con", "pci_cfg", "pcm_config", "pci__cfg", "pci__conf", "pct_config", "pci_fab", "pci__conn", "pct_fab"]}}
{"project": "qemu", "commit_id": "da3e8a23492dbc13c4b70d90b6ae42970624e63a", "target": 0, "func": "static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    DeviceState *qdev = DEVICE(vpci_dev);\n\n    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);\n\n    virtio_net_set_netclient_name(&dev->vdev, qdev->id,\n\n                                  object_get_typename(OBJECT(qdev)));\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 11641, "substitutes": {"vpci_dev": ["vpci1Dev", "vpcci_dev", "vpci1dev", "vpci___pub", "vpii___des", "vpci___info", "vpci___conn", "vpci_Dev", "vpci_device", "vpci_info", "vpci___device", "vpci_val", "vpci_cmd", "vpii___cur", "vpii_cmd", "vpc_info", "vpcci_Dev", "vpc_Dev", "vpii_conn", "vpci___des", "vpci___dec", "vpii_pub", "vpii_cur", "vpii_des", "vpii___conn", "vpc_device", "vpci___Dev", "vpc_dev", "vpci_dec", "vpci___cur", "vpci_cur", "vpci_des", "vpcci_device", "vpci_conn", "vpci_pub", "vpii_dec", "vpci___dev", "vpcci_ver", "vpcci_val", "vpci1device", "vpci1info", "vpcci_server", "vpii___dev", "vpci___cmd", "vpii_dev", "vpci_server", "vpci_ver"], "errp": ["errr", " errps", " errwp", "err", "errwp", "rrping", "errpb", "rrr", "rrp", " errping", "erP", "riskp", "erp", " errpb", "riskps", "riskwp", "errps", "Erpb", "Erps", " errr", "errping", " errP", "Erp", "Erwp", "rrP", "errP", "riskpb", "erping"], "qdev": ["qdiv", "qqdata", "qudev", "qumd", "eqdiv", "qqgu", "qudevice", "qqdev", "qvdiv", "qvgu", "eqdev", "querymd", "dqdiv", "dqdevice", "querydev", "qqmd", "qgu", "qvdev", "qudata", "qvgo", "dqdev", "qgo", "iqgo", "iqdev", "qdevice", "querydevice", "iqdiv", " qdiv", "qmd", "iqgu", " qdevice", "qqdiv", "qdata", "eqdevice", "qqgo", "qqdevice", "querydata"], "dev": ["doc", "dd", "priv", "device", "cam", "go", "ev", "det", "ve", "var", "adv", "buf", "d", "eng", "del", "def", "local", "attr", "raw", "ver", "window", "mem", "develop", "cho", "de", "data", "test", "dem", "DEV", "conn", "v", "conf", "wd", "gu", "die", "env", "val", "Dev", "cmd", "des", "hw", "w", "serv", "att", "debug"], "vdev": ["qde", " vDev", " vdef", "cdev", "wDev", "vtde", "wapp", "vtdev", "vtvalid", "vde", "vtdevice", "wdev", "vdevice", "vvar", " vvalid", "mvar", "mdef", "cdevice", "qapp", "qdef", "svDev", "vvalid", " vgo", " vde", "evgo", "evdev", "qgo", "pdevice", "qev", "pgo", "vgo", "qcast", " vdevice", " vvar", "svvar", "wcast", "mDev", "vev", "pdev", "qvar", "qdevice", "evdef", "svdevice", "mdev", " vev", "qvalid", "vdef", "vapp", "mgo", "vDev", "cDev", " vapp", "cvar", "pdef", " vcast", "vcast", "qDev", "mdevice", "evvar", "wev", "svdev", "wdevice"]}}
{"project": "qemu", "commit_id": "052495178821fdc97b4125a8677c1b68eb458db9", "target": 0, "func": "static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n    int ret;\n\n\n\n    if (nvram->blk) {\n\n        nvram->size = blk_getlength(nvram->blk);\n\n\n\n        ret = blk_set_perm(nvram->blk,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,\n\n                           BLK_PERM_ALL, errp);\n\n        if (ret < 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n    }\n\n\n\n    nvram->buf = g_malloc0(nvram->size);\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        error_setg(errp, \"spapr-nvram must be between %d and %d bytes in size\",\n\n                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return;\n\n    }\n\n\n\n    if (nvram->blk) {\n\n        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);\n\n\n\n        if (alen != nvram->size) {\n\n            error_setg(errp, \"can't read spapr-nvram contents\");\n\n            return;\n\n        }\n\n    } else if (nb_prom_envs > 0) {\n\n        /* Create a system partition to pass the -prom-env variables */\n\n        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);\n\n        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],\n\n                                         nvram->size - MIN_NVRAM_SIZE / 4);\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_NVRAM_FETCH, \"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(RTAS_NVRAM_STORE, \"nvram-store\", rtas_nvram_store);\n\n}\n", "idx": 11642, "substitutes": {"dev": ["usb", "priv", "device", "cam", "ev", "proc", "p", "ach", "adv", "pad", "d", "grad", "def", "serial", "ver", "mem", "md", "de", "data", "ad", "phy", "dem", "DEV", "conn", "v", "Dev", "cmd", "Device", "pro", "hw", "w", "serv", "att", "disk", "iv", "sd", "nv"], "errp": ["errr", "rrpad", "errpad", "ererp", "scoreP", "ererping", "errpe", "err", "erpy", "erps", "errorpg", "rrping", "errpb", "rrr", "errorP", " errpg", "iterps", "rrp", "scorepb", "iterpad", "ererr", "iterping", "erP", "rrpy", "erp", "ererpad", " errpb", "dieP", "ererps", "iterp", "errorpb", "errorp", "scorepg", "errps", " errr", "errping", " errP", "diep", "ererpy", "diepe", "errpg", "rrps", "errP", "errpy", "erpe", "dier", "scorep", " errpe"], "nvram": ["cvroy", "uvcam", "nvlamm", "svdim", "navram", "svrum", "nvmm", "uvrum", "nwsam", "cvlamm", "nvrom", " svram", "navyan", "nvscan", "vcrix", " svcam", "uvmm", "nvgam", "nvsam", "cvgram", "svsam", "NVscan", "uvgram", "navcam", "naviam", "vcrom", "nwrom", "vciam", "npyan", "nnrum", "svcam", "vcgram", "uvnam", "nvroy", "cviam", "vcsam", "navgram", "vcrem", "navrom", "nvlim", "svroy", "npcam", "nngram", "uvsam", "uvlim", "nvyan", "cvscan", " svrum", "cvnam", "vcma", "nvrix", "nvrum", "svmm", "nwiam", "sviam", "cvrem", "cvmm", "uvscan", "vccam", "npgram", "navrix", "NVrom", "nvcam", "svrix", "vcdim", "vclamm", "uviam", "navsam", "nviam", "NVram", "svnam", "nwmem", "cvyan", "NVlamm", "svram", "navmem", "svrom", "nnrom", "navmm", "vcarma", "cvsam", "cvrum", "nvmem", "navlim", "svgam", "cvarma", "nwram", "nwgram", "cvlim", "cvcam", "svrem", "nvnam", "npram", "navma", "NViam", " svgram", "NVcam", "nvrem", "cvram", "vcscan", "vcmm", "uvroy", "navarma", "NVgam", "nnram", "npiam", "cvrom", "nprom", "uvrom", "svmem", "cvdim", "NVgram", "cvma", "nvarma", "vcgam", "navrum", "uvram", "nvma", "nvdim", "nvgram", "svgram", "vcram"], "ret": ["ert", "len", "tr", "success", "reset", "back", "flag", "err", "print", "det", "RET", "f", "reply", "nt", "ref", " Ret", "mt", "fun", "pret", "after", " alt", "alt", "ter", "ext", "r", "try", "t", "rem", "rets", "reg", "deg", "val", "Ret", "xt", "red", "cmd", "rt", "re", "elt", "res", "cert", "ft", "gt", "Return", "out"]}}
{"project": "qemu", "commit_id": "4b63a0df3bda8a2c278e45d9d94d9ba6d5791d8d", "target": 1, "func": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n", "idx": 11646, "substitutes": {"p": ["command", "process", "op", "power", "pc", "tp", "pat", "part", "at", "a", "pp", "pt", "bp", "ping", "q", "req", "proc", "sp", "post", "rep", "f", "o", "cp", "ps", "fp", "d", "vp", "pkg", "m", "jp", "ap", "np", "l", "press", "i", "progress", "port", "local", "request", "lp", "r", "pers", "pm", "j", "n", "pb", "y", "P", "t", "v", "cache", "b", "c", "wp", "h", "w", "temp", "pi", "php", "x", "z", "att", "comm", "app", "pre", "pa"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstU, dstV, src1, width);\n\n}\n", "idx": 11662, "substitutes": {"dstU": [" dndU", "sndG", "sstG", "dstA", "destU", "dstsP", "sndUV", "sndV", "dstsUp", "sstV", "dstG", "dSTUV", "dstsA", "sstU", "dndV", " dndUp", "sstUV", "dptUV", "dstUp", "dndUp", "dndP", "destA", " dstA", "dptV", "dstsU", "dndA", "dSTV", "dndUV", "dstUV", "dstP", "destUp", "dSTG", "dptU", " dndP", "dSTU", "dndU", "dptG", "sndU", " dndA", " dstUp", " dstP", "dndG", "destP"], "dstV": ["dsetL", "dstL", "dsrcV", "ddestN", "DestV", "ddestL", "dsrcL", "destU", "dstVO", "dsetV", "destVO", "DestUV", "DstN", "DstL", "DstV", " destV", "destL", "destV", "dntU", " dstVO", "dsrcN", "dstN", "ddestV", " destL", "dsrcUV", "dntL", "destN", " destU", "dsetVO", "destUV", "dstUV", " dstL", "dntVO", "ddestUV", "DstUV", "dntV", "DestN", " destVO", "DestL", "dsetU"], "src1": ["rcOne", "source2", "rc1", "sourceOne", " srcOne", "src01", " src0", "src0", " src01", "source1", "rc0", "rc2", "source01", "srcOne", "source0", "rc01"], "src2": ["rc1", "rc3", "srcB", " srcB", "rc2", "source3", "source2", " src3", "src3", "sourceB", "source1", "rcB"], "unused": ["unalUsed", "unaluse", "unUsed", " unavailable", "UnUsed", " unuse", "unalavailable", "unuse", "Unused", "Unavailable", " unUsed", "unalused", "Unuse", "unavailable"]}}
{"project": "FFmpeg", "commit_id": "30e256430eb88c6d4c382581b89bca171d79fbc0", "target": 0, "func": "int ff_thread_init(AVCodecContext *avctx)\n\n{\n\n    if (avctx->thread_opaque) {\n\n        av_log(avctx, AV_LOG_ERROR, \"avcodec_thread_init is ignored after avcodec_open\\n\");\n\n        return -1;\n\n    }\n\n\n\n#if HAVE_W32THREADS\n\n    w32thread_init();\n\n#endif\n\n\n\n    if (avctx->codec) {\n\n        validate_thread_parameters(avctx);\n\n\n\n        if (avctx->active_thread_type&FF_THREAD_SLICE)\n\n            return thread_init(avctx);\n\n        else if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            return frame_thread_init(avctx);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11665, "substitutes": {"avctx": [" avcontext", "avconn", "avecontext", "avsys", "avectr", "avesys", "avcmd", "afcall", "svpool", "averct", "averctx", "averjac", "avejac", "avcrit", "avetx", "avecrit", "avcall", "wavkl", "avepkg", "iqct", "aftx", "faxtx", "iqctx", "afsys", "wavctx", "AVctx", "svctx", "avcontext", "afconn", "afcaps", "avercontext", "AVkl", "averkw", "avjp", "cvcontext", "avectx", " avconn", "afctr", " avtx", "avercmd", "svtx", "avecaps", "averkl", "wavtx", "avejp", "avkt", "avercrit", "avctl", "afctx", "averctl", "avekw", "averconn", "afpool", "cvkt", "faxctx", "cvctx", "avct", "AVctl", "svcontext", "wavcmd", "wavctl", "afcontext", "wavcontext", "avjac", "avcaps", "averjp", " avkt", "avepool", " avpkg", "faxcaps", "avkl", "averpkg", " avkw", "iqsys", "aversys", "faxcall", "iqcrit", "AVcmd", "avpool", "avctr", "avkw", "wavkt", "cvtx", " avjac", "avertx", "averctr", "avpkg", "avtx", " avjp", "avect", "avecall"]}}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 11674, "substitutes": {"mr": ["tm", "ms", "kr", "MT", "ml", "lt", "tr", "hr", "hm", "rpm", "nm", "mx", "mm", "gm", "rs", "older", "asm", "rar", "wr", "m", "bm", "rn", "MR", "drm", "shr", "mn", "rr", "adr", "r", "md", "pm", "br", "rg", "irm", "nr", "pr", "mk", "ctr", "sr", "RM", "ocr", "rm", "vr", "km", "ims", "Mr", "dr", "mt"], "is_write": ["flag_post", "flagpubwrit", "ispubpost", "flagpubwrite", "flag_writ", "Is_send", "flag_writing", "Is_written", "Is_only", "ispubwrit", "flagpubwriting", "is_post", "ispubwriting", "is_only", "is_control", "flag_write", "is_writing", "Is_control", "is_send", "is_writ", "is_written", "flagpubpost", "Is_write", "Is_read", "ispubwrite", "is_read"]}}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!blk->serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(blk->conf.bs);\n\n        if (*dinfo->serial) {\n\n            blk->serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 11685, "substitutes": {"dev": ["obj", "priv", "av", "device", "cam", "ev", "ve", "buf", "adv", "pad", "nt", "d", "block", "def", "dis", "ver", "mem", "js", "de", "data", "ad", "dem", "DEV", "conn", "v", "conf", "info", "gu", "env", "val", "tech", "Dev", "sh", "cmd", "des", "hw", "w", "res", "link", "db", "vr", "iv", "disk", "sd", "pro", "out"], "blk": ["blkg", "plk", "llck", " blj", "slc", "plK", "slkg", "sln", "BLke", "Blke", "blockck", "slg", " blark", "BLk", "blark", "slck", "Blck", "blkt", "bleK", "blg", "Blak", "BLK", "Blkid", "blkw", "plak", "blb", "Blg", "plc", "chk", "blej", "blockark", "slkt", "blck", "pln", "llak", "llk", " blke", "BLck", "bleak", "blek", " blkid", "bln", "bkg", "blak", "belkw", "blockak", "BLkw", "slk", "Bln", "bleke", "blK", "Blj", "chb", "plck", "blockk", "blke", "belak", "Blk", "bleck", "plg", " blak", "bck", "bb", "blc", "Blc", " blkt", "blekid", "llke", "belck", "blj", "plark", "bk", "chck", " blkw", "BLark", " blck", "belk", " blb", "BLak", " blkg", "blkid", "bkt", "bkw", "chkw"], "s": ["ms", "vs", "ats", "hs", "d", "cs", "m", "bits", "ins", "details", "r", "http", "se", "y", "sports", "t", "os", "b", "w", "serv", "comm", "ims", "sd", "ports", "gets", "source", "settings", "tests", "sp", "gs", "sts", "changes", "g", "sv", "args", "ses", "utils", "bs", "services", "less", "js", "als", "ss", "conf", "sb", "des", "ls", "params", "spec", "sl", "qs", "a", "rs", "as", "es", "i", "ts", "n", "views", "ns", "ds", "simple", "sync", "p", "ps", "south", "us", "aws", "is", "j", "S", "its", "self", "v", "https", "c", "bis", "h", "stats", "fs", "actions", "set"], "cylinders": ["cylsers", "shellinders", "ylriers", "shellriers", "bilinders", "clikes", "shellicans", "bilcles", "bilsers", "ylicans", "cylcles", "solidsers", "clcles", "ylinders", "cylikes", "chelinders", "clsers", "solidcles", "solidinders", "chelicans", "solidikes", "chelriers", "cylriers", "clinders", "cylicans", "bilikes"], "heads": ["thens", "locks", "ths", "aunts", " hangs", "tails", "blocks", "olds", "quarters", "HEAD", "uploads", "offs", "guards", "tips", "bs", "inks", "cycles", "links", " Heads", " bends", "views", "rows", "cles", "storms", "ads", "headed", "reads", "stocks", "anches", "hops", "headers", "loads", "nuts", "uds", "masters", "head", "hz", "mers", "helps"], "secs": ["reqls", "reqns", " secns", "reqts", "secondsls", "rupts", "ruptls", " secis", "Secls", "secns", "Secps", " secps", " secls", "ruptps", " sects", "secondsns", "reqs", "secondss", "sects", "secondsts", "secps", "secis", "secls", "Secs", "ruptis", "Secis"], "virtio_blk_id": ["virtio_blck_i", "virtio_blk_name", "virtio_blk_ref", "virtio_blk__no", "virtio_block_no", "virtio_blkPnum", "virtio_block_ref", "virtio_blck_no", "virtio_blk__ref", "virtio_blkPi", "virtio_blkPid", "virtio_block_name", "virtio_block__ref", "virtio_blk_no", "virtio_blck_id", "virtio_block__name", "virtio_blk__id", "virtio_blk__name", "virtio_blck_num", "virtio_block__no", "virtio_block_id", "virtio_blk_i", "virtio_blkPno", "virtio_block__id", "virtio_blk_num"], "dinfo": ["dsinformation", "edinformation", "rinfo", "finf", " dfo", "edinfo", " dinformation", "finfo", "dsinfo", "bdfo", "dbdetails", "dentry", "dbinfo", "dsinf", "dinf", "sdfo", "bddetails", "dbentry", "finformation", "sdinf", "bdpi", "sdinformation", "rinf", " dpi", " dinf", "dsfo", "edentry", "sdinfo", "dfo", "bdinformation", "bdinfo", "ddetails", "rpi", "ffo", "bdinf", "dinformation", "rfo", "dpi", "bdentry", "dbinformation", "eddetails"]}}
{"project": "FFmpeg", "commit_id": "e048a9cab10f1d41dca7b1ad9c8ecaceb3424d86", "target": 1, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    PCMDecode *s = avctx->priv_data;\n    int sample_size, c, n, i;\n    short *samples;\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n    uint8_t *dstu8;\n    int16_t *dst_int16_t;\n    int32_t *dst_int32_t;\n    int64_t *dst_int64_t;\n    uint16_t *dst_uint16_t;\n    uint32_t *dst_uint32_t;\n    samples = data;\n    src = buf;\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n        return -1;\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n        return -1;\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n        /* 2 samples are interleaved per block in PCM_DVD */\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n        /* we process 40-bit blocks per channel for LXF */\n        sample_size = 5;\n    n = avctx->channels * sample_size;\n    if(n && buf_size % n){\n        if (buf_size < n) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n            return -1;\n        }else\n            buf_size -= buf_size % n;\n    buf_size= FFMIN(buf_size, *data_size/2);\n    *data_size=0;\n    n = buf_size/sample_size;\n    switch(avctx->codec->id) {\n    case CODEC_ID_PCM_U32LE:\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_U32BE:\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_S24LE:\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_S24BE:\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_U24LE:\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_U24BE:\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_S24DAUD:\n        for(;n>0;n--) {\n          uint32_t v = bytestream_get_be24(&src);\n          v >>= 4; // sync flags are here\n          *samples++ = av_reverse[(v >> 8) & 0xff] +\n                       (av_reverse[v & 0xff] << 8);\n        break;\n    case CODEC_ID_PCM_S16LE_PLANAR:\n        n /= avctx->channels;\n        for(c=0;c<avctx->channels;c++)\n            src2[c] = &src[c*n*2];\n        for(;n>0;n--)\n            for(c=0;c<avctx->channels;c++)\n                *samples++ = bytestream_get_le16(&src2[c]);\n        src = src2[avctx->channels-1];\n        break;\n    case CODEC_ID_PCM_U16LE:\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_U16BE:\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_S8:\n        dstu8= (uint8_t*)samples;\n        for(;n>0;n--) {\n            *dstu8++ = *src++ + 128;\n        samples= (short*)dstu8;\n        break;\n#if HAVE_BIGENDIAN\n    case CODEC_ID_PCM_F64LE:\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_F32LE:\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16LE:\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64BE:\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n    case CODEC_ID_PCM_S16BE:\n#else\n    case CODEC_ID_PCM_F64BE:\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16BE:\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64LE:\n    case CODEC_ID_PCM_F32LE:\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_S16LE:\n#endif /* HAVE_BIGENDIAN */\n    case CODEC_ID_PCM_U8:\n        memcpy(samples, src, n*sample_size);\n        src += n*sample_size;\n        samples = (short*)((uint8_t*)data + n*sample_size);\n        break;\n    case CODEC_ID_PCM_ZORK:\n        for(;n>0;n--) {\n            int x= *src++;\n            if(x&128) x-= 128;\n            else      x = -x;\n            *samples++ = x << 8;\n        break;\n    case CODEC_ID_PCM_ALAW:\n    case CODEC_ID_PCM_MULAW:\n        for(;n>0;n--) {\n            *samples++ = s->table[*src++];\n        break;\n    case CODEC_ID_PCM_DVD:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        switch (avctx->bits_per_coded_sample) {\n        case 20:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n                src = src8;\n            break;\n        case 24:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                src = src8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n            return -1;\n            break;\n        samples = (short *) dst_int32_t;\n        break;\n    case CODEC_ID_PCM_LXF:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        //unpack and de-planerize\n        for (i = 0; i < n; i++) {\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract low 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract high 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n        src += n * avctx->channels * 5;\n        samples = (short *) dst_int32_t;\n        break;\n    default:\n        return -1;\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n    return src - buf;", "idx": 11712, "substitutes": {"avctx": ["afkw", "wavcfg", " avcontext", "avconn", "avecontext", "avercmp", "vrpkg", "averconfig", "avsys", "abconn", "avesys", "avcmd", "avaddr", "ajcu", "vrctl", "abcu", "afconfig", " avconf", "navjp", "abctl", "averctx", "avcmp", "averjac", "ajconn", "navkl", "avercfg", "avetx", "avpid", "avepkg", "navcfg", "aftx", "vrconfig", "avectl", "wavctx", "avconf", "ajpkg", "navctx", "AVctx", "avcontext", "vrctx", "navkw", "aveaddr", "averkw", "avjp", "ajpid", "ajctx", "avconfig", "avekl", "avectx", "avepid", "ajtx", "aveconfig", " avconn", "afcmp", "ajctl", "averaddr", "avcfg", "afcfg", "ajcontext", " avtx", "aveca", "avresp", "wavtx", "avcu", "avejp", " avcmd", "ajcfg", "avctl", "wavconfig", "afctx", "avekw", "AVtx", " avkj", "abconf", "vrtx", "AVcontext", "abctx", "averresp", "abca", "avecmd", "avkj", "aveobj", "vrkl", "avekj", "AVctl", "awresp", "wavcmd", " avcfg", "ajsys", "aveconf", "wavctl", "avobj", "wavcontext", "wavsys", "wavkw", "avjac", "abcontext", "wavpkg", " avobj", "AVcfg", "awctx", "navcontext", "avecfg", "vrcfg", "navconfig", "vrkj", "abpid", "awjac", " avcu", "avecmp", "ajca", "awtx", "avkl", " avkw", "afaddr", " avresp", "avkw", " avjac", "vrcontext", "avertx", "avtx", "abobj", "avpkg", " avjp", "avca"], "data": ["output", "Data", "empty", "id", "next", "map", "buffer", "text", "message", "a", "read", "image", "sample", "to", "area", "stream", "p", "value", "audio", "f", "bin", "frame", "pad", "rec", "d", "block", "m", "ata", "bits", "type", "length", "raw", "window", "bytes", "txt", "mu", "in", "package", "r", "video", "t", "feed", "input", "dat", "ns", "w", "batch", "DATA", "name", "size", "out"], "data_size": ["data_string", " data_string", "data_timeout", "dat_timeout", " data_timeout", "data_length", "data_offset", "data_Size", "data5timeout", " data_offset", " data_Size", "data5size", "dat5type", "dat_type", "dat5Size", "dat5timeout", " data_SIZE", "data_SIZE", " data_length", "data5type", "data_type", "dat_size", "dat_Size", "dat5size", "data5Size"], "avpkt": ["avcpkt", "avpacket", "avepvt", "avepst", "avcpct", "avppvt", "aveppst", "wavopkg", "aveppkt", "avppst", "avwpkt", "avcpst", "avopkt", "avnpnt", " avpkg", "avwpct", "avPacket", " avcpct", " avcpacket", "avPmsg", "wavpkt", "wavpacket", "avwpkg", "avPkt", "wavpmsg", " avcpkg", "avpvt", "avopmsg", "avcpkg", "avwpmsg", "avcpacket", " avpct", "wavopacket", "avppnt", "avpnt", "avopkg", "avpct", " avpacket", "aveppvt", "avcpnt", "avnpst", "avepkt", "aveppnt", "avepnt", "avpst", "avcpvt", "avwpacket", " avcpkt", "avpmsg", "avopacket", "avppkt", "avPct", "avPkg", "avpkg", "wavopkt", "wavopmsg", "avnpvt", "wavpkg", "avnpkt"], "buf": ["map", "buffer", "uf", "rb", "proc", "p", "seq", "bin", "Buffer", "vec", "pkg", "np", "ref", "cb", "raw", "bytes", "txt", "mem", "queue", "r", "br", "box", "cap", "ctx", "v", "cache", "b", "tmp", "cmd", "orig", "img", "buff", "db", "msg", "cv", "conv", "wb"], "s": ["sq", "spec", "a", "rs", "p", "gs", "ps", "d", "g", "m", "r", "js", "j", "S", "ss", "v", "e", "sb", "b", "h", "ns", "stats", "w", "ds", "sys"], "sample_size": ["samplelyfilter", " sample_location", "sampleletmember", "ample_space", "sampleletscope", " sample_Size", "change_status", "sample67status", "sampleptlocation", "sample67body", "ample_count", "ample_string", "sample67size", "sample67filter", "sample_body", "sampleptbody", "sample_type", "ample_size", "sampleletspace", "sampleptsize", "sample_count", "changeletsize", "sample_string", "sampleletsize", "changeletmember", "sample_scope", "changeletstatus", "sample_start", "change_size", "sample_location", "change_member", "samplelystatus", "sampleletstatus", "sample_Size", "sample_SIZE", "sampleletstring", "change_filter", " sample_start", "sampleletfilter", " sample_type", "sample67location", "samplelymember", "ample_Size", "sample67SIZE", "samplelysize", "sample67member", "sample_loss", "sample_filter", "sample_status", "sampleptSIZE", "sample_member", "sample_space", "ample_length", " sample_SIZE", " sample_body", " sample_loss", "changeletfilter", "ample_scope", "sampleptloss", "sample_length"], "c": ["ch", "k", "p", "f", "cp", "bc", "dc", "d", "g", "cs", "m", "cb", "cc", "t", "ci", "count", "v", "lc", "e", "b", "cn", "cm", "nc", "x", "C", "co", "ca"], "n": ["len", "num", "na", "u", "net", "nan", "nm", "nl", "nas", "norm", "network", "k", "Ni", "p", "ng", "o", "an", "f", "ne", "nt", "ni", "d", "nor", "g", "normal", "np", "m", "l", "rn", "nn", "mn", "en", "dn", "ln", "r", "j", "N", "fn", "t", "new", "v", "nr", "b", "cn", "un", "h", "false", "sn", "ns", "w", "nc", "x", "nb", "z", " N", "no", "name", "nv", "size", "nw", "number"], "i": ["id", "I", "li", "p", "o", "d", "ip", "m", "l", "ic", "mi", "j", "ir", "ix", "im", "y", "iu", "ci", "v", "b", "di", "bi", "pi", "si", "it", "x", "ii"], "samples": ["psources", "cents", "specizes", "sannels", "Sources", "Samples", "samps", "sources", "Sannels", "cannels", "psizes", "sizes", "Samps", "seannels", "seents", "psamps", "Sizes", "seamples", "seources", "sents", "specamps", "cources", "psamples", "camples", "specources", "specamples", "Sents"], "src": ["filename", "sl", "url", "source", "rs", "req", "proc", "sub", "seq", "bin", "trans", "bc", "attr", "ins", "ptr", "conv", "txt", "addr", "ser", "r", "rel", "dest", "rc", "input", "sb", "b", "comp", "tmp", "str", "sr", "st", "sc", "img", "iv", "loc", "inst"], "src8": ["source8", "rc8", "src6", "src64", "source6", "inst8", "source64", "rc2", "rc6", "rc64", "source2", "inst6", "inst2", "inst64"], "src2": ["rc0", "src1", "rc1", " src0", "rc2", "src0", "source2", " src1", "source0", "source1"], "MAX_CHANNELS": ["MAX_PLANNICS", "MAX_PLANSEL", "MAX_CHANNES", "MAX_CHOUNELS", "MAX_CHANICS", "MAX_ChANGATIONS", "MAX_CHANSICS", "MAX_CHACATIONS", "MAX_CHANSERS", "MAX_CHANNICS", "MAX_CHACELS", "MAX_CHANEL", "MAX_PLANNELS", "MAX_CHANNATIONS", "MAX_CHOUNEL", "MAX_PLANNERS", "MAX_ChANGES", "MAX_CHANGATIONS", "MAX_ChANNELS", "MAX_CHOUNATIONS", "MAX_CHANSELS", "MAX_CHACEL", "MAX_CHANGICS", "MAX_PLANSICS", "MAX_ChANNES", "MAX_CHANGELS", "MAX_CHACES", "MAX_ChANGELS", "MAX_CHANSEL", "MAX_CHANGEL", "MAX_CHANNERS", "MAX_PLANSELS", "MAX_CHANERS", "MAX_CHANGES", "MAX_ChANGEL", "MAX_CHANELS", "MAX_ChANNEL", "MAX_ChANNATIONS", "MAX_CHANNEL", "MAX_PLANSERS", "MAX_CHOUNES", "MAX_CHANGERS", "MAX_PLANNEL"], "dstu8": ["dstu2", "dst_8", "dSTu6", "dst_2", "dSTU6", "dSTu2", "dstU2", "dst_6", "dSTU2", "dstu6", "dstU6", "dSTu8", "dSTU8", "dstU8"], "dst_int16_t": ["dst_int16_n", "dst_int16_T", "dst_int32_n", "dst_int32_T", "dst_int16_type", "dst_int32_type"], "dst_int32_t": ["dst_int64_type", "dst_int64_T", "dst_int64_n", "dst_int32_n", "dst_int32_T", "dst_int32_type"], "dst_int64_t": ["dst_int64_type", "dst_int64_T", "dst_int64_p", "dst_int32_T", "dst_int32_p", "dst_int32_type"], "dst_uint16_t": ["dst_uint8_t", "dst_uint8_T", "dst_uint8_n", "dst_uint16_T", "dst_uint16_n"], "dst_uint32_t": ["dst_uint64_n", "dst_uint64_t", "dst_uint64_p", "dst_uint64_T", "dst_uint32_n", "dst_uint32_T", "dst_uint32_p"]}}
{"project": "qemu", "commit_id": "599d64f6dc10f267a45e7abebfcafd8e7626585b", "target": 1, "func": "static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n", "idx": 11714, "substitutes": {"env": ["ef", "vs", "ah", "et", "config", "network", "policy", "eh", "manager", "ev", "ov", "ec", "ve", "buf", "dev", "engine", "enter", "worker", "En", "te", "window", "shell", "en", "mem", "ew", "esc", "ctx", "EN", "conn", "conf", "v", "environment", "ten", "e", "oe", "er", "kernel", "estate", "org", "context", "param", "cv", "viron"], "ri": ["ami", "uti", "ai", "ati", "vi", "rip", "uri", "ita", "rise", "RI", "wi", "iri", "ry", "iro", "ni", "rob", "rio", "ira", "ra", "ria", "ki", "i", "ti", "pri", "ris", "mi", "ir", "iu", "ci", "phi", "rd", "xi", "gi", "rin", "di", "rt", "ric", "stri", "si", "pi", "ini", "umi", "ru", "udi", "rid", "gra", "ii"], "value": ["key", "current", "address", "buffer", "code", "image", "update", "region", "range", "field", "unit", "size", "block", "type", "local", "values", "word", "function", "property", "index", "attribute", "data", "total", "node", "test", "new", "state", "v", "info", "VALUE", "val", "Value", "scale", "rule", "w", "max", "name", "ue"]}}
{"project": "qemu", "commit_id": "036078475427f2562c8e505f6bb44dbf5d8cbd95", "target": 1, "func": "static int usb_host_open(USBHostDevice *dev, int bus_num,\n\n                         int addr, const char *port,\n\n                         const char *prod_name, int speed)\n\n{\n\n    int fd = -1, ret;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (dev->fd != -1) {\n\n        goto fail;\n\n    }\n\n\n\n    fd = usb_host_open_device(bus_num, addr);\n\n    if (fd < 0) {\n\n        goto fail;\n\n    }\n\n    DPRINTF(\"husb: opened %s\\n\", buf);\n\n\n\n    dev->bus_num = bus_num;\n\n    dev->addr = addr;\n\n    strcpy(dev->port, port);\n\n    dev->fd = fd;\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"husb: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++) {\n\n            printf(\"%02x \", dev->descr[x]);\n\n        }\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n\n\n    /* start unconfigured -- we'll wait for the guest to set a configuration */\n\n    if (!usb_host_claim_interfaces(dev, 0)) {\n\n        goto fail;\n\n    }\n\n\n\n    usb_ep_init(&dev->dev);\n\n    usb_linux_update_endp_table(dev);\n\n\n\n    if (speed == -1) {\n\n        struct usbdevfs_connectinfo ci;\n\n\n\n        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n        if (ret < 0) {\n\n            perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n            goto fail;\n\n        }\n\n\n\n        if (ci.slow) {\n\n            speed = USB_SPEED_LOW;\n\n        } else {\n\n            speed = USB_SPEED_HIGH;\n\n        }\n\n    }\n\n    dev->dev.speed = speed;\n\n    dev->dev.speedmask = (1 << speed);\n\n    if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) {\n\n        dev->dev.speedmask |= USB_SPEED_MASK_FULL;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n\n\n    if (!prod_name || prod_name[0] == '\\0') {\n\n        snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    } else {\n\n        pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                prod_name);\n\n    }\n\n\n\n    ret = usb_device_attach(&dev->dev);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* USB devio uses 'write' flag to check for async completions */\n\n    qemu_set_fd_handler(dev->fd, NULL, async_complete, dev);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (dev->fd != -1) {\n\n        close(dev->fd);\n\n        dev->fd = -1;\n\n    }\n\n    return -1;\n\n}\n", "idx": 11742, "substitutes": {"dev": ["ow", "usb", "command", "doc", "priv", "send", "prof", "add", "api", "cam", "end", "proc", "ay", "prop", "d", "attr", "desc", "util", "pub", "package", "se", "scan", "wd", "unknown", "env", "cmd", "w", "serv", "pi", "user", "sd", "pro", "dd", "av", "write", "ve", "buf", "task", "fail", "hd", "ptr", "ver", "mod", "server", "develop", "test", "aux", "conn", "conf", "cast", "Dev", "any", "des", "temp", "link", "att", "driver", "debug", "app", "writer", "draw", "patch", "obj", "spec", "buffer", "device", "req", "go", "ev", "valid", "den", "form", "devices", "var", "ach", "od", "error", "nt", "th", "def", "serial", "raw", "window", "mem", "connect", "rent", "cho", "ad", "ctx", "gu", "remote", "comment", "exec", "hw", "start", "er", "db", "build", "event", "det", "home", "pad", "normal", "pkg", "client", "handle", "all", "md", "de", "DEV", "v", "self", "cache", "player", "val", "query", "h", "tag", "stat", "watch", "disk", "sys", "store"], "bus_num": ["bus_um", "bus_number", "buszhom", "boot_um", "busityhom", "busingn", "chainingno", "bus_hom", "busznom", "bus_name", "chain_num", "boot_nom", "bus_Num", "buslnumber", "busznumber", "busznum", "busitynumber", "chain_gen", "boot_hom", "boot_Num", "buslmon", "boot_mon", "busingnum", "chainingn", "chainingnum", "boot_n", "buslnum", "bus_NUM", "buslNUM", "busitynum", "bus_nom", "chain_no", "bus_no", "boot_name", "boot_number", "bus_mon", "bus_n", "boot_NUM", "chaininggen", "bus_gen", "busitynom", "businggen", "busingno", "chain_n", "boot_num"], "addr": ["src", "align", "obj", "dd", "id", "net", "address", "url", "arp", "map", "at", "add", "Address", "prefix", "et", "order", "ack", "bind", "alloc", "p", "buf", "pad", "trans", "act", "ip", "pkg", "pos", "ref", "gate", "attr", "rn", "ptr", "adr", "pub", "ord", "alt", "handle", "r", "rel", "ix", "ad", "ac", "conn", "wd", "ace", "host", "nat", "cmd", "eth", "rt", "ag", "az", "res", "alias", "mac", "att", "name", "loc", "offset", "mt", "store"], "port": ["Port", "key", "ports", "len", "num", "address", "pc", "priority", "prefix", "buffer", "pt", "gp", "pport", "file", "p", "value", "buf", "cp", "pad", "prot", "ip", "pose", "size", "pos", "service", "type", "control", "ptr", "ort", "server", "PORT", "version", "interface", "bus", "direction", "rot", "host", "pipe", "name", "pid", "length", " sport", "pod"], "prod_name": ["prod_num", "proc_spec", "prod_desc", "prods_file", "proc2num", "prods2file", "prod2type", "prod__spec", "prod2name", "prodnamename", "proc_num", "prods_names", "prod2spec", "proc2name", "prodnametype", "prod_names", "prod2desc", "proc_name", "prodnamenames", "proc2names", "prods_type", "prod__names", "proc2desc", "prod_type", "prod_file", "proc_type", "prods2names", "prod2file", "prods2type", "prod_spec", "prod2names", "proc_desc", "proc_names", "prods2name", "prod__name", "prods_name", "prod2num", "prodnamefile", "prod__type"], "speed": ["command", "sign", "wind", "ctl", "wait", "cc", "t", "skip", "fee", "gain", "sd", "performance", "size", "sk", "power", "status", "species", "weight", "sp", "height", "sec", "capacity", "score", "limit", "Speed", "efficiency", "kind", "rate", "server", "scroll", "ss", "interface", "count", "scale", "cpu", "sc", "driver", "time", "cost", "state", "spec", "EED", "buffer", "slow", "policy", "stream", "engine", "powered", "type", "timeout", "mode", "sort", "transform", "sw", "sie", "peed", "style", "len", "sync", "fd", "pe", "priority", "secure", "flag", "seek", "sim", "service", "sex", "zero", "loss", "ssl", "fast", "sn", "flags", "length", "delay", "sys"], "ret": ["fin", "len", "tr", "success", "reset", "fi", "nl", "std", "back", "flag", "err", "det", "RET", "func", "sent", "reply", "nt", "iter", "rev", "fun", "mt", " Ret", "ptr", "alt", "mem", "lat", "r", "try", "rel", "j", "sat", "t", "rets", "deg", "val", "Ret", "tmp", "cmd", "rt", "elt", "re", "res", "cert", "result", "att", "gt", "ft", "out"], "x": ["key", "xp", "xy", "tx", "mx", "nex", " cx", "axis", " i", " dx", "ex", " k", "cross", "xc", "dx", "ox", "wx", "X", "i", "xs", "xxx", "inx", "mix", "xxxx", "index", " _", "rx", "ix", " t", "y", "ick", "t", "ctx", "px", " v", "xes", " X", "xi", "ey", " ax", "xt", " c", "times", "any", "xx", "yx", "z", "ax", "fx", "batch", "time", "\u00e7", " y", " xx", "lex", "max", "xa", "ux", "xxxxxxxx", "number"], "ci": ["CI", " cd", "ai", "fi", "ice", "ati", "sci", "ctrl", " cc", "li", "vi", "ee", " di", "ni", "cs", "ki", " pi", "i", "ti", "ia", "ic", "cci", " si", " ti", "mi", "cli", " ic", " vi", "icc", " cis", " pri", "ctx", "lc", "Si", " mi", "gu", "ace", "di", "cm", "cgi", "pi", " ice", "cu", "si", "II", "ini", " ii", "co", "vc", "ca", "ii", "ico"]}}
{"project": "qemu", "commit_id": "fa617181839741727d0067ea68807133f498f29b", "target": 1, "func": "static int esp_pci_scsi_init(PCIDevice *dev)\n\n{\n\n    PCIESPState *pci = PCI_ESP(dev);\n\n    DeviceState *d = DEVICE(dev);\n\n    ESPState *s = &pci->esp;\n\n    uint8_t *pci_conf;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* Interrupt pin A */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    s->dma_memory_read = esp_pci_dma_memory_read;\n\n    s->dma_memory_write = esp_pci_dma_memory_write;\n\n    s->dma_opaque = pci;\n\n    s->chip_id = TCHI_AM53C974;\n\n    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,\n\n                          \"esp-io\", 0x80);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);\n\n    s->irq = pci_allocate_irq(dev);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 11748, "substitutes": {"dev": ["tm", "hid", "obj", "dd", "spec", "priv", "ch", "pt", "device", "api", "cam", "go", "ev", "proc", "devices", "ve", "p", "home", "DE", "adv", "pad", "nt", "normal", " device", "def", "serial", "ver", "window", "server", "mem", "md", "de", "data", "test", "ad", "phy", "scan", "ctx", "dem", "DEV", "conn", "v", "bus", "remote", "Dev", "cmd", "h", "Device", "des", "hw", "w", "serv", "pi", "driver", "att", "dm", "disk", "app", "sd", "pro", "vol", "sys"], "pci": ["Pca", "pingsi", "ppcus", "ppcu", " pcci", " pcgi", "ipcci", "opcci", "psi", "Pci", "epcus", " pct", "postix", "pix", "pct", "apmi", "cpci", "pki", "ipci", "apki", "pcu", "apci", " pii", "Pki", "vpsi", "ppci", "patix", "pingcci", "pcpi", "cpct", "opii", "opoci", "pcci", "cpki", "patci", "pccu", " pca", "ppi", "pii", "opci", "poci", "pingci", "pcca", " pcus", "vpcci", "ppki", "apct", " ppi", "cpmi", "postcgi", "pcgi", "postvi", "Pcu", "postci", "patcgi", "pni", "epci", " pix", " pvi", "vpni", " poci", " pcu", " pmi", "ipii", "vpci", "pppi", "patvi", "epcu", "ppca", "pca", "ipoci", "pvi", "pmi", "pingni", "ipni", "ipsi", "pcus", " pki", "epki"], "d": ["dd", "fd", "device", "p", "o", "f", "ind", "da", "dc", "g", "pd", "m", "l", "del", "i", "dis", "did", "D", "dn", "r", "md", "gd", "de", "done", "n", "dq", "ad", "dest", "t", "v", "e", "b", "c", "h", "di", "dat", "w", "bd", "des", "db", "dict", "dm", "dh", "sd", "dt", "ds", "dr"], "s": ["vs", "sq", "spec", "qs", "source", "sol", "ats", "a", "rs", "hs", "sp", "p", "gs", "sts", "f", "ps", "south", "g", "cs", "l", "m", "ins", "sv", "i", "es", "ses", "sam", "bs", "session", "services", "so", "server", "r", "is", "js", "ys", "S", "ss", "ts", "n", "y", "its", "se", "t", "j", "v", "os", "sb", "b", "ims", "c", "sw", "cmd", "h", "sa", "ns", "stats", "des", "st", "set", "comm", "ls", "sd", "ds", "store"], "pci_conf": ["pki_conf", "pki_config", "pci_ref", "pci__config", "ppi_con", "pci_Conf", "pci_con", "pci__ref", "pci__Conf", "ppi_config", "ppi_conf", "pki_Conf", "pci_config", "pci__con", "pki_con", "pci__conf", "pki_ref", "ppi_Conf"], "err": ["arr", "kr", "inner", "norm", "notice", "ah", "Error", "errors", "ch", "lr", "order", "rs", "erd", "ev", "ec", "resp", "buf", "error", "ex", "iter", "aaa", "gr", "rev", "cer", "rn", "gz", "cb", "mr", "eor", "drm", "rr", "desc", "trace", "txt", "usr", "Er", "r", "try", "br", "rc", "conf", "erb", "cfg", "die", "e", "der", "str", "res", "er", "ocr", "fee", "result", "msg", "cr", "exc", "hz", "dr", "out"]}}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void copy_frame(Jpeg2000EncoderContext *s)\n\n{\n\n    int tileno, compno, i, y, x;\n\n    uint8_t *line;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){\n\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (s->planar){\n\n            for (compno = 0; compno < s->ncomponents; compno++){\n\n                Jpeg2000Component *comp = tile->comp + compno;\n\n                int *dst = comp->data;\n\n                line = s->picture.data[compno]\n\n                       + comp->coord[1][0] * s->picture.linesize[compno]\n\n                       + comp->coord[0][0];\n\n                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){\n\n                    uint8_t *ptr = line;\n\n                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)\n\n                        *dst++ = *ptr++ - (1 << 7);\n\n                    line += s->picture.linesize[compno];\n\n                }\n\n            }\n\n        } else{\n\n            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0]\n\n                   + tile->comp[0].coord[0][0] * s->ncomponents;\n\n\n\n            i = 0;\n\n            for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){\n\n                uint8_t *ptr = line;\n\n                for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){\n\n                    for (compno = 0; compno < s->ncomponents; compno++){\n\n                        tile->comp[compno].data[i] = *ptr++  - (1 << 7);\n\n                    }\n\n                }\n\n                line += s->picture.linesize[0];\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11749, "substitutes": {"s": ["ms", "vs", "ours", "orders", "ats", "sg", "hs", "cs", "m", "bits", "ins", "details", "r", "http", "t", "sports", "os", "b", "reports", "times", "comm", "ims", "ports", "gets", "source", "settings", "gs", "sts", "g", "sv", "ses", "services", "plays", "less", "js", "als", "ss", "sets", "ops", "ads", "e", "sb", "ows", "ls", "sq", "qs", "a", "rs", "as", "ants", "es", "ts", "n", "styles", "prints", "sw", "results", "ns", "ds", "p", "ps", "this", "aws", "pers", "is", "series", "S", "its", "c", "bis", "stats", "fs", "steps", "sys", "parts"], "tileno": ["ilename", "tilento", "tlogo", "bilno", "utilzo", " tilename", "dalono", "bilena", "dalestate", "daleno", "tilensis", "taltery", "tilno", "ataltery", "tilena", "tiltery", "ileno", "ilano", "talena", "tlena", " tilzo", " tilestate", "ilno", "taleno", "utilento", "atalogo", "atalena", "tleno", "talogo", "tilogo", "yllano", "utilno", "tooleno", "dalzo", "utilestate", "elinename", "bilename", "yllno", "ataleno", "utilensis", " tilono", "elinena", "tilename", "tltery", "tilono", "bilano", "yllename", "tilestate", "bilzo", "ilento", "elineno", " tilena", "ylleno", "ilensis", "elinzo", "bileno", "tilano", "toolno", "utileno", "toolento", "utilono", "tilzo", "toolensis"], "compno": ["omppos", "ompmeta", "compna", "componentNO", "ompdo", "compeno", "propNO", "comnumber", "comppo", "omppo", "cmpna", "commno", "cmpdo", "componentpo", "commmo", "comnone", "cmppos", "comeno", "configNO", "critno", "cmpmeta", "compmeta", "commnone", "compda", "cmpNO", "comyes", "cmpnos", " compmo", "comppos", "cmpmo", "ompna", "propno", "commo", "compo", "commpos", " compko", "compNO", "compyes", "propsym", "buffyes", " compnone", "commna", "compnos", "ompko", "cmpyes", "compmo", "buffnone", "cmpeno", "comdo", "critko", "critnone", "compnumber", "componentnos", "componenteno", "configno", "componentdo", "propna", "comko", "ompeno", "comNO", "commmeta", "crityes", " compeno", "ompNO", "procpo", "cmpda", "ompno", "commda", "cmpko", "commeno", "cmpno", "cmppo", " compnos", "ompyes", "configeno", "componentno", "compko", "ompnos", "ompda", "componentnumber", "comno", "commNO", "procnumber", "commsym", "compdo", "componentsym", "commpo", "comnos", "componentmo", "procNO", "compnone", "componentna", "ompmo", "ompnone", "cmpnone", "buffno", "procno", "compsym", "configko", "buffko", " compyes"], "i": ["id", "ai", "I", "io", "li", "p", "o", "ui", "ip", "m", "l", "ti", "ic", "cli", "index", "mi", "is", "j", "im", "ix", "n", "iu", "ci", "t", "zi", "v", "phi", "xi", "e", "c", "di", "ij", "si", "pi", "it", "z", "ini", "II", "ori", "ii", "ico"], "y": ["py", "yt", "xy", "ya", "axy", "sky", "ty", "ch", "ady", "yy", "yi", "wy", "o", "ay", "ry", "yn", "g", "m", "year", "oy", "my", "ies", "ye", "lon", "yes", "parent", "yer", "dy", "lat", "try", "j", "ley", "html", "yr", "Y", "hot", "ey", "b", "very", "ly", "uy", "gy", "sy", "ym", "fy", "any", "sys", "iy", "hey", "yout", "by", "ny", "kit", "out", "cy"], "x": ["xp", "on", "xy", "tx", "mx", "path", "text", "at", "mat", "q", "step", "p", "f", "ex", "ox", "dx", "ip", "xc", "m", "wx", "lon", "X", "xs", "xxx", "xxxx", "lat", "ext", "rx", "ix", "j", "px", "v", "xes", "xi", "e", "xt", "any", "w", "xx", "xml", "php", "z", "ax", "fx", "xa", "att", "el", "xe", "content", "ux", "dr", "xf"], "line": ["page", "lin", "len", "next", "pe", "nl", "call", "path", "code", "url", "text", "base", "cell", "print", "list", "range", "stroke", "file", "Line", "email", "point", "frame", "lines", "iter", "eline", "ip", "label", "block", "l", "pos", "limit", "trace", "port", "word", "ine", "online", "queue", "ln", "chain", "row", "try", "node", "zone", "lock", "comment", "pipe", "link", "lay", "LINE", "ide", "co", "user", "lo", "le", "byte", "liner", "out"], "tile": ["map", "ie", "feature", "print", "kt", "detail", "util", "queue", "details", "t", "mobile", "entity", "tree", "chip", "target", "slice", "tain", "tar", "TI", "yt", "tty", "mate", "tg", "ve", "iter", "note", "tle", "pixel", "ti", "sett", "test", "node", "feat", "title", "scale", "league", "table", "link", "grid", "template", "tf", "skill", "buffer", "mat", "ile", "file", "Tile", "profile", "unit", "frame", "component", "th", "tier", "tc", "tab", "ite", "vt", "trace", "term", "browser", "ts", "phy", "surface", "transform", "texture", "quote", "peer", "lay", "nil", "tu", "console", "module", "tool", "mt", "ty", "cell", "sim", "til", "sector", "te", "face", "port", "tif", "token", "shot", "il", "bit", "sid", "ten", "cache", "player", "via", "tele", "query", "sel", "tip", "store"], "comp": ["col", "acc", "op", "spec", "lib", "priv", "cmp", "con", "cum", "config", "prof", "ch", "par", "crit", "req", "cell", "loc", "prep", "compl", "proc", "rec", "resp", "var", "func", "prop", "rep", "cp", "omp", "sec", "component", "cat", "pkg", "pixel", "tab", "desc", "supp", "cc", "mod", "dep", "bit", "cont", "rel", "cond", "coll", "comb", "perm", "ctx", "ac", "conn", "rc", "lc", "cong", "cache", "c", "com", "fac", "cmd", "comment", "deep", "etc", "fc", "mac", "coord", "att", "comm", "buff", "co", "app", "mp", "Comp", "pro", "conv", "agg"], "dst": ["dedest", " dsp", " dest", " dport", "csp", "Dst", "cport", "dedbl", "cdest", "dbl", "ddest", "dedst", "Dsp", "dsp", " dST", "dedST", "dST", " dbl", "dest", "Dbl", "cst", "dport", "Ddest", " ddest", "DST", "Dest", "Dport"], "ptr": ["arr", "butt", "len", "tr", "prime", "fd", "tp", "nl", "buffer", "pointer", "pt", "eps", "lr", "req", "err", "cut", "sp", "inters", "rep", "pair", "pad", "iter", "pointers", "vec", "phrase", "pos", "grad", "ref", "inter", "hl", "trace", "port", "adr", "pend", "addr", "dep", "dra", "br", "pen", "deg", "fr", "pr", "ctr", "cmd", "eth", "pipe", "tip", "pert", "pi", "peer", "quad", "link", "coord", "Ptr", "dh", "ped", "offset", "dr"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return telldir(fs->dir);\n\n}\n", "idx": 11781, "substitutes": {"ctx": ["obj", "tx", "cmp", " cx", "req", "ct", "Context", "cf", "bc", "xc", "pkg", "ref", "cb", "unc", "xs", "kind", "cc", "mc", "cas", "conn", "px", "wd", "anc", "cmd", "hw", "fc", "context", "fx", "ca"], "fs": ["ms", "obs", "vs", "fw", "fd", "qs", "rs", "hs", "gs", "df", "f", "ps", "cs", "bits", "FS", "fps", "xs", "bs", "aws", "ys", "less", "ss", "ts", "irs", "sf", "Fs", "os", "ns", "fc", "ls", "s", "ims", "ds", "sys"]}}
{"project": "FFmpeg", "commit_id": "4b5a12a2cb0252c4a08b6d099eaf69523e8c62e5", "target": 0, "func": "static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref)\n\n{\n\n    AResampleContext *aresample = inlink->dst->priv;\n\n    const int n_in  = insamplesref->audio->nb_samples;\n\n    int n_out       = FFMAX(n_in * aresample->ratio * 2, 1);\n\n    AVFilterLink *const outlink = inlink->dst->outputs[0];\n\n    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);\n\n    int ret;\n\n\n\n    if(!outsamplesref)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);\n\n    outsamplesref->format                = outlink->format;\n\n    outsamplesref->audio->channel_layout = outlink->channel_layout;\n\n    outsamplesref->audio->sample_rate    = outlink->sample_rate;\n\n\n\n    if(insamplesref->pts != AV_NOPTS_VALUE) {\n\n        int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den);\n\n        int64_t outpts= swr_next_pts(aresample->swr, inpts);\n\n        aresample->next_pts =\n\n        outsamplesref->pts  = (outpts + inlink->sample_rate/2) / inlink->sample_rate;\n\n    } else {\n\n        outsamplesref->pts  = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,\n\n                                 (void *)insamplesref->extended_data, n_in);\n\n    if (n_out <= 0) {\n\n        avfilter_unref_buffer(outsamplesref);\n\n        avfilter_unref_buffer(insamplesref);\n\n        return 0;\n\n    }\n\n\n\n    outsamplesref->audio->nb_samples  = n_out;\n\n\n\n    ret = ff_filter_samples(outlink, outsamplesref);\n\n    aresample->req_fullfilled= 1;\n\n    avfilter_unref_buffer(insamplesref);\n\n    return ret;\n\n}\n", "idx": 11793, "substitutes": {"inlink": ["cinlink", "outline", "oinline", "inputband", "isinlayer", " inlayer", "cinstream", " instream", "unline", "cinlinked", "outlayer", "inLink", "newlock", "intool", "isinlink", "newlink", "unband", "inputrange", "inputstream", "inrange", "unLink", "outcommand", "inntool", "isinlinked", "inputlay", "innlock", "newrange", "outlinked", " inband", "newtool", "innlink", " outstyle", "inlinked", "isinline", "outflow", "unlay", "cinline", "outstyle", "oinLink", "oinlayer", "inlayer", "inputline", " outLink", "inputlink", "inputLink", "inband", " inLink", "inputlock", "outstream", "inflow", "outLink", "inputflow", " outline", "innrange", "instyle", " instyle", "uncommand", "instream", " inflow", "inlay", "inputtool", "cinlayer", "inlock", "oinlink", " inlinked", "unlink", " inlay", " incommand", "incommand"], "insamplesref": ["insamplesdef", "inamplesRef", "insplesref", "insampsp", "outsamplesRef", "outsampsRef", "stsamplesef", "stsampsrel", "outsamplesreference", "outsamplesrb", "insampsrel", "insacesdef", "insizesef", "stsizesef", "insizesreference", "insonentsdef", "insampsreference", "insoundsref", "stsamplesref", "insamplesp", "insamplesRef", "outsamplesre", "insamplestab", "insonentsref", "insentsRef", "insoundsrb", "outsampsrel", "insplesobj", "insentsp", "insacesrb", "stsampsobj", "insizesre", "insampsRef", "insilesref", "stsamplesdef", "insplesrel", "outsampstab", "insreportsdef", "insilesreference", "insentsdef", "insampspb", "outsamplestab", "inampsref", "inampsp", "insancesref", "stsamplesreference", "outsampsref", "stsamplesobj", "insplesp", "insampsobj", "insreportspb", "insplesdef", "insoundsdef", "insamplesrb", "insilesrel", "insamplesobj", "insampledef", "insamplesreference", "insilesre", "insamplesef", "stsizesref", "insizesref", "insampstab", "inampsRef", "stsizesreference", "insonentsef", "insampsref", "stsampsreference", "insampsef", "insamplepb", "insacesref", "insacesRef", "insamplespb", "outsamplesdef", "insancesobj", "insampsre", "outsamplespb", "stsizesdef", "insreportsreference", "insampsdef", "inamplesdef", "stsamplesrel", "outsampsre", "insamplesre", "outsamplesrel", "stsampsref", "insentsref", "insizesdef", "insamplereference", "insonentsreference", "insampleref", "outsampspb", "outsampsreference", "inampsdef", "insamplesrel", "insplestab", "insoundsRef", "inamplesref", "insizestab", "insizesrel", "outsampsdef", "insizesRef", "inamplesp", "insplesreference", "insreportsref", "insancesreference", "insancesrel", "insplesRef"], "aresample": ["arersamp", "rumsample", "kessample", "astsam", "aresam", "rsample", "arersample", "astspect", "arsample", "airsamp", "kesam", "airsample", "aresamp", "astsample", "iansamp", "arespace", "ianspler", "stssample", "arespler", "arspm", "arerspm", "arspect", "arespect", "kespler", "stsamp", "arerspace", "stspace", "stsam", "rssample", "astspm", "areamp", "irespm", "rumsamp", "rsamp", "arsamp", "arssample", "stspm", "rumspm", "iresample", "astssample", "iansam", "iansample", "airsam", "airssample", "astsamp", "aressample", "irespect", "iresam", "rsam", "kesamp", "arespm", "stsample", "kesample", "rumspace", "aream", "areample", "airspler", "arsam"], "outlink": ["Outlink", "onlink", "outerdisk", "outcomp", "offcomp", "outerlink", "Outline", " outlayer", " outloader", "inhandle", "outport", "offlayer", "toloader", "outerlayer", "ndisk", "OUTcomp", "offlock", "outloader", "olayer", "newlink", "offdisk", "indisk", " outlinked", "servloader", "outerlinked", "nlink", "outerhandle", "outlock", "inlock", "OUTstream", "onlet", "OUTlink", "outlet", "outlayer", "newpack", " outdisk", "OUTline", "tolink", "Outlinked", "outpack", "newline", "inpack", "todisk", "outerport", "checkdisk", "nport", "OUTlinked", "servlink", "offlink", "olinked", "incomp", "outerthread", "outthread", "offstream", "offport", "checklink", "onlinked", "checkhandle", "outline", "othread", "outhandle", "nlayer", "offpack", "newlock", " outthread", "offline", "outlinked", "online", "servdisk", "OUTlet", "outstream", "olink", "instream", "outdisk", "Outlet"], "outsamplesref": ["alsamplesRef", "outsamplesmb", "nsamplesreference", "outsamplesRef", "offspacesRef", "alsampsRef", "outsampsREF", "outsampsRef", "outsimsobj", "offsamplesreference", "nsampsro", "outsampleslf", "outsresultsref", "outsamplesreference", "bspaceslf", "outsolutionstab", "outsizesresp", "outsolutionsref", "nsamplesnote", "outsportsrel", "offsamplesre", "outsessionsinfo", "outsumpsRef", "outsappingsfer", "insamplesRef", "alsampleself", "outsamplesre", "outsplesobj", "outsampsnote", "outsonentsresp", "outsampsrel", "outsidesinfo", "unsamplesrel", "outsonentsrel", "offspacesre", "outsamplesfer", "outsessionstab", "outsampleself", "outsocksreference", "outsinksrel", "insampsRef", "outspacesobj", "inasolutionsobj", "nsamplesRef", "bspacesref", "outsidestab", "outsplesreference", "outsessionsobj", "unsamplesfer", "unsamplesresp", "outsolutionsinfo", "offsamplesref", "outsampslf", "bsampleslf", " outsamplesold", "outsplesro", " outsizesobj", "outsocksro", "bspacesrel", "outsamplestab", "outsizesrel", "outsocksref", "unsappingsfer", "outsizesRef", "inasamplesobj", "outsampsref", "outspacesref", "insampsobj", " outsamplesreference", "unsappingsresp", "offsamplesRef", "outspacesreference", "outspaceslf", "outsplesref", "offspacesref", "outsizesreference", "outsresultsobj", "outsamplesnote", "outsplesRef", "insamplesREF", "nsamplesref", "outsimsREF", "insamplesobj", "outsinksRef", "outspacesRef", "outsumpsreference", "nsampsreference", "outsamplesresp", "outsamplesro", "outspacesre", "outsessionsref", "alsampsrel", "inasamplesinfo", "inasamplestab", "unsappingsrel", "outsappingsref", "bsamplesrel", "offsamplesrel", "insampsref", "outsizesref", "inasamplesref", "alsampsref", "outspacesrel", "nsamplesmb", "inasolutionsinfo", "outsizesre", "outsamplesREF", "outsamplesobj", "outsappingsresp", "outsidesobj", "outsplesREF", " outsamplesobj", "outsportsref", "outsampsro", "outsampsmb", "bsamplesRef", "outsidesref", "nsampsRef", "outsampself", "outsamplesold", "outsportsRef", "insampsREF", "outsumpsnote", "nsampsref", "outsampsre", "outsappingsrel", "outsamplesrel", "offspacesrel", "outsonentsfer", "offsampleslf", "alsampself", "outsizesold", "outsresultsreference", "unsappingsref", " outsizesref", "offspaceslf", "outspacesold", "outsizesfer", "outsimsrel", "inasolutionsref", "outsampsobj", "outsinksreference", "outspaceself", "outsimsref", "outsampsreference", "offspacesreference", " outsizesreference", "bsamplesref", "outsamplesinfo", "outsportslf", "outsplesmb", "alsamplesref", "outsinksref", " outsizesold", "outsimslf", "outsresultsold", "inasolutionstab", "outsizesobj", "outsimsRef", "outsocksmb", "outsportsre", "nsamplesro", "nsampsnote", "nsampsmb", "outsizeslf", "outsolutionsobj", "bspacesRef", "alsamplesrel", "unsamplesref", "outsumpsref", "outsonentsref"], "ret": ["arr", "len", "tr", "reset", " RET", "read", "print", "RET", "resp", "ry", "nt", "jp", "true", "ref", " Ret", "mt", "def", "after", "alt", "try", "t", "mel", "rem", "rets", "val", "Ret", "elt", "re", "rt", "str", "res", "it", "result", "att", "get", "gt", "ll", "Return"]}}
{"project": "FFmpeg", "commit_id": "138568e9da0e3abfc818329ab12ea3fb667639fb", "target": 0, "func": "static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    unsigned int i, entries;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n    entries = get_be32(pb);\n\n    if(entries >= UINT_MAX / sizeof(MOV_stts_t))\n\n        return -1;\n\n\n\n    sc->ctts_count = entries;\n\n    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));\n\n    if (!sc->ctts_data)\n\n        return -1;\n\n    dprintf(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    for(i=0; i<entries; i++) {\n\n        int count    =get_be32(pb);\n\n        int duration =get_be32(pb);\n\n\n\n        if (duration < 0) {\n\n            av_log(c->fc, AV_LOG_ERROR, \"negative ctts, ignoring\\n\");\n\n            sc->ctts_count = 0;\n\n            url_fskip(pb, 8 * (entries - i - 1));\n\n            break;\n\n        }\n\n        sc->ctts_data[i].count   = count;\n\n        sc->ctts_data[i].duration= duration;\n\n\n\n        sc->time_rate= ff_gcd(sc->time_rate, duration);\n\n    }\n\n    return 0;\n\n}\n", "idx": 11795, "substitutes": {"c": ["pc", "con", "abc", "call", "cam", "ct", "enc", "p", "cl", "ec", "f", "cp", "cf", "bc", "dc", "g", "cur", "cs", "tc", "m", "l", "cb", "cc", "ce", "cont", "chain", "coll", "n", "mc", "t", "ci", "ctx", "ac", "rc", "lc", "v", "conf", "cache", "e", "b", "anc", "com", "cn", "nc", "cm", "etc", "cu", "fc", "C", "co", "cr", "ca"], "pb": ["td", "lb", "tf", "bj", "typ", "pc", "tp", "mb", "ub", "pp", "uf", "pt", "bp", "rb", "ping", "asm", "proc", "p", "sp", "buf", "resp", "amp", "sub", "cp", "fp", "pg", "bc", "vp", "pkg", "tc", "jp", "fb", "cb", "lp", "pm", "emb", "eb", "ctx", "px", "erb", "pl", "sb", "b", "wp", "sys", "dp", "bb", "stab", "PB", "ob", "gb", "buff", "pack", "mp", "pro", "wb", "pa"], "atom": ["entry", "orm", " symb", " element", "at", " carb", "tg", " Atom", "m", "ata", "type", "um", "term", " term", " om", "tem", "fam", " atoms", "tmp", " app", "om", "chem", "item", "msg", "app", " form", "name", " tmp"], "st": ["src", "tt", "tr", "sl", "et", "at", "ch", "pt", "St", "ct", "sp", "stra", "sts", "sim", "ut", " ss", "sec", "th", "sv", "ust", "ste", "so", "cont", "stage", "ss", "ist", "se", "t", "sw", "sh", "ST", "ost", "sn", "sa", "str", "start", "sta", "est", "rest", "inst", "set", "s", "ft", "mt"], "sc": ["sche", "ck", " subsc", "spec", "arc", "sync", "pc", "sl", "usc", "sum", "ch", "decl", "sch", "cam", "enc", "proc", "ec", "cl", "sp", "ui", "bc", "sec", "dc", "scope", "cs", "tc", "cer", "osc", "sv", "psc", "desc", "ctl", "capt", "scl", "cc", "ka", "sup", "isc", "ss", "esc", "SC", "mc", "ci", "ctx", "rc", "lc", "gc", "Sc", "uc", "sh", "anc", "comp", "asc", "exec", "nc", "scale", "cu", "disc", "tch", "cv", "cr", "soc", "loc", "sys"], "i": ["id", "u", "ai", "fi", "I", "me", "li", "ei", "iq", "k", "ri", "p", "o", "sim", "iri", "ind", "ui", "d", "ip", "g", "m", "l", "ki", "ti", "ic", "cli", "in", "mi", "index", "chain", "is", "j", "im", "ix", "n", "y", "t", "ci", "\u0438", "iu", "phi", "zi", "v", "xi", "multi", "e", "qi", "gi", "di", "bi", "ij", "cgi", "iy", "pi", "si", "it", "x", "batch", "ini", " ii", "hi", "ji", "ims", "asi", "ii"], "entries": ["enties", " enties", "ientrier", " entires", "pentries", " entures", "entsries", "ENTries", "entures", " entarts", "ntries", "entsies", "ENTrier", "entsresses", "Entrys", "nties", "entires", "entsencies", "Enties", "entresses", "entencies", "pentencies", "entsarts", "entsrier", "centrys", "enrys", "entsances", " Entriers", "entslements", "ntrys", "centriers", "entances", "Entencies", "ENTies", "enires", "ENTrys", "pentriers", "entrier", "ientances", " entrys", " entriers", " Entarts", "Entrier", "enries", "entsriers", "entsures", "ientries", "pentlements", "entsires", "penties", "ENTires", " Entures", "ntriers", "Entries", "enresses", "entriers", "entarts", " Entries", "entrys", "entsrys", "ntlements", "Entriers", "Entresses", "centries", "ENTances", "Entires", "entlements", "pentrys", "centrier", "ientrys"]}}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n", "idx": 11806, "substitutes": {"obj": ["bj", "xy", "off", "pt", "Obj", "o", "ind", "nt", "act", "pkg", "oid", "ref", "object", "attr", "window", "so", "js", "j", "t", "ctx", "self", "bo", "rect", "tmp", "bh", "og", "ot", "hw", "str", "onet", "ob", "img", "co", "inst", "out", "ij"], "name": ["NAME", "key", "id", "spec", "nm", "me", "path", "names", "base", "order", "nam", "var", "dev", "f", "m", "ra", "type", "ame", "def", "word", "lat", "mem", "data", "ma", "n", "cap", "t", "man", "fam", "info", "c", "cmd", "str", "w", "alias", "Name", "no", "am"], "o_out": ["o__out", "o2in", " o2in", "ozin", "ozOut", "o_Out", " o_Out", "o2outs", "ozout", "o__in", " o2out", " o2outs", "o__outs", "o_in", "o2out", "o_outs", " o_outs", " o_in"]}}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        if (bdrv_truncate(base, length) < 0) {\n\n            error_setg(errp, \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, errp,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(errp)) {\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 11810, "substitutes": {"bs": ["ms", "lb", "obs", "vs", "bf", "pse", "bp", "rs", "bas", "sub", "gs", "ps", "bc", "ase", "BS", "cs", "bm", "bits", "fps", "bytes", "is", "js", "its", "bos", "ts", "pb", "boot", "ctx", "bps", "lbs", "ubs", "sb", "b", "basic", "bis", "bh", "bi", "ns", "stats", "fs", "blog", "ls", "hz", "ds", "sys"], "base": ["prefix", "based", "parent", "bound", "http", "se", "handler", "bo", "fr", "b", "bal", "real", "history", "pre", "kit", "key", "source", "bas", "null", "server", "top", "sb", "basic", "bot", "force", "was", "no", "Base", "state", "id", "mb", "buffer", "back", "bp", "as", "file", "area", "cp", "ase", "ip", "stable", "local", "store", "chain", "old", "start", "it", "db", "bar", "space", "out", "extra", "pse", "bid", "to", "p", "ps", "this", "handle", "super", "bit", "las", "root", "box", "v", "change", "cache", "binding", "h", "origin", "bi", "res", "full", "set", "name", "sys", "pa"], "speed": ["command", "frequency", "spec", "send", "status", "drive", "EED", "priority", "buffer", "thread", "seek", "weight", "height", "engine", "disable", "score", "limit", "sex", "Speed", "sleep", "position", "port", "wait", " size", "scroll", "interface", "count", "sw", "scale", " speeds", "start", "slice", "driver", "peed", "time", "duration", "offset", "size", "delay"], "on_error": [" on_result", " on_close", "on_query", "on_ERROR", " on_query", "on_command", "on___error", " on_ERROR", "onJERROR", "on___err", "on___query", "onJresult", "on___command", "onWresult", "on___close", "on_close", "on_result", "on_err", " on_err", "onJerror", "onWerror", " on_command", "onWERROR"], "cb": ["lb", "ck", "callback", "CB", "bf", "cmp", "ctrl", "rb", "bp", "cor", "func", "buf", "cp", "fp", "cf", "bc", "dc", "tc", "cs", "cd", "fun", "cc", "fn", "pb", "handler", "ctx", "cfg", "b", "c", "cn", "nc", "bb", "ob", "fc", "gb", "db", "cv"], "opaque": ["obaques", "Opaque", "pacity", "hopque", "pque", "opaques", "pfac", "opque", "Opque", "opfac", "okulence", " opaques", "hopacity", "obulence", "Opacity", "obaque", " opacity", "paque", " opulence", "okaque", "hopfac", "Opfac", "obacity", "hopaque", "okacity", "opulence", "okaques", "opacity"], "errp": ["errorr", "errr", "usrping", "rrpe", " errps", "dangercp", "rerps", "errorpa", "errpe", "rerjp", "errorjp", "erpa", "dangercache", "erps", " errpa", "diepa", " errpc", "derp", "errorps", "errorpc", "rrping", "rrr", "erpb", "errorP", "errorcache", "errpb", "rrp", " errping", "derping", "errpc", "derps", "erp", "rerpb", "usrpa", "errorping", "dieP", "derpc", "dangerpc", "errorpb", "errcp", "errorp", "usrp", "errps", " errr", "errping", " errP", "warnpc", "diep", "warncache", "rrP", "diepe", "errpa", "erjp", "rerp", "errP", "rrpa", "errcache", "errorcp", "errjp", "dangerp", "erping", "warncp", "warnp", " errpe"], "length": ["len", "depth", "be", "frequency", "ah", "address", "enth", "buffer", "code", "message", "path", "idth", "join", "padding", "match", "build", "end", "weight", "wind", "zip", "read", "p", "height", "number", "f", "maximum", "volume", "SIZE", "capacity", "component", "limit", "l", "type", "sequence", "zero", "position", "port", "json", "ength", "loop", "term", "index", "max", "level", "total", "Length", "ENGTH", "count", "phi", "shape", "transform", "present", "h", "ob", "driver", "full", "time", "angle", "head", "duration", "history", "performance", "offset", "size", "distance"], "base_length": ["baseJlength", "base8strength", " base2len", "server_Length", "base8duration", " base_match", "base2len", " base2length", "baselenwidth", " base2Length", " base2width", "base8match", "base_match", "server_length", "base8length", "base_len", "base_Length", "baselencode", "baseJmatch", "server_len", "base_strength", " baseJlength", "base_width", " base_duration", "base67code", "base67width", " baseJmatch", "baseJduration", "base2Length", " base2code", "base_duration", " base_width", " baseJduration", "base2length", " base2phi", "baseJstrength", " base_len", "base67phi", "baselenphi", "base2code", "base_code", " base_Length", "baselenlength", "base67length", "base2width", " base_phi", "base2phi", " base_strength", "base_phi", " baseJstrength", " base_code"], "orig_base_flags": ["orig_ase_flags", "orig_cache_flags", "orig_ase_flag", "orig_base_fs", "orig_ase_styles", "orig_file_links", "orig_file_flags", "orig_baseLocalstyles", "orig_base_flag", "orig_file_fs", "orig_baseLocalflags", "orig_base_properties", "orig_base_styles", "orig_cache_properties", "orig_base_links", "orig_file_flag", "orig_baseLocalflag", "orig_cache_fs", "orig_cache_flag"]}}
{"project": "FFmpeg", "commit_id": "4f90688b6e1d79d85ac2e065a2cf1e7e9bd665a7", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n                                  MatroskaTrack *track)\n{\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n    uint8_t* data = *buf;\n    int isize = *buf_size;\n    uint8_t* pkt_data = NULL;\n    int pkt_size = isize;\n    int result = 0;\n    int olen;\n    switch (encodings[0].compression.algo) {\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n        return encodings[0].compression.settings.size;\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n        do {\n            olen = pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n        if (result)\n            goto failed;\n        pkt_size -= olen;\n        break;\n#if CONFIG_ZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n        z_stream zstream = {0};\n        if (inflateInit(&zstream) != Z_OK)\n        zstream.next_in = data;\n        zstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            zstream.avail_out = pkt_size - zstream.total_out;\n            zstream.next_out = pkt_data + zstream.total_out;\n            result = inflate(&zstream, Z_NO_FLUSH);\n        } while (result==Z_OK && pkt_size<10000000);\n        pkt_size = zstream.total_out;\n        inflateEnd(&zstream);\n        if (result != Z_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n#if CONFIG_BZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n        bz_stream bzstream = {0};\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n        bzstream.next_in = data;\n        bzstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n            result = BZ2_bzDecompress(&bzstream);\n        } while (result==BZ_OK && pkt_size<10000000);\n        pkt_size = bzstream.total_out_lo32;\n        BZ2_bzDecompressEnd(&bzstream);\n        if (result != BZ_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n    default:\n    }\n    *buf = pkt_data;\n    *buf_size = pkt_size;\n    return 0;\n failed:\n    av_free(pkt_data);\n}", "idx": 11813, "substitutes": {"buf": ["arr", "doc", "buffer", "read", "uf", "rb", "enc", "p", "var", "seq", "bl", "pad", "bc", "Buffer", "block", "pkg", "pos", "cb", "window", "bytes", "bs", "mem", "queue", "box", "cap", "rc", "v", "cast", "que", "b", "tmp", "cmd", "h", "dat", "w", "batch", "buff", "cv", "wb"], "buf_size": ["buf__length", "buf_length", "buf_Size", "buff_Size", "buf_SIZE", "buf_sh", "buff_scale", "buf__scale", "buf2size", "buf2length", "buf2scale", "buf__SIZE", "buff_SIZE", "buf2SIZE", "buf__size", "buff_length", "buff_size", "buff_sh", "buf_scale"], "track": ["tr", "run", "Track", "sync", "record", "kick", "train", "match", "fire", "seek", "sound", "ack", "bind", "stream", "report", "rack", "trace", "tab", "session", "handle", "met", "queue", "index", "r", "race", "tracks", "roll", "t", "metadata", "search", "transform", "cmd", "reflect", "tracking", "batch", "set", "pack", "claim", "store"], "encodings": ["decoders", "enccoding", "encointers", "encODifiers", "encointifiers", "enccodrings", "ecodations", "decODings", "encointing", "encODings", "decODing", "encodifiers", "encordings", "decoding", "encoders", "encODers", "encODrings", "encodations", "ecoding", "eccodations", "encening", "decodrings", "enccoders", "encorders", "encordations", "encenings", "encodrings", "enccodations", "encoding", "eccoding", "encODifications", "encODations", "decODrings", "eccodings", "decODers", "eccodifiers", "encointings", "encODing", "ecodifiers", "ecodifications", "decodings", "encording", "enccodifiers", "encenifications", "eccodifications", "ecodings", "enceners", "enccodifications", "ecoders", "encodifications", "eccoders", "enccodings"], "data": ["len", "Data", "array", "xy", "next", "map", "buffer", "read", "image", "end", "valid", "p", "value", " Data", "bin", "error", "iter", "d", "size", " DATA", "open", "pos", "ata", "raw", "window", "bytes", "mu", "mem", "r", "n", "ATA", "t", "info", "aw", "good", "input", "results", "dat", "str", "w", "start", "res", "table", "result", "batch", "DATA", "no", "name", "offset", "length"], "pkt_data": ["packet_data", "pelt_info", "pktlydata", "ptt_map", "packet_read", "pct_len", "pktLsize", "pkt_buffer", "pnt_data", "ptt_size", "packet_name", "pkt64size", "pkt_len", "pkt_str", "pkt_read", "pct_buffer", "pelt_size", "pkt_name", "pelt_name", "pelt_data", "ptt_data", "pet_len", "pktLdata", "packet_size", "pkt_mem", "pktLmem", "packet_cache", "pet_data", "ptt_mem", "pkt_map", "pkt_info", "pktlyread", "pkt_cache", "pktLmap", "pct_data", "pktlystr", "pet_str", "pkt64buffer", "packet_str", "pkt64len", "pnt_cache", "pkt_batch", "pct_size", "pkt64data", "pet_batch", "pkt_size", "pnt_name"], "olen": ["len", "hal", "het", "olid", "lan", "rown", "sol", "equipped", "ran", "sofar", "occupied", "haven", "aken", "ldon", "known", "wid", "didn", "linger", "wan", "rn", "mn", "hung", "broken", "written", "failed", "alt", "mem", "opted", "ln", "regon", "angled", "kl", "zon", "total", "done", "agger", "ele", "wn", "hat", "led", "mel", "alg", "lol", "won", "cn", "ken", "eth", "origin", "held", "temp", "nom", "claimed", "ilee", "oled", "filled", "lost", "aled", "killed", " leftover", "oin", "ret"]}}
{"project": "qemu", "commit_id": "ba9c5de5f2d33d468a07a8794121472ea031a0b5", "target": 0, "func": "void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n", "idx": 11833, "substitutes": {"cs": ["ck", "vs", "cus", "qs", "cks", "ats", "rs", "css", "ars", "ras", "ec", "sts", "cp", "CS", "ps", "ins", "cc", "bs", "ce", "js", "ys", "ss", "ts", "rc", "ics", "wcs", "c", "acs", "ns", "fs", "ks", "sc", "ces", "ls", "ds", "uns"], "addr": ["src", "obj", "id", "address", "url", "arp", "prefix", "a", "Address", "rs", "err", "alloc", "uid", " address", "hash", "pad", "act", "ip", "hop", "pkg", "ref", "attr", "rn", "ptr", "rr", "adr", "handle", "ord", "r", "ad", "ctx", "rc", "v", "host", "cmd", "eth", "rt", "hw", "str", "res", "x", "dh", "name", "offset"], "is_write": ["is_wait", "is__writ", " is_read", "is__read", "Is_only", "is__write", " is_writ", "Is_wait", " is_writing", "is_only", "is_writing", "is_writ", "is__writing", "Is_write", "Is_read", "is_read"], "is_exec": ["is2run", "is2exec", "is_open", " is_read", "is2open", " is_open", "is_run", " is_run", "is2read", "is_read"], "unused": ["Unusage", "unaavailable", " unusage", "unause", " unavailable", " unuse", "unusage", "unaused", "unuse", "Unused", "Unavailable", "unausage", "Unuse", "unavailable"], "size": ["len", "empty", "send", "use", "sum", "izes", "weight", "alloc", "uid", "Size", "SIZE", "g", "block", "l", "ize", "en", "bytes", "mem", "n", "cap", "count", "sn", "max", "name", "offset", "length"], "cpu": ["ck", "nic", "aco", "pc", "gpu", "prof", "processor", "bean", "alloc", "nu", "proc", "ex", "cp", "pu", "ox", "jp", "process", "np", "nn", "ka", "qa", "core", "CPU", "clock", "mem", "uda", "phy", "aux", "ctx", "ac", "conn", "gc", "chip", "cn", "anc", "setup", "hw", "nc", "cu", "stat", "phys", "aq", "rom", "ca"], "env": ["doc", "vs", "ah", "priv", "map", "ee", "end", "proc", "uv", "vp", "esm", "desc", "stack", "cause", "cmd", "nc", "context", "cv", "dh", "ens", "era", "next", "bean", "ec", "buf", "Environment", "ptr", "en", "txt", "server", "node", "esc", "conn", "environment", "e", "eas", "oe", "estate", "sc", "nv", "ef", "obj", "gear", "ei", "err", "export", "ev", "den", "bind", "engine", "worker", "scope", " ens", "vt", "window", "shell", "ts", "ctx", "forge", "er", "db", "console", "extra", "entry", "eh", "here", "manager", "erd", "dev", "te", "cb", "ext", "inv", "ew", "dn", "dest", "neck", "v", "ten", "msg", "viron", "store"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static int virtio_serial_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&\n\n        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */\n\n        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */\n\n        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;\n\n\n\n    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);\n\n    if (!vdev) {\n\n        return -1;\n\n    }\n\n    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED\n\n                                        ? proxy->serial.max_virtserial_ports + 1\n\n                                        : proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_CONSOLE,\n\n                    proxy->class_code, 0x00);\n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n\n}\n", "idx": 11834, "substitutes": {"pci_dev": ["pci_req", "pcu2device", "pci_ev", "pciCserial", "ppi_buf", "pci_def", "pciCdev", "pci2Dev", "pci2dev", "pci2ve", "pcu2dev", "ppi_ev", "pcu2serial", "pci_Dev", "pcu_ve", "ppi_req", "pciCDev", "pcu2Dev", "pci_ve", "pci2device", "pci2def", "pci_buf", "pci_serial", "ppi_dev", "pci_device", "pcu_serial", "pci_conn", "pcu_conn", "pcu_def", "pcu_device", "pcu_Dev", "pciCdevice", "pci2serial", "pcu_dev"], "proxy": ["xy", "map", "shadow", "roxy", "friend", "reply", "report", "linux", "parent", "http", "view", "handler", "cas", "ion", "target", "pin", "controller", "native", "result", "see", "user", "pre", "pro", "callback", "Proxy", "use", "address", "socket", "source", "PRO", "ping", "slave", "null", "request", "relation", "server", "none", "mi", "version", "echo", "oe", "pipe", "alias", "force", "link", "driver", "project", "XY", "page", "prime", "gp", "device", "profile", "reason", "worker", "trace", "index", "dirty", "browser", "clone", "connection", "phy", "cone", "reverse", "tor", "info", "remote", "copy", "master", "console", "module", "password", "select", "show", "priority", "wrapper", "pointer", "embed", "pse", "manager", "pool", " proxies", "client", "port", "holder", "super", "series", "self", "primary", "cache", "lock", "query", "false", "po"], "vdev": ["vpriv", "vprof", "ndevice", "evdes", "nvdes", "evdevice", "vcconn", " vdat", "ndata", "pdiv", "pev", "vnormal", " vnormal", "uvpriv", "uvdes", " vdef", "fdev", " vdes", "vcw", "vdat", " vval", "nvval", "evprof", "vcdev", " vw", "vdevice", "nvpriv", "vconn", "mdes", "vval", " vdiv", "uvdev", "ndev", "fdevice", "uvconn", "fdata", " vpriv", "nvdiv", "pnormal", "nvnormal", "cvdat", "evdev", "vw", "nev", "cvev", " vdevice", " vconn", "vev", "uvdef", "pdev", " vev", "nvdev", "ndat", "mdev", " vdata", "uvval", "vdata", "vdef", "vdes", "cvdev", " vprof", "vdiv", "mprof", "uvw", "vcdef", "fev", "mdevice", "nvev"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qmp_chardev_open_serial(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    ChardevHostdev *serial = backend->serial;\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n}\n", "idx": 11840, "substitutes": {"id": ["Id", "path", "end", "ident", "hash", "uid", "dev", "kid", " pid", "oid", "ref", "kind", "ID", "sid", "root", "ids", "ad", " rid", " fid", "mid", "tag", "vid", " tid", "aid", "name", "pid", "rid"], "backend": ["backline", "jackad", "gateend", "bookends", "gateends", "jackender", "jackend", "Backended", "bookended", "jackended", "backends", "gateline", "gateender", "Backline", "bookline", "Backender", "Backad", "bookend", "Backend", "backender", "bookender", "Backends", "backended", "bookad", "backad"], "ret": ["lit", "tr", "et", "std", "det", "RET", "resp", "nt", "ref", "def", "mt", "txt", "mem", "rem", "rets", "reg", "val", "Ret", "rect", "red", "rt", "sel", "re", "des", "res", "pet", "rm"], "errp": ["krr", "errorr", "errr", " erp", " errps", "krm", " erpo", "lerpo", "errm", "lerbp", "errpo", "errbp", " erps", "krp", "lerp", "errorp", "errps", " errm", "lerps", " errbp", " errr", " errpo", " erbp", "errorm"], "serial": ["usb", "Serial", "tty", "mot", "select", "custom", "erial", "human", "device", "sharp", "spot", "ident", "iso", "dev", "error", "normal", "machine", "quant", "local", "phone", "raw", "util", "json", "random", "handle", "ser", "cho", "series", "tel", "selected", "boot", "root", "final", "mobile", "bus", "specific", "unknown", "primary", "special", "remote", "host", "pal", "sel", "des", "serv", "private", "initial", "sys"], "fd": ["td", "fin", " fin", "dd", "off", "fi", "bf", " d", "fl", "ff", "file", "form", "df", "f", "ind", "fp", "ld", "da", "d", "cf", "fm", " td", "pd", "ud", "hd", "fb", " df", "ptr", "fe", "cb", "fa", "dt", "ln", "gd", "cond", "fn", "dl", " ff", "fr", "dir", "FD", " fid", "ped", "elt", "dat", "bd", "fs", "fee", "fc", "fed", "ini", " f", "disk", "nd", " fut", "ds", "sd", "af"]}}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void alpha_pci_vga_setup(PCIBus *pci_bus)\n\n{\n\n    switch (vga_interface_type) {\n\n#ifdef CONFIG_SPICE\n\n    case VGA_QXL:\n\n        pci_create_simple(pci_bus, -1, \"qxl-vga\");\n\n        return;\n\n#endif\n\n    case VGA_CIRRUS:\n\n        pci_cirrus_vga_init(pci_bus);\n\n        return;\n\n    case VGA_VMWARE:\n\n        if (pci_vmsvga_init(pci_bus)) {\n\n            return;\n\n        }\n\n        break;\n\n    }\n\n    /* If VGA is enabled at all, and one of the above didn't work, then\n\n       fallback to Standard VGA.  */\n\n    if (vga_interface_type != VGA_NONE) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n", "idx": 11843, "substitutes": {"pci_bus": ["pci_driver", "pca_bus", "pca_component", "pdi_byte", "pcietybox", "pcp_bus", "pci__bus", "pciitycomponent", "pciityBUS", "pcietyloop", "pci_boot", "pciitybus", "pci_interface", "pca_host", "pcpetybox", "pciitydriver", "pcimybus", "pci_loop", "pci_BUS", "pcp_lock", "pcp_loop", "pcimylock", "pcimybox", "pdi_bus", "ppi_boot", "pcietylock", "pca_box", "pcimyloop", "pcpetyloop", "pciitybyte", "pca_boot", "pci__bridge", "pcpetybus", "pciityinterface", "pci__boot", "pci_Bus", "pci_component", "pciityhost", "pci_host", "pciityBus", "pcpetylock", "pci_box", "pci_lock", "pciityboot", "pca_bridge", "pcietybus", "ppi_bus", "pci_byte", "pcp_box", "pdi_BUS", "ppi_driver", "ppi_interface", "pci_bridge", "pca_Bus", "pdi_boot", "pci__box"]}}
{"project": "qemu", "commit_id": "75554a3ca10a7ad295d2a3d2e14ee6ba90f94c8b", "target": 0, "func": "struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)\n\n{\n\n    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);\n\n    struct omap_uart_s *s = omap_uart_init(base, irq,\n\n                    fclk, iclk, txdma, rxdma, chr);\n\n    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,\n\n                    omap_uart_writefn, s);\n\n\n\n    s->ta = ta;\n\n    s->base = base;\n\n\n\n    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);\n\n\n\n    return s;\n\n}\n", "idx": 11844, "substitutes": {"ta": ["tm", "ba", "ota", "tr", "beta", "tx", "la", "na", "tp", "a", "base", "tie", "tta", "bas", "meta", "eta", "da", "ra", "ata", "te", "Ta", "ti", "ka", "fa", "mu", "mi", "wa", "ma", "ts", "t", "tor", "pha", "tap", "sa", "po", "pi", "si", "tar", "TA", "tu", "oa", "ca", "mt", "pa"], "irq": [" irquire", " irqs", " irqu", "pirqs", "mrq", "irqs", "mrql", "ironqs", "ironquire", "mrqs", " irquest", "irqu", "pirquest", "pirq", "pirqu", "ironquest", "ironq", "irquest", "irql", "pirquire", " irql", "mrqu", "pirql", "irquire"], "fclk": [" fcld", "flq", "flk", "lfclq", "fllk", " fpld", "foclke", "lfclik", "fslq", "fclik", "fcld", "fslk", "fplke", " fclke", "flltk", "lfcltk", "flik", "fmild", "fllq", "fplk", "fclke", "fllik", "fcltk", "fslik", "fmilke", "foclk", "fltk", "lfllik", "fclq", " fplke", "focld", "fmilk", "fpld", "lfllq", "lflltk", " fplk", "lfclk", "fsltk", "lfllk"], "iclk": ["ICrlke", "icflq", "iccllq", "icflck", "icllq", "icllj", "ICrlk", "IClk", "icllk", "icdlq", "iccllk", "icdlk", "iclq", "icrlke", "ICrlck", "icclq", "iclj", "iclck", "icdlj", "icllke", "icflke", "icdlke", "iclke", "iccllj", "icrlck", "IClke", "icflk", "icclj", "IClck", "icrlq", "icclck", "icclke", "iccllke", "IClq", "icclk", "icrlk", "icrlj", "ICrlq"], "txdma": ["txDna", " txdna", "xdmas", "xdmm", "txnmm", " txdmm", "txDmm", "txnmas", " txdmas", "txnna", "txnma", "xdma", "txlma", "txsdms", "txlmm", " txsdmas", " txsdmm", "txsdma", "txdmm", "txsdmas", "txDma", "txdmas", "xlma", "txlmas", " txsdna", "txDms", "txDmas", "xlms", "xdms", " txsdma", "xlmm", "txsdmm", "txlms", "txdna", "txdms", "txsdna", "xlmas"], "rxdma": ["rdxma", " rdxota", "rdxm", "rdxda", "rxdda", "rxdmas", "rdxota", " rdxda", "rxdmm", " rxdota", "rxdota", " rxdmm", "rddota", " rdxma", "rvdota", " rxdm", "rrdda", " rxdmas", "rddmas", "rddm", " rdxmas", "rrdmm", "rcdmm", "rrdma", "rdxmas", " rdxmm", "rddma", " rxdda", "rvdma", "rcdmas", "rcdma", "rxdm", "rvdmas", "rcdda", "rvdm", "rdxmm", "rrdmas", " rdxm"], "chr": ["chre", "chsr", "clsr", " chrs", "Chrs", "Char", "shsr", " chre", "clre", "shr", "cherrs", "shre", "chrs", "clrs", "Chrg", "cherar", "Chr", "cherr", "chrg", "cherrg", " chrg", "clr", "shrs", " chsr"], "s": ["ms", "ports", "sq", "vs", "sl", "gets", "a", "ats", "qs", "rs", " is", "hs", "p", "gs", "sts", "o", "sm", "f", "ps", " gets", "changes", "g", "cs", "m", "l", "bits", "ins", "sv", "i", "ies", "es", "bs", "services", " reports", "details", "r", "is", "js", "S", "ss", "ts", "se", "n", "its", "als", "t", " sets", "v", "e", "sb", "b", "os", "c", "h", "sa", "ns", "stats", "w", "fs", "des", "single", "ls", "states", "rates", "ds", "su"]}}
{"project": "qemu", "commit_id": "6e6e55f5c2e5b520d6506c2716287ba3b5d1bbc8", "target": 0, "func": "static void QEMU_NORETURN help(void)\n\n{\n\n    const char *help_msg =\n\n           QEMU_IMG_VERSION\n\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n\n           \"QEMU disk image utility\\n\"\n\n           \"\\n\"\n\n           \"    '-h', '--help'       display this help and exit\\n\"\n\n           \"    '-V', '--version'    output version information and exit\\n\"\n\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\n           \"                         specify tracing options\\n\"\n\n           \"\\n\"\n\n           \"Command syntax:\\n\"\n\n#define DEF(option, callback, arg_string)        \\\n\n           \"  \" arg_string \"\\n\"\n\n#include \"qemu-img-cmds.h\"\n\n#undef DEF\n\n#undef GEN_DOCS\n\n           \"\\n\"\n\n           \"Command parameters:\\n\"\n\n           \"  'filename' is a disk image filename\\n\"\n\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n\n           \"    manual page for a description of the object properties. The most common\\n\"\n\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n\n           \"    encryption keys.\\n\"\n\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n\n           \"    options are the same as for the 'cache' option\\n\"\n\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n\n           \"    supported. 'b' is ignored.\\n\"\n\n           \"  'output_filename' is the destination disk image filename\\n\"\n\n           \"  'output_fmt' is the destination format\\n\"\n\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n\n           \"    used format\\n\"\n\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\n           \"    '[ID_OR_NAME]'\\n\"\n\n           \"  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\\n\"\n\n           \"    instead\\n\"\n\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n\n           \"  '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\"\n\n           \"       match exactly. The image doesn't need a working backing file before\\n\"\n\n           \"       rebasing in this case (useful for renaming the backing file)\\n\"\n\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n\n           \"  '-p' show progress of command (only certain commands)\\n\"\n\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n\n           \"       fully allocated\\n\"\n\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n\n           \"       prior to running qemu-img)\\n\"\n\n           \"\\n\"\n\n           \"Parameters to check subcommand:\\n\"\n\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n\n           \"       hiding corruption that has already occurred.\\n\"\n\n           \"\\n\"\n\n           \"Parameters to convert subcommand:\\n\"\n\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n\n           \"       process (defaults to 8)\\n\"\n\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n\n           \"\\n\"\n\n           \"Parameters to snapshot subcommand:\\n\"\n\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n\n           \"  '-c' creates a snapshot\\n\"\n\n           \"  '-d' deletes a snapshot\\n\"\n\n           \"  '-l' lists all snapshots in the given image\\n\"\n\n           \"\\n\"\n\n           \"Parameters to compare subcommand:\\n\"\n\n           \"  '-f' first image format\\n\"\n\n           \"  '-F' second image format\\n\"\n\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n\n           \"\\n\"\n\n           \"Parameters to dd subcommand:\\n\"\n\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n\n           \"(default: 512)\\n\"\n\n           \"  'count=N' copy only N input blocks\\n\"\n\n           \"  'if=FILE' read from FILE\\n\"\n\n           \"  'of=FILE' write to FILE\\n\"\n\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n\n    bdrv_iterate_format(format_print, NULL);\n\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n\n}\n", "idx": 11852, "substitutes": {"QEMU_NORETURN": ["QEMU_NEPurn", "QEMU_NETEXT", "QEMU_NORET_", "QEMU_NORetEXT", "QEMU_NORETSEXT", "QEMU_NOREP_", "QEMU_NOREPurn", "QEMU_NETURN", "QEMU_NEPEXT", "QEMU_NORETEXT", "QEMU_NORETS_", "QEMU_NOREPEXT", "QEMU_NOReturn", "QEMU_NOREPURN", "QEMU_NEP_", "QEMU_NET_", "QEMU_NORet_", "QEMU_NEPURN", "QEMU_NORETSurn", "QEMU_NORetURN", "QEMU_NORETSURN", "QEMU_NORETurn", "QEMU_NETurn"], "help_msg": ["help_info", " help_message", "help_message", " help_Msg", " help_info", "help_Msg"]}}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void coroutine_fn bdrv_create_co_entry(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    CreateCo *cco = opaque;\n\n    assert(cco->drv);\n\n\n\n    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(&cco->err, local_err);\n\n    }\n\n    cco->ret = ret;\n\n}\n", "idx": 11853, "substitutes": {"opaque": ["porulent", "OPinion", "Opaque", "OPulent", " copacement", "hopinion", "OPaque", "opulent", "metlation", "opinion", "Opacity", "porinion", "Oplation", "hopulent", "poratile", " copacity", "metacity", "metaque", "hopatile", "Opacement", "metacement", "hopaque", "OPatile", "opacement", "poraque", " coplation", "oplation", " copaque", "opatile", "opacity"], "local_err": [" local_er", "other_plain", "local_loc", "otherityarr", "localeder", "local_arr", "local_error", "local_attr", "localedlr", "otherityerr", "localityerr", " locally_er", "localityplain", "local___usr", " locally_attr", " local_txt", "local___lr", "local___arr", "local___loc", "local_er", "local___er", "state_err", "local_lr", "state_loc", "local_txt", " locally_error", "state___loc", "localederr", "local___plain", "other_arr", "state___err", "local_plain", " local_lr", "local___error", "localedtxt", "local___attr", "other_err", "state___usr", "localityarr", "local_usr", "otherityplain", " locally_err", "local___txt", "local___err", "state_usr"], "ret": ["len", "tr", "lt", "lit", "pas", " RET", "reset", "url", "pat", "nl", "flag", "uf", "pt", "err", "nz", "RET", "resp", "reply", "nt", "cat", "rev", "ref", "inter", "mt", "def", "fun", "ptr", "pret", "vt", "alt", "mem", "ext", "r", "cont", "rel", "ben", "t", "rem", "rets", "deg", "arg", "gc", "val", "Ret", "rect", "xt", "rt", "re", "elt", "rest", "res", "rm", "ft", "get", "att", "gt", "ll", "Return", "out"], "cco": ["eca", "czo", " icO", "CCoo", "becos", "ecoo", " icos", "ckoin", "cku", " ccco", "ccano", "becpo", "inco", "incopy", "cO", "eco", "CCO", "becoin", " ccoo", "ckoo", "ccpo", " ico", "czos", "CCopy", "czO", " aco", "fcoin", "fco", "ccO", " icco", "ecov", "ccov", "ccu", "scoin", "cza", "ccco", "beco", "czco", "czano", "ckco", "incos", "scpo", "ccoin", "ckO", "incoin", "cca", "CCo", " cca", "cov", "ccos", "ckov", "czopy", "ecco", "sco", "ecu", "scos", "czoin", "CCos", " ccoin", "ecano", " ccO", "CCoin", "cko", "fcos", "coo", " acO", " ccos", " ccano", "fcpo", "cu", "co", "ccopy", "coin", "ccoo", " acco"]}}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)\n\n{\n\n    target_ulong old, val, mask;\n\n    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;\n\n    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {\n\n        mask |= 1 << CP0EnHi_EHINV;\n\n    }\n\n\n\n    /* 1k pages not implemented */\n\n#if defined(TARGET_MIPS64)\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        int entryhi_r = extract64(arg1, 62, 2);\n\n        int config0_at = extract32(env->CP0_Config0, 13, 2);\n\n        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;\n\n        if ((entryhi_r == 2) ||\n\n            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {\n\n            /* skip EntryHi.R field if new value is reserved */\n\n            mask &= ~(0x3ull << 62);\n\n        }\n\n    }\n\n    mask &= env->SEGMask;\n\n#endif\n\n    old = env->CP0_EntryHi;\n\n    val = (arg1 & mask) | (old & ~mask);\n\n    env->CP0_EntryHi = val;\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_entryhi(env, env->current_tc);\n\n    }\n\n    /* If the ASID changes, flush qemu's TLB.  */\n\n    if ((old & env->CP0_EntryHi_ASID_mask) !=\n\n        (val & env->CP0_EntryHi_ASID_mask)) {\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n}\n", "idx": 11854, "substitutes": {"env": ["doc", "vs", "ah", "config", "end", "vv", "uv", "enter", "pg", "eng", "vp", "desc", "queue", "cmd", "serv", "ent", "org", "context", "cv", "era", "vert", "et", "code", "init", "tk", "ec", "ve", "buf", "gate", "en", "txt", "server", "ter", "outer", "test", "esc", "conn", "conf", "environment", "e", "sb", "eas", "oe", "door", "nv", "ef", "obj", "gear", "req", "err", "enc", "ev", "engine", "worker", "her", "vt", "window", "equ", "ctx", "forge", "hw", "er", "db", "console", "vm", "timer", "entry", "eh", "here", "event", "manager", "erd", "dev", "chart", "te", "cb", "addr", "ew", "pb", "v", "query", "msg", "ner"], "arg1": ["doc2", "Arg3", "Arg2", "arg5", "Arg4", "argument2", "args4", " arg2", "args3", "doc4", "args1", "doc3", "Arg1", " arg4", "arg4", "args2", "argument5", "arg2", "argument3", " arg5", "doc1", " arg3", "Arg5", "arg3", "argument1"], "old": [" local", "inner", "obj", "expected", "current", "off", "empty", " updated", "al", " unused", "add", "back", "or", " orig", "loc", "OLD", "older", "valid", " last", " ref", "hash", "var", "same", "ind", "ld", "hard", " saved", "oid", "bor", "ref", "local", "other", " previous", "hold", "handle", "alt", "mem", "ord", "holder", "index", " new", " os", "Old", " update", "test", "last", "new", "v", " error", "lower", "lock", "tmp", " low", "low", "from", "orig", "found", " handle", "diff", "equal", "x", " ind", "full", "set", " form", "le", "high", "arg", "ret"], "val": ["arr", "key", "obj", "tx", "entry", "al", "err", "VAL", "valid", "func", "value", "var", "buf", "p", "dev", "act", "mount", "ival", "rol", "ref", "Val", "vt", "alt", "mem", "cal", "eval", "index", "bit", "test", "data", "final", "new", "v", "pl", "pal", "pol", "bal", "orig", "sel", "elt", "res", "vals", "it", "x", "result", "item", "el", "aval", "iv", "max", "loc", "vol", "ret"], "mask": ["clear", "shift", "key", "mb", "map", "mx", "sum", "buffer", "sign", "flag", "message", "cmp", "match", "weight", "zip", "hash", "ban", "mass", "mount", "limit", "m", "block", "gate", "mas", "zero", "qual", "mn", "window", "mod", "miss", "hold", "filter", "black", "bit", "magic", "ma", "lag", "fix", "perm", "Mask", "mark", "mk", "shape", "transform", "mission", "lock", "cmd", "scale", "master", "mail", "flags", "tag", "ask", "mac", "batch", "broad", "set", "result", "mut", "pack", "patch", "sk", "mt", "mean"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static bool vmxnet3_verify_driver_magic(hwaddr dshmem)\n\n{\n\n    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);\n\n}\n", "idx": 11861, "substitutes": {"dshmem": ["dSHms", "dskMem", " dshram", " dshms", "deshram", "dshtab", " dshtab", "dskmem", "dchmem", "dSHmem", "dhmem", "dhtab", "deshms", "dhMem", "dskmemory", " dshmemory", "dshmemory", "dshram", "dhmemory", "dSHram", " dchms", "deshmem", "dsktab", " dchmem", "dchram", "dshMem", "dshms", " dshMem", "dchms", " dchram"]}}
{"project": "qemu", "commit_id": "7443b43758ba5eeca8f81ca15fe9fced8983be26", "target": 1, "func": "ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n", "idx": 11865, "substitutes": {"ptr": ["src", "arr", "obj", "tr", "tty", "id", "pc", "address", "buffer", "pointer", "pt", "alloc", "proc", "p", "resp", "buf", "sp", "dev", "ps", "pad", "ind", "rob", "th", "jp", "pos", "ref", "inter", "desc", "port", "handle", "addr", "mem", "index", "r", "expr", "kl", "t", "ctx", "rc", "deg", "pr", "ctr", "eth", "rt", "hw", "str", "Ptr", "iv", "loc", "dr"], "ram_addr": ["ram__address", "gram_address", "ram_add", "ram_cmd", " ram_cmd", "ram__info", "ram____env", "gram_addr", " ram__addr", "ram__ptr", " ram__add", "ram_ptr", "sam_info", " ram__cmd", "ram__obj", "ram_obj", "ram_env", "sam_ptr", "ram__add", "ram_info", "ram__addr", "gram_env", " ram_obj", "sam_addr", " ram_add", "ram_address", " ram__obj", "ram__cmd", "sam_address", "ram____address", "ram____addr"]}}
{"project": "FFmpeg", "commit_id": "03acb035d1292685cc24a2be0f62dd8332711734", "target": 1, "func": "static int decode_format80(VqaContext *s, int src_size,\n\n    unsigned char *dest, int dest_size, int check_size) {\n\n\n\n    int dest_index = 0;\n\n    int count, opcode, start;\n\n    int src_pos;\n\n    unsigned char color;\n\n    int i;\n\n\n\n    start = bytestream2_tell(&s->gb);\n\n    while (bytestream2_tell(&s->gb) - start < src_size) {\n\n        opcode = bytestream2_get_byte(&s->gb);\n\n        av_dlog(s->avctx, \"opcode %02X: \", opcode);\n\n\n\n        /* 0x80 means that frame is finished */\n\n        if (opcode == 0x80)\n\n            break;\n\n\n\n        if (dest_index >= dest_size) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (opcode == 0xFF) {\n\n\n\n            count   = bytestream2_get_le16(&s->gb);\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(1) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode == 0xFE) {\n\n\n\n            count = bytestream2_get_le16(&s->gb);\n\n            color = bytestream2_get_byte(&s->gb);\n\n            av_dlog(s->avctx, \"(2) set %X bytes to %02X\\n\", count, color);\n\n            CHECK_COUNT();\n\n            memset(&dest[dest_index], color, count);\n\n            dest_index += count;\n\n\n\n        } else if ((opcode & 0xC0) == 0xC0) {\n\n\n\n            count = (opcode & 0x3F) + 3;\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode > 0x80) {\n\n\n\n            count = opcode & 0x3F;\n\n            av_dlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count);\n\n            CHECK_COUNT();\n\n            bytestream2_get_buffer(&s->gb, &dest[dest_index], count);\n\n            dest_index += count;\n\n\n\n        } else {\n\n\n\n            count = ((opcode & 0x70) >> 4) + 3;\n\n            src_pos = bytestream2_get_byte(&s->gb) | ((opcode & 0x0F) << 8);\n\n            av_dlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(dest_index - src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n\n            dest_index += count;\n\n        }\n\n    }\n\n\n\n    /* validate that the entire destination buffer was filled; this is\n\n     * important for decoding frame maps since each vector needs to have a\n\n     * codebook entry; it is not important for compressed codebooks because\n\n     * not every entry needs to be filled */\n\n    if (check_size)\n\n        if (dest_index < dest_size)\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n\n\n    return 0; // let's display what we decoded anyway\n\n}\n", "idx": 11877, "substitutes": {"s": ["ms", "sq", "vs", "qs", "a", "ats", "rs", "as", "sg", "hs", "gs", "sts", "an", "f", "ps", "ants", "ess", "changes", "cs", "m", "ains", "bits", "ies", "es", "ses", "sv", "ins", "bs", "store", "params", "aws", "r", "is", "js", "als", "S", "ss", "ts", "n", "less", "details", "erences", "t", "sports", "its", "v", "conf", "j", "os", "sb", "e", "c", "bis", "h", "ns", "stats", "fs", "serv", "comm", "ls", "ims", "ds", "sys", "parts"], "src_size": ["src_length", "src_offset", "rc_offset", "rc_SIZE", "src_end", "rc_size", "rc_name", "src_SIZE", "src_name", "rc_length", "rc_end"], "dest": ["src", "tr", "priv", "status", "sum", "source", "buffer", "config", "decl", "end", "buf", "dev", "trans", "iter", "dc", "cat", "way", "del", "gate", "null", "ptr", "desc", "port", "txt", "usr", "mem", "cont", "test", "global", "comb", "sort", "v", "good", "tmp", "copy", "master", "target", "orig", "origin", "dist", "temp", "rest", "est", "st", "csv", "table", "Dest", "result", "set", "loc", "out", "foreign"], "dest_size": ["dest_set", "dest_SIZE", "dest2name", "destrictname", "Dest_set", "destrictindex", "dest2size", "Dest_SIZE", "dest_index", "dest2index", "Dest_Size", "dest_num", "destrictsize", " dest_num", " dest_index", "dest_Size", "Dest_size", "dest2num", "dest_name", "Dest_index", " dest_name", "destrictnum"], "check_size": ["checkktoffset", "addrktnum", "checkktnum", "addr_offset", "addrktoffset", "checkmodsize", "addr_size", "check_offset", "checkbufpadding", "checkbufnum", "addrktsize", "checkmodnum", "check_padding", "addr_padding", "checkktsize", "addrktpadding", "checkmodpadding", "checkmodoffset", "check_num", "checkbufoffset", "checkktpadding", "addr_num", "checkbufsize"], "count": ["command", "each", "add", "ct", "mount", "ount", "cc", "amount", "allow", "check", "found", "cmd", "nb", "history", "size", "col", "depth", "frequency", "call", "code", "match", "weight", "height", "score", "limit", "test", "cond", "Count", "conf", "cast", "force", "z", "cost", "draw", "number", "current", "counter", "hash", "nt", "cycle", "process", "cd", "type", "balance", "filter", "hold", "index", "n", "now", "info", "comment", "make", "only", "find", "len", "empty", "num", "sum", "flag", "list", "common", "all", "core", "cont", "total", "collection", "v", "cache", "val", "ctr", "c", "set", "C", "important", "max", "offset", "length"], "opcode": ["iopCode", " opCode", "iopcode", "oppno", "hopcache", " opcod", "hopcase", "oppnum", "operse", "hopce", "OPCode", "opce", "iopclass", "operno", "opnum", "hopno", "opcase", "operCode", "itso", "ropcode", " opno", " opcommand", "opct", "opcache", "operct", "hopcod", " opclass", "hopcode", "oppcode", "opercache", "deepcode", "deepcase", "ropdate", "Opno", "itCode", "itcode", "opse", "OPcase", "OPno", "iopdate", "OpCode", "OPnum", "hopse", "operce", "operclass", "Opnum", " opce", "oppCode", "deepcod", "Opcode", "opercode", " opdate", "opcommand", "OPcommand", "OPcode", " opso", "opcod", "opso", "hopcommand", "itcod", " opse", "deepno", "OPcod", "opercommand", "OPce", "hopso", "ropCode", " opcache", "opno", "opclass", "ropclass", " opct", "opdate", "hopCode", "OPct", "hopclass", "opCode"], "start": ["shift", "len", "art", "next", "id", "reset", "starting", "part", "base", "init", "end", "begin", "seek", "wind", "p", "sp", "first", "trans", "stop", "pos", "limit", " Start", "ish", "in", "index", "top", "import", "skip", "check", "from", "origin", "Start", "st", "it", "get", "set", "time", "head", "before", "offset", "size"], "src_pos": [" src_pc", "src_rot", "source_loc", "src_index", "src_loc", "src___rot", "src___pos", "src_parent", "src67os", "src_pt", "srcmmlen", "srcmmpos", "src64pos", "source_pos", "src10pos", "src_po", "src10pc", " src_offset", "srczparent", "src_os", " src_pt", "source_po", "src_pat", "src_offset", "src_position", "src_cos", " src_rot", "src67position", "src1os", " src_loc", "src_len", "dest_pos", "srcmmindex", "dest_pat", "src64cos", "dest_index", " src_parent", "dest_len", "src_pc", " src_po", "src67pt", " src_position", "srcmmpat", "srczpos", " src_os", "source_cos", "src1pos", "src67pos", "src64os", " src_cos", "src10rot", "src___pc", "src1cos", "srczpo"], "color": ["col", "key", "colored", "category", "source", "code", "feature", "or", "cor", "role", "err", "theme", "value", "hash", "white", "pair", "normal", "cat", "other", "type", "pixel", "parent", "token", "term", "background", "black", "r", "blue", "alpha", "coll", "COLOR", "rc", "colour", "c", "Color", "comment", "red", "olor", " colour", "font", "border", "country", "light", "name", "state", "style"], "i": ["u", "func", "o", "m", "im", "ski", "y", "t", "ci", "zi", "cmd", "gi", "pi", "hi", "ji", "ims", "key", "cmp", "I", "li", "uri", "init", "ind", "iter", "g", "ki", "ti", "mi", "ix", "xi", "multi", "qi", "si", "batch", "id", "ai", "buffer", "ei", "var", "ui", "ip", "ic", "in", "index", "_", "chain", "n", "\u0438", "phi", "copy", "it", "ini", "ii", "uint", "fi", "me", "q", "p", "sim", "cli", "ish", "is", "cont", "j", "iu", "v", "c", "di", "bi", "x", " ii", "C", " j", "ij"]}}
{"project": "FFmpeg", "commit_id": "d3b25383daffac154846daeb4e4fb46569e728db", "target": 1, "func": "static int zero12v_decode_frame(AVCodecContext *avctx, void *data,\n\n                                int *got_frame, AVPacket *avpkt)\n\n{\n\n    int line = 0, ret;\n\n    const int width = avctx->width;\n\n    AVFrame *pic = data;\n\n    uint16_t *y, *u, *v;\n\n    const uint8_t *line_end, *src = avpkt->data;\n\n    int stride = avctx->width * 8 / 3;\n\n\n\n    if (width == 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Width 1 not supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')\n\n        && avpkt->size % avctx->height == 0\n\n        && avpkt->size / avctx->height * 3 >= width * 8)\n\n        stride = avpkt->size / avctx->height;\n\n\n\n    if (avpkt->size < avctx->height * stride) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small: %d instead of %d\\n\",\n\n               avpkt->size, avctx->height * stride);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n    pic->key_frame = 1;\n\n\n\n    y = (uint16_t *)pic->data[0];\n\n    u = (uint16_t *)pic->data[1];\n\n    v = (uint16_t *)pic->data[2];\n\n    line_end = avpkt->data + stride;\n\n\n\n    while (line++ < avctx->height) {\n\n        while (1) {\n\n            uint32_t t = AV_RL32(src);\n\n            src += 4;\n\n            *u++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *v++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *u++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 2) {\n\n                if (!(width & 1)) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *v++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *u++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *v++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 2) {\n\n                if (width & 1) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 11885, "substitutes": {"avctx": [" avcontext", "avconn", "avecontext", "navcmd", "navcu", "afdyl", "avcmd", "ajreq", "averctx", "avcmp", "averjac", "avejac", "averreq", "ajconn", "avercfg", "avetx", " avctl", "avetmp", "abcmp", "avepkg", "avdyl", "aftx", "abtx", "avereq", "avectl", "ajpkg", "navctx", "averlvl", "awcmd", "avcontext", "afconn", "ajtmp", "avercontext", "ajctx", "avekl", "avectx", "ajtx", " avconn", "afcmp", "avertmp", "ajctl", "avtmp", "navdyl", "avcfg", "ajcontext", "afcfg", " avtx", "avercmd", "averkl", "avcu", "ajjac", " avcmd", "ajcfg", "avctl", "aflvl", "afctx", "avlvl", "ajcmd", "avelvl", "abctx", "awcontext", "ajkl", "avecmd", " avcmp", " avcfg", "afcontext", "avercc", "abcontext", "avjac", "avcc", "awctx", "navcontext", "avedyl", "afcc", "avecfg", "avecc", " avpkg", " avcu", "afcu", "awtx", "avreq", "avkl", "navtx", "afcmd", " avjac", "avertx", "avtx", "avpkg"], "data": ["format", "first", "name", "d", "block", "m", "bits", "values", "stack", "r", "done", "t", "times", "str", "ot", "w", "options", "history", "size", "items", "depth", "Data", "next", "pieces", "record", "read", "code", "message", "at", "init", "value", "buf", "height", "args", "mu", "rel", "video", "new", "date", "dat", "table", "DATA", "byte", "params", "number", "obj", "current", "id", "buffer", "a", "device", "image", "step", "file", "area", "hash", "error", "frame", "def", "i", "raw", "window", "ic", "plain", "index", "mode", "feed", "info", "action", "ns", "it", "empty", "num", "extra", "text", "blocks", "padding", "base", "list", "to", "p", "bin", "pad", "ata", "bytes", "ext", "cache", "input", "val", "origin", "response", "offset", "length"], "got_frame": ["got_state", "got_frames", "received_error", "got2frame", "got2frames", "got_error", "received_frames", "got2error", "received_frame", "got2state", "received_state"], "avpkt": ["wavpadkg", "avpacket", "avcpct", "avenpacket", "avewpacket", "airwpcht", "aftpatx", "avipkg", "afpkt", "avcpwk", "avpaycht", "avPkt", "avwpkg", "avprekg", "wavpadkt", "afcpet", "afpdat", "avptx", "avPnt", "afcpkt", "avppct", "afcpacket", "wavpadct", "avpartnt", "avnpKT", "avpatx", "avwpett", "avpadat", "avprekt", "airwpkt", "aftpnt", "avnpet", "afcpnt", "avcpet", "avpadkg", "avcpKT", "avepkg", "avpawk", "avepacket", "avpant", "avwpkt", "aftpkt", "avepett", "avnpdat", "avsptx", "avcptx", "avipacket", "afpwt", "afpnt", "avcpacket", "avppnt", "avpnt", "avcpnt", "avepkt", "aftpakt", "avpatacket", "avjpct", "avwpacket", "avenpKT", "airwpacket", "airpacket", "avppkt", "avlpacket", "avpaykt", "avpaywt", "avnpkt", "avPht", "avcpkt", "avjpnt", " avpht", "avnpacket", "avpaacket", "avpaet", "avpartkt", "avjpkt", "avpadkt", "afpcht", "avwpet", "afpacket", "avpcht", "avspnt", "avpett", "avpatKT", " avpct", "avpreacket", "avpdat", "airpkt", "avpwk", "avwpcht", "avPct", " avPct", "wavpkg", "wavpacket", "airpcht", "avipet", "avpatkt", "avspwk", "avcpett", "aftptx", "avewpet", "avenpkt", "avpadct", "afcpcht", "avlpkt", "avewpkt", "afcpwt", " avPht", "avpartwt", "avpKT", "avepet", "avnpkg", "airpett", "avlpcht", "avpaynt", "avepKT", "wavpkt", "avipkt", "avspkt", "avcpdat", "afpet", "avcpkg", "avenpett", "avprect", "avnpett", " avpnt", "avcpcht", "wavpadacket", "avppht", "wavpct", "avpwt", "avpct", " avPnt", "airwpett", "avlpett", "avpakt", " avPkt", "avpht", "avpatett", "aftpawk", "afcpdat", "aftpant", "avpartcht", "avpkg", "aftpwk", "avpet", "avewpkg", "avpadacket", "avjpht", "avcpwt"], "ret": ["fin", "len", "tr", "success", "lit", "reset", "status", "back", "flag", "format", "err", "print", "det", "RET", "resp", "ry", "nt", "jp", "ref", "pret", "def", "progress", "txt", "alt", "mem", "try", "cont", "rel", "rem", "rets", "fr", "not", "val", "Ret", "rt", "re", "elt", "res", "rm", "it", "result", "gt", "ll", "ft", "out", "mt"], "pic": ["jac", "lp", "py", "tt", "png", "Pic", "typ", "pc", "pat", "tx", "syn", "vol", "pt", "pse", "ping", "cam", "pan", "picture", "iac", "p", "peg", "sp", "kt", "ps", "fp", "mic", "ip", "jp", "capt", "ic", "parse", "ican", "txt", "ig", "pit", "Pict", "pick", "shot", "pres", "plain", "script", "magic", "perm", "photo", "ctx", "ac", "px", "pen", "fr", "feat", "xi", "pl", "pot", "gc", "chat", "wp", "anc", "pol", "ot", "eric", "pin", "pert", "pi", "stat", "fc", "pict", "piece", "phys", "Picture", "img", "kit", "mt", "pa"], "y": ["key", "yt", "py", "xy", "axy", "sky", "ch", "vy", "cy", "yy", "ny", "k", "p", "o", "ay", "height", "g", "l", "m", "oy", "my", "i", "ye", "yer", "iny", "dy", "r", "ys", "j", "top", "n", "t", "yr", "Y", "rot", "yo", "ey", "e", "b", "c", "h", "ly", "gy", "sy", "ym", "w", "iy", "by", "x", "z", "s", "yl", "yi", "offset", "sys"], "u": ["uf", "k", "uv", "p", "uid", "o", "nu", "f", "au", "pu", "lu", "ui", "U", "ut", "l", "um", "i", "util", "ou", "mu", "us", "n", "uni", "iu", "t", "fu", "un", "c", "uc", "h", "uu", "eu", "w", "cu", "ul", "x", "ur", "tu", "ue", "su"], "v": ["nv", "a", "va", "av", "vi", "q", "k", "vv", "uv", "ve", "var", "p", "o", "f", "vp", "g", "l", "m", "sv", "i", "qv", "vt", "ver", "j", "version", "n", "t", "V", "e", "b", "c", "h", "w", "x", "vr", "cv", "iv", "vc", "conv", "vol"], "line_end": ["linePender", " line2start", " line_id", "line2end", " line_bound", " line_ended", "line2start", "line2ends", "linePstart", "line_ended", "line_start", "line_END", " line2end", "line2id", "line_id", " line_start", "linePend", " line_ender", " line_END", "line2END", "line_bound", " line_ends", " line2ends", "line_ender", "linePbound", " line2END", "line_ends"], "src": ["inner", "sq", "lin", "filename", "sync", "sl", "url", "tp", "source", "text", "rs", "err", "sub", "iter", "sec", "bc", "th", "pos", "l", "attr", "hl", "ptr", "i", "ic", "txt", "addr", "in", "lat", "ser", "rl", "r", "row", "dest", "ix", "scan", "rc", "nr", "input", "sb", "ctr", "c", "comp", "sn", "str", "rt", "start", "sr", "st", "slice", "sc", "fc", "x", "img", "ur", "time", "s", "loc", "syn", "sys"], "line": ["page", "depth", "lin", "id", "pe", "nl", "ie", "path", "code", "source", "li", "cell", "Line", "file", " stroke", "pair", "frame", "lines", "eline", "iter", "block", "l", "pos", "pixel", " lin", "position", "port", "i", "length", "ine", "edge", "ln", "row", " frame", "level", "se", "node", " l", " lines", "e", "pipe", "slice", " row", "link", "LINE", "ode", " slide", "ide", "lo", "no", "le", "offset", "liner"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n", "idx": 11911, "substitutes": {"field": ["butt", "array", "address", "map", "buffer", "message", "flag", "match", "cell", "manager", "list", "file", "form", "ment", "f", "pair", "pad", "word", "window", "term", "queue", "Field", "row", "FIELD", "test", "node", "fields", "line", "master", "league", "load", "rule", "tag", "table", "link", "group", "pack", "bar", "grid"], "bit": ["uint", "key", "gem", "op", "id", "status", "board", "hit", "config", "ch", "flag", "p", "point", "task", "bin", "unit", "slot", "bc", "ip", "block", "bits", "git", "i", "word", "port", "row", "test", "t", "ac", "check", "rot", "Bit", "b", "lock", "bot", "tag", "bug", "band", "it", "x", "piece", "bt", "byte", "BIT"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    res = 999;\n\n    endptr = &f;\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 11919, "substitutes": {"str": ["arr", "doc", "len", "obj", "tr", "inner", "spec", "buffer", "vol", "text", "prefix", "format", "end", "print", "Str", "list", "form", "sp", "p", "buf", "seq", "sts", "rep", "f", "iter", "trans", "gr", "del", "cur", "cs", "ptr", "shr", "length", "raw", "txt", "expr", "r", "chain", "cont", "br", "coll", "n", "t", "new", "fr", "pr", "ctr", "orig", "re", "res", "st", "stri", "msg", "STR", "s", "String", "name", "pre", "inst", "ar", "dr", "out"], "endptr": [" endPtr", "ENDcert", "appendpt", "appendcap", "endaddr", "appendptr", "endedobj", "endercap", "endset", "endedptr", "startobj", "enderset", "startcap", "endedpointers", "endedpointer", "endedctr", "postset", "startpt", "intaddr", "postpt", "endser", "endedPtr", "ENDaddr", "endobj", "endedcert", "endedser", "enderpt", "postptr", "endcert", " endaddr", "entptr", "endedpt", "enderctr", "enderpointers", "entpt", "endpointer", "enderptr", " endcert", "intcert", "endctr", "enderpointer", "enderPtr", " endpointers", "endPtr", "endedset", "intptr", "endpt", "intpointer", "startpointer", "appendpointer", "startptr", "endcap", "enderser", " endpointer", "endpointers", "ENDpointer", "endercert", "entcert", " endobj", "startaddr", "ENDptr", "entctr", "postser", "endedaddr"], "err": ["arr", "warn", "kr", "inner", "norm", " cr", "notice", "hr", "Error", "lr", "req", "here", "erd", "resp", "error", " ec", " Err", "iter", "ox", "gr", " terr", "act", "erer", "cer", "attr", "gz", "ere", "eor", " arr", "shr", "progress", "rr", "mr", "urg", "usr", "ger", "Er", "r", "rel", " fr", "br", "coll", "repl", "conf", "irm", "fr", " error", "pr", "ler", "e", "die", " score", "der", " dist", "cmd", " er", "res", "er", "spr", "diff", "z", "rer", "ner", "cr", " gr", "rar", "dr", "sys"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n", "idx": 11933, "substitutes": {"klass": ["ikktor", " klasses", "ikkclass", " ktor", "oklas", " kls", "ktor", "okls", "kclass", " klas", "Klasses", "ikkls", "Kcl", " kclass", "klas", "ikcl", "Klass", "cctor", "cclass", "ccls", "Kls", "kls", "kcl", "oklass", " kcl", "ikls", "okclass", "ikklas", "klasses", "iklasses", "ikklass", "ccclass", "iklass"], "data": ["key", "Data", " d", "rec", "o", " Data", "dev", "bin", "d", " DATA", "m", "ata", "def", "raw", "json", "mu", "r", "rc", " sd", "dat", "di", "res", "result", "DATA", "module", "name", "out"], "dc": ["doc", "ck", "dd", "pc", "a", "cca", "DC", "nz", "ec", "iac", "p", "cp", "da", "d", "bc", "tc", "cs", "cd", "m", "i", "desc", "ic", "cc", "ta", "dk", "ga", "mc", "lc", "rc", "gc", " DC", "c", "cmd", "di", "cm", "nc", "kw", "dp", "disc", "fc", "db", "dm", "dh", "cr", "dt", "ca"], "k": ["kit", "kr", "key", "ck", "ko", "spec", "kick", "K", "q", "tk", "ak", "wk", "ack", "kt", "kar", "kan", "rek", "p", "o", "ku", "kid", "ok", "d", "g", "m", "ki", "i", "kind", "ka", "dk", "j", "kl", "n", "mc", "t", "ikk", "kn", "ik", "kat", "mk", "uk", "b", "c", "kh", "ijk", "kw", "ks", "it", "z", "km", "ek", "work", "kj", "sk", "kk"]}}
{"project": "qemu", "commit_id": "eefa3d8ef649f9055611361e2201cca49f8c3433", "target": 1, "func": "qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n", "idx": 11936, "substitutes": {"wsource": ["hwsequence", "wasource", "wmessage", "awsite", " wservice", "waservice", "wser", " wscope", "waource", " winput", "winterface", "awource", "wcause", "wtseries", "wordsequence", "winput", "rwsource", "wtsession", "wtstore", " wource", "wscope", "wtcause", "wordmessage", " wseries", "ysource", "hwmessage", "hwsource", "wasite", "wsession", "expinput", " wser", "rwinterface", "walinterface", "wascope", "rwsequence", " wstore", "wsite", "expser", "yinput", "wsequence", "wtsequence", "ysite", "wservice", "awsource", "hwsession", "wtsource", "wtinterface", "wtscope", "wordsource", "wseries", "walsequence", "wordsession", "yser", "walsource", "wource", " wsite", "expsite", "walcause", "rwcause", "wastore", "expsource", "awservice", "wstore", "waseries", "wtmessage"]}}
{"project": "qemu", "commit_id": "e40c3d2e7f4b58669a1b4e5dfb684e57c0bf62ce", "target": 0, "func": "static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,\n\n                              uint32_t irq, bool use_highmem)\n\n{\n\n    Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf;\n\n    int i, bus_no;\n\n    hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base;\n\n    hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size;\n\n    hwaddr base_pio = memmap[VIRT_PCIE_PIO].base;\n\n    hwaddr size_pio = memmap[VIRT_PCIE_PIO].size;\n\n    hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base;\n\n    hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size;\n\n    int nr_pcie_buses = size_ecam / PCIE_MMCFG_SIZE_MIN;\n\n\n\n    Aml *dev = aml_device(\"%s\", \"PCI0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A08\")));\n\n    aml_append(dev, aml_name_decl(\"_CID\", aml_string(\"PNP0A03\")));\n\n    aml_append(dev, aml_name_decl(\"_SEG\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_BBN\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"PCI0\")));\n\n    aml_append(dev, aml_name_decl(\"_STR\", aml_unicode(\"PCIe 0 Device\")));\n\n    aml_append(dev, aml_name_decl(\"_CCA\", aml_int(1)));\n\n\n\n    /* Declare the PCI Routing Table. */\n\n    Aml *rt_pkg = aml_package(nr_pcie_buses * PCI_NUM_PINS);\n\n    for (bus_no = 0; bus_no < nr_pcie_buses; bus_no++) {\n\n        for (i = 0; i < PCI_NUM_PINS; i++) {\n\n            int gsi = (i + bus_no) % PCI_NUM_PINS;\n\n            Aml *pkg = aml_package(4);\n\n            aml_append(pkg, aml_int((bus_no << 16) | 0xFFFF));\n\n            aml_append(pkg, aml_int(i));\n\n            aml_append(pkg, aml_name(\"GSI%d\", gsi));\n\n            aml_append(pkg, aml_int(0));\n\n            aml_append(rt_pkg, pkg);\n\n        }\n\n    }\n\n    aml_append(dev, aml_name_decl(\"_PRT\", rt_pkg));\n\n\n\n    /* Create GSI link device */\n\n    for (i = 0; i < PCI_NUM_PINS; i++) {\n\n        uint32_t irqs =  irq + i;\n\n        Aml *dev_gsi = aml_device(\"GSI%d\", i);\n\n        aml_append(dev_gsi, aml_name_decl(\"_HID\", aml_string(\"PNP0C0F\")));\n\n        aml_append(dev_gsi, aml_name_decl(\"_UID\", aml_int(0)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_PRS\", crs));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n                   aml_interrupt(AML_CONSUMER, AML_LEVEL, AML_ACTIVE_HIGH,\n\n                                 AML_EXCLUSIVE, &irqs, 1));\n\n        aml_append(dev_gsi, aml_name_decl(\"_CRS\", crs));\n\n        method = aml_method(\"_SRS\", 1, AML_NOTSERIALIZED);\n\n        aml_append(dev_gsi, method);\n\n        aml_append(dev, dev_gsi);\n\n    }\n\n\n\n    method = aml_method(\"_CBA\", 0, AML_NOTSERIALIZED);\n\n    aml_append(method, aml_return(aml_int(base_ecam)));\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_CRS\", 0, AML_NOTSERIALIZED);\n\n    Aml *rbuf = aml_resource_template();\n\n    aml_append(rbuf,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0000, nr_pcie_buses - 1, 0x0000,\n\n                            nr_pcie_buses));\n\n    aml_append(rbuf,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio,\n\n                         base_mmio + size_mmio - 1, 0x0000, size_mmio));\n\n    aml_append(rbuf,\n\n        aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                     AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio,\n\n                     size_pio));\n\n\n\n    if (use_highmem) {\n\n        hwaddr base_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].base;\n\n        hwaddr size_mmio_high = memmap[VIRT_PCIE_MMIO_HIGH].size;\n\n\n\n        aml_append(rbuf,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000,\n\n                             base_mmio_high, base_mmio_high, 0x0000,\n\n                             size_mmio_high));\n\n    }\n\n\n\n    aml_append(method, aml_name_decl(\"RBUF\", rbuf));\n\n    aml_append(method, aml_return(rbuf));\n\n    aml_append(dev, method);\n\n\n\n    /* Declare an _OSC (OS Control Handoff) method */\n\n    aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n    aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n    method = aml_method(\"_OSC\", 4, AML_NOTSERIALIZED);\n\n    aml_append(method,\n\n        aml_create_dword_field(aml_arg(3), aml_int(0), \"CDW1\"));\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.5.1. _OSC Interface for PCI Host Bridge Devices\n\n     * The _OSC interface for a PCI/PCI-X/PCI Express hierarchy is\n\n     * identified by the Universal Unique IDentifier (UUID)\n\n     * 33DB4D5B-1FF7-401C-9657-7441C03DD766\n\n     */\n\n    UUID = aml_touuid(\"33DB4D5B-1FF7-401C-9657-7441C03DD766\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(4), \"CDW2\"));\n\n    aml_append(ifctx,\n\n        aml_create_dword_field(aml_arg(3), aml_int(8), \"CDW3\"));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW2\"), aml_name(\"SUPP\")));\n\n    aml_append(ifctx, aml_store(aml_name(\"CDW3\"), aml_name(\"CTRL\")));\n\n    aml_append(ifctx, aml_store(aml_and(aml_name(\"CTRL\"), aml_int(0x1D), NULL),\n\n                                aml_name(\"CTRL\")));\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    ifctx1 = aml_if(aml_lnot(aml_equal(aml_name(\"CDW3\"), aml_name(\"CTRL\"))));\n\n    aml_append(ifctx1, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x10), NULL),\n\n                                 aml_name(\"CDW1\")));\n\n    aml_append(ifctx, ifctx1);\n\n\n\n    aml_append(ifctx, aml_store(aml_name(\"CTRL\"), aml_name(\"CDW3\")));\n\n    aml_append(ifctx, aml_return(aml_arg(3)));\n\n    aml_append(method, ifctx);\n\n\n\n    elsectx = aml_else();\n\n    aml_append(elsectx, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(4), NULL),\n\n                                  aml_name(\"CDW1\")));\n\n    aml_append(elsectx, aml_return(aml_arg(3)));\n\n    aml_append(method, elsectx);\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_DSM\", 4, AML_NOTSERIALIZED);\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.6.1. _DSM for PCI Express Slot Information\n\n     * The UUID in _DSM in this context is\n\n     * {E5C937D0-3553-4D7A-9117-EA4D19C3434D}\n\n     */\n\n    UUID = aml_touuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0)));\n\n    uint8_t byte_list[1] = {1};\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(ifctx1, aml_return(buf));\n\n    aml_append(ifctx, ifctx1);\n\n    aml_append(method, ifctx);\n\n\n\n    byte_list[0] = 0;\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(method, aml_return(buf));\n\n    aml_append(dev, method);\n\n\n\n    Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\n\n    aml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, dev_rp0);\n\n    aml_append(scope, dev);\n\n}\n", "idx": 11957, "substitutes": {"scope": ["acc", "tr", "spec", "req", "event", "alloc", "proc", "sp", "cl", "var", "ram", "block", "flow", "serial", "window", "row", "test", "root", "scan", "mode", "ctx", "ops", "env", "res", "sc", "app", "module", "sys"], "memmap": ["timpack", "hwtab", "memorytab", "cachemap", "ramMap", "mmap", "histcache", "memhash", "mapdict", "cachemask", " memMap", "ramhash", "mmcap", "memdown", "mapapper", "memtab", "hwapper", "memcache", "memorydown", "histap", "rammap", "Mempack", "memcap", "memorymask", "cacheap", "memorydict", " mempack", "rampack", "hwlist", "memmask", "memapper", "MemMap", "timtab", "cachelist", "mmcache", "mapmap", "memMap", "hwpack", "Memmap", "histmap", "timap", "memdict", "ramap", "memoryapper", "memlist", "memorylist", "memorypack", "memorycache", "hwdown", "mmmap", "memoryap", "ramdict", "timmap", "mmmask", "mapap", "mempack", "hwmap", "memoryhash", "memorycap", "hwcap", "histcap", "mapdown", "hwap", "maphash", "mmlist", "memorymap", "memap"], "irq": ["irz", "yrz", "rerqu", "ibrz", "yrquant", "rerz", "yrqu", "rerquant", "irquant", "ibrq", "irqu", "yrq", "ibrqu", "ibrquant", "rerq"], "use_highmem": ["use2lowmem", "use2lowms", "use_fastms", "use_lowmem", "use_highms", "use2highmemory", "use_hmem", "use_hms", "use2highMem", "use_lowms", "use2highms", "use_lowMem", "use_hmemory", "use2lowMem", "use_lowmemory", "use_fastmem", "use2highmem", "use_highMem", "use_hMem", "use_highmemory", "use_fastmemory", "use_fastMem", "use2lowmemory"], "method": ["tr", "acc", "spec", "cmp", "call", "record", "path", "event", "func", "prop", "mount", "instance", "fun", "attr", "util", "mod", "Method", "mode", "hod", "action", "cmd", "exec", "member", "METHOD", "access", "module", "inst", "ann"], "crs": ["acds", "Cds", "cds", "ccRS", "cri", "Crs", "Cri", "acri", "ccri", "acRS", "ccds", "ccrs", "CRS", "acrs", "cRS"], "ifctx": ["Ifctx", "ifcontext", "condctx", "Ifcontext", "iftx", "Iftx", "IFaddr", "IFcontext", "IFtx", "ifaddr", "condcontext", "IFctx", "condtx", "Ifaddr", "condaddr"], "UUID": ["UUL", "Uuid", "Nuid", "Cuid", "CUID", "SUUL", "CUL", "SUUID", "SUID", "SUuid", "NID", "CID", "UID", "NUL", "NUID"], "ifctx1": ["Ifctx0", "ifctx2", "ifctx0", "ifcontext0", "ifreq2", "ifcc0", "Ifctx1", "Ifctx2", "Ifctx3", "Ifcontext0", "ifcontext1", "ifctx3", "Ifcontext3", "Ifcontext2", "ifcc1", "ifcc3", "ifreq3", "ifreq0", "ifreq1", "ifcontext2", "ifcontext3", "Ifcontext1", "ifcc2"], "elsectx": ["elifX", "evseqi", "elseqh", "elifh", "elsectionx", "elseqi", "elseqx", "elsectioni", "elsectionh", "evsecti", "evsecth", "evsectX", "evseqh", "elseqX", "elsecti", "elsecth", "elsectX", "evseqx", "elifx", "evsectx", "elsectionX", "elifi", "evseqX"], "buf": ["doc", "buffer", "uf", "err", "ff", "alloc", "proc", "seq", "cf", "bc", "act", "block", "ref", "cb", "family", "mem", "queue", "box", "cap", "ctx", "cast", "tmp", "cmd", "kw", "batch", "buff", "msg", "cv"], "i": ["id", "u", "ai", "I", "a", "li", "ei", " I", " di", "k", " e", "p", "o", "sim", " li", "ui", "ip", "m", "l", " pi", "ki", "ti", "ic", " ti", "mi", "j", "ix", "n", "y", "ci", "zi", "v", " mi", "xi", "qi", "multi", "b", "e", "c", "gi", "di", "bi", "si", "pi", "it", "x", "ini", " ii", " bi", "oi", " ni", " j", "ii"], "bus_no": ["bus7No", "bus_go", "busptrow", "busptno", " bus_row", "bridge_NO", "bus_NO", "bridge_no", "bus_No", "bus7no", "busptNo", "bus7nos", "bus_eno", "bus_yes", "busptyes", "Bus_no", " bus_ne", "bus_nos", "Bus_No", "Bus_row", "bus_ne", "Bus_nos", " bus_nos", "bus_row", " bus_yes", "bus7row", " bus_No", "bridge_eno", "bridge_go"], "dev": ["hid", "tr", "dd", "off", "development", "priv", "gpu", "slow", "av", "pt", "prom", "device", "cam", "go", "end", "den", "ev", "det", "home", "nav", "ve", "var", "adv", "pu", "pad", "nt", "normal", "stable", "def", "hd", "local", "desc", "serial", "raw", "ver", "dep", "mem", "develop", "cho", "md", "roll", "dem", "DEV", "conn", "v", "gu", "env", "tech", "val", "Dev", "cmd", "des", "w", "temp", "serv", "debug", "disk", "sd", "pro", "draw", "vol"], "rt_pkg": ["rt_pack", "rt_buf", "rx_pack", "rx_buf", "rx_kg", "rx_pkg", "rt_kg"]}}
{"project": "qemu", "commit_id": "ae261c86aaed62e7acddafab8262a2bf286d40b7", "target": 0, "func": "static int vmdk_parent_open(BlockDriverState *bs)\n\n{\n\n    char *p_name;\n\n    char desc[DESC_SIZE + 1];\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    desc[DESC_SIZE] = '\\0';\n\n    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != NULL) {\n\n        char *end_name;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == NULL)\n\n            return -1;\n\n        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n\n            return -1;\n\n\n\n        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11958, "substitutes": {"bs": ["ms", "obs", "vs", "qs", "aos", "bp", "rs", "hs", "gs", "bes", "sts", "ps", "bc", "BS", "cs", "outs", "bits", "ins", "es", "ses", "bn", "aus", "aws", "als", "js", "irms", "ss", "ts", "its", "bos", "pb", "lbs", "bps", "ubs", "ubis", "os", "sb", "b", "bis", "bh", "acs", "ns", "fs", "bb", "vals", "blog", "ls", "ims", "hz", "ds"], "p_name": ["p_code", "pcuppetname", "pc_label", "p_error", "pkgnm", "prentext", "p_id", " p_val", "p_val", " p_names", "postonname", "pkglan", "pkgnames", "p_parent", "puppetName", "pugn", "padugpath", "padugn", "pad_n", "pcuppetName", "pkgcap", " p_Name", "pocknm", "p_nm", "pkgcode", "pc_name", "pkgparent", "prenname", "p_n", "p_path", "pocknames", "pad_path", "p_lan", "puppettext", "pbostonparent", "pugcap", "pbostoncode", "p_cap", " p_lan", "pbostonname", "pcuppetlabel", "postoncode", "pad_error", "puppetname", "pc_text", "puppetlabel", "pb_parent", "pad_name", "pbostoncap", "pc_Name", "p_label", "padugname", " p_id", "pb_cap", "pcuppettext", "padugerror", " p_default", "p_names", "pugparent", "pugname", "postonparent", "pugpath", "prenName", "p_text", "p_Name", "pugcode", "p_default", "pkgname", "pocklan", "pb_code", "pb_name", "p_old", "pugerror", " p_old", "pockname", " p_nm", "postoncap", "prenlabel"], "desc": ["doc", "obj", "cmp", "Desc", "req", "described", "rec", "sub", "resp", "buf", "seq", "dev", "nt", "d", "dc", "sec", "phrase", "cd", "def", "ptr", "txt", "ript", "ext", "dep", "pres", "md", "cont", "de", "dest", "esc", "DES", "rc", "sort", "info", "dir", "good", "comp", "red", "cmd", "comment", "des", "asc", "dist", "bd", "str", "st", "disc", "sc", "msg", "dict", "description", "name", "pro", "ds"], "s": ["ms", "vs", "sq", "ats", "rs", "hs", "sp", "gs", "sts", "p", "ps", "ess", "cs", "sv", "ses", "xs", "aws", "js", "j", "S", "ss", "ts", "se", "t", "v", "sb", "b", "c", "ns", "fs", "sis", "ls", "ds", "sys"], "end_name": [" end_val", "end__key", "endjname", "endjame", "end64Name", "end_Name", "end64mem", "end_path", "END_ame", "end__name", "end_mem", "end_val", "ENDjame", "start_error", "start_name", "ENDjname", "end64val", " end_mem", "end__error", "end_error", "end64name", " end_on", "END_name", " end_Name", "endjName", "end__num", "start__error", "start_key", "start__key", "start__name", "end_ame", "END_Name", "start_num", " end_path", "end_on", "start__num", "end_key", "ENDjName", "end_num"]}}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static MemoryRegionSection address_space_do_translate(AddressSpace *as,\n\n                                                      hwaddr addr,\n\n                                                      hwaddr *xlat,\n\n                                                      hwaddr *plen,\n\n                                                      bool is_write,\n\n                                                      bool is_mmio)\n\n{\n\n    IOMMUTLBEntry iotlb;\n\n    MemoryRegionSection *section;\n\n    MemoryRegion *mr;\n\n\n\n    for (;;) {\n\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n\n        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);\n\n        mr = section->mr;\n\n\n\n        if (!mr->iommu_ops) {\n\n            break;\n\n        }\n\n\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n\n                | (addr & iotlb.addr_mask));\n\n        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n\n        if (!(iotlb.perm & (1 << is_write))) {\n\n            goto translate_fail;\n\n        }\n\n\n\n        as = iotlb.target_as;\n\n    }\n\n\n\n    *xlat = addr;\n\n\n\n    return *section;\n\n\n\ntranslate_fail:\n\n    return (MemoryRegionSection) { .mr = &io_mem_unassigned };\n\n}\n", "idx": 11969, "substitutes": {"as": ["ms", "AS", "a", "mm", "arp", "aster", "aos", "rs", "ars", "ak", "asm", "ras", "area", "ach", "am", "ase", "admin", "cs", "ra", "ame", "ds", "bs", "us", "las", "ias", "ss", "ts", "with", "aser", "ac", "ast", "os", "eas", "asa", "sa", "ns", "acs", "ag", "As", "ar", "asi", "sys", "pa"], "addr": ["add", "lr", "attr", "hl", "arch", "rr", "r", "data", "t", "wd", "ace", "cmd", "str", "elt", "ar", "arr", "art", "dd", "tr", "tx", "address", "arp", "at", "wid", "ptr", "alpha", "ac", "rt", "alias", "work", "src", "obj", "id", "url", "nl", "a", "Address", "rs", "err", "hash", "ld", "ip", "pos", "ref", "rn", "i", "ad", "ctx", "ha", "ag", "hw", "start", "oad", "oa", "loc", "mt", "align", "ash", "len", "off", "ack", "pad", "da", "act", "adr", "ord", "alt", "lat", "las", "rc", "ress", "res", "x", "coord", "name", "offset", "rid", "dr"], "xlat": ["wsat", "waddr", "wlat", "Xlat", "xsat", " xLat", "XLat", "wLat", "xLat", " xsat", "xaddr", "Xaddr", "exsat", "exLat", "Xsat", " xaddr", "exlat", "exaddr"], "plen": ["penlen", "PLen", "selen", "PLength", "plun", "klen", "iplun", "pten", "PLlen", "slen", "klEN", " pllen", "iplength", "PLEN", "klun", "kllen", "slun", "penEN", "penen", "iplen", "penength", "selength", "sellen", " plEN", "ipllen", "klength", "slener", "plener", "sllen", " plener", "ptun", "selEN", "ptatten", "iplener", "iplEN", "klatten", "pllen", "platten", "ptEN", "plEN", "plength", " plength", " plun", " platten"], "is_write": ["isletfine", "is_fine", "is1read", "type1write", "is_Write", "is1write", "type1read", "type_fine", "Is_update", " is_read", "is1fine", "isletread", "Is_Write", " is_writ", "isletwrite", "is_update", "is1log", "type1fine", "type1log", "is_log", " is_Write", "is_writ", "type_read", "type_log", "type_write", "isletlog", "Is_write", "is_read"], "is_mmio": ["is2mxio", "is_mxio", "is_mmiol", "is_tmios", "is_mio", "is2mmios", "is_tmio", "is_MMios", "is_MMio", "is_mios", "is2mxios", "is2mxIO", "is_miol", "is_mmIO", "is2mmio", "is_mmios", "is_tmIO", "is_mIO", "is_MMiol", "is_mxios", "is_mxIO", "is2mmIO"], "iotlb": ["ylb", "ietb", "skyl", "oteLB", "iottlr", "iottbl", "iottl", "iolr", "yLB", "otelab", "otlab", "iourlp", "otbl", "potl", "iotl", "potlr", "ietLB", "otlb", "iourlbs", "ioplb", "iotlr", "itb", "iottlp", "ietlb", "ietlu", "otl", "ietlab", "iotlp", "iotbl", "iopbl", "ylab", "netlbs", "iotb", "ioplbs", "otelb", "nitbl", "iourlb", "ioplr", "otlbs", "iottlbs", "iotlbs", "iottb", "iolbs", "iottlab", "ietlbs", "potlp", "netlp", "potlb", "nitlr", "iobl", "skylbs", "skylb", "skylab", "skyb", "iotLB", "otb", "netlb", "potlbs", "ylu", "otelu", "nitlb", "nitlab", "itlb", "nitlbs", "iolb", "iourlr", "netlr", "nitlp", "itlab", "itlbs", "iotlab", "iottlb", "potbl", "iotlu", "potlab"], "section": ["tr", "spec", "entry", "part", "layer", "format", "channel", "region", "asm", "manager", "area", "sub", "ment", "job", "pair", "ry", "sector", "sec", "component", "instance", "block", "sam", "port", "session", "mod", "Section", "sect", "r", "j", "row", "ss", "description", "se", "connection", "header", "mode", "lc", "journal", "sb", "option", "master", "member", "sections", "tag", "table", "result", "room", "set", "group", "db", "context", "ner", "rup", "module", "our", "state"], "mr": ["ms", "kr", "ml", "tr", "hr", "hm", "rpm", "mb", "mx", "nm", "lr", "rb", "rs", "arry", "asm", "older", "ar", "wm", "rar", "gr", "wr", "m", "bm", "rn", "MR", "drm", "shr", "mn", "rr", "usr", "adr", "r", "rl", "pm", "md", "br", "mc", "mir", "rg", "nr", "pr", "mk", "wcs", "ctr", "mid", "mor", "rt", "tur", "sr", "cm", "er", "ocr", "rm", "rer", "vr", "mp", "our", "dt", "Mr", "ds", "dr", "mt"], "d": ["dd", "fd", "p", "f", "da", "dc", "dx", "g", "pd", "did", "dn", "D", "dra", "r", "gd", "j", "de", "done", "dq", "dl", "t", "dir", "b", "h", "di", "dat", "bd", "dp", "db", "dj", "s", "dm", "dh", "debug", "dt", "ds", "dr"]}}
{"project": "qemu", "commit_id": "30de46db50d2f9f74c5f7ab1cc463b8dec026407", "target": 0, "func": "static void read_guest_mem(void)\n\n{\n\n    uint32_t *guest_mem;\n\n    gint64 end_time;\n\n    int i, j;\n\n    size_t size;\n\n\n\n    g_mutex_lock(data_mutex);\n\n\n\n    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n    while (!fds_num) {\n\n        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {\n\n            /* timeout has passed */\n\n            g_assert(fds_num);\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check for sanity */\n\n    g_assert_cmpint(fds_num, >, 0);\n\n    g_assert_cmpint(fds_num, ==, memory.nregions);\n\n\n\n    /* iterate all regions */\n\n    for (i = 0; i < fds_num; i++) {\n\n\n\n        /* We'll check only the region statring at 0x0*/\n\n        if (memory.regions[i].guest_phys_addr != 0x0) {\n\n            continue;\n\n        }\n\n\n\n        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);\n\n\n\n        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;\n\n\n\n        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,\n\n                         MAP_SHARED, fds[i], 0);\n\n\n\n        g_assert(guest_mem != MAP_FAILED);\n\n        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));\n\n\n\n        for (j = 0; j < 256; j++) {\n\n            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);\n\n            uint32_t b = guest_mem[j];\n\n\n\n            g_assert_cmpint(a, ==, b);\n\n        }\n\n\n\n        munmap(guest_mem, memory.regions[i].memory_size);\n\n    }\n\n\n\n    g_assert_cmpint(1, ==, 1);\n\n    g_mutex_unlock(data_mutex);\n\n}\n", "idx": 11975, "substitutes": {"guest_mem": ["guestlyram", "guess_val", "guestThemp", "guestedlyaddr", "guestMmem", "guestMaddr", "guest_addr", "gutestfulmem", "guest__ram", "guest2memory", "guessed_mb", "guested_ram", "guest_msg", "gutestfulmsg", "gutest_buffer", "guested2pool", "guestJmp", "guest_mb", "guest_mp", "guest_memory", "guestlyaddr", "guested_Mem", "guest_phys", "guester___mem", "guestedlymem", "guested2Mem", "guester_mm", "guester_mem", "guest__addr", "guestJMem", "guest___name", "guester___addr", "guest2pool", "guestmatmem", "guested_buf", "guest2Mem", "guestJmem", "guest_mm", "guest__buf", "guest_buffer", "guester_addr", "guested2mem", "guest_rm", "guestMbuf", "guested_phys", "guestfulbuffer", "guestfulmsg", "guester___mm", "guest_val", "guest___mm", "guessedThemem", "gutest_msg", "guest_pool", "guest_Mem", "guestmatMem", "guest__mem", "guestedlyram", "guess_memory", "guessed_mem", "guest_hist", "guestMram", "guessedTheMem", "guested_memory", "guessedThemp", "guestJmb", "guested_hist", "guested_addr", "guest_buf", "guested2memory", "guestThemb", "guestedlybuf", "guest__pool", "guestfulrm", "guest_name", "guestmathist", "guester_name", "guestlymem", "guest__memory", "guest_ram", "guest___mem", "guestTheMem", "gutest_mem", "guest__Mem", "guest___addr", "guessed_Mem", "guestfulmem", "guestThemem", "guestlybuf", "guested_mem", "gutestfulbuffer", "guest2mem", "guess_mem", "guessedThemb", "gutest_rm", "guestmatphys", "guested_pool", "guessed_mp", "gutestfulrm", "guester___name"], "end_time": ["appendpttime", "endpttim", " end_timer", "endTimeTime", "endptTime", "endptrate", "endpttime", "endptruntime", "end8start", " end_size", "appendptstart", "append_time", "append_runtime", "end_rate", "end8time", "endjrate", "endjtime", "endjTime", "end_start", "end_Time", "end8rate", "end_inter", "end_runtime", "endjtim", "appendptrate", "end8runtime", "end_size", "endTimesize", "endTimetimer", "end_timer", "endjinter", " end_tim", "endptstart", "endjruntime", " end_Time", "appendptruntime", "end_tim", "endjstart", "append_rate", "endptinter", " end_inter", "endTimetime", "append_start"], "i": ["ie", "print", "o", "m", "im", "y", "ci", "zi", "gi", "pi", "hi", "ji", "history", "ims", "ami", "status", "I", "source", "li", "uri", "init", "ri", "ex", "ind", "ki", "ti", "ia", "mi", "ix", "iti", "xi", "e", "multi", "si", "batch", "id", "ai", "ei", "point", "iri", "ui", "ip", "ic", "in", "index", "chain", "n", "\u0438", "phi", "info", "remote", "it", "ini", "ii", "me", "io", "q", "list", "to", "sim", "json", "us", "is", "series", "iu", "v", "ik", "h", "di", "bi", "x", " ii", "set", "name", "dr", "ij"], "j": ["obj", "bj", "on", "aj", "ja", "jump", "J", "jc", "a", "ch", "jo", "q", "yy", "ev", "k", "p", "ng", "job", "o", "jit", "ind", "jp", "l", "m", "json", "jj", "index", "js", "uj", "br", "ix", "n", "y", "jas", "ian", "jl", "v", "fr", "bo", "b", "c", "kh", "bi", "adj", "oj", "by", "it", "x", "z", "att", "dj", "ju", "ji", "jack", "kj", "ij"], "size": ["grow", "small", "empty", "address", "sum", "buffer", "code", "message", "huge", "base", "format", "area", "sp", "height", "south", "Size", "SIZE", "capacity", "g", "m", "type", "ize", "index", "storage", "large", "data", "total", "n", "body", "sha", "new", "count", "zone", "gc", "shape", "cache", "dim", "c", "scale", "si", "z", "set", "s", "max", "name", "space", "length", "number"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,\n\n                               uint32_t *byte_len)\n\n{\n\n    int ret;\n\n    struct ibv_wc wc;\n\n    uint64_t wr_id;\n\n\n\n    ret = ibv_poll_cq(rdma->cq, 1, &wc);\n\n\n\n    if (!ret) {\n\n        *wr_id_out = RDMA_WRID_NONE;\n\n        return 0;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ibv_poll_cq return %d!\\n\", ret);\n\n        return ret;\n\n    }\n\n\n\n    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;\n\n\n\n    if (wc.status != IBV_WC_SUCCESS) {\n\n        fprintf(stderr, \"ibv_poll_cq wc.status=%d %s!\\n\",\n\n                        wc.status, ibv_wc_status_str(wc.status));\n\n        fprintf(stderr, \"ibv_poll_cq wrid=%s!\\n\", wrid_desc[wr_id]);\n\n\n\n        return -1;\n\n    }\n\n\n\n    if (rdma->control_ready_expected &&\n\n        (wr_id >= RDMA_WRID_RECV_CONTROL)) {\n\n        DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\"\n\n                  \" left %d\\n\", wrid_desc[RDMA_WRID_RECV_CONTROL],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n    if (byte_len) {\n\n        *byte_len = wc.byte_len;\n\n    }\n\n\n\n    return  0;\n\n}\n", "idx": 11978, "substitutes": {"rdma": ["erdmeta", "rodma", "redme", "rrma", "rhm", "redm", "rdman", "rdMA", "redmar", "redma", "rrman", "irdmb", "rhman", "rdmad", "irdms", "rdla", "drpo", "erdMA", "drMA", "rodpo", "rhmar", "rdme", "drms", "drda", "rdms", "ldma", "drma", "rrm", "rodda", "drman", "rhda", "redla", "rdmb", "ldme", "redman", "redMA", "rodmm", "rodmar", "rdm", "rdpo", "rdmeta", "redmb", "redmm", "ldmm", "irdma", "rodmeta", "rdmar", "erdmm", "redms", "ldman", "ldMA", "drme", "drmar", "ldla", "erdma", "drmad", "rhma", "irdmad", "redmeta", "rdda", "rhpo", "rrmar", "redmad", "rdmm", "drmb", "erdla", "erdmar"], "wr_id_out": ["wr_info_Out", "wr_info_output", "wr_info_in", "wr_id_str", "wr_id_Out", "wr_id_output", "wr_info_out", "wr_id_in"], "byte_len": ["byte_Len", "Byte_size", "byte_length", "Byte_len", "Byte_length", "Byte_Len", "byte_size"], "ret": ["reset", "reply", "bad", " Ret", "t", "rem", "deg", "elt", "ll", "td", "arr", "tr", "imp", "status", "code", "RET", "fail", "iter", "pret", "after", "usr", "txt", "ter", "try", "final", "sat", "rets", "Ret", "rt", "no", "tf", "net", "back", "err", "resp", "nt", "ref", "inter", "def", "failed", "reg", "backed", "red", "cert", "ft", "out", "mt", "len", "lit", "num", "lib", " RET", "flag", "fun", "git", "zero", "tif", "alt", "ext", "cont", "j", "total", "tn", "val", "re", "res", "x", "set", "gt", " fut", "Return"], "wc": ["ww", "wrco", "wac", "wordc", "wrcan", "evct", "wrg", "wacm", "wg", "wordcc", "wcs", "wordcs", "wcm", "kwcm", "rwcs", "kwci", "wv", "rww", "wev", " wcu", "wci", "kwc", " wv", "wdw", "wacc", "wct", "wact", "evc", "wry", " wcc", "wdy", "kwcs", "wdc", "wco", "wvc", "wtcan", "rwce", "rwcm", "waci", "rwy", "rwg", "wec", "wy", "wacs", "privcs", "privc", "rwvc", "rwci", "wcc", "wtco", "wdcs", "privcu", "wavc", "wrcs", " wco", "wcan", "wtcs", "wcu", "evvc", "rwc", "wordv", " ww", "wecs", " wcs", "rwv", "wece", "privco", "evcs", " wce", "wav", "wtc", "rwct", "wrc", "wdg", "wce", "wtcu", " wcan"], "wr_id": ["write_sid", " wrnameid", " wr_info", "wrogid", "wt_url", "wa_id", " wrnamek", "pr_addr", "wr___link", "wr_code", "wr_ide", "pr_ID", "rwOid", "write_hash", "wr_i", "wrnameide", "wr_ip", "wr___ip", "wr_type", "wr_link", "wrOtype", "wrOflag", "write_info", "wr_k", "wrTheide", "wr_sid", "wm_in", " wr_ide", "wr___number", "wrOsid", "wr_hash", "rw_id", "wrnamek", "wroghash", "wa_i", "rwOlink", " wr_code", "wm_number", "wr_flag", "wr_addr", "pr_orig", "rw_link", "wr___info", "wroginfo", "wr___id", " wrnamecode", "wr_url", "wr_orig", "write_source", "wr_ids", "wrOsource", "wr_bit", " wrnameide", "wt_kid", "pr_pid", "wr_name", "wr___flag", "wr___in", "wrOlink", "rw_ip", "wr_source", "wrTheid", "wr_kid", "wr_in", "wrnameid", "wr_ID", " wr_type", "rwOflag", "wrThecode", "write_type", "write_name", "pr_id", "wa_bit", "wa_Id", "wr_pid", "rwOip", "wr_number", "wrThek", "write_id", "wrOip", "wm_id", "wt_Id", "wr_info", "wrnamecode", "wrogsid", "wr_Id", "pr_ids", "wrOid", " wr_k", "wt_id", "rw_flag", "pr_info", "wm_info", " wr_name"], "block": ["key", "work", "tx", "off", "sync", "entry", "map", "part", "record", "buffer", "mm", "blocks", "join", "event", "point", "pool", "task", "unit", "error", "open", "ref", "type", "local", "word", "window", "mem", "bit", "Block", "chain", "row", "OCK", "data", "box", "bus", "line", "lock", "start", "piece", "link", "batch", "item", "group", "name", "byte", "number"], "nb_sent": ["num_sent", "nb_send", "nbbytessend", "nbbytesreceived", "num_send", "nb_received", "num_received", "nb_Sent", "nbbytesSent", "nbbytessent", "num_Sent"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    uint32_t minor_ver;\n\n    int comp_brand_size;\n\n    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */\n\n    char* comp_brands_str;\n\n    uint8_t type[5] = {0};\n\n\n\n    avio_read(pb, type, 4);\n\n    if (strcmp(type, \"qt  \"))\n\n        c->isom = 1;\n\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n\n    minor_ver = avio_rb32(pb); /* minor version */\n\n    snprintf(minor_ver_str, sizeof(minor_ver_str), \"%\"PRIu32\"\", minor_ver);\n\n    av_dict_set(&c->fc->metadata, \"minor_version\", minor_ver_str, 0);\n\n\n\n    comp_brand_size = atom.size - 8;\n\n    if (comp_brand_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n\n    if (!comp_brands_str)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, comp_brands_str, comp_brand_size);\n\n    comp_brands_str[comp_brand_size] = 0;\n\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n\n    av_freep(&comp_brands_str);\n\n\n\n    return 0;\n\n}\n", "idx": 11979, "substitutes": {"c": ["pc", "con", "abc", "a", "cam", "ct", "enc", "k", "p", "ec", "cl", "f", "cp", "cf", "bc", "dc", "xc", "g", "cs", "m", "tc", "l", "cb", "cc", "ce", "coll", "n", "mc", "t", "ci", "ctx", "ac", "rc", "lc", "v", "conf", "gc", "e", "cache", "b", "anc", "h", "can", "nc", "cm", "etc", "cu", "fc", "C", "co", "cv", "cr", "vc"], "pb": ["tf", "apy", "bj", "typ", "pc", "tp", "ub", "mb", "pp", "uf", "pt", "bp", "ping", "tk", "rb", "pan", "asm", "proc", "p", "sp", "buf", "pool", "xb", "cp", "fp", "pg", "bc", "vp", "jp", "np", "tc", "pkg", "fb", "ap", "cb", "tab", "ab", "lp", "bs", "pm", "phy", "ctx", "px", "erb", "sb", "b", "wp", "bb", "ob", "PB", "fc", "pel", "phys", "mp", "wb", "pa"], "atom": [" com", "tm", "sym", "op", "mol", "typ", "mate", "al", "orm", "at", " exc", "base", " component", "or", "p", "o", "prop", "omp", "component", "m", "atomic", "ata", "um", "raw", "element", "term", "month", " orb", "tem", "data", "node", "y", "b", "com", "from", "ym", "ator", "om", "orb", "x", " err", "item", "org", "msg", "tar", "app", " form", "state"], "minor_ver": ["minor_ser", "minor2dec", "minor__Ver", "minor__ser", "miner_ver", "minornetcur", "minOR2Ver", "minor_vert", "minornetVer", "minOR2dec", "minornetdec", "minore_v", "minore_vert", "minor2ver", "minor_Ver", "minor_vers", "minor2cur", "minornetver", "minore_ver", "minor__ver", "minOR_Ver", "minore_ever", "minor_cur", "miner_vers", "minOR2cur", "minOR_ver", "minor2Ver", "miner_ser", "minOR_cur", "minor_dec", "minOR2ver", "minor__vers", "miner_Ver", "minor_v", "minOR_dec", "minor_ever"], "comp_brand_size": ["comp_brand_city", "comp_family_Size", "comp_family_size", "comp_brand_name", "comp_font_name", "comp_branditycity", "comp_brand_len", "comp_font_size", "comp_family_len", "comp_costitycity", "comp_family_index", "comp_branditysize", "comp_label_size", "comp_label_Size", "comp_label_index", "comp_brand_index", "comp_cost_SIZE", "comp_cost_count", "comp_cost_size", "comp_costitycount", "comp_brand_count", "comp_costitysize", "comp_font_SIZE", "comp_cost_city", "comp_label_count", "comp_brand_SIZE", "comp_font_count", "comp_branditycount", "comp_costitySIZE", "comp_brand_Size", "comp_branditySIZE"], "minor_ver_str": ["minor_ver2name", "minor_ver_dr", "minor_version_br", "minor_ver_br", "minor_ver2fr", "minor_ver_Str", "minor_version_dr", "minor_ser_arr", "minor_ver2str", "minor_Ver_arr", "minor_Ver_name", "minor_Ver_STR", "minor_Ver_str", "minor_ver_fr", "minor_ver2STR", "minor_ver2br", "minor_ver_arr", "minor_ver2Str", "minor_ver_name", "minor_ser_Str", "minor_ver_STR", "minor_ser_fr", "minor_ser_str", "minor_ver2arr", "minor_version_str", "minor_Ver_Str", "minor_version_Str", "minor_Ver_br"], "comp_brands_str": ["comp_brages_Str", "comp_brages_str", "comp_brads_str", "comp_brances_arr", "comp_brards_str", "comp_brards_string", "comp_brands_arr", "comp_brances_str", "comp_brances_list", "comp_brels_string", "comp_brands_list", "comp_brels2string", "comp_brands_ptr", "comp_brels_Str", "comp_brads_fr", "comp_brands_data", "comp_brags_dr", "comp_brels_br", "comp_brands_dr", "comp_brages_br", "comp_brards_br", "comp_brels2ptr", "comp_brages_data", "comp_brards_arr", "comp_brands2data", "comp_brands2string", "comp_brags_string", "comp_brels2Str", "comp_brands2ptr", "comp_brands_fr", "comp_brels_str", "comp_brags_str", "comp_brands2arr", "comp_brels2str", "comp_brands_string", "comp_brads_string", "comp_brands2Str", "comp_brances_data", "comp_brands_br", "comp_brands_Str", "comp_brands2str", "comp_brels_arr", "comp_brags_arr", "comp_brands2list", "comp_brads_arr", "comp_brels_ptr"], "type": [" ty", "key", "id", "typ", "what", "status", "pe", "tp", " Type", "buffer", "ty", "message", "where", "format", "ping", "types", "file", "p", "value", "field", "unit", "error", "size", "TYPE", "block", " TYPE", "null", "desc", "kind", "ver", "all", "index", "Type", "data", "header", "test", "y", "t", "check", "sort", "info", "ype", "class", "shape", "ror", "rule", "tag", "time", "pack", "name", "state", "style", "ico"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 11980, "substitutes": {"bus": ["usb", "ck", "board", " BUS", "config", "device", "BUS", "proc", "book", "buf", "dev", "mount", " device", "block", "Bus", " Bus", " board", "handle", "us", "chain", "boot", "box", "uses", "lock", "used", "controller", " buses", "driver"], "devfn": [" devicefn", " devlen", " devicenm", "evfn", "evnm", "devfunction", " devfunction", "devicefunction", "devicefn", "devicelen", "evlen", "devicenm", "devlen", " devnm", "devnm", " devicefunction"], "offset": ["shift", "off", "id", "address", "prefix", "padding", "offer", "before", "o", "point", "error", "slot", "location", "block", "pos", "oid", "ref", "type", "zero", "position", "trace", "length", "window", "util", "addr", "index", "attribute", "Offset", " offsets", "info", "origin", "start", "alias", "seed", "set", "initial", "loc", "size", "out"], "value": ["output", "command", "key", "vector", "power", "current", "address", "buffer", "code", "message", "text", "range", "unit", "volume", "size", "type", "sequence", "values", "word", "term", "function", "attribute", "property", "index", "data", "version", "v", "VALUE", "val", "Value", "comment", "result", "description", "name", "ue", "number"]}}
{"project": "FFmpeg", "commit_id": "073811cdd29e365498b3455ee4e0eda4b957a957", "target": 0, "func": "static int decode_stream_header(NUTContext *nut){\n\n    AVFormatContext *s= nut->avf;\n\n    ByteIOContext *bc = &s->pb;\n\n    StreamContext *stc;\n\n    int class, stream_id;\n\n    uint64_t tmp, end;\n\n    AVStream *st;\n\n\n\n    end= get_packetheader(nut, bc, 1);\n\n    end += url_ftell(bc);\n\n\n\n    GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base);\n\n    stc= &nut->stream[stream_id];\n\n\n\n    st = s->streams[stream_id];\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    class = get_v(bc);\n\n    tmp = get_fourcc(bc);\n\n    st->codec->codec_tag= tmp;\n\n    switch(class)\n\n    {\n\n        case 0:\n\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n            st->codec->codec_id = codec_get_id(codec_bmp_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 1:\n\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n            st->codec->codec_id = codec_get_id(codec_wav_tags, tmp);\n\n            if (st->codec->codec_id == CODEC_ID_NONE)\n\n                av_log(s, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n            break;\n\n        case 2:\n\n//            st->codec->codec_type = CODEC_TYPE_TEXT;\n\n//            break;\n\n        case 3:\n\n            st->codec->codec_type = CODEC_TYPE_DATA;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown stream class (%d)\\n\", class);\n\n            return -1;\n\n    }\n\n    GET_V(stc->time_base_id    , tmp < nut->time_base_count);\n\n    GET_V(stc->msb_pts_shift   , tmp < 16);\n\n    stc->max_pts_distance= get_v(bc);\n\n    GET_V(stc->decode_delay    , tmp < 1000); //sanity limit, raise this if moors law is true\n\n    st->codec->has_b_frames= stc->decode_delay;\n\n    get_v(bc); //stream flags\n\n\n\n    GET_V(st->codec->extradata_size, tmp < (1<<30));\n\n    if(st->codec->extradata_size){\n\n        st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        get_buffer(bc, st->codec->extradata, st->codec->extradata_size);\n\n    }\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_VIDEO){\n\n        GET_V(st->codec->width , tmp > 0)\n\n        GET_V(st->codec->height, tmp > 0)\n\n        st->codec->sample_aspect_ratio.num= get_v(bc);\n\n        st->codec->sample_aspect_ratio.den= get_v(bc);\n\n        if((!st->codec->sample_aspect_ratio.num) != (!st->codec->sample_aspect_ratio.den)){\n\n            av_log(s, AV_LOG_ERROR, \"invalid aspect ratio\\n\");\n\n            return -1;\n\n        }\n\n        get_v(bc); /* csp type */\n\n    }else if (st->codec->codec_type == CODEC_TYPE_AUDIO){\n\n        GET_V(st->codec->sample_rate , tmp > 0)\n\n        tmp= get_v(bc); // samplerate_den\n\n        if(tmp > st->codec->sample_rate){\n\n            av_log(s, AV_LOG_ERROR, \"bleh, libnut muxed this ;)\\n\");\n\n            st->codec->sample_rate= tmp;\n\n        }\n\n        GET_V(st->codec->channels, tmp > 0)\n\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n\n        av_log(s, AV_LOG_ERROR, \"Stream header %d checksum mismatch\\n\", stream_id);\n\n        return -1;\n\n    }\n\n    stc->time_base= &nut->time_base[stc->time_base_id];\n\n    av_set_pts_info(s->streams[stream_id], 63, stc->time_base->num, stc->time_base->den);\n\n    return 0;\n\n}\n", "idx": 11983, "substitutes": {"nut": ["utt", "six", "Nut", "orn", "na", "san", "art", "pieces", "net", "nm", "got", "nas", "ours", "config", "aos", "nu", "ng", "sts", "gob", "ne", "nt", "ut", "ox", "nor", "this", "hawk", "np", "ano", "sequ", "rn", "sam", "mn", "torn", "uts", "hn", "cont", "snap", "nova", "n", "node", "sat", "fn", "ctx", "roy", "orr", "tn", "nr", "nir", "rot", "pot", "nat", "cn", "cmd", "wp", "nuts", "ns", "ot", "nc", "cot", "nih", "ocr", "stab", "piece", "etc", "org", "nil", "our", "nv", "hog", "nw", "nov"], "s": ["src", "obs", "sq", "sl", "status", "qs", "a", "ats", "rs", "sg", "p", "gs", "sts", "sp", "sm", "ps", "south", "sac", "g", "cs", "sv", "i", "ses", "bs", "aws", "is", "js", "S", "ss", "ts", "n", "sat", "t", "v", "conf", "os", "sb", "b", "c", "sw", "h", "sn", "ns", "sa", "stats", "fs", "w", "sc", "set", "ls", "tools", "ds", "out", "sys"], "bc": ["ba", "oc", "chron", "arc", "ck", "pc", "bf", "jc", "bp", "rb", "proc", "ec", "cl", "buf", "ng", "cf", "dc", "xc", "tc", "cs", "cb", "ic", "cc", "bs", "bg", "snap", "BC", "pb", "mc", "ctx", "rc", "lc", "bo", "gc", "sb", "c", "cn", "uc", "voc", "nc", "etc", "bb", "sc", "fc", "gb", "comm", "db", "bt", "gro", "soc", "vc", "sys"], "stc": ["strcc", "ustcu", "Stdc", "stde", " stf", "irstc", "ustfac", "str", "lath", "usth", " stlc", "nte", "istcu", "ustc", "strc", "thc", "istdc", "esth", "estc", "irstac", "istm", "stt", "utcu", "istf", "estfac", "ste", "istt", "stdt", "estl", " ste", "ustm", "ntco", "stw", "utm", " stcc", "ntt", "sth", "utt", " stt", "stac", "stdm", "ustl", "ntc", "stcu", "stdc", "stl", "thm", "stco", "strw", "strlc", "strm", "thfac", "stf", "stdco", " stac", "istc", "stdfac", "latc", "stm", "irstcc", "strac", "irstlc", "stcc", "Str", "latl", " stco", "stfac", "stlc", "Stc", " stdc", "utc", "latfac", "istr", "Stf", "stdw", " str", "thw", "ustt", "strfac"], "class": ["method", "classes", "aud", "id", "lib", "spec", "status", "pe", "cmp", "part", "con", "code", "CLASS", "event", "func", "cl", "ident", "prop", "capacity", "label", "instance", "type", "kind", "lass", "cc", "mod", "ord", "package", "Class", "version", "level", "test", " Class", "interface", "cap", "t", "state", "count", "lc", "cast", "c", "title", "tag", "fc", "sc", " CLASS", "module", "name", "size", "style"], "stream_id": ["stream_index", "stream_oid", "mountIDhash", "mountIDsource", "Stream_id", "streamerid", "stream_ids", "mount_oid", "streamIDsource", "stream_source", "channel_pid", "Stream_info", "stream_no", "mount_hash", "channel_bid", "Stream_ids", "streamIDhash", "mountIDid", "streamersource", "channel_info", "stream_bid", "stream_pid", "streamIDoid", "streamNameinfo", "streamNameindex", "streamNameid", "mount_source", "channel_id", "channel_index", "streameroid", "stream_info", "streamerhash", "channel_no", "mountIDoid", "streamNameno", "stream_hash", "streamIDid", "mount_id"], "tmp": ["tm", "prefix", "proc", "uv", "amp", "prop", "attr", "desc", "appy", "t", "metadata", "orig", "elt", "nb", "tar", "cv", "size", "tv", "tim", "td", "tt", "cmp", "tp", "rb", "sp", "buf", "jp", "sam", "txt", "top", "test", "node", "final", "rt", "temp", "etc", "mp", "emp", "img", "params", "src", "tf", "obj", "png", "net", "mb", "ffff", "up", "sample", "zip", "meta", "resp", " np", "cp", "nt", "tc", "pos", "timeout", "perm", "ctx", "mk", "crop", "qq", " mp", "p", "pkg", "np", "cb", "addr", "ext", "cont", "snap", "total", "pb", "tn", "cache", " tv", "tag", "buff", "max", "offset", "trap"], "end": ["fin", "obj", "len", "id", "send", "add", "and", "begin", "ff", "END", "post", "End", "ut", "size", "stop", "pos", "np", "limit", "length", "ended", "pend", "ext", "alt", "ord", "bound", "dest", "last", "ad", "v", "ending", "e", "rest", "start", "ent", "set", "head", "max", "nd", "offset", "append"], "st": ["td", "src", "tt", "art", "obj", "tra", "net", "sl", "et", "std", "must", "add", "pt", "St", "ct", "step", "stan", "sp", "sts", "nt", "ut", "stable", "th", "stop", "sv", "ust", "stack", "ste", "so", "usr", "storage", "cont", "ss", "ist", "se", "sat", "t", "ast", "sw", "sh", "ST", "ost", "irst", "sn", "rt", "str", "rest", "sta", "ot", "start", "stat", "sc", "est", "ft", "mont", "set", "wt", "nd", "inst", "out", "mt", "store"]}}
{"project": "FFmpeg", "commit_id": "5127f465bd3e2cf9cbf66dea3cf7b481b522d266", "target": 1, "func": "static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *s;\n\n    unsigned char *d;\n\n    unsigned char *d_end;\n\n    unsigned char queue[QUEUE_SIZE];\n\n    unsigned int qpos;\n\n    unsigned int dataleft;\n\n    unsigned int chainofs;\n\n    unsigned int chainlen;\n\n    unsigned int speclen;\n\n    unsigned char tag;\n\n    unsigned int i, j;\n\n\n\n    s = src;\n\n    d = dest;\n\n    d_end = d + dest_len;\n\n    dataleft = AV_RL32(s);\n\n    s += 4;\n\n    memset(queue, 0x20, QUEUE_SIZE);\n\n    if (AV_RL32(s) == 0x56781234) {\n\n        s += 4;\n\n        qpos = 0x111;\n\n        speclen = 0xF + 3;\n\n    } else {\n\n        qpos = 0xFEE;\n\n        speclen = 100;  /* no speclen */\n\n    }\n\n\n\n    while (dataleft > 0) {\n\n        tag = *s++;\n\n        if ((tag == 0xFF) && (dataleft > 8)) {\n\n            if (d + 8 > d_end)\n\n                return;\n\n            for (i = 0; i < 8; i++) {\n\n                queue[qpos++] = *d++ = *s++;\n\n                qpos &= QUEUE_MASK;\n\n            }\n\n            dataleft -= 8;\n\n        } else {\n\n            for (i = 0; i < 8; i++) {\n\n                if (dataleft == 0)\n\n                    break;\n\n                if (tag & 0x01) {\n\n                    if (d + 1 > d_end)\n\n                        return;\n\n                    queue[qpos++] = *d++ = *s++;\n\n                    qpos &= QUEUE_MASK;\n\n                    dataleft--;\n\n                } else {\n\n                    chainofs = *s++;\n\n                    chainofs |= ((*s & 0xF0) << 4);\n\n                    chainlen = (*s++ & 0x0F) + 3;\n\n                    if (chainlen == speclen)\n\n                        chainlen = *s++ + 0xF + 3;\n\n                    if (d + chainlen > d_end)\n\n                        return;\n\n                    for (j = 0; j < chainlen; j++) {\n\n                        *d = queue[chainofs++ & QUEUE_MASK];\n\n                        queue[qpos++] = *d++;\n\n                        qpos &= QUEUE_MASK;\n\n                    }\n\n                    dataleft -= chainlen;\n\n                }\n\n                tag >>= 1;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11985, "substitutes": {"src": ["source", "rb", "rs", "sub", "star", "bin", "trans", "cur", "ins", "bs", "usr", "txt", "addr", "in", "r", "rl", "rel", "rc", "sur", "sb", "b", "c", "tmp", "copy", "rest", "sr", "st", "sc", "x", "ur", "iv", "loc", "img", "out", "sys"], "dest": ["id", "source", "decl", "end", "slave", "to", "home", "p", "trans", "dc", "cat", "del", "way", "gate", "desc", "r", "test", "done", "v", "good", "red", "tmp", "target", "master", "origin", "rest", "dist", "temp", "w", "st", "table", "Dest", "result", "partial", "loc", "out"], "dest_len": ["dest___l", "dest___lon", "del___l", "dest__loc", "dest_l", "del___length", "del_length", "del_len", "dest__len", "orig_pos", "dest__l", "orig_loc", "dest__pos", "dest_lon", "orig_length", "dest__length", "dest_length", "del_l", "dest__lon", "del___len", "del___lon", "dest___length", "dest_loc", "orig_len", "dest___len", "del_lon", "dest_pos"], "s": ["ms", "ats", "span", "hs", "cs", "m", "bits", "ins", "r", "t", "os", "has", "b", "str", "w", "ims", "ar", "units", "status", "source", "sp", "gs", "sts", "g", "sv", "args", "xs", "bs", "less", "js", "ss", "ops", "e", "sb", "des", "sc", "z", "ls", "sq", "spec", "qs", "a", "rs", "as", "f", "es", "index", "ts", "n", "ns", "start", "single", "tes", "ds", "comments", "q", "p", "ps", "us", "is", "S", "its", "series", "self", "c", "h", "stats", "fs", "st", "x", "sys"], "d": ["td", "dos", "dd", "id", "fd", "q", "end", "p", "o", "dev", "f", "da", "dc", "dx", "g", "del", "m", "l", "pd", "ld", "def", "did", "D", "dn", "dra", "r", "gd", "de", "n", "dq", "ad", "done", "t", "new", "dom", "v", "dir", "e", "b", "dim", "c", "red", "du", "di", "des", "dig", "dist", "bd", "dp", "w", "dat", "diff", "result", "z", "db", "dict", "dh", "debug", "dm", "sd", "dt", "ds", "dr", "out"], "d_end": ["d__len", " d_begin", "d__end", "d_END", "dxbegin", "d__start", "dh_ender", "d__en", "dxEND", "dh_end", " d_range", "dec_ender", "dxen", "dh_close", "dec_start", " d_start", "d_pos", "d_begin", "d_en", "d_start", "D_end", "dxend", " d_len", "d_range", "d_ender", "d_len", "dxrange", "dxlen", "D_start", " d_en", "D_len", " d_END", "dec_end", "d__ender", "dec_en", "dh_END", "dxstart", "d__pos", "d_close", "D_pos"], "queue": ["available", "next", "array", "entry", "status", "sync", "priority", "config", "buffer", "prefix", "message", "channel", "base", "Q", "q", "menu", "layer", "flag", "manager", "list", "complete", "history", "buf", "job", "pool", "worker", "ques", "limit", "block", "process", "require", "client", "sequence", "qv", "stack", "quality", "store", "all", "server", "Queue", "data", "dq", "journal", "que", "cache", "line", "archive", "master", "library", "force", "tube", "result", "batch", "context", "msg", "console", "jobs", "database", "ue", "required"], "qpos": [" qpo", "qpoint", "xpoint", "dqprop", "eqpo", "qloc", "qblock", "eqprop", "eqPos", " qprop", "qpo", "querypo", "queryPOS", " qloc", "dqpoint", "qtpo", "quloc", "queryloc", "iqpos", "qPOS", "dqposition", " qPOS", "qtpos", "ixpo", "tposition", "iqcache", "xposition", " qblock", "queryposition", "tpo", "iqPOS", "xpo", "dqpos", "qualpo", "qprop", "qupo", "qposition", "tPos", "qcache", "ixpos", " qPos", "qualpos", "ixposition", "qPos", "querypos", "iqposition", " qcache", "qtpoint", "qupos", "dqpo", "qublock", "iqpoint", "querypoint", "ixPos", "quPOS", "tpos", "iqpo", "qtposition", "qualposition", "xpos", "queryblock", "eqpos", " qposition", "qucache", "qualPOS", "dqPos", "qualpoint", "quposition"], "dataleft": ["Dataleft", " dataseaft", "datalpt", "catalefter", "dataleyfter", "datasext", " datalexp", "datalseaft", "cataleaft", "dataseft", "datalesxt", "datalseff", " dataleykt", "datealft", "datasefter", "dataleskt", " dataseft", " datasexp", "datALExt", "dat8", "datalesaft", "datalsexp", " dataleyff", "Dataleyft", " datalefts", "dataleyaft", "date_", "Dataleyff", " datasefter", "datalept", " dataleyfts", "dataleyld", "datalft", "datalesfter", "dataleyfts", " dat_", " dataleaft", "dataseaft", "datalff", " dataleffer", "datasexp", "datALEld", "catalseaft", "datalsefter", "datalesff", "dataneft", " dataseffer", " dataleyft", "datealkt", "dataaleff", "Dataleyld", "datalesft", " datasext", "dataleyft", "dataleypt", "dataaleaft", "datalexp", "datalseft", "catalseft", " dataseff", "datapleff", " dataleypt", "dataaseft", "datalefter", "dataplept", "dataleld", " dat8", "catalsefter", "datalespt", "Dataleff", "dataseld", "datealxt", "datalekt", "dataleffer", "dat_", "datalsept", "Dataleld", " dataleyaft", "dataleykt", "datalsext", "datalesxp", "catalsexp", "dt_", " dataleyxt", "dataseffer", "dt8", " datalext", "datapleft", "dataleaft", "datealffer", " dataleff", "dataleyxt", "datanefter", "datealaft", "dataaseff", " datalefter", "datalseffer", "datalext", "datalaft", " datalekt", "dataleff", " datalept", "date8", "datasept", "dataleyff", "dataseff", "dataneaft", "catalexp", "datanexp", "dataaseaft", "datALEft", "datealxp", "datalefts", "cataleft", "dataalept", "Dataleyxt", "dataasept", "datalsefts", "dataaleft", "datALEff", "Datalext", "dataplefts"], "chainofs": ["blockOFg", "chainlengthsid", "chainfontss", "chainOfsw", "chainOfS", "chainOfss", "chainfontsid", "chainofsid", "blockofsid", "chainOFsb", "blockofS", "baseOFs", "chainOFsw", "chainfonts", "chaineffsid", "blockOFs", "Chainofsid", "chainlengthis", "blockofi", "blockofsb", "baseofis", "chainfontsb", "chainofss", "chainOFsid", "blockOFsid", "blockofg", "chainOfsid", "chainofe", "baseofsid", "chainOFis", "baseOFis", "Chainofss", "baseOFsid", "chainoffsid", "baseofsi", "blockofe", "blockOFe", "ChainOfs", "chainofsw", "ChainOfss", "chainoffg", "chainOFsi", "chainoffs", "baseOFsi", "baseofs", "Chainofs", "chainOFi", "chainOFs", "ChainOfsw", "chainOfi", "chainofi", "blockofs", "chainlengthsi", "blockOFi", "chainofsi", "chainfontsw", "chainofsb", "ChainOfsid", "chainoffis", "chaineffs", "chainOfs", "chainlengths", "chainfonti", "blockOFS", "chainofis", "chainOFS", "blockOFsb", "chainOFe", "chainOFss", "chainOfsb", "chainofS", "chainoffe", "chainofg", "chainfontS", "chaineffe", "chaineffg", "Chainofsw", "chainOFg", "chainoffsi"], "chainlen": [" chainen", "cachell", "chainln", "grouplan", "repeatlon", "blocklen", "cachelen", "stacklan", "grouperr", "Chainlength", "blockLen", "rowll", "chainlan", " chaincoll", "Chainlen", "rangelan", " chainerr", "stackln", "Chainen", " chainLen", "grouplength", "checkLen", "chainLen", "rangelen", "chaincoll", "cachelan", "repeatlen", "rowcoll", "chainen", "rangeerr", " chainlan", "repeatln", "chainref", "checklen", "checkln", "chainll", "chainlength", " chainlength", "blocklength", " chainll", "rowen", "rangelength", "cachecoll", "Chainref", "grouplen", "stacklon", "stacklen", "cachelon", "ChainLen", " chainref", "chainerr", " chainln", "repeatlan", "rowlen", "cacheen", "Chainln", "blockref", "checken", "chainlon", "cacheln"], "speclen": ["speccog", "peclength", "specleden", "Speclew", "Speccens", "Speclength", "speccon", "speclog", "specken", "peclend", "peclen", "peplength", "specelend", "speCLenum", "speplenum", "Speccog", "speclon", "Speccen", "Speccon", "speclens", "specledength", "specllen", "speCLen", "speckon", "peccend", "speccew", "speclenum", "pepllen", "Speclog", "speflen", "Speclon", "speclength", "speccength", "specelength", "speclew", "specceng", "speflew", "speflens", "specledens", "speclusen", "spepllen", "peplen", "speCLlen", "speCLength", "Speclens", "specleng", "specledew", "speplen", "speckog", "speflog", "pecceng", "peclenum", "pecleng", "speckenum", "speflength", "peccength", "peccen", "speccen", "speclend", "Speccength", "Speccew", "specluseng", "specelen", "speplength", "specklen", "speccens", "Speclen", "peplenum", "speclusend", "speccend", "speckength", "speflon", "speceleng", "pecllen", "speclusength"], "tag": ["key", "tt", "brand", "id", "flag", "format", "match", "go", "tg", "var", "hash", "task", "field", "cat", "tc", "type", "attr", "te", "word", "kind", "token", "mod", "tail", "bit", "magic", "version", "test", "t", "mode", "Tag", "reg", "date", "feat", "tags", "comment", "cmd", "ag", "stat", "bug", "color", "link", "tar", "set", "pack", "name", "style", "TAG"], "i": ["id", "ai", "status", "I", "ie", "io", "me", "li", "ei", "init", "k", "p", "ii", "sim", "ind", "ui", "iter", "ip", "g", "m", "l", "ki", "ti", "ic", "cli", "us", "index", "r", "mi", "im", "ix", "n", "y", "t", "ci", "iu", "\u0438", "zi", "v", "phi", "info", "xi", "e", "multi", "b", "qi", "c", "h", "gi", "di", "bi", "str", "si", "pi", "it", "ini", "oi", "hi", "out", "ij"], "j": ["obj", "bj", "art", "aj", "ja", "jump", "J", "ie", "at", "ch", "li", "pt", "jo", "q", "k", "p", "o", "job", "sim", "jit", "ind", "f", "jp", "l", "m", "pos", "json", "index", "jj", "try", "js", "uj", "br", "n", "y", "jas", "t", "jl", "v", "fr", "pr", "b", "c", "bi", "oj", "it", "x", "z", "att", "dj", "no", "ji", "kj", "ij"]}}
{"project": "qemu", "commit_id": "3daa41078aedf227ec98b0d1c9d56b77b6d20153", "target": 1, "func": "void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}", "idx": 11988, "substitutes": {"req": ["sq", "obj", "tx", "cmp", "qq", "require", "prefix", "call", "decl", "crit", "q", "err", "ack", "compl", "tek", "rec", "resp", "job", "seq", "task", "ind", "ps", "gr", "pkg", "jp", "need", "wx", "cb", "request", "desc", "progress", "rr", "urg", "txt", "pub", "addr", "inv", "ext", "qt", "md", "r", "usr", "js", "rel", "needed", "dq", "aux", "ctx", "rem", "reg", "deg", "fr", "good", "wcs", "ctr", "comp", "query", "cmd", "low", "exec", "subject", "forced", "rest", "res", "requ", "coord", "org", "comm", "quest", "required"]}}
{"project": "qemu", "commit_id": "577bf808958d06497928c639efaa473bf8c5e099", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 11998, "substitutes": {"s": ["ms", "sq", "qs", "a", "rs", "as", "sg", "p", "gs", "sts", "ps", "d", "g", "cs", "m", "es", "i", "ses", "bs", "aws", "r", "is", "js", "S", "ss", "ts", "n", "t", "v", "os", "sb", "b", "c", "sn", "ns", "stats", "fs", "z", "comm", "ls", "sd", "ds"], "pc": ["ms", "td", "arc", "pic", "pp", "pt", "rs", "enc", " PC", "proc", "p", "ec", "amp", "sec", "bc", "cs", "tc", "ptr", "cc", "ts", "pb", "mc", "ac", "px", "PC", " dc", "rc", " RPC", "gc", "c", "asc", "nc", " rc", "fc", "sc", "vc", " proc", "pa"], "tmp": ["tf", "tt", "obj", "lambda", "prime", "cmp", "mb", "map", "buffer", " unused", " ptr", " mp", " proc", "uf", "Temp", "zip", "sp", "p", " cached", "resp", "buf", " np", " sp", "cp", "mint", " mt", " td", "np", " MP", "jp", "m", "pkg", "ptr", "cb", "vt", "util", "txt", "appy", "snap", "test", " t", "pb", "perm", "t", "ctx", "tn", "v", "mk", " out", " resp", " temp", " ts", "comp", "rt", " p", "temp", "etc", " pp", "nb", "MP", "buff", " tcp", "cv", "mp", " result", "emp", "img", "ret"]}}
{"project": "qemu", "commit_id": "8dfd5f96515ca20c4eb109cb0ee28e2bb32fc505", "target": 0, "func": "static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,\n\n                                            uint16_t code, const char *reason)\n\n{\n\n    struct iovec iov;\n\n    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));\n\n    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =\n\n        cpu_to_be16(code);\n\n    ioc->rawoutput.offset += 2;\n\n    if (reason) {\n\n        buffer_append(&ioc->rawoutput, reason, strlen(reason));\n\n    }\n\n    iov.iov_base = ioc->rawoutput.buffer;\n\n    iov.iov_len = ioc->rawoutput.offset;\n\n    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,\n\n                               &iov, 1, iov.iov_len);\n\n    buffer_reset(&ioc->rawoutput);\n\n    qio_channel_websock_write_wire(ioc, NULL);\n\n    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);\n\n}\n", "idx": 12023, "substitutes": {"ioc": [" iroc", "ciict", "iuoc", "iuog", "hioc", "inioad", "miosc", "pioad", "gioc", "dioco", "liocal", "Ioc", "iict", "iuocr", "iuoca", "miog", "hioci", "ciOC", "uiok", "bioc", "liog", "diocy", "uiict", " iocation", " ioca", "miocr", "diroc", "clioad", "ioint", "Iroc", "diOC", "cliOC", "siosc", "inioc", "dioc", "IOC", "siocon", "iosc", "pioco", "iioc", "cioci", "clioc", "iocate", "giocon", "pioc", "piOC", "ciocal", "mioc", "iog", "liroc", "hiocate", "ioco", "lioint", "iiOC", " ioco", " iocal", "ciok", "cioint", "iocy", "iniOC", "xiog", "xiocation", "mioad", "uioci", "liocate", "inioci", "iocal", "iocr", " iocon", "mioca", "iocation", "lioc", "piog", " ioci", " iocate", "piocate", "liocation", "cioc", "piroc", "biog", "iiroc", "hiocation", " iog", "iocon", "biov", "iOC", "lioci", "iok", "clioci", "xiocate", "sioc", "piocation", "Iok", "biocate", "giog", "iroc", "Iocy", "piosc", " ioint", "pioci", "xioc", "iiocy", "Ioci", " ioad", "sioad", " iocr", "liov", "liOC", "ioci", "ioad", " iocy", "piocon", "miocon", "Iict", "uioc", "dioci", "giroc", "ioca", " iOC", "liocy"], "code": [" cause", "command", " count", "status", "call", " status", " create", "message", "coe", "buffer", " component", " text", " chip", "Code", "value", " scheme", " change", "frame", "error", "size", "second", "type", " challenge", " sequence", "length", "ce", " cmd", " content", " frame", "create", " control", " coded", "data", "mode", " state", "count", " mode", " chunk", " error", " program", "change", "close", " decode", " event", "scene", "ode", "age", "time", " command", " body", " message"], "reason": ["command", "warn", "use", "status", "negative", "require", "message", "external", "crit", "why", " why", "value", "ASON", "ason", "critical", "report", "error", "unit", "component", "original", "block", "condition", "note", "other", "zero", "detail", "request", "desc", "intention", "broken", " reasons", "none", "details", "when", "chain", "asons", "race", "cond", "warning", "severe", "connection", "roy", "cause", "unknown", "change", "close", "comment", "re", "rule", "res", "force", "context", "lost", " whence", "because", "group", "msg", "description", "name", "before", "template", "Reason"], "iov": ["vector", "imp", "io", "minecraft", "av", "ei", "iw", "ichael", "ovi", "iq", "von", "ovo", "resp", "iop", "uv", "ibr", "gov", "voice", "mpeg", "ivic", "iro", "liv", "lv", "kj", "vp", "vec", "np", "rov", "chrom", "i", "drm", "kov", "isco", "iph", "inv", "verbs", "uj", "soc", "iva", "lov", "vo", "iu", "idav", "ever", "v", "IV", "nov", "iol", "voc", "nom", "iii", "ih", "ech", "vision", "rir", "iour", "Iv", "vr", "iv", "rolet", "river", "iev", " vib", "ux", "tv", "meg", "ij"]}}
{"project": "qemu", "commit_id": "77af8a2b95b79699de650965d5228772743efe84", "target": 0, "func": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)\n\n{\n\n    fadt->model = 1;\n\n    fadt->reserved1 = 0;\n\n    fadt->sci_int = cpu_to_le16(pm->sci_int);\n\n    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);\n\n    fadt->acpi_enable = pm->acpi_enable_cmd;\n\n    fadt->acpi_disable = pm->acpi_disable_cmd;\n\n    /* EVT, CNT, TMR offset matches hw/acpi/core.c */\n\n    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);\n\n    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);\n\n    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);\n\n    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);\n\n    /* EVT, CNT, TMR length matches hw/acpi/core.c */\n\n    fadt->pm1_evt_len = 4;\n\n    fadt->pm1_cnt_len = 2;\n\n    fadt->pm_tmr_len = 4;\n\n    fadt->gpe0_blk_len = pm->gpe0_blk_len;\n\n    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */\n\n    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */\n\n    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |\n\n                              (1 << ACPI_FADT_F_PROC_C1) |\n\n                              (1 << ACPI_FADT_F_SLP_BUTTON) |\n\n                              (1 << ACPI_FADT_F_RTC_S4));\n\n    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);\n\n    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs\n\n     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used\n\n     */\n\n    if (max_cpus > 8) {\n\n        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);\n\n    }\n\n    fadt->century = RTC_CENTURY;\n\n}\n", "idx": 12026, "substitutes": {"fadt": ["tfpadth", "efadtt", " fAdto", "fpadtree", "frodtd", "flavelet", "fwdts", "fplaywt", "fildtd", "fpaddet", "fradkt", "fpadout", "confplayt", "fadtor", "foreadt", "fildto", "leadit", "confpadnt", "feddt", "fadout", "favelet", "tfadth", "confpadto", "feadg", "confadt", "facet", "foreadwt", "fadvt", "fADT", "foreadx", "fadter", "ffadter", "ffadtor", "ifpadt", "confadtr", "fpadkt", "feadx", "efpadtt", "fradeti", "strrodx", "flpadt", "fpadh", "fplayte", "fADt", "fradtt", "fradti", "efadt", "dfadt", "fiberti", "fadedt", "fadlet", "flpadwt", "facedt", "flaveot", "feadot", "fopadt", "faceto", "fladter", "fadst", "frodtor", "fadh", "xeadtd", "fleadkt", "yaddt", "tfpadts", "fadth", "faudkt", "tfpadt", " fadtt", "fadtr", "ufadt", "faultvt", "ufadto", "confpadt", "confadtd", "leadlet", "frakt", "feadwt", "stradts", "facht", "dfpadit", "freatt", "xeadT", "faultdt", "fangtor", "fladwt", "ufpadtree", "fankh", "feadt", "fayrt", "faytd", "favex", "fpadta", "fachnot", "farkrt", "frodT", "fachtd", "fadT", "fadta", "faidtt", "fleadg", "confplayto", "fangt", "fodkt", "ufadtree", "favets", "ufpadto", "ffadnot", "ffpadtor", "confadto", "ladit", "foadh", "efpadt", "frodt", "fwdt", "fpadit", "fradett", "fankt", "fladts", "fAdt", "fpadnt", "fleadt", "flavet", "fradet", "fadti", "faidt", "yadt", "fadets", "fanktr", "confadnt", "foradt", "freatdt", "ffpadnot", "foreadkt", "fleadter", "confplaytr", "fplayt", "faudset", "ifadtor", "faudet", "fodg", "fpadnot", "fadeot", "fpadtt", "xadtd", "fpadt", "farktar", "strrodt", "fayg", "faddT", "faytar", "yrakt", "faddt", "efadset", "fradt", "fiberdt", "tfadt", "fwdh", "fAdto", "flpadet", "fadelet", "ifadte", "fopadout", "formadt", "stradt", "ufpadh", "foradwt", "farth", "fadwt", "faytt", "fadset", "fankout", "stradtor", "faultto", "fplayto", "fachth", "feadts", "favekt", "xeadg", "farkit", "faudtor", "ladt", "efpadit", "feadlet", "confplaytd", "fachts", "fladlet", "feadnt", "fadtar", "fadtree", "fwdtree", "ifpadte", "yrakdt", "fayT", "xadt", "confpadta", "fartto", "fpadts", "dfpadt", "fpadtar", "ffpadter", "fladg", "ifpaddet", "fwdto", "fradtr", "fpadter", "formadtr", "facevt", "fadte", "freattt", "flpadte", "fayset", "fAdtt", "faidto", "feadkt", "fAdT", "formadkt", "fpadrt", "fopadh", "fangnot", "tfadts", "fadtt", "efadit", "fadit", "flavets", "faudwt", "foradx", "fachtor", "faveot", "fadett", "feadit", "fildt", " fadto", "failh", "strrodtor", "fachtr", "fpadwt", "fladte", "fpadte", " fAdt", "fadet", "fedddet", "fAdkt", "fayt", "frodx", "stradx", "fladkt", "fopadtr", "fadto", "ladT", "leadT", "feddte", "fwdtor", "feadta", "fraddt", "fauddet", "fadsnt", "feddtor", "farttree", "fpadto", "failout", "fladet", "frakvt", "feadtd", "formradkt", "faddet", "fpadet", "faudts", "yrakto", "fwdx", "fachter", "fadsta", "faidT", "fplayet", "xadg", "favet", "ifaddet", "fAdtr", "yrakvt", "fadrt", "foadt", "ffadt", "feadT", "fADlet", "fADit", "failt", "tfpadset", "tfadset", "fladot", "fildtr", "frakdt", "dfpadtar", " fadT", "feadtt", "dfadrt", "formradtr", "dfadtar", "xadT", "fodt", " fAdtt", "fadot", "strrodts", "ifpadtor", "ifadt", "xeadt", "fpadtor", "frodts", "fplaytd", "leadt", "fpadx", "farkt", "fadg", "fpadset", "fpadtr", "faddit", "ufadh", "fadx", "frodg", "fladt", "fadnot", "fodter", "faultt", "faddlet", "frakto", "failtr", "fadeti", "faudtr", "ufpadt", "ffpadt", "fibertt", "efpadset", "fadsto", "fadkt", "foadtr", "formradt", "faudte", "fartt", "feadto", " fAdT", "dfadit", "fangter", "fradedt", "dfpadrt", "fadnt", "fplaytr", "fadts", "freatti", "faudt", "feadter", "fibert", "fpadth", "yadvt", "fadtd", "foradkt", "favewt", "faudth", "fachto", "fachset", "fayit", "foadout", "ladlet", "yadto", "confadta", "feadset"], "pm": ["ms", "activity", "gem", "py", "hm", "rpm", "pc", "nm", "mm", "pp", "pt", "gm", "prom", "asm", "p", "gom", "post", "dev", "sm", "ps", "pg", "ram", "mo", "pkg", "m", "pd", "bm", "my", "um", "process", "service", "sam", "mod", "pai", "mi", "pb", "perm", "px", "rem", "conf", "PM", "mmm", "wp", "ym", "master", "member", "lamm", "cm", "po", "pi", "ams", "rm", "prem", "param", "dm", "mp", "vm", "pre", "pid", "am", "iam", "pa"]}}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)\n\n{\n\n    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);\n\n\n\n    if (val & ACPI_BITMASK_SLEEP_ENABLE) {\n\n        /* change suspend type */\n\n        uint16_t sus_typ = (val >> 10) & 7;\n\n        switch(sus_typ) {\n\n        case 0: /* soft power off */\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        case 1:\n\n            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.\n\n               Pretend that resume was caused by power button */\n\n            ar->pm1.evt.sts |=\n\n                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);\n\n            qemu_system_reset_request();\n\n            qemu_irq_raise(ar->pm1.cnt.cmos_s3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 12036, "substitutes": {"ar": ["arr", "art", "arc", "ah", "ear", "arb", "arp", "air", "a", "par", "war", "et", "ars", "rs", "ak", "or", "arry", "dar", "mar", "ara", "car", "cr", "ra", "mr", "rr", "adr", "aer", "arm", "r", "ary", "ir", "actor", "arg", "ler", "anc", "ro", "ag", "aro", "er", "har", "ocr", "AR", "ard", "tar", "ur", "bar", "are", "rar", "am"], "val": ["key", "len", "num", "xy", "tx", "al", "status", "sol", " value", "crit", "valid", "VAL", "value", "var", "p", "buf", "unit", " aval", "rol", "l", "ref", "Val", "fb", "values", "vt", "cal", "bit", "eval", "index", "data", "test", "kl", "reg", "count", "v", " v", "conf", "b", "pol", "bal", "sel", "elt", "res", "serv", "stat", "vals", "it", "x", "el", "aval", "max", "vol"]}}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static void win32_rearm_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct qemu_alarm_win32 *data = t->priv;\n\n    uint64_t nearest_delta_us;\n\n\n\n    if (!active_timers[QEMU_TIMER_REALTIME] &&\n\n                !active_timers[QEMU_TIMER_VIRTUAL])\n\n        return;\n\n\n\n    nearest_delta_us = qemu_next_deadline_dyntick();\n\n    nearest_delta_us /= 1000;\n\n\n\n    timeKillEvent(data->timerId);\n\n\n\n    data->timerId = timeSetEvent(1,\n\n                        data->period,\n\n                        host_alarm_handler,\n\n                        (DWORD)t,\n\n                        TIME_ONESHOT | TIME_PERIODIC);\n\n\n\n    if (!data->timerId) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(data->period);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 12038, "substitutes": {"t": ["td", "tm", "tt", "tr", "u", "a", "pt", "k", "tg", "p", "kt", "o", "f", "nt", "d", "mint", "g", "l", "tc", "m", "mt", "te", "i", "vt", "txt", "r", "ta", "that", "ts", "y", "n", "test", "v", "e", "tin", "b", "c", "wt", "h", "w", "ent", "it", "x", "z", "T", "tu", "tick", "dt", "ret"], "data": ["clear", "config", "add", "format", "rec", "o", "d", "block", "m", "details", "r", "done", "str", "share", "size", "key", "Data", "record", "call", "delete", " DATA", "request", "relation", "ta", "rel", "version", "final", "new", "date", "dat", "table", "att", "DATA", "debug", "no", "writer", "state", "params", "obj", "valid", "error", "def", "window", "index", "chain", "owner", "n", "connection", "ad", "bus", "info", "action", "exec", "db", "module", "empty", "entry", "join", "list", "complete", "p", "defined", "dev", " Data", "da", "normal", "ata", "client", "zero", "json", "cache", "group", "name", "dr"], "nearest_delta_us": ["nearest_delta_eu", "nearest_delta_mus", "nearest_dota_ms", "nearest_delta_u", "nearest_dota_eu", "nearest_dota_mus", "nearest_dota_um", "nearest_delta_ms", "nearest_delta_um", "nearest_dota_us", "nearest_dota_u"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qapi_dealloc_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    void **obj = qapi_dealloc_pop(qov);\n\n    if (obj) {\n\n        g_free(*obj);\n\n    }\n\n}\n", "idx": 12075, "substitutes": {"v": ["nv", "u", "vy", "vi", "av", "q", "ev", "vv", "ov", "uv", "p", "var", "o", "f", "d", "vp", "m", "sv", "i", "qv", "vt", "r", "j", "n", "y", "vo", "vd", "V", "vim", "e", "b", "c", "h", "verb", "x", "cv", "vr", "vm", "vc", "conv", "tv", "nov"], "errp": ["errr", "errP", "rP", " errP", "rp", "err", "rr", "erP", " errr", "erp"], "qov": ["qovi", " qOV", "dqvo", "quvo", "wovi", " qvo", "dqOV", " qovi", "quova", "qova", "quav", "wav", "qOV", " qav", "wova", "qav", "quov", "quOV", "qvo", "dqova", " qova", "quovi", "dqov", "wov"], "obj": ["utt", "arr", "bj", "xy", "ready", "pt", "Obj", "tk", "Object", "func", "resp", "o", "nt", "ok", "act", "instance", "mo", "ref", "object", "attr", "ptr", "objects", "txt", "addr", "alt", "expr", "js", "rel", "j", "ts", "fn", "ctx", "bo", "fr", "os", "rect", "tmp", "any", "ns", "str", "elt", "ob", "inst", "vol"]}}
{"project": "qemu", "commit_id": "c951d9a6751576a076ac80a5e5145ceb8d794d38", "target": 1, "func": "static void file_completion(const char *input)\n\n{\n\n    DIR *ffs;\n\n    struct dirent *d;\n\n    char path[1024];\n\n    char file[1024], file_prefix[1024];\n\n    int input_path_len;\n\n    const char *p;\n\n\n\n    p = strrchr(input, '/');\n\n    if (!p) {\n\n        input_path_len = 0;\n\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n\n        pstrcpy(path, sizeof(path), \".\");\n\n    } else {\n\n        input_path_len = p - input + 1;\n\n        memcpy(path, input, input_path_len);\n\n        if (input_path_len > sizeof(path) - 1)\n\n            input_path_len = sizeof(path) - 1;\n\n        path[input_path_len] = '\\0';\n\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n\n    }\n\n#ifdef DEBUG_COMPLETION\n\n    monitor_printf(cur_mon, \"input='%s' path='%s' prefix='%s'\\n\",\n\n                   input, path, file_prefix);\n\n#endif\n\n    ffs = opendir(path);\n\n    if (!ffs)\n\n        return;\n\n    for(;;) {\n\n        struct stat sb;\n\n        d = readdir(ffs);\n\n        if (!d)\n\n            break;\n\n\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n\n            memcpy(file, input, input_path_len);\n\n            if (input_path_len < sizeof(file))\n\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n\n                        d->d_name);\n\n            /* stat the file to find out if it's a directory.\n\n             * In that case add a slash to speed up typing long paths\n\n             */\n\n            stat(file, &sb);\n\n            if(S_ISDIR(sb.st_mode))\n\n                pstrcat(file, sizeof(file), \"/\");\n\n            readline_add_completion(cur_mon->rs, file);\n\n        }\n\n    }\n\n    closedir(ffs);\n\n}\n", "idx": 12079, "substitutes": {"input": ["command", "inc", "u", "config", "prefix", "edit", "human", "pattern", "first", "m", "import", "view", "unknown", "cmd", "str", "w", " in", "context", "history", "output", "key", "source", "read", "uri", "Input", "init", "value", "request", "ix", "missing", "get", "PUT", "initial", "shift", "current", "id", "buffer", "image", "up", "sample", "focus", "form", "field", "f", " Input", "ip", "cur", "local", "i", "raw", "in", "index", "P", "exec", "start", "it", "empty", "select", "text", "join", "base", "padding", "q", "pad", "active", " inputs", "c", "query", "h", "x"], "ffs": ["ffieldS", "affgins", "effS", "effds", "ffds", "lfs", "FFns", "ffS", " ffws", "ffieldgins", "lffs", "FFds", "affs", "affS", "ffjs", "FFts", "ffields", "xffws", "xffS", "effts", "ufds", "aftjs", "FFS", "lfds", "aftS", "ffieldns", "ffts", "ffieldjs", "FFgins", "fffs", "effs", "uffs", "effjs", "ffws", "FFjs", "aftns", "FFws", "affns", "ffgins", "lfts", "ufjs", " ffS", "ffns", "effns", "afts", "xffs", "ufts", "FFfs", "ufs", "FFs"], "d": ["td", "dd", "fd", "nd", "defined", "f", "ld", "da", "dc", "dx", "g", "pd", "m", "l", "i", "D", "dn", "r", "md", "gd", "j", "de", "data", "done", "n", "ad", "dl", "t", "v", "dir", "e", "b", "dim", "c", "du", "h", "di", "dat", "w", "bd", "dist", "dot", "z", "db", "dict", "s", "dm", "dh", "sd", "dt", "ds", "dr"], "path": ["doc", "config", "prefix", "PATH", "format", "pattern", "print", "prop", "mount", "open", "m", "desc", "parent", "session", "package", "data", "cmd", "str", "ath", "context", "history", "output", "key", "call", "code", "message", "route", "sp", "test", "Path", "conn", "dir", "temp", "link", "time", "template", "current", "part", "policy", "pt", "form", "error", "cp", "th", "ref", "type", "local", "raw", "index", "chain", "line", "host", "out", "empty", "entry", "text", "pointer", "ring", "list", "pkg", "port", "all", "core", "root", "directory", "cache", "c", "stat", "full", "set", "name", "length", "parts"], "file": ["output", "page", "filename", "id", "fd", "fi", "part", "buffer", "io", "source", "base", "format", "image", "document", "channel", "ile", "File", "list", "to", "f", "field", "error", "fp", "files", "domain", "size", "type", "local", "null", "parent", "port", "model", "txt", "handle", "cli", "server", "bit", "il", "r", "data", "header", "entity", "tree", "dir", "line", "lock", "h", "stat", "table", "full", "result", "time", "db", "user", "s", "disk", "name", "byte", "length", "out"], "file_prefix": ["file__ix", "file2root", "file_base", "file_label", "fileerpassword", "file2fix", "file_pre", "file2prefix", "folder_ix", "module_ix", " file_primary", "module_label", "page_prefix", "file_network", "file_password", "fileerix", "file_root", "file__base", "FILE_prefix", "file_context", "file__pre", "file__label", " file_pre", "foldererix", "page_path", "foldererpre", "file_fix", "FILE_fix", "folder_pre", "file__prefix", "file_ix", "FILE_pre", "file__fix", "file_path", "page_padding", "fileerpre", " file_fix", "file2pre", "file_primary", "file_padding", "foldererpassword", " file_ix", " file_network", "page_context", " file_root", "folder_prefix", "file__root", "foldererprefix", "folder_password", "module_base", "module_prefix", "fileerprefix"], "input_path_len": ["input_path_Len", "input_path_num", "input_path___len", "input_path_en", "input_path_el", "input_path_lon", "input_pathtyLen", "input_Path_el", "input_col_len", "input_Path_size", "input_path___num", "input_col_en", "input_Path_val", "input_path__Len", "input_path__len", "input_Path_l", "input_pathtylen", "input_path2l", "input_Path_len", "input_col_pos", "input_path__en", "input_pathtylabel", "input_path__pos", "input_Path_label", "input_path_size", "input_Path_num", "input_path_label", "input_Path_loc", "input_path_loc", "input_path2length", "input_path___Len", "input_path__lon", "input_path__coll", "input_Path_lon", "input_path_length", "input_pathtyval", "input_path_coll", "input_path_pos", "input_path___loc", "input_path_val", "input_Path_pos", "input_col_coll", "input_path2len", "input_path2Len", "input_path_l", "input_Path_length", "input_Path_Len", "input_path__length"], "p": ["ph", "u", "pc", "pe", "tp", "par", "pp", "prefix", "pt", "padding", "q", "ping", "bp", "a", "k", "sp", "post", "f", "cp", "ps", "fp", "pg", "pad", "ip", "g", "jp", "m", "pos", "ap", "np", "l", "press", "i", "pkg", "after", "lp", "r", "j", "n", "pb", "y", "P", "t", "v", "pr", "b", "c", "wp", "h", "pro", "pi", "php", "x", "pre", "pa"], "sb": ["sq", " sc", " sa", "bf", "mb", "sth", "std", "rb", "bp", "sg", "sp", "sm", " sp", "ld", " ss", "hd", "sv", "cb", "sam", "si", " db", "bs", "pb", "dl", " b", "dB", "eb", "ssl", "sf", "b", "zb", "sw", "sh", " sd", "kb", "sa", "SB", "bd", "st", "stat", " SB", "sc", "bb", "nb", "ob", "gb", "ib", "db", "dh", "dm", "s", " sys", "ds", "sd"]}}
{"project": "qemu", "commit_id": "6350b0904615cc0531cc3059ea34db5c009c88aa", "target": 1, "func": "static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n", "idx": 12083, "substitutes": {"obj": ["obs", "xy", "typ", "Obj", "go", "ev", "p", "o", "ex", "od", "nt", "act", "oid", "ref", "object", "attr", "inv", "cont", "js", "j", "ctx", "bo", "unknown", "os", "tmp", "h", "bh", "ot", "hw", "serv", "onet", "ob", "it", "phys", "org", "vr", "inst", "out"], "v": ["vs", "vy", "vi", "av", "q", "ev", "vu", "vv", "uv", "p", "o", "vc", "f", "d", "vp", "g", "m", "l", "sv", "vis", "vt", "ver", "r", "j", "t", "V", "b", "c", "w", "cv", "vr", "vm", "nv", "conv", "tv"], "opaque": [" opane", "oposer", "oplaque", " oposer", "opque", "opsaque", "oplain", "opane", "oplacity", " opacity", "opsoser", "paque", "opain", "popain", "pane", "poser", "popacity", "popque", "oplque", " opque", "popaque", "opsane", " opain", "opacity"], "name": ["NAME", "key", "id", "nm", "part", "prefix", "text", "path", "names", " names", "named", "nam", "var", "p", "error", "label", "m", "type", "ame", "attr", "local", " Name", "word", "term", "family", "property", "data", "n", "cap", "comment", "title", " prefix", "str", "alias", "tag", "Name", "param", "size"], "errp": ["nrp", "ierbp", "errpad", "ererp", "errorm", "nrcp", "erpa", "ierpad", "erpc", "errm", "rrping", "nrbp", "warnbp", "ierm", "rrm", "errorpoint", "rrp", "rezm", "ererP", "erP", "ererpc", "errbp", "errpc", "erp", "warnP", "errorping", "ererpa", "warnpa", "errcp", "errorp", "errpoint", " errm", " errbp", "errping", "rezp", "rezpoint", "warnpc", "errpa", "nrpad", "errP", "rrpoint", "rezping", "warncp", "warnp", "rrbp", "warnpad", "ierp", "iercp"], "dev": ["dd", "priv", "av", "pt", "device", "cam", "go", "ev", "det", "nav", "proc", "den", "ve", "var", "adv", "od", " Dev", "nt", "d", "eng", " device", "def", "oy", "serial", "vt", "ver", "addr", "dep", "md", "ad", "dem", "conn", "DEV", "wd", "conf", "gu", "env", "tech", "die", "Dev", "van", "Device", "des", "hw", "w", "serv", "att", "debug", "app", "pro"], "prop": ["col", "key", "op", "ph", "tx", "lit", "priv", "spec", "acc", " props", "prof", "pt", "decl", "plot", "err", "ev", "per", "proc", "pred", "p", "rep", "ps", "cp", "sec", "prot", "jp", "pos", "pkg", "attr", "def", " Prop", "pri", "supp", "term", "property", "rel", "j", "pb", "cap", "perm", "ctx", "conf", "info", "cfg", "pr", "feat", "pl", "val", "comp", "fac", "cmd", "str", "rop", "opt", "by", "Prop", "att", "pack", "mp", "pro"], "ptr": ["arr", "tr", "address", "tp", "priority", "buffer", "pointer", "pt", "err", "seek", "proc", "p", "sp", "buf", "rep", "inters", "pointers", "rob", "jp", "pos", "ref", "inter", "attr", "vt", "adr", "addr", "expr", "index", "br", "dest", "ctx", "pr", "val", "ctr", "eth", "pert", "Ptr", "set", "vr", "loc", "offset", "dr"], "local_err": [" local_er", "localErerr", "local_rs", "localmyer", "loc_conn", "loc_err", "local_exc", "locmyrb", "localErbuf", " local_r", "local2err", " local_buf", "local2rr", " local_exc", "local2msg", "loc_er", "local_r", "localjrr", "local_er", "local2exc", "local_conn", " local_msg", "localmyrb", "local_gz", "loc_rb", " local_gz", "localjmsg", "localErr", " local_rs", "local_buf", "locmyerr", "locmyer", " local_rr", "local_rr", "localjerr", "locmyconn", "local_msg", "local_rb", "localErrs", "localmyconn", "localjexc", "localmyerr"], "value": [" voltage", "update", "range", "vp", "values", "attribute", "data", "VALUE", "always", "unknown", " bar", "result", "see", " load", " seek", "size", "tv", " values", "output", "key", " VAL", "depth", "address", "status", " total", "VAL", "sv", "hello", " Value", "test", "version", "byte", "state", "ue", "current", "id", "buffer", "valid", " address", "field", "unit", " val", "type", "serial", "raw", " rest", "property", "index", "description", "now", " compute", " payload", "start", " quantity", "content", "entry", "priority", "text", "currently", "we", "label", "position", "port", "save", "json", "checked", "total", " priority", "val", "Value", " tv", "set", " result", "max", "length"]}}
{"project": "qemu", "commit_id": "d7cd369402191814a1bb339a730f3af411e9682f", "target": 1, "func": "static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 12086, "substitutes": {"opaque": ["coaques", " opossibly", "Opaque", "opossibly", "Opossibly", "pque", "opaques", "colation", "opque", " opvious", "opvious", "OPlation", "OPaque", "Opinion", "coaque", " Opaque", "opinion", "coque", " opinion", "Opvious", "paque", " Opvious", "OPaques", "paques", " Opinion", "OPque", " Opossibly", "plation", "oplation"], "co": ["col", "oc", "aco", "ko", "op", "con", " ro", "pc", "fo", " Co", "go", " con", "cro", "o", "Co", " ho", "flo", "mo", "ra", "osa", "ho", "uto", "cal", "mi", "oo", "bo", "c", "ro", "po", "nc", "oe", "cu", "CO", "lo", " mo", "ca", "ico"]}}
{"project": "FFmpeg", "commit_id": "6a99310fce49f51773ab7d8ffa4f4748bbf58db9", "target": 1, "func": "static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)\n\n{\n\n    int i = 0;\n\n    unsigned int ave_mean;\n\n    s->transient[ch] = get_bits1(&s->gb);\n\n    if (s->transient[ch]) {\n\n        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));\n\n        if (s->transient_pos[ch])\n\n            s->transient[ch] = 0;\n\n        s->channel[ch].transient_counter =\n\n            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);\n\n    } else if (s->channel[ch].transient_counter)\n\n        s->transient[ch] = 1;\n\n\n\n    if (s->seekable_tile) {\n\n        ave_mean = get_bits(&s->gb, s->bits_per_sample);\n\n        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);\n\n    }\n\n\n\n    if (s->seekable_tile) {\n\n        if (s->do_inter_ch_decorr)\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);\n\n        else\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);\n\n        i++;\n\n    }\n\n    for (; i < tile_size; i++) {\n\n        int quo = 0, rem, rem_bits, residue;\n\n        while(get_bits1(&s->gb)) {\n\n            quo++;\n\n            if (get_bits_left(&s->gb) <= 0)\n\n                return -1;\n\n        }\n\n        if (quo >= 32)\n\n            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);\n\n\n\n        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);\n\n        if (ave_mean <= 1)\n\n            residue = quo;\n\n        else {\n\n            rem_bits = av_ceil_log2(ave_mean);\n\n            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;\n\n            residue  = (quo << rem_bits) + rem;\n\n        }\n\n\n\n        s->ave_sum[ch] = residue + s->ave_sum[ch] -\n\n                         (s->ave_sum[ch] >> s->movave_scaling);\n\n\n\n        if (residue & 1)\n\n            residue = -(residue >> 1) - 1;\n\n        else\n\n            residue = residue >> 1;\n\n        s->channel_residues[ch][i] = residue;\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 12095, "substitutes": {"s": ["ms", "events", "vs", "orders", "parts", "ats", "sg", "hs", "cs", "m", "bits", "ins", "details", "http", "se", "y", "t", "sports", "ties", "os", "serv", "comm", "rates", "ims", "ers", "ports", "status", "gets", "settings", "gs", "sts", "ex", "ess", "changes", "ies", "sv", "ses", "sam", "bs", "services", "als", "js", "less", "ss", "conf", "sets", "ops", "sb", "z", "ls", "states", "sq", "obj", "qs", "a", "rs", "as", "ants", "es", "ts", "views", "styles", "sw", "results", "ns", "ds", "comments", "eps", "ps", "ains", "aws", "is", "series", "S", "its", "ssl", "c", "bis", "h", "stats", "fs", "stat", "set", "sys", "store"], "ch": ["col", "Ch", "chron", "ah", "hr", "gh", "sky", "channel", "q", "chan", "sch", "cell", "chn", "cor", "chin", " chip", "k", "pan", "p", "ach", "cl", "ich", "cp", "gr", "th", "chart", "cur", "chi", "cs", "cer", "client", "chrom", "cb", "hl", "ver", "cht", "chain", "cho", "cod", "br", "y", "ches", "v", "zh", "och", "ched", "che", "chip", "chat", "change", "c", "sh", "h", "kh", "ih", "tch", "ech", "z", "batch", "CH", "history", "ht", "cha"], "tile_size": ["tile10width", "tree_width", "tile67size", " tile_length", " tile_small", "tile10size", "tree_dimension", "tileNamesmall", "tree67width", "tile10number", "tile_dimension", "tree_size", "tile_width", "tile_number", "tile_Size", " tile_len", "tree67number", "tile_length", "tile67dimension", "tile_small", "tree_number", "tileNameSize", "tile67number", "tile10dimension", " tile_Size", "tileNamesize", "tile67width", "tree67size", "tree67dimension", "tile_len"], "ave_mean": ["ena00mean", "aveLEgroup", "ave42made", "ave_sem", "aveLEmean", "ave_group", "avematsummary", "aveLEmin", "ave_____sum", "av_made", "avematmean", "ome_an", "av2max", "ave2max", "av2mean", "av2made", "ave_an", "erve_sem", "av_sum", "ave67sav", "ave00metadata", "ome2mean", "ave_average", "ome_average", "ave_made", "ave00min", "ave2made", "avematsav", "ave42sum", "ave2an", "erve_mode", "ave_min", "ave_sum", "ave42max", "ave67normal", "ave_summary", "ome2normal", "ave_metadata", "ome2average", "ena00group", "av2sum", "ave2average", "ave_normal", "av_max", "ave__mean", "ena_min", "ave00mean", "ena_metadata", "ave_max", "ave00group", "ave2normal", "ave2mean", "vae_mean", "aveLEmetadata", "ome_normal", "ave2sum", "ave67summary", "vae_sav", "ave_sav", "erve_mean", "vae_summary", "ena00min", "ena_mean", "ena_group", "ave__made", "ave__max", "ena00metadata", "vae_normal", "ave67mean", "ome2an", "ave_mode", "ome_mean", "erve_sum", "ave__sum", "ave_____mode", "av_mean", "ave42mean", "avematnormal", "ave_____mean", "ave_____sem"], "i": [" m", "id", "u", "ai", "status", "I", "li", "ei", "go", " I", " di", "p", "o", " li", " k", "ui", "iter", "m", " pi", "ki", "ti", " multi", "ic", " si", "cli", " ti", "mi", "in", "is", "us", "j", "index", "ix", "im", "y", "t", "ci", "iu", "phi", "v", "info", " j", "xi", "e", "multi", "qi", "gu", "h", "gi", "di", " index", "bi", "pi", "si", "it", "z", "ini", " ii", " bi", "hi", " ni", " iter", "ii"], "rem": ["num", "extra", "io", "prom", "rip", "em", "rec", "resp", "fine", "hist", "chrom", "Rem", "mem", "pres", "mi", "im", "br", "REM", "remote", "pol", "re", "cm", "temp", "res", "rm", "comm", "rom"], "rem_bits": ["rem__bits", " rem_bs", "rem__", "rem_0", "rem__ins", " rem_ins", "rem__bs", "rem2bs", " rem_bit", "rem2bits", " rem_0", "rem__bit", "rem_ins", " rem__", "rem_bit", "rem_bs", "rem2bit", "rem2ins"], "residue": ["resvidUE", "reshidue", "residues", "rsidentues", "ResidUE", "rsidentUE", "resinUE", "rsiduer", "residUE", "Resinues", "rsidentue", "reshiduer", "resvidues", "resoliduer", "Residue", "resinue", "residentues", "residentue", "reshidues", "ResinUE", "resolidues", "resinuer", "residentuer", "resolidUE", "residuer", "Residues", "reshidUE", "resviduer", "rsidues", "resvidue", "Resinue", "rsidue", "resolidue", "rsidUE", "residentUE", "rsidentuer", "resinues", "Resinuer", "Residuer"], "quo": ["queso", "aquota", "queo", "quesos", "quota", "aquoin", "aquot", "aqupo", "quoo", "quoin", "qpo", "qoin", "quesota", "requo", " quoo", "sqo", "sqos", "qoo", "aquoo", "squoo", "squoin", "aquos", "requao", "queoo", "squos", "quos", "qupo", "queota", "requot", "requoo", "quao", "qo", "queao", "sqot", " quao", "tyo", " quot", "tyota", "quesot", "quepo", "quot", "queot", "aquo", "queos", "sqota", "qos", "typo", "squo", " quota", "tyoo", " qupo"]}}
{"project": "FFmpeg", "commit_id": "405af431040a57c630716b3940d7240021e8b80c", "target": 0, "func": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    CinAudioContext *cin = avctx->priv_data;\n\n    const uint8_t *src = buf;\n\n    int16_t *samples = data;\n\n    int delta;\n\n\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n\n\n    delta = cin->delta;\n\n    if (cin->initial_decode_frame) {\n\n        cin->initial_decode_frame = 0;\n\n        delta = (int16_t)AV_RL16(src); src += 2;\n\n        *samples++ = delta;\n\n        buf_size -= 2;\n\n    }\n\n    while (buf_size > 0) {\n\n        delta += cinaudio_delta16_table[*src++];\n\n        delta = av_clip_int16(delta);\n\n        *samples++ = delta;\n\n        --buf_size;\n\n    }\n\n    cin->delta = delta;\n\n\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n\n\n    return src - buf;\n\n}\n", "idx": 12099, "substitutes": {"avctx": ["Avcontext", "apcontext", " avcontext", "vrcmp", "avconn", "aftx", "Avconn", "afctx", "apconn", "vrtx", "avcontext", "vrctx", "Avctx", " avcmp", "Avtx", " avconn", "afcmp", "afcontext", "avcmp", "vrcontext", "aptx", "avtx", " avtx", "apctx"], "data": ["output", "len", "Data", "empty", "buffer", "text", "message", "a", "read", "padding", "image", "to", "area", "stream", "p", "value", "audio", "dev", "bin", "frame", "pad", "error", "d", "media", " DATA", "block", "pos", "ata", "bits", "zero", "length", "raw", "window", "bytes", "mu", "addr", "r", "video", "content", "done", "n", "t", "feed", "cache", "input", "results", "dat", "ns", "str", "start", "table", "batch", "DATA", "s", "name", "offset", "size", "items"], "data_size": ["dataCTlength", "buf_Size", "dataCTsent", "dataCTSize", "dataCTsize", "buf_range", "data_length", "data_range", " data_range", "data_Size", " data_sent", " data_Size", " data_SIZE", "data_sent", "data_SIZE", " data_length", "data_type", "buf_type"], "avpkt": ["avcpkt", "avpacket", "afPkt", "avparkt", "avcpct", "afPwp", "afPct", " avpth", "wavppdu", "avppst", "avwpkt", "afpkt", "avcpka", "avcpst", "afpwp", "avppth", " avcpth", "avPacket", "avpka", " avcpacket", "wavpkt", "avppka", "avppdu", "avPkt", "afpacket", "wavpdu", "avpdu", "avppacket", "avwpnt", "avparacket", "avcpacket", "avPwp", "avcpth", "avwpdu", "avppnt", "avpnt", "afPacket", " avcpka", "wavppnt", "avpwp", "avcpdu", "avparct", "avpatka", "avpct", "avcpwp", " avpacket", "avparwp", "wavppkt", "avcpnt", " avpka", "wavppst", "avpst", "avpatacket", "avpatth", "avwpst", " avcpkt", "afpct", "wavpst", "avppkt", "avPct", "avpth", "avpatkt", "wavpnt"], "buf": ["output", "len", "map", "xff", "config", "buffer", "uf", "rb", "ff", "alloc", "uv", "p", "bin", "bc", "vec", "late", "block", "pkg", "ref", "pos", "cur", "cb", "ptr", "bytes", "txt", "queue", "mem", "br", "dest", "box", "pb", "cap", "ctx", "rc", "cache", "b", "tmp", "cmd", "bh", "orig", "dat", "Buff", "batch", "context", "buff", "msg", "cv", "loc", "img", "wb"], "src": ["proc", "rec", "uv", "func", "attr", "ins", "ser", "rl", "scan", "ipl", "ost", "sr", "slice", "size", "inner", "filename", "source", "ind", "iter", "rob", "ptr", "txt", "usr", "rel", "comp", "sta", "sc", "syn", "img", "obj", "sl", "url", "xff", "buffer", "rs", "stream", "sub", "trans", "cur", "pos", "ref", "raw", "in", "ctx", "nr", "tmp", "offset", "start", "s", "iv", "loc", "len", "obs", "num", "sync", "seek", "bin", "cb", "bytes", "addr", "sid", "dest", "rc", "self", "input", "shape", "ctr", "sn", "st", "stat", "inst", "length", "sys"], "samples": ["sdents", "Sples", "tamples", "Sources", "Samples", " sples", "sdems", "samps", "sources", "namples", "tamps", "damps", "tents", "nents", "Samps", " sents", "filesples", " samps", "filesamples", "namps", "dounds", "sents", "nounds", "Sems", "sems", "sounds", "sdamples", "tources", "dems", "filesamps", "Sounds", "dents", "sples", "sdamps", "filesents", "Sents", "dources", "damples"], "delta": ["dielt", " distant", "detime", "Delta", " dDelta", "idynamic", " dynamic", "melt", "sdota", "lelt", "dant", "DDelta", " detime", "felta", "dielta", "sota", "drota", " diff", "edota", "adota", "idota", "Delt", "sdynamic", "dummy", "idelta", "drelta", "adant", "relta", "sdelt", "mynamic", "dota", "dDelta", "adDelta", "dporal", "ristant", "rota", "mummy", "diota", "metime", "edummy", "lelta", "selt", "lummy", "diporal", "fata", "mata", "sistant", "Dota", "fota", "mporal", "lant", "felt", "selta", "sdant", " dummy", "drynamic", "retime", "edelta", "diff", "edelt", "sant", "adelt", "mota", " dota", "lota", "delt", "distant", "sdiff", "melta", "idelt", " delt", "Dant", "sporal", "sdummy", "relt", "driff", "sdelta", "adelta", "dynamic"], "buf_size": ["queue_size", "queue_offset", "bufixoffset", " buf_shift", " buf2SIZE", "buf2shift", "buf_empty", "window_scale", " buf2shift", "buff_Size", "buff_scale", "buf_offset", "buf2to", " buf_len", " buf_to", " buf2to", " buf2size", "buf_index", "buf_scale", "buf_min", "queue_SIZE", "buf_len", "buf2size", "bufixempty", "window_size", "queue_empty", "buf_ize", "window_index", "window_ize", "buf_Size", "bufixSIZE", "buf_SIZE", "buf_shift", " buf_SIZE", "queue_sized", "buff_min", "buf2SIZE", "buf_to", "buff_size", "bufixsize", "buf_sized", "queue_scale"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j, k;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[0];\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + 2]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[0][0];\n\n    my += r->dmv[0][1];\n\n    for(j = 0; j < 2; j++){\n\n        for(i = 0; i < 2; i++){\n\n            for(k = 0; k < 2; k++){\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 12106, "substitutes": {"r": ["kr", "tr", "hr", "resource", "rb", "rs", "q", "err", "p", "rf", "o", "f", "d", "rw", "gr", "g", "this", "m", "l", "ra", "mr", "rr", "br", "n", "t", "rc", "rd", "v", "nr", "e", "b", "c", "h", "rt", "re", "sr", "w", "res", "er", "result", "ur", "vr", "R", "rar", "ar", "dr"], "block_type": ["block_name", "byte_name", "block8size", "block_id", "block8type", "block2size", "block2name", "block8id", "block8name", "block_size", "block2id", "block2type", "byte_id", "byte_type", "byte_size"], "dir": ["DIR", "depth", "orient", " d", "path", "ind", "d", "direct", "desc", "dy", "dep", "bound", "ir", "cond", "box", "directory", "direction", "deg", "rect", "dim", "lock", "Dir", "di", "coord", "rad", "db", "angle", " direction"], "s": ["ms", "vs", "ats", "hs", "d", "cs", "m", "ins", "session", "http", "se", "y", "t", "sports", "os", "b", "times", "w", "sr", "sd", "ims", "ar", "status", "source", "settings", "sp", "gs", "sts", "ex", "g", "sv", "ses", "xs", "als", "js", "less", "ss", "conf", "ops", "sb", "sc", "ls", "sq", "obj", "spec", "sl", "a", "rs", "as", "sm", "f", "l", "es", "ts", "n", "sw", "sh", "ns", "er", "single", "space", "ds", "p", "an", "ps", "south", "is", "S", "its", "series", "ssl", "v", "self", "https", "c", "h", "stats", "fs", "st", "sys"], "A": ["ACT", "AS", "I", "a", "K", "Answer", "AH", "Ass", "Area", "If", "NA", "And", "U", "AU", "CA", "ALL", "HA", "AM", "AN", "AT", "AF", "AP", "Alpha", "Args", "Both", "G", "Av", "SA", "GA", "S", "N", "Array", "ACE", "Ar", " a", "P", "All", "Al", "O", "UA", "V", "An", "AL", "LA", "ACC", "M", "Java", "API", "AA", "F", "JA", "Bar", "As", "AR", "AC", "AV", "T", "App", "EA", "At", "Others", "R", "L", "Abs", "AB", "BA"], "B": ["FB", "CB", "J", "I", "BF", "Bern", "BE", "Q", "BM", "Bs", "WB", "GB", "Big", "NB", "DB", "Buffer", "BS", "IB", "Builder", "Other", "Both", "Box", "BR", "D", "RB", "Be", "Block", "BC", "LIB", "OB", "BY", "Blue", "S", "N", "P", "BB", "Body", "Y", "V", "TB", "b", "BG", "M", "BI", "F", "Bar", "Chain", "Z", "PB", "Bytes", "T", "BER", "R", "VB", "BL", "L", "LB", "AB", "BA"], "C": ["Ch", "CNN", "CG", "CW", "H", "CB", "Cs", "Cache", "I", "K", "Q", "JC", "CT", "DC", "Code", "CM", "CS", "CON", "Co", "CD", "CA", "CN", "X", "G", "D", "CP", "BC", "S", "N", "CE", "Cat", "SC", "P", "Count", "Y", "V", "E", "Con", "c", "CL", "M", "CU", "F", "Chain", "Z", "AC", "Config", "T", "CR", "Cl", "R", "L", "CC", "Car", "EC"], "i": ["ai", "I", "a", "li", "p", "o", "f", "m", "l", "ic", "ia", "mi", "ir", "iu", "ci", "v", "ik", "e", "h", "bi", "ij", "iy", "si", "it", "x", "ii"], "j": ["aj", "ja", "jump", "J", "jc", "q", "p", "o", "ii", "g", "jp", "l", "m", "jj", "uj", "n", "y", "v", "b", "c", "z", "dj", "ji", "kj", "ij"], "k": ["kr", "key", "ck", "kg", "ko", "u", "K", "q", "tk", "ak", "p", "o", "m", "ka", "n", "v", "ik", "mk", "ke", "kh", "kw", "z", "km", "ek", "kj", "sk", "kk"], "mx": ["ms", "ml", "MX", "xp", "kg", "xy", "nm", "mm", "nz", "ex", "xc", "dx", "mn", "mal", "xs", "mu", "mi", "ma", "px", "mk", "xi", "yp", "xx", "zx", "yx", "km", " xx", "ll", "sk"], "my": ["ms", "ml", "py", "mb", "nm", "me", "mm", "gm", "yy", "mis", "bm", "mr", "mn", "ky", "mi", "md", "pm", "ma", "mc", "yo", "mk", "mid", "gy", "mp", "ny", "vm", "mt"]}}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "int qemu_paio_init(struct qemu_paioinit *aioinit)\n\n{\n\n    int ret;\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret) die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret) die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    TAILQ_INIT(&request_list);\n\n\n\n    return 0;\n\n}\n", "idx": 12111, "substitutes": {"aioinit": ["aIOerr", " aioInit", "aioerr", "aioserr", "aioInit", "aIOInit", " aioerr", " aIOerr", " aIOInit", "aiosInit", " aIOinit", "aIOinit", "aiosinit"], "ret": ["arr", "len", "tr", "lt", "reset", " RET", "net", "Alt", "pas", "et", "nl", "back", "leg", "err", "print", "det", "RET", "reply", "nt", "iter", "ld", " terr", "cat", "del", " Ret", "mt", "def", "desc", " alt", "txt", "usr", "alt", "ter", "dt", "ext", "cont", "try", "t", "rem", "rets", "reg", "deg", "backed", "not", "val", "Ret", "nat", "cmd", "eth", "rt", "re", "elt", "res", "vet", "cert", "it", "att", "rm", "gt", "full", "get", "result", "ll", " fut", "ft", "out"]}}
{"project": "qemu", "commit_id": "2c80e42395bfe0bf291c082f9399431e1ff9d758", "target": 0, "func": "dprint(int level, const char *fmt, ...)\n\n{\n\n    va_list args;\n\n\n\n    if (level <= debug) {\n\n        va_start(args, fmt);\n\n        vfprintf(stderr, fmt, args);\n\n        va_end(args);\n\n    }\n\n}\n", "idx": 12130, "substitutes": {"level": ["col", "key", "display", "pe", "priority", "code", "lvl", "message", "where", "format", "Level", "print", "enc", "role", "goal", "fail", "VEL", "l", "vel", "type", "local", "high", "family", "rel", "stage", " lvl", "coll", "mode", "levels", "v", "action", "scale", "tag", "color", "set", "ale", "co", "debug", "console", "cost", "le", "loc", "state", "style"], "args": ["arr", "aps", "vs", "qs", "igs", "names", "ars", "rs", "keys", "types", "tests", "func", "gs", "ants", "atts", "lines", "items", "ables", "files", "points", "bits", "values", "ins", "xs", "terms", "Args", "aws", "ts", "rows", "ids", " arguments", "__", "ags", "fields", "ics", "ads", "limits", "caps", "cmd", "results", "str", "flags", "w", "ns", "options", "vals", "actions", "uments", "ls", "s", "ims", "ds", "arg", "params", "parts"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n", "idx": 12133, "substitutes": {"hotplug_dev": ["hotplug_buf", "hotplugPev", "hotpl_ev", "hotpl_buf", "hotplugPdev", "hotplug_ev", "hotplugPbuf", "hotplugPdef", "hotplug2ev", "hotplug2dev", "hotpl_dev", "hotplug_def", "hotpl_def", "hotplug2buf", "hotplug2def"], "dev": ["doc", "obj", "dd", "spec", "development", "priv", "ch", "av", "device", "cam", "err", "ev", "home", "ve", "buf", "adv", "d", "eng", "def", "dis", "ver", "pub", "mem", "develop", "de", "data", "dem", "DEV", "conn", "conf", "v", "info", "gu", "env", "tech", "val", "Dev", "der", "cmd", "Device", "des", "hw", "w", "driver", "debug", "pro", "state", "out"], "errp": ["errr", "errP", "rP", "rps", " errps", "errps", "rp", "err", "rr", "erP", " errr", "erps", " errP", "erp"], "pci_dev": ["pudi_dev", "pudi_device", "pudietycache", "pci_ev", "pci_def", "pudi_cache", "pcci_develop", "pcietycache", "pcipdev", "pci___def", "pci___ev", "pcipdec", "pudietydev", "pcu_ev", "pcietydevice", "pci_cache", "pci_Dev", "pci_dec", "pcipev", "pki_dec", "pcipadv", "pci___develop", "pudietydevice", "pcci_dev", "pci_adv", "pcietydev", "pci_device", "pci_develop", "pci___dev", "pki_adv", "pcu_device", "pcu_Dev", "pki_ev", "pcci_def", "pcci_ev", "pki_dev", "pcu_dev"], "pbdev": ["xbdef", "ebbus", "bpdiv", "ppdev", "erbdevice", "pkgdef", "pcbuf", "bufdev", "pkggo", "PBdes", "tpvar", "pbcache", "bpdes", "PBev", "pbsys", "pcdevelop", "cbver", "lbdev", "lbdevice", "pbdevice", "jpdevice", "pcdev", "jpev", "pbdet", "ebdev", "fbdev", "pbrent", "pcdet", "bpsys", "pbdevelop", "sbdev", "pgver", "pbdiv", "pcbuild", "bufdevice", "pxdet", "erbdev", "ebev", "PBvar", "PBver", "bppriv", "pcgo", "pcdevice", "pcver", "pgdevice", "pbDev", "lbcache", "pkgdevice", "pgDEV", "bpdevice", "fbvar", "tpver", "cbDev", "pbbuf", "bufDev", "xbgo", "xbdev", "fbver", "sbev", "pgbuf", "pbpriv", "xbdes", "jpdev", "pcrent", "tfdevice", "ppsys", "pbval", "pbdef", "bpev", "pbbus", "tfdef", "pbver", "cbdevice", "PBpriv", "pgval", "ebdevice", "erbdes", "pbev", "pbdesc", "pkgdev", "pcval", "sbdevice", "xbbuild", "rbev", "pxdevice", "tpdevice", "pbDEV", "lpbus", "lpdevice", "pbgo", "PBdev", "pkgdet", "fbdevice", "jpbus", "xbsys", "tpdev", "bufev", "PBdiv", "tfdevelop", "cbev", "lpev", "rbdev", "pbbuild", "pkgbuf", "erbev", "pgrent", "lbpriv", "rbdes", "pkgbuild", "ppdes", "pxval", "PBdevice", "rbdevice", "ppdesc", "tfdev", "bpdev", "pgdev", "sbdiv", "rbDev", "pcdef", "PBcache", "pkgval", "lpdev", "cbrent", "pkgDEV", "cbdef", "pcDEV", "bpcache", "bpdesc", "cbdev", "pxdev", "pbdes", "pbvar", "cbdevelop", "xbdesc"], "s": ["sq", "socket", "rs", "hs", "p", "gs", "sts", "f", "ps", "south", "g", "m", "sv", "i", "sam", "bs", "r", "is", "js", "j", "S", "ss", "ts", "n", "t", "ssl", "v", "sb", "b", "c", "h", "ns", "w", "fs", "set", "sis", "ls", "ds"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12134, "substitutes": {"opaque": ["iperatibility", "iperaque", "Opaque", "opulse", "opient", "oplaque", "opatile", "opsacity", "iperient", " opatibility", "opsulse", "Opient", " opatile", "Opatile", "opsaque", "iopacity", "Opatibility", "oplacity", "opatibility", "iperatile", "oplais", "oplulse", "opsais", "iopulse", "opais", "iopaque", " opient", "iopais", "opacity"], "addr": ["align", "arr", "work", "len", "src", "shift", "obj", "id", "tx", "net", "address", "map", "cmp", "pat", "at", "add", "Address", "a", "order", "rs", "err", "ack", "hash", " address", "pad", "act", "hop", "pkg", "pos", "ref", "gate", "rn", "hl", "ptr", "urg", "adr", "usr", "ord", "mem", "index", "r", "row", "handle", "data", "ix", "ad", "now", "ctx", "sha", "reg", "cmd", "str", "hw", "res", "tag", "x", "coord", "msg", "dh", "name", "loc", "offset", "state", "dr", "mt"], "size": ["align", "shift", "len", "password", "id", "address", "sum", "code", "message", "Size", "SIZE", "type", "desc", "ize", "mem", "data", "n", "cap", "mode", "count", "c", "start", "z", "msg", "name", "offset", "length"], "s": ["ms", "sq", "a", "rs", "hs", "p", "gs", "o", "f", "ps", "d", "g", "m", "l", "es", "ses", "xs", "r", "pers", "js", "j", "S", "ss", "ts", "n", "t", "v", "conf", "ops", "os", "sb", "b", "c", "h", "ns", "w", "fs"]}}
{"project": "qemu", "commit_id": "c471ad0e9bd46ca5f5c9c796e727230e043a091d", "target": 0, "func": "static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i, j;\n\n    int r = 0;\n\n    const char *part_name[] = {\n\n        \"descriptor table\",\n\n        \"available ring\",\n\n        \"used ring\"\n\n    };\n\n\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n\n\n        j = 0;\n\n        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,\n\n                                           vq->desc_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,\n\n                                           vq->avail_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,\n\n                                           vq->used_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (r == -ENOMEM) {\n\n        error_report(\"Unable to map %s for ring %d\", part_name[j], i);\n\n    } else if (r == -EBUSY) {\n\n        error_report(\"%s relocated for ring %d\", part_name[j], i);\n\n    }\n\n    return r;\n\n}\n", "idx": 12142, "substitutes": {"dev": ["usb", "dd", "development", "device", "cam", "go", "ev", "devices", "ve", " Dev", "adv", "pad", "nt", "d", " device", "def", "local", "serial", "ver", "mem", "develop", "de", "data", "test", "ad", "phy", "scan", "ac", "dem", "DEV", "conn", "v", "info", "unknown", "gu", "tech", "host", "Dev", "cmd", "exec", "Device", "des", "hw", "w", "driver", "att", "debug", "app", "disk", "sd", "pro"], "start_addr": [" start_mt", "start__phys", " start_adr", " start_pos", "starting_addr", "start_address", "start___adr", "starting_ptr", "start___address", "starting_address", "startLphys", "starting_adr", "start_phys", " start_ptr", "start_hop", "start___tick", "start___addr", "start_mt", "start_ptr", "startLpos", "starting_tick", "start_tick", "start__addr", "start_adr", "start_pos", " start_phys", "start__pos", "startLaddr", "starting_hop"], "size": ["len", "empty", "small", "send", "sum", "network", "message", "resolution", "format", "range", "sp", "height", "unit", "Size", "SIZE", "capacity", "ize", "mem", "storage", "share", "body", "mode", "count", "iz", "shape", "dim", "c", "scale", "fee", "si", "pi", "z", "s", "max", "name", "space", "length"], "i": ["ami", "id", "u", "ai", "fi", "I", "me", "ie", "li", "q", "yi", "iq", "ri", "p", "o", "sim", "ind", "ui", "ip", "g", "m", "l", "ti", "ic", "in", "mi", "r", "index", "im", "ix", "ir", "n", "y", "t", "ci", "iu", "zi", "v", "phi", "xi", "e", "multi", "qi", "c", "h", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "z", "ini", "hi", "ji", "ii"], "j": ["jac", "je", "obj", "next", "aj", "ja", "jump", "J", "jc", "q", "err", "ct", "k", "p", "job", "o", "ind", "d", "Ja", "g", "jp", "m", "l", "note", "ret", "json", "jj", "r", "index", "js", "uj", "br", "row", "n", "y", "try", "t", "state", "jl", "v", "fr", "pr", "b", "c", "h", "bi", "adj", "res", "it", "x", "z", "dj", "ji", "kj", "out", "ij"], "part_name": ["part_names", "part_no", " part_info", "partxname", " part_no", "part_data", "part9nam", "part_id", "part_nam", "part9name", " part_nam", "part9names", "partxnames", "partxdata", "part_info", "part9data", "part_dict", " part_dict", "partxnam", " part_id", " part_data", " part_names"], "vq": ["vqa", " vdq", "vue", "vmquant", " vquant", " vrequ", " vqt", "verrequ", "veq", "vccal", "vmqt", "vcq", "vvquery", " vue", "fdq", "vvdq", " vquery", "fqu", "nvpl", "varcal", "vcqt", "vdq", "vrquery", " vcomm", "vardq", "vvcal", "vcrequ", "vrqs", "vquest", "vvcomm", "voq", "varq", "nvqs", "invclient", "varkg", "vvqs", "vpl", "vmrequ", "voqs", "vclient", "nvq", "avpl", " vquest", "varqa", "vqu", "tvqu", "varue", "vqs", "vocharge", "tvqs", "veqs", "vquant", "avkg", "varquant", "avqs", "verdq", "vcquant", "vvcharge", "vrcharge", "vcomm", "vcharge", "fqs", "nvkg", "tvq", "varquest", "varcomm", " vqa", "vcquest", "invue", "tvcharge", "vcal", "vvq", "verquest", "invq", "invquest", "avqt", " vcharge", "vedq", "vkg", "vqt", "avqa", " vclient", "fq", "vmq", "voqu", " vqu", "varqt", " vkg", "verq", "varclient", " vpl", "vquery", "vcdq", " vqs", "vvquant", "vrequ", "vequ", "avq", "vrq"]}}
{"project": "qemu", "commit_id": "3435f39513a104294b5e3bbf3612047028d25cfc", "target": 0, "func": "void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n\n{\n\n    RAMBlock *block;\n\n    ram_addr_t offset;\n\n    int flags;\n\n    void *area, *vaddr;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = addr - block->offset;\n\n        if (offset < block->length) {\n\n            vaddr = block->host + offset;\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (xen_enabled()) {\n\n                abort();\n\n            } else {\n\n                flags = MAP_FIXED;\n\n                munmap(vaddr, length);\n\n                if (mem_path) {\n\n#if defined(__linux__) && !defined(TARGET_S390X)\n\n                    if (block->fd) {\n\n#ifdef MAP_POPULATE\n\n                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :\n\n                            MAP_PRIVATE;\n\n#else\n\n                        flags |= MAP_PRIVATE;\n\n#endif\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, block->fd, offset);\n\n                    } else {\n\n                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, -1, 0);\n\n                    }\n\n#else\n\n                    abort();\n\n#endif\n\n                } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                    flags |= MAP_SHARED | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                flags, -1, 0);\n\n#else\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                flags, -1, 0);\n\n#endif\n\n                }\n\n                if (area != vaddr) {\n\n                    fprintf(stderr, \"Could not remap addr: \"\n\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n\n                            length, addr);\n\n                    exit(1);\n\n                }\n\n                memory_try_enable_merging(vaddr, length);\n\n                qemu_ram_setup_dump(vaddr, length);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 12145, "substitutes": {"addr": ["align", "len", "art", "obj", "id", "off", "address", "map", "nl", "prefix", "add", "pointer", "Address", "base", "order", "a", "err", "alloc", "hash", "var", "point", " address", "error", "pad", "act", "location", "ip", "pos", "ref", "attr", "ptr", "arch", "i", "adr", "row", "owner", "arity", "action", "host", "eth", "start", "alias", "oad", "coord", "max", "name", "loc", "size", "dr"], "length": ["section", "duration", "format", "end", "location", "oh", "family", "amount", "row", "data", "enabled", "size", "frequency", "address", "path", "message", "height", "capacity", "limit", "lon", "ptr", "loop", "Length", "count", "ob", "square", "time", "required", "number", "available", "form", "maximum", "volume", "SIZE", "l", "type", "sequence", "ength", "mask", "index", "last", "line", "host", "angle", "len", "vector", "lib", "enth", "padding", "idth", "join", "build", "position", "port", "level", "total", "ENGTH", "shape", "lock", "present", "h", "full", "max"], "block": ["work", "obj", "tx", "sync", "address", "map", "record", "part", "buffer", "prefix", "blocks", "network", "base", "device", "q", "image", "list", "range", "k", "p", "point", "bl", "hash", "buf", "profile", "frame", "number", "ram", "ip", "instance", "label", "ref", "type", "def", "object", "zero", "word", "model", "mask", "mem", "bit", "Block", "chain", "row", "snap", "attribute", "header", "box", "check", "info", "bo", "mark", "line", "b", "lock", "link", "space", "set", "group", "pack", "no", "BL", "byte", "size", "store"], "offset": ["align", "key", "shift", "len", "next", "frequency", "off", "entry", "id", "address", "et", "prefix", "buffer", "pointer", "padding", "base", "order", "flag", "end", "seek", "alloc", "sp", "point", "iso", "o", "height", "error", "pad", "slot", "size", "location", "ano", "pos", "lon", "type", "inter", "position", "ptr", "port", "mask", "index", "amount", "aff", "row", "owner", "total", "count", "Offset", "ace", "origin", "start", "alias", "coord", "set", "angle", "loc"], "flags": ["ms", "marks", "ats", "rights", "weights", "func", "ensions", "bits", "heads", "values", "fps", "details", "fields", "options", "items", "ports", "aps", "acts", "status", "units", "frames", "settings", "types", "weight", "atts", "FLAG", "args", "utils", "cond", "generation", "packages", "grades", "ops", "limits", "alities", "finals", "faces", "features", "states", "tools", "state", "params", " Flags", "Flags", "locks", "errors", "goal", "lands", "ants", "words", "lines", "points", "terms", "mask", "ts", "links", "styles", "ags", "levels", "tags", "properties", "s", "ments", "amps", "comments", "alf", "fd", "flag", "offs", "quality", "posts", "lag", "acl", "stats", "fs", "actions", "lights", "missions", "parts"], "area": ["page", "era", "array", "off", "address", "map", " areas", "va", "a", "section", "prefix", "format", "order", "average", "buffer", "region", "Area", "range", "alloc", "meta", " address", "iso", "rep", "au", "buf", "pad", "volume", "instance", "location", "ra", "ata", "balance", "rea", "window", "ka", "mask", "qa", "function", "storage", "ta", "description", "alpha", "ma", "total", "mode", "zone", "ha", "acl", "metadata", "action", "division", "definition", "alias", "foo", "usage", "memory", "bar", "aa", "access", "rage", "are", "space", "angle"], "vaddr": ["avarg", "varadr", "vdr", "avhost", "qvcoord", " vadr", "svarea", "wptr", "avaddr", "qvaddr", "voffset", " vrt", "waddress", "larea", " vstore", "vmmod", "avint", "vmhost", "svhost", "vmdb", "rdr", "rstore", "Vadd", "waddr", "avrt", "vmaddress", "vmod", "vmaddr", " vadd", "varadd", " vdr", " varg", "svcoord", "hint", "uvoffset", "vtarg", "svoffset", "svadr", "vdb", "svaddress", "svadd", "vadr", "vptr", "vararea", "vstore", "vrstore", "hptr", " vint", "valloc", "svaddr", "vrt", "vmrt", " vaddress", "vraddr", " vmod", " vdb", "vroffset", "uvcoord", "vadd", "vtint", "vthost", "haddress", "varg", "qvoffset", "varaddr", " vhost", "vhost", "vrdr", "ladd", "avalloc", "roffset", "avadd", "haddr", "wadr", "avdb", "uvaddr", "vint", " valloc", "avmod", "wdr", "Vhost", "hadr", "svalloc", "wint", "vtaddr", " voffset", "vcoord", "laddr", "varea", "raddr", "hdr", "ladr", "Vaddress", "vaddress", "vmadd", "uvaddress", "qvaddress", "Vaddr", " vptr"]}}
{"project": "qemu", "commit_id": "8f5d58ef2c92d7b82d9a6eeefd7c8854a183ba4a", "target": 1, "func": "const char *object_get_typename(Object *obj)\n\n{\n\n    return obj->class->type->name;\n\n}\n", "idx": 12182, "substitutes": {"obj": ["src", "obs", "xy", "typ", "sky", "nm", "ctrl", "Obj", "rb", "req", "tk", "o", "od", "ind", "nt", "act", "this", "instance", "cur", "ref", "object", "obo", "attr", "parent", "objects", "txt", "expr", "js", "j", "data", "ctx", "self", "pot", "tmp", "cmd", "bh", "og", "elt", "any", "po", "oj", "ob", "onet", "inst", "ht", "sys"]}}
{"project": "FFmpeg", "commit_id": "1846a3eac854799fbffc9669dcf4de558b917957", "target": 0, "func": "static int vaapi_build_decoder_config(VAAPIDecoderContext *ctx,\n\n                                      AVCodecContext *avctx,\n\n                                      int fallback_allowed)\n\n{\n\n    AVVAAPIDeviceContext *hwctx = ctx->device->hwctx;\n\n    AVVAAPIHWConfig *hwconfig = NULL;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    VAStatus vas;\n\n    int err, i, j;\n\n    int loglevel = fallback_allowed ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    const AVCodecDescriptor *codec_desc;\n\n    const AVPixFmtDescriptor *pix_desc;\n\n    enum AVPixelFormat pix_fmt;\n\n    VAProfile profile, *profile_list = NULL;\n\n    int profile_count, exact_match, alt_profile;\n\n\n\n    codec_desc = avcodec_descriptor_get(avctx->codec_id);\n\n    if (!codec_desc) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    profile_count = vaMaxNumProfiles(hwctx->display);\n\n    profile_list = av_malloc(profile_count * sizeof(VAProfile));\n\n    if (!profile_list) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaQueryConfigProfiles(hwctx->display,\n\n                                profile_list, &profile_count);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, loglevel, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    profile = VAProfileNone;\n\n    exact_match = 0;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vaapi_profile_map); i++) {\n\n        int profile_match = 0;\n\n        if (avctx->codec_id != vaapi_profile_map[i].codec_id)\n\n            continue;\n\n        if (avctx->profile == vaapi_profile_map[i].codec_profile)\n\n            profile_match = 1;\n\n        profile = vaapi_profile_map[i].va_profile;\n\n        for (j = 0; j < profile_count; j++) {\n\n            if (profile == profile_list[j]) {\n\n                exact_match = profile_match;\n\n                break;\n\n            }\n\n        }\n\n        if (j < profile_count) {\n\n            if (exact_match)\n\n                break;\n\n            alt_profile = vaapi_profile_map[i].codec_profile;\n\n        }\n\n    }\n\n    av_freep(&profile_list);\n\n\n\n    if (profile == VAProfileNone) {\n\n        av_log(ctx, loglevel, \"No VAAPI support for codec %s.\\n\",\n\n               codec_desc->name);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    if (!exact_match) {\n\n        if (fallback_allowed || !hwaccel_lax_profile_check) {\n\n            av_log(ctx, loglevel, \"No VAAPI support for codec %s \"\n\n                   \"profile %d.\\n\", codec_desc->name, avctx->profile);\n\n            if (!fallback_allowed) {\n\n                av_log(ctx, AV_LOG_WARNING, \"If you want attempt decoding \"\n\n                       \"anyway with a possibly-incompatible profile, add \"\n\n                       \"the option -hwaccel_lax_profile_check.\\n\");\n\n            }\n\n            err = AVERROR(EINVAL);\n\n            goto fail;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"No VAAPI support for codec %s \"\n\n                   \"profile %d: trying instead with profile %d.\\n\",\n\n                   codec_desc->name, avctx->profile, alt_profile);\n\n            av_log(ctx, AV_LOG_WARNING, \"This may fail or give \"\n\n                   \"incorrect results, depending on your hardware.\\n\");\n\n        }\n\n    }\n\n\n\n    ctx->va_profile = profile;\n\n    ctx->va_entrypoint = VAEntrypointVLD;\n\n\n\n    vas = vaCreateConfig(hwctx->display, ctx->va_profile,\n\n                         ctx->va_entrypoint, 0, 0, &ctx->va_config);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to create decode pipeline \"\n\n               \"configuration: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        err = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    hwconfig = av_hwdevice_hwconfig_alloc(ctx->device_ref);\n\n    if (!hwconfig) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    hwconfig->config_id = ctx->va_config;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->device_ref,\n\n                                                      hwconfig);\n\n    if (!constraints)\n\n        goto fail;\n\n\n\n    // Decide on the decoder target format.\n\n    // If the user specified something with -hwaccel_output_format then\n\n    // try to use that to minimise conversions later.\n\n    ctx->decode_format = AV_PIX_FMT_NONE;\n\n    if (ctx->output_format != AV_PIX_FMT_NONE &&\n\n        ctx->output_format != AV_PIX_FMT_VAAPI) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            if (constraints->valid_sw_formats[i] == ctx->decode_format) {\n\n                ctx->decode_format = ctx->output_format;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (output \"\n\n                       \"format).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise, we would like to try to choose something which matches the\n\n    // decoder output, but there isn't enough information available here to\n\n    // do so.  Assume for now that we are always dealing with YUV 4:2:0, so\n\n    // pick a format which does that.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        for (i = 0; constraints->valid_sw_formats[i] != AV_PIX_FMT_NONE; i++) {\n\n            pix_fmt  = constraints->valid_sw_formats[i];\n\n            pix_desc = av_pix_fmt_desc_get(pix_fmt);\n\n            if (pix_desc->nb_components == 3 &&\n\n                pix_desc->log2_chroma_w == 1 &&\n\n                pix_desc->log2_chroma_h == 1) {\n\n                ctx->decode_format = pix_fmt;\n\n                av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (format \"\n\n                       \"matched).\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    // Otherwise pick the first in the list and hope for the best.\n\n    if (ctx->decode_format == AV_PIX_FMT_NONE) {\n\n        ctx->decode_format = constraints->valid_sw_formats[0];\n\n        av_log(ctx, AV_LOG_DEBUG, \"Using decode format %s (first in list).\\n\",\n\n               av_get_pix_fmt_name(ctx->decode_format));\n\n        if (i > 1) {\n\n            // There was a choice, and we picked randomly.  Warn the user\n\n            // that they might want to choose intelligently instead.\n\n            av_log(ctx, AV_LOG_WARNING, \"Using randomly chosen decode \"\n\n                   \"format %s.\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n        }\n\n    }\n\n\n\n    // Ensure the picture size is supported by the hardware.\n\n    ctx->decode_width  = avctx->coded_width;\n\n    ctx->decode_height = avctx->coded_height;\n\n    if (ctx->decode_width  < constraints->min_width  ||\n\n        ctx->decode_height < constraints->min_height ||\n\n        ctx->decode_width  > constraints->max_width  ||\n\n        ctx->decode_height >constraints->max_height) {\n\n        av_log(ctx, AV_LOG_ERROR, \"VAAPI hardware does not support image \"\n\n               \"size %dx%d (constraints: width %d-%d height %d-%d).\\n\",\n\n               ctx->decode_width, ctx->decode_height,\n\n               constraints->min_width,  constraints->max_width,\n\n               constraints->min_height, constraints->max_height);\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n\n\n    // Decide how many reference frames we need.  This might be doable more\n\n    // nicely based on the codec and input stream?\n\n    ctx->decode_surfaces = DEFAULT_SURFACES;\n\n    // For frame-threaded decoding, one additional surfaces is needed for\n\n    // each thread.\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n        ctx->decode_surfaces += avctx->thread_count;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n    vaDestroyConfig(hwctx->display, ctx->va_config);\n\n    av_freep(&profile_list);\n\n    return err;\n\n}\n", "idx": 12190, "substitutes": {"ctx": ["jac", "obj", "ck", "tx", "cmp", "pc", "con", "config", "crit", " cx", "req", "cam", "ct", "kt", "Context", "cp", "cf", "xc", "bc", "act", "dc", "jp", "tc", "np", "pkg", "vp", "cb", "cc", "txt", "mc", "cas", "conn", "rc", "cfg", "wcs", "setup", "cmd", "voc", "hw", "cm", "nc", "kw", "cu", "context", "comm", "cv", "conv"], "avctx": [" avctl", "hwcontext", "evctx", " avcontext", "ravcomp", "avctl", "avconn", "ravcontext", "evcontext", "hwconn", "hwctl", "ravctx", "evcomp", "vrtx", "svctx", "awtx", "awcontext", "avcontext", " avconfig", "vrctl", "vrctx", "camconfig", "hwtx", "svcontext", "avconfig", "hwcomp", "avcomp", "camctx", "camtx", "evtx", "ravtx", "svconn", "camcontext", "vrcontext", "vrconn", "awconfig", "avtx", " avtx", "svtx", "awctx"], "fallback_allowed": ["fallback_forced", "fallback2only", "fallBack_enabled", "fallBack_only", "fallBack_forced", "fallBack_defined", "fallback2forced", "fallback_defined", "fallback_only", "fallBack_allowed", "fallback_enabled", "fallback2allowed", "fallback2enabled"], "hwctx": ["nwpkg", "himcontext", "hwcontext", "fwcontext", "fwctx", "owctx", "fwtx", "iwcp", "fwcfg", "nwctx", "himcp", "hawctx", "iwconfig", "hwcp", "iwctx", "himctx", "iwcontext", "avcontext", "fwcp", "owconn", "iwconn", "htcfg", "hwpkg", "hawtx", "iwpkg", "hwtx", "himtx", "hwcfg", "iwtx", "iwcfg", "avconfig", "hawpkg", "nwtx", "owconfig", "htconfig", "owcfg", "fwconfig", "hawcp", "htctx", "avcfg", "nwcp", "hwconn", "htconn"], "hwconfig": ["fwconf", "htConfig", "hwconf", "htconfig", "hwcfg", "iwconfig", "fwconfig", "hwConfig", "iwcfg", "fwConfig", "htconf", "htcfg", "iwConfig", "iwconf", "fwcfg"], "constraints": ["constains", "contracts", "Constraint", "Constsains", "Constsaints", "constsaints", "Constracts", "Constsacts", "constacts", "Constrains", "constraint", "constaints", "constsacts", "Constraints", "contrains", "contraints", "constrains", "constsains", "constracts", "contraint", "constaint", "Constsaint", "constsaint"], "vas": ["vs", "na", "menu", "cam", "ras", "cs", "stack", "rea", "jpg", " dc", "wcs", "caps", "eu", " va", "camera", "result", "conv", "tx", "status", "ja", "va", "nexus", "buf", "sts", "ver", "bs", "ea", "qa", " coord", " os", " fs", "eas", "VA", "scale", "ows", "vid", "sc", " cs", "vals", "vers", "png", "pas", "nas", "css", "as", "area", "VS", " ov", "es", "vis", " vac", "ts", " vis", "can", "bridge", "auc", "cus", "base", " cac", " ec", "cf", " vers", "save", "us", "ega", "las", "pres", "jas", "cfg", "cache", "gc", "rus", "usa", " tv", "fs", " canvas", "res", "cu", " cursor", " stats"], "err": ["arr", "kr", "render", "obj", "inner", "Error", "order", "lr", "or", "req", "css", "resp", "ach", "buf", "error", "erer", "aaa", "gr", "iter", "attr", "rn", "gz", "mr", "rr", "usr", "cli", "Er", "r", "try", "test", "br", "y", "fg", "count", "conf", "nr", "fr", "cfg", "pr", "die", "der", "str", "elt", "oe", "fee", "er", "fer", "resh", "rank", "ner", "cr", "dr"], "i": ["ami", "id", "ai", "I", "me", "ie", "li", "init", "iq", "p", "ii", "sim", "ex", "ind", "ui", "ip", "instance", "l", "m", "my", "um", "ki", "ti", "ic", "ia", "in", "index", "mi", "chain", "try", "ir", "ix", "im", "y", "iu", "ci", "phi", "v", "zi", "info", "xi", "remote", "e", "multi", "c", "h", "gi", "eu", "di", "bi", "pi", "si", "it", "x", "ini", "hi", "ji", "ims", "ij"], "j": ["jump", "func", "ng", "o", "m", "y", "t", "fr", "pr", "b", "FIG", "ji", "key", "bj", "tr", "ja", "J", "jc", "jo", "job", "fail", "g", "jp", "jj", "try", "js", "jl", "e", "z", "att", "IF", "IA", "ev", "k", "jit", "l", "def", "index", "_", "uj", "n", "V", "oj", "it", "dj", "aj", "q", "IC", "p", "json", "us", "br", "v", "c", "x", "C", "kj", "ij"], "codec_desc": ["codec_des", "coddec_des", "codec_description", "coddec_set", "codoc_def", "codec_def", "codoc_spec", "codoc_des", "codec509cmp", "codecopdescription", "coddec_cmp", "codoc_description", "codoc_desc", "codecopdesc", "codec509desc", "codec_supp", "codec509des", "codec509set", "codec_spec", "coddec_desc", "codecopdef", "codec_cmp", "codecopdes", "codec_set", "codoc_supp"], "pix_desc": ["pfx_desc", "pix_des", "pfx_buf", "pix__des", "pfx_des", "pix_vec", "pix__buf", "pix_buf", "pix__vec", "pfx_vec", "pix__desc"], "pix_fmt": ["pix2Fdr", "pix_Ftm", "pix_sfmt", "pix_ftm", "pix_tmt", "pix_Flt", "pix_sfdr", "pix_sftm", "pix2fdr", "pix_Fmt", "pix_tdr", "pix_flt", "pix2ftm", "pix2Flt", "pix_ttm", "pix_fdr", "pix2flt", "pix2fmt", "pix2Ftm", "pix_Fdr", "pix_sflt", "pix_tlt", "pix2Fmt"], "profile": ["key", "depth", "ph", "spec", "status", "pe", "priority", "prof", "me", "policy", "username", "feature", "processor", "settings", "base", "image", "PRO", "device", "pse", "summary", "sample", "proc", "picture", "file", "prop", "person", "frame", "slot", "volume", "prototype", "component", "instance", "include", "type", "phone", "port", "relation", "filter", "family", "package", "property", "description", "header", "node", "pen", "menu", "tree", "buffer", "pr", "primary", "cache", "line", "fac", "properties", "h", "option", "plane", "po", "alias", "pi", "cpu", "table", "style", "result", "full", "usage", "gpu", "user", "module", "history", "pro", "Profile", "role"], "profile_list": ["Profile2lists", " profile_LIST", "Profile_lists", " profile_group", "prof_list", "profile2List", "profile_listed", "profile_LIST", "Profile2List", "profile8group", "profile_no", "profile2lists", "profile12count", "profile12no", "profile_List", "profile_lists", "profile_group", "profile12listed", "profile8list", "profile12list", "profile_set", "Profile_list", "Profile2list", "Profile_List", " profile_lists", "profile2list", "profile8count", "prof_LIST", "profile_dict", " profile_no", " profile_dict", "prof_set", " profile_listed"], "profile_count": ["project_count", "profileCountbase", "profileCountmax", "profile_check", "sample_Count", "profile2max", "user_found", "profileCountcheck", "profileCountlength", "project_length", "profile12length", "sample_match", "profile2base", " profile_max", "profile_base", "profile_max", "projectCountcount", "profile12check", "profile12max", "projectCountlength", "profile00label", "profile12log", "sample_index", "profile32max", "profile12count", "profile_Count", "projectCountmax", "sample_count", "profile32count", "profile32base", "profile00list", " profile2max", "user_label", "profile_index", " profile_base", "profile12list", " profile2count", "user_count", "profile_log", "profile2length", "user_list", " profile_log", " profile2length", "profile00found", "profile_label", " profile2log", "profileCountlist", "profile2list", "profileCountcount", " profile2base", "profile_found", "profile_length", "project_check", "profile2log", " profile_length", "profile2count", "projectCountcheck", "profile32list", "profile_match", " profile2list", "project_max", "profile00count"], "exact_match": ["exactly_count", "exact_message", "exical0match", "exact0match", "exact_Match", "exactly_message", "exical_met", "exact_count", "exact0count", "exical_error", "exical0count", "exical_match", "exactly_match", "exical0met", "exact0error", "exactisticmatch", "exactisticMatch", "exactly_Match", "exact0met", "exact_met", "exactisticcount", "exical0error", "exactisticmessage", "exact_error", "exical_count"], "alt_profile": ["altackprof", "alt_prof", "alt_project", " alt_project", "alt__project", "altackprofile", "altacksample", "alt__sample", "alt__profile", "alt__prof", " alt_sample", " alt_prof", "alt_sample", "altackproject"]}}
{"project": "FFmpeg", "commit_id": "0065d2d520caab2321b35a7bec5d62564913238b", "target": 0, "func": "static int parse(AVCodecParserContext *ctx,\n\n                 AVCodecContext *avctx,\n\n                 const uint8_t **out_data, int *out_size,\n\n                 const uint8_t *data, int size)\n\n{\n\n    VP9ParseContext *s = ctx->priv_data;\n\n    int marker;\n\n\n\n    if (size <= 0) {\n\n        *out_size = 0;\n\n        *out_data = data;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (s->n_frames > 0) {\n\n        *out_data = data;\n\n        *out_size = s->size[--s->n_frames];\n\n        parse_frame(ctx, *out_data, *out_size);\n\n\n\n        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;\n\n    }\n\n\n\n    marker = data[size - 1];\n\n    if ((marker & 0xe0) == 0xc0) {\n\n        int nbytes = 1 + ((marker >> 3) & 0x3);\n\n        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;\n\n\n\n        if (size >= idx_sz && data[size - idx_sz] == marker) {\n\n            const uint8_t *idx = data + size + 1 - idx_sz;\n\n            int first = 1;\n\n\n\n            switch (nbytes) {\n\n#define case_n(a, rd) \\\n\n            case a: \\\n\n                while (n_frames--) { \\\n\n                    int sz = rd; \\\n\n                    idx += a; \\\n\n                    if (sz > size) { \\\n\n                        s->n_frames = 0; \\\n\n                        av_log(avctx, AV_LOG_ERROR, \\\n\n                               \"Superframe packet size too big: %d > %d\\n\", \\\n\n                               sz, size); \\\n\n                        return AVERROR_INVALIDDATA; \\\n\n                    } \\\n\n                    if (first) { \\\n\n                        first = 0; \\\n\n                        *out_data = data; \\\n\n                        *out_size = sz; \\\n\n                        s->n_frames = n_frames; \\\n\n                    } else { \\\n\n                        s->size[n_frames] = sz; \\\n\n                    } \\\n\n                    data += sz; \\\n\n                    size -= sz; \\\n\n                } \\\n\n                parse_frame(ctx, *out_data, *out_size); \\\n\n                return *out_size\n\n\n\n                case_n(1, *idx);\n\n                case_n(2, AV_RL16(idx));\n\n                case_n(3, AV_RL24(idx));\n\n                case_n(4, AV_RL32(idx));\n\n            }\n\n        }\n\n    }\n\n\n\n    *out_data = data;\n\n    *out_size = size;\n\n    parse_frame(ctx, data, size);\n\n\n\n    return size;\n\n}\n", "idx": 12192, "substitutes": {"ctx": ["jac", "obj", "ck", "tx", "cmp", "pc", "config", " cx", "req", "ct", "k", "p", "kt", "resp", "cp", "cf", "xc", "bc", "act", "jp", "tc", "np", "pkg", "gz", "cb", "unc", "ctl", "conv", "cc", "aus", "kl", "ac", "conn", "cas", "wd", "gc", "ctr", "c", "cn", "cmd", "kh", "kb", "hw", "cm", "kw", "cu", "sc", "x", "kk", "context", "cv", "tz", "ca", "sys"], "avctx": [" avjs", "ajclient", "Avcontext", " avclient", "avclient", " avcontext", "ajjs", "ajctx", "Avjs", "Avclient", "avcontext", "ajcontext", "avjs", "Avctx"], "out_data": [" out_body", "out_bytes", "fullmopsize", "outmopdata", "out_dat", "outmemdata", "net_source", " out_details", "full_div", "outmopsize", "out_body", "outmemDATA", "out_DATA", "net_data", "net_DATA", "out_div", "out__data", "fullmopdiv", " out_bytes", "in_size", "out_details", "full_size", "out__Data", "outmemsize", " out_dat", "out_Data", " out_Data", "out__dat", "out_source", "out__size", "net_size", "in_data", "fullmopdata", "outmopdiv", "in_bytes", "outmemsource", "full_data"], "out_size": ["n_SIZE", " out_SIZE", "out_name", "out_SIZE", "Out_shape", "n_size", "Out_width", "out_length", " out_speed", "out_len", "out_message", "in_length", " out_name", "n_height", "out_ize", "outptscore", "out_width", "Out_ize", "out_shape", " out_length", " out_len", "window_message", "in_name", "in_size", "out_height", "out_score", "window_size", "outptize", "outptmessage", "out_speed", "window_ize", "window_score", "outptsize", "Out_size"], "data": ["format", "d", "block", "values", "package", "done", "t", "str", "maybe", "partial", "inner", "Data", "next", "tx", "record", "read", "at", "message", "value", "buf", "mu", "none", "video", "rel", "any", "dat", "missing", "table", "DATA", "no", "byte", "number", "buffer", "a", "image", "file", "form", "stream", "ref", "type", "def", "i", "raw", "window", "index", "mode", "info", "rew", "only", "len", "empty", "extra", "text", "pointer", "padding", "list", "to", "p", "this", "ata", "zero", "bytes", "all", "snap", "root", "cache", "x", "name", "offset", "length"], "size": ["small", "send", "format", "range", "storage", "se", "fee", "speed", "power", "notice", "status", "negative", "address", "network", "message", "code", "write", " Size", "sp", "value", "height", "Size", "capacity", "g", "yes", "ize", "rate", "body", "final", "new", "count", "e", "scale", "member", "equal", "z", "time", "number", "shift", "buffer", "SIZE", "scope", "l", "type", "timeout", "window", "index", "n", "last", "now", "mode", "zone", "from", "content", "space", "style", "len", "vector", "empty", "num", "sum", "padding", "to", "south", "normal", "zero", "position", "is", "total", "v", "mark", "cache", "shape", "false", "sn", "set", "max", "name", "offset", "length"], "s": ["sq", "comments", "sl", "qs", "ats", "rs", "tests", "hs", "p", "gs", "sts", "ps", "ess", "changes", "g", "cs", "m", "sv", "es", "ses", "xs", "bs", "aws", "details", "is", "js", "als", "S", "ss", "ts", "its", "t", "ssl", "v", "sets", "self", "os", "sb", "c", "sw", "h", "ns", "stats", "w", "fs", "checks", "actions", "comm", "set", "ls", "states", "ims", "ds", "sys", "parts"], "marker": [" markter", "maskER", "Markder", " markaster", "maskin", " markner", "Markt", "markarer", " markder", "markener", "signaster", "markater", "signarer", "misster", "signner", "locater", " markin", "Markater", "markin", "markter", "mixer", "masker", "markder", "markaster", "missater", "markt", "maskener", "signater", " markarer", "maskater", "Markter", "missener", "signiner", "markiner", "maskiner", "arkder", "maskter", " markt", "markar", "MarkER", "Markener", "arkar", "signer", "arkener", "Markar", "Marker", "arker", "arkER", "misser", "signER", " markER", "Markiner", "markER", "arkter", "arkt", "mixER", "maskar", "markner", " markiner", "locer", "mixiner", " markater", "mixarer", "locaster", "Markin", "locner"], "idx": ["catxes", " idz", "catx", "idv", "inz", "indxes", "midex", "Idxs", " idv", "Idex", "Iddx", "idct", " idix", "idy", "Idix", "inct", "midix", "idb", "idez", " idxes", "IDy", "inx", "IDix", "midx", "Idz", " idn", "indxs", " iddx", "iddx", " idex", "catxs", "Idx", " idct", "iden", "idex", "midz", "idix", "IDdx", "IDz", "IDx", " idb", "idxs", "indy", "indb", "catb", "indx", "idxes", " idxs", "idz", "Idy", " idy", "indz", "idn", "idect", "Idv", "IDv", "inn"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n", "idx": 12200, "substitutes": {"dev": ["ow", "doc", "obj", "dd", "priv", "device", "cam", "go", "ev", "proc", "devices", "p", "ve", "adv", "var", "pad", "def", "dis", "raw", "ver", "window", "mem", "md", "de", "ad", "dem", "DEV", "conn", "v", "wd", "info", "cast", "gu", "Dev", "Device", "des", "hw", "w", "serv", "debug", "iv", "app", "sd", "pro", "ds"], "d": ["dd", "dos", "fd", "p", "o", "f", "od", "ind", "ld", "da", "dx", "dc", "ded", "l", "nd", "args", "dis", "did", "mod", "dn", "D", "dra", "md", "r", "gd", "j", "ord", "de", "done", "n", "drivers", "ad", "y", "dom", "v", "e", "b", "dim", "c", "du", "di", "dat", "str", "bd", "w", "dp", "dj", "db", "dm", "dh", "dict", "sd", "dt", "ds", "dr"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 12205, "substitutes": {"d": ["dd", "dos", "fd", "p", "dev", "df", "ind", "ld", "dx", "dc", "pd", "l", "m", "da", "did", "D", "dn", "dra", "r", "ord", "gd", "de", "data", "md", "dq", "ad", "dl", "t", "rd", "info", "b", "c", "du", "di", "dat", "bd", "dp", "dump", "it", "db", "dm", "dh", "debug", "sd", "dt", "ds", "dr"], "val": [" eval", " VAL", "tx", "al", "sl", "pt", " value", "crit", "valid", "VAL", "value", " al", "p", "prop", "buf", "ival", "vec", "ref", "Val", "vt", "util", "all", "cal", "bit", "eval", "il", "cho", "rel", "data", "test", "cond", "t", "ac", "v", " v", "pr", "pl", "b", "pal", " data", "bal", "pol", "elt", "sel", "fee", "serv", "sil", "ul", "vals", "x", "set", "el", "aval", "max", "loc", "vol", "ret"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n", "idx": 12215, "substitutes": {"f": ["tf", "fd", "fw", "bf", "fi", "fo", "uf", "q", "ff", "file", "form", "p", "rf", "df", "fp", "fm", "cf", "d", "l", "m", "fb", "um", "ret", "i", "lf", "fe", "r", "t", "ac", "of", "new", "self", "fr", "e", "b", "c", "fac", "h", "F", "w", "fs", "fc", "z", "fx", "full", "ft", "af"], "v": ["nv", "vs", "u", "va", "vol", "vi", "av", "q", "ev", "k", "vv", "uv", "p", "value", " i", "ve", "o", "d", " n", "lv", "vp", "m", "l", "um", "sv", "i", "values", "qv", "vt", "ver", "inv", "NV", "j", "version", "n", "vd", "V", " iv", "val", "b", "c", "h", "w", "x", "get", "cv", "iv", "wire", "vm", "vc", "conv", "size", "tv"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n\n{\n\n    int i, len, sz;\n\n    GetBitContext gb;\n\n    int code_table[64];\n\n\n\n    /* get the rle codes (at most 64 bytes) */\n\n    init_get_bits(&gb, src, 64 * 8);\n\n    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {\n\n        code_table[i] = get_sbits(&gb, 4);\n\n        sz += FFABS(code_table[i]);\n\n    }\n\n    src += (get_bits_count(&gb) + 7) / 8;\n\n\n\n    /* do the rle unpacking */\n\n    for (i = 0; i < 64 && dst_size > 0; i++) {\n\n        len = code_table[i];\n\n        if (len < 0) {\n\n            len = -len;\n\n            memset(dst, *src++, FFMIN(len, dst_size));\n\n        } else {\n\n            memcpy(dst, src, FFMIN(len, dst_size));\n\n            src += len;\n\n        }\n\n        dst += len;\n\n        dst_size -= len;\n\n    }\n\n    return src;\n\n}\n", "idx": 12216, "substitutes": {"src": ["usc", "rec", "uv", "ins", "hl", "stack", "ser", "r", "rl", "scan", "fr", "str", "sr", "dist", "slice", "conv", "source", "read", "ctrl", "code", "init", "buf", "ind", "RC", "iter", "sec", "bc", "ptr", "txt", "usr", "sur", "sb", "comp", "rt", "sc", "ls", "syn", "img", "obj", "sq", "url", "buffer", "rs", "req", "stream", "sub", "th", "cur", "in", "bg", "now", "tmp", "copy", "inst", "start", "s", "iv", "loc", "out", "sync", "insert", "bin", "fp", "cb", "bytes", "addr", "cont", "dest", "rc", "input", "ctr", "sn", "sel", "st", "fc", "offset", "sys"], "dst": [" dost", "dput", "dsts", "deost", "Dsts", "dssts", "sdsts", " dest", "dsst", "Dost", "Dst", " dsts", "ddest", "dsput", "dend", " dput", "Dend", "dsdest", "dpt", "sdpt", "dest", "Dpt", " dpt", " dht", "sdest", "sdht", " dend", "sdst", "sdput", "dsht", "Dest", "Ddest", "dht", " ddest", "dost", "deend", "dsest", "deest"], "dst_size": ["dst__size", "dst_group", "dost_capacity", "dpt_offset", "dtd_block", "dst_Size", "dst_offset", "dint_size", "dpt_size", "dost__SIZE", "ddest_max", "dst_capacity", "dint_shape", "dbr_size", "dost__size", "dst_sum", "dint_sum", "dost_SIZE", "ddest_size", "ddest_scope", "dbr_time", "dint_SIZE", "dst_SIZE", "dst_num", "dbr_Size", "dpt_SIZE", "dst_shape", "dost_size", "dst_scope", "dst__capacity", "dpt_style", "dost__capacity", "dtd_group", "dst__SIZE", "dst_style", "dtd_size", "dst_time", "dbr_num", "dst_max", "dst_block"], "i": ["span", "o", "m", "r", "im", "ski", "y", "t", "ci", "zi", "gi", "cgi", "iy", "pi", "oi", "ji", "ims", "asi", "ami", "status", "I", "li", "uri", "ri", "ind", "ki", "ti", " ti", "mi", "ix", "xi", "e", "multi", "qi", "si", "batch", "yi", "ai", "PI", "ei", "point", "ui", "ip", "l", "ic", "index", "chain", "n", "\u0438", "phi", "info", "remote", "it", "ini", " bi", "ii", "sync", "fi", "me", "io", "q", "list", "p", "sim", "this", "client", "cli", "is", "j", "series", "iu", "v", "di", "bi", "x", " ii", " j", "ij"], "len": ["hl", "ln", "html", "deg", "pl", "elt", "el", "ll", "size", "fin", "lim", "cmp", "fl", "li", "lang", "von", "iter", "gl", "limit", "rev", "lon", "gz", "lf", "en", "rel", "repl", "z", "ls", "syn", "spec", "sl", "nl", "lan", "compl", "ld", "vec", "l", "pos", "tail", "mem", "kl", "n", "dl", "lc", "low", "lis", "loc", "L", "lt", "lit", "lib", "Len", "list", "del", "lp", "all", "alt", "il", "loss", "total", "tl", "rot", "ler", "val", "ul", "full", "msg", "length"], "sz": ["rszip", " sze", "tsZ", " sZ", "esz", "tsz", "esze", "geszh", " siz", " szh", "esld", "szh", "tesz", "rszh", "tesiz", "asz", "szi", " sld", "asld", "tszi", "rsiz", " szip", "sszi", "tsiz", "rszi", "ssiz", " szi", "esnz", "gesz", "teszi", "rsz", "teszip", "sze", "gesiz", "snz", "sld", "siz", "asze", " snz", "szip", "asnz", "ssz", "sZ", "ssZ", "geszi"], "gb": ["gg", "gif", "mb", "fi", "bf", "lib", "gm", "uf", "rb", "tg", "gs", "GB", "Gb", "pg", "g", "bm", "bits", "cd", "ruby", "cb", " GB", "git", "gin", "bs", "yg", "bg", "rl", "ubi", "gd", "eg", "rg", "fg", "vg", "cfg", "gc", "sb", "b", "tmp", "kb", "cgi", "bb", "by", "nb", " rgb", "db", "buff", "bt", "cv", "gt", "bridge", "vm", "hub"], "code_table": ["code_tmp", "code__table", "code2Table", "code2entry", "code_angle", "codemattable", " code_cache", "code_entry", " code_entry", "change_angle", "codematTABLE", "codeptcollection", "change_TABLE", "codeptTABLE", "change_tmp", "change_table", "codematcollection", " code_buffer", " code_collection", " code_TABLE", "codematpool", "code_cache", " code_Table", "code_buffer", "code2buffer", "code_pool", "codepttable", "code_TABLE", " code_map", "code_collection", "code__buffer", "code_map", "code__map", "codeptpool", "code2TABLE", "code2table", "code2cache", "code2map", "code__entry", " code_pool", "code_Table"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    /* walk down the bs forest recursively */\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        bool perm;\n\n\n\n        /* try to recurse in this top level bs */\n\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n\n\n        /* candidate is the first non filter */\n\n        if (perm) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 12243, "substitutes": {"candidate": ["candate", " candiate", "candicate", "resultiate", "Candidates", "Candiate", "formicate", "Candidate", "resultidate", "centidates", " Candidates", " Candiate", "formidate", " candeter", " Candidate", "centidate", "candiate", "Candate", "formeter", " Candate", "resulteter", "centiate", "centate", "candidates", " candicate", "formiate", "candeter", "resulticate"], "bs": ["ms", "obs", "vs", "ists", "bp", "bas", "Bs", "gs", "bl", "sts", "ps", "bc", "BS", "cs", "bm", "bits", "es", "bsp", "uts", "us", "bg", "is", "js", "its", "bos", "ts", "pb", "lbs", "ubs", "ics", "os", "sb", "b", "bis", "bh", "bi", "ns", "fs", "bb", "ib", "bt", "sys"], "it": ["itted", "lit", "ITS", "ists", "al", "at", "quit", "q", "init", "p", "bl", "sit", "ex", "ind", "ut", "iter", "ip", "g", "l", "i", "ait", "wait", "ic", "pit", "lat", "in", "il", "j", "im", "its", "ist", "ir", "n", "iti", "t", "iz", "out", "exec", "h", "ot", "est", "ul", "IT", "att", "item", "ib", "bt", "It", "hit", "mit"], "perm": ["ms", "xp", "imp", "acc", "prime", "cum", "rpm", "pc", "mb", "priv", "prof", "mm", "pp", "prom", "req", "em", " perf", " cond", "per", "proc", "p", "rep", "prop", "cp", " permission", "jp", "m", "attr", "ptr", "por", "unc", "pri", "mod", "marg", "mi", "pers", "dem", " imp", " permitted", "pr", "pl", "mission", "tmp", "fac", "pol", " sec", "mut", "cert", "comm", "msg", "mp", "emp", "prem", "pty", " permits", "lem"]}}
{"project": "qemu", "commit_id": "f4bf56fb78ed0e9f60fa1ed656c14ff4c494da5a", "target": 1, "func": "static int vhost_user_set_mem_table(struct vhost_dev *dev,\n\n                                    struct vhost_memory *mem)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    int i, fd;\n\n    size_t fd_num = 0;\n\n    bool reply_supported = virtio_has_feature(dev->protocol_features,\n\n                                              VHOST_USER_PROTOCOL_F_REPLY_ACK);\n\n\n\n    VhostUserMsg msg = {\n\n        .hdr.request = VHOST_USER_SET_MEM_TABLE,\n\n        .hdr.flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (reply_supported) {\n\n        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;\n\n    }\n\n\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        ram_addr_t offset;\n\n        MemoryRegion *mr;\n\n\n\n        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);\n\n        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,\n\n                                     &offset);\n\n        fd = memory_region_get_fd(mr);\n\n        if (fd > 0) {\n\n            msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr;\n\n            msg.payload.memory.regions[fd_num].memory_size  = reg->memory_size;\n\n            msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr;\n\n            msg.payload.memory.regions[fd_num].mmap_offset = offset;\n\n            assert(fd_num < VHOST_MEMORY_MAX_NREGIONS);\n\n            fds[fd_num++] = fd;\n\n        }\n\n    }\n\n\n\n    msg.payload.memory.nregions = fd_num;\n\n\n\n    if (!fd_num) {\n\n        error_report(\"Failed initializing vhost-user memory map, \"\n\n                     \"consider using -object memory-backend-file share=on\");\n\n        return -1;\n\n    }\n\n\n\n    msg.hdr.size = sizeof(msg.payload.memory.nregions);\n\n    msg.hdr.size += sizeof(msg.payload.memory.padding);\n\n    msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion);\n\n\n\n    if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (reply_supported) {\n\n        return process_message_reply(dev, &msg);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12245, "substitutes": {"dev": ["doc", "development", "priv", "av", "device", "cam", "build", "go", "ev", "det", "proc", "devices", "var", "adv", "prop", "pad", "nt", "d", "eng", "ram", "def", "serial", "ver", "handle", "addr", "md", "develop", "de", "data", "boot", "test", "ad", "scan", "conn", "DEV", "v", "info", "conf", "env", "host", "os", "Dev", "van", "cmd", "des", "hw", "w", "att", "db", "debug", "disk", "app", "sd", "pro"], "mem": ["ms", "tm", "doc", "Memory", "tx", "lim", "mb", "map", "sum", "buffer", "mm", "em", "Mem", "alloc", "ram", "hist", "program", "m", "ref", "my", "mt", "mu", "met", "mi", "md", "core", "addr", "tem", "storage", " Mem", "emb", "rem", "cache", "gc", "master", "nom", "temp", "sys", "res", "serv", "hw", "stat", "rm", "phys", "buff", "memory", "msg", "usage", "access", "loc", "am", "store"], "fds": ["fuds", "frDs", "alfds", "hds", "frs", "alfdos", "alfDs", "fDs", "huds", "alfd", "frd", "efrs", " fdos", "efds", "effs", "frds", "hrs", "efuds", " ffs", "hfs", " fuds", " fDs", "frdos", "ffs", " frs", "fdos"], "i": ["id", "ai", "I", "io", "ie", "li", "ei", "init", "k", "p", "o", "sim", "f", "ind", "ui", "ip", "g", "m", "l", "ti", "ic", "ia", "in", " ti", "mi", "index", "chain", "j", "im", "ix", "n", "y", "t", "ci", "iu", "zi", "v", "phi", "xi", "e", "multi", "c", "gi", "di", "bi", "ij", "pi", "si", "it", "x", "ini", " ii", "oi", " j", "ii"], "fd": ["td", "fin", "dd", "fi", "draw", "bf", "fl", "ffff", "ff", "file", "func", "df", "f", "fp", "cf", "fm", "d", "FF", "fun", "fb", "hd", "ptr", "fe", "lf", "tif", "fa", "index", "gd", "fn", "dl", "fr", "dir", "FD", " fid", "fat", "elt", "fs", "fc", "ini", "db", "nd", "dt", "ft", "ds", "sd"], "reg": ["arr", "mb", "config", "rs", "req", "err", "region", "go", "rec", "resp", "form", "ram", "gr", "g", "act", "ref", "arch", "sam", "mn", "rr", "mod", "addr", "r", "eg", "rel", "Reg", "br", "roy", "rg", "repl", "rem", "conn", "arg", "pr", "gc", "cmd", "ro", "re", "rule", "res", "tag", "REG", "disc", "rm", "org", "msg", "debug", "gro", "app", "loc", "rar", "rom", "dr", "gra", "ret"], "offset": ["ms", "key", "shift", "len", "off", "extra", "reset", "address", "map", "mb", "mm", "pointer", "padding", "order", "err", "alloc", "area", "meta", "o", "field", "error", "f", "fp", "slot", "offs", "location", "pos", "ref", "attr", "ptr", "position", "length", "window", "addr", "index", "row", "owner", "data", "Offset", "tmp", "mid", "origin", "start", "seed", "coord", "loc", "size", "mt"], "mr": ["kr", "ml", "Mr", "tr", "hr", "mx", "igr", "lr", "rs", "gr", "m", "bm", "rn", "MR", "drm", "shr", "mn", "rr", "adr", "r", "rl", "br", "mc", "mer", "rg", "nr", "irm", "pr", "mk", "mor", "rt", "sr", "cm", "er", "RM", "ocr", "rm", "ur", "vr", "cr", "rar", "ar", "dr", "mt"]}}
{"project": "FFmpeg", "commit_id": "fa74cdc60d19798c951dcc242ca7273e6483f2b3", "target": 1, "func": "int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,\n                     uint8_t **poutbuf, int *poutbuf_size,\n                     const uint8_t *buf, int buf_size,\n                     int64_t pts, int64_t dts, int64_t pos)\n{\n    int index, i;\n    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];\n    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {\n        s->next_frame_offset =\n        s->cur_offset        = pos;\n        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;\n    }\n    if (buf_size == 0) {\n        /* padding is always necessary even if EOF, so we add it here */\n        memset(dummy_buf, 0, sizeof(dummy_buf));\n        buf = dummy_buf;\n    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */\n        /* add a new packet descriptor */\n        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);\n        s->cur_frame_start_index = i;\n        s->cur_frame_offset[i]   = s->cur_offset;\n        s->cur_frame_end[i]      = s->cur_offset + buf_size;\n        s->cur_frame_pts[i]      = pts;\n        s->cur_frame_dts[i]      = dts;\n        s->cur_frame_pos[i]      = pos;\n    }\n    if (s->fetch_timestamp) {\n        s->fetch_timestamp = 0;\n        s->last_pts        = s->pts;\n        s->last_dts        = s->dts;\n        s->last_pos        = s->pos;\n        ff_fetch_timestamp(s, 0, 0, 0);\n    }\n    /* WARNING: the returned index can be negative */\n    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,\n                                    poutbuf_size, buf, buf_size);\n    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes\n    /* update the file pointer */\n    if (*poutbuf_size) {\n        /* fill the data for the current frame */\n        s->frame_offset = s->next_frame_offset;\n        /* offset of the next frame */\n        s->next_frame_offset = s->cur_offset + index;\n        s->fetch_timestamp   = 1;\n    }\n    if (index < 0)\n        index = 0;\n    s->cur_offset += index;\n    return index;\n}", "idx": 12255, "substitutes": {"s": ["ms", "vs", "ats", "end", "hs", "func", "into", "cs", "m", "bits", "ins", "details", "r", "http", "se", "y", "sports", "ties", "os", "b", "w", "serv", "comm", "ims", "ar", "ers", "ports", "call", "source", "settings", "sql", "tests", "gs", "sts", "ex", "changes", "g", "sv", "ses", "sam", "xs", "bs", "services", "als", "js", "less", "ss", "new", "conf", "ops", "sb", "sc", "z", "ls", "states", "state", "sq", "obj", "spec", "aunts", "qs", "a", "rs", "as", "es", "raw", "terms", "store", "_", "ts", "n", "ags", "sw", "ns", "rest", "er", "ds", "comments", "sync", "eps", "p", "ps", "save", "aws", "is", "j", "S", "its", "ssl", "v", "https", "search", "c", "bis", "h", "acs", "stats", "re", "fs", "set", "sys", "parts"], "avctx": ["AVcc", " avcontext", " avtmp", "avcon", " avcon", " avcc", " avpkg", "AVctx", "AVcontext", "AVtmp", "avcontext", "averpkg", "avercontext", "AVpkg", "AVcon", "avertmp", "averctx", "avercc", "avtmp", "avpkg", "avcc", "avercon"], "poutbuf": ["spotbuf", "pinuf", " pOutbuf", " poutbuffer", "pendbuffer", "spotbuffer", "pinqueue", "spoutvec", "poutqueue", "poutbuffer", "potbuf", " poutqueue", "spoutuf", "penduf", "pOutqueue", " poutuf", "pinbuf", " pOutbuffer", "pendvec", "pinbuffer", "pOutuf", "spotuf", "potuf", "potvec", "potqueue", "poutuf", "pOutbuffer", "pendbuf", " pOutuf", "spoutbuffer", " pOutqueue", "poutvec", "spotvec", "pOutbuf", "spoutbuf", "potbuffer", "pinvec"], "poutbuf_size": ["poutqueue_size", "poutbuf0dim", "poutbuf_Size", "poutbuf0size", "poutbuffer_Size", "poutqueue_dim", "poutqueue_len", "poutbuf_length", "poutqueue_SIZE", "poutbuf_SIZE", "poutbuffer_SIZE", "poutqueue2size", "poutbuffer_size", "poutbuf2Size", "poutqueue2Size", "poutqueue_Size", "poutbuf_dim", "poutbuffer_length", "poutbuf0Size", "poutbuf_len", "poutbuf2size", "poutbuf2dim", "poutqueue2dim"], "buf": ["doc", "bf", "map", "buffer", "uf", "rb", "ff", "p", "pool", "bin", "cp", "bc", "Buffer", "block", "vec", "ref", "fb", "cb", "ptr", "port", "raw", "bytes", "queue", "mem", "data", "br", "pb", "box", "cap", "cast", "cache", "b", "tmp", "cmd", "h", "str", "grab", "Buff", "foo", "batch", "buff", "db", "bar", "cv", "conv", "bag", "out", "wb"], "buf_size": ["buffer_size", "uf_Size", " bufferseqsync", "uf_length", "buffer_SIZE", "bufINGsw", "buf_sw", "buf2sync", "bufINGchain", "uf_sw", "buf_length", " bufferseqSIZE", " buffer_SIZE", "uf_chain", " bufferseqsize", "bufINGsize", "buf_chain", "buffer_Size", "bufseqSIZE", "buf2size", " buffer_size", " buffer_sync", "bufINGSize", "uf_SIZE", "buf_Size", "buf_SIZE", " buf_count", " buf_SIZE", "buf_time", "buf2SIZE", "buf_count", "uf_size", "buffer_count", "buf_sync", " buf_time", "bufseqsize", "bufseqsync"], "pts": ["pkgs", "cmdids", "ointts", "pkgds", "ppss", "aptts", "aptds", "ptrids", "pkgts", "ppds", "oints", "ptns", "aptss", "ptts", "points", "pointts", "pkgss", "ptids", "ptets", "pps", "PTts", "cmdts", "apts", "PTs", "ptrts", "cmdns", "PTets", "PTjs", "ptds", "ptss", "pointns", "cmds", "ptrs", "cmdjs", "ointjs", "ointets", "ptrns", "ptjs", "ppts", "pointids", "cmdets"], "dts": ["mdTS", "pcs", "gdps", "mps", "dTS", "dcs", " dms", "edps", "edms", "mdcs", "mdps", " dps", "pps", "pjs", "dms", "mcs", " dTS", "gdts", "pms", "gdjs", "gdcs", "edcs", "mdts", "mjs", " dcs", "pTS", "dps", "mts", "edts", "djs"], "pos": ["doc", "len", "op", "spec", "off", "POS", "pc", "add", "pointer", "pt", "base", "lang", "end", "to", "proc", "p", "point", "o", "resp", "Pos", "ps", "prot", "pose", "limit", "ref", "def", "bits", "position", "port", "length", "win", "pid", "lat", "pres", "neg", "top", "cond", "pb", "body", "mos", "rot", "gen", "os", "mon", "tmp", "pro", "origin", "po", "start", "res", "tag", "pi", "nos", "set", "oss", "no", "loc", "offset", "size"], "index": ["key", "len", "num", "id", "success", "address", "negative", "status", "code", "pointer", "seek", "IND", "value", "point", "f", "error", "ind", "frame", "d", "find", "active", "timeout", "zero", "position", "length", "connect", "row", "j", "Index", "n", "of", "state", "count", "ion", "val", "e", "c", "si", "x", "result", "set", "no", "loc", "offset", "size", "out", "number"], "i": ["id", "ai", "fi", "I", "a", "io", "ei", "li", "uri", "vi", "init", "ri", "p", "ii", "f", "ind", "ui", "iter", "ip", "g", "m", "ti", "ic", "cli", "mi", "is", "chain", "j", "im", "ix", "n", "y", "iu", "ci", "phi", "zi", "info", "v", "xi", "qi", "e", "multi", "gi", "di", "bi", "si", "pi", "it", "x", "ini", "oi", "hi", "ori", "ij"], "dummy_buf": ["duffy_buff", "dummyedpg", "dummyeduf", "duffy_pb", "dummy___uf", "dancy_buff", "duffy_cmd", "dancy_uf", "duffy_pg", "dummy___buff", "dummy_cur", "dummy_pg", "duffy_uf", "dummy___buf", "dummy_buff", "duffy_buf", "dummyedcur", "dummy_buffer", "dummy_pb", "dancy_buf", "duffy_cur", "dummy_uf", "dancy_buffer", "dummyedbuf", "dummy___cmd", "dummy_cmd"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, qiov, offset);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n", "idx": 12257, "substitutes": {"client": ["current", "net", "google", "con", "config", "call", "network", "api", "cell", "manager", "Client", "contact", "cl", "open", "component", "local", "window", "util", "session", "ic", "cli", "server", "connect", "ce", "core", "bound", "http", "cod", "node", "connection", "handler", "conn", "remote", "cache", "close", "c", "controller", "force", "context", "co", "public", "private", "grid"], "sector_num": ["sectoracnum", "sectorlyNum", "sectorlysym", "ceiverlynum", "ceiver_index", "sector_mon", "ceiver_Num", "ceiverlysym", "sectoracNum", "sectoracsym", "ceiverlyNum", "ceiverlyindex", "sectoracindex", "sector_Num", "sectorlyindex", "ceiver_sym", "ceiver_num", "ector_Num", "sector_sym", "ector_mon", "ector_hom", "sectorlynum", "sector_index", "ector_num", "sector_hom"], "nb_sectors": ["nb_velements", "nb_vecs", "nb_seors", "nb_pseors", "nb_psectors", "nb_psevers", "nb_veors", "nb_pselements", "nb_pelements", "nb_pegments", "nb_spegments", "nb_pecs", "nb_specs", "nb_speors", "nb_severs", "nb_selements", "nb_pevers", "nb_vevers", "nb_spectors", "nb_vectors", "nb_secs", "nb_vegments", "nb_pectors", "nb_peors", "nb_segments"], "qiov": [" qconv", "quconv", " qiv", "quiop", "chiev", "kiev", "chconv", "chiva", " qiva", "chiop", "qiev", " qoj", "qiva", "qiop", "qiv", "koj", "qoj", "choj", "quiva", " qiev", "qconv", "chiov", "quiov", "chiv", " qiop", "kiov", "kiv"], "offset": ["shift", "len", "num", "off", "reset", "id", "address", "et", "pointer", "padding", "base", "offer", "end", "seek", "point", "o", "error", "pad", "slot", "location", "pos", "oid", "ref", "timeout", "addr", "index", "ta", "Offset", " offsets", "encrypted", "from", "origin", "start", " off", "seed", "set", "size", "style"], "request": ["command", "reset", "add", "update", "print", "over", "report", "parse", "reference", "package", "attribute", " requesting", "question", "create", "import", "cmd", "param", " attempt", "public", "claim", "art", "address", " req", "record", "call", "message", " requested", "document", "match", "task", " query", " argument", "new", "QUEST", "setup", "rule", "xml", "rank", " command", "work", "project", "order", "req", "point", "frame", "worker", "push", "condition", "process", "type", "index", "execute", "forward", "copy", "from", "quest", "Request", "select", "q", "begin", "complete", "child", "pair", "common", "core", "transfer", "root", "change", "input", "search", "suggest", "query", "requ", "response"], "reply": ["output", "command", "next", "vote", "callback", "notice", "send", "status", "nl", "respond", "part", "back", "write", "message", "Reply", "match", "err", "route", "bool", "resp", "post", "report", "error", "service", "onse", "ply", "relation", "rr", "sett", "ish", "r", "try", " Reply", "translation", "transfer", "echo", "body", "repl", "bill", "info", "tree", "b", "related", "comment", "tmp", "ror", "replace", "bb", "force", "table", "link", "result", "proxy", "dict", "answer", "response", "apply", "state", "out"], "ret": ["arr", "tf", "len", "obj", "lt", "reset", "status", "pat", "et", "read", "back", "flag", "print", "det", "nz", "RET", "resp", "report", "f", "ry", "nt", "prot", "limit", "ref", "fun", "def", "mt", "args", "ply", "desc", "inter", "alt", "mem", "ord", "r", "ext", "ter", "j", "data", "ts", "t", "rem", "rets", "rot", "info", "deg", "arg", "backed", "val", "Ret", "tmp", "rt", "re", "elt", "sys", "res", "result", "att", "set", "gt", "db", "gb", "ll", "ft", "out"]}}
