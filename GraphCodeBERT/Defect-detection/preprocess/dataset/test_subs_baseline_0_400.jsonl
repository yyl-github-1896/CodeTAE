{"project": "FFmpeg", "commit_id": "32bf6550cb9cc9f487a6722fe2bfc272a93c1065", "target": 0, "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "idx": 3, "substitutes": {"s": ["d", "c", "sv", "ss", "p", "conv", "g", "sa", "ds", "m", "b", "fs", "aws", "ps", "ns", "sw", "sd", "w", "e", "ts", "v", "h", "gs", "f", "ats", "t", "a"], "pb": ["fp", "proc", "sys", "cp", "wp", "lp", "tmp", "phys", "buf", "pc", "jp", "bj", "tk", "p", "conv", "py", "pm", "erb", "np", "bp", "txt", "pp", "mp", "cb", "rb", "pause", "gp", "td", "buff", "pg", "bot", "tab", "new", "vp", "tm", "tf", "tp", "conf", "pa", "vm", "xp", "span", "ctx", "pl", "px", "pool", "pkg", "emb", "pt", "db", "fb", "orp", "typ", "dp", "peer", "sb", "resp", "apy", "PB", "uf", "obj", "pro"], "codec": [" codoe", "codeac", "predec", "odeco", "codeoe", "codefc", "podEC", "podest", "podec", "codener", "codest", "typEC", " codiac", "callenc", "cmdec", "podcam", "cedec", " codeco", "odoe", "odcam", " codelta", " codoc", "codeiac", "predisc", "odac", "odec", "copec", " coddec", " codent", "coec", "podener", "typpeg", "codeg", "codeoc", "callec", "codedec", "copeca", "odener", "odfc", " codac", "odisc", "codeeca", "cedeca", "Codac", "octel", "coddec", "cellapter", "codenc", "checkec", "podac", "ceenc", "modec", "codera", "codeec", "codecam", " codeman", "codcam", "copent", "checkoe", "odest", "odEC", " codapter", "oderer", "codsc", "codeisc", "modeco", "cmddec", "callect", " codsc", "podisc", "Codel", "critec", " codeca", "modoc", "cmdelta", " coderer", " codisc", "codac", "codeest", "codeEC", "typerer", "celloe", "calliac", "predera", " codpeg", "octeco", "codoc", "codeender", "Codelta", "podica", "Codeco", "codeerer", "codpeg", "cedeco", "coderer", "codeca", "modEC", "ceiac", "codiac", "codeect", "codeman", "critera", " codica", "critisc", "cellec", "Codec", " codera", "codeco", "codeeco", "codoe", "odiac", "modent", "cedac", "copsc", "codect", "codica", "model", "codEC", "modeca", "codender", "coerer", "Codoc", "moddec", "modpeg", "coisc", "ceec", "coeco", "odeca", " codender", "checkapter", "ceect", " codeg", "codel", "celleman", "codeenc", " codfc", "typdec", "podeca", " codEC", "Coddec", "codelta", "typec", "predeman", "codisc", "codeeg", "Coderer", "checkeman", "odender", " codener", "codapter", "codeener", "cmderer", "modsc", "octec", "codfc", "octoc", "codent", "typeg", "odica", "criteman"], "size": ["data", "total", "south", "number", "message", "shift", "count", "news", "settings", "to", "n", "sample", "set", "send", "m", "small", "sum", "space", "see", "num", "notice", "shape", "storage", "type", "scope", "length", "dimension", "SIZE", "buffer", "e", "name", "offset", "ize", "body", "range", "scale", "empty", "what", "bytes", "fee", "scroll", "sized", "max", "position", "area", "len", "capacity", "Size", "sn"], "big_endian": ["big_ENDior", "big_endingior", "big_endsIAN", "big_endsians", "big_ender", "big_rendican", "big_ENDIAN", "big_endican", "big_endser", "big_ENDians", "big_endians", "big_endsican", "big_rendIAN", "big_endIAN", "big_endsior", "big_rendior", "big_ENDical", "big_startians", "big_andIAN", "big_rendian", "big_endsical", "big_endingican", "big_endingIAN", "big_endeian", "big_ander", "big_endior", "big_startian", "big_endeians", "big_endeical", "big_andians", "big_andior", "big_endingian", "big_ENDian", "big_andian", "big_endeIAN", "big_endical", "big_startIAN", "big_starter", "big_endsian"], "id": ["oid", "parent", "try", "format", "p", "init", "set", "x", "time", "k", "hash", "h", "ID", "f", "d", "key", "head", "link", "num", "it", "tag", "end", "aid", "name", "sid", "offset", "vid", "bid", "ident", "hid", "root", "ide", " tid", "iden", "code", "addr", "style", " fid", "rid", "ref", "index", "Id", "rank", "info", "type", "hd", "uid", "pid", "kid", "len", "data", "hide", "status", "no", "is", "wire", "debug", "url", "mid", "ids", "with", "orig", "md", "start", "like", "ip", "tar", "null", "in", "ad", "t"], "bitrate": ["bugRate", "butride", "bitscurrency", " bitrates", "fitzip", "butrates", "fitride", "bitcurrency", " bitcurrency", " bitzip", " bitride", "bitsrates", "BitRate", "Bitrate", "butzip", " bitRate", "bitrates", "Bitrates", "butrate", "bugrate", "bitride", "bugrates", "bugcurrency", "bitsRate", "fitrate", "fitrates", "bitzip", "bitsrate", "bitRate"]}}
{"project": "qemu", "commit_id": "c0c24b95542bc1a4dc3fc6ea71475ae04fa69189", "target": 1, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}", "idx": 12, "substitutes": {"xendev": ["xentew", " xendeata", "xendsef", "xendedep", " xendata", "xentef", "xestec", "xndev", "xandec", "exendev", "xenderew", "xandev", "exenddev", "xendeddev", "xendsec", "wendeg", "xendeg", "wendef", "xaendec", "xestoe", "exentev", "exentem", "xendedec", "xadev", "xaenderev", "xendoc", "xaendoe", "xadep", "xentem", "xendoe", "wendev", "xendef", "xendsew", " xenddev", "xendem", "xestev", "xenderev", "xendeerv", "xENDee", "xenderov", "xtendev", " xndew", "xendata", "xentdev", "xhendec", "xaenderoe", "xendov", "xendedoe", "xendederv", "xaendiv", "xendedef", "yendev", "xentee", "xaendev", "xtendef", "xendeoc", "xentoc", "exendem", "xENDdev", "xendedem", "xentev", " xndev", "xendee", "xandeg", "xestiv", "xendsev", "xndov", "xhendev", " xnddev", "xnddev", "xandep", "xendsata", "xendedev", "xenderv", "xendeem", "xenderec", "yendedev", "xENDov", "exenderv", "exentdev", "yenddev", "xendep", "xenddev", "xendec", "xtentev", "wendep", "xaenderec", " xendoc", "xendedee", "xentata", "wendedef", "xenderdev", "yendedec", "yendederer", "xendedeg", "xhenderer", "xtenddev", "xENDec", "xtentdev", "xendederer", " xendeoc", "xenterv", "wendedeg", "xtendee", "xadec", "xENDew", "xendeew", " xendeew", "wendee", "xendsoc", "wendedep", " xndov", "yenderer", " xendew", "wendedec", "xENDef", "wendedee", "xendeata", "xadeg", "xaenderiv", "xendeev", "exenterv", "yendec", "xtentef", "xendew", "xenderiv", "xenderoe", "xndec", "wendec", " xendeev", "xendsdev", "xendsee", "xenderer", "xendediv", "xndew", "xendiv", "xnderer", "yendeddev", " xendov", "wendedev", "xENDev", "xtentee", "xhenddev"], "i": ["id", "c", "p", "init", "li", "x", "series", " ti", "iu", "ti", "ind", "ix", "zi", "h", "ini", "I", "f", "my", " bi", "batch", "list", " j", "conv", "xi", "ic", "qi", "m", " n", "ui", "it", "ims", "im", " v", " li", "io", "remote", "\u0438", " k", "ri", "j", " m", "ii", "iri", " mi", "ji", "slice", "pi", "asi", "me", "index", "ci", "ei", "info", "phi", "ij", "fi", " ii", "y", " pi", "bi", "err", "hi", " I", "go", "v", " ni", "mi", "di", "ai", "si", "multi", "is", "sim", "ami", "cli", "gi", " si", "ip", "oi", " my", "in", "o", " multi"], "xen_9pdev": ["xen_9lpval", "xen_9fdev", "xen_6pdiv", "xen_9pcprof", "xen_9pcDEV", "xen_6pDEV", "xen_9ptDEV", "xen_9Pdef", "xen_ninepprof", "xen_9tpstat", "xen_9lpgu", "xen_ninepds", "xen_9tblock", "xen_15ppval", "xen_1ddev", "xen_10pdes", "xen_93pdd", "xen_999pDev", "xen_9npDEV", "xen_999pdd", "xen_9pDev", "xen_09wpDEV", "xen_9pcdb", "xen_09wpdem", "xen_9tpDEV", "xen_9partdev", "xen_93pgev", "xen_ninedserv", "xen_9tdef", "xen_9pconn", "xen_9tpcast", "xen_9lpserv", "xen_10pDEV", "xen_9lpev", "xen_15pfam", "xen_999pdev", "xen_ninetdevice", "xen_6pcdiv", "xen_ninepgo", "xen_9partdes", "xen_ninetpgu", "xen_10fdes", "xen_ninetpgo", "xen_5tpcast", "xen_14pDEV", "xen_ninetpds", "xen_9padev", "xen_9tpgu", "xen_9ptdem", "xen_9pprof", "xen_09wpdev", "xen_9phpstat", "xen_6pcdef", "xen_9pgdef", "xen_9pidev", "xen_9padserv", "xen_1pdb", "xen_9pblock", "xen_9pidevice", "xen_10dserv", "xen_09tpDEV", "xen_9pcserv", "xen_5pdev", "xen_9lpdef", "xen_9pdevice", "xen_2009patt", "xen_9erdev", "xen_9pardev", "xen_6pserv", "xen_999prden", "xen_9ppdevice", "xen_9pgdd", "xen_9pfam", "xen_ninetpdev", "xen_9pcast", "xen_9npgu", "xen_15pdevice", "xen_9lpdev", "xen_93pgdef", "xen_999pidev", "xen_9pver", "xen_9tpgo", "xen_17pccom", "xen_10dev", "xen_14parcast", "xen_09pdev", "xen_nineddev", "xen_9erdes", "xen_30pmem", "xen_9pserv", "xen_9pdata", "xen_9ppgo", "xen_9lpDEV", "xen_9npdevice", "xen_14pcast", "xen_9parcast", "xen_9tpdevice", "xen_9ppDev", "xen_30bpmem", "xen_9prDev", "xen_9dDev", "xen_5pstat", "xen_5tpstat", "xen_9fds", "xen_ninetdev", "xen_9pev", "xen_09tpgu", "xen_9pcom", "xen_10fDEV", "xen_9pdes", "xen_ninepev", "xen_9pcdata", "xen_9edes", "xen_9ndef", "xen_9ppgu", "xen_9tdd", "xen_9fev", "xen_9tpev", "xen_9ppblock", "xen_9pDEV", "xen_9pcconn", "xen_17pctech", "xen_9pdef", "xen_9ndev", "xen_9ppprof", "xen_970pcom", "xen_9tprof", "xen_9wpcast", "xen_5pver", "xen_30bpdev", "xen_ninepblock", "xen_9posttech", "xen_9pidgu", "xen_14pardata", "xen_14pdev", "xen_ninepgu", "xen_970pgo", "xen_9Pev", "xen_9pccast", "xen_9tdevice", "xen_9lpmem", "xen_17pdev", "xen_10ddev", "xen_30pDEV", "xen_9opev", "xen_6pdef", "xen_9pcdes", "xen_6pev", "xen_9pdver", "xen_999pev", "xen_9ppval", "xen_9lpdd", "xen_999prDev", "xen_9pgdev", "xen_9pdDEV", "xen_9pddes", "xen_9pdd", "xen_6pcserv", "xen_9wpdev", "xen_9ppdev", "xen_14parDEV", "xen_9pcdevice", "xen_9opdev", "xen_9patt", "xen_09wpdef", "xen_ninepdevice", "xen_9ddev", "xen_9pdcast", "xen_ninepdef", "xen_9partDEV", "xen_10pserv", "xen_9pddev", "xen_999pidgu", "xen_9parDEV", "xen_9lpgo", "xen_9dDEV", "xen_9wpden", "xen_9wpdem", "xen_9erdiv", "xen_9prdev", "xen_09tpdev", "xen_93pev", "xen_9pidval", "xen_970bpgo", "xen_15pval", "xen_9dconn", "xen_9bpdev", "xen_1ddb", "xen_9lpfam", "xen_ninetdef", "xen_2009pdev", "xen_nineddevice", "xen_9tserv", "xen_9xpgo", "xen_09pDEV", "xen_1dconn", "xen_9piblock", "xen_9edev", "xen_9bpgo", "xen_1pconn", "xen_ninepdev", "xen_14pardev", "xen_9ndem", "xen_9ppcom", "xen_9lpds", "xen_ninepserv", "xen_ninetprof", "xen_9pcDev", "xen_999prdev", "xen_30bpDEV", "xen_1pdev", "xen_9tver", "xen_9fDEV", "xen_9tpatt", "xen_2009tpdev", "xen_93pgdd", "xen_9ppdef", "xen_9ppfam", "xen_6pcdev", "xen_9pdb", "xen_9ddb", "xen_9pstat", "xen_9fgu", "xen_9pigu", "xen_ninetver", "xen_09pdem", "xen_15pdev", "xen_9phpver", "xen_9pds", "xen_9pgu", "xen_9bpmem", "xen_999pden", "xen_9postcom", "xen_6pdes", "xen_9fdd", "xen_9pval", "xen_10pds", "xen_9ptdef", "xen_970bpdev", "xen_ninedev", "xen_9pcdiv", "xen_2009tpatt", "xen_9tpver", "xen_93pgdev", "xen_9bpcom", "xen_9tdev", "xen_9dev", "xen_970bpcom", "xen_9piddd", "xen_9pgo", "xen_9ddevice", "xen_9phpdev", "xen_970pDev", "xen_9pdstat", "xen_9ppver", "xen_9wpDev", "xen_9pccom", "xen_970bpDev", "xen_1pDev", "xen_14pdata", "xen_6pcev", "xen_9opDEV", "xen_10pev", "xen_15ppdevice", "xen_9pcdef", "xen_9phpcast", "xen_9lpdevice", "xen_6pcdes", "xen_9tgu", "xen_9wpdata", "xen_999piddd", "xen_9pden", "xen_10dDEV", "xen_9prden", "xen_9pdiv", "xen_09pdef", "xen_10pdev", "xen_1dDev", "xen_17pcdev", "xen_2009pev", "xen_9postdev", "xen_10fdev", "xen_9xpds", "xen_15ppfam", "xen_09pdevice", "xen_5pcast", "xen_9npdev", "xen_9tatt", "xen_970pdev", "xen_5tpdev", "xen_9opserv", "xen_9xpdev", "xen_9paddev", "xen_9tpdev", "xen_9ptdev", "xen_9pcdev", "xen_17ptech", "xen_9partdiv", "xen_10fds", "xen_09tpdevice", "xen_9pgDev", "xen_9nDEV", "xen_6pdev", "xen_9piddev", "xen_93pdev", "xen_9pcgu", "xen_ninetblock", "xen_9eds", "xen_9eDEV", "xen_6pcDEV", "xen_9dserv", "xen_9pidfam", "xen_9Pdev", "xen_9tev", "xen_9erDEV", "xen_9pmem", "xen_9paddevice", "xen_9pcver", "xen_9wpDEV", "xen_9pgconn", "xen_9ptech", "xen_9bpDev", "xen_ninetgu", "xen_9pgdb", "xen_9wpdef", "xen_15ppdev", "xen_999pgu", "xen_9tpds", "xen_93pdef", "xen_9xpgu", "xen_9Pserv", "xen_9pdem", "xen_9pgev", "xen_9fdes", "xen_ninepver", "xen_30pdev", "xen_2009tpev", "xen_17pcom", "xen_9bpDEV", "xen_9pdds", "xen_9piddevice", "xen_5tpver", "xen_9pctech", "xen_09pgu", "xen_9pcev", "xen_9fmem", "xen_999piddev", "xen_9pardata"], "s": ["d", "S", "j", "stats", "c", "ss", "p", "g", "n", "r", "ds", "m", "b", "fs", "ps", "w", "e", "v", "rs", "h", "o", "gs", "sb", "os", "t"], "fsdev": ["FSDEV", " fsDev", " fsDEV", "FSdevice", "csdev", "FSDev", " fsdevice", "csDev", "csdevice", "FSdev", "csDEV", "fsDEV", "fsdevice", "fsDev"], "str": ["br", "chain", "data", "j", "cr", "ctr", "arr", "buf", "er", "p", "g", "sl", "txt", "r", "Str", "out", "res", "b", "x", "msg", "ring", "sc", "it", "pr", "sw", "w", "buffer", "err", "ptr", "name", "fr", "cs", "shr", "STR", "print", "dr", "v", "sts", "rs", "vol", "wr", "f", "tr", "st", "t", "sp"], "ring_order": ["ring_record", " ring_record", "ring_err", " ring_err", " ring_type", "ring_type"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,\n\n                                int pred_order)\n\n{\n\n    int p, porder, psize;\n\n    int i, part_end;\n\n    int count = 0;\n\n\n\n    /* subframe header */\n\n    count += 8;\n\n\n\n    /* subframe */\n\n    if (sub->type == FLAC_SUBFRAME_CONSTANT) {\n\n        count += sub->obits;\n\n    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {\n\n        count += s->frame.blocksize * sub->obits;\n\n    } else {\n\n        /* warm-up samples */\n\n        count += pred_order * sub->obits;\n\n\n\n        /* LPC coefficients */\n\n        if (sub->type == FLAC_SUBFRAME_LPC)\n\n            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n\n\n        /* rice-encoded block */\n\n        count += 2;\n\n\n\n        /* partition order */\n\n        porder = sub->rc.porder;\n\n        psize  = s->frame.blocksize >> porder;\n\n        count += 4;\n\n\n\n        /* residual */\n\n        i        = pred_order;\n\n        part_end = psize;\n\n        for (p = 0; p < 1 << porder; p++) {\n\n            int k = sub->rc.params[p];\n\n            count += 4;\n\n            count += rice_count_exact(&sub->residual[i], part_end - i, k);\n\n            i = part_end;\n\n            part_end = FFMIN(s->frame.blocksize, part_end + psize);\n\n        }\n\n    }\n\n\n\n    return count;\n\n}\n", "idx": 35, "substitutes": {"s": ["sys", "ls", "S", "stats", "c", "sg", "is", "sh", "sv", "ss", "es", "sec", "g", "n", "sim", "vs", "ses", "comm", "set", "ds", "b", "x", "fs", "less", "ps", "its", "js", "ns", "bs", "sw", "http", "ims", "e", "ms", "bis", "cs", "ts", "spec", "hs", "sts", "v", "rs", "h", "gs", "f", "sb", "ats", "ins", "sq", "os", "t", "a", "se"], "sub": ["j", "aux", "test", "add", "pro", "summary", "ub", "web", "ext", "sec", "prep", "sim", "stat", "watch", "slice", "rob", "sl", "sup", "pb", "nil", "lib", "utils", "var", "sum", "com", "other", "b", "sc", "seq", "mod", "job", "syn", "sur", "bs", "tag", "dev", "subject", "ch", "desc", "sing", "sam", "cond", "pl", "ver", "embed", "con", "pkg", "pred", "pop", "reg", "pre", "sel", "control", "super", "sb", "rc", "repl", "sq", "th", "so", "exec", "Sub", "sci", "supp"], "pred_order": ["predpostend", "permationorder", "pred_ord", "seqpostend", "pred_Order", "seq_end", " pred_orders", " pred_err", "permationoffer", "predpostord", "pred_num", "pred_key", " pred_unit", "pred_orders", "perm_index", "pred_end", "pred_err", "seq_order", "predulooffer", "predationoffer", "predpostorder", "predationorders", "pred_unit", "permationkey", "predulokey", "permationindex", "preduloorder", "preduloindex", "perm_key", "pred_index", "pred_offer", "seqpostord", "predationorder", " pred_num", "predationunit", "seqpostorder", "seq_Order", "predpostOrder", "predationindex", "perm_order", "predationnum", "seq_ord", "seqpostOrder", "perm_offer", "predationkey"], "p": ["d", "j", "cp", "wp", "lp", "l", "pro", "jp", "pc", "c", "ep", "port", "g", "n", " P", "P", "r", "pi", "bp", "np", "app", "pp", "m", "b", "x", "pg", "pos", "pe", "vp", "at", "pad", "pr", "ps", "tp", "pat", "ip", "perm", "pa", "k", "xp", "ap", "pl", "pkg", "pt", "post", "v", "pre", "per", "o", "h", "pers", "point", "t", "ping", "sp"], "porder": [" pkey", " pversion", " pme", "prank", "permrender", "pcfield", "pnder", "porders", "piorder", "permgrade", " pder", "pinforce", "pporder", " ppriority", "permpriority", "pnumber", " pnumber", "pme", "pcinfo", "pprender", "ppgrade", "pder", "pprank", "pposition", " pgrade", "pame", "pinversion", "ppriority", "pforce", "pversion", "painfo", "ppposition", "pafield", "permorder", "crank", " prank", " porders", "pgrade", "ppkey", " pposition", "prender", "ppder", "pinnumber", "pnkey", "pnposition", "piforce", "pinorder", "pnorder", "piversion", "ppdir", "paorder", "pcorder", "pcme", " pforce", "pfield", "pdir", "cdir", "pppriority", "pinfo", "pinumber", " prender", "pporders", " pdir", "pkey", "corder", "corders", " pinfo", " pfield"], "psize": ["fpsization", "ppsize", "sssize", "ppsizer", "rsization", "fpsize", "alsize", "ppsization", "upssize", "ipssize", "fpsizer", "persization", "psizable", "rsizer", "upsization", "alsization", "ssizable", "rsized", "apsization", "apssize", "persizer", "ssization", "psized", "persize", "ppsizable", "rsize", "upsize", "msized", "ssize", "apsizer", "alsizer", "alsized", "psiz", "ipsizable", "persiz", "ppsiz", "msizer", "msization", "ipsize", "ipsization", "psizer", "msize", "pssize", "ppssize", "psization", "upsizer", "apsize", "fpsiz"], "i": ["j", "id", "l", "ii", "jp", "c", "is", "xi", "ic", "pi", "index", "ish", "iter", "ci", "li", "m", "x", "u", "info", "start", "phi", "it", "at", "ij", "ip", "end", "fi", "y", "pa", "k", "bi", "e", "iu", "ti", "ir", "ind", "ix", "ia", "v", "in", "mi", "di", "ini", "h", "ai", "si", "I", "pid", "point", "iat", "sp"], "part_end": [" part_ends", " part_ender", " part_start", "part_ends", "part_start", "part2end", "partJEND", " part_END", "partJstop", "partJpend", "part_End", "part_stop", "part_ender", "part2ends", "part7END", "partJend", "partMemedge", "part_edge", "part64end", "part64ender", "part7stop", " part_End", "part_begin", " part_pend", " part_stop", "partMemend", "part7end", " part_edge", "part_pend", "part2start", "part_END", " part_begin", "part7pend", "partMemEnd", "part2begin"]}}
{"project": "qemu", "commit_id": "24408a7d2b459bed3697367b81ada76518ca96ef", "target": 0, "func": "static void ppc_spapr_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    const char *boot_device = args->boot_order;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    hwaddr rma_alloc_size;\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, rtas_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    spapr = g_malloc0(sizeof(*spapr));\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        hw_error(\"qemu: Unable to create RMA\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = ram_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    /* We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary */\n\n    rtas_limit = MIN(spapr->rma_size, 0x80000000);\n\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\n\n                                  XICS_IRQS);\n\n    spapr->next_irq = XICS_IRQ_BASE;\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n\n\n        xics_cpu_setup(spapr->icp, cpu);\n\n\n\n        /* Set time-base frequency to 512 MHz */\n\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n\n\n\n        /* PAPR always has exception vectors in RAM not ROM. To ensure this,\n\n         * MSR[IP] should never be set.\n\n         */\n\n        env->msr_mask &= ~(1 << 6);\n\n\n\n        /* Tell KVM that we're in PAPR mode */\n\n        if (kvm_enabled()) {\n\n            kvmppc_set_papr(cpu);\n\n        }\n\n\n\n        qemu_register_reset(spapr_cpu_reset, cpu);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    spapr->ram_limit = ram_size;\n\n    if (spapr->ram_limit > rma_alloc_size) {\n\n        ram_addr_t nonrma_base = rma_alloc_size;\n\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n\n\n\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n\n        vmstate_register_ram_global(ram);\n\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n\n                                           rtas_limit - spapr->rtas_addr);\n\n    if (spapr->rtas_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus)) {\n\n        spapr->has_graphics = true;\n\n    }\n\n\n\n    if (usb_enabled(spapr->has_graphics)) {\n\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        if (spapr->has_graphics) {\n\n            usbdevice_create(\"keyboard\");\n\n            usbdevice_create(\"mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              load_limit - KERNEL_LOAD_ADDR);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n", "idx": 43, "substitutes": {"args": ["doc", "values", "aux", "atts", "arr", "images", "limits", "actions", "objects", "words", "names", "xs", "comm", "roots", "qs", "ants", "vals", "ids", "params", "locks", "ars", "aws", "units", "parts", "js", "users", "orders", "ads", "ians", "flags", "amps", "terms", "arms", "err", "ts", "keys", "points", "ams", "grades", "changes", "artifacts", "GS", "ags", "bits", "results", "yes", "gs", "arg", "yrs", "apps", "cmd", "Args"], "cpu_model": ["membookmode", "cpu_control", "cpupromode", "cpubookcontrol", "cpu_mode", "cpupronetwork", "membookmodels", "cpu_fine", "membookmodel", "cpu_models", "cpubookmode", "mem_models", "pu_mode", "pu_network", "pu_model", "mem_mode", "cpuprofine", "mem_control", "cpubookmodel", "cpupromodel", "pu_fine", "cpu_network", "cpubookmodels", "membookcontrol", "mem_model"], "kernel_filename": ["kernelityfilename", "system_file", "kernel___file", "system_subject", "kernel_subject", "kernel_file", "kernel_module", "cpu_module", "kernelityfolder", "system_folder", "cpu_location", "kernelitysubject", "kernel_location", "system_filename", "kernel___subject", "cpu_filename", "kernel_folder", "kernelityfile", "kernel___folder", "kernel_files", "cpu_files", "kernel___filename"], "kernel_cmdline": ["kernel_bindLine", "kernel_commandname", "kernel_bindlines", "kernel_bindline", "kernel_commlines", "kernel_cpname", "kernel_commline", "kernel_commandlines", "kernel_cpline", "kernel_commandLine", "kernel_commpoint", "kernel_commandline", "kernel_bindname", "kernel_cmdlines", "kernel_cpLine", "kernel_cmdpoint", "kernel_cmdname", "kernel_commandpoint", "kernel_cmdLine", "kernel_bindpoint"], "initrd_filename": ["initrb_label", "initrd___label", "initrb_prefix", "initrd_file", "initrd__filename", "initrd___prefix", "initrd__file", "initrb_directory", "initrd_location", "initrd__prefix", "initrd_prefix", "initrb_file", "initrd___filename", "initrd_label", "initrb_filename", "initrd_directory", "initrb_location", "initrd___file", "initrd__label"], "boot_device": ["start_register", "boot_option", "start_option", "start_device", "start_order", "boot_order", "boot64register", "boot64device", "boot_register", "boot64order", "boot64option"], "cpu": ["proc", "core", "cp", "net", "phys", "pc", "c", "chip", "conn", "pu", "hw", "gpu", "CPU", "util", "processor", "linux", "cache", "prof", "cow", "boot", "vm", "ctx", "pool", "gc", "clock", "cu", "process", "mem"], "env": ["proc", "ec", "eas", "er", "sh", "ext", "ev", "me", "her", "environment", "ei", "em", "pe", "cur", "dev", "ef", "eu", "end", "vm", "e", "el", "en", "here", "ctx", "ew", "te", "worker", "pid", "eng"], "phb": ["PHp", "phbp", "php", " phbp", "Phbs", "phbs", " php", "Phbp", "PHbs", "PHb", "PHbp", "Phb", "Php", " phbs"], "i": ["j", "l", "et", "z", "p", "n", "pi", "r", "ci", "li", "m", "b", "x", "it", "ip", "y", "bi", "im", "e", "io", "ia", "v", "h", "si", "I", "f", "a", " bi"], "sysmem": ["Sysreg", "systemmem", "ysmeta", " sysmemory", " sysmeta", "ysMem", "sysreg", "Sysmemory", " sysMem", "ysmem", "sysMem", "sysmemory", "systemmeta", "ysmemory", "systemmemory", "ysreg", "Sysmem", "systemMem", " sysreg", "sysmeta"], "ram": ["ma", "mb", "ro", "rom", "iam", "fam", "row", "lim", "memory", "res", "ra", "dev", "gram", "vm", "cam", "sam", "RAM", "rum", "reg", "mm", "am", "range", "process", "Ram", "rem", "mem", "tem", "gra"], "rma_alloc_size": ["rma_alloc_sum", "rma_mem_size", "rma_ptr_data", "rma_ptr_Size", "rma_mem_storage", "rma_buf_sum", "rma_alloc_address", "rma_mem_address", "rma_alloc_count", "rma_ptr_size", "rma_alloc_space", "rma_alloc_data", "rma_alloc_Size", "rma_allocxlen", "rma_max_SIZE", "rma_mem_name", "rma_max_string", "rma_alloc_storage", "rma_alloc_SIZE", "rma_alloc_ize", "rma_alloc_string", "rma_alloc_name", "rma_ptr_len", "rma_alloc_len", "rma_buf_space", "rma_buf_size", "rma_max_size", "rma_buf_len", "rma_buf_count", "rma_allocxspace", "rma_allocxsize", "rma_mem_ize"], "load_limit": ["load2limit", "loadablepolicy", "loadablelimits", "lengthablelimits", "Load_limit", "loadablelimit", "length_limits", "load2lim", "length_policy", "lengthablelimit", "load_policy", "load2size", "lengthablepolicy", "Load_size", "length_lim", "load_size", "lengthablelim", "Load_lim", "length_limit", "load_limits", "loadablelim", "load_lim"], "rtas_limit": ["rtlas_adjust", "rtas_adjust", "rtas67set", "rtas_link", "rtas67size", "rtAs_limit", "rtAs_link", "rtas_set", "rtlas_Limit", "rtas_Limit", "rtlas_size", "rtas67limit", "rtAs_level", "rtAs_set", "rtas_lim", "rtlas_limit", "rtas_level", "rtAs_size", "rtas_size", "rtAs_lim", "rtas67level"], "fw_size": ["hw_SIZE", "fw_SIZE", "hw_size", "hw_Size", "fw_Size"], "filename": ["fp", "fil", "kan", "format", "ename", "seek", "files", "kj", "processor", "params", "ame", "fs", "family", "location", "writer", "username", "metadata", "nm", "uri", "framework", "Filename", "original", "fn", "prefix", "socket", "jpg", "json"], "spapr": ["spapperrb", "spaptu", "sphaperr", "spapren", "ppapar", "spaprb", "ppapru", "ppapprer", "scopeapterr", "ispaprb", "repapestr", "sphapcr", "spiprer", "spapperren", "spapprt", "spashi", "spaptrb", "spcapr", "spapers", "spapear", "ppaptdr", "spapprer", "isparmi", "repmapr", "spapedr", "spashd", "spaspren", "espaprt", "serviceapd", "spapsrr", "spapeerr", "spappner", "ispapr", "ppape", "ppmape", "sparmr", "spaperrar", "spapprc", "spashr", "spapeu", "espaprb", "spaprc", "espcaprer", "serviceape", "ppaptar", "spaperbr", "spmapr", "spaperr", "processaprar", "repapbr", "spappr", "scopeaptr", "spaspr", "spappp", "espcapr", "scopeapr", "spappdr", "spaptner", "ppaprs", "spappe", "spmapcr", "ppapterr", "spopr", "processapr", "spapp", "spasprs", "sparmi", "espcaprb", "spipru", "servicerapr", "processapperr", "spashrar", "spagr", " spopr", "spapdr", "spaprt", "spaperrb", "spajar", "espajar", "sphapbr", "repapcr", " spopcr", "spaprer", "spagrer", "espapcr", "spmapp", "spaper", "processapperrar", " spaprer", "ppaperr", "spapterr", "sparmrar", "ppmapr", "spappru", "serviceapr", "repapscr", "spcapcr", "serviceaprar", "ispaprar", "repaprb", "isparmrb", "isparmr", "spaperren", "spagrb", "spagcr", "spapsr", "spaptrc", "sprapd", "processaprb", "repaprr", "spashe", "spaspstr", "repapsr", "spajrt", "spipr", "repapr", "spapi", "spaptcr", "sphaprc", "scopeaprc", "spapercr", "ppapprs", "ppaptr", "repapsrr", "spaprr", "spcaprs", "spiprs", " spoprer", "spappar", "processapperren", " spaprb", "sprapr", "spaperar", "scopeaptrc", "spapsrb", "espapar", "processapren", "spaptrt", "spappre", "processapperrb", "espajrer", "spmapu", "sphapr", "spmaprer", "repapsbr", "repaperen", "ppapre", "ppappru", "spcapru", "spaptdr", "spaprar", "spoprb", "isparmrar", "scopeaperr", "serviceraprar", "espaprer", "spoprer", "spapti", "spaped", "spapprs", "spaperrr", "spapperrar", "spopp", "spraprar", " spapcr", "spmaprb", "servicerapd", "spapar", "spajr", "spapecr", "spape", "spcaprer", "spopre", "spmape", "scopeaptner", "spashrb", "sparmren", "repapu", "spaperen", "sphapner", "spapner", "repapstr", "spaptrer", "spapsbr", "espapr", "ppapr", "repmaprb", "spajrer", "repmapu", "repapren", "spcaprb", "spapperrs", "spapru", " spoprb", "ppmapre", "spaptar", "scopeapner", "repmapcr", "spaptrar", "spopcr", "sprape", "spapd", "sparmrb", "servicerape", "spapcr", "ppmapp", "repapers", "spaptr", "spapee", "sphaprr", "espcapcr", "espajr", "ispapi", "repaprs", "spapsrer", "spapu", "spope", "espajrt", "spapscr", "spapbr", "ppapp", "spapperr", "ppapdr", "spapstr", "repaper", "ppaprer", "spapestr", "spmapre", "spaperb", "spaprs", "spapperstr", "spapre", "ppappr"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n", "idx": 60, "substitutes": {"avctx": ["avctl", "avergc", "avconn", "avectx", "avectl", "Avcontext", "avercontext", "avjac", "avobj", "avertx", "AVconn", "vercu", "averctl", " avctl", " avca", "avca", "evtx", "ajgc", "Avconn", "wavjac", "avpkg", "avecontext", "avercu", "averca", " avtmp", "abbuf", "avercfg", "AVcontext", "vertx", "wavtx", "avtx", "avcu", " avcfg", "ajctx", "ajca", "abctx", "Avtx", " avcontext", "avgc", " avobj", "evcontext", "averobj", "avecmp", "avetmp", "svjac", "Avctx", "avebuf", "AVbuf", "wavcp", " avgc", "evjac", "avepkg", "wavpkg", "avetx", "wavctx", "avbuf", "AVtx", "verctx", "evctx", "avcp", "AVctx", "averjac", " avconn", "avcfg", "avertmp", "avtmp", " avcp", " avcmp", "svcontext", "aveconn", "ajcontext", "avecp", "avercmp", "abcontext", "avecfg", "averconn", " avpkg", " avtx", "AVobj", "wavcontext", " avjac", "avcontext", "verconn", "abobj", " avcu", "svctx", "aveobj", "avcmp", "averctx", "svtx"], "buf": ["data", "br", "tmp", "mb", "code", "bc", "p", "text", "img", "ref", "window", "pb", "read", "bp", "out", "cb", "rb", "b", "msg", "seq", "block", "buffer", "cv", "err", "w", "ctx", "bg", "Buffer", "bin", "db", "fb", "queue", "bytes", "max", "bf", "raw", "uf", "cmd", "buff"], "buf_size": ["buf_SIZE", "buf_Size", "buf_len", "buf2Size", "queue_size", "buf2len", "queue_len", "queue_Size", "buf2size", "buf2SIZE", "queue_SIZE"], "s1": ["hs1", " sOne", "ssOne", "sOne", "hs2", "ts1", " sone", "js2", "sts01", "s01", "tsone", "lsone", "tsOne", "sts1", "ss01", "jsOne", "ts2", "sone", "lsOne", " s2", "hsone", "ls2", "js1", "ss2", "ls1", " s01", "stsOne", "ssone", "jsone", "ss1", "sts2", "s2", "hsOne"], "s": ["ls", "sis", "c", "scl", "p", "es", "n", "ses", "set", "params", "us", "its", "conf", "cs", "spec", "an", "h", "gs", "f", "sb", "args", "os", "a", "stats", "sv", "settings", "vs", "details", "ds", "qs", "m", "less", "bs", "ims", "bis", "sam", "hs", "sts", "ins", "sq", "esm", "sync", "acs", "S", "l", "ss", "als", "comm", "csv", "tes", "sym", "ns", "sw", "y", "ms", "ts", "changes", "tests", "se", "ops", "sys", "status", "is", "g", "times", "b", "fs", "aws", "ps", "parts", "js", "w", "e", "comments", "as", "sports", "sm", "rs", "bits", "ats", "t", "obj"], "height": ["ty", "bottom", "visible", "window", "html", "above", "volume", "hei", "buffer", "embed", " Height", "hash", "h", "alpha", "sky", "dim", "ht", "huge", "zh", "high", "tight", "count", "gravity", "row", "holes", "lat", "shape", "xy", "range", "display", "depth", "angle", "padding", "root", "grow", "th", "length", "capacity", "gh", "total", "size", "host", "style", "rank", "confidence", "memory", "cache", "history", "title", "kw", "y", "level", "radius", "scale", "results", "quality", "rows", "he", "Height", "through", "docker", "resolution", "crop", "wh", "hold", "table", "ip", " heights", "show", "ows", "bits", "hang", "density"], "i": ["id", "q", "l", "ii", "p", "g", "n", "pi", "index", "ci", "m", "b", "x", "info", "it", "ij", "y", "iu", "ix", "ia", "mi", "h", "I", "si", "f"], "v": ["vc", "q", "l", "value", "c", "V", "sv", "qv", "p", "z", "g", "n", "vt", "m", "b", "u", "va", "vp", "iv", "lv", "k", "w", "e", "h", "uv", "av", "f"], "j": ["jump", "q", "l", "jp", "ji", "c", "aj", "uj", "z", "p", "g", "n", "kj", "m", "b", "pos", "J", "jl", "ij", "js", "y", "k", "jc", "f", "jj", "json"], "aspect": ["iaspect", "accessio", "ancel", " Aspects", "raspects", "assform", "aspection", "aupection", "arpects", "ario", "asception", "iaspecting", "raspecting", "aception", "nascel", "accesspect", "aspects", "ascel", "raspect", "aspi", "asio", "anpi", "ASspect", " Aspect", " Aspi", "assception", "aupect", "naspi", "nasspect", " Aspecting", "accessspect", "xpect", "iaspects", "auform", "xpects", "asspection", "iaspi", "ASpect", "apect", "asform", "accesspects", "apection", "raspi", "xspect", "AScel", "aform", "arpect", "asspect", "xio", "anspect", "anpect", "naspect", "auception", "aspecting", "arspect", "ASpi"]}}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 70, "substitutes": {"drc": ["pdrh", "Disco", "pdsoc", "prc", "didsoc", " drs", "drom", "ksrc", "hdsrc", " drom", "dRC", " darc", " dsoc", "didRC", " dirc", "pdRC", " dric", "drh", "Drh", "krc", "Dric", "psrc", "darc", "pdrc", "Dirc", "dirc", " dsrc", "dsoc", "ddRC", "hdRC", "dric", "pduc", "prs", "hdisco", "duc", "krs", "pdric", "didrom", "dduc", "didrc", "dsrc", "ddarc", "Dsrc", "DRC", " duc", "pdrom", "drs", "didric", "pirc", "Drc", "pdirc", "disco", "hdrc", "didsrc", "didisco", "kirc", " dRC", "ddrc", "pdarc", " drh"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 83, "substitutes": {"r": ["usr", "gr", "ro", "c", "p", "hr", "ren", "x", "ur", "request", "req", "pr", "sr", "rf", "ry", "h", "ret", "re", "this", "mr", "br", "d", "q", "lr", "result", "rb", "m", "u", "kr", "rec", "rr", "ar", "remote", "tr", "rel", "rar", "R", "rd", "j", "cr", "l", "er", "nr", "vr", "all", "ref", "res", "i", "run", "error", "err", "fr", "rl", "or", "v", "rem", "rc", "repl", "item", "rg", "g", "rer", "attr", "rect", "rate", "rw", "b", "w", "e", "rh", "adr", "rt", "reg", "rs", "o", "t", "obj", "rn"], "s": ["sys", "S", "q", "stats", "c", "is", "ss", "p", "es", "sl", "ds", "qs", "res", "i", "b", "fs", "ps", "js", "ns", "bs", "y", "w", "cs", "spec", "sts", "rs", "v", "sp", "h", "gs", "sb", "os", "sq", "a", "sn"], "n": ["j", "d", "ul", "number", " ng", "l", "size", "c", "no", "nc", "non", "nl", "N", "p", "z", "cn", "g", "np", "names", "out", "m", "i", "b", "x", "num", "ne", "nw", "new", "none", "ll", "nan", "ns", "t", "note", "y", "w", "en", "ln", "nm", "or", "un", "mn", "v", "nt", "h", "o", "nu", "dn", " N", "ot", "nn", "na", "nor", "fn", "nb", "len", "sn"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void lm32_evr_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    hwaddr flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    hwaddr ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    hwaddr timer0_base = 0x80002000;\n\n    hwaddr uart0_base  = 0x80006000;\n\n    hwaddr timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpu_model);\n\n        exit(1);\n\n    }\n\n\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_allocate_system_memory(phys_ram, NULL, \"lm32_evr.sdram\",\n\n                                         ram_size);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init(serial_hds[1]);\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 84, "substitutes": {"machine": ["monitor", "template", "message", "hello", "device", "instance", "host", "sim", "session", "node", "server", "me", "dem", "mode", "engine", "m", "network", "series", "history", "iso", "achine", "Machine", "shell", "cell", "connection", "config", "vm", "agent", "command", "computer", "manager", "mac", "frame", "process", "channel", "handler", "hard", "money", "zone", "model", "state", "module"], "cpu_model": ["cpu2model", "cu_type", "cpu_mode", "cpu2label", "nic67model", "processormymodel", "cpumyrelation", "processormyname", "cpu67location", " cpu_string", "pu_model", "cpu2type", "nic_base", "cpu2link", "cpubookmodel", "nic67location", "cpubookdevice", "nic_link", "cpu67link", "pu_module", " cpu_link", "pu_link", "pu_device", "cpu_vector", "cpu_type", "cpumymodel", "cu_link", "cpu_name", "cpu_base", "cu_label", "cpu_string", "cpu67model", "processor_model", "cpumyname", "cpubookvector", "processormyrelation", " cpu_mode", "processor_name", "cpu_device", "cpu_location", "nic_model", "cpu_label", "pu_name", "cpubookname", "cpu67base", "pu_vector", "cpu_module", "cpu_relation", "nic67base", "nic_location", "processor_relation", "cu_model", "nic67link", "cpu_link"], "kernel_filename": ["system_file", "processor_file", "processor_filename", "kernelamemode", "kernel_file", "system_mode", "system_names", "kernelamefile", "processor_name", "kernelamefilename", "kernel_directory", "kernel_mode", "kernelamenames", "system_filename", "processor_directory", "kernel_names", "kernel_name"], "cpu": ["proc", "core", "ka", "bean", "cp", "arch", "net", "instance", "phys", "pc", "cn", "conn", "chip", "hog", "pu", "hw", "np", "gpu", "CPU", "node", "onet", "comm", "processor", "util", "task", "mx", "cli", "linux", "cache", "pai", "prof", "boot", "loader", "mu", "vm", "normal", "cum", "ilo", "cam", "aco", "ctx", "comp", "home", "computer", "nic", "gc", "runner", "pkg", "bench", "mac", "clock", "cu", "uu", "frame", "process", "program", "nu", "current", "mem", "obj", "base", "module"], "env": ["ec", "net", "eas", "er", "buf", "gear", "ext", "next", "ent", "conn", "org", "init", "ev", "session", "window", "vs", "np", "node", "server", "ner", "viron", "environment", "nv", "visor", "policy", "info", "obs", "priv", "win", "network", "dev", "config", "eu", "shell", "sw", "conf", "vm", "disk", "context", "e", "en", "equ", "ctx", "global", "manager", "mn", "v", "uv", "event", "ve", "estate", "state", "mem", "eng", "map", "Environment", "era"], "dinfo": ["Dinfo", "drfo", "drinfo", "drinf", "ddube", "dno", "rInfo", "rinfo", "drinformation", "rinformation", "dinformation", "didno", "rinf", "rfo", "uinf", "dfo", "didube", " dago", "dinf", "didinfo", "ddinfo", "didago", "Dinf", "uInfo", "uinformation", "dInfo", " dInfo", "Dinformation", "Dfo", " dfo", "dbinfo", " dinformation", " dinf", "uinfo", "ddago", " dube", "dbinformation", "ddno", " dno", "dago", "dube", "dbfo", "dbinf"], "address_space_mem": ["address_space2mem", "address_space_memory", "address_space_ram", "address_area_mem", "address_space2memory", "address_area_ram", "address_area_memory", "address_space2ram"], "phys_ram": ["phys2ram", "phy_room", "sys_disk", "phys_sam", "phys_iam", "phys_room", "physsmem", " phys_iam", "phys_mem", "phys_memory", "phys2mem", "phys______memory", "phys______mem", " phys_sam", "physsram", "phy_memory", "phy_ram", " phys_mem", "phys______ram", "physsdisk", "phys2room", "sys_ram", "physssam", "sys_mem", "phys______room", "phys2memory", "phy_mem", "sys_sam", "phys_disk"], "irq": ["irQ", "ibrq", "ibrve", "IRQ", "ibrQ", "ibriq", "ireq", "ireQ", "iriq", "IRve", "IRq", "ireve", "irve", "IRiq", "ireiq"], "reset_info": ["resetgrdetails", " reset_data", "resetnessinfo", "resetnessInfo", " resetgrdata", "reset_init", "resetgrdata", "resetPrinit", "et_Info", "reseterinit", "resetableInfo", "reseterinfo", "resetnessdetails", "resetgrlock", "resetPrInfo", "etableinit", " reset_details", " reset_Info", "resetableinfo", "et_init", " reset_lock", "et_entry", "resetableentry", "etableInfo", "reset_Info", "et_info", "etableinfo", "resetPrinfo", " resetgrinfo", " reset_init", "reset_details", "resetPrentry", "reset_entry", "reset_lock", "resetableinit", "reset_data", "resetgrinfo", " resetgrlock", "reseterdata", " resetgrdetails", "etableentry"], "i": ["j", "id", "ii", "z", "p", "xi", "pi", "m", "ei", "b", "phi", "ip", "fi", " pi", "e", "iu", "io", "ia", "v", "o", "di", "si", "I", "f", "imm", "t", "a", " bi"]}}
{"project": "qemu", "commit_id": "cf57298af5336df2aece47ef16c290a3a81457dd", "target": 0, "func": "aio_write_f(int argc, char **argv)\n\n{\n\n\tchar *p;\n\n\tint count = 0;\n\n\tint nr_iov, i, c;\n\n\tint pattern = 0xcd;\n\n\tstruct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n\tBlockDriverAIOCB *acb;\n\n\n\n\twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'C':\n\n\t\t\tctx->Cflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tctx->qflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&aio_write_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind > argc - 2)\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n", "idx": 108, "substitutes": {"argv": [" argp", "firec", "argsV", "argss", "argumentvs", "arpv", "matchvs", "argp", "argsver", "argsk", "argsl", "matchm", "argV", "argumentl", "argver", "argsp", "argsvs", "docV", "argumentv", "argsm", "argm", "parv", "agvin", "pars", "Argp", "docv", " argk", "targetm", "targetc", "parc", "agver", "firevin", "targetvin", "matchc", "argk", " argvin", " argl", "arpvs", "firev", " argm", "arguments", "docvs", "argsc", "argl", " argvs", " argc", "argvs", "argsvin", "agc", "agv", "Argv", "Argm", "parvs", "argc", "firever", "arpc", "matchv", "Argc", "args", "argsv", "targetv", "argvin", "argumentp", " argV", "argumentc", "arpk", "docc"], "p": ["fp", "j", "cp", "q", "d", "lp", "l", "op", "jp", "pc", "count", "g", "n", "P", "pb", "r", "np", "pp", "m", "b", "u", "pos", "vp", "it", "at", "pr", "ps", "pat", "tp", "y", "pa", "ap", "pattern", "pl", "pkg", "pt", "v", "o", "h", "f", "t", "a", "ping", "sp"], "nr_iov": ["n_iv", "nrmyiov", "etr_ios", "etrmyios", "NR_ovi", "nr__iv", "etr_ij", "nr_volt", "nr_ovi", "nrmyij", "nr_ij", "nr_yon", "etr_iov", "etr_ibr", "nr_iour", "n__iv", "etrmyiov", "NR_iov", "nr__veh", "nr__iour", "n_veh", "nr___iour", "nrmyios", "nr___veh", "nrpyiv", "n_iov", "n__iour", "nr__iov", "nrpyyon", "NR_iv", "nr___iv", "nr_veh", "our_iov", "n__veh", "our_volt", "our_iv", "nr_ios", "etrmyibr", "nr___iov", "NR_yon", "nr_voice", "nr_iv", "our_voice", "nrpyiov", "nrmyibr", "nrpyovi", "nr_ibr", "n_iour", "etrmyij", "n__iov"], "i": ["multi", "j", "id", "q", "l", "ii", "ki", "tim", "ji", "status", "is", "sim", "g", "n", "xi", "ic", "pi", "index", "me", "qi", "progress", "ci", "li", "iter", "ami", "m", "ei", "b", "x", "cli", "ui", "info", "phi", "gi", "it", "ij", "ex", "ip", "oi", "y", "ims", "bi", "im", "hi", "iu", "ti", "ind", "ix", "v", "zi", "in", "mi", "di", "ini", "\u0438", "ai", "si", "I", "f", "ri", "t", "ite", "this", "chain"], "c": ["ec", "vc", "cp", "fc", "l", "count", "bc", "xc", "unc", "g", "n", "dc", "cb", "m", "b", "x", "ce", "C", "cont", "cmp", "k", "ch", "cf", "tc", "e", "cs", "con", "co", "coll", "gc", "v", "abc", "cc", "o", "ct", "h", "cl", "col", "f", "lc", "ac", "t", "mc", "a"], "ctx": ["cp", "ctr", "parent", "tmp", "mom", "unc", "hw", "window", "bp", "gt", "req", "t", "ctl", "conf", "k", "cf", "context", "xp", "pkg", "wrapper", "wx", "handler", "Context", "ck", "resp", "timeout", "fn", "jac", "ctrl", "acl", "settings", "np", "crit", "cb", "act", "kt", "msg", "check", "cmp", "cookie", "gc", "co", "loc", "nt", "expr", "cm", "std", "obj", "cas", "addr", "nc", "dc", "index", "utils", "history", "kw", "that", "abc", "val", "client", "prefix", "exec", "cmd", "proc", "sys", "today", "fc", "func", "xc", "conn", "ca", "txt", "cfg", "tx", "tm", "tz", "config", "scope", "cv", "px", "cu", "cc", "ct", "lc", "iat", "tc", "module"], "acb": ["icbd", " acbd", " acbr", "ACbd", "sacb", " acB", "accB", "acsb", "icsb", "ACsb", "acbd", "ACB", "sacB", "accb", "ACb", " acsb", "accbr", "acgb", "acbr", "accgb", "icb", " acgb", "sacgb", "sacbr", "icB", "acB"], "optind": ["optimmind", "OptInd", "altind", "optedIND", "opInd", "optwind", "optinder", "opinder", " optcount", "optval", "optmind", "timeoutini", "optimindex", "optionsindex", "optionmind", "stopinf", "stoploc", "altindex", "optedind", "Optindex", "opcount", "Optwind", "optimval", "altinder", "Optbind", "stopind", " optInd", "optimnd", "optnd", "ossval", "optinn", "optedine", "mmcond", "opIND", "optedbind", "timeoutind", "optionindex", " optindex", "optedindex", "optiminn", "ossinn", "optcount", "timeoutmind", "optedwind", "optInd", "optimInd", "Optval", "timeoutindex", " optwind", "mmini", " optnd", "timeoutcond", "optine", "optionsinn", "optedloc", "opindex", "ossindex", "stopine", "optedInd", "optimind", "optimloc", "Optcount", "mmind", "optimini", "optbind", "altIND", "optcond", "fitind", "optionsmind", "Optind", "optionIND", "ossind", "opind", "optionsind", "optimcond", "opcond", "optloc", "opnd", "optindex", "optedcond", " optIND", "timeoutinn", "optini", "Optinn", "fitindex", "optiminf", "optioninn", "optionbind", "optimine", "optIND", "optinf", " optcond", "optedinf", "fitIND", "OptIND", "optionind", "mmmind", "fitinder"], "len": ["ls", "ele", "cp", "format", "lic", "n", " bl", "kl", "iter", "li", "lf", "led", "gt", "lon", "lig", "body", "pre", "lif", "ler", "line", "fn", "lis", "mem", "ld", "count", "Len", "link", "full", "num", "msg", "lan", "ll", "cmp", "fl", "tl", "ln", "alt", "del", "offset", "els", "elt", "length", "le", "l", "size", "nl", "all", "fun", "gl", "la", "sl", "ellen", "lt", "gen", "compl", "dl", "err", "el", "en", "str", "bin", "val", "loop", "repl", "doc", "lp", "il", "L", "lib", "url", "fin", "lit", "pos", "vec", "pl", "coll", "ell", "mat", "bl", "ml", "lc"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 121, "substitutes": {"dest": ["usr", "parent", "cp", "ctr", "tmp", "match", "port", "route", "server", "iter", "out", "gest", "sum", "reason", "axis", "opt", "output", "wait", "spec", "nom", "est", "dim", "mem", "d", "comb", "list", "shift", "source", "pipe", "dep", "sort", "result", "dist", "coord", "task", "reverse", "msg", "check", "it", "trans", "ptr", "search", "gate", "alt", "loc", "tr", "rel", "chain", "Dest", "buf", "rest", "host", "addr", "dc", "decl", "dat", "dev", "comment", "save", "v", "last", "target", "address", "draw", "src", "master", "sp", "success", "transfer", "mount", "add", "temp", "status", "way", "table", "pos", "orig", "cont", "start", "delete", "transform", "desc", "copy", "origin", "global", "good", "st", "seed", "store"], "linesize": ["linesiz", "valsize", "linesizes", "csizes", "linesizable", " linesiz", "lsizer", "csizer", "lsizable", "valsiz", "lsiz", "csizable", "linesIZE", "inesize", "inesizable", " linesIZE", " linesizes", "lsIZE", "inesizer", "valsIZE", "lsizes", "csize", "valsizes", "lsize", "inesizes", "linesizer"], "block": ["Block", "list", "word", "source", "record", "row", "BL", "box", "node", "set", "link", "pixel", "pack", "load", "lock", "check", "entry", "type", "stop", "ip", "cell", "trans", "param", "buffer", "copy", "bin", "group", "bl", "field", "cl", "event", "unit", "line", "bf", "point", "scan", "join", "map", "chain"], "i": ["multi", "batch", "j", "q", " m", "ii", "ki", "c", " j", "is", "sim", "n", "init", "xi", "ic", "pi", "asi", "me", "iter", "index", "ci", "li", "qi", "m", "ei", "x", "ui", "phi", "it", " ti", "ip", " ii", "y", " pi", "ims", " x", "bi", "im", "iu", "ti", " I", " iter", " v", "ind", "ix", "print", "v", "zi", "mi", "di", "ini", "ai", "I", "si", " err", "point", " bi"], "cm": ["mr", "mt", "ace", "cp", "ctr", "gr", "fc", "cd", "cr", "mb", "c", "pc", "mask", "cn", "km", "bm", "rom", "dc", "fine", "ca", "CM", "pm", "cy", "mode", "ci", "mp", "ym", "comm", "csv", "m", "com", "form", "cont", "wm", "asm", "cmp", "conf", "ch", "vm", "cv", "tc", "um", "cs", "copy", "co", "cut", "gc", "nm", "hm", "mm", "rm", "cc", "sem", "ct", "cl", "gm", "lc", "ck", "mc", "fm", "module", "cmd"]}}
{"project": "qemu", "commit_id": "301c7d38a0c359b91526391d13617386f3d9bb29", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n        const char *desc_file_path)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    Error *local_err = NULL;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,\n\n                             &local_err);\n\n        if (ret) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n            VmdkExtent *extent;\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, sectors, &extent);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n\n            if (ret) {\n\n                bdrv_unref(extent_file);\n\n                return ret;\n\n            }\n\n        } else {\n\n            fprintf(stderr,\n\n                \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type);\n\n            return -ENOTSUP;\n\n        }\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p && *p != '\\n') {\n\n            p++;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 122, "substitutes": {"desc": ["doc", "ec", "id", "cd", "buf", "pc", "phrase", "dc", "description", "ref", "txt", "pb", "Desc", "label", "out", "dist", "path", "asc", "esc", "cont", "sc", "seq", "cur", "pat", "sub", "comment", "ptr", "err", "rec", "ctx", "bl", "rc", "resp", "lc", "des", "cmd"], "bs": ["sys", "ls", "bank", "bc", "bh", "bd", "bm", "vs", "pb", "bp", "ses", "ds", "cb", "qs", "b", "fs", "ubs", "lbs", "BS", "obs", "ps", "its", "bos", "aos", "ns", "js", "bt", "bi", "bis", "ms", "cs", "ts", "ks", "bps", "rs", "bl", "bits", "gs", "bas", "sb", "bf", "bn", "acs"], "desc_file_path": ["desc_File_path", "desc_file_ref", "desc_File_ref", "desc_file_name", "desc_File_Path", "desc_file_Path", "desc_File_name"], "ret": ["mt", "usr", "RET", "try", "format", "n", "iter", "out", "x", "ne", "gt", "ber", " Ret", "state", "got", "backed", "ry", "rm", "hash", "stay", "reset", "resp", "re", "back", "net", "result", "deg", "ll", "it", "Ret", "final", "rot", "alt", "ter", "rev", "get", "del", "nt", "arg", "tr", "cert", "elt", "jump", "j", "cat", "jp", "dt", "code", "fun", "bool", "lt", "res", "run", "att", "prot", "err", "val", "last", "rets", "det", "rem", "flag", "gov", "len", "cmd", "inter", "arm", "status", "arr", "value", "after", "r", "txt", "lit", "ft", "red", "cont", "def", "rt", "print", "t", "obj"], "access": ["arch", "acc", "ace", "Access", "id", "ma", "test", "acl", "key", "status", "code", "aw", "use", "mask", "ext", "view", "ast", "seek", "row", "attr", "upload", "read", "index", "ref", "ca", "mode", "ax", "path", "action", "asc", "act", "assert", "esc", "url", "usage", "seq", "sc", "priv", "req", "att", "ex", "accessible", "config", "accept", "cast", "owner", "name", "alias", "sect", "str", "array", "exclusive", "ha", "pass", "est", "max", "ac", "sha", "scan", "area", "length"], "type": ["core", "sys", "Type", "ype", "ty", "test", "key", "size", "status", "dt", "code", "view", "port", "style", "all", "to", "sort", "description", "ref", "index", "kind", "path", "table", "action", "link", "info", "pe", " Type", "shape", "cmp", "title", "time", "tag", "file", "block", "error", "otype", "buffer", "cast", "version", "color", "name", "ver", "TYPE", "role", "alias", "class", "types", "range", "null", "address", "te", "t", "ime", "length", "ping", "typ"], "fname": ["cfnames", "Fpath", "Ftype", "fullnames", "fulltype", "Fname", "lfName", "fpath", "lfpath", "fName", " fnames", "FName", " fpath", "cfName", " fName", "fullpath", "fullName", " ftype", "fullname", "lfname", "fnames", "cfname", "cfpath", "lftype", "Fnames", "ftype"], "p": ["fp", "d", "cp", "q", "j", "lp", "l", "jp", "c", "pc", "g", "n", "P", "r", "pb", "s", "pp", "path", "m", "b", "pr", "ps", "pat", "tp", "y", "pa", "ptr", "e", "ap", "pt", "v", "h", "pers", "f", "par", "rep", "t", "ping", "sp"], "flat_offset": ["flush_address", "flatrowop", "flatMemoffset", "flatMemaddress", "flat_data", "flatzshift", "flat_set", "full_shift", "flat_origin", "flatstartorigin", "utf_op", "utf_limit", "flatrowoffset", "flat__origin", " flat_pos", "flat_op", " flat_offs", "flatzcount", "flatzOffset", "full_offset", "full_Offset", "flatrowset", "flat__Offset", "flat_shift", "flat_offs", "flat_address", "flat_Offset", "flush_offset", "flatMemdata", "utf_set", "flat__offset", "flush_data", "flat_pos", "flush_Offset", "flatMemOffset", "flatstartoffset", "flat___Offset", "utf_offset", "flatrowlimit", " flat_origin", "flatzoffset", "flat___offset", "flatstartOffset", "flat__pos", "full_count", "flat_limit", "flatstartpos", "flat_count", " flat_Offset", "flat___offs"], "extent_path": ["extend_path", "extent_name", "extention_group", "extent_group", "extent_Path", "extents_path", "extention_Path", "extent___file", "extend_Path", "extent_pointer", "extents_Path", "extent___name", "extents_name", "extents_file", "extent___pointer", "extent___path", "extention_file", "extend_name", "extend_pointer", "extend_file", "extention_path"], "extent_file": ["extent_field", "extents_fp", "extentsfile", "extentsfiles", "extent_fp", "extentiparray", "extent2file", "extents_path", "extentsarray", "extend_field", "extend_array", "extent_File", "extents_files", "extant_File", "extent_array", "extant_file", "extentipfiles", "extentipfile", "extents_file", "extent_files", "extend_file", "extent2fp", "extentsfield", "extent2path", "extent2files", "extentipfield", "extend_files", "extant_base", "extent_base"], "local_err": ["locallyattr", "locallyerr", " local_msg", "local_conf", "local_state", "localErerr", "master_err", "total_err", "local___err", "local1sys", "local___attr", "local1conf", " local_error", "local_attr", "locallyerror", "local___rr", "locallystate", " local_res", "local_sys", "local1err", "totallystate", "totallyerr", "local_res", "total_cfg", "master_sys", "local___er", "local1attr", "totallyerror", "master_attr", "total_state", " local_rr", "local___sys", "masterlyconf", " local_er", "locallyconf", "localErerror", "local_error", "localErcfg", "localErstate", "local_cfg", "masterlyerr", "local_rr", "locallycfg", "masterlyattr", "local___conf", "master_conf", "totallycfg", "masterlysys", "total_error", "locallysys", "local___res", "local_msg", "local_er"], "extent": ["exant", "ordency", "existented", "Extend", "extented", "indension", "contency", "indency", "contension", "Extency", "ordension", "exent", "Extent", "xtented", "contant", "indent", "xtend", "extant", "indant", "content", "xtency", "exented", "xtant", "txtent", "txtend", "existent", "ordant", "xtent", "ordent", "Extant", "extension", "extend", "existant", "txtency", "extency", "txtant", "exency", "existency"]}}
{"project": "FFmpeg", "commit_id": "323e6fead07c75f418e4b60704a4f437bb3483b2", "target": 1, "func": "static void compute_rematrixing_strategy(AC3EncodeContext *s)\n\n{\n\n    int nb_coefs;\n\n    int blk, bnd, i;\n\n    AC3Block *block, *block0;\n\n\n\n    s->num_rematrixing_bands = 4;\n\n\n\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n\n        return;\n\n\n\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        block = &s->blocks[blk];\n\n        block->new_rematrixing_strategy = !blk;\n\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n\n            /* calculate calculate sum of squared coeffs for one band in one block */\n\n            int start = ff_ac3_rematrix_band_tab[bnd];\n\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            CoefSumType sum[4] = {0,};\n\n            for (i = start; i < end; i++) {\n\n                CoefType lt = block->mdct_coef[0][i];\n\n                CoefType rt = block->mdct_coef[1][i];\n\n                CoefType md = lt + rt;\n\n                CoefType sd = lt - rt;\n\n                sum[0] += lt * lt;\n\n                sum[1] += rt * rt;\n\n                sum[2] += md * md;\n\n                sum[3] += sd * sd;\n\n            }\n\n\n\n            /* compare sums to determine if rematrixing will be used for this band */\n\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n\n                block->rematrixing_flags[bnd] = 1;\n\n            else\n\n                block->rematrixing_flags[bnd] = 0;\n\n\n\n            /* determine if new rematrixing flags will be sent */\n\n            if (blk &&\n\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n\n                block->new_rematrixing_strategy = 1;\n\n            }\n\n        }\n\n        block0 = block;\n\n    }\n\n}\n", "idx": 149, "substitutes": {"s": ["sys", "ls", "sync", "S", "j", "stats", "c", "sg", "sv", "ss", "p", "es", "settings", "conv", "n", "g", "times", "stat", "details", "ses", "comm", "set", "ds", "qs", "m", "b", "x", "space", "fs", "less", "services", "aws", "series", "syn", "ps", "parts", "js", "ns", "bs", "sw", "scl", "http", "conf", "ex", "comments", "e", "span", "cs", "ts", "spec", "sts", "eps", "rs", "bits", "gs", "source", "ats", "sb", "sq", "os", "t", "a", "ops", "self"], "nb_coefs": ["nb_coecp", "nb_coefficientses", "nb_coefficientsers", "nb_coafS", "nb_coefficientsp", "nb_coeffe", "nb_coecls", "nb_coefficients", "nb_codefs", "nb_conefls", "nb_coefficiente", "nb_coefers", "nb_conefficientses", "nb_coefS", "nb_couferences", "nb_coefp", "nb_coefts", "nb_coafts", "nb_coefficientsts", "nb_conffers", "nb_coefficientsS", "nb_coafls", "nb_coefficienters", "nb_coecs", "nb_coafers", "nb_conefe", "nb_conefficientsts", "nb_coefes", "nb_coefls", "nb_coefe", "nb_conefficientsS", "nb_coffs", "nb_cofferences", "nb_coefficientsls", "nb_coeffp", "nb_coffe", "nb_conefers", "nb_coafes", "nb_conefts", "nb_coecerences", "nb_conffs", "nb_conefS", "nb_coffS", "nb_codefts", "nb_coffers", "nb_coufes", "nb_coeferences", "nb_coufS", "nb_coneferences", "nb_conffe", "nb_coafs", "nb_conefficientss", "nb_coefficientserences", "nb_codefers", "nb_conefficientsers", "nb_conefs", "nb_coufs", "nb_coufls", "nb_coeffs", "nb_coefficientss", "nb_conefes", "nb_coefficienterences", "nb_coeffS", "nb_conefficientsls", "nb_confferences", "nb_coffls", "nb_coeffls", "nb_coefferences", "nb_coeffers"], "blk": [" blak", "berk", "flck", " bltk", "brkk", "lbunk", "berck", "bleak", " blunk", "berak", "BLk", "blunk", " blkh", "bertk", "lbak", " blek", "blak", "glck", " blark", "bln", "glkk", " blkk", "frak", "BLkid", "blogck", "blkid", "silk", "bgk", "bgkg", "frtk", "glkid", "brkid", "brak", "blen", "lbark", "lbck", "brkg", "brn", "glkh", "blogark", "brck", "blekk", "blek", " blck", " blkg", "blogunk", "flkk", "blkk", "blkh", "lbk", "lbkk", "silak", "bgkid", "blogk", "BLn", "bleek", "bltk", "glak", "silek", "silkk", " blkid", "blark", "flk", "bgck", "lbkid", "blkg", "blck", "BLck", "bleck", "flkh", "blekid", "brk", "frck", "glk", "frk"], "bnd": ["abdj", "bbind", "bind", " bld", "bldj", "bbund", "blond", "ynd", " bneck", "bhnt", "hst", "bng", "bneck", " bend", "abneck", "hnd", "bhld", "blend", "bdd", "bst", "yust", "hbd", "bhnd", "ubdir", "abck", "lnt", "abbd", "ubdd", "ynt", "tng", "bbst", "abnt", " bund", "lend", "abst", "bbbd", "bond", "hld", "bend", "bgn", "bdj", "bbld", "abond", " bbd", "ybd", "ubnd", "brnd", "bbgn", " bck", "tond", "lst", "blnd", "lbd", "lld", "brbd", "brgn", "abng", " bgn", "tnt", "bck", "tnd", "bust", " bdd", "bnt", "bbnt", "abnd", "bund", "bhneck", "bbdir", "bbnd", "bld", " bnt", " bind", "brind", "blck", "bbond", " bdj", "ubund", "blnt", "abend", " bust", "bbdd", "bbd", "abld", " bdir", " bst", "brust", "brend", "brld", " bond", "brnt", "bbng", "lnd", "brst", "bdir"], "i": ["multi", "j", "id", "ii", "ki", "ori", "ji", "status", "is", "p", "n", "xi", "ic", "pi", "index", "qi", "me", "li", "ci", "ami", "m", "ei", "b", "x", "u", "cli", "start", "ui", "info", "phi", "it", "gi", "ij", "series", "ip", "oi", "y", "k", "bi", "hi", "iu", "ti", "ind", "uri", "io", "ix", "print", "v", "zi", "in", "PI", "mi", "ini", "di", "\u0438", "ai", "I", "si", "ri", "this"], "block": ["object", "p", "blocking", "window", "out", "set", "x", "load", "lock", "volume", "zero", "book", "wall", "k", "buffer", "bo", "manager", "group", "line", "ck", "number", "list", "bank", "bc", "row", "clus", "box", "link", "filter", "check", "file", "bus", "unit", "sync", "byte", "chain", "jump", "mask", "flow", "record", "BL", "condition", "part", "new", "type", "snap", "network", "pool", "bin", "one", "loop", "point", "prefix", "map", "sp", "Block", "skip", "instance", "no", "bit", "b", "unknown", "pack", "clip", "def", "plugin", "scope", "ip", "local", "command", "pop", "blocks", "layout", "bl", "field", "cl", "zone", "obj", "base", "join"], "block0": ["bl0", "box1", "group1", "box0", "block2", " blockk", "groupk", "Block1", "Blockk", "block1", "bl2", " block2", "blockk", "Block2", "Block0", "group2", " block1", "bl1", "group0"], "sum": ["doc", "total", "stack", "Sum", "mean", "ma", "add", "size", " SUM", "match", "summary", "status", "count", "ut", "sun", "use", "up", "sim", "cal", "dict", "all", "sort", "stat", "result", "fac", "ass", "set", "score", "sat", "see", "num", "us", "info", "su", "msg", "cache", "zero", " Sum", "ge", "cmp", "average", "mu", "gram", "comment", "cum", "save", "um", "cast", "sam", "post", "scale", "tu", "vol", "hash", "process", "sky", "max", "si", "mem", "put", "share"]}}
{"project": "qemu", "commit_id": "9bb234b3b170299c39c9e88cfe7da5434a92d99d", "target": 1, "func": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();", "idx": 164, "substitutes": {"x0": ["x25", "x180", "ox180", "rx2", "ox4", " xn", "t00", "xt1", "t1", "t3", "x4", " x00", "t2", "rx0", "tx00", "x3", "tx1", "x2", "ix25", "X0", "tx3", "ox25", "tx2", "t0", "tn", " x2", "ix180", "ox0", " x3", "ix1", "x00", "xn", "ix0", "X2", "Xn", "ox1", "tx0", " x4", "xt0", " x25", " x180", "X1", "xt4", "rx1", "rx3"], "x1": ["t01", "vOne", "t1", "t3", " xOne", " x01", "tone", "t2", "x3", "tx1", "xOne", "x2", "xx1", "tx2", "t0", " x2", "tOne", "xxone", " x3", "v0", "x01", "tx0", "v01", "xone", "v1", "xx0", " xone", "txOne", "xx3"]}}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n", "idx": 176, "substitutes": {"env": ["proc", "doc", " environment", "gear", "buf", "code", "next", "qv", "conn", "ev", "window", "txt", "server", "ah", "menu", "viron", " ens", "NV", "environment", "esc", "nv", "entry", "vp", "priv", "req", "dev", "ef", "end", "desc", "vv", "cv", "en", "ctx", "En", "v", "ov", "uv", "event", "ve", "gov", "Ev", "obj"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 178, "substitutes": {"env": ["proc", "stack", "buf", "code", "web", "ev", "window", "vs", "txt", "environment", "info", "bar", "dev", "vec", "config", "end", "vv", "cv", "context", "e", "w", "en", "disk", "buffer", "name", "v", "uv", "map"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n", "idx": 179, "substitutes": {"s": ["sys", "sis", "ls", "S", "south", "j", "stats", "is", "source", "ss", "sv", "es", "n", "service", "details", "ses", "comm", "ers", "ds", "qs", "utils", "b", "params", "fs", "less", "services", "aws", "iss", "uns", "ps", "parts", "js", "ns", "bs", "sw", "y", "ims", "w", "comments", "ms", "as", "cs", "ts", "spec", "ains", "changes", "ies", "hs", "bes", "events", "sts", "rs", "tests", "ags", "ares", "h", "gs", "ats", "sb", "st", "sq", "os", "states", "se"], "link_down": ["link64desc", "matchendown", "link64min", "linklyfree", "link_setup", "linklyfull", "linkedopen", "linkedown", "linkydowns", "close_downs", "linkitydown", "link_off", "ink_off", " link_open", " link_up", "linkendown", "close_desc", "link_up", "linkydown", "closeymin", "linklydown", "link_own", "link42downs", "linkenfull", "link42down", "linkydesc", "link_now", "closeydowns", "ink_setup", "match_down", "close_down", "closeydown", "linkedmin", "link_downs", "match_free", "link_target", "ink_down", "match_full", "link64downs", "link_desc", "linkenfree", "linklytarget", "link_full", "linkitytarget", "matchentarget", "matchenfree", "link64down", "link_min", "linkityfree", "ink_downs", "link_free", "matchenfull", "linkityfull", "linkeddown", "link_open", "link42desc", "match_target", "linkymin", "link42min", "closeydesc", " link_min", "close_min", " link_now", " link_own", "linkentarget"]}}
{"project": "FFmpeg", "commit_id": "3547f8e8f8418af0c578eba0de62ecba08e460c2", "target": 0, "func": "static int rv34_decode_mv(RV34DecContext *r, int block_type)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    GetBitContext *gb = &s->gb;\n\n    int i, j, k, l;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int next_bt;\n\n\n\n    memset(r->dmv, 0, sizeof(r->dmv));\n\n    for(i = 0; i < num_mvs[block_type]; i++){\n\n        r->dmv[i][0] = svq3_get_se_golomb(gb);\n\n        r->dmv[i][1] = svq3_get_se_golomb(gb);\n\n    }\n\n    switch(block_type){\n\n    case RV34_MB_TYPE_INTRA:\n\n    case RV34_MB_TYPE_INTRA16x16:\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        return 0;\n\n    case RV34_MB_SKIP:\n\n        if(s->pict_type == AV_PICTURE_TYPE_P){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n            break;\n\n        }\n\n    case RV34_MB_B_DIRECT:\n\n        //surprisingly, it uses motion scheme from next reference frame\n\n        /* wait for the current mb row to be finished */\n\n        if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n\n            ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0);\n\n\n\n        next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride];\n\n        if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n            ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        }else\n\n            for(j = 0; j < 2; j++)\n\n                for(i = 0; i < 2; i++)\n\n                    for(k = 0; k < 2; k++)\n\n                        for(l = 0; l < 2; l++)\n\n                            s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]);\n\n        if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) //we can use whole macroblock MC\n\n            rv34_mc_2mv(r, block_type);\n\n        else\n\n            rv34_mc_2mv_skip(r);\n\n        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);\n\n        break;\n\n    case RV34_MB_P_16x16:\n\n    case RV34_MB_P_MIX16x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n\n        break;\n\n    case RV34_MB_B_FORWARD:\n\n    case RV34_MB_B_BACKWARD:\n\n        r->dmv[1][0] = r->dmv[0][0];\n\n        r->dmv[1][1] = r->dmv[0][1];\n\n        if(r->rv30)\n\n            rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        else\n\n            rv34_pred_mv_b  (r, block_type, block_type == RV34_MB_B_BACKWARD);\n\n        rv34_mc_1mv     (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD);\n\n        break;\n\n    case RV34_MB_P_16x8:\n\n    case RV34_MB_P_8x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);\n\n        if(block_type == RV34_MB_P_16x8){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);\n\n            rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);\n\n        }\n\n        if(block_type == RV34_MB_P_8x16){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);\n\n            rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);\n\n        }\n\n        break;\n\n    case RV34_MB_B_BIDIR:\n\n        rv34_pred_mv_b  (r, block_type, 0);\n\n        rv34_pred_mv_b  (r, block_type, 1);\n\n        rv34_mc_2mv     (r, block_type);\n\n        break;\n\n    case RV34_MB_P_8x8:\n\n        for(i=0;i< 4;i++){\n\n            rv34_pred_mv(r, block_type, i, i);\n\n            rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);\n\n        }\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 185, "substitutes": {"r": ["mr", "br", "d", "rd", "q", "cr", "gr", "usr", "er", "ro", "c", "nr", "self", "rg", "vr", "p", "hr", "g", "n", "attr", "result", "rect", "rb", "m", "res", "b", "rw", "u", "sr", "kr", "w", "e", "err", "response", "rec", "fr", "rr", "ir", "adr", "rt", "or", "ar", "ry", "rs", "v", "rm", "h", "o", "rel", "ocr", "rar", "rc", "t", "re", "obj", "R", "this", "rn"], "block_type": ["blocketytype", "Block_TYPE", "Block_Type", "byte_length", "block___key", "blocktypet", "block_kind", "block2status", "block2name", "block_role", "Block_name", "block___type", "blocketyType", "Block_status", " block_name", "Block_type", "block___length", "block_t", "byte_role", "blocktypeType", "byte_key", "block_status", "block___role", "block_key", "byte_type", "blockityrole", "blockitykey", " block_kind", "blocktypeTYPE", "blockitylength", "blockitytype", "block2Type", "blocktypetype", "block_TYPE", "Block_t", "blocketyname", "block_Type", "block2type", "block_name", "blocketystatus", " block_Type", "block_length"], "s": ["ls", "c", "aunts", "p", "es", "n", "ses", "params", "gets", "its", "sr", "conf", "cs", "spec", "events", "h", "gs", "f", "sb", "args", "os", "a", "south", "stats", "sv", "conv", "settings", "session", "vs", "details", "xs", "ds", "qs", "m", "ants", "eds", "less", "bs", "ims", "bis", "sam", "hs", "ar", "sts", "eps", "ins", "states", "sq", "S", "ss", "als", "sl", "comm", "utils", "ns", "sw", "y", "ms", "ts", "changes", "v", "ops", "sp", "sys", "is", "g", "times", "b", "fs", "aws", "ps", "parts", "js", "w", "e", "as", "sports", "rs", "o", "bits", "ats", "t"], "gb": ["Gb", "mb", "rg", "eb", "vg", "tg", "sv", "bd", "bm", "kb", "gif", "g", "hog", "py", "sl", "pi", "deg", "cfg", "rect", "cb", "rb", "yg", "gy", "fg", "b", "gd", "eg", "meg", "gt", "tm", "bb", "bt", "bs", "gu", "hub", "ch", "cv", "goo", "bg", "gc", "now", "db", "fb", "range", "gs", "GB", "si", "sb", "cm", "gm", "bf", "gg", "gow", "nb", "gam", "uf", "gh"], "i": ["multi", "batch", "id", "key", "ii", "ki", "list", "ji", "c", "is", "z", "p", "sim", "xi", "ic", "pi", "asi", "index", "qi", "li", "ci", "iter", "ami", "m", "b", "x", "u", "ui", "info", "gi", "it", "phi", "ij", "iso", "ip", " ii", "y", "bi", "im", "hi", "iu", "ti", "span", "ski", "ind", "uri", "ix", "v", "zi", "in", "mi", "h", "o", "ini", "di", "ai", "I", "si", "f", "ri"], "j": ["jump", "q", "key", "jp", "ji", "dj", "z", "uj", "p", "aj", "g", "n", "kj", "m", "b", "J", "ij", "jl", "ch", "bi", "jc", "ja", "v", "o", "jj"], "k": ["ko", "ka", "q", "key", "ki", "km", "z", "ke", "kg", "kh", "p", "n", "g", "kj", "kk", "m", "u", "sk", "ch", "w", "mk", "ks", "v", "o", "K", "ik", "ck"], "l": ["ls", "lp", "le", "L", "il", "nl", "p", "g", "n", "sl", "li", "lo", "m", "lock", "ll", "lv", "e", "el", "pl", "ln", "len", "loc", "v", "o", "h", "lc", "length"], "next_bt": ["next___BT", "next_gb", "next___bc", " next___bc", " next___BT", "next___cb", "next____bt", "next_bc", " next_BT", " next_gb", "next_gt", " next_cb", "next____BT", "next_BT", "next____bc", "next_cb", " next_bc", " next_gt", " next___cb", " next___bt", "next___bt", "next___gb", "next___gt", "next____cb"]}}
{"project": "qemu", "commit_id": "40365552c2fceacc9800ec9a87b9ead516a9a6ce", "target": 1, "func": "static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,\n\n                             const char *replaces,\n\n                             int64_t speed, uint32_t granularity,\n\n                             int64_t buf_size,\n\n                             BlockdevOnError on_source_error,\n\n                             BlockdevOnError on_target_error,\n\n                             bool unmap,\n\n                             BlockCompletionFunc *cb,\n\n                             void *opaque, Error **errp,\n\n                             const BlockJobDriver *driver,\n\n                             bool is_none_mode, BlockDriverState *base)\n\n{\n\n    MirrorBlockJob *s;\n\n\n\n\n    if (granularity == 0) {\n\n        granularity = bdrv_get_default_bitmap_granularity(target);\n\n    }\n\n\n\n    assert ((granularity & (granularity - 1)) == 0);\n\n\n\n    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||\n\n         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&\n\n        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"on-source-error\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size < 0) {\n\n        error_setg(errp, \"Invalid parameter 'buf-size'\");\n\n        return;\n\n    }\n\n\n\n    if (buf_size == 0) {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    /* We can't support this case as long as the block layer can't handle\n\n     * multiple BlockBackends per BlockDriverState. */\n\n    if (replaces) {\n\n        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);\n\n        if (replaced_bs == NULL) {\n\n            return;\n\n        }\n\n    } else {\n\n        replaced_bs = bs;\n\n    }\n\n    if (replaced_bs->blk && target->blk) {\n\n        error_setg(errp, \"Can't create node with two BlockBackends\");\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(s->target, s->common.blocker);\n\n\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    if (s->target->blk) {\n\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n\n        blk_iostatus_enable(s->target->blk);\n\n    }\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}", "idx": 200, "substitutes": {"bs": ["sys", "ls", "stats", "bc", "bh", "vs", "pb", "bp", "box", "ds", "b", "ubs", "fs", "lb", "BS", "lbs", "gb", "iss", "obs", "bolt", "boot", "ps", "its", "bb", "js", "bos", "ns", "bis", "fps", "cs", "ts", "ctx", "bus", "bps", "hs", "db", "hz", "rs", "bytes", "bits", "blog", "gs", "bas", "sb", "os", "prefix", "socket", "obj"], "target": ["jump", "total", "template", "parent", "device", "match", "host", "handle", "port", "source", "view", "next", "p", "to", "window", "Target", "result", "trigger", "stable", "path", "table", "link", "task", "secondary", "b", "gt", "bolt", "it", "type", "dev", "scope", "bt", "stop", "local", "map", "buffer", "kit", "ts", "origin", "home", "dest", "arget", "manager", "db", "v", "range", "launch", "address", "sp", "primary", "root", "src", "rel", "arg", "super", "compatible", "t", "obj", "join", "master", "this", "top"], "replaces": ["creplace", "breforms", "regex", "crechanges", "replays", "cregex", "prechanges", "creforms", "remplace", "greplays", "comforms", "REps", "creps", "preforms", "complaces", "breplaces", "vreplays", "reforms", "rembs", "greps", "breps", "prochanges", "pregex", "REpps", "creplaces", "preplays", "greplaces", "REplaced", "progex", "replaced", "REforms", "preplaces", "remplaced", "vreps", "proforms", "remps", "breplaced", "Replace", "compps", "Replaced", "prepps", "rebs", "vrechanges", "Rebs", "rechanges", "preps", "complaced", "repps", "vreplaces", "grechanges", "reps", "preplaced", "REplaces", "Replaces", "crebs", "replace", "remplaces", "creplaced", "proplaces", "Reps"], "speed": ["sync", "stats", "sex", "status", "size", "skip", "peed", "delay", "count", "height", "port", "seek", "engine", "sql", "rate", " speeds", "force", "weight", "Speed", "length", "sw", "slow", "buffer", "fps", "command", "flags", "fast", "priority", "offset", "scale", "address", "scroll", "frequency", "rates", "seed", "timeout", "sleep", "capacity", "sn"], "granularity": [" granule", " granity", "severity", "ranulus", "cosulus", "cosularity", "angity", "ranity", "granly", " granality", "ranularity", "ranular", "severular", "circulus", "genity", "genulation", "granality", "cosular", "circulation", "angule", "granular", "severularity", "cumulus", "circularity", "sanularity", "granule", "genly", "hangulation", "angularity", "gunulation", "cosulation", "sanality", "cumularity", "angulus", "circular", "gunity", "ranulation", "granulation", "severly", "genularity", "cumity", " granular", " granly", "genulus", "genular", "sanulus", "hangular", "gunulus", "gunule", "granulus", "granity", "cumular", " granulus", "gunular", "sanity", "gunularity", "hangularity", "gunality", "hangity"], "buf_size": ["buf3size", "bg_size", "buf_len", "buf_capacity", "buf2len", "buflensize", "uf_size", "buflencount", "buf_count", "bufitylimit", "buf_SIZE", "poolitysize", "buf_limit", "buf_space", "buf3len", "poolitylimit", "poolitycount", "uf_len", "buffer_space", "buf_lock", "buffer_Size", "bg3len", "bg3capacity", "pool_size", "pool_limit", "buf2limit", "uf_sum", "buf2capacity", "buf_sum", "buffer_SIZE", "poolitylock", "bufitysize", "bufitycount", "buf2count", "buf2size", "pool_count", "buflenlimit", "bg3size", "uf_SIZE", "bg_len", "bg_capacity", "buf_Size", "pool_lock", "buf2lock", "buf3capacity", "buffer_size", "bufitylock", "buflenlock"], "on_source_error": ["on_sourcefulerror", "on_sourcefuldanger", "on_target__error", "on_sourceceptionerror", "on_source__ror", "on_target__err", "on_source__error", "on_sourceceptionror", "on_target__danger", "on_source__err", "on_sourcefulerr", "on_sourcelogtag", "on_sourcelogerror", "on_target_danger", "on_target_node", "on_source__change", "on_target_tag", "on_target_ror", "on_target__ror", "on_source_change", "on_source_node", "on_sourceceptiontag", "on_sourceceptiondanger", "on_sourcefulror", "on_source_tag", "on_sourceaccessror", "on_source_err", "on_target_err", "on_sourceaccesserror", "on_source__danger", "on_target_change", "on_source_danger", "on_source_ror", "on_sourcelogdanger", "on_sourceaccessnode", "on_sourcelogror"], "on_target_error": ["on_target2ror", "on_target_catch", "on_target_ror", "on_source_option", "on_targetlycatch", "on_source_ror", "on_target2error", "on_target_result", "on_targetlyror", "on_source_err", "on_targetlyerr", "on_source_catch", "on_target_fail", "on_source_result", "on_target_err", "on_target2fail", "on_targetlyerror", "on_source_fail", "on_target_option"], "unmap": ["Unmask", "UNmaps", " unmask", " unpack", "Unmaps", "UNmask", " unmaps", "UNmap", "UNpack", "unmask", "Unmap", "Unpack", "unmaps", "unpack"], "cb": ["fp", "obb", "proc", "cp", "fc", "cd", "CB", "func", "buf", "c", "eb", "bc", "fun", "dc", "pb", "bp", "cfg", "rb", "b", "lb", "gb", "obs", "cmp", "call", "cf", "cv", "callback", "cs", "ctx", "db", "cc", "src", "cmd", "rc", "fn", "bf", "ck", "nb", "ctrl"], "opaque": [" oplay", "ipplex", "ipacement", "opsacity", "pacity", "ipatile", "paque", "opacity", "oplaque", "opsaque", "pplex", "opplex", " opplex", "ipaque", "oplatile", "opsatile", "opsacement", "oplacement", "oplacity", "oplay", "opacement", "play", "iplay", "ipacity", " opacity", "opatile"], "errp": ["errorr", "errpc", "rerp", "derpid", " errsp", "derpc", "derp", " errm", "rersp", "errpr", "rerm", "rrp", "krm", "errpp", "errorp", "arrp", " errpa", "sprpa", "krP", "erm", "rerpad", " errP", "sprpr", "herpp", "krp", "errpa", "herm", "krpa", "sprp", "herP", " errr", "rrP", " errps", "erP", "rerpid", "errpid", " errpr", "rrm", "err", "erp", "errorP", "rrsp", "errsp", "errorps", "errps", "errorpid", "errm", "sprP", "erps", "erpp", "errr", "erpa", "arrpa", "arrpr", "herp", "rerpc", "errpad", "errorpad", "errP", "derpad", "rrpp", "arrP", "errorpc"], "driver": ["core", "builder", "device", "tool", "drivers", "host", "handle", "docker", "service", "description", "window", "definition", "box", "dist", "utils", "proxy", "Driver", "native", "force", "type", "dev", "js", "browser", "writer", "hub", "version", "desc", "der", "setup", "owner", "finder", "ver", "bus", "manager", "db", "river", "dr", "wrapper", "handler", "drive", "ctor"], "is_none_mode": ["is_None_message", "is_nonebermode", "is_noneberMode", "is_no_mate", "is_no_Mode", "is_no_mode", "is_none_Mode", "is_None_Mode", "is_none_enabled", "is_noneamenabled", "is_noneammode", "is_nonebermessage", "is_None_mode", "is_none_mate", "is_None_enabled", "is_noneamMode", "is_none_message"], "base": ["sys", "bound", "parent", "id", "is", "source", "back", "p", "server", "bp", "ase", "stable", "bit", "b", "force", "store", "start", "Base", "cache", "it", "bar", "bare", "boot", "history", "based", "state", "scope", "ip", "local", "buffer", "kit", "shadow", "origin", "support", "bal", "db", "enabled", "bid", "null", "scale", "root", "bas", "super", "prefix", "background", "master", "top"], "s": ["sys", "ls", "d", "S", "j", "stats", "l", "c", "is", "sv", "ss", "p", "es", "als", "settings", "n", "actions", "sl", "vs", "details", "ses", "comm", "set", "ds", "qs", "m", "i", "b", "locks", "fs", "less", "store", "gets", "aws", "ps", "its", "ex", "js", "ns", "y", "ims", "w", "bis", "ms", "e", "ports", "ts", "cs", "search", "sports", "hs", "sts", "rs", "v", "single", "h", "pers", "gs", "f", "uploads", "ats", "sq", "os", "t", "sync"]}}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218, "substitutes": {"qi": ["omi", "q", "uti", "ki", "ii", "iq", "qq", "ogi", "qv", "agi", "pi", "ugi", "qa", "ci", "Ni", "iqu", "qs", "ei", "eni", "i", "aki", "mic", "cgi", "ku", "qt", "IQ", "aq", "cci", "qu", "quer", "dq", "fi", "oi", "chi", "iu", "ti", "eur", "ia", "cu", "zi", "ini", "ik", "sq", "imei", "yi", "qua"]}}
{"project": "FFmpeg", "commit_id": "2bfd0a97587d26c0c39413a6291ccc66e4a928d0", "target": 1, "func": "static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);", "idx": 244, "substitutes": {"ctx": ["cp", "ctrl", "cas", "fc", "tmp", "jp", "c", "pc", "xc", "bc", "unc", "conn", "ca", "txt", "ci", "cb", "care", "tx", "kt", "sc", "cmp", "kw", "context", "cv", "setup", "tc", "pkg", "obj", "abc", " cx", "cc", "cu", "ct", "rc", "Context", "cm", "mem", "mc", "jac", "cmd"], "gb": ["Gb", "mb", "rg", "eb", "vg", "ib", "tg", "kb", "gif", "g", "img", "py", "deg", "cfg", "cb", "rb", "yg", "csv", "pg", "gd", "eg", "gt", "storage", "bb", "bt", "hub", "buffer", "px", "bg", "rl", "gc", "wb", "db", "fb", "bytes", "again", "GB", "gs", "sb", "bn", "bf", "gg", "gm", "nb", "bsp", "asm", "uf", "gh"], "vlc": ["tlt", "tlc", "lvc", "lvt", "wlci", "cilcs", "wlc", "cilv", "tlcs", "wlt", "vlcs", "rlc", "lvci", "tlci", "wll", "cill", "cilc", "rlcs", "vlt", "vlci", "wlcs", "vll", "rll", "rlv", "lvcs", "vlv", "wlv"], "symbols": ["sympols", "symmsols", "symmsels", "symmbles", "semsels", "sembols", "symsols", "symmbols", "semss", "symsels", "symmbials", "symsials", "symbels", "Symbol", "syphels", "Sympols", "syphols", "sychels", "syembels", "symples", "sychols", "sembs", "sympors", "sympels", "Sympors", "syphles", "syembols", "symss", "syembials", "symbol", "semsols", "sympol", "Sympels", "symmsles", "sychol", "sembels", "symbs", "semsles", "symbles", "Symbels", "symsles", "Symbors", "syphol", "sychors", "syphors", "Symbols", "symbors", "sembles", "symps", "symmsials", "symbials", "sympials", "syembles", "syphs", "symmbels", "Sympol"], "bits": ["fixes", "nets", "values", "stats", "fits", "issues", "lists", "settings", "files", "words", "checks", "details", "cuts", "bles", "dates", "weights", "utils", "ops", "bit", "locks", "ubs", "gets", "obs", "cells", "bars", "pieces", "its", "parts", "ps", "bs", "jobs", "tags", "errors", "flags", "plugins", "bis", "ports", "pins", "keys", "rots", "bps", "lines", "ints", "bytes", "blocks", "tops", "versions", "ats", "ins", "states", "items", "cats"], "codes": ["fixes", "values", "cod", "ones", "scripts", "sections", "images", "code", "lists", "checks", "names", "xs", "maps", "ids", "cache", "cells", "modules", "bs", "tags", "errors", "comments", "flags", "terms", "cs", "headers", "keys", "items", "odes", "classes", "bps", "lines", "types", "ints", "bytes", "blocks", "versions", "states", "inters", "cats"], "num_lens": ["num_rans", "num_lsuns", "num_liens", "num_lsis", "num_lsms", "num_leis", "num_lsents", "num_lans", "num_leents", "num_lates", "num_Lents", "num_rens", "num_leiens", "num_Lms", "num_lems", "num_lms", "num_Lates", "num_rents", "num_leates", "num_Lis", "num_lsates", "num_Luns", "num_leuns", "num_ranguages", "num_lis", "num_Languages", "num_Lens", "num_lents", "num_lsens", "num_Lans", "num_luns", "num_languages", "num_leens", "num_lsiens", "num_Liens"], "num_codes": ["num_odes", "num_checks", "num_ones", "num___checks", " num_objects", "num_planes", " num_errors", "num___codes", "num_objects", "num___code", "num_cats", " num_planes", " num_bits", " num_checks", "num___planes", " num_cats", "num_errors", "num_bits", "num___obs", "NUM_obs", "num___cats", " num_ones", "num___odes", "num_code", "num_obs", "NUM_cats", "NUM_codes", " num_code", "NUM_odes"], "num_codes_sum": ["num_values_msg", "num_codes2total", "num_codes_size", "num_codes___count", "num_codes_se", "num_values_count", "num_codes__up", "num_codes__max", "num_images_num", "num_codes_msg", "num_codes_total", "num_codes_max", "num_images_Sum", "num_lines2total", "num_values_sum", "num_lines_count", "num_codes2sum", "num_codes_Sum", "num_values_size", "num_codes_num", "num_lines_sum", "num_lines2up", "num_codes___sum", "num_lines2max", "num_lines_total", "num_codes_count", "num_codes2num", "num_codes___map", "num_lines2sum", "num_images_sum", "num_codes2max", "num_codes__total", "num_codes_up", "num_images_count", "num_codes2count", "num_images_se", "num_lines_map", "num_codes_map", "num_codes__sum", "num_codes2map", "num_lines_up", "num_codes2up", "num_lines_max"], "prefix": ["fixes", "batch", "key", "status", "size", "code", "mask", "height", "next", "term", "p", "init", "n", "ref", "pi", "fix", "index", "bp", "pointer", "power", "sequence", "path", "counter", "password", "none", "lock", "localhost", "cache", "zero", "pad", "length", "version", "alias", "origin", "len", "pkg", "ind", "quote", "post", "priority", "offset", "ix", "print", "radius", "pre", "label", "scale", "padding", "alpha", "root", "max", "position", "reset", "missing", "timeout", "point", "base", "master", "chain"], "i": ["multi", "id", "q", "l", "ii", "iq", "ji", "jp", "c", "is", "p", "iy", "n", "xi", "pi", "index", "ish", "s", "li", "ci", "ami", "m", "b", "x", "ui", "info", "start", "phi", "gi", "it", "at", "ij", "ip", "y", "ims", "bi", "im", "ie", "e", "hi", "iu", "ti", "ind", "io", "ix", "offset", "v", "zi", "in", "di", "ini", "ai", "si", "I", "this"], "j": ["jump", "br", "q", "key", "l", "jp", "ji", "c", "bj", "dj", "jit", "z", "p", "aj", "uj", "g", "n", "index", "kj", "m", "b", "x", "other", "adj", "it", "at", "ge", "J", "ij", "jl", "pr", "job", "js", "att", "y", "k", "e", "jc", "fr", "oj", "pt", "ja", "ix", "v", "on", "o", "obj", "jac", "jj", "json"], "count": ["core", "Count", "id", "ctr", "try", "summary", "c", "handle", "n", "read", "out", "set", "sum", "weight", "req", "found", "conf", "cast", "ind", "queue", "scroll", "hash", "missing", "batch", "number", "key", "test", "list", "next", "result", "create", "sequence", "num", "name", "range", "depth", "nt", "max", "length", "chain", "total", "size", "code", "z", "child", "ref", "index", "write", "counter", "close", "find", "info", "new", "cache", "type", "call", "comment", "level", "err", "process", "loop", "current", "len", "common", "success", "cycle", "mount", "add", "temp", "status", "score", "table", "cont", "start", "amount", "now", "frequency", "ount", "race", "state", "base"]}}
{"project": "FFmpeg", "commit_id": "7bf3f380466eeff24916fd6218aca13e414c6240", "target": 1, "func": "static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,\n\n                                  CodedBitstreamUnit *unit)\n\n{\n\n    BitstreamContext bc;\n\n    int err;\n\n\n\n    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n\n    if (err < 0)\n\n        return err;\n\n\n\n    switch (unit->type) {\n\n    case HEVC_NAL_VPS:\n\n        {\n\n            H265RawVPS *vps;\n\n\n\n            vps = av_mallocz(sizeof(*vps));\n\n            if (!vps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_vps(ctx, &bc, vps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_vps(ctx, vps);\n\n            if (err < 0) {\n\n                av_free(vps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = vps;\n\n        }\n\n        break;\n\n    case HEVC_NAL_SPS:\n\n        {\n\n            H265RawSPS *sps;\n\n\n\n            sps = av_mallocz(sizeof(*sps));\n\n            if (!sps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_sps(ctx, &bc, sps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_sps(ctx, sps);\n\n            if (err < 0) {\n\n                av_free(sps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = sps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_PPS:\n\n        {\n\n            H265RawPPS *pps;\n\n\n\n            pps = av_mallocz(sizeof(*pps));\n\n            if (!pps)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_pps(ctx, &bc, pps);\n\n            if (err >= 0)\n\n                err = cbs_h265_replace_pps(ctx, pps);\n\n            if (err < 0) {\n\n                av_free(pps);\n\n                return err;\n\n            }\n\n\n\n            unit->content = pps;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_TRAIL_N:\n\n    case HEVC_NAL_TRAIL_R:\n\n    case HEVC_NAL_TSA_N:\n\n    case HEVC_NAL_TSA_R:\n\n    case HEVC_NAL_STSA_N:\n\n    case HEVC_NAL_STSA_R:\n\n    case HEVC_NAL_RADL_N:\n\n    case HEVC_NAL_RADL_R:\n\n    case HEVC_NAL_RASL_N:\n\n    case HEVC_NAL_RASL_R:\n\n    case HEVC_NAL_BLA_W_LP:\n\n    case HEVC_NAL_BLA_W_RADL:\n\n    case HEVC_NAL_BLA_N_LP:\n\n    case HEVC_NAL_IDR_W_RADL:\n\n    case HEVC_NAL_IDR_N_LP:\n\n    case HEVC_NAL_CRA_NUT:\n\n        {\n\n            H265RawSlice *slice;\n\n            int pos, len;\n\n\n\n            slice = av_mallocz(sizeof(*slice));\n\n            if (!slice)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);\n\n            if (err < 0) {\n\n                av_free(slice);\n\n                return err;\n\n            }\n\n\n\n            pos = bitstream_tell(&bc);\n\n            len = unit->data_size;\n\n            if (!unit->data[len - 1]) {\n\n                int z;\n\n                for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n\n                av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Deleted %d trailing zeroes \"\n\n                       \"from slice data.\\n\", z);\n\n                len -= z;\n\n            }\n\n\n\n            slice->data_size = len - pos / 8;\n\n            slice->data = av_malloc(slice->data_size);\n\n            if (!slice->data) {\n\n                av_free(slice);\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            memcpy(slice->data,\n\n                   unit->data + pos / 8, slice->data_size);\n\n            slice->data_bit_start = pos % 8;\n\n\n\n            unit->content = slice;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_AUD:\n\n        {\n\n            H265RawAUD *aud;\n\n\n\n            aud = av_mallocz(sizeof(*aud));\n\n            if (!aud)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_aud(ctx, &bc, aud);\n\n            if (err < 0) {\n\n                av_free(aud);\n\n                return err;\n\n            }\n\n\n\n            unit->content = aud;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 245, "substitutes": {"ctx": ["gru", "vc", "ka", "cp", "sys", "cas", "wcs", "fc", "func", "jp", "pc", "xc", "nc", "unc", "conn", "conv", "hw", "np", "kl", "cfg", "mc", "comm", "cb", "act", "tx", "kt", "sc", "etc", "req", "cmp", "voc", "cci", "history", "xy", "config", "ctl", "kw", "conf", "context", "cv", "setup", "cond", "grad", "pkg", "gc", "cu", "cc", "nt", "wx", "ct", "cl", "rc", "ck", "iat", "tc", "jac", "cmd"], "unit": ["doc", "domain", "number", "document", "nit", "piece", "test", "device", "net", "word", "item", "format", "no", "volt", "term", "unt", "init", "element", "package", "out", "task", "bit", "sum", "condition", "mun", "num", "relation", "other", "plain", "su", "lock", "volume", "it", "kt", "units", "type", "reason", "mu", "note", "tag", "man", "gem", "connection", "block", "version", "force", "um", "command", "attribute", "option", "uint", "bin", "un", "tu", "uu", "category", "vol", "du", "nu", "application", "Unit", "position", "prefix", "tc", "module", "cmd", "byte"], "bc": ["ec", "vc", "fc", "bitcoin", "BBC", "bec", "BC", "c", "pc", "nc", "bd", "lic", "dc", " dc", "ca", "uc", "ic", "clus", "bp", "mc", "comm", "cb", " ac", "b", " BC", "sc", "ll", "voc", "bb", "bt", "bs", "aos", " bo", "bi", "circ", "cs", "bg", "gc", "wic", "ba", "bo", " db", " ic", "bridge", " cx", "cc", " buf", "ct", "CBC", "sb", "abl", "bn", "lc", "bf", "rc", "exec", "tc", " ba"], "err": ["usr", "try", "trace", "eas", "ach", "drm", "init", "ev", "order", "iter", "ner", "req", "pr", "conf", "fer", "here", "shr", "eor", " arr", "hz", "ry", "fee", " ec", "resp", "mr", "br", "test", "lr", "rez", " er", "css", "result", "any", " Err", "rb", "erer", "msg", " error", "kr", "errors", "rr", "die", "rev", " terr", "expr", "cer", "elt", "rel", "warn", "rar", "cr", "l", "er", "buf", "nr", "code", "vr", "later", "actor", "rank", "res", "plain", "priv", "dev", "virt", "ait", "y", "error", "level", "diff", "ier", "fr", "str", "or", "Error", "val", "empty", "oe", "erd", "rc", " cr", " br", "late", "cmd", "sys", "arr", "aaa", "term", "attr", "r", "cfg", "exc", "notice", "extra", "yr", "js", "der", "Er", "ell", "dr", "rs", "gz", "norm", "rn", "typ"], "vps": ["vPs", "vts", "verpps", " vplays", "vinases", "vtpy", " vpps", "vings", "wPs", "verts", "vcpoints", "wps", "vp", "vmpy", "vpy", "vports", "vips", "avpoints", "verplets", "vicplays", "vcips", " vPs", "vicps", "vinpy", "nvps", "avps", "vinports", " vases", "vcports", "weps", " vpoints", "verjs", "verplays", "vceps", "nvports", "vtps", " vts", "vmplets", "vcp", "vjs", "avp", " vports", "veps", "avports", "vinps", "vases", "vicjs", "vcars", "vmes", "vcases", "vtists", "vpass", "avips", "victs", " vpass", " vp", "vists", "vplays", " vjs", "vpoints", " veps", "vcps", "vcpass", "vpps", "vcPs", "vcmes", "avts", "vtplets", "nvpass", " vgs", "vars", "vcplets", "vcpps", " vips", "vcplays", "vmps", "verps", "verars", "avmes", "vcgs", "vinists", "vgs", "vplets", "vcts", "vmists", "nvts", " vars", "wplays", "vinplets", " vplets", " vmes"], "sps": ["ispr", " sms", " sss", "hasips", "jsps", "ispt", "hps", "geps", "spt", " spped", " sts", "rsps", "paps", "ppps", "haspped", "osPS", "rsips", "ismp", "jsaps", "Splets", "haspps", "iesPS", " spr", "espt", "ospps", "Sps", "hops", "isms", " sops", "gps", "hips", "sts", " splets", "seps", "sms", "Spr", "ppt", "esps", "sveps", "svpr", " smp", "esms", "gpr", "Seps", "spl", "Spps", "svPS", "spps", "vesps", "ispps", "smp", "spped", "pss", "vests", "gPS", "iespps", "espr", "spr", "svps", "sips", "oseps", "sPS", " seps", " spps", "sops", "vesips", "vesops", "pmp", "osps", "isps", "jspl", " sips", "splets", " saps", "hts", " spl", " spt", "rspps", "iesplets", "ppl", " sPS", "hasps", "iesps", "rspped", "SPS", "saps", "sss", "jsss"], "pps": ["ls", "pres", "php", "fx", "stats", "phones", "phys", "ppo", "acts", "clips", "phis", "makes", "trak", "caps", "xs", "kk", "pp", "ips", "ppings", "opers", "oops", "pots", "params", "hands", "pes", "ps", "hops", "upp", "ears", "ppa", "mph", "fps", "ppers", "amps", "ods", "houses", "px", "psc", "ks", "bps", "places", "aps", "helps", "eps", "rpm", "ups", "tops", "cpp", "dds", "apps", "ops", "sticks"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n", "idx": 246, "substitutes": {"opaque": ["iopument", "popaque", "ipque", " opula", " opque", "popque", "obument", "obula", "opacity", "iopula", "popument", "opque", "opula", "iopaque", "ipaque", "popacity", "obacity", "iopacity", "opument", "ipacity", "popula", "ipula", " opacity", "obaque"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 248, "substitutes": {"priv": ["proc", "alloc", "env", "prop", "pro", "phys", "adv", "api", "conn", "pri", "ev", "attr", "pi", "riv", "debug", "path", "info", "access", "pad", "pr", "Pri", "disabled", "iv", "ptr", "private", "pkg", "DEV", "Priv", "pub", "rc", "por", "mem", "serv", "auth"], "id": ["oid", "ide", "key", " tid", "iden", "status", "addr", " rid", "rid", " fid", "init", "ref", "Id", " pid", "kind", "path", "mid", "var", " mid", "ids", "num", "info", "start", "type", "tag", "ip", "end", "aid", "did", "name", "uid", "str", "sid", "vid", "bid", "ident", "hash", "h", "ID", "wid", "pid", "kid"], "bulk_packet": ["bulk_buckets", "bulk_packon", "bulk_octpoint", "bulk_bucketer", "bulk_bucket", "bulk_header", "bulk_packeder", "bulk_payette", "bulk_packets", "bulk_pickacket", "bulk_packette", "bulk_packedacket", "bulk_packsacket", "bulk_buckon", "bulk_signeter", "bulk_packET", "bulk_pickET", "bulk_packpoint", "bulk_decetting", "bulk_bucker", "bulk_packatcher", "bulk_paramacket", "bulk_ipper", "bulk_octatcher", "bulk_signet", "bulk_payer", "bulk_decet", "bulk_buckpoint", "bulk_decacket", "bulk_ippet", "bulk_messacket", "bulk_packedet", "bulk_picketer", "bulk_messer", "bulk_packset", "bulk_signacket", "bulk_packeter", "bulk_deceter", "bulk_messet", "bulk_ippET", "bulk_headette", "bulk_packer", "bulk_payon", "bulk_headET", "bulk_parameter", "bulk_ippetting", "bulk_signon", "bulk_buckatcher", "bulk_signET", "bulk_packetting", "bulk_headet", "bulk_payET", "bulk_buckette", "bulk_packseter", "bulk_packedatcher", "bulk_payacket", "bulk_packser", "bulk_packacket", "bulk_signets", "bulk_payeter", "bulk_buckacket", "bulk_messpoint", "bulk_bucketting", "bulk_octacket", "bulk_payets", "bulk_octet", "bulk_paramet", "bulk_payet", "bulk_parametting", "bulk_picket", "bulk_payetting", "bulk_octer", "bulk_buckET"], "data": ["reader", "d", "Data", "batch", "input", "device", "size", "buf", "value", "DATA", "text", "all", "p", "any", "window", "read", "box", "result", "out", "sequence", "action", "dat", "params", "full", "sent", "load", "tx", "fin", "none", "off", "pos", "cache", "zero", "def", "type", "pad", "extra", "mu", "length", "block", "error", "rew", "buffer", "w", "rec", "name", "str", "bin", "db", "val", "empty", "ata", "bytes", "di", "done", "bits", "ret", "ad", "f", "raw", "resp", "mem", "obj", "len", "this"], "data_len": ["ata2en", "data_rel", "ata_ln", "file_lan", "data00len", "buffer00rel", "file_length", "data2len", "file_ln", "data0en", "data_length", "data0len", "data_en", "ata_length", "data00rel", "data2en", "data2length", "ata_en", "buffer00Len", "ata_len", "buffer00len", " data_en", "ata2length", " data_length", " data_Len", "buffer_rel", "ata2Len", "buffer00fun", "data_lan", "data0Len", "ata_Len", "data_Len", "buffer_fun", "data0length", "buffer_Len", "data_ln", "data2Len", "ata2len", "data_fun", "data00fun", "data00Len", "buffer_len", "file_len"], "dev": ["proc", "sys", "d", "env", "test", "device", "pro", "prop", "adv", "api", "conn", "p", "ev", "hw", "window", "pi", "prom", "app", "riv", "debug", "link", "var", "pack", "info", "def", "mem", "pad", "iv", "conf", "sd", "ptr", "w", "wd", "cam", "stick", "ctx", "ver", "Device", "home", "go", "DEV", "db", "tech", "v", "school", "nt", "hid", " Dev", "ad", "av", "ve", "tr", "scan", "pub", "raw", "des", "Dev", "obj", "serv", "cmd"], "aurb": ["aucnb", "urchbase", "urba", "urchbi", "thurf", "vaeb", "thurbo", "aurdb", "thura", "ursb", "aurbb", "augb", "aurB", "urchf", "urchbr", "arrybb", "aerb", "arialf", "urib", "aucrb", "aurbar", "aural", "vaesb", "narbar", "aurib", "aucby", "augm", "urchbd", "aimba", "augbar", "auraf", "aurbd", "aurbo", "aurby", "aerbase", "thurm", "augl", "arryba", "augbot", "aua", "narb", "aimB", "aucfb", "aerba", "aucf", "aul", "narl", "aharb", "aub", "urchgb", "aharnb", "urchba", "arialnb", "aurba", "aurm", "arialb", "urb", "augdb", "thurb", "vaeib", "augbind", "averba", " aurdb", "aursb", "vaeba", "aurfb", "thurbd", "aurab", "urchfb", "urchm", "afferbr", "arrysb", "augnb", "urchby", "aimb", "afferb", "aerbr", "augbd", " aurbot", "averbi", " aurbind", "aurl", "averrb", "aerrb", "thurrb", "aurbind", "urchl", "aura", "urchnb", "thurbar", "nargb", "urchb", "aurbr", "aucgb", "thurB", "aurf", "aimrb", "aurgb", "aurbi", "affernb", "aurbase", "auggb", "arrybase", "aucba", "thurgb", "urchbind", "urchdb", "arryb", "aharbi", "thurl", "aucb", "aurnb", "urchbb", "urchbot", "aucbo", "urchbo", "arryib", "aucbi", "aurrb", "aernb", "urchrb", "averb", "aurbot", "auf", "thurfb", "auraa", "arialby", "urchB", "augbi", "thurba", "aerbb", "afferrb", "ahardb"]}}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}", "idx": 262, "substitutes": {"avctx": ["AVcontext", "vcontext", "avxy", "avconn", "devconn", "avectx", "avconf", "devctx", " avcp", "vrxy", " avcmp", "apcontext", "vrctx", "devcontext", "avtx", "AVconf", " avxy", "aveconn", " avcfg", "afctx", "avecp", "avecfg", "AVconn", " avtx", "vcmp", " avcontext", "AVtx", "apctx", "verctx", "avcp", "AVctx", "apconf", "vctx", "avexy", "afconn", "avcontext", "verconn", "avecontext", "afcontext", " avconn", "avecmp", "vercontext", "avcfg", "apconn", "devconf", "vrcontext", "vercfg", "vrcp", "avcmp", "aftx", "vcfg"], "s": ["ls", "c", "p", "es", "n", "ses", "set", "params", "store", "gets", "sc", "services", "its", "conf", "ports", "cs", "spec", "ies", "h", "gs", "sb", "args", "os", "so", "a", "stats", "sv", "source", "vs", "details", "ess", "ds", "qs", "m", "less", "bs", "ims", "hs", "sts", "eps", "ins", "states", "sq", "sync", "self", "j", "S", "l", "ss", "z", "als", "sl", "comm", "sa", "utils", "ns", "sw", "y", "save", "ms", "ts", "changes", "v", "single", "se", "sys", "status", "is", "stat", "g", "b", "fs", "aws", "ps", "parts", "js", "local", "comments", "sports", "has", "rs", "ats", "st", "t"], "i": ["id", "try", "ori", "c", "p", "n", " ki", "li", "x", " ti", "k", "iu", "ti", "span", "spec", "uri", "ix", "zi", "ini", "I", " info", " bi", "q", " j", "xi", "ic", "qi", "m", "u", "ui", "it", " v", " li", "io", "remote", "\u0438", "ri", "chain", "j", " m", "l", "ii", " mi", "ji", "rest", "pi", "adi", "asi", "me", "ci", "ei", "res", "info", "phi", "ij", "fi", " ii", "y", " pi", "bi", " I", "v", " ni", "mi", "di", "ai", "si", "point", "multi", "ki", "status", "sim", "g", "ami", "b", "cli", "gi", " si", "ip", "oi", "print", " multi", "t"]}}
{"project": "FFmpeg", "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a", "target": 1, "func": "static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n", "idx": 265, "substitutes": {"avctx": ["AVcontext", "AVcc", "vcontext", " avcontext", "AVtx", "AVctx", " avcc", "vctx", "vtx", "avtx", "avcontext", "vcc", "avcc", " avtx"], "s": ["sys", "ls", "d", "S", "stats", "status", "er", "c", "sg", "is", "sv", "ss", "p", "es", "settings", "session", "als", "source", "vs", "details", "ses", "comm", "set", "ds", "qs", "ops", "ips", "params", "less", "aws", "services", "ps", "its", "parts", "js", "ns", "bs", "sw", "ims", "w", "bis", "sam", "ports", "cs", "ts", "spec", "a", "changes", "hs", "sts", "eps", "rs", "v", "h", "gs", "sb", "ats", "args", "sq", "os", "t", "serv", "ssl", "sp"], "length": ["data", "total", "q", "message", "lp", "number", "l", "size", "L", "c", "count", "height", "ENGTH", "component", "term", "text", "p", "pi", "sequence", "be", "x", "full", "load", "form", "duration", "shape", "type", " lengths", "history", "Length", "bb", "end", "ength", "hl", "buffer", "available", "len", "v", "angle", "padding", "h", "enth", "position", "f", "th", "t", " Length", "capacity"], "n": ["ni", "d", "j", "ul", "net", "l", "nb", "size", "c", "no", "cn", "N", "p", "nl", "all", "np", "ng", "Len", "m", "x", "num", "ne", "it", "nan", "network", "ns", "y", "w", "en", "nm", "mn", "an", "v", "nt", "o", "nu", "nn", "ot", "na", " N", "t", "len", "sn"], "i": ["id", "init", "ish", "li", "iu", "ti", "ir", "ind", "uri", "ix", "zi", "ini", "I", "this", "batch", "list", "xi", "ic", "qi", "u", "ui", "it", "at", "ex", "gu", "ims", "im", "io", "PI", "\u0438", "ri", "chain", "j", "l", "ii", "iq", "ji", "pi", "index", "me", "progress", "ci", "ei", "phi", "esi", "ij", "y", "bi", "hi", "mi", "di", "ai", "si", "point", "multi", "ni", "ki", "status", "is", "sim", "ami", "cli", "gi", "ip", "oi", "ie", "e", "print", "in"], "r": ["mr", "br", "rd", "d", "gr", "cr", "l", "lr", "er", "rg", "ro", "nr", "c", "hr", "ru", "rect", "rb", "res", "rate", "u", "ur", "red", "ra", "sr", "rf", "e", "rr", "rx", "rl", "rt", "ar", "dr", "rs", "rm", "rar", "rc", "tr", "ri", "art", "re", "a", "R", "rn"], "g": ["q", "gr", "l", "rg", "ug", "c", "tg", "gravity", "p", "ga", "mg", "gy", "gp", "fg", "pg", "u", "gd", "eg", "msg", "gb", "gt", "gi", "ge", "gen", "ig", "gu", " G", "G", "bg", "gc", "go", "reg", "group", "green", "gs", "gm", "gg", "gam", "ger", "gh"], "b": ["br", "d", "j", "l", "eb", "c", "bc", "z", "p", "ab", "cb", "rb", "be", "u", "bit", "gb", "bar", "bb", "base", "bs", "bi", "bis", "bg", "ob", "bin", "ba", "bo", "db", "fb", "v", "blue", "by", "B", "beta", "f", "sb", "bf", "nb", "obj", "a", "ib"]}}
{"project": "qemu", "commit_id": "09cd058a2cf77bb7a3b10ff93c1f80ed88bca364", "target": 1, "func": "static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n", "idx": 272, "substitutes": {"opaque": ["ipsolete", "ipque", "iopen", " Opaque", "open", "ospane", "iopane", "caten", "hopaque", "ospaques", "hopque", "iopaques", "cataque", " Opque", "opque", "iopaque", "opane", "ipaque", "ospaque", "cataques", " Opaques", "opsolete", "opaques", "ospen", "hopaques", " Opsolete", "ipaques", "hopsolete", "catane"], "addr": ["ace", "alloc", "id", "work", "art", "add", "ange", "host", "handle", "aj", "from", "attr", "hw", "ref", "r", "align", "coord", "act", "tx", "ord", "ack", "pad", "ip", "ptr", "alias", "adr", "rt", "alt", "ag", "offset", "ix", "dr", "rs", "ident", "address", "arp", "hash", " address", "src", "ad", "rc", "wid", "prefix", " af", "obj", "asm", "map", "inter"], "value": ["data", "values", "image", "message", "number", "total", "vector", " data", " val", "sequence", "set", "ue", "memory", "store", "msg", "seq", "weight", "type", "time", "length", "content", "VALUE", "block", "buffer", "w", "attribute", "name", "val", "v", "address", "padding", "field", " address", "unit", "Value", "state", "mem", "map", " Value", "byte"], "size": ["data", "total", "number", "message", "count", "style", "z", "window", "s", "set", "sy", "sum", "space", " Size", "start", "shape", "storage", "type", "amount", "SIZE", "name", "len", "sid", "offset", "ize", "scale", "empty", "bytes", "address", "fee", "si", "sha", "mem", "length", "Size", "sn"], "attrs": ["ttls", "attrrs", "attrls", "ttributes", " attls", " attributes", "ttr", "attributes", "ttrs", "attrr", "attrributes", " attr", "attls", "attr"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280, "substitutes": {}}
{"project": "qemu", "commit_id": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 289, "substitutes": {"dev": ["sys", "data", "d", "env", "device", "buf", "usb", "adv", "ach", "vr", "conn", "dd", "ev", "hw", "dem", "link", "res", "Dev", "start", "info", "def", "priv", "pad", "gu", "sd", "w", "cam", "ver", "spec", "de", "DEV", "v", "val", "nt", "vol", "ad", "ve", "scan", "des", "mem", "obj", "serv", "dis", "cmd"], "conf": ["cp", "c", "cal", "fam", "init", "app", "change", "aff", "cap", "cf", "cond", "cs", "spec", "con", "hz", "vol", "sky", "f", "asm", "comb", "conv", "crit", "cb", "com", "cmp", "cell", "ion", "co", "apache", "cm", "nb", "acc", "aux", "phys", "bm", "inf", "ref", "fac", "comm", "decl", "res", "parse", "info", "cache", "ns", "comment", "compl", "ctx", "map", "auth", "cmd", "sp", "arch", "proc", "prop", "inv", "cn", "conn", "cfg", "lib", "fs", "def", "cons", "confirmed", "config", "irm", " Conf", "param", "ch", "command", "Conf", "cc", "disc", "obj", "module"], "serial": ["sys", "sync", "template", "id", "initial", "human", "sex", "serv", "temp", "device", "technical", "phys", "successful", "encrypted", "usb", "cho", "slot", "chip", "virtual", "soft", "select", "custom", "tty", "description", "psy", "power", "path", "sql", "ionic", "sat", "res", "chron", "series", "boot", "special", "iso", "optional", " Serial", "ser", "token", "zip", "final", "version", "normal", "color", "spec", "ver", "bus", "specific", "phone", "random", "material", "erial", "mot", "ident", "sem", "primary", "micro", "vol", "selected", "sector", "pocket", "mobile", "raw", "quant", "json", "Serial", "vector"], "s": ["ls", "c", "p", "es", "n", "app", "ses", "set", "params", "store", "gets", "services", "its", "http", "ports", "cs", "spec", "h", "gs", "sb", "args", "os", "serv", "a", "south", "stats", "sv", "source", "settings", "service", "vs", "details", "ds", "qs", "less", "bs", "ims", "hs", "sts", "ins", "sq", "sync", "j", "S", "ss", "sl", "comm", "utils", "csv", "i", "https", "ns", "y", "ms", "ts", "changes", "v", "tests", "se", "sp", "is", "g", "simple", "r", "b", "fs", "aws", "ps", "js", "w", "e", "as", "sports", "rs", "ats", "des", "t"], "cylinders": [" sidewcles", "celliners", "cylours", "cylainers", "dyliners", "rocketinders", "oblograms", "rocketours", "dylainers", "ylograms", "cellinders", "cylcles", "cylograms", "ylinders", " sidewinders", "cylsers", "cellours", " sidewograms", " sidewsers", "dylours", "cyliners", "ylsers", "oblsers", "cellainers", "rocketiners", "oblcles", "oblinders", "ylcles", "dylinders", "rocketainers"], "heads": ["masters", "head", "thens", "inks", "aunts", "nuts", "stocks", "quarters", " bends", "links", "locks", "loads", " Heads", "tips", "views", "HEAD", "ths", "reads", " hangs", "hops", "storms", "bs", "anches", "tails", "headed", "ads", "headers", "offs", "helps", "hz", "uds", "cles", "blocks", "forces", "olds", "uploads", "mers", "cycles"], "secs": ["secn", " secps", "towns", "Secats", "secats", "ecls", "Secps", "Secs", " secn", "threadd", "townd", "secls", "secd", "ecps", "townls", "ecats", " secd", "threads", " secats", "Secls", "threadls", " secls", "threadn", "ecs", "townn", "secps"], "virtio_blk_id": ["virtio_blks_ref", "virtio_blk_index", "virtio_blk_info", "virtio_blck_no", "virtio_blk_no", "virtio_blks_id", "virtio_blk_ref", "virtio_blck_ref", "virtio_blks_info", "virtio_blk_i", "virtio_blck_i", "virtio_blck_id", "virtio_blks_index"], "dinfo": ["Dinfo", "didetails", "ardInfo", "mddetails", "Ddetails", "mdinf", "edinf", "diinfo", "dishow", "xinfo", "DInfo", "dinformation", "ddetails", "ardinfo", "mdinfo", " ddetails", "arddetails", " dshow", "xInfo", "dinf", "edinfo", "Dinf", "dInfo", " dInfo", "Dinformation", "xinformation", " dinformation", " dinf", "eddetails", "edInfo", "diinf", "mdshow", "dshow", "xinf"]}}
{"project": "qemu", "commit_id": "0647d47cc184da587c76743546b6af6dfdb8f1da", "target": 1, "func": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n", "idx": 304, "substitutes": {"buf": ["data", "alloc", "q", "tmp", "c", "bc", "bh", "p", "text", "window", "read", "r", "txt", "bp", "pb", "box", "out", "cb", "rb", "b", "msg", "cur", "vec", "bs", "block", "cap", "cf", "buffer", "cv", "w", "err", "ctx", "ob", "pkg", "Buffer", "bin", "wb", "queue", "v", "bl", "h", "bf", "raw", "Buff", "mem", "obj", "uf", "cmd", "buff"], "magic": ["data", "id", "code", "format", "Magic", "style", "chip", "meta", "eric", "ic", "pi", "power", "agic", "bug", "kind", "mid", "header", "mic", "phy", "serial", "policy", "icon", "md", "info", "volume", "type", "cookie", "icy", "iso", "tag", "mag", "version", "metadata", "xxx", "flags", "spec", "offset", "vol", "padding", "hash", "h", "handler", "flag", "pic", "prefix", "sha", "kid", "length", "cmd"], "s": ["sys", "S", "q", "c", "sv", "ss", "p", "g", "r", "ds", "m", "b", "fs", "ps", "js", "bs", "ns", "e", "as", "cs", "ts", "str", "rs", "v", "h", "gs", "f", "sb", "ins", "t", "a", "self", "sp"], "len": ["doc", "data", "ls", "fil", "lp", "le", "l", "size", "L", "nc", "ext", "nl", "limit", "fun", "g", "n", "sl", "kl", "lim", "iter", "li", "Len", "lib", "mid", "lf", "fin", "num", "msg", "pos", "seq", "lan", "ll", "mil", "gen", "syn", "fl", "t", "length", "vec", "hl", "dl", "err", "el", "en", "pl", "ln", "str", "coll", "alt", "loc", "mn", "val", "v", "bytes", "nt", "padding", "vol", "lang", "wid", "elt", "enc", "mem", "ld"], "buflen": ["buclan", "buglen", " buflar", "buclun", "BUflength", "BUglun", "buclen", "buflar", "buselen", "bullen", "buclength", "buplun", "BUflan", " buplar", "buplan", "buglength", "BUflen", "buplen", " buplength", "buselength", "buglan", "bullar", "buflan", "bullun", "buplength", "buselar", " buflength", "BUglen", "buflun", "buselun", "BUglan", " buplun", "buplar", "buflength", " buplen", "BUglength", "bullength", "BUflun", "buglun", " buflun"], "ext_backing_fmt": ["ext_backing_mformat", "ext_backing_vtm", "ext_backing_mtx", "ext_backing_lats", "ext_backing_lnt", "ext_backing_mtm", "ext_backing_mlt", "ext_backing_vlt", "ext_backing_fformat", "ext_backing_ltx", "ext_backing_lformat", "ext_backing_vtx", "ext_backing_lmt", "ext_backing_vmt", "ext_backing_mats", "ext_backing_fnt", "ext_backing_fmnt", "ext_backing_mmt", "ext_backing_fmformat", "ext_backing_ftx", "ext_backing_ftm", "ext_backing_llt", "ext_backing_flt", "ext_backing_mnt", "ext_backing_ltm", "ext_backing_fmmt", "ext_backing_fats", "ext_backing_fmats"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n", "idx": 305, "substitutes": {"c": ["ec", "fc", "cd", "l", "cr", "pc", "nc", "bc", "cn", "p", "g", "dc", "ci", "mc", "cb", "m", "com", "ce", "C", "cont", "etc", "cache", "cur", "conf", "cf", "e", "cs", "ctx", "con", "gc", "coll", "anc", "enc", "co", "v", "abc", "cu", "cc", "ct", "f", "rc", "cm", "lc", "ac", "t", "tc"], "pb": ["fp", "cp", "lp", "wp", "jp", "buf", "pc", "ub", "bc", "p", "pm", "ab", "np", "bp", "erb", "pp", "mp", "cb", "rb", "td", "pg", "b", "lb", "vp", "tp", "bb", "bs", "pa", "tc", "cv", "ap", "pl", "ctx", "pkg", "wb", "pt", "db", "fb", "dp", "pan", "sb", "nb", "PB", "ib", "uf", "sp"], "atom": ["data", "ace", "prop", "tmp", "item", " form", "phys", "format", "addr", "ext", "component", "term", "p", "atomic", "attr", "element", "node", "app", "coord", "m", "chem", "b", "x", "num", "form", "msg", "het", "tab", "entry", "tm", "at", "att", "orb", "tar", "xml", "ch", "normal", "buffer", "sam", "ap", "canon", " orb", "str", "nm", "ob", "emb", "or", "abc", "ata", "orm", "mat", "o", "ct", " om", "f", "event", "arb", "raw", "om", "kat", "byte", "obj", "oat", "asm", "tem", "cmd", "typ"], "st": ["mt", "stan", "inst", "usr", "stack", "sta", "art", "ste", "et", "ut", "rest", "nd", "step", "sh", "tt", "ss", "p", "ast", "tra", "stat", "sl", "s", "stable", "ust", "set", "td", "ST", "start", "sc", "etc", "at", "stop", "bt", "sw", "end", "ist", "ts", "fr", "sty", "str", "rt", "pt", "sts", "nt", "irst", "ost", "est", "ct", "must", "sb", "th", "sn", "so", "t", "stage", "se", "std", "St", "sp"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n", "idx": 321, "substitutes": {"listener": ["opender", " listerer", "listerer", "listeners", "openable", "lender", " listenable", "leners", "opener", "Listenable", "Listender", "lener", "LISTener", " listeners", "Listener", "nullener", "nulleners", "LISTenable", "LISTerer", "listenable", "Listerer", "openers", "lenable", "LISTender", " listender", "nullender", "listender"], "d": ["j", "dt", "c", "bd", "p", "dd", "dict", "n", "dx", "g", "dc", "r", "ds", "dat", "m", "i", "b", "ord", "dra", "dq", "dm", "sd", "did", "dl", "w", "e", "de", "db", "fd", "dr", "o", "du", "di", "ad", "f", "D", "pd", "da", "t", "ld", "dn"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325, "substitutes": {"bpp": ["bip", "dPP", "cip", "dpl", " bsp", "bPP", "ppp", "cpps", " bpps", "dpps", "psp", "cPP", "sbpp", "pff", " bff", " bpl", "pip", "rpl", "rPP", " bip", "bpl", "ppl", "rpp", "dpp", "sbpl", "bpps", "sbff", "rpps", "cpp", "bff", "bsp", "sbsp", "ppps", "cpl"], "buf": ["doc", "proc", "batch", "data", "br", "aux", "cat", "func", "prop", "list", "bc", "conv", "fam", "img", "ref", "window", "pb", "r", "np", "iter", "deg", "result", "cb", "rb", "act", "pg", "b", "phy", "pack", "msg", "seq", "cache", "def", "bar", "req", "cur", "vec", "ait", "map", "block", "cap", "desc", "buffer", "cv", "w", "cam", "err", "bag", "grad", "pool", "aka", "pkg", "nm", "bin", "emb", "db", "que", "queue", "v", "fb", "empty", "mat", "raw", "agg", "Buff", "kat", "feat", "uf", "cmd", "buff"]}}
{"project": "qemu", "commit_id": "fac7d7b1cdb21f921d7ac396365f5e920ef03096", "target": 1, "func": "int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 338, "substitutes": {"netdev": ["webdef", "webdev", "NETDev", " netdevice", " netconn", " netDev", "webDev", "NETdev", "NETconn", "netdef", "NETdef", " netdef", "Netprivate", "netprivate", "webdevice", "NetDev", " networkprivate", "netdevice", "netconn", "NETdevice", "netDev", "webconn", " networkDev", " networkdev", " netprivate", "Netdev"], "name": ["data", "id", "NAME", "nam", "key", "size", "host", "no", "p", "ename", "n", "names", "package", "order", "path", "table", "ame", "part", "family", "info", "new", "type", "filename", "ip", "file", "cap", "version", "local", "who", " Name", "alias", "ident", "address", "channel", "Name", "named", "prefix", "base", "chain"], "peer": ["proc", "parent", "eth", "holder", "er", "instance", "pc", "host", "peak", "soc", "p", "pipe", "actor", "server", "node", "package", "stable", "pod", "verified", "pe", "type", "tp", "connected", "connection", "ser", "local", "buffer", "player", "owner", "via", "pool", "pkg", "ter", "remote", "target", "ker", "client", "sp", "channel", "handler", "worker", "slave", "socket", "ssl", "ping", "self", "chain"], "errp": ["ererps", " errping", "rrping", "dercp", "ierpb", "derpb", " errpid", "derp", " errm", "derping", " errpat", "timerpart", "dangerP", "rrp", "timerps", "errorp", "iercp", "rerps", " errpa", "errorpa", "erpat", " errP", "derpat", "errpa", "derm", "dangerpat", "rerpid", "errpart", "ererpb", " errps", "erP", "errpid", "erercp", "rrm", "ierp", "erp", "rerpa", "timerp", "errorps", "errps", "errorpid", "errping", "errm", "ierpat", "ererpart", "errpat", "errorpart", "timerpat", "ererp", "errpb", "errorpat", "errP", "dangerp", "errcp", "ererpat", "rerp"], "tap": ["cp", "trace", "tmp", "op", "format", "ach", "port", "p", "app", "td", "vp", "trip", "t", "wat", "cap", "ap", "ten", "channel", "batch", "test", "comb", "tk", "tif", "pb", "lat", "submit", "tab", "tp", "pa", "each", "tu", "arp", "dp", "tr", "th", "rep", "trap", "tw", "cat", "wp", "amp", "dat", "parse", "hap", "tf", "att", "TP", "snap", "wan", "bat", "ts", "pool", "plant", "pin", "pan", "capt", "map", "sp", "tim", "attach", "tt", "tg", "conn", "package", "Tap", "pp", "table", "tun", "pack", "atten", "pai", "tm", "ta", "transform", "tar", "apt", "pl", "ape", "atom", "wt", "raf", "kat", "tc", "ping", "buff"], "fd": ["fp", "d", "rd", "fc", "ff", "flo", "func", "dt", "buf", "handle", "port", "bd", "pipe", "dd", "tif", " fid", "fa", "dc", "tty", "dir", "result", " fin", "ds", "cb", "td", "dat", "lf", "fin", "fed", "fs", "gd", "dra", "fl", "fi", "ctl", "file", "cf", "sd", "disk", "ptr", "dl", "hd", "df", "fe", "fr", "db", "io", "ud", "fb", "fee", "du", "draft", "handler", "f", "FD", "bf", "fn", "pid", "da", "raf", "socket", "fm", "ld"], "queues": ["queued", "quUES", "quues", "tenue", "quue", "queums", "tenots", "peots", "plue", "tenants", "quesants", "plued", "quesums", "Queue", "tenums", "Queues", "quesots", "peued", "quesUES", "quesued", "quesues", "plues", "queots", "peues", "QueUES", "queUES", "tenued", "queue", "quesue", "queants", "peants", "plums", "tenues"], "script": ["template", "scripts", "test", "ssh", "source", "style", "pipe", "fun", "description", "attr", "server", "lib", "action", "Script", "sql", "parse", "profile", "sc", "type", "run", "execute", "shell", "push", "comment", "command", "method", "shadow", "spec", "cript", "magic", "driver", "control", "handler", "capt", "png", "rc", "parser", "timeout", "exec", "sync", "cmd"], "downscript": ["offtemplate", "evenbutton", "offscript", "ownbutton", "Downscript", "Downstyle", "ownscript", " downfunction", "downtemplate", "DOWNfunction", " downstyle", "downScript", "offbutton", "DOWNScript", "DOWNstyle", "downbutton", "downfunction", "evenScript", "eventemplate", " downScript", "owntemplate", "evenscript", "DOWNscript", "offScript", "DownScript", "ownScript", "downstyle", "Downfunction"], "err": ["mr", "sys", "inner", "cr", "test", "try", "lr", "eas", "er", "buf", "arr", "aaa", "later", "init", "ev", "attr", "result", "r", "order", "iter", "progress", "cfg", "exc", "cb", "res", "msg", "ered", "plain", "anne", "notice", "req", "kr", "conf", "timer", "error", "ch", "errors", "e", "Er", "der", "ptr", "eor", "fr", "rr", "rx", "ln", "aer", "str", "rev", "Error", "dr", "rs", "rm", "empty", "urg", "fee", "gz", "erd", "norm", "rc", "resp", "warn", "elt", "obj", "cmd", "rn"], "vhostfdname": ["vhostfcName", "vHostFDnames", "vHostfdnum", "vhostFDspec", "vHostFDnam", "vHostFDnum", "vhostfnspec", "vhostfdnam", "vhostdirname", "vhostfcnames", "vhostfnname", "vhostfxName", "vhostFDnames", "vhostflspec", "vhostdirnames", "vhostFDid", "vHostfdname", "vHostfdspec", "vhostflname", "vhoststreamid", "vHostFDn", "vHostFDName", "vhostfdnum", "vhostFDnum", "vHostfdnames", "vHostFDid", "vhostfxnam", "vHostFDname", "vhostflnum", "vhostfdn", "vhostfdspec", "vHostfdName", "vhostdirn", "vhostFDnam", "vHostfdn", "vhostfcname", "vHostFDspec", "vhoststreamname", "vhostfxname", "vhostfcn", "vhostfnnum", "vhostflName", "vhostFDName", "vhostfdid", "vhostFDname", "vhostFDn", "vhoststreamName", "vhostfdName", "vHostfdid", "vhostfxid", "vhostdirName", "vhostfnName", "vhostfdnames", "vHostfdnam", "vhoststreamnam"], "ifname": ["Ifnames", "fnames", "ifnames", "ifaddress", "fname", "fullnames", "fullname", "Ifaddress", "Ifname", "fulladdress", "faddress"], "fds": ["wuds", "fcs", "wcs", " fcs", " fuds", "wdds", "cds", "wds", "cuds", "fuds", "fdds", "ccs", "cdds", " fdds"], "vhost_fds": ["vhost_frs", "vhost_ldds", "vhost_ifrs", "vhost_cdds", "vhost_cds", "vhost_ifdds", "vhost_lrs", "vhost_ifds", "vhost_cuds", "vhost_ifuds", "vhost_luds", "vhost_fuds", "vhost_fdds", "vhost_crs", "vhost_lds"], "nfds": ["func", "c", "def", "config", "call", "ctl", "block", "exec", "_", "cmd"], "i": ["j", "id", "ii", "c", "p", "n", "pi", "index", "r", "iter", "ci", "m", "cli", "phi", "it", "ij", "ip", "fi", "k", "ti", "ind", "v", "di", "ai", "I", "si", "f"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 369, "substitutes": {"job_id": ["job_source", "jobNameids", "jobIdversion", " job_source", "job_Id", "job_version", "job__Id", "jobIdids", "jobNameversion", "jobIdsource", "jobNamesource", "job_ids", " job_Id", "jobNameid", "job__ids", " job_ids", "jobIdid", "job__id", "job__oid", " job_oid", " job_version", "job_oid"], "bs": ["ls", "las", "bc", "bh", "bm", "es", "vs", "pb", "bp", "bles", "ds", "b", "fs", "ubs", "lbs", "BS", "lb", "gb", "obs", "ps", "its", "bb", "js", "bt", "bos", "bi", "bis", "cs", "ts", "bus", "bps", "rs", "bas", "gs", "sb", "ubis"], "base": ["bound", "id", "parent", "basic", "bottom", "mb", "port", "source", "absolute", "p", "bind", "from", "relative", "server", "bp", "ase", "stable", "reverse", "b", "real", "fs", "us", "start", "Base", "check", "extra", "bar", "bare", "boot", "based", "file", "local", "pa", "buffer", "shadow", "area", "lower", "fr", "origin", "bal", "bo", "db", "bid", "scale", "on", "client", "root", "bas", "super", "f", "sb", "ias", "birth", "st", "bu", "prefix", "state", "socket", "back", "se", "common"], "backing_file_str": ["backing_file_name", "backing_file_dr", "backing_file2name", "backing_File_dr", "backing_files_str", "backing_File_string", "backing_files_name", "backing_files_string", "backing_file_string", "backing_file2str", "backing_files_spec", "backing_file2spec", "backing_file_spec", "backing_file2string", "backing_File_str", "backing_file_br", "backing_File_br", "backing_file_arr"], "speed": ["stats", "sex", "interface", "status", "size", "pload", "peed", "delay", "height", "port", "seek", "power", "rank", "score", "sum", " speeds", "start", "weight", "Speed", " Speed", "sw", "slow", "mph", "buffer", "command", "fps", "fast", "spec", "EED", "spe", "priority", "offset", "scale", "frequency", "driver", "enable", "state", "length", "capacity"], "on_error": ["onphpror", " on_scale", "on_scale", "ona_error", "onphpERROR", "on_bug", "onphperror", "on_block", "on_ror", "onistcomplete", "on___ERROR", "ona_complete", "on___error", "on____scale", "on____block", "onisterror", "on_complete", "on___ror", "ona___bug", "on___bug", " on_block", "on____error", "on_ERROR", "ona___complete", "ona_bug", "ona___error", " on_ror", "on___complete", "onistbug", " on_ERROR"], "cb": ["fp", "obb", "cand", "cp", "ctr", "cod", "fc", "cd", "CB", "func", "c", "nc", "bc", "xb", "fun", "rob", "erb", "pb", "cfg", "rb", "b", "cgi", "lb", "gb", "job", "bb", "cell", "cf", "cv", "callback", "cs", "ctx", "db", "fb", "cc", "cmd", "sb", "fn", "bf", "ck", "rc", "tc", "ctrl"], "opaque": ["oppaques", "opience", "hoprox", "popaques", "popaque", "bitrox", "opca", "Opience", "bitaque", "Opaque", "hopacity", "pacity", "paque", "prox", "opacity", "hopaque", "bitacity", "paques", "popience", "hopulence", " opaques", "oppca", "popacity", "opaques", "bitulence", " opience", "Opacity", "oprox", "oppaque", "Opaques", "oppacity", " opca", "opulence", "pulence", " opacity", "pca"], "errp": ["Erpa", " Errp", " errpad", "eorsp", "derp", " Errps", "Ersp", "Erp", " erp", " erpos", "errpo", "errpa", "eorpa", " errps", " erps", "derpo", " erpad", "eorp", "errsp", " Errpos", "errps", "derpa", "dersp", "eorpo", "Erpo", " Errpad", " errpos", "errpad", "errpos"], "s": ["ls", "c", "p", "es", "n", "ses", "set", "services", "its", "t", "http", "ports", "cs", "spec", "ies", "events", "an", "h", "gs", "f", "sb", "args", "sol", "os", "so", "a", "d", "south", "stats", "sv", "source", "settings", "details", "ds", "qs", "m", "less", "ims", "sam", "hs", "sts", "eps", "pers", "ins", "states", "sq", "sync", "j", "S", "l", "ss", "als", "sl", "comm", "i", "https", "views", "ns", "y", "save", "ms", "ts", "changes", "v", "single", "results", "se", "ssl", "sp", "common", "status", "is", "g", "r", "b", "fs", "su", "aws", "ps", "js", "sd", "w", "e", "sports", "sm", "rs", "o", "ats", "st", "des", "store"]}}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}", "idx": 372, "substitutes": {"avctx": [" avreq", "avermem", "avctl", "avconn", "avecb", "avectx", " avcpu", "avefunc", "AVproc", "navtxt", "avercontext", "avjac", "savtx", "wavtxt", "avertx", "navctx", "abcmp", "averctl", " avctl", "avetxt", " avca", "avca", "evtx", "ajgc", "afconn", "avpkg", "savjp", "abtc", "avecontext", "afpkg", "avtxt", "vercontext", "averca", " avtmp", "AVcontext", "averpkg", "absys", "evtxt", "vertx", "avercp", "avsys", "wavtx", "avtx", "avcu", "ajcu", "capctx", "abcp", "ajtx", "capcfg", "ajctx", "avercb", "savjac", "evhw", "abctx", " avcontext", "acthw", "AVfunc", "avgc", "evcontext", "avemem", "navconn", "afcontext", "avetmp", "avmem", "avhw", "averjp", "avertxt", "wavcu", "wavfunc", "abconn", "abcb", "wavcp", "wavcmd", "avertc", "aversys", "awcontext", "wavmem", "capcu", "actgc", " avgc", "awcpu", " avtxt", "avecu", "avepkg", "wavpkg", "avtc", "wavctl", "navcontext", "avetx", "wavctx", "AVtx", "avehw", "evconn", "verctx", "evctx", "avcp", "savproc", "AVctx", "avercmd", "averjac", "acttx", "avekw", "averkw", "abtx", " avconn", "avcb", "avcfg", "actctx", "avertmp", "avcmd", " avsys", "actjac", "avtmp", "savctx", "savcu", "devctx", " avcmp", "awctx", "avjp", "wavca", "avproc", "wavconn", " avtc", "aveproc", "avfunc", "afctx", "ajcontext", "avecp", "avercmp", "abcontext", "wavcfg", "averconn", "devcmd", "devtx", "captx", "avkw", " avpkg", " avtx", "avereq", "wavcontext", "avcpu", "AVcu", "abcpu", "ajcfg", "actcontext", "devkw", "awtx", "avcontext", "verconn", "avreq", "avecmd", "averreq", "actjp", "avcmp", "averctx"], "picture": ["image", "public", "piece", "summary", "style", "stat", "person", "professional", "pdf", "img", "secure", "description", " perspective", "figure", "pi", "photo", "details", " Picture", "query", "power", "import", "pty", "relative", "important", "share", " profile", "audio", "pict", "password", "iture", "family", "policy", "profile", "pen", "info", "performance", "vp", "def", "foreign", "Profile", "history", "Picture", "note", "man", "file", "comment", "command", "private", "ctx", "show", "video", "support", "please", "print", "friendly", "frame", "media", "camera", "place", "contact", "png", "pair", "position", "pic", "feat", "remember", "join", "feature"], "got_picture_ptr": ["got_picture___pointer", "got_picture_ref", "got_profile_pos", "got_pictureptptr", "got_profile_ptr", "got_photo_pad", "got_pictureptround", "got_profile_ctr", "got_picture_Ptr", "got_photo_ptr", "got_profile_pointer", "got_profile_round", "got_picture_pad", "got_picture_addr", "got_photo_Ptr", "got_picture___pointers", "got_picture_round", "got_picture___ref", "got_picture_pointers", "got_pictureptaddr", "got_picture_inst", "got_profile_pointers", "got_picture_pointer", "got_profile_addr", "got_picture___ptr", "got_pictureptpointer", "got_picture_obj", "got_picture_pos", "got_photo_pointer", "got_picture_ctr", "got_profile_ref"], "avpkt": ["avnpkin", "avtpvc", "avpacktx", "avwkg", "averpkt", "avnpnt", "avpads", "avpvt", "ahpackkt", "avbptt", "avnpacket", "avwcmd", "avcpkg", "avpvc", "avecpvc", "ahput", "avpant", "avecpkg", "avmvt", "avpadmit", "avpafx", "avpfx", "avbpkt", "avpkg", "avepkl", "avejpvt", "avejpkt", "avbpvc", "avpacket", "avdacket", "avptt", "averpds", "obpaft", "avppkg", "avpeacket", "avpds", "avecpkt", "avepvt", "ahpackket", "avmacket", "avpkl", "avcpvc", "avpemk", "rawnpacket", "rawnpkin", "avdkt", "avpefx", "ahpket", "ahpackkg", "avhfx", "averpaacket", "averpmk", "avpackkt", "averpacket", "avejpacket", "avpamit", "avhacket", "averpakt", "avdnt", "avpackacket", "averhfx", "avpackkg", "avpaykl", "avppket", "avpacmd", "avepacket", "ahpkg", "obpkt", "obpamit", "avwut", "aveptt", "avpnt", "avpakt", "obpakt", "avpackds", "rawpacket", "avwket", "avpadft", "avbpkg", "averpfx", "rawpnt", "averhacket", "rawnpnt", "avhmk", "avepkg", "avpamk", "obpcmd", "averptx", "avpackket", "averhmk", "avptx", "avhkt", "avppkt", "avtpkg", "avpayvt", "avpadkt", "avpmit", "avtptt", "averhkt", "avpmk", "avpaacket", "avjpkl", "avjpvt", "avcptt", "avwft", "averpatx", "rawnpkt", "avwkt", "avdkin", "avpayacket", "avpkin", "avpft", "obpft", "avpaft", "avpket", "rawpkt", "avput", "obpacmd", "avmkl", "avdds", "avjpacket", "avpackut", "ahpkt", "avepvc", "averpads", "avjpkt", "avpakin", "avejpkl", "avtpkt", "obpmit", "ahpackut", "avcpkt", "avpaykt", "avdtx", "avpadcmd", "avnpkt", "avwmit", "avpekt", "avepkt", "avpput", "avpcmd", "avecptt", "rawpkin", "avmkt", "avpatx"], "ret": ["success", "mt", "usr", "RET", "summary", "status", " RET", "fun", "sort", "result", "ref", "r", "out", "res", "fin", "lit", "ft", "cont", "gt", "ll", "def", "mem", "att", "Ret", "ert", "final", "al", "ort", "det", "len", "gc", "pas", "rev", "rt", "alt", "ter", "del", "print", "get", "val", "rets", "pret", "nt", "arg", "rem", "cert", "reset", "resp", "tr", "elt", "t", "re", "flag", "back", "report"], "frame_number": ["frame__number", "frame_counter", "image_number", "image_count", "image_counter", "frame__counter", "frame__id", "framepocounter", "frameponumber", "framepoid", "frame_count", "framepocount", "frame__count", "frame_id", "image_id"]}}
{"project": "qemu", "commit_id": "84a3a53cf61ef691478bd91afa455c801696053c", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 373, "substitutes": {"sbd": ["rscd", "gbc", " spd", " sbb", "csdb", "ysbd", " sbc", "ysBD", "rsdd", " sdd", " svd", "jsdd", "sdd", "rsbb", "rsBD", "ysbb", "dsbd", "ysbm", "jsbd", "dsdb", " scd", "cspd", "jsdb", "csvd", "rsbm", " sBD", "jscd", "sdb", "sbc", "dsBD", "spd", "gbd", "rsdb", "dsbc", "sbb", " sbm", "gBD", "sbm", "sBD", "scd", "csbd", "svd", " sdb", "gdb", "rsbd"], "dev": ["proc", "d", " device", "env", "device", "pro", "rad", "adv", "sh", "conn", "dd", "dep", "ev", "hw", "DE", "window", "dem", "var", " dw", "priv", "def", "mem", "pad", "gu", "sw", "ch", "sd", "w", "cam", "ver", "de", "go", "DEV", "db", "v", "eng", "nt", "h", "disc", " Dev", "ad", "av", "ve", "tr", "th", "des", "Dev", "dis"], "s": ["sys", "ls", "j", "S", "d", "stats", "l", "c", "is", "sv", "ss", "p", "es", "settings", "g", "n", "r", "details", "comm", "set", "ds", "qs", "m", "ants", "i", "b", "params", "aws", "services", "ps", "its", "parts", "js", "ns", "bs", "sw", "sd", "sing", "ims", "comments", "w", "sam", "as", "ts", "cs", "spec", "changes", "sm", "hs", "sts", "rs", "v", "h", "bits", "gs", "sb", "ats", "args", "sq", "a", "sp"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n", "idx": 391, "substitutes": {"s": ["sys", "sis", "ls", "S", "master", "c", "is", "sh", "sv", "ss", "p", "es", "source", "sl", "sa", "set", "ds", "comm", "qs", "m", "i", "b", "less", "aws", "ps", "js", "ns", "sub", "conf", "sac", "sam", "ts", "spec", "sports", "has", "rs", "v", "single", "gs", "sb", "sq", "so", "os", "raw", "obj", "a", "se", "ssl", "self", "sp"], "slave": ["student", "master", "device", "instance", "code", "ssh", "sh", " Slave", "pipe", "slice", "sl", "node", "server", "seat", "stable", " slaves", "sa", "proxy", "ds", "pause", "link", "submit", "phy", "asha", "vp", "esi", " servant", "ave", "ser", "writer", "caster", "save", "cam", "buffer", "command", "attribute", "peg", "dest", "sudo", "bridge", "address", "mi", "handler", "peer", "ve", "sb", "worker", "th", "raw", "des", "so", "sync", "se", "ssl", "capacity"]}}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n", "idx": 399, "substitutes": {"a": ["ace", "ma", "sta", "aux", "l", "eas", "er", "A", "ach", "aaa", "aj", "p", "es", "back", "ga", "la", "ca", "ab", "aa", "r", "app", "s", "out", "sa", "oa", "act", "af", "au", "access", "at", "aq", "att", "t", "ed", "ant", "w", "e", "ap", "as", "ae", "ea", "apt", "el", "area", "aka", "pkg", "ba", "ar", "an", "am", "ia", "v", "ata", "alpha", "ai", "ac", "al", "acs", "era"], "b": ["br", "d", "j", "l", "mb", "eb", "c", "bc", "back", "z", "to", "g", "ab", "pb", "r", "bp", "s", "app", "erb", "out", "cb", "rb", "lib", "i", "x", "be", "u", "other", "gb", "new", "bb", "base", "bs", "y", "bi", "bis", "e", "bg", "ob", "ba", "bin", "db", "body", "fb", "v", "bl", "by", "o", "B", "beta", "f", "sb", "nb", "ib"], "status": ["active", "sex", "code", "Status", "warning", " Status", "stat", "p", "result", "details", "progress", "tree", "res", "msg", "info", "sc", "check", "atus", "valid", "reason", "type", "uses", "sw", "error", "desc", "compl", "err", "flags", "name", "spec", "fr", "str", "gc", "scale", "negative", "tr", "flag", "st", "prefix", "state", "sync"]}}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n", "idx": 402, "substitutes": {"lexer": ["pollter", "poller", "lexner", "lexber", " lexber", "flexer", "taxber", "logner", "Lexener", " lexiter", "ixner", "lexener", " lexner", "taxiter", "taxe", " lexter", " lexger", "speer", "pollger", "pollner", "lexiner", "lexe", "ixener", "wordber", "flexter", "Lexer", "lexiter", "Lexter", "spener", "worder", "flexiter", "ixe", "taxer", "pollener", "flexner", "ixer", " lexe", "polliner", "loger", "lexter", "Lexger", "spee", "worde", "flexener", "logter", "worditer", "logiter", "speener", "Lexiner", " lexener", "lexger", "flexiner"], "func": ["aux", "fc", "mb", "code", "unc", "conv", "fun", " fun", "result", "fac", "cb", "coord", "m", "res", " fn", "new", " fmt", "msg", "req", "job", "xy", "impl", "kw", "update", "cf", "apply", "callback", "lambda", "as", "ctx", "function", "val", "handler", "expr", "event", "f", "fn", "exec", "obj", "cmd", " function"]}}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n", "idx": 404, "substitutes": {"bs": ["ls", "cks", "bc", "bh", "bd", "ss", "bm", "pb", "bp", "ses", "ds", "b", "aks", "fs", "ubs", "lbs", "BS", "lb", "gb", "obs", "ps", "its", "bb", "bos", "ns", "bt", "aos", "bi", "bis", "cs", "ts", "ba", "bps", "bits", "gs", "bas", "sb", "bf", "aus"], "fd": ["fp", "d", "rd", "id", "fc", "ff", "dt", "nd", "dd", " fid", "dir", "fat", "ds", "td", "dat", "fin", "fed", "fs", "pos", "ed", "fi", "sd", "hd", "disk", "dl", "fps", "df", "cond", "fe", "db", "fee", "du", "sector", "f", "pd", "FD", "fn", "bf", "pid", "fm"], "sector_num": ["sector_orig", "sector_no", "sectorPNum", "piece_num", "piece_orig", "sector_Num", "piece_nom", "sector_nom", " sector_no", "sector_prim", "sectorPindex", "piece_prim", "sectorPnum", "sector_index", " sector_index", " sector_Num"], "qiov": ["quiour", "quiev", "sqiov", " qkov", "quiop", "sqiv", " qiour", "qrov", "qios", "sqiour", "Qiop", " quj", "sqiop", " qigroup", "qquj", "qiour", "Qiov", "quiv", "requiv", "qqios", "qqiev", "quiov", " qrov", " qiv", "qkov", "qiop", "quj", "quios", "qqiov", "qukov", "qigroup", " qios", "requiov", " qiev", "qiev", "requiev", "requrov", "Qigroup", "Qkov", "qurov", "qiv", "quigroup", "quuj", " qiop"], "nb_sectors": ["nb__veriers", "nb_seors", "nb__sectors", "nb__sellers", "nb_selements", "nb_elements", "nb_veriers", "nb_veors", "nb_eivers", "nb_pegments", "nb_bectors", "nb_sections", "nb_vevers", "nb_seriers", "nb_spectors", "nb_pectors", "nb_segments", "nb_ectors", "nb__veors", "nb_severs", "nb_pellers", "nb__vectors", "nb_spellers", "nb_egments", "nb_peivers", "nb_psections", "nb_psellers", "nb_speriers", "nb_vections", "nb_speors", "nb_seivers", "nb_psectors", "nb_pelements", "nb_bevers", "nb__seors", "nb_vellers", "nb__vellers", "nb_peors", "nb_periers", "nb_psevers", "nb_bellers", "nb_bections", "nb_sellers", "nb__seriers", "nb_vectors"], "cb": ["fp", "obb", "cp", "fc", "cd", "CB", "func", "dt", "c", "eb", "ub", "bc", "nc", "conn", "kb", "dc", "erb", "pb", "cfg", "rb", "b", "cli", "cgi", "lb", "gb", "bt", "cell", "conf", "cf", "cv", "callback", "ctx", "abb", "db", "fb", "cc", "cmd", "sb", "bf", "ck", "nb", "ctrl"], "opaque": ["oppaques", "suppacity", "ocaque", "oppartment", " opula", " opque", " open", "open", " opartment", "suppen", "oputo", "oppen", "oppula", "pacity", "opputo", "ocula", "ocque", "paque", "opartment", "opacity", "upputo", "paques", "uppaques", "suppartment", "ocacity", "opque", "opula", "oppque", "opaques", "puto", "uppaque", "uppacity", "oppaque", "oppacity", " opacity", "suppaque"], "type": ["id", "Type", "oid", "ype", "ty", "test", "key", " ty", "size", "value", "status", "pc", "dt", "port", "style", "to", "ico", "kind", "family", "info", "pe", "weight", "tp", "time", "tag", "state", "error", "role", "name", "ver", "TYPE", "types", "what", "by", "handler", "f", "unit", "timeout", "t", "tc", "TY", "length", "typ"], "acb": ["abdb", "sacbar", "acerbe", "acerbuilder", "ac2", " acba", "Acdb", "acv", " cacl", "ach", "accbe", " cacbc", " acB", "accbc", "sacn", "aucl", "Acfb", "acsb", "facdb", "racbuilder", "icanb", "abfb", " acsb", "aclb", "can", "accsb", "facba", "acgb", "cab", " acl", " cacub", "acba", "acwb", "iacbt", "macbb", "ancsb", "acfb", "sacwb", " cacrb", " cacb", "acrb", "facl", "icanl", "facgb", "cabb", "ascb", " acc", "sac2", " cacy", "sacbuilder", "iach", "acl", "accub", "sacb", " cacwb", "macb", "acbt", "accxb", "icsb", "acla", "pacy", "accbt", "accb", "accpb", " acbe", "aucbe", "accbb", "aclsb", " acn", "ancc", "aclub", "sacrb", "icb", "acerb", "sacv", "accp", "iacl", "abgb", "ancrb", "aclxb", "icB", "aca", "acB", "facfb", "acc", "acdb", "ACn", "iacbe", "Acgb", "aclp", " acbb", "iacpb", "ancb", "iacsb", "ascl", "accl", "sacbb", "facn", "ACb", "ancv", "sacsb", "acxb", "acbar", "acbe", " cacxb", "ACl", "acpb", "sacc", " cacbar", "abn", "pac2", "ascn", "acca", " cacbt", "abh", "icbe", "aucpb", "abbt", "iacn", "sacbe", "ancbar", "accba", "icanbt", "acerba", "racba", "aucb", "facb", "acbuilder", "sacba", "pacb", "acbc", " aca", "Acb", " acp", "ascbe", "ACbe", " cacsb", " ach", "acy", "cabe", "abb", "iacB", "acub", "icanbc", "accn", "acbb", "acn", "racb", " acv", "aclbe", "acp", "macbe", "abbe", "racbe", "pacwb", "iacb", "sacy", " cac2"]}}
{"project": "FFmpeg", "commit_id": "c8d0d8bc767309d5e8d9ee64addc11117190338e", "target": 1, "func": "static int crypto_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    const char *nested_url;\n\n    int ret;\n\n    CryptoContext *c = h->priv_data;\n\n\n\n    if (!av_strstart(uri, \"crypto+\", &nested_url) &&\n\n        !av_strstart(uri, \"crypto:\", &nested_url)) {\n\n        av_log(h, AV_LOG_ERROR, \"Unsupported url %s\\n\", uri);\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n\n\n    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {\n\n        av_log(h, AV_LOG_ERROR, \"Key or IV not set\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n    if (flags & AVIO_FLAG_WRITE) {\n\n        av_log(h, AV_LOG_ERROR, \"Only decryption is supported currently\\n\");\n\n        ret = AVERROR(ENOSYS);\n\n        goto err;\n\n    }\n\n    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {\n\n        av_log(h, AV_LOG_ERROR, \"Unable to open input\\n\");\n\n        goto err;\n\n    }\n\n    c->aes = av_mallocz(av_aes_size);\n\n    if (!c->aes) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto err;\n\n    }\n\n\n\n    av_aes_init(c->aes, c->key, 128, 1);\n\n\n\n    h->is_streamed = 1;\n\n\n\n    return 0;\n\nerr:\n\n    av_free(c->key);\n\n    av_free(c->iv);\n\n    return ret;\n\n}\n", "idx": 436, "substitutes": {"h": ["enh", "q", "zh", "l", "he", "ph", "self", "host", "handle", "bh", "sh", "p", "kh", "hr", "g", "eh", "hw", "r", "oh", "ah", "H", "hh", "her", "comm", "hp", "m", "b", "dh", "ih", "cache", "it", "history", "http", "y", "ch", "hd", "hl", "context", "rh", "hi", "here", "ctx", "hal", "hm", "hs", "hz", "v", "ha", "hash", "help", "th", "ht"], "uri": ["fp", "domain", "id", "q", "iri", "directory", "URI", "universal", "uni", "source", "web", "har", "nil", "pi", "ugi", "qi", "query", "path", "url", "html", "i", "u", "ur", "ui", "phi", "picture", "request", "filename", "base", "location", "connection", "archive", "http", "file", "username", "hi", "iu", " URI", "resource", "uid", "ir", "origin", "io", "remote", "queue", "uu", "address", "du", "uv", "nu", "ri", "href", "prefix", "subject", "this"], "flags": ["wcs", "atts", "acts", "actions", "settings", "files", "workers", "names", "details", "weights", "options", "Flags", "utils", "links", "vals", "lf", "params", "locks", "fields", "pages", "heads", "cons", "ps", "fl", "features", "planes", "tags", "lag", "comments", "fps", "levels", "pins", "ts", "cs", "facts", "ags", "properties", "posts", "bits", "gs", "states", "flag", "ats", "args", "ops"], "nested_url": ["nested_str", "nestedtloc", "nested_link", "nesting_domain", "nest_url", "nesting_Url", "nestedturl", "nesting_url", "nestedtpath", "nappedtloc", "napped_url", "nappedtpath", "nesting_l", "nesting_uri", "nestedlyurl", "napped_loc", "nested_Url", "nested_domain", "nested_l", "nestedtstr", "napped_str", "nappedtstr", "nappedturl", "nest_l", "nesting_str", "napped_path", "nest_link", "nest_uri", "nested_loc", "nestedlyl", "nestedlystr", "nestedlydomain", "nested_path", "nested_uri"], "ret": ["mt", "RET", "try", "ext", "out", "off", "gt", "ber", " Ret", "pas", "rm", "pass", "f", "reset", "resp", "mem", "re", "back", "result", "deg", "ll", "it", "Ret", "gc", "rev", "ter", "del", "alt", "get", "nt", "arg", "tr", "elt", "rel", "j", "l", "jp", "dt", "addr", "nl", " RET", "fun", "ref", "lt", "res", "att", "err", "compl", "str", "val", "rets", "det", "rem", "len", "cmd", "prop", "status", "arr", "il", "Return", "txt", "r", "ft", "def", "desc", "rt", "reg", "print", "pret", "t", "alg"], "c": ["ec", "d", "cp", "chain", "fc", "cr", "l", "xc", "bc", "nc", "p", "conv", "g", "n", "dc", "ca", "ci", "comm", "cb", "lib", "com", "b", "ce", "C", "cont", "etc", "cache", "cur", "config", "can", "t", "conf", "ch", "cf", "cv", "cam", "w", "tc", "cs", "ctx", "con", "co", "coll", "gc", "anc", "v", "abc", "cu", "cc", "ct", "cl", "col", "f", "cm", "rc", "lc", "ac", "enc", "mc", "a", "ctrl"]}}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 439, "substitutes": {"avctx": [" avproc", "avesys", "avconn", "afsys", "avectx", "navdesc", "navproc", "avsys", "avcu", "Avcontext", "avproc", "iverproc", "afctx", "navpc", "avepkg", "wavpkg", "navctx", "navcontext", "wavctx", " avcontext", "wavcontext", "ivercontext", "iverctx", "Avconn", "avcontext", "avpkg", "avpc", "navconn", "avecontext", "wavsys", "afdesc", "afpkg", "afcontext", " avcu", " avconn", "avdesc", "iverdesc", "Avpc", "afcu", "ivercu", "navcu", "Avctx", " avpc"], "count": ["total", "Count", "id", "number", "message", "batch", "try", "add", "list", "size", "skip", "code", "c", "z", "all", "only", "n", "index", "counter", "sum", "b", "num", "C", "cont", "info", "cache", "found", "amount", "type", "cmp", "t", "call", "OUNT", "buffer", "len", "gc", "ind", "now", "consider", "cc", "nt", "ct", "ount", "current", "max", "th", "nb", "base", "length"], "i": ["multi", "batch", "j", "id", "key", " m", "ii", "ki", " mi", "c", " j", "ji", "is", "sim", "g", "n", "xi", "ski", "pi", "window", "qi", "me", "index", "li", "ci", "m", "ei", "x", "u", "cli", "us", "ui", "info", "phi", "it", "gi", "series", "history", "ip", " ii", "gu", "y", "fi", "ims", "bi", "e", "hi", "iu", "ti", "span", "go", "uri", "ix", "print", "v", "remote", "uu", "zi", "in", "mi", "di", "\u0438", "ai", "I", "si", "ri", "t", "yi", "chain"], "p": ["fp", "php", "proc", "j", "cp", "public", "q", "d", "lp", "wp", "l", "br", "op", "jp", "er", "pc", "status", "port", "up", "g", "pm", "P", "pb", "np", "bp", "pi", "app", "pp", "power", "progress", "patch", "hp", "pg", "b", "parse", "part", "policy", "info", "pe", "cache", "vp", "at", "ps", "tp", "ip", "local", "pa", "w", "xp", "ap", "complete", "pl", "comp", "pool", "pkg", "pt", "post", "per", "pre", "process", "h", "dp", "pers", "admin", "f", "pd", "resp", "par", "rep", "ping", "pro"]}}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444, "substitutes": {"filename": ["fp", "ames", "journal", "wav", "fil", "FIL", "directory", "unc", "ename", "files", "n", "fle", "txt", "nil", "lua", "kj", "figure", "kl", "path", "csv", "ame", "family", "stem", "None", "title", "println", "tp", "file", "username", "name", "aka", "nm", "FN", "uri", "nature", "til", "jpg", "Filename", "null", "flake", "original", "src", "f", "fn", "prefix", "subject"], "fd": ["fp", "dial", "d", "fx", "fc", "ff", "cd", "FH", "dt", "nd", "bd", "conn", "dd", " fid", "dir", "ds", "cb", "dig", "td", "dat", "fin", "wind", "fed", "fs", "gd", "fl", "ed", "fi", "sd", "hd", "cf", "ptr", "dl", "wd", "disk", "df", "stream", "fr", "cond", "ln", "ind", "db", "ud", "fb", "od", "xd", "fee", "ini", "gz", "f", "pd", "FD", "fn", " ff", "pid", "bf", "elt", "da", "ld"], "ret": ["success", "mt", "br", "usr", "RET", "et", "status", "quad", "ext", "nl", "fun", "result", "after", "txt", "deg", "lt", "iter", "rect", "out", "url", "leg", "res", "fin", "ft", "ne", "cont", "gt", "ll", "def", "mem", "att", "reply", "Ret", " Ret", "fi", "nat", "tail", "err", "tn", "len", "rt", "alt", "rev", "ter", "val", "rm", "rets", "arg", "nt", "nz", "cmd", "det", "tr", "rem", "reset", "cert", "resp", "elt", "t", "re", "des", "back", "not", "inter", "mail"], "fdparam": ["cfprom", "bfParam", "cfaram", "dparams", "fdparams", "FDprom", "dparam", "fdParam", "bfaram", "FDparam", "bfparam", "fdprom", "cfParam", "FDaram", "FDparams", "dParam", "ndParam", "daram", "FDParam", "ndprom", "cfparam", "bfparams", "fdaram", "ndaram", "ndparam"], "st": ["mt", "inst", "sta", "ste", "et", "l", "ut", "rest", "stru", "nd", "sth", "tt", "sh", "z", "stat", "ast", "p", "sl", "r", "stable", "ust", "set", " ss", "ST", "start", " stat", "sc", "cont", "state", " ST", "sw", "end", "ist", "fr", "sty", "str", " est", "rt", "sm", "sts", "ct", "est", "ost", "cl", "so", "sn", "th", "t", "stage", "se", "std", "St", "sp"]}}
{"project": "qemu", "commit_id": "7d55273fcdc307399fc0e327a0c14c140cd439cf", "target": 0, "func": "static void sun4uv_init(ram_addr_t RAM_size,\n\n                        const char *boot_devices,\n\n                        const char *kernel_filename, const char *kernel_cmdline,\n\n                        const char *initrd_filename, const char *cpu_model,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    CPUState *env;\n\n    char *filename;\n\n    m48t59_t *nvram;\n\n    int ret, linux_boot;\n\n    unsigned int i;\n\n    ram_addr_t ram_offset, prom_offset;\n\n    long initrd_size, kernel_size;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    QEMUBH *bh;\n\n    qemu_irq *irq;\n\n    int drive_index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n    void *fw_cfg;\n\n    ResetData *reset_info;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    bh = qemu_bh_new(tick_irq, env);\n\n    env->tick = ptimer_init(bh);\n\n    ptimer_set_period(env->tick, 1ULL);\n\n\n\n    bh = qemu_bh_new(stick_irq, env);\n\n    env->stick = ptimer_init(bh);\n\n    ptimer_set_period(env->stick, 1ULL);\n\n\n\n    bh = qemu_bh_new(hstick_irq, env);\n\n    env->hstick = ptimer_init(bh);\n\n    ptimer_set_period(env->hstick, 1ULL);\n\n\n\n    reset_info = qemu_mallocz(sizeof(ResetData));\n\n    reset_info->env = env;\n\n    reset_info->reset_addr = hwdef->prom_addr + 0x40ULL;\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n    main_cpu_reset(reset_info);\n\n    // Override warm reset address with cold start address\n\n    env->pc = hwdef->prom_addr + 0x20ULL;\n\n    env->npc = env->pc + 4;\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->prom_addr,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        ret = load_elf(filename, hwdef->prom_addr - PROM_VADDR,\n\n                       NULL, NULL, NULL);\n\n        if (ret < 0) {\n\n            ret = load_image_targphys(filename, hwdef->prom_addr,\n\n                                      (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\n\n                                  TARGET_PAGE_MASK);\n\n        }\n\n        qemu_free(filename);\n\n    } else {\n\n        ret = -1;\n\n    }\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = 0;\n\n    initrd_size = 0;\n\n    if (linux_boot) {\n\n        /* XXX: put correct offset */\n\n        kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                    ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              KERNEL_LOAD_ADDR,\n\n                                              ram_size - KERNEL_LOAD_ADDR);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_size = load_image_targphys(initrd_filename,\n\n                                              INITRD_LOAD_ADDR,\n\n                                              ram_size - INITRD_LOAD_ADDR);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        }\n\n        if (initrd_size > 0) {\n\n            for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) {\n\n                if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { // HdrS\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR);\n\n                    stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\n\n                           &pci_bus3);\n\n    isa_mem_base = VGA_BASE;\n\n    pci_vga_init(pci_bus, 0, 0);\n\n\n\n    // XXX Should be pci_bus3\n\n    pci_ebus_init(pci_bus, -1);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,\n\n                       serial_hds[i], 1);\n\n        i++;\n\n    }\n\n    for(; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], NULL/*serial_irq[i]*/, 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], NULL/*parallel_irq[i]*/,\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS);\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n\n                                      i % MAX_IDE_DEVS);\n\n       if (drive_index != -1)\n\n           hd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           hd[i] = NULL;\n\n    }\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    /* FIXME: wire up interrupts.  */\n\n    i8042_init(NULL/*1*/, NULL/*12*/, 0x60);\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        drive_index = drive_get_index(IF_FLOPPY, 0, i);\n\n       if (drive_index != -1)\n\n           fd[i] = drives_table[drive_index].bdrv;\n\n       else\n\n           fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(NULL/*6*/, 2, 0, 0x3f0, fd);\n\n    nvram = m48t59_init(NULL/*8*/, 0, 0x0074, NVRAM_SIZE, 59);\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 461, "substitutes": {"RAM_size": ["ramLLspace", "RAM_space", "ram_space", "RAM_SIZE", "ram_align", "RAM_align", "ramLLalign", "ramLLSIZE", "ramLLsize", "ram_SIZE", "ram_size"], "boot_devices": ["serial_pages", "bootedgpu", "serial_blocks", "booteddevices", "bootedpages", "boot_blocks", "boot_pages", "serialabledevices", "serialablepages", "boot_gpu", "serial_devices", "bootablegpu", "serialableblocks", "bootablepages", "serialablegpu", "bootabledevices", "serial_gpu", "bootedblocks", "bootableblocks"], "kernel_filename": ["system_file", "cpu_fn", "kernel_path", "kernel_fn", "system_processor", "kernel_file", "kernel_processor", "cpu_path", "cpu_file", "kernel_cmd", "system_cmd", "system_filename", "cpu_filename"], "kernel_cmdline": ["kernel_extline", "kernel_extl", "kernel_commandlines", "kernel_extlines", "kernel_commandl", "kernel_commandline", "kernel_cmdlines", "kernel_callline", "kernel_cmdl", "kernel_calllines", "kernel_calll"], "initrd_filename": ["initrd_file", "initrd_fn", "initrs_file", "initrs_files", "initrs_filename", "initrd_files", "initrs_fn"], "cpu_model": ["cpuitysettings", "gpu_link", "core_mode", "cpu_mode", "core_models", "pu_Model", "cpu_settings", "cpu_Model", "cpu_models", "gpu_models", "gpu_mode", "pu_model", "default_machine", "cpuitymode", "cpu_machine", "pu_models", "pu_link", "default_Model", "cpuitymodel", "cpuitymodels", "core_settings", "core_model", "default_model", "gpu_model", "default_models", "cpu_link"], "hwdef": ["hzDef", "fwdef", "hwDef", "fwf", "wxdefault", "cowf", "hzdict", "hwf", "fwdefined", "hubDef", "hwobj", "hwdefault", "wxDef", "hwdata", "hdobj", "hardDef", "htobj", "iwdict", "iwdefine", "hwdict", "fwdata", "iwdefined", "hdDEF", "harddef", "htdef", "hwdefine", "cowdata", "htDef", "iwdefinition", "fwDEF", "hhDef", "hubdef", "hddef", "cowdef", "hwDEF", "hhdefine", "hddefinition", "harddata", "hdDef", "fwobj", "fwDef", "hwdefined", "hhdict", "iwdef", "hzdef", "cowDef", "iwDef", "hubdefined", "hhdef", "iwdefault", "hardf", "wxdef", "hzdefine", "wxdefinition", "hddefault", "hwdefinition", "htDEF"], "env": ["usr", "eas", "ext", "ent", "ev", "window", "hw", "server", "ner", "eg", "vp", "ef", "conf", "vm", "context", "ae", "here", "equ", "nav", "manager", "console", "h", "te", "sb", "mem", "serv", "eng", "era", "ec", "net", "operator", "sv", "vs", "erb", "cb", "environment", "esc", "export", "msg", "shell", "end", "den", "ew", "door", "iev", "uv", "esm", "ger", "inst", "er", "buf", "code", "gear", "vr", "eh", "actor", "ah", "vt", "engine", "ei", "eni", "info", "entry", "network", "dev", "forge", "eu", "ed", "hl", "el", "en", "ea", "ctx", "ped", "db", "v", "oe", "erd", "ve", "worker", "Environment", "proc", "et", "inv", "eb", "conn", "org", "img", "cfg", "nv", "em", "pe", "desc", "cv", "e", "ja", "event", "ee", "state", "obj", "eve", "dn"], "filename": ["fp", "fil", "nam", "ename", "files", "tty", "kl", "processor", "fs", "family", "stem", "location", "file", "username", "disk", "buffer", "nm", "uri", "til", "Filename", "driver", "src", "fn", "prefix", "cmd", "rn"], "nvram": ["NVmem", "vmem", "nvgram", "vrum", "NVgram", "NVrum", "tvrum", "tvmem", "tvgram", "nvmem", "tvram", "NVram", "vram", "vgram", "nvrum"], "ret": ["sys", "RET", "net", "status", "format", "ref", "set", "res", "lit", "ll", "def", "mem", "Ret", "irm", "fi", "ter", "rt", "reg", "ry", "val", "nt", "rem", "reset", "flag", "cmd"], "linux_boot": ["Linux_out", "Linux_boot", "linux_bus", "linux_Boot", "linux_out", "Linux_soft", "linux__out", "linux_soft", "Linux_Boot", "Linux_bus", "linux__boot", "Linux_start", "linux_start", "linux__Boot", "linux__start"], "i": ["j", "l", "ii", "p", "iy", "pi", "li", "ci", "m", "b", "info", "it", "fi", "ip", "y", "bi", "ti", "io", "ia", "v", "mi", "di", "o", "si", "I", "f", "t"], "ram_offset": ["RAM_offset", "ram_pos", "ram_addr", "RAM_addr", "RAM_pos", "ram_size"], "prom_offset": ["prom__offset", "prom__pos", "prom_addr", "rem_pos", "prom_address", "prom__address", "rem_address", "prom__addr", "prom_pos", "rem_addr", "rem_offset"], "initrd_size": ["initrdtlen", "initr_size", "initrdtsize", "initrtsum", "initrd_area", "initrtlen", "initrtsize", "initrdlylen", "initrdlysize", "initrd_len", "initr_area", "initrd_sum", "initr_len", "initrdlyarea", "initrdtarea", "initr_sum", "initrdlysum", "initrdtsum", "initrtarea"], "kernel_size": ["kernel_index", "program_length", "program_size", "kernel_length", "program_index", "kernel_name", "program_name"], "pci_bus": ["pci_us", "pdi_driver", "pci_driver", "pdi_boot", "pdi_us", "pci2driver", "pdi_bus", "pci___driver", "pci2bus", "pci___boot", "pci___us", "pci___bus", "pci2us", "pci2boot", "pci_boot"], "pci_bus2": ["pci__bus3", "pci__dev3", "pci_BUS3", "pci_boot2", "pci_boot1", "pci_boot0", "pci__dev0", "pci__dev1", "pci_BUS2", "pci__bus2", "pci_dev3", "pci_dev2", "pci__dev2", "pci_BUS1", "pci_bus1", "pci_boot3", "pci__bus0", "pci_bus0", "pci_dev0", "pci_BUS0", "pci_dev1", "pci__bus1"], "pci_bus3": ["pci_device7", "pci_bus5", "pci_dev5", "pci_device5", "pci_block7", "pci_block3", "pci_block2", "pci_block5", "pci_dev3", "pci_device3", "pci_device2", "pci_dev2", "pci_dev7", "pci_bus7"], "bh": ["br", " inh", "hirt", "eth", "zh", "lr", "bec", "eb", "bj", "vr", "sh", "bd", "kh", "uh", "hr", "eh", "ssl", "ash", "hw", "bone", "pb", "oh", "ah", "hh", "bp", "orth", "hp", "phy", "b", "lb", "dh", "ih", "phi", "bol", "bb", "bt", "bs", "hub", "ldon", "beck", "hl", "bash", "bis", "rh", "ctx", "abb", "igh", "pkg", "pas", "hal", "bo", "hz", "fb", "bridge", "bang", "ha", "hab", "bl", "h", "sb", "fn", "bf", "bn", "hn", "hun", "ht"], "irq": ["irv", "prck", "pirv", "IRck", "pirq", "prv", "irqs", "prq", "IRq", "IRqs", "irck", "pirqs", "pirck", "IRv", "prqs"], "drive_index": ["drive__id", "drive_id", "drive__index", "drive_num", "driver_num", "driver_id", "drive_addr", "drive__num", "driver_addr", "driver_index", "drive__addr"], "hd": ["he", "dt", "sh", "bd", "kb", "dd", "hw", "hp", "md", "dh", "him", "haw", "dq", "hl", "dl", "rh", "ht", "hs", "hz", "dr", "ha", "hid", "HD", "pd", "ck", "vd", "hn", "ld", "dn"], "MAX_IDE_BUS": ["MAX_ID_US", "MAX_ID_BS", "MAX_IDEOPBS", "MAX_IDE_US", "MAX_ID_TX", "MAX_IDEOPTX", "MAX_IDE_TX", "MAX_ID_BUS", "MAX_IDEOPUS", "MAX_IDEOPBUS", "MAX_IDE_BS"], "MAX_IDE_DEVS": ["MAX_IDE_DIYS", "MAX_IDE_DIVS", "MAX_IDE_DEYS", "MAX_IDE2DABS", "MAX_IDE_DAPS", "MAX_IDE_DPS", "MAX_IDE2DAYS", "MAX_IDE_DAVS", "MAX_IDE2DAPS", "MAX_IDE_DEPS", "MAX_IDE_DEBS", "MAX_IDE_DABS", "MAX_IDE_DIBS", "MAX_IDE2DEBS", "MAX_IDE_DIPS", "MAX_IDE_DYS", "MAX_IDE_DVS", "MAX_IDE_DAYS", "MAX_IDE2DEYS", "MAX_IDE2DEPS", "MAX_IDE2DAVS", "MAX_IDE_DBS", "MAX_IDE2DEVS"], "fd": ["fp", "fc", "ff", "cd", "dt", "bd", "dd", "dir", "fat", "ds", "fin", "fs", "md", "dh", "def", "fl", "ef", "fi", "sd", "dl", "wd", "df", "fr", "db", "fb", "dr", "f", "pd", "FD"], "MAX_FD": [" MAX_FILE", "MAX_DF", "MAX_FILE", "MAX_DIR", " MAX_DIR", " MAX_DF"], "fw_cfg": ["fw2cfg", "fw_conf", "FW_cfg", "FW_config", "fw_config", "FW_fg", "fw2fg", "fw_fg", "fw2conf", "FW_conf", "fw2config"], "reset_info": [" reset_attr", "memingflag", "reseterInfo", "reseterinfo", "resetationdata", "resetationno", "reset___information", "reset_ini", "memingstate", "resetedhistory", "init_data", "init_info", "reset_details", "init_INFO", "et_history", "reseterinformation", "mem_state", " reset_Info", "reseterfo", "resetedfo", "reset2data", "reset_flag", "reseterattr", "reset_Info", "reset_history", "reset_id", "init_id", "reset2Info", "resetabledata", "reset2info", "starter_details", "resetingflag", "eterinfo", "resetedinfo", "resetinginformation", "reset_INFO", "starter_info", "resetationfo", "mem_flag", "resetingstate", "et_fo", "resetationini", "reset_fo", "reset___Info", "eterfo", "reseterno", "starter_INFO", "reset___state", "resetationinfo", "resetationhistory", "reset_no", "meminginformation", "resetableid", "resetationInfo", "reset_attr", "reset___flag", "resetedno", "resetableINFO", "reseterhistory", "eterno", " reset_ini", " reset_information", "mem_information", "reset_state", " reset_data", "meminginfo", "starter_information", "resetableinfo", "eterhistory", "resetinginfo", "et_info", "et_no", "reset_information", "reset___attr", "reset_data", "mem_info", "reset___info", "reset2ini"]}}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n", "idx": 474, "substitutes": {"env": ["init", "ev", "window", "hw", "server", "ner", "ef", "conf", "vv", "context", "response", "equ", "manager", "que", "queue", "ten", "enter", "eng", "era", "ec", "sv", "vs", "viron", "ds", "environment", "esc", "shell", "end", "die", "ter", "ew", "door", "uv", "expr", "enc", "er", "code", "buf", "addr", "eh", "ah", "engine", "entry", "cur", "dev", "forge", "block", "hl", "err", "el", "en", "ctx", "ob", "EN", "db", "v", "ov", "oe", "erd", "ve", "worker", "exec", "Environment", "doc", "et", "eb", "conn", "org", "txt", "cfg", "nv", "em", "config", "cv", "e", "En", "event", "ee", "store", "obj", "dn"], "def": ["doc", "DEF", "fc", "prop", "buf", "fam", "init", "ref", "definition", "dem", "crit", "out", "decl", "act", "res", "lit", "form", "info", "req", "defined", "ef", "vec", "dev", "conf", "define", "block", "desc", "Def", "df", "spec", "de", "det", "cmd", "pro"], "i": ["multi", " wi", "j", "chain", "id", "key", " m", "ii", "l", "ki", " mi", " j", "p", "sim", "n", "xi", "ic", "pi", "me", "index", "s", "li", "ci", "iter", "ami", "m", " e", "em", "x", "cli", "us", "ui", "phi", "it", "gi", "ex", " ti", "ip", " ii", "gu", "y", " pi", "ims", "bi", "im", "e", "ti", " my", " I", " iter", " p", " v", "ind", " li", "ix", "v", "zi", "mi", "ini", "di", "o", "ai", "I", "si", " multi", " bi"]}}
{"project": "FFmpeg", "commit_id": "ccc27e2139336b66cdec3bb73a2cc7e60ef7e599", "target": 1, "func": "static int bfi_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size = avpkt->size;\n\n    BFIContext *bfi = avctx->priv_data;\n\n    uint8_t *dst = bfi->dst;\n\n    uint8_t *src, *dst_offset, colour1, colour2;\n\n    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n\n    uint32_t *pal;\n\n    int i, j, height = avctx->height;\n\n\n\n    if (bfi->frame.data[0])\n\n        avctx->release_buffer(avctx, &bfi->frame);\n\n\n\n    bfi->frame.reference = 1;\n\n\n\n    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* Set frame parameters and palette, if necessary */\n\n    if (!avctx->frame_number) {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_I;\n\n        bfi->frame.key_frame = 1;\n\n        /* Setting the palette */\n\n        if (avctx->extradata_size > 768) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Palette is too large.\\n\");\n\n            return -1;\n\n        }\n\n        pal = (uint32_t *)bfi->frame.data[1];\n\n        for (i = 0; i < avctx->extradata_size / 3; i++) {\n\n            int shift = 16;\n\n            *pal = 0;\n\n            for (j = 0; j < 3; j++, shift -= 8)\n\n                *pal +=\n\n                    ((avctx->extradata[i * 3 + j] << 2) |\n\n                    (avctx->extradata[i * 3 + j] >> 4)) << shift;\n\n            pal++;\n\n        }\n\n        bfi->frame.palette_has_changed = 1;\n\n    } else {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_P;\n\n        bfi->frame.key_frame = 0;\n\n    }\n\n\n\n    buf += 4; // Unpacked size, not required.\n\n\n\n    while (dst != frame_end) {\n\n        static const uint8_t lentab[4] = { 0, 2, 0, 1 };\n\n        unsigned int byte   = *buf++, av_uninit(offset);\n\n        unsigned int code   = byte >> 6;\n\n        unsigned int length = byte & ~0xC0;\n\n\n\n        if (buf >= buf_end) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input resolution larger than actual frame.\\n\");\n\n            return -1;\n\n        }\n\n\n\n        /* Get length and offset(if required) */\n\n        if (length == 0) {\n\n            if (code == 1) {\n\n                length = bytestream_get_byte(&buf);\n\n                offset = bytestream_get_le16(&buf);\n\n            } else {\n\n                length = bytestream_get_le16(&buf);\n\n                if (code == 2 && length == 0)\n\n                    break;\n\n            }\n\n        } else {\n\n            if (code == 1)\n\n                offset = bytestream_get_byte(&buf);\n\n        }\n\n\n\n        /* Do boundary check */\n\n        if (dst + (length << lentab[code]) > frame_end)\n\n            break;\n\n\n\n        switch (code) {\n\n\n\n        case 0:                //Normal Chain\n\n            if (length >= buf_end - buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Frame larger than buffer.\\n\");\n\n                return -1;\n\n            }\n\n            bytestream_get_buffer(&buf, dst, length);\n\n            dst += length;\n\n            break;\n\n\n\n        case 1:                //Back Chain\n\n            dst_offset = dst - offset;\n\n            length *= 4;        //Convert dwords to bytes.\n\n            if (dst_offset < bfi->dst)\n\n                break;\n\n            while (length--)\n\n                *dst++ = *dst_offset++;\n\n            break;\n\n\n\n        case 2:                //Skip Chain\n\n            dst += length;\n\n            break;\n\n\n\n        case 3:                //Fill Chain\n\n            colour1 = bytestream_get_byte(&buf);\n\n            colour2 = bytestream_get_byte(&buf);\n\n            while (length--) {\n\n                *dst++ = colour1;\n\n                *dst++ = colour2;\n\n            }\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    src = bfi->dst;\n\n    dst = bfi->frame.data[0];\n\n    while (height--) {\n\n        memcpy(dst, src, avctx->width);\n\n        src += avctx->width;\n\n        dst += bfi->frame.linesize[0];\n\n    }\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = bfi->frame;\n\n    return buf_size;\n\n}\n", "idx": 490, "substitutes": {"avctx": ["avctl", "avergc", "avconn", "avectx", "ajreq", "averconfig", "avectl", "ajcmp", "avercontext", "avejp", "avjac", "ajsys", "avertx", "avegc", "AVconn", "abcmp", "averctl", " avctl", "wavcc", "wavjac", "avecontext", "avercu", "wavcmp", "avernp", "AVcontext", "ajvoc", "avesys", "avconfig", "avercp", "avvoc", "ravvoc", "avsys", "wavtx", "avnp", " avjp", "avtx", "avcu", "wavnp", "ajcu", "ajtx", "ajctx", "abctx", " avcontext", "avgc", "ravreq", "ravcmp", "avercc", "avecmp", "ajjac", "avecv", "averjp", "ravcontext", "abgc", "abconn", "avconf", "aversys", " avgc", "avecu", "afgc", "avercv", "wavctl", "AVcmd", "wavconf", "wavctx", "avcp", "AVctx", "avercmd", "afcv", "averjac", "averconf", "ajcc", "abctl", "ajconfig", "avcc", "abtx", "afcmp", " avconn", " avcmd", "ajcmd", " avconf", "avcmd", "ravjac", " avcmp", "avjp", "abcu", "aveconn", "afctx", "ajcontext", "avejac", "avecp", "avercmp", "abcontext", "avervoc", "avenp", "averconn", " avtx", "averctx", "wavcontext", " avjac", "avcv", "ajcp", "avcontext", "avreq", " avcu", "avecmd", "averreq", "ravconfig", "avcmp", "ravctx"], "data": ["id", "p", "window", "read", "load", "output", "buffer", "bytes", "done", "feed", "fn", "apps", "batch", "d", "Data", "list", "next", "actions", "text", "filter", "at", "end", "file", "stream", "name", "first", "offset", "frame", "padding", "max", "button", "rel", "chain", "device", "size", "multiple", "dat", "res", "cache", "pad", "ns", "block", "error", "flags", "str", "bin", "last", "empty", "ata", "results", "rc", "date", "da", "len", "input", "value", "no", "DATA", "attr", "mode", "important", "align", "table", "mid", "pos", "start", "extra", "def", "pieces", "mu", "content", "w", "video", "raw", "area"], "data_size": ["data_length", "buf_SIZE", "data_offset", "buf_offset", "buf_size", "data_SIZE", "buf_length"], "avpkt": ["avpadt", "avepqt", "avpodvt", "avwpconn", "avopvt", "avpodnt", "avwkg", "avpaction", "avnpnt", "avpvt", "avwpqt", "uvpvt", "avpaconn", "avpadtt", "avcompcmd", "avewpwp", "avpwp", "avpodkt", "avcompkt", "avpdat", "uvppkt", "avewpqt", "avpdt", "avwpvt", "avepdt", "avpkg", "campakt", "avcpnt", "avpacket", "avptt", "avwqt", "avwct", "avewpkg", "avcpdat", "campvt", "avopconn", "avwpkg", "uvppcmd", "avwpct", "wavcpdat", "avwpction", "avcompvt", "avppvt", "avPkg", "campconn", "campkt", "avpconn", "wavpkt", "avpnt", "avpakt", "avwpacket", "avppcmd", "avpadvt", "avpoddat", "avepkg", "avewpkt", "uvpptt", "campaconn", "avpawp", "wavpvt", "avewpdt", "avpartction", "avwpkt", "avnpvt", "campacket", "avppkt", "avopacket", "avPct", "avpadkt", "avpction", "uvppvt", "avpct", "avpaacket", "avewpct", "avopkt", "avcpvt", "wavpdat", "avwkt", "avPqt", "avcomptt", "wavpnt", "avpqt", "avepwp", "avpptt", "wavcpnt", "uvpkt", "uvptt", "avepct", "avpartwp", "avwpdt", "campavt", "avpartdt", "avcpkt", "avpadcmd", "avewpction", "avpavt", "avnpkt", "wavcpvt", "avepkt", "avpcmd", "avepction", "uvpcmd", "avpartkt", "avPkt", "wavcpkt", "avwpwp", "avnpdat", "campaacket"], "buf": ["br", "batch", "ff", "tmp", "shift", "addr", "bc", "next", "img", "ref", "window", "box", "iter", "cb", "rb", "dat", "b", "pos", "msg", "seq", "vec", "cap", "block", "buffer", "cv", "err", "ptr", "ctx", "bg", "len", "Buffer", "offset", "queue", "rc", "bn", "raw", "mem", "uf", "cmd", "buff"], "buf_end": ["buf_stop", "buffer_ends", "buf_ends", "buf_start", "buffer_start", "buffer_end", "buffer_stop"], "bfi": ["erbdi", "erbqi", "sbfd", "erbfi", "bci", "nbdi", "bvi", "lpi", "mbili", "wbilia", "bmi", "ffd", "bbqi", "erbfif", "gpi", "boundisi", "brfi", "ubqi", "ubfi", "ablu", " bci", "wbfi", "lfo", " bfif", " bqi", "abvi", "sbfo", " bini", "hubxf", "hubfi", "lci", "ubfo", "bbvi", "sbqi", "bcgi", "mfi", "bbbi", " bcgi", " bilia", "mbci", "abli", "mfo", " bfo", "abci", "mbilia", "bqi", "bbci", "wbili", " bili", "bfd", "bbfi", "dbfi", "ffo", "bbfo", " bmi", "nbfi", "bbini", " blu", "wbpi", "abfo", "bbli", "lvi", "boundini", "bilia", "dbini", "erbilia", "nbfo", "bxf", "llu", " bvi", "hubcgi", "mini", "abfi", "sbfi", "mdi", "bisi", "bbdi", "hubdi", "ffi", "fili", "brili", "bili", "hubili", " bbi", "bbi", "bfo", " bdi", "fci", "gci", "bini", "abbi", "boundfi", "gfi", " bfd", "bdi", "bbpi", "brxf", "lfi", "dbisi", " bli", "nbini", "bbmi", "bbili", "erbcgi", "brdi", "blu", "bpi", " bpi", "gfo", "hubqi", "dbili", "boundili", "bfif", "filia", "abmi", "fqi", "ubini", "bli", "mbfi", "erbili", "bbxf", "bbilia", " bisi", "bbfif"], "dst": [" ddest", "bbl", "Ddest", "ddest", "Dest", " dnt", "drabl", "drasc", "ddsrc", "ddnt", "vbl", " dset", "vend", "dend", "dset", "isdsc", "dnt", "isdest", "gST", " dsrc", "isdst", "dST", "ddst", " dest", "Dnt", "dbl", "Dset", "vsrc", "gdest", "DST", "dsrc", "Dst", "dest", "vst", "drast", "Dsc", "Dsrc", "bsrc", "bst", "Dend", "gset", "Dbl", "dsc", "gst", "isdbl", "bend", "draest", " dST"], "src": ["sys", "usr", "tmp", "rg", "addr", "source", "img", "seek", "cb", "seq", "iv", "sub", "trans", "ptr", "comp", "bg", "origin", "rl", "dest", "str", "bin", "loc", "scale", "rc", "sq", "lang", "seed", "rel", "sn"], "dst_offset": ["dsrc_slot", "dsrc_alt", "dsrc_offset", "dst_alt", "dsrc_pos", "dst_slot", "dst_pos"], "colour1": ["color1", "colourOne", "colorOne", "greyOne", "grey1", " colourOne", "color2", "grey2"], "colour2": [" colours02", "type2", " colour02", " colour62", "type62", " colours2", "type02", "colour02", "colour62", " colours62"], "frame_end": ["data_length", "data_END", "window_max", "frame_start", "data_start", "frame_length", "frame2end", "data_end", "window_end", "frame_max", "window_start", "frame2length", "frame2start", "frame2END", "frame_END"], "pal": ["phal", "stack", "ul", "batch", "face", "stal", "pro", "ph", "quant", "mon", "shift", "mask", "qq", "style", "p", "phil", "cal", "all", "attr", "pillar", "fac", "ass", "wh", "pp", "out", "Pal", "sum", "pixel", "pack", "pac", "pos", "pen", "flat", "qt", "cache", "prof", "att", "pat", "local", "font", "mel", "sam", "pattern", "color", "pard", "pl", "shr", "pool", "isal", "sal", "bin", "what", "val", "pill", "mat", "padding", "alpha", "png", "pid", "al", "mem", "base", "buff"], "i": ["multi", "ii", "ki", "er", "is", "p", "g", "init", "xi", "ic", "pi", "index", "me", "qi", "li", "ci", "ami", "m", "ei", "b", "x", "us", "ui", "info", "gi", "it", "at", "ij", "ex", "eu", "ip", " ii", "y", "bi", "im", "e", "ie", "iu", "ti", "hi", "ind", "ix", "ia", "v", "zi", "in", "mi", "di", "ini", "by", "\u0438", "ai", "si", "f", "I", "ri"], "j": ["jump", "br", "q", "key", "l", "ii", "jp", "ji", "c", "bj", "dj", "jit", "z", "p", "aj", "uj", "g", "n", "kh", "ju", "index", "kj", "out", "jas", "b", "other", "bot", "it", "ge", "J", "ij", "jl", "js", "note", "bs", "y", "k", "jo", "bi", "ie", "je", "jc", "oj", "ion", "str", "and", "bo", "ja", "mn", "v", "o", "obj", "jj", "json"], "height": ["input", "ty", "zh", "bottom", "size", "Height", "high", "host", "count", "shift", "room", "gravity", "p", "kh", "row", "resolution", "cy", "window", "read", "wh", "table", "memory", "html", "tx", "volume", "hei", "history", "scope", "t", "y", "ch", "k", "buffer", "w", "headers", "offset", "depth", "padding", "h", "hash", "alpha", "hang", "f", "dim", "png", "th", "density", "capacity"]}}
{"project": "qemu", "commit_id": "7b0309490cb108d881a0c66d6b350b4db7b3b4ac", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 491, "substitutes": {"opts": ["opss", "OPths", "itmos", "operss", " opths", "OPops", "itcs", "expers", "experTS", " ops", "optcs", "opers", "opmos", "iopts", "opcs", "opTS", "OPTS", "iopTS", "OPss", "itts", "optpx", "operts", "expercs", "opops", "iopops", " opss", "iops", "optmos", "experops", "experts", "oppx", "expermos", "operths", "OPs", "OPts", "itpx", "experpx", "opths", "optts", "ops"], "oc": ["ec", "cp", "oid", "alloc", "op", "c", "bc", "nc", "unc", "soc", "org", "ic", "ico", "og", "mc", "oco", "ox", "OC", "ku", "ok", "it", "cur", "oca", "voc", "roc", "toc", "osc", "arc", "oci", "cs", "canon", "erc", "ob", "co", "coll", "anc", "loc", "od", "orp", "cc", "mot", "o", "oe", "ocr", "ost", "rc", "ot", "os", "ac", "obj", "ctor", "ocate"], "dc": ["doc", "ec", "vc", "d", "cp", "ctr", "design", "cat", "fc", "cd", "cr", "dt", "c", "dj", "pc", "bc", "DC", "nc", "bd", "dd", "iac", "cfg", "dat", "cmp", "dm", "ctl", "kw", "cf", "desc", "disk", "tc", "cam", "df", "cs", "ctx", "adr", "co", "gc", "db", "mn", "dr", "cc", "disc", "di", "dp", "cmd", "cm", "rc", "lc", "ac", "da", "mc", "ctrl", "cca"], "driver": ["reader", "oid", "NAME", "interface", " drivers", "drivers", "step", "handle", "port", "route", "iter", "proxy", "Driver", "loader", "username", "hop", "ind", "manager", "wrapper", "handler", "drive", "test", "key", " Driver", "operator", "source", "session", "dir", "force", "tab", "cmp", "search", "foo", "stream", "remote", "river", "driving", "direct", "ctor", "json", "graph", "device", "host", "addr", "DR", "dd", "description", "definition", "engine", "type", "roy", "connection", "call", "error", "db", "target", "draw", "_", "cmd", "roller", "label", "debug", "kind", "url", "sql", "def", "plugin", "filename", "browser", "writer", "desc", "der", "finder", "alias", "adr", "dr", "bridge", "field", "control", "direction"], "path": ["input", "template", "data", "mount", "test", "key", "device", "prop", "host", "port", "p", "Path", "route", "dir", "ath", "index", "box", "query", "pointer", "kind", "url", "where", "link", "patch", "full", "form", "it", "local", "desc", "hook", "context", "arc", "pattern", "method", "alias", "spec", "str", "pkg", "pt", "loc", "io", "partial", "depth", "PATH", "root", "raw", "th", "prefix", "point", "length", "chain"], "id": ["oid", "status", "addr", "is", "port", "rid", "init", "ref", "Id", "kind", "ids", "i", "serial", "time", "tag", "ip", "alias", "uid", "ind", "rev", "ident", "root", "ID", "os", "pid", "kid"], "dev": ["doc", "sys", "aux", "test", "device", "buf", "conn", "ev", "ds", "res", "tx", "info", "def", "iv", "cam", "w", "wd", "spec", "de", "DEV", "val", "nt", "di", "os", "des", "Dev", "obj"], "bus": ["sys", "mount", "cat", "test", "buf", "host", "handle", "bc", "port", "back", "Bus", "way", "bool", "box", "util", "bug", "boss", "proxy", "cb", "lib", "used", "b", "serial", "us", "lock", "cache", "bolt", "bar", "ack", "boot", "hand", "board", "bs", "hub", "browser", "http", "local", "block", "binding", "stick", "BUS", "kit", "callback", "bal", "home", "db", "body", "bridge", "bid", "pass", "nt", "loop", "di", "handler", "os", "ac", "state", "socket", "base", "chain"], "err": ["proc", "sys", "mr", "usr", "cr", "arr", "buf", "er", "init", "ev", "attr", "txt", "r", "iter", "cfg", "exc", "cb", "msg", "cur", "conf", "error", "errors", "der", "rr", "obj", "cmd"], "typename": ["sypename", "typerAME", "sylename", "sypenAME", "tylenamer", "tylenAME", "sypenamer", "typenAME", "typnename", "typerame", "typnamer", "typerename", "tylename", "sypenamed", "tyrename", "typenename", "tyrenAME", "tyrenamer", "typenamed", "typenamer", "sylenamed", "sylenAME", "tylenamed", "tyrenamed", "tylenename", "sylenamer", "typname", "typeramed", "sylenename", "sypenename", "typnAME", "tyrenename"]}}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "void thread_pool_submit(ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(func, arg, NULL, NULL);\n\n}\n", "idx": 501, "substitutes": {"func": ["proc", "doc", "fx", "aux", "fc", "unc", "fun", "fac", "util", "cb", "coord", "act", "b", "orig", "grid", "def", "job", "cell", "kw", "cf", "apply", "lambda", "cast", "df", "cs", "comp", "con", "function", "pkg", "closure", "cc", "good", "fee", "f", "fn", "lc", "cmd"], "arg": ["doc", "arr", "mb", "item", "org", "g", "window", "ref", "og", "Arg", "ng", "ax", "inc", "num", "msg", "new", "win", "ack", " argument", "ig", " Arg", "oc", "param", "ctx", "ag", "reg", "ar", "argument", "mm", "val", " targ", "vol", "urg", "arp", "ret", "event", "ad", " larg", "args", "gov", "par", "mem"]}}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n", "idx": 510, "substitutes": {}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539, "substitutes": {"cpu": ["core", "ka", "cp", "c", "p", "pu", "hw", "gpu", "node", "localhost", "nan", "ctl", "vm", "cf", "cum", "context", "cam", "comp", "nic", "pkg", "bo", "que", "hz", "console", "uu", "ck", "mem", "net", "np", "act", "none", "linux", "cmp", "tp", "gnu", "cell", "ilo", "setup", "aco", "ruby", "gc", "co", "remote", "frame", "thread", "java", "device", "jp", "phys", "nc", "CPU", "processor", "pty", "cache", "ctx", "pool", "ob", "go", "mac", "clock", "process", "current", "cmd", "proc", "sys", "alloc", "pc", "cn", "stat", "conn", "util", "cli", "prof", "boot", "mu", "ch", "cv", "copy", "rpm", "null", "cu", "nz", "o", "lc", "obj"], "cc": ["proc", "ec", "acc", "vc", "cp", "fc", "bec", "func", "pc", "CC", "c", "nc", "xc", "bc", "unc", "cy", "uc", "cz", "ci", "pp", "cb", "cmp", "cci", "cell", "ctl", "cf", "cv", "cast", "tc", "cs", "ctx", "comp", "gc", "anc", "co", "cu", "ct", "icc", "cl", "rc", "ck", "lc", "mc", "cmd", "cca"], "ret": ["RET", "try", "status", "match", "git", "no", "count", "Return", "nl", "conn", " RET", "soft", "conv", "result", "ref", "r", "out", "res", "ft", "num", "ne", "gt", "Ret", " Ret", "fi", "got", "rt", "re", "alt", "reg", "print", "val", "nt", "nz", "f", "rem", "reset", "tr", "resp", "flag", "elt", "t", "len", "std", "sp"], "sc": ["ec", "sys", "isc", "fc", "pc", "c", "bc", "sv", "ss", "scl", "uc", "mp", "asc", " ss", "esc", "sch", " sd", "cmp", "syn", "Sc", "scope", "sw", "osc", "oc", "ch", "sd", "cv", "tc", "arc", "cs", "ctx", "gc", "SC", "rs", "cl", "rc", "sb", "sq", "ac", "lc", "mc", "sync", "ssl", "sp"], "last_tb": ["last_tsl", "last_Tl", "last_tj", "last_tracej", "last_wtbr", "last_otfb", "last_ttj", "last_wtb", "last_tl", "last_tba", "last_otba", "last_Tbi", "last_ttb", "last_tsbr", "last_tsbe", "last_traceb", "last_otb", "last_trrb", "last_tfb", "last_wtl", "last_tsbi", "last_trb", "last_ttfb", "last_tracefb", "last_tsbl", "last_traceba", "last_Tbr", "last_tsb", "last_tbr", "last_Trb", "last_Tbl", "last_otj", "last_wtbi", "last_tbi", "last_tbe", "last_ttba", "last_trbr", "last_Tb", "last_Tbe", "last_tbl"], "tb": ["testbc", "ptb", "xbt", "ptbt", "tbl", "ltb", "xb", "ltbl", "tempbc", "tempbre", "testmb", "ltbt", "testb", "tbre", "tbt", "ptbl", "tempmb", "tbc", "xv", "ltv", "tv", "tempb", "tmb", " tbc", " tmb", " tbre", "ptv", "testbre", "xbl"]}}
{"project": "qemu", "commit_id": "b7b6348ab433519f16c1500e3ea04805428be91e", "target": 0, "func": "static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)\n\n{\n\n    int i;\n\n    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;\n\n    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;\n\n\n\n    copy_scsw_to_guest(&dest->scsw, &src->scsw);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {\n\n        dest->esw[i] = cpu_to_be32(src->esw[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {\n\n        dest->ecw[i] = cpu_to_be32(src->ecw[i]);\n\n    }\n\n    /* extended measurements enabled? */\n\n    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n\n        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||\n\n        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {\n\n        return;\n\n    }\n\n    /* extended measurements pending? */\n\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n\n        return;\n\n    }\n\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n\n        (stctl == SCSW_STCTL_SECONDARY) ||\n\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n\n        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {\n\n            dest->emw[i] = cpu_to_be32(src->emw[i]);\n\n        }\n\n    }\n\n}\n", "idx": 547, "substitutes": {"dest": ["bound", "usr", "env", "tmp", "port", "order", "iter", "out", "see", "sum", "gest", "req", "foreign", "opt", "spec", "nom", "wrapper", "est", "prototype", "message", "test", "comb", "source", "sort", "result", "dist", "export", "shape", "end", "trans", "ptr", "translation", "member", "loc", "remote", "display", "tr", "rel", "chain", "total", "document", "Dest", "rest", "to", "decl", "phi", "priv", "dev", "comment", "wb", "v", "consider", "target", "results", "master", "success", "created", "temp", "prop", "way", "rw", "cont", "orig", "them", "transform", "local", "desc", "w", "complete", "copy", "pl", "origin", "now", "global", "good", "peer", "st", "store"], "src": ["usr", "ctr", "tmp", "init", "sup", "nil", "other", "sc", "req", "sur", "sr", "http", "comp", "ipp", "ind", "sb", "inner", "source", "sort", "usc", "dist", "inc", "ack", "cmp", "iv", "sub", "sing", "setup", "ripp", "loc", "ost", "sel", "sq", "rel", "secure", "sync", "sn", "inst", "stri", "rest", "from", "sl", "stock", "SOURCE", "etc", "cur", "syn", "sw", "ctx", "bin", "btn", "rc", "obl", "pri", "sys", "input", "sh", "sec", "lib", "unknown", "pack", "start", "filename", "ser", "desc", "via", "origin", "now", "rt", "rs", "in", "stab", "super", "st", "supp"], "pmcw": ["pmcwa", "pmccnw", "pmscwa", "pmrcw", "pmmcw", "mpcW", "pxcinwx", "pmcsw", "mpcws", "pmacsw", "PMdcw", "pmrcwd", "pmrcwx", "pmccws", "pxcw", "mpccnw", "pmccw", "pmcinwd", "pmrcwa", "pmcwd", "pmpcws", "pmcinwx", "pmcws", "pxcinwa", "pxcinwd", "pmarcW", "pmdcwa", "pmarcws", "pmmcnw", "pmmcwa", "pmmcsw", "PMcnw", "pmscwx", "pxcwd", "PMdcsw", "mpccws", "pmcinw", "pmcinwa", "pmscw", "pmcnw", "pmdcw", "pmdcsw", "pmpcw", "PMcw", "PMcwa", "mpccW", "pmarcnw", "pmpcW", "PMdcnw", "pmarcw", "pmccW", "pxcinw", "pmacnw", "pxcwx", "PMdcwa", "pxcwa", "pmcwx", "PMcsw", "mpccw", "pmpcnw", "pmscwd", "pmacw", "pmacwa", "pmcW", "mpcnw", "pmdcnw", "mpcw"], "i": ["id", "parent", "try", "port", "init", "li", "spin", "page", "x", "us", " ti", "iu", "ti", "span", "ind", "uri", "ix", "zi", "ini", "I", "f", " bi", "batch", "q", "list", "xi", "ic", "qi", "sequence", "m", "u", "ui", "it", "ex", "ims", "im", "um", "name", " li", "io", "remote", "PI", "\u0438", "ri", "json", "chain", "php", " m", "ii", "iri", " mi", "ji", "to", "pi", "ci", "ei", "phi", "eu", "fi", " ii", "y", " pi", "bi", "mac", "client", " ni", "mi", "di", "ai", "si", "point", "multi", "ki", "is", "sim", "ami", "cli", "gi", " si", "ip", "oi", " iter", "print", "in", " multi", "t"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int i;\n\n    int got_output;\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int ret = 0;\n\n    handle_eof:\n\n\n\n        ist->last_dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration)\n\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            else if (ist->st->avg_frame_rate.num)\n\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n\n                                              AV_TIME_BASE_Q);\n\n            else if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 566, "substitutes": {"ist": ["usr", "wn", "drm", "hw", "ont", "ief", "hist", "its", "xt", "exist", "ush", "xp", "elist", "ous", "ir", "ind", "alist", "pas", "iop", "ists", "est", "ik", "ire", "art", "pect", "asm", "ht", "ld", "istant", "ift", "isd", "ister", "htt", "ast", "tip", "ic", "ess", "dist", "act", "assert", "lect", "irc", "ect", "each", "sts", "artist", "expr", "inst", "wp", "rest", "IST", "eh", "ust", "pir", "isting", "ict", "iste", "att", "ait", "hl", "ista", " est", "pt", "irst", "erd", "istar", "spect", "lp", "et", "il", "is", "ism", "ith", "irs", "ird", "dit", "ert", "irm", "edit", "iz", "ort", "ilst", "ick", "isi", "st", "iat", "wikipedia", "typ"], "pkt": ["expacket", "pcht", "pant", "opelt", "Packet", "Pkg", "expkg", "payet", "apelt", " pmsg", "prokg", "opacket", "apkt", "phpacket", " pet", "paykt", " pct", "pft", " pcmd", "paelt", "pcmd", "opet", " pck", "proacket", "pelt", "apct", "payacket", "dkt", "opcmd", "apnt", "ppelt", "dacket", "tpkt", " pft", "opcht", "Pkt", "ppkt", "pakt", "apkg", "tpmsg", "paft", "expkt", "packet", " pkg", "tpkg", "apft", "apacket", "pct", "pmsg", "phpkg", " pelt", "Pct", "pkg", "ppacket", "promsg", " packet", "pnt", "pck", "prokt", "dck", "pet", "payelt", "expct", "ppet", " pnt", " pcht", "det", "phpkt", "opkg", "ppck", "ppcht", "opkt", "phpcmd", "tpacket"], "i": ["j", "id", "l", "ii", " m", " j", "p", "g", "n", "r", "m", "b", "x", "info", "it", "fi", "ip", "ir", "v", "mi", "di", "ret", "I", "si", "iat", "t", "mem"], "got_output": ["got___success", "got_dot", "got_exit", "get_log", "gotptclient", "got___wrong", "fitted_output", "fitted_client", "gotableoutput", "got_wrong", "gotablelog", "got_offset", "gotableexit", "got_success", "gotptresult", "gotableresult", "got_result", "get_dot", "gotptexit", "gotten_output", "gotureOutput", "gotten_success", "got_log", "gotptoutput", "gotureoutput", "gotten_offset", "get_Output", "get_output", "fitted_result", "got___offset", "got_current", "gotten_wrong", "gotableclient", "got_client", "fitted_exit", "get_current", "got_Output", "gotabledot", "goturecurrent", "got___output"], "avpkt": ["avpreket", "avpodcht", "campaykt", "avprett", "avPnt", "avpka", "ajpqt", "averpaet", "averpakg", "avtaddr", "avnpact", "avfkt", "averpkt", "averpkat", "avlpmt", "avpayet", "avpvt", "avevcht", "avpostaddr", "avcpkg", "avpvc", "avpaddr", "avppacket", "avpwk", "avppconn", "avpvec", "afpkt", "avwpdu", "wavipvt", "averpacmd", "avpdu", "avpodkt", "ajpostkg", "ajpostqt", "avepket", "avpartacket", "avopdr", "avbpkt", "avpayvec", "avlpkt", "avtpacket", "avpkg", "avprpty", "avpscht", "avpycmd", "campvec", "avpostqt", "wavipacket", "avnpwk", "avppmk", "avpostkt", "avpcet", "avpacket", "avpadvc", "campkg", "averpavc", "avvpwk", "avpskg", "avpreka", "avpdr", "avepgt", "avevwk", "avdpett", "avvact", "avtkg", "avPett", " avppty", "averpkg", "aveppkt", "avvcht", "avprkt", "avpostkg", "avpaet", "campet", "avphpvec", "avPpty", "avpcvc", "averpavt", "averfkt", "averpet", "avepreacket", "avvpkg", "avwpkg", "ajpostaddr", "avnpcht", "avepmt", "avtpdu", "avpodact", "avphpkt", "aveppwk", "avdkt", "avepcht", "avenpwk", "ajpaddr", "avbpmk", "avppvt", "avpelt", "avcpet", " avPett", "avpydr", "avjpqt", "avfkat", "avpavc", "avspkt", "avpaykg", "avfkg", "afpdu", "averpakt", "avwpcht", "avevkt", "avipvt", "averpadr", "avbpacket", "campkt", "averfkat", "avepreka", "avpkat", "avtqt", "avpacmd", "avpet", "avpett", "avepacket", "avpconn", "wavpkt", "avpnt", " avpnt", "avpakt", "avpartket", "afwpdu", "avwpacket", "aveprekt", "avpact", "avvpmt", " avPkt", "avlpkg", "avpckt", "avpadvt", "avfcht", "avpskat", "avcpacket", "avdpkt", "avdgt", "avpartka", "avpadr", "avepkg", "avphpkg", "campaykg", "avlpwk", "avnpmt", "avspka", "wavpvt", "avpodwk", "avdconn", "avpcvt", "averpvt", "avpreacket", "afpacket", "avwpkt", "avpmt", "avjpkg", "averfkg", "avppkt", "avcpdu", "campayvec", "avipmk", "avspket", "avpadkt", "avepka", "afwpacket", "wavipkt", "afwpkt", "avprekt", "avpadet", "avpskt", "avenpkt", "avtpelt", "afwpelt", "avpmk", "ajpkt", "averpcmd", "avepact", "aveppconn", "avphpet", "wavpmk", "avopkt", "avlpconn", "avwpkat", "avtkt", "avpakg", " avPpty", "ajpostkt", "avjpaddr", "afpelt", "avvpkt", "avpket", "avpgt", "avcpvec", "wavpacket", "avpqt", " avpett", "avppty", "aveppgt", "campayet", "avcpelt", "avjpkt", "avepconn", "avtpkt", "avenpmt", "avwpelt", "avppwk", "averpdr", " avPnt", "avipkt", "avcpkt", "avpaykt", "ajpkg", "avspacket", "wavipmk", "avprnt", "avopcmd", "avepreket", "avlpgt", "averpvc", "avpavt", "avppgt", "avnpkt", "avepwk", "averfcht", "avvwk", "avvkt", "avenpkg", "averpcht", "avdppty", "avpcmd", "avepkt", "avdwk", "avevact", "avopkg", "avnpkg", "avpcht", "avpartkt", "avdpnt", "avPkt", "avipacket", "avbpvt", "avpykg", "avpykt"]}}
{"project": "qemu", "commit_id": "c5a49c63fa26e8825ad101dfe86339ae4c216539", "target": 1, "func": "static target_ulong disas_insn(DisasContext *s, CPUState *cpu)\n\n{\n\n    CPUX86State *env = cpu->env_ptr;\n\n    int b, prefixes;\n\n    int shift;\n\n    TCGMemOp ot, aflag, dflag;\n\n    int modrm, reg, rm, mod, op, opreg, val;\n\n    target_ulong next_eip, tval;\n\n    int rex_w, rex_r;\n\n    target_ulong pc_start = s->base.pc_next;\n\n\n\n    s->pc_start = s->pc = pc_start;\n\n    prefixes = 0;\n\n    s->override = -1;\n\n    rex_w = -1;\n\n    rex_r = 0;\n\n#ifdef TARGET_X86_64\n\n    s->rex_x = 0;\n\n    s->rex_b = 0;\n\n    x86_64_hregs = 0;\n\n#endif\n\n    s->rip_offset = 0; /* for relative ip address */\n\n    s->vex_l = 0;\n\n    s->vex_v = 0;\n\n    if (sigsetjmp(s->jmpbuf, 0) != 0) {\n\n        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        return s->pc;\n\n    }\n\n\n\n next_byte:\n\n    b = x86_ldub_code(env, s);\n\n    /* Collect prefixes.  */\n\n    switch (b) {\n\n    case 0xf3:\n\n        prefixes |= PREFIX_REPZ;\n\n        goto next_byte;\n\n    case 0xf2:\n\n        prefixes |= PREFIX_REPNZ;\n\n        goto next_byte;\n\n    case 0xf0:\n\n        prefixes |= PREFIX_LOCK;\n\n        goto next_byte;\n\n    case 0x2e:\n\n        s->override = R_CS;\n\n        goto next_byte;\n\n    case 0x36:\n\n        s->override = R_SS;\n\n        goto next_byte;\n\n    case 0x3e:\n\n        s->override = R_DS;\n\n        goto next_byte;\n\n    case 0x26:\n\n        s->override = R_ES;\n\n        goto next_byte;\n\n    case 0x64:\n\n        s->override = R_FS;\n\n        goto next_byte;\n\n    case 0x65:\n\n        s->override = R_GS;\n\n        goto next_byte;\n\n    case 0x66:\n\n        prefixes |= PREFIX_DATA;\n\n        goto next_byte;\n\n    case 0x67:\n\n        prefixes |= PREFIX_ADR;\n\n        goto next_byte;\n\n#ifdef TARGET_X86_64\n\n    case 0x40 ... 0x4f:\n\n        if (CODE64(s)) {\n\n            /* REX prefix */\n\n            rex_w = (b >> 3) & 1;\n\n            rex_r = (b & 0x4) << 1;\n\n            s->rex_x = (b & 0x2) << 2;\n\n            REX_B(s) = (b & 0x1) << 3;\n\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n\n            goto next_byte;\n\n        }\n\n        break;\n\n#endif\n\n    case 0xc5: /* 2-byte VEX */\n\n    case 0xc4: /* 3-byte VEX */\n\n        /* VEX prefixes cannot be used except in 32-bit mode.\n\n           Otherwise the instruction is LES or LDS.  */\n\n        if (s->code32 && !s->vm86) {\n\n            static const int pp_prefix[4] = {\n\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n\n            };\n\n            int vex3, vex2 = x86_ldub_code(env, s);\n\n\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n\n                   otherwise the instruction is LES or LDS.  */\n\n                break;\n\n            }\n\n            s->pc++;\n\n\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n\n                goto illegal_op;\n\n            }\n\n#ifdef TARGET_X86_64\n\n            if (x86_64_hregs) {\n\n                goto illegal_op;\n\n            }\n\n#endif\n\n            rex_r = (~vex2 >> 4) & 8;\n\n            if (b == 0xc5) {\n\n                vex3 = vex2;\n\n                b = x86_ldub_code(env, s);\n\n            } else {\n\n#ifdef TARGET_X86_64\n\n                s->rex_x = (~vex2 >> 3) & 8;\n\n                s->rex_b = (~vex2 >> 2) & 8;\n\n#endif\n\n                vex3 = x86_ldub_code(env, s);\n\n                rex_w = (vex3 >> 7) & 1;\n\n                switch (vex2 & 0x1f) {\n\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n\n                    b = x86_ldub_code(env, s) | 0x100;\n\n                    break;\n\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n\n                    b = 0x138;\n\n                    break;\n\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n\n                    b = 0x13a;\n\n                    break;\n\n                default:   /* Reserved for future use.  */\n\n                    goto unknown_op;\n\n                }\n\n            }\n\n            s->vex_v = (~vex3 >> 3) & 0xf;\n\n            s->vex_l = (vex3 >> 2) & 1;\n\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n\n        }\n\n        break;\n\n    }\n\n\n\n    /* Post-process prefixes.  */\n\n    if (CODE64(s)) {\n\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n\n           over 0x66 if both are present.  */\n\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n\n    } else {\n\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n\n            dflag = MO_32;\n\n        } else {\n\n            dflag = MO_16;\n\n        }\n\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n\n            aflag = MO_32;\n\n        }  else {\n\n            aflag = MO_16;\n\n        }\n\n    }\n\n\n\n    s->prefix = prefixes;\n\n    s->aflag = aflag;\n\n    s->dflag = dflag;\n\n\n\n    /* now check op code */\n\n reswitch:\n\n    switch(b) {\n\n    case 0x0f:\n\n        /**************************/\n\n        /* extended op code */\n\n        b = x86_ldub_code(env, s) | 0x100;\n\n        goto reswitch;\n\n\n\n        /**************************/\n\n        /* arith & logic */\n\n    case 0x00 ... 0x05:\n\n    case 0x08 ... 0x0d:\n\n    case 0x10 ... 0x15:\n\n    case 0x18 ... 0x1d:\n\n    case 0x20 ... 0x25:\n\n    case 0x28 ... 0x2d:\n\n    case 0x30 ... 0x35:\n\n    case 0x38 ... 0x3d:\n\n        {\n\n            int op, f, val;\n\n            op = (b >> 3) & 7;\n\n            f = (b >> 1) & 3;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            switch(f) {\n\n            case 0: /* OP Ev, Gv */\n\n                modrm = x86_ldub_code(env, s);\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                mod = (modrm >> 6) & 3;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    opreg = OR_TMP0;\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                xor_zero:\n\n                    /* xor reg, reg optimisation */\n\n                    set_cc_op(s, CC_OP_CLR);\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n                    break;\n\n                } else {\n\n                    opreg = rm;\n\n                }\n\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n                gen_op(s, op, ot, opreg);\n\n                break;\n\n            case 1: /* OP Gv, Ev */\n\n                modrm = x86_ldub_code(env, s);\n\n                mod = (modrm >> 6) & 3;\n\n                reg = ((modrm >> 3) & 7) | rex_r;\n\n                rm = (modrm & 7) | REX_B(s);\n\n                if (mod != 3) {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                } else if (op == OP_XORL && rm == reg) {\n\n                    goto xor_zero;\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n                }\n\n                gen_op(s, op, ot, reg);\n\n                break;\n\n            case 2: /* OP A, Iv */\n\n                val = insn_get(env, s, ot);\n\n                tcg_gen_movi_tl(cpu_T1, val);\n\n                gen_op(s, op, ot, OR_EAX);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x82:\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n    case 0x80: /* GRP1 */\n\n    case 0x81:\n\n    case 0x83:\n\n        {\n\n            int val;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (b == 0x83)\n\n                    s->rip_offset = 1;\n\n                else\n\n                    s->rip_offset = insn_const_size(ot);\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = rm;\n\n            }\n\n\n\n            switch(b) {\n\n            default:\n\n            case 0x80:\n\n            case 0x81:\n\n            case 0x82:\n\n                val = insn_get(env, s, ot);\n\n                break;\n\n            case 0x83:\n\n                val = (int8_t)insn_get(env, s, MO_8);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op(s, op, ot, opreg);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* inc, dec, and other misc arith */\n\n    case 0x40 ... 0x47: /* inc Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n\n        break;\n\n    case 0x48 ... 0x4f: /* dec Gv */\n\n        ot = dflag;\n\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n\n        break;\n\n    case 0xf6: /* GRP3 */\n\n    case 0xf7:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (mod != 3) {\n\n            if (op == 0) {\n\n                s->rip_offset = insn_const_size(ot);\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            /* For those below that handle locked memory, don't load here.  */\n\n            if (!(s->prefix & PREFIX_LOCK)\n\n                || op != 2) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* test */\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n            gen_op_testl_T0_T1_cc();\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            break;\n\n        case 2: /* not */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_movi_tl(cpu_T0, ~0);\n\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n            } else {\n\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            break;\n\n        case 3: /* neg */\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                TCGLabel *label1;\n\n                TCGv a0, t0, t1, t2;\n\n\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                a0 = tcg_temp_local_new();\n\n                t0 = tcg_temp_local_new();\n\n                label1 = gen_new_label();\n\n\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n\n\n                gen_set_label(label1);\n\n                t1 = tcg_temp_new();\n\n                t2 = tcg_temp_new();\n\n                tcg_gen_mov_tl(t2, t0);\n\n                tcg_gen_neg_tl(t1, t0);\n\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n\n                                          s->mem_index, ot | MO_LE);\n\n                tcg_temp_free(t1);\n\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n\n\n                tcg_temp_free(t2);\n\n                tcg_temp_free(a0);\n\n                tcg_gen_mov_tl(cpu_T0, t0);\n\n                tcg_temp_free(t0);\n\n            } else {\n\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n            gen_op_update_neg_cc();\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            break;\n\n        case 4: /* mul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 5: /* imul */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                set_cc_op(s, CC_OP_MULB);\n\n                break;\n\n            case MO_16:\n\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n                /* XXX: use 32 bit mul which could be faster */\n\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n                set_cc_op(s, CC_OP_MULW);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n                set_cc_op(s, CC_OP_MULL);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n\n                                  cpu_T0, cpu_regs[R_EAX]);\n\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n\n                set_cc_op(s, CC_OP_MULQ);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 6: /* div */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        case 7: /* idiv */\n\n            switch(ot) {\n\n            case MO_8:\n\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n\n                break;\n\n            case MO_16:\n\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n\n                break;\n\n            default:\n\n            case MO_32:\n\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n\n                break;\n\n#endif\n\n            }\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0xfe: /* GRP4 */\n\n    case 0xff: /* GRP5 */\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        op = (modrm >> 3) & 7;\n\n        if (op >= 2 && b == 0xfe) {\n\n            goto unknown_op;\n\n        }\n\n        if (CODE64(s)) {\n\n            if (op == 2 || op == 4) {\n\n                /* operand size for jumps is 64 bit */\n\n                ot = MO_64;\n\n            } else if (op == 3 || op == 5) {\n\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n\n            } else if (op == 6) {\n\n                /* default push size is 64 bit */\n\n                ot = mo_pushpop(s, dflag);\n\n            }\n\n        }\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (op >= 2 && op != 3 && op != 5)\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n\n\n        switch(op) {\n\n        case 0: /* inc Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, 1);\n\n            break;\n\n        case 1: /* dec Ev */\n\n            if (mod != 3)\n\n                opreg = OR_TMP0;\n\n            else\n\n                opreg = rm;\n\n            gen_inc(s, ot, opreg, -1);\n\n            break;\n\n        case 2: /* call Ev */\n\n            /* XXX: optimize if memory (no 'and' is necessary) */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n\n            gen_push_v(s, cpu_T1);\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 3: /* lcall Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_lcall:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                           tcg_const_i32(dflag - 1),\n\n                                           tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                      tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 4: /* jmp Ev */\n\n            if (dflag == MO_16) {\n\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n            }\n\n            gen_op_jmp_v(cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jr(s, cpu_T0);\n\n            break;\n\n        case 5: /* ljmp Ev */\n\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 1 << ot);\n\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        do_ljmp:\n\n            if (s->pe && !s->vm86) {\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n\n                                          tcg_const_tl(s->pc - s->cs_base));\n\n            } else {\n\n                gen_op_movl_seg_T0_vm(R_CS);\n\n                gen_op_jmp_v(cpu_T1);\n\n            }\n\n            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));\n\n            gen_jr(s, cpu_tmp4);\n\n            break;\n\n        case 6: /* push Ev */\n\n            gen_push_v(s, cpu_T0);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x84: /* test Ev, Gv */\n\n    case 0x85:\n\n        ot = mo_b_d(b, dflag);\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0xa8: /* test eAX, Iv */\n\n    case 0xa9:\n\n        ot = mo_b_d(b, dflag);\n\n        val = insn_get(env, s, ot);\n\n\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        gen_op_testl_T0_T1_cc();\n\n        set_cc_op(s, CC_OP_LOGICB + ot);\n\n        break;\n\n\n\n    case 0x98: /* CWDE/CBW */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x99: /* CDQ/CWD */\n\n        switch (dflag) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n\n            break;\n\n        case MO_16:\n\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n\n            break;\n\n        default:\n\n            tcg_abort();\n\n        }\n\n        break;\n\n    case 0x1af: /* imul Gv, Ev */\n\n    case 0x69: /* imul Gv, Ev, I */\n\n    case 0x6b:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (b == 0x69)\n\n            s->rip_offset = insn_const_size(ot);\n\n        else if (b == 0x6b)\n\n            s->rip_offset = 1;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        if (b == 0x69) {\n\n            val = insn_get(env, s, ot);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else if (b == 0x6b) {\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n            tcg_gen_movi_tl(cpu_T1, val);\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        }\n\n        switch (ot) {\n\n#ifdef TARGET_X86_64\n\n        case MO_64:\n\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n\n            break;\n\n#endif\n\n        case MO_32:\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n\n            break;\n\n        default:\n\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n\n            /* XXX: use 32 bit mul which could be faster */\n\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n            break;\n\n        }\n\n        set_cc_op(s, CC_OP_MULB + ot);\n\n        break;\n\n    case 0x1c0:\n\n    case 0x1c1: /* xadd Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n            } else {\n\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        gen_op_update2_cc();\n\n        set_cc_op(s, CC_OP_ADDB + ot);\n\n        break;\n\n    case 0x1b0:\n\n    case 0x1b1: /* cmpxchg Ev, Gv */\n\n        {\n\n            TCGv oldv, newv, cmpv;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            oldv = tcg_temp_new();\n\n            newv = tcg_temp_new();\n\n            cmpv = tcg_temp_new();\n\n            gen_op_mov_v_reg(ot, newv, reg);\n\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n\n\n            if (s->prefix & PREFIX_LOCK) {\n\n                if (mod == 3) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n\n                                          s->mem_index, ot | MO_LE);\n\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n            } else {\n\n                if (mod == 3) {\n\n                    rm = (modrm & 7) | REX_B(s);\n\n                    gen_op_mov_v_reg(ot, oldv, rm);\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n\n                    rm = 0; /* avoid warning */\n\n                }\n\n                gen_extu(ot, oldv);\n\n                gen_extu(ot, cmpv);\n\n                /* store value = (old == cmp ? new : old);  */\n\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n\n                if (mod == 3) {\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                    gen_op_mov_reg_v(ot, rm, newv);\n\n                } else {\n\n                    /* Perform an unconditional store cycle like physical cpu;\n\n                       must be before changing accumulator to ensure\n\n                       idempotency if the store faults and the instruction\n\n                       is restarted */\n\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n\n                }\n\n            }\n\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n\n            set_cc_op(s, CC_OP_SUBB + ot);\n\n            tcg_temp_free(oldv);\n\n            tcg_temp_free(newv);\n\n            tcg_temp_free(cmpv);\n\n        }\n\n        break;\n\n    case 0x1c7: /* cmpxchg8b */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n\n            goto illegal_op;\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        } else\n\n#endif        \n\n        {\n\n            if (!(s->cpuid_features & CPUID_CX8))\n\n                goto illegal_op;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n\n            } else {\n\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n\n            }\n\n        }\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n\n\n        /**************************/\n\n        /* push/pop */\n\n    case 0x50 ... 0x57: /* push */\n\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x58 ... 0x5f: /* pop */\n\n        ot = gen_pop_T0(s);\n\n        /* NOTE: order is important for pop %sp */\n\n        gen_pop_update(s, ot);\n\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0x60: /* pusha */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_pusha(s);\n\n        break;\n\n    case 0x61: /* popa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_popa(s);\n\n        break;\n\n    case 0x68: /* push Iv */\n\n    case 0x6a:\n\n        ot = mo_pushpop(s, dflag);\n\n        if (b == 0x68)\n\n            val = insn_get(env, s, ot);\n\n        else\n\n            val = (int8_t)insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x8f: /* pop Ev */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        ot = gen_pop_T0(s);\n\n        if (mod == 3) {\n\n            /* NOTE: order is important for pop %sp */\n\n            gen_pop_update(s, ot);\n\n            rm = (modrm & 7) | REX_B(s);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n        } else {\n\n            /* NOTE: order is important too for MMU exceptions */\n\n            s->popl_esp_hack = 1 << ot;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            s->popl_esp_hack = 0;\n\n            gen_pop_update(s, ot);\n\n        }\n\n        break;\n\n    case 0xc8: /* enter */\n\n        {\n\n            int level;\n\n            val = x86_lduw_code(env, s);\n\n            level = x86_ldub_code(env, s);\n\n            gen_enter(s, val, level);\n\n        }\n\n        break;\n\n    case 0xc9: /* leave */\n\n        gen_leave(s);\n\n        break;\n\n    case 0x06: /* push es */\n\n    case 0x0e: /* push cs */\n\n    case 0x16: /* push ss */\n\n    case 0x1e: /* push ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(b >> 3);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x1a0: /* push fs */\n\n    case 0x1a8: /* push gs */\n\n        gen_op_movl_T0_seg((b >> 3) & 7);\n\n        gen_push_v(s, cpu_T0);\n\n        break;\n\n    case 0x07: /* pop es */\n\n    case 0x17: /* pop ss */\n\n    case 0x1f: /* pop ds */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        reg = b >> 3;\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, reg);\n\n        gen_pop_update(s, ot);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x1a1: /* pop fs */\n\n    case 0x1a9: /* pop gs */\n\n        ot = gen_pop_T0(s);\n\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n\n        gen_pop_update(s, ot);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /**************************/\n\n        /* mov */\n\n    case 0x88:\n\n    case 0x89: /* mov Gv, Ev */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0xc6:\n\n    case 0xc7: /* mov Ev, Iv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod != 3) {\n\n            s->rip_offset = insn_const_size(ot);\n\n            gen_lea_modrm(env, s, modrm);\n\n        }\n\n        val = insn_get(env, s, ot);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        if (mod != 3) {\n\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n        } else {\n\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n\n        }\n\n        break;\n\n    case 0x8a:\n\n    case 0x8b: /* mov Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n    case 0x8e: /* mov seg, Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        if (reg >= 6 || reg == R_CS)\n\n            goto illegal_op;\n\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n        gen_movl_seg_T0(s, reg);\n\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            if (reg == R_SS) {\n\n                s->tf = 0;\n\n                gen_eob_inhibit_irq(s, true);\n\n            } else {\n\n                gen_eob(s);\n\n            }\n\n        }\n\n        break;\n\n    case 0x8c: /* mov Gv, seg */\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (reg >= 6)\n\n            goto illegal_op;\n\n        gen_op_movl_T0_seg(reg);\n\n        ot = mod == 3 ? dflag : MO_16;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n        break;\n\n\n\n    case 0x1b6: /* movzbS Gv, Eb */\n\n    case 0x1b7: /* movzwS Gv, Eb */\n\n    case 0x1be: /* movsbS Gv, Eb */\n\n    case 0x1bf: /* movswS Gv, Eb */\n\n        {\n\n            TCGMemOp d_ot;\n\n            TCGMemOp s_ot;\n\n\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n            /* ot is the size of source */\n\n            ot = (b & 1) + MO_8;\n\n            /* s_ot is the sign+size of source */\n\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n\n                } else {\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    switch (s_ot) {\n\n                    case MO_UB:\n\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_SB:\n\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    case MO_UW:\n\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    default:\n\n                    case MO_SW:\n\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n\n                        break;\n\n                    }\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x8d: /* lea */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            TCGv ea = gen_lea_modrm_1(a);\n\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n\n        }\n\n        break;\n\n\n\n    case 0xa0: /* mov EAX, Ov */\n\n    case 0xa1:\n\n    case 0xa2: /* mov Ov, EAX */\n\n    case 0xa3:\n\n        {\n\n            target_ulong offset_addr;\n\n\n\n            ot = mo_b_d(b, dflag);\n\n            switch (s->aflag) {\n\n#ifdef TARGET_X86_64\n\n            case MO_64:\n\n                offset_addr = x86_ldq_code(env, s);\n\n                break;\n\n#endif\n\n            default:\n\n                offset_addr = insn_get(env, s, s->aflag);\n\n                break;\n\n            }\n\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n\n            gen_add_A0_ds_seg(s);\n\n            if ((b & 2) == 0) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd7: /* xlat */\n\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n\n        gen_extu(s->aflag, cpu_A0);\n\n        gen_add_A0_ds_seg(s);\n\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n\n        val = insn_get(env, s, MO_8);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n\n        break;\n\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            uint64_t tmp;\n\n            /* 64 bit case */\n\n            tmp = x86_ldq_code(env, s);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, tmp);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            ot = dflag;\n\n            val = insn_get(env, s, ot);\n\n            reg = (b & 7) | REX_B(s);\n\n            tcg_gen_movi_tl(cpu_T0, val);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        }\n\n        break;\n\n\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n\n    do_xchg_reg_eax:\n\n        ot = dflag;\n\n        reg = (b & 7) | REX_B(s);\n\n        rm = R_EAX;\n\n        goto do_xchg_reg;\n\n    case 0x86:\n\n    case 0x87: /* xchg Ev, Gv */\n\n        ot = mo_b_d(b, dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3) {\n\n            rm = (modrm & 7) | REX_B(s);\n\n        do_xchg_reg:\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        } else {\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n            /* for xchg, lock is implicit */\n\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n\n                                   s->mem_index, ot | MO_LE);\n\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        }\n\n        break;\n\n    case 0xc4: /* les Gv */\n\n        /* In CODE64 this is VEX3; see above.  */\n\n        op = R_ES;\n\n        goto do_lxx;\n\n    case 0xc5: /* lds Gv */\n\n        /* In CODE64 this is VEX2; see above.  */\n\n        op = R_DS;\n\n        goto do_lxx;\n\n    case 0x1b2: /* lss Gv */\n\n        op = R_SS;\n\n        goto do_lxx;\n\n    case 0x1b4: /* lfs Gv */\n\n        op = R_FS;\n\n        goto do_lxx;\n\n    case 0x1b5: /* lgs Gv */\n\n        op = R_GS;\n\n    do_lxx:\n\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_lea_modrm(env, s, modrm);\n\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n\n        gen_add_A0_im(s, 1 << ot);\n\n        /* load the segment first to handle exceptions properly */\n\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n\n        gen_movl_seg_T0(s, op);\n\n        /* then put the data */\n\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n\n        if (s->base.is_jmp) {\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* shifts */\n\n    case 0xc0:\n\n    case 0xc1:\n\n        /* shift Ev,Ib */\n\n        shift = 2;\n\n    grp2:\n\n        {\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = x86_ldub_code(env, s);\n\n            mod = (modrm >> 6) & 3;\n\n            op = (modrm >> 3) & 7;\n\n\n\n            if (mod != 3) {\n\n                if (shift == 2) {\n\n                    s->rip_offset = 1;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                opreg = OR_TMP0;\n\n            } else {\n\n                opreg = (modrm & 7) | REX_B(s);\n\n            }\n\n\n\n            /* simpler op */\n\n            if (shift == 0) {\n\n                gen_shift(s, op, ot, opreg, OR_ECX);\n\n            } else {\n\n                if (shift == 2) {\n\n                    shift = x86_ldub_code(env, s);\n\n                }\n\n                gen_shifti(s, op, ot, opreg, shift);\n\n            }\n\n        }\n\n        break;\n\n    case 0xd0:\n\n    case 0xd1:\n\n        /* shift Ev,1 */\n\n        shift = 1;\n\n        goto grp2;\n\n    case 0xd2:\n\n    case 0xd3:\n\n        /* shift Ev,cl */\n\n        shift = 0;\n\n        goto grp2;\n\n\n\n    case 0x1a4: /* shld imm */\n\n        op = 0;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1a5: /* shld cl */\n\n        op = 0;\n\n        shift = 0;\n\n        goto do_shiftd;\n\n    case 0x1ac: /* shrd imm */\n\n        op = 1;\n\n        shift = 1;\n\n        goto do_shiftd;\n\n    case 0x1ad: /* shrd cl */\n\n        op = 1;\n\n        shift = 0;\n\n    do_shiftd:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (mod != 3) {\n\n            gen_lea_modrm(env, s, modrm);\n\n            opreg = OR_TMP0;\n\n        } else {\n\n            opreg = rm;\n\n        }\n\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n\n\n        if (shift) {\n\n            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n\n            tcg_temp_free(imm);\n\n        } else {\n\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* floats */\n\n    case 0xd8 ... 0xdf:\n\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n\n            /* XXX: what to do if illegal op ? */\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n            break;\n\n        }\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        rm = modrm & 7;\n\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n\n        if (mod != 3) {\n\n            /* memory op */\n\n            gen_lea_modrm(env, s, modrm);\n\n            switch(op) {\n\n            case 0x00 ... 0x07: /* fxxxs */\n\n            case 0x10 ... 0x17: /* fixxxl */\n\n            case 0x20 ... 0x27: /* fxxxl */\n\n            case 0x30 ... 0x37: /* fixxx */\n\n                {\n\n                    int op1;\n\n                    op1 = op & 7;\n\n\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n\n                    if (op1 == 3) {\n\n                        /* fcomp needs pop */\n\n                        gen_helper_fpop(cpu_env);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x08: /* flds */\n\n            case 0x0a: /* fsts */\n\n            case 0x0b: /* fstps */\n\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n\n                switch(op & 7) {\n\n                case 0:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 1:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    case 2:\n\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LESW);\n\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n\n                        break;\n\n                    }\n\n                    break;\n\n                case 1:\n\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n\n                    switch(op >> 4) {\n\n                    case 1:\n\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    switch(op >> 4) {\n\n                    case 0:\n\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        break;\n\n                    case 3:\n\n                    default:\n\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                            s->mem_index, MO_LEUW);\n\n                        break;\n\n                    }\n\n                    if ((op & 7) == 3)\n\n                        gen_helper_fpop(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0c: /* fldenv mem */\n\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0d: /* fldcw mem */\n\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n\n                break;\n\n            case 0x0e: /* fnstenv mem */\n\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x0f: /* fnstcw mem */\n\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x1d: /* fldt mem */\n\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x1f: /* fstpt mem */\n\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* frstor mem */\n\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2e: /* fnsave mem */\n\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n\n                break;\n\n            case 0x2f: /* fnstsw mem */\n\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n\n                                    s->mem_index, MO_LEUW);\n\n                break;\n\n            case 0x3c: /* fbld */\n\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n\n                break;\n\n            case 0x3e: /* fbstp */\n\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3d: /* fildll */\n\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n\n                break;\n\n            case 0x3f: /* fistpll */\n\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        } else {\n\n            /* register float ops */\n\n            opreg = rm;\n\n\n\n            switch(op) {\n\n            case 0x08: /* fld sti */\n\n                gen_helper_fpush(cpu_env);\n\n                gen_helper_fmov_ST0_STN(cpu_env,\n\n                                        tcg_const_i32((opreg + 1) & 7));\n\n                break;\n\n            case 0x09: /* fxchg sti */\n\n            case 0x29: /* fxchg4 sti, undocumented op */\n\n            case 0x39: /* fxchg7 sti, undocumented op */\n\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x0a: /* grp d9/2 */\n\n                switch(rm) {\n\n                case 0: /* fnop */\n\n                    /* check exceptions (FreeBSD FPU probe) */\n\n                    gen_helper_fwait(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0c: /* grp d9/4 */\n\n                switch(rm) {\n\n                case 0: /* fchs */\n\n                    gen_helper_fchs_ST0(cpu_env);\n\n                    break;\n\n                case 1: /* fabs */\n\n                    gen_helper_fabs_ST0(cpu_env);\n\n                    break;\n\n                case 4: /* ftst */\n\n                    gen_helper_fldz_FT0(cpu_env);\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    break;\n\n                case 5: /* fxam */\n\n                    gen_helper_fxam_ST0(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x0d: /* grp d9/5 */\n\n                {\n\n                    switch(rm) {\n\n                    case 0:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fld1_ST0(cpu_env);\n\n                        break;\n\n                    case 1:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2t_ST0(cpu_env);\n\n                        break;\n\n                    case 2:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldl2e_ST0(cpu_env);\n\n                        break;\n\n                    case 3:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldpi_ST0(cpu_env);\n\n                        break;\n\n                    case 4:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldlg2_ST0(cpu_env);\n\n                        break;\n\n                    case 5:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldln2_ST0(cpu_env);\n\n                        break;\n\n                    case 6:\n\n                        gen_helper_fpush(cpu_env);\n\n                        gen_helper_fldz_ST0(cpu_env);\n\n                        break;\n\n                    default:\n\n                        goto unknown_op;\n\n                    }\n\n                }\n\n                break;\n\n            case 0x0e: /* grp d9/6 */\n\n                switch(rm) {\n\n                case 0: /* f2xm1 */\n\n                    gen_helper_f2xm1(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2x */\n\n                    gen_helper_fyl2x(cpu_env);\n\n                    break;\n\n                case 2: /* fptan */\n\n                    gen_helper_fptan(cpu_env);\n\n                    break;\n\n                case 3: /* fpatan */\n\n                    gen_helper_fpatan(cpu_env);\n\n                    break;\n\n                case 4: /* fxtract */\n\n                    gen_helper_fxtract(cpu_env);\n\n                    break;\n\n                case 5: /* fprem1 */\n\n                    gen_helper_fprem1(cpu_env);\n\n                    break;\n\n                case 6: /* fdecstp */\n\n                    gen_helper_fdecstp(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fincstp */\n\n                    gen_helper_fincstp(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x0f: /* grp d9/7 */\n\n                switch(rm) {\n\n                case 0: /* fprem */\n\n                    gen_helper_fprem(cpu_env);\n\n                    break;\n\n                case 1: /* fyl2xp1 */\n\n                    gen_helper_fyl2xp1(cpu_env);\n\n                    break;\n\n                case 2: /* fsqrt */\n\n                    gen_helper_fsqrt(cpu_env);\n\n                    break;\n\n                case 3: /* fsincos */\n\n                    gen_helper_fsincos(cpu_env);\n\n                    break;\n\n                case 5: /* fscale */\n\n                    gen_helper_fscale(cpu_env);\n\n                    break;\n\n                case 4: /* frndint */\n\n                    gen_helper_frndint(cpu_env);\n\n                    break;\n\n                case 6: /* fsin */\n\n                    gen_helper_fsin(cpu_env);\n\n                    break;\n\n                default:\n\n                case 7: /* fcos */\n\n                    gen_helper_fcos(cpu_env);\n\n                    break;\n\n                }\n\n                break;\n\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n\n                {\n\n                    int op1;\n\n\n\n                    op1 = op & 7;\n\n                    if (op >= 0x20) {\n\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n\n                        if (op >= 0x30)\n\n                            gen_helper_fpop(cpu_env);\n\n                    } else {\n\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                        gen_helper_fp_arith_ST0_FT0(op1);\n\n                    }\n\n                }\n\n                break;\n\n            case 0x02: /* fcom */\n\n            case 0x22: /* fcom2, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x03: /* fcomp */\n\n            case 0x23: /* fcomp3, undocumented op */\n\n            case 0x32: /* fcomp5, undocumented op */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x15: /* da/5 */\n\n                switch(rm) {\n\n                case 1: /* fucompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1c:\n\n                switch(rm) {\n\n                case 0: /* feni (287 only, just do nop here) */\n\n                    break;\n\n                case 1: /* fdisi (287 only, just do nop here) */\n\n                    break;\n\n                case 2: /* fclex */\n\n                    gen_helper_fclex(cpu_env);\n\n                    break;\n\n                case 3: /* fninit */\n\n                    gen_helper_fninit(cpu_env);\n\n                    break;\n\n                case 4: /* fsetpm (287 only, just do nop here) */\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x1d: /* fucomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x1e: /* fcomi */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x28: /* ffree sti */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2a: /* fst sti */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                break;\n\n            case 0x2b: /* fstp sti */\n\n            case 0x0b: /* fstp1 sti, undocumented op */\n\n            case 0x3a: /* fstp8 sti, undocumented op */\n\n            case 0x3b: /* fstp9 sti, undocumented op */\n\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x2c: /* fucom st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                break;\n\n            case 0x2d: /* fucomp st(i) */\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucom_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x33: /* de/3 */\n\n                switch(rm) {\n\n                case 1: /* fcompp */\n\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    gen_helper_fpop(cpu_env);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x38: /* ffreep sti, undocumented op */\n\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fpop(cpu_env);\n\n                break;\n\n            case 0x3c: /* df/4 */\n\n                switch(rm) {\n\n                case 0:\n\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n\n                    break;\n\n                default:\n\n                    goto unknown_op;\n\n                }\n\n                break;\n\n            case 0x3d: /* fucomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x3e: /* fcomip */\n\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_update_cc_op(s);\n\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n\n                gen_helper_fpop(cpu_env);\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                break;\n\n            case 0x10 ... 0x13: /* fcmovxx */\n\n            case 0x18 ... 0x1b:\n\n                {\n\n                    int op1;\n\n                    TCGLabel *l1;\n\n                    static const uint8_t fcmov_cc[8] = {\n\n                        (JCC_B << 1),\n\n                        (JCC_Z << 1),\n\n                        (JCC_BE << 1),\n\n                        (JCC_P << 1),\n\n                    };\n\n\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n\n                    l1 = gen_new_label();\n\n                    gen_jcc1_noeob(s, op1, l1);\n\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n\n                    gen_set_label(l1);\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n        /************************/\n\n        /* string ops */\n\n\n\n    case 0xa4: /* movsS */\n\n    case 0xa5:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_movs(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xaa: /* stosS */\n\n    case 0xab:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_stos(s, ot);\n\n        }\n\n        break;\n\n    case 0xac: /* lodsS */\n\n    case 0xad:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_lods(s, ot);\n\n        }\n\n        break;\n\n    case 0xae: /* scasS */\n\n    case 0xaf:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_scas(s, ot);\n\n        }\n\n        break;\n\n\n\n    case 0xa6: /* cmpsS */\n\n    case 0xa7:\n\n        ot = mo_b_d(b, dflag);\n\n        if (prefixes & PREFIX_REPNZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n\n        } else if (prefixes & PREFIX_REPZ) {\n\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n\n        } else {\n\n            gen_cmps(s, ot);\n\n        }\n\n        break;\n\n    case 0x6c: /* insS */\n\n    case 0x6d:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base, \n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_ins(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0x6e: /* outsS */\n\n    case 0x6f:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes) | 4);\n\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        } else {\n\n            gen_outs(s, ot);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* port I/O */\n\n\n\n    case 0xe4:\n\n    case 0xe5:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xe6:\n\n    case 0xe7:\n\n        ot = mo_b_d32(b, dflag);\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T0, val);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xec:\n\n    case 0xed:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xee:\n\n    case 0xef:\n\n        ot = mo_b_d32(b, dflag);\n\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n\n        gen_check_io(s, ot, pc_start - s->cs_base,\n\n                     svm_is_rep(prefixes));\n\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n\n\n        /************************/\n\n        /* control */\n\n    case 0xc2: /* ret im */\n\n        val = x86_ldsw_code(env, s);\n\n        ot = gen_pop_T0(s);\n\n        gen_stack_update(s, val + (1 << ot));\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xc3: /* ret */\n\n        ot = gen_pop_T0(s);\n\n        gen_pop_update(s, ot);\n\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n\n        gen_op_jmp_v(cpu_T0);\n\n        gen_bnd_jmp(s);\n\n        gen_jr(s, cpu_T0);\n\n        break;\n\n    case 0xca: /* lret im */\n\n        val = x86_ldsw_code(env, s);\n\n    do_lret:\n\n        if (s->pe && !s->vm86) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(val));\n\n        } else {\n\n            gen_stack_A0(s);\n\n            /* pop offset */\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            /* NOTE: keeping EIP updated is not a problem in case of\n\n               exception */\n\n            gen_op_jmp_v(cpu_T0);\n\n            /* pop selector */\n\n            gen_add_A0_im(s, 1 << dflag);\n\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n\n            gen_op_movl_seg_T0_vm(R_CS);\n\n            /* add stack offset */\n\n            gen_stack_update(s, val + (2 << dflag));\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xcb: /* lret */\n\n        val = 0;\n\n        goto do_lret;\n\n    case 0xcf: /* iret */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n\n        if (!s->pe) {\n\n            /* real mode */\n\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        } else if (s->vm86) {\n\n            if (s->iopl != 3) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n        } else {\n\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n\n                                      tcg_const_i32(s->pc - s->cs_base));\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n        }\n\n        gen_eob(s);\n\n        break;\n\n    case 0xe8: /* call im */\n\n        {\n\n            if (dflag != MO_16) {\n\n                tval = (int32_t)insn_get(env, s, MO_32);\n\n            } else {\n\n                tval = (int16_t)insn_get(env, s, MO_16);\n\n            }\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            } else if (!CODE64(s)) {\n\n                tval &= 0xffffffff;\n\n            }\n\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n\n            gen_push_v(s, cpu_T0);\n\n            gen_bnd_jmp(s);\n\n            gen_jmp(s, tval);\n\n        }\n\n        break;\n\n    case 0x9a: /* lcall im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_lcall;\n\n    case 0xe9: /* jmp im */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        } else if (!CODE64(s)) {\n\n            tval &= 0xffffffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0xea: /* ljmp im */\n\n        {\n\n            unsigned int selector, offset;\n\n\n\n            if (CODE64(s))\n\n                goto illegal_op;\n\n            ot = dflag;\n\n            offset = insn_get(env, s, ot);\n\n            selector = insn_get(env, s, MO_16);\n\n\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n\n            tcg_gen_movi_tl(cpu_T1, offset);\n\n        }\n\n        goto do_ljmp;\n\n    case 0xeb: /* jmp Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        tval += s->pc - s->cs_base;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_jmp(s, tval);\n\n        break;\n\n    case 0x70 ... 0x7f: /* jcc Jb */\n\n        tval = (int8_t)insn_get(env, s, MO_8);\n\n        goto do_jcc;\n\n    case 0x180 ... 0x18f: /* jcc Jv */\n\n        if (dflag != MO_16) {\n\n            tval = (int32_t)insn_get(env, s, MO_32);\n\n        } else {\n\n            tval = (int16_t)insn_get(env, s, MO_16);\n\n        }\n\n    do_jcc:\n\n        next_eip = s->pc - s->cs_base;\n\n        tval += next_eip;\n\n        if (dflag == MO_16) {\n\n            tval &= 0xffff;\n\n        }\n\n        gen_bnd_jmp(s);\n\n        gen_jcc(s, b, tval, next_eip);\n\n        break;\n\n\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_setcc1(s, b, cpu_T0);\n\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n\n        break;\n\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n\n            goto illegal_op;\n\n        }\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n\n        break;\n\n\n\n        /************************/\n\n        /* flags */\n\n    case 0x9c: /* pushf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n\n            gen_push_v(s, cpu_T0);\n\n        }\n\n        break;\n\n    case 0x9d: /* popf */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            ot = gen_pop_T0(s);\n\n            if (s->cpl == 0) {\n\n                if (dflag != MO_16) {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK |\n\n                                                           IOPL_MASK)));\n\n                } else {\n\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                           ID_MASK | NT_MASK |\n\n                                                           IF_MASK | IOPL_MASK)\n\n                                                          & 0xffff));\n\n                }\n\n            } else {\n\n                if (s->cpl <= s->iopl) {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                                tcg_const_i32((TF_MASK |\n\n                                                               AC_MASK |\n\n                                                               ID_MASK |\n\n                                                               NT_MASK |\n\n                                                               IF_MASK)\n\n                                                              & 0xffff));\n\n                    }\n\n                } else {\n\n                    if (dflag != MO_16) {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)));\n\n                    } else {\n\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n\n                                                          ID_MASK | NT_MASK)\n\n                                                         & 0xffff));\n\n                    }\n\n                }\n\n            }\n\n            gen_pop_update(s, ot);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            /* abort translation because TF/AC flag may change */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x9e: /* sahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n\n        break;\n\n    case 0x9f: /* lahf */\n\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n\n            goto illegal_op;\n\n        gen_compute_eflags(s);\n\n        /* Note: gen_compute_eflags() only gives the condition codes */\n\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n\n        break;\n\n    case 0xf5: /* cmc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xf8: /* clc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n\n        break;\n\n    case 0xf9: /* stc */\n\n        gen_compute_eflags(s);\n\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n\n        break;\n\n    case 0xfc: /* cld */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n    case 0xfd: /* std */\n\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n\n        break;\n\n\n\n        /************************/\n\n        /* bit operations */\n\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        op = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        if (mod != 3) {\n\n            s->rip_offset = 1;\n\n            gen_lea_modrm(env, s, modrm);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n        /* load shift */\n\n        val = x86_ldub_code(env, s);\n\n        tcg_gen_movi_tl(cpu_T1, val);\n\n        if (op < 4)\n\n            goto unknown_op;\n\n        op -= 4;\n\n        goto bt_op;\n\n    case 0x1a3: /* bt Gv, Ev */\n\n        op = 0;\n\n        goto do_btx;\n\n    case 0x1ab: /* bts */\n\n        op = 1;\n\n        goto do_btx;\n\n    case 0x1b3: /* btr */\n\n        op = 2;\n\n        goto do_btx;\n\n    case 0x1bb: /* btc */\n\n        op = 3;\n\n    do_btx:\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        mod = (modrm >> 6) & 3;\n\n        rm = (modrm & 7) | REX_B(s);\n\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n\n        if (mod != 3) {\n\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n            /* specific case: we need to add a displacement */\n\n            gen_exts(ot, cpu_T1);\n\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n            if (!(s->prefix & PREFIX_LOCK)) {\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n            }\n\n        } else {\n\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n        }\n\n    bt_op:\n\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n\n        if (s->prefix & PREFIX_LOCK) {\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Needs no atomic ops; we surpressed the normal\n\n                   memory load for LOCK above so do it now.  */\n\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                           s->mem_index, ot | MO_LE);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n\n                                            s->mem_index, ot | MO_LE);\n\n                break;\n\n            }\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n        } else {\n\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n\n            switch (op) {\n\n            case 0: /* bt */\n\n                /* Data already loaded; nothing to do.  */\n\n                break;\n\n            case 1: /* bts */\n\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            case 2: /* btr */\n\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            default:\n\n            case 3: /* btc */\n\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n\n                break;\n\n            }\n\n            if (op != 0) {\n\n                if (mod != 3) {\n\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n\n                } else {\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* Delay all CC updates until after the store above.  Note that\n\n           C is the result of the test, Z is unchanged, and the others\n\n           are all undefined.  */\n\n        switch (s->cc_op) {\n\n        case CC_OP_MULB ... CC_OP_MULQ:\n\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        case CC_OP_INCB ... CC_OP_INCQ:\n\n        case CC_OP_DECB ... CC_OP_DECQ:\n\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        case CC_OP_SARB ... CC_OP_SARQ:\n\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n\n            /* Z was going to be computed from the non-zero status of CC_DST.\n\n               We can get that same Z value (and the new C value) by leaving\n\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n\n               same width.  */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n\n            break;\n\n        default:\n\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n\n            gen_compute_eflags(s);\n\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n\n                               ctz32(CC_C), 1);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x1bc: /* bsf / tzcnt */\n\n    case 0x1bd: /* bsr / lzcnt */\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n\n        if ((prefixes & PREFIX_REPZ)\n\n            && (b & 1\n\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n\n            int size = 8 << ot;\n\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n            if (b & 1) {\n\n                /* For lzcnt, reduce the target_ulong result by the\n\n                   number of zeros that we expect to find at the top.  */\n\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n\n            } else {\n\n                /* For tzcnt, a zero input must return the operand size.  */\n\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n\n            }\n\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n\n            gen_op_update1_cc();\n\n            set_cc_op(s, CC_OP_BMILGB + ot);\n\n        } else {\n\n            /* For bsr/bsf, only the Z bit is defined and it is related\n\n               to the input and not the result.  */\n\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n\n\n            /* ??? The manual says that the output is undefined when the\n\n               input is zero, but real hardware leaves it unchanged, and\n\n               real programs appear to depend on that.  Accomplish this\n\n               by passing the output as the value to return upon zero.  */\n\n            if (b & 1) {\n\n                /* For bsr, return the bit index of the first 1 bit,\n\n                   not the count of leading zeros.  */\n\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n\n            } else {\n\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n\n            }\n\n        }\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        break;\n\n        /************************/\n\n        /* bcd */\n\n    case 0x27: /* daa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_daa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x2f: /* das */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_das(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x37: /* aaa */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aaa(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0x3f: /* aas */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_helper_aas(cpu_env);\n\n        set_cc_op(s, CC_OP_EFLAGS);\n\n        break;\n\n    case 0xd4: /* aam */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        if (val == 0) {\n\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n\n            set_cc_op(s, CC_OP_LOGICB);\n\n        }\n\n        break;\n\n    case 0xd5: /* aad */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        val = x86_ldub_code(env, s);\n\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n\n        set_cc_op(s, CC_OP_LOGICB);\n\n        break;\n\n        /************************/\n\n        /* misc */\n\n    case 0x90: /* nop */\n\n        /* XXX: correct lock test for all insn */\n\n        if (prefixes & PREFIX_LOCK) {\n\n            goto illegal_op;\n\n        }\n\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n\n        if (REX_B(s)) {\n\n            goto do_xchg_reg_eax;\n\n        }\n\n        if (prefixes & PREFIX_REPZ) {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x9b: /* fwait */\n\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n\n            (HF_MP_MASK | HF_TS_MASK)) {\n\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_fwait(cpu_env);\n\n        }\n\n        break;\n\n    case 0xcc: /* int3 */\n\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        break;\n\n    case 0xcd: /* int N */\n\n        val = x86_ldub_code(env, s);\n\n        if (s->vm86 && s->iopl != 3) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0xce: /* into */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        break;\n\n#ifdef WANT_ICEBP\n\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n\n#if 1\n\n        gen_debug(s, pc_start - s->cs_base);\n\n#else\n\n        /* start debug */\n\n        tb_flush(CPU(x86_env_get_cpu(env)));\n\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n\n#endif\n\n        break;\n\n#endif\n\n    case 0xfa: /* cli */\n\n        if (!s->vm86) {\n\n            if (s->cpl <= s->iopl) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        } else {\n\n            if (s->iopl == 3) {\n\n                gen_helper_cli(cpu_env);\n\n            } else {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            }\n\n        }\n\n        break;\n\n    case 0xfb: /* sti */\n\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n\n            gen_helper_sti(cpu_env);\n\n            /* interruptions are enabled only the first insn after sti */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob_inhibit_irq(s, true);\n\n        } else {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x62: /* bound */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        ot = dflag;\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = (modrm >> 3) & 7;\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n\n        gen_lea_modrm(env, s, modrm);\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        if (ot == MO_16) {\n\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        } else {\n\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n\n        }\n\n        break;\n\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n\n        reg = (b & 7) | REX_B(s);\n\n#ifdef TARGET_X86_64\n\n        if (dflag == MO_64) {\n\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n\n        } else\n\n#endif\n\n        {\n\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n\n        }\n\n        break;\n\n    case 0xd6: /* salc */\n\n        if (CODE64(s))\n\n            goto illegal_op;\n\n        gen_compute_eflags_c(s, cpu_T0);\n\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n\n        break;\n\n    case 0xe0: /* loopnz */\n\n    case 0xe1: /* loopz */\n\n    case 0xe2: /* loop */\n\n    case 0xe3: /* jecxz */\n\n        {\n\n            TCGLabel *l1, *l2, *l3;\n\n\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n\n            next_eip = s->pc - s->cs_base;\n\n            tval += next_eip;\n\n            if (dflag == MO_16) {\n\n                tval &= 0xffff;\n\n            }\n\n\n\n            l1 = gen_new_label();\n\n            l2 = gen_new_label();\n\n            l3 = gen_new_label();\n\n            b &= 3;\n\n            switch(b) {\n\n            case 0: /* loopnz */\n\n            case 1: /* loopz */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jz_ecx(s->aflag, l3);\n\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n\n                break;\n\n            case 2: /* loop */\n\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n\n                gen_op_jnz_ecx(s->aflag, l1);\n\n                break;\n\n            default:\n\n            case 3: /* jcxz */\n\n                gen_op_jz_ecx(s->aflag, l1);\n\n                break;\n\n            }\n\n\n\n            gen_set_label(l3);\n\n            gen_jmp_im(next_eip);\n\n            tcg_gen_br(l2);\n\n\n\n            gen_set_label(l1);\n\n            gen_jmp_im(tval);\n\n            gen_set_label(l2);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x130: /* wrmsr */\n\n    case 0x132: /* rdmsr */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (b & 2) {\n\n                gen_helper_rdmsr(cpu_env);\n\n            } else {\n\n                gen_helper_wrmsr(cpu_env);\n\n            }\n\n        }\n\n        break;\n\n    case 0x131: /* rdtsc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_start();\n\n\t}\n\n        gen_helper_rdtsc(cpu_env);\n\n        if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n            gen_io_end();\n\n            gen_jmp(s, s->pc - s->cs_base);\n\n        }\n\n        break;\n\n    case 0x133: /* rdpmc */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_rdpmc(cpu_env);\n\n        break;\n\n    case 0x134: /* sysenter */\n\n        /* For Intel SYSENTER is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysenter(cpu_env);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    case 0x135: /* sysexit */\n\n        /* For Intel SYSEXIT is valid on 64-bit */\n\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n\n            goto illegal_op;\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n#ifdef TARGET_X86_64\n\n    case 0x105: /* syscall */\n\n        /* XXX: is it usable in real mode ? */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n\n           after the syscall insn completes. This allows #DB to not be\n\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n\n        gen_eob_worker(s, false, true);\n\n        break;\n\n    case 0x107: /* sysret */\n\n        if (!s->pe) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n\n            /* condition codes are modified only in long mode */\n\n            if (s->lma) {\n\n                set_cc_op(s, CC_OP_EFLAGS);\n\n            }\n\n            /* TF handling for the sysret insn is different. The TF bit is\n\n               checked after the sysret insn completes. This allows #DB to be\n\n               generated \"as if\" the syscall insn in userspace has just\n\n               completed.  */\n\n            gen_eob_worker(s, false, true);\n\n        }\n\n        break;\n\n#endif\n\n    case 0x1a2: /* cpuid */\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(pc_start - s->cs_base);\n\n        gen_helper_cpuid(cpu_env);\n\n        break;\n\n    case 0xf4: /* hlt */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n        }\n\n        break;\n\n    case 0x100:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* sldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, ldt.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 2: /* lldt */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 1: /* str */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n\n                             offsetof(CPUX86State, tr.selector));\n\n            ot = mod == 3 ? dflag : MO_16;\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 3: /* ltr */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n\n            }\n\n            break;\n\n        case 4: /* verr */\n\n        case 5: /* verw */\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_update_cc_op(s);\n\n            if (op == 4) {\n\n                gen_helper_verr(cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_verw(cpu_env, cpu_T0);\n\n            }\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            break;\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x101:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0,\n\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xc8: /* monitor */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n\n            gen_extu(s->aflag, cpu_A0);\n\n            gen_add_A0_ds_seg(s);\n\n            gen_helper_monitor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        case 0xc9: /* mwait */\n\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xca: /* clac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_clac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xcb: /* stac */\n\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n\n                || s->cpl != 0) {\n\n                goto illegal_op;\n\n            }\n\n            gen_helper_stac(cpu_env);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        case 0xd0: /* xgetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n\n\n        case 0xd1: /* xsetbv */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            /* End TB because translation flags may change.  */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xd8: /* VMRUN */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n\n                             tcg_const_i32(s->pc - pc_start));\n\n            tcg_gen_exit_tb(0);\n\n            s->base.is_jmp = DISAS_NORETURN;\n\n            break;\n\n\n\n        case 0xd9: /* VMMCALL */\n\n            if (!(s->flags & HF_SVME_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmmcall(cpu_env);\n\n            break;\n\n\n\n        case 0xda: /* VMLOAD */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdb: /* VMSAVE */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        case 0xdc: /* STGI */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_stgi(cpu_env);\n\n            break;\n\n\n\n        case 0xdd: /* CLGI */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_clgi(cpu_env);\n\n            break;\n\n\n\n        case 0xde: /* SKINIT */\n\n            if ((!(s->flags & HF_SVME_MASK)\n\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n\n                || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_skinit(cpu_env);\n\n            break;\n\n\n\n        case 0xdf: /* INVLPGA */\n\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n\n            gen_add_A0_im(s, 2);\n\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n\n            if (dflag == MO_16) {\n\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n\n            }\n\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n\n            break;\n\n\n\n        CASE_MODRM_OP(4): /* smsw */\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n\n            if (CODE64(s)) {\n\n                mod = (modrm >> 6) & 3;\n\n                ot = (mod != 3 ? MO_16 : s->dflag);\n\n            } else {\n\n                ot = MO_16;\n\n            }\n\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n\n            break;\n\n        case 0xee: /* rdpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n\n            break;\n\n        case 0xef: /* wrpkru */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n\n            break;\n\n        CASE_MODRM_OP(6): /* lmsw */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            gen_helper_lmsw(cpu_env, cpu_T0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n\n            if (s->cpl != 0) {\n\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_invlpg(cpu_env, cpu_A0);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        case 0xf8: /* swapgs */\n\n#ifdef TARGET_X86_64\n\n            if (CODE64(s)) {\n\n                if (s->cpl != 0) {\n\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n                } else {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n\n                                  offsetof(CPUX86State, kernelgsbase));\n\n                }\n\n                break;\n\n            }\n\n#endif\n\n            goto illegal_op;\n\n\n\n        case 0xf9: /* rdtscp */\n\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n\n                goto illegal_op;\n\n            }\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(pc_start - s->cs_base);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_start();\n\n            }\n\n            gen_helper_rdtscp(cpu_env);\n\n            if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                gen_io_end();\n\n                gen_jmp(s, s->pc - s->cs_base);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x108: /* invd */\n\n    case 0x109: /* wbinvd */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n\n            /* nothing to do */\n\n        }\n\n        break;\n\n    case 0x63: /* arpl or movslS (x86_64) */\n\n#ifdef TARGET_X86_64\n\n        if (CODE64(s)) {\n\n            int d_ot;\n\n            /* d_ot is the size of destination */\n\n            d_ot = dflag;\n\n\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = (modrm & 7) | REX_B(s);\n\n\n\n            if (mod == 3) {\n\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n\n                /* sign extend */\n\n                if (d_ot == MO_64) {\n\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n\n                }\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            } else {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n\n            }\n\n        } else\n\n#endif\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0, t1, t2, a0;\n\n\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            t0 = tcg_temp_local_new();\n\n            t1 = tcg_temp_local_new();\n\n            t2 = tcg_temp_local_new();\n\n            ot = MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = (modrm >> 3) & 7;\n\n            mod = (modrm >> 6) & 3;\n\n            rm = modrm & 7;\n\n            if (mod != 3) {\n\n                gen_lea_modrm(env, s, modrm);\n\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n\n                a0 = tcg_temp_local_new();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n\n            } else {\n\n                gen_op_mov_v_reg(ot, t0, rm);\n\n                TCGV_UNUSED(a0);\n\n            }\n\n            gen_op_mov_v_reg(ot, t1, reg);\n\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n\n            tcg_gen_andi_tl(t1, t1, 3);\n\n            tcg_gen_movi_tl(t2, 0);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n\n            tcg_gen_andi_tl(t0, t0, ~3);\n\n            tcg_gen_or_tl(t0, t0, t1);\n\n            tcg_gen_movi_tl(t2, CC_Z);\n\n            gen_set_label(label1);\n\n            if (mod != 3) {\n\n                gen_op_st_v(s, ot, t0, a0);\n\n                tcg_temp_free(a0);\n\n           } else {\n\n                gen_op_mov_reg_v(ot, rm, t0);\n\n            }\n\n            gen_compute_eflags(s);\n\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n\n            tcg_temp_free(t0);\n\n            tcg_temp_free(t1);\n\n            tcg_temp_free(t2);\n\n        }\n\n        break;\n\n    case 0x102: /* lar */\n\n    case 0x103: /* lsl */\n\n        {\n\n            TCGLabel *label1;\n\n            TCGv t0;\n\n            if (!s->pe || s->vm86)\n\n                goto illegal_op;\n\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n\n            modrm = x86_ldub_code(env, s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n\n            t0 = tcg_temp_local_new();\n\n            gen_update_cc_op(s);\n\n            if (b == 0x102) {\n\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n\n            } else {\n\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n\n            }\n\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n\n            label1 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n\n            gen_op_mov_reg_v(ot, reg, t0);\n\n            gen_set_label(label1);\n\n            set_cc_op(s, CC_OP_EFLAGS);\n\n            tcg_temp_free(t0);\n\n        }\n\n        break;\n\n    case 0x118:\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        op = (modrm >> 3) & 7;\n\n        switch(op) {\n\n        case 0: /* prefetchnta */\n\n        case 1: /* prefetchnt0 */\n\n        case 2: /* prefetchnt0 */\n\n        case 3: /* prefetchnt0 */\n\n            if (mod == 3)\n\n                goto illegal_op;\n\n            gen_nop_modrm(env, s, modrm);\n\n            /* nothing more to do */\n\n            break;\n\n        default: /* nop (multi byte) */\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n        }\n\n        break;\n\n    case 0x11a:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (prefixes & PREFIX_REPZ) {\n\n                /* bndcl */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcu */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                TCGv_i64 notu = tcg_temp_new_i64();\n\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n\n                tcg_temp_free_i64(notu);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- from reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                    /* bnd registers are now in-use */\n\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndldx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n\n                } else {\n\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n\n                }\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x11b:\n\n        modrm = x86_ldub_code(env, s);\n\n        if (s->flags & HF_MPX_EN_MASK) {\n\n            mod = (modrm >> 6) & 3;\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n\n                /* bndmk */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (a.base >= 0) {\n\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n\n                    if (!CODE64(s)) {\n\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n\n                    }\n\n                } else if (a.base == -1) {\n\n                    /* no base register has lower bound of 0 */\n\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n\n                } else {\n\n                    /* rip-relative generates #ud */\n\n                    goto illegal_op;\n\n                }\n\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n\n                if (!CODE64(s)) {\n\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n\n                }\n\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n\n                /* bnd registers are now in-use */\n\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n\n                break;\n\n            } else if (prefixes & PREFIX_REPNZ) {\n\n                /* bndcn */\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n\n            } else if (prefixes & PREFIX_DATA) {\n\n                /* bndmov -- to reg/mem */\n\n                if (reg >= 4 || s->aflag == MO_16) {\n\n                    goto illegal_op;\n\n                }\n\n                if (mod == 3) {\n\n                    int reg2 = (modrm & 7) | REX_B(s);\n\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n\n                        goto illegal_op;\n\n                    }\n\n                    if (s->flags & HF_MPX_IU_MASK) {\n\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n\n                    }\n\n                } else {\n\n                    gen_lea_modrm(env, s, modrm);\n\n                    if (CODE64(s)) {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEQ);\n\n                    } else {\n\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n\n                                            s->mem_index, MO_LEUL);\n\n                    }\n\n                }\n\n            } else if (mod != 3) {\n\n                /* bndstx */\n\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n\n                if (reg >= 4\n\n                    || (prefixes & PREFIX_LOCK)\n\n                    || s->aflag == MO_16\n\n                    || a.base < -1) {\n\n                    goto illegal_op;\n\n                }\n\n                if (a.base >= 0) {\n\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_A0, 0);\n\n                }\n\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n\n                if (a.index >= 0) {\n\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n\n                } else {\n\n                    tcg_gen_movi_tl(cpu_T0, 0);\n\n                }\n\n                if (CODE64(s)) {\n\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                } else {\n\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n\n                }\n\n            }\n\n        }\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n\n        modrm = x86_ldub_code(env, s);\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x120: /* mov reg, crN */\n\n    case 0x122: /* mov crN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n\n                reg = 8;\n\n            }\n\n            switch(reg) {\n\n            case 0:\n\n            case 2:\n\n            case 3:\n\n            case 4:\n\n            case 8:\n\n                gen_update_cc_op(s);\n\n                gen_jmp_im(pc_start - s->cs_base);\n\n                if (b & 2) {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n\n                                         cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                    gen_jmp_im(s->pc - s->cs_base);\n\n                    gen_eob(s);\n\n                } else {\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_start();\n\n                    }\n\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n                    if (s->base.tb->cflags & CF_USE_ICOUNT) {\n\n                        gen_io_end();\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                goto unknown_op;\n\n            }\n\n        }\n\n        break;\n\n    case 0x121: /* mov reg, drN */\n\n    case 0x123: /* mov drN, reg */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            modrm = x86_ldub_code(env, s);\n\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n\n             * AMD documentation (24594.pdf) and testing of\n\n             * intel 386 and 486 processors all show that the mod bits\n\n             * are assumed to be 1's, regardless of actual values.\n\n             */\n\n            rm = (modrm & 7) | REX_B(s);\n\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            if (CODE64(s))\n\n                ot = MO_64;\n\n            else\n\n                ot = MO_32;\n\n            if (reg >= 8) {\n\n                goto illegal_op;\n\n            }\n\n            if (b & 2) {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n\n                gen_jmp_im(s->pc - s->cs_base);\n\n                gen_eob(s);\n\n            } else {\n\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n\n            }\n\n        }\n\n        break;\n\n    case 0x106: /* clts */\n\n        if (s->cpl != 0) {\n\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n\n        } else {\n\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n\n            gen_helper_clts(cpu_env);\n\n            /* abort block because static cpu state changed */\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n        }\n\n        break;\n\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n\n    case 0x1c3: /* MOVNTI reg, mem */\n\n        if (!(s->cpuid_features & CPUID_SSE2))\n\n            goto illegal_op;\n\n        ot = mo_64_32(dflag);\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n\n        break;\n\n    case 0x1ae:\n\n        modrm = x86_ldub_code(env, s);\n\n        switch (modrm) {\n\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxsave(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n\n            if (!(s->cpuid_features & CPUID_FXSR)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n\n                goto illegal_op;\n\n            }\n\n            if (s->flags & HF_TS_MASK) {\n\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n\n                break;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                goto illegal_op;\n\n            }\n\n            gen_lea_modrm(env, s, modrm);\n\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                  cpu_regs[R_EDX]);\n\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            /* XRSTOR is how MPX is enabled, which changes how\n\n               we translate.  Thus we need to end the TB.  */\n\n            gen_update_cc_op(s);\n\n            gen_jmp_im(s->pc - s->cs_base);\n\n            gen_eob(s);\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clwb */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_nop_modrm(env, s, modrm);\n\n            } else {\n\n                /* xsaveopt */\n\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n\n                    goto illegal_op;\n\n                }\n\n                gen_lea_modrm(env, s, modrm);\n\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n\n                                      cpu_regs[R_EDX]);\n\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n\n            }\n\n            break;\n\n\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n\n            if (prefixes & PREFIX_LOCK) {\n\n                goto illegal_op;\n\n            }\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* clflushopt */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n\n                    goto illegal_op;\n\n                }\n\n            } else {\n\n                /* clflush */\n\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n\n                    goto illegal_op;\n\n                }\n\n            }\n\n            gen_nop_modrm(env, s, modrm);\n\n            break;\n\n\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n\n        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */\n\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n\n        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */\n\n            if (CODE64(s)\n\n                && (prefixes & PREFIX_REPZ)\n\n                && !(prefixes & PREFIX_LOCK)\n\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n\n                TCGv base, treg, src, dst;\n\n\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n\n\n                if (modrm & 0x10) {\n\n                    /* wr*base */\n\n                    dst = base, src = treg;\n\n                } else {\n\n                    /* rd*base */\n\n                    dst = treg, src = base;\n\n                }\n\n\n\n                if (s->dflag == MO_32) {\n\n                    tcg_gen_ext32u_tl(dst, src);\n\n                } else {\n\n                    tcg_gen_mov_tl(dst, src);\n\n                }\n\n                break;\n\n            }\n\n            goto unknown_op;\n\n\n\n        case 0xf8: /* sfence / pcommit */\n\n            if (prefixes & PREFIX_DATA) {\n\n                /* pcommit */\n\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n\n                    || (prefixes & PREFIX_LOCK)) {\n\n                    goto illegal_op;\n\n                }\n\n                break;\n\n            }\n\n            /* fallthru */\n\n        case 0xf9 ... 0xff: /* sfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n\n            break;\n\n        case 0xe8 ... 0xef: /* lfence */\n\n            if (!(s->cpuid_features & CPUID_SSE)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n\n            break;\n\n        case 0xf0 ... 0xf7: /* mfence */\n\n            if (!(s->cpuid_features & CPUID_SSE2)\n\n                || (prefixes & PREFIX_LOCK)) {\n\n                goto illegal_op;\n\n            }\n\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n\n            break;\n\n\n\n        default:\n\n            goto unknown_op;\n\n        }\n\n        break;\n\n\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n\n        modrm = x86_ldub_code(env, s);\n\n        mod = (modrm >> 6) & 3;\n\n        if (mod == 3)\n\n            goto illegal_op;\n\n        gen_nop_modrm(env, s, modrm);\n\n        break;\n\n    case 0x1aa: /* rsm */\n\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n\n        if (!(s->flags & HF_SMM_MASK))\n\n            goto illegal_op;\n\n        gen_update_cc_op(s);\n\n        gen_jmp_im(s->pc - s->cs_base);\n\n        gen_helper_rsm(cpu_env);\n\n        gen_eob(s);\n\n        break;\n\n    case 0x1b8: /* SSE4.2 popcnt */\n\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n\n             PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n        }\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n    }\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n\n}\n", "idx": 569, "substitutes": {"s": ["ls", "c", "sg", "strings", "p", "es", "n", "ses", "params", "gets", "services", "its", "conf", "ports", "ans", "cs", "spec", "ains", "ies", "an", "h", "properties", "gs", "sb", "args", "os", "a", "mods", "stats", "sv", "actions", "settings", "vs", "details", "ers", "ds", "qs", "eds", "ears", "bs", "tags", "ims", "bes", "hs", "ar", "sts", "eps", "pers", "ins", "states", "sq", "j", "S", "er", "sets", "ss", "z", "als", "sl", "comm", "i", "tes", "uns", "sym", "ns", "sw", "y", "ms", "ts", "changes", "v", "tests", "ares", "results", "uploads", "rates", "se", "ssl", "sp", "sys", "scripts", "sh", "is", "g", "fs", "aws", "ps", "js", "sd", "ads", "comments", "e", "terms", "rs", "ats"], "cpu": ["proc", "sys", "core", "cp", "alloc", "phys", "jp", "c", "p", "conn", "pu", "hw", "np", "gpu", "CPU", "ds", "x", "sc", "linux", "cache", "ps", "tp", "mu", "cap", "vm", "cs", "ctx", "spec", "gc", "clock", "cu", "process", "os", "mem", "pro"], "env": ["proc", "ec", "cp", "usr", "net", "et", "er", "buf", "sv", "ss", "conn", "docker", "ev", "window", "vs", "hw", "server", "ds", "environment", "esc", "pe", "vp", "dev", "ef", "eu", "conf", "vm", "disk", "w", "e", "context", "setup", "en", "here", "ctx", "home", "v", "ten", "obj", "eng", "cmd"], "b": ["br", "d", "l", "mb", "eb", "c", "bc", "p", "bind", "n", "g", "reb", "r", "ab", "bp", "cb", "rb", "m", "i", "x", "u", "be", "bit", "bb", "bs", "y", "bi", "w", "e", "wb", "bin", "ba", "db", "fb", "v", "o", "h", "B", "sb", "bf", "nb", "a", "ib", "byte"], "prefixes": ["fixes", "fixesers", "fixesels", "fixences", "fixis", "prefixentials", "frames", " prefixences", "termsedes", "ixales", "stickences", "fixlees", "frams", "stripes", "stickales", "fixeses", " prefixe", "ixers", "prefixES", "stripES", "fixales", "termsions", "ixets", "framers", " prefixales", "parentsentials", "prefixis", "prefixers", "fixesis", "parentsales", "prefixs", "fixesES", "ixs", "fixers", "termses", "prefixales", "prefixlees", "stripedes", " prefixets", " prefixlees", "ixe", "fixe", " prefixs", "fixesales", "prefixions", "parentsES", "fixese", "prefixets", "ixences", "fixES", " prefixis", " prefixers", "fixesions", "fixesentials", "fixels", "stripions", "termsES", "sticklees", "stickes", "parentses", "prefixences", "ixes", "prefixels", "fixentials", "fixesedes", "prefixedes", "framets", "prefixe", " prefixels"], "shift": ["ctr", "xff", "ff", "aw", "use", "mask", "sh", "sup", "set", "align", "hift", "cb", "aff", "load", "start", "off", "opt", "conf", "ffff", "rew", "Shift", "wrap", "scale", "sb", "push", "sp"], "ot": ["br", "et", "oll", "ool", "ut", "ro", "ol", "ent", "ots", "ow", "O", "uts", "ref", "oc", "rot", "ort", "re", "io", " os", "ress", "o", "ost", "ct", "OL", "oo", "os", "OT", "Os"], "aflag": ["ablit", "aftlag", "afld", "alfld", "aflit", "aftld", "alflag", "ablag", "alflit", "aftlit", "abld", "afread", "alfread", "aftread", "abread"], "dflag": ["rfield", "rflags", "dflags", " dfree", "pflags", "pfield", " dflags", " dfield", "dfield", "dfree", "pflag", "rflag", "pfree", "rfree"], "modrm": ["Modr", "Modrem", " modrem", "MODr", "modr", "modmem", "MODmem", "modrem", "MODrem", "MODrm", "Modmem", " modmem", " modr", "Modrm"], "reg": ["REG", "Reg", "ro", "rom", "g", "ref", "r", "ru", "mg", "res", "eg", "red", "win", "mem", "rec", "rt", "ret", "rem", "rc", "ram", "rep", "re", "rar"], "rm": ["mr", "arm", "rim", "ro", "rom", "rid", "RM", "attr", "ref", "r", "rb", "m", "res", "mem", "perm", "rf", "rr", "rt", "rpm", "rem", "ram", "raf", "rel", "re", "rar", "rn"], "mod": ["cod", "mods", "add", "addr", "fun", "ref", "mode", "set", "m", "pos", "md", "sub", "perm", "man", "mo", "pop", "del", "mm", "MOD", "od", "rem", "mem", "module", "pro"], "op": ["p", "up", "attr", "ref", "mp", "bit", "pos", "off", "ok", "cmp", "opt", "ip", "oc", "hop", "rot", "ap", "pop", "loc", "OP", "o", "rep", "obj", "oper", "ops", "pro"], "opreg": ["oprec", "omreg", "aprec", "apreg", "opregister", " oprec", "apregister", "omregister", " opregister", "omrec"], "val": ["data", "value", "buf", "ref", "pol", "vals", "var", "tx", "num", "pos", "def", "VAL", "pr", "dev", "ctx", "bal", "bin", "alt", "eval", "v", "vol", "ret", "rem", "rel", "mem"], "next_eip": ["next_ei", "next_seips", "next_edip", "next_edi", "next_eei", "next_sei", "next_eips", "next_edips", "next_seip", "next_eeip", "next_eeips"], "tval": ["tVal", "Tval", " tvalue", " tbl", "tvalue", "pbl", "Tvalue", "pval", " tVal", "tbl", "pVal", "TVal", "Tbl", "pvalue"], "rex_w": ["pex_x", "rex___r", "rex___weight", "pex_b", "wr_x", "rex_x", "pex_W", "rex_W", "pex_w", "rex___w", "rex_b", "wr_w", "rex_weight", "wr_weight", "wr_r", "rex___x"], "rex_r": ["x_w", "x_r", "x_l", "rez_r", "rex7l", "rez_o", "rex_f", "x_f", "rex7r", "rex_b", "rez_b", "rex7f", "rex_o", "rex7w", "rex_l"], "pc": ["proc", "ec", "cp", "PC", "fc", "po", "c", "bc", "port", "p", "dc", "pn", "pm", "pb", "pi", "bp", "mp", "pp", "page", "sc", "cmp", "pr", "tp", "pa", "ptr", "arc", "cs", "ctx", "gc", "co", "pt", "cc", "pan", "rc", "pic", "pid", "point", "mc"], "base": ["sys", "bound", "status", "mb", "back", "ref", "mark", "server", "bp", "ase", "out", "balance", "profile", "Base", "extra", "cache", "bs", "file", "block", "buffer", "cs", "name", "db", "bas", "prefix", "top"]}}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 572, "substitutes": {"bs": ["cks", "bc", "bh", "is", "bd", "ss", "bm", "bp", "ds", "b", "ubs", "fs", "lbs", "BS", "ps", "its", "bb", "bos", "ns", "aos", "bi", "bis", "cs", "ts", "bg", "ks", "bps", "rs", "bl", "bits", "gs", "bas", "sb", "bf", "bn"], "filename": ["fp", "ames", "fil", "LCS", "directory", "source", "ename", "files", "fle", "kj", "localhost", "txt", "nil", "lua", "path", "url", "ame", "fs", "family", "title", "println", "location", "file", "username", "name", "via", "origin", "aka", "nm", "FN", "uri", "til", "jpg", "Filename", "src", "sbm", "binary", "f", "fn", "prefix", "subject", "asm", "json", "rn"], "flags": ["status", "mask", "settings", "files", "faces", "xf", "options", "Flags", "links", "locks", "fs", "fields", " fmt", " flag", "linux", "features", "tags", "ts", " options", "ags", "fee", "bits", "properties", "args", "flag", "FLAG", "Flag", "fd"], "iscsilun": ["iscsolun", "ircsilUN", "ircslong", "ircslut", "iscsilut", "ecsiln", "ecsilUN", "iscsolut", "iscsolUN", "ecsinUN", "iscslun", "iscselUN", "ecsinun", "iscsinut", "iscsolong", "ecsinut", "ircslUN", "ircsilong", "iscslut", "iscslUN", "ecsilut", "ircsilun", "ircsilut", "iscsisUN", "iscslong", "ircslun", "iscsisong", "iscsilong", "iscsinun", "iscsln", "ecsilun", "iscselut", "iscsinUN", "iscsilUN", "iscselun", "iscsinn", "ecsinn", "iscsisun", "iscseln", "iscsiln", "iscsisut"], "iscsi": ["icsie", "discsi", "ischSI", "discii", "iscity", "impscale", "uscsd", "nicsc", "sicsan", "iconsi", "escsi", "ircsim", "discsim", "discsan", "uscsim", "iscscale", "iscsc", "uscsan", "iscsie", "ircsa", "ischki", "uscso", "ischsi", "scsim", "nicsa", "nicsi", "miscSI", "scsd", "sicsi", "iwsie", "discSI", "discsa", "ischsd", "escsie", "impsan", "miscso", "discsc", "scity", "uscSI", "iscsd", "iscii", "scsa", "icsi", "iscki", "escsim", "iwsi", "discsie", "icsc", "uscsi", "ischno", "miscno", "ircsi", "sicscale", "iscno", "iscSI", "iconsan", "icondi", "uscno", "uscsa", "nicii", "ircki", "discsd", "discci", "discity", "impdi", "icci", "iwsc", "ircSI", "miscsi", "iscso", "ischsim", "ircsie", "scsc", "iscdi", "iconsim", "scsi", "discscale", "iscsa", "iscci", "ischso", "iscsan", "scii", "iwci", "iscsim", "discdi", "ischity", "uscki", "ischsa", "impsi", "uscdi", "sicdi", "ircsd"], "iscsi_url": ["iscasus_url", "iscsta_ret", "iscci_res", "iscsim_json", "iscdi_url", "iscsipydl", "iscsiptbuf", "iscasus_uri", "iscsi_handler", "iscstapyhandler", "iscsi_json", "iscdi_link", "iscsi_rel", "iscasus_buf", "iscsi_http", "iscsi_buf", "iscsi_file", "iscci_len", "iscsi_uri", "iscsi__file", "iscci_link", "iscsi_ret", "iscstapyresult", "iscci_rel", "iscci_dl", "iscdi_file", "iscsimyurl", "iscsi_loader", "iscsim_loader", "iscci_url", "iscsi_result", "iscsta_result", "iscsi1url", "iscsipystr", "iscsi_res", "iscsi_dl", "iscsimyrel", "iscsi_Url", "iscsiacstr", "iscsipyhandler", "iscdi_http", "iscsi__link", "iscsim_str", "iscsi_date", "iscsipyresult", "iscsi__url", "iscasus_str", "iscstapyurl", "iscdi_uri", "iscsi_str", "iscdi_str", "iscsiptstr", "iscsta_url", "iscsi__str", "iscsiacurl", "iscsiacUrl", "iscsipturl", "iscsipyusername", "iscsi1Url", "iscsimylink", "iscsta_handler", "iscstapyret", "iscsipturi", "iscsipyret", "iscsim_Url", "iscsimyres", "iscsim_url", "iscsi_username", "iscdi_date", "iscsi_link", "iscsiacjson", "iscsipyurl", "iscsi1loader", "iscsi_len", "iscci_str", "iscci_username"], "task": ["proc", " tasks", "func", " tid", "instance", "text", "TAG", " transaction", "table", "action", "link", "bit", "unknown", "tx", "new", "Task", " Task", "job", "t", "command", " unknown", "function", "thread", "background", "exec", "master"], "initiator_name": ["initiator_type", "initiatorNameno", "initiatorNameName", "initiater_no", "initiate_version", "initiate_string", "initiater_type", "initiate_name", "initiator_string", "initiator___name", "initiater_name", "initiate_key", "initiator_version", "initiator____NAME", "initiate_NAME", "initiator___string", "initiator____version", "initiator____name", "initiator___key", "initiator_NAME", "initiator_no", "initiatorNametype", "initiator_key", "initiater_Name", "initiatorNamename", "initiator_Name"], "ret": ["mt", "RET", "eth", "et", "try", "status", "arr", "dt", "tmp", "mb", "ext", " RET", "fun", "result", "deg", "tree", "out", "res", "ft", "gt", "ll", "def", "mem", "att", "reply", "Ret", "ert", " Ret", "opt", "final", "xt", "desc", "mel", "vet", "ts", "str", "gc", "pas", "alt", "re", "rt", "ter", "rev", "print", "pt", "val", "rm", "rets", "get", "nt", "backed", "hash", "nz", "expr", "rel", "arg", "rem", "tr", "det", "resp", "reset", "elt", "t", "back", "len", "cmd"]}}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573, "substitutes": {"pkt": ["rkt", "vpet", "tpnt", " ppt", "Pett", "racket", "Packet", "vpacket", "paydu", " pett", "prowk", "paykt", "apkt", " pet", "pett", "pdu", "tppt", " pcmd", "pcmd", "apcmd", "proacket", "payacket", "apnt", " pwk", "tpkt", "vpkt", "apett", "Pcmd", "produ", "Pkt", "vpth", " pth", " pdu", "packet", "rpt", "Pet", "rnt", "pnt", " packet", "pwk", "prokt", "pet", "Pnt", "Pth", "pth", " pnt", "paywk", "ppt", "tpacket"], "pkt_data": ["pkt_bin", "pet_len", "pkt_str", "pnt_str", "pkt_buf", "pet_length", "pkt_length", "pet_str", "pnt_data", "pnt_buf", "pet_data", "pnt_bin"], "pkt_len": ["pct_length", "pct_data", "pet_len", "pkt_str", "pkt_Len", "pkt1str", "pkt_l", "pct_Len", "pwd_len", "pkt1data", "pkt2length", "pet_length", "pkt2len", "pkt_length", "pkt1len", "pkt2data", "pct_len", "pwd_str", "pwd_length", "pet_data", "pwd_data", "pkt1length", "pet_l", "pkt2Len"], "vhdr": [" vhdel", "vhsrr", "vhadr", "vholp", "vhgt", " vthld", "vrhder", "vbhvr", "vchDR", "Vhrid", " vihdel", "uvhdgt", " vohusr", "vhtder", "vshstr", "vhdrr", "vherder", "varchdr", "chstr", "uvhdel", "vherdr", "vereharg", "uvhdcmd", "vbhaddr", "Vihder", "vihder", "vchvr", "uvhg", "uvhdpar", "vehdr", "cHstr", "vihrr", "vhasrr", "vihrd", "vHarg", "uvhsg", "vshint", "vhrdr", "uvhpar", "uvhddr", "verehbr", "uvhddel", "vhaddr", "vhdpar", " vhaddr", "vdhdr", "uvhsdr", "vhspar", " voharr", "vthrid", "vhelparr", "vhelpdel", "vhrDR", "vshrid", "vehbr", "vhashgr", " vhrid", "vthvr", "vihgt", " vihgt", "cHdr", " vohdr", "vshdel", "vhrpar", "uvhsrr", "vHdr", "vphrd", "chDR", "vhsgt", "Vhder", "nvhdr", "vwrr", "vhhgt", "vhbr", "vehgt", "vhashcmd", "vihdel", "vhashgt", "vhalp", "vhhdr", "chdr", "hthrr", "vhtrd", "uvhdrid", "vohusr", "vhsusr", "vherrid", "vhasman", "vhpar", "verhbr", "varchder", "vHint", "vthrr", " vhld", "vhdgr", "vherrd", "vhdel", " vohDR", "vhdder", " vharr", "vdhrid", "vhostdr", "uvhdgr", " vohheader", "vhint", "verhdr", "vthld", "vhddr", " vhusr", "vihrid", "voharr", " vohder", "vhostgt", "vhsdel", "uvhsman", "hhdr", "vhelpdr", "vhodr", "vthheader", "vchint", "vohdr", "vshpar", " vihder", "veharg", "vhostbr", "vwheader", "hthder", " vthdr", "vchaddr", "Vhrd", "vhasdr", "vchld", "vohrid", "vhheader", "vhasg", " vohpar", "uvhrid", "vhstr", "cHint", "vchdr", "vihdr", "vhvr", "vhelpusr", "verhgt", "vohr", "vhostarg", "vhg", "vbhdr", "vhusr", "vhrusr", "vthdr", "vohDR", "vphlp", "vwdr", "vphld", "vhddel", "vHstr", "vhsdr", "vhgr", "vharr", "vhcmd", "vhr", "vhrid", "verehdr", "nvhrd", "vhman", "nvhld", "vhard", "nvhald", "uvhdr", "vhelppar", "vbhld", " vhDR", "verharg", "vhsDR", "vhdcmd", " vohr", "vthaddr", "nvhlp", "vhhgr", "vwder", " vthvr", "vhtrid", " vhgt", "vthr", "uvhgr", "chint", "vdhr", "hthdr", " vthaddr", "hthheader", "vhdheader", "vHbr", "vphdr", "uvhgt", "nvhard", "vhelpder", "vihg", "vohpar", "vshdr", "vohheader", " vohrid", "uvhman", "vhdrid", "vhdgt", "vrhgt", "varchusr", "vhhcmd", "Vihrd", "vhashdr", "hhder", "Vihdr", "nvhadr", "uvhcmd", "vhold", "vhsg", "vhld", "vchstr", "hhrr", "nvhalp", "uvhrr", " vhvr", "vohder", "vhald", "vihman", "vhder", " vhheader", "vharg", "vthder", "vhsman", "vHgt", "vhlp", "vshDR", "vhrd", " vihdr", " vhpar", "vhelprid", "vrhdel", "verehgt", "vdhheader", "vhsder", " vhder", "vhtdr", "hhheader", "varcharr", "vrhdr", "Vhdr", " vhr", "vhrr", "vHDR", "vhord", "cHDR", "vhDR", "Vihrid"], "isip4": ["isip44", "isIP44", " isip44", "isist4", "isp6", "isep6", " isIP4", "isIP4", "istip0", "istip04", " isIP6", "istp6", "isep4", "ismp44", "isist0", "isp4", "isep256", "isp0", "isip8", "istp04", "isep04", " isIP8", "isp8", " isIP44", " isip256", "iscp8", "isist6", "isip256", "isip0", " isip8", "ismp4", "isep0", "istip4", "istip6", "isIP8", "ismp256", "istp0", "iscp6", "ismp6", "iscp44", "isip04", "isp04", "istp4", "isep44", "isist04", "isp44", "isIP6", "iscp4"], "isip6": ["Isip3", "isipp8", "ismip8", "issIP6", "isipp62", "isp6", "isep6", "issip8", "isip36", "isep8", "isIPnet", "isop2", "isip2", "isep36", "isIP4", "Isip2", "issip4", "ismip6", "isep4", "isop4", "isp3", "ismhip62", "isp4", "Isip4", "Isip6", "isip8", "ismip36", "ismip62", "issIP4", "iship8", "ismhip8", "isipp6", "isepnet", "iship6", "iship36", "issIPnet", "isid8", "isipp36", "isip62", "isep62", "isIP8", "ismhip6", "isp2", "isip3", "ismhip36", "isid4", "isop6", "isidnet", "issip6", "isipnet", "issIP8", "isop3", "iship62", "isid6", "issipnet", "isIP6"], "istcp": ["ditwp", "iftcp", "ortdp", "istcmp", "ISTcp", "ISTmp", "pectcp", "histp", "istmp", "ismcop", "iftcop", "istcop", "istpc", "ortcp", "ISTpc", "pectp", "pectpc", "ortpd", "ISTp", "histcp", "ditdp", "istwp", "iftcmp", "istpd", "ditpd", "histpd", "ismcmp", "ismcp", "histcop", "istdp", "ismmp", "pectcop", "histdp", "ISTcmp", "ISTcop", "istp", "ortwp", "histpc", "iftmp", "histwp", "ditcp"], "isudp": ["istsudps", "iswebp", "ismudp", "ismwebpc", "isldp", "isrodp", "istsugcp", "iswebpc", "isudpc", "isudpd", "istsudp", "ismwebp", "ismwebcp", "ismudpa", "isadp", "iuidp", "iudpt", "isldpd", "ismwebpa", "isldpt", "isugu", "isuvp", "isrodps", "isbugcp", "istsudu", "iudp", "iuidpt", "isuidpd", "isugps", "isuidp", "isbugpt", "isudpt", "iudcp", "isadpa", "ismudpc", "isuidu", "isugp", "isadpc", "isbugp", "istsugu", "isrodu", "isuvcp", "isugcp", "iuidcp", "isudpa", "ismudcp", "isrodcp", "isbugpd", "iswebcp", "isldcp", "istsugps", "isuvpc", "isuvpa", "isudcp", "isudu", "istsudcp", "istsugp", "iswebpa", "isadcp", "isuidpt", "iudpd", "isuidcp", "iuidpd", "isudps", "isuidps"], "data": ["d", "Data", "input", "image", "message", "batch", "id", "size", "aw", "no", "DATA", "value", "p", "text", "to", "n", "window", "result", "table", "dat", "m", "pos", "valid", "extra", "def", "pad", "mu", "ip", "output", "map", "block", "rew", "al", "buffer", "name", "a", " DATA", "str", "bin", "db", "val", "ata", "bytes", "in", "padding", "di", "done", "rel", " Data", "raw", "t", "area", "length"], "len": [" length", "ls", "total", "lp", "le", "l", "size", "L", "il", "z", "p", "limit", "n", "lic", "kl", "lim", "Len", "lf", "fin", "lit", "num", "pos", "valid", "lan", "ll", "cmp", "gen", "vec", "lon", "length", "end", "trans", " l", "err", "compl", "el", "en", "ln", "str", "enc", " el", "loc", "offset", "v", "val", "nt", "vol", "h", " clen", "resp", "wid", "elt", "t", "mem", "lang", "sp"]}}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n", "idx": 574, "substitutes": {"errp": ["rp", "rrP", "erP", "rrp", "errr", "rP", "err", "erp", "rps", "errP", "rrr", "rr", "errps", "erps", "rrps"], "list": ["batch", "ul", "List", "data", "ls", "parent", "lp", "l", "temp", "instance", "LIST", "p", "all", "limit", "dict", "record", "result", "lt", "out", "set", "table", "collection", "i", "part", "info", "new", "flat", "lock", "cont", "it", "found", "listed", "local", "block", "ist", "pl", "str", "print", "v", "null", "nt", "st", "lc", "t", "map"]}}
{"project": "FFmpeg", "commit_id": "ca488ad480360dfafcb5766f7bfbb567a0638979", "target": 1, "func": "static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,\n\n                         unsigned int c, const unsigned int *div_blocks,\n\n                         unsigned int *js_blocks)\n\n{\n\n    ALSSpecificConfig *sconf = &ctx->sconf;\n\n    unsigned int offset = 0;\n\n    unsigned int b;\n\n    ALSBlockData bd[2] = { { 0 } };\n\n\n\n    bd[0].ra_block         = ra_frame;\n\n    bd[0].const_block      = ctx->const_block;\n\n    bd[0].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[0].opt_order        = ctx->opt_order;\n\n    bd[0].store_prev_samples = ctx->store_prev_samples;\n\n    bd[0].use_ltp          = ctx->use_ltp;\n\n    bd[0].ltp_lag          = ctx->ltp_lag;\n\n    bd[0].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[0].quant_cof        = ctx->quant_cof[0];\n\n    bd[0].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[0].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[0].js_blocks        = *js_blocks;\n\n\n\n    bd[1].ra_block         = ra_frame;\n\n    bd[1].const_block      = ctx->const_block;\n\n    bd[1].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[1].opt_order        = ctx->opt_order;\n\n    bd[1].store_prev_samples = ctx->store_prev_samples;\n\n    bd[1].use_ltp          = ctx->use_ltp;\n\n    bd[1].ltp_lag          = ctx->ltp_lag;\n\n    bd[1].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[1].quant_cof        = ctx->quant_cof[0];\n\n    bd[1].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[1].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[1].js_blocks        = *(js_blocks + 1);\n\n\n\n    // decode all blocks\n\n    for (b = 0; b < ctx->num_blocks; b++) {\n\n        unsigned int s;\n\n\n\n        bd[0].block_length = div_blocks[b];\n\n        bd[1].block_length = div_blocks[b];\n\n\n\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n\n\n\n        bd[0].raw_other    = bd[1].raw_samples;\n\n        bd[1].raw_other    = bd[0].raw_samples;\n\n\n\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n\n            // damaged block, write zero for the rest of the frame\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n\n            return -1;\n\n        }\n\n\n\n        // reconstruct joint-stereo blocks\n\n        if (bd[0].js_blocks) {\n\n            if (bd[1].js_blocks)\n\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n\n\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n\n        } else if (bd[1].js_blocks) {\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n\n        }\n\n\n\n        offset  += div_blocks[b];\n\n        bd[0].ra_block = 0;\n\n        bd[1].ra_block = 0;\n\n    }\n\n\n\n    // store carryover raw samples,\n\n    // the others channel raw samples are stored by the calling function.\n\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n\n\n\n    return 0;\n\n}\n", "idx": 585, "substitutes": {"ctx": ["ka", "cp", "mom", "kb", "hw", "nil", "kl", "care", "req", "ctl", "conf", "cf", "context", "xp", "ann", "grad", "pkg", "wx", "handler", "Context", "ck", "resp", "timeout", "fn", "jac", "bc", "bh", "conv", "xs", "crit", "cb", "pause", "act", "something", "kt", "policy", "msg", "cmp", "pat", "xy", "setup", "gc", "apache", "loc", "animate", "cm", "mc", "std", "obj", "aux", "jp", "addr", "utils", "etc", "history", "kw", "dl", "that", "anc", "abc", " cx", "prefix", "cmd", "proc", "wcs", "today", "work", "func", "ppo", "xc", "conn", "ca", "txt", "cfg", "rect", "tx", "them", "config", "course", "px", "via", "ia", "cc", "ct", "iat", "asia", "tc"], "ra_frame": ["ra_channel", "raptlock", "ra_lock", "raptframe", "ra_shot", "ra___scene", "dra_frame", "RA_frames", "raptshot", "dra_shot", "ra_series", "ravelopframe", "dra_lock", "raveloplock", "ra_frames", "ra_scene", "ror_scene", "ra___frame", "ror_series", "ra___series", "RA_frame", "ror_channel", "ra___channel", "ravelopshot", "RA_block", "ra_block", "ror_frame"], "c": ["ec", "d", "fc", "l", "count", "bc", "unc", "p", "n", "dc", "r", "ci", "cb", "m", "C", "cache", "config", "e", "cs", "cut", "ct", "f", "rc", "lc", "ac", "t", "a"], "div_blocks": ["ra_images", "div___block", "div_frames", "div_images", "div___images", "div___blocks", "div___frames", "ra_blocks", "ra_frames", "ra_block", "div_block"], "js_blocks": ["obs_boxes", "js67boxes", "js___times", "js____block", "css___events", "qs_blocks", "js_jobs", "js_rows", "js_nos", "obs_rows", "qs_locks", "css___blocks", "qs_values", "css___times", "css_times", "js_Blocks", "bs_blocks", "js_maps", "jsThepages", "js67rows", "bs_nos", "js_events", "bs_guards", "obs_blocks", "js_boxes", "js__locks", "js_values", "bs_pages", "obs_maps", "js67maps", "bs_block", "jsTheblocks", "js__events", "js_guards", "qs_Blocks", "js___locks", "js____blocks", "js____guards", "jsTheblock", "js_block", "js___blocks", "js_pages", "js__blocks", "js__times", "jsThejobs", "css_events", "js67blocks", "js_times", "bs_jobs", "css___locks", "css_blocks", "js___events", "js____nos", "js_locks", "css_locks"], "sconf": ["sscon", "tsconf", "SConf", "scon", "Scfg", "Sconf", "tscfg", " sConf", "tsconfig", "ssconf", " scfg", "sscfg", "tsConf", "dscfg", "Sconfig", "ssconfig", "sconfig", "dsconfig", "sConf", "dscon", "dsconf", " sconfig", "scfg", "Scon"], "b": ["br", "d", "l", "nb", "mb", "buf", "eb", "bc", "bh", "p", "g", "ab", "bp", "cb", "rb", "m", "i", "x", "bar", "bb", "base", "y", "k", "bi", "buffer", "e", "bg", "ba", "db", "v", "B", "sb", "bf", "t", "a", "ib"], "bd": ["try", "aj", "kb", "py", "bind", "td", "bet", "bot", "off", "wd", "cond", "de", "bo", "BD", "pd", "sb", "fn", "ck", "back", "ld", "bel", "br", "d", "bc", "bh", "ds", "tab", "fl", "bs", "shell", "bro", "bg", "bn", "th", "cd", "dt", "but", "dd", "dc", "dat", "gd", "pad", "att", "dev", "bos", "hd", "bi", "dl", "ba", "db", "btn", "od", "di", "det", "bf", "da", "dis", "cmd", "dj", "no", "nd", "sh", "dash", "be", "md", "dh", "def", "bb", "js", "bt", "sd", "desc", "ben", "bl", "des"]}}
{"project": "qemu", "commit_id": "71b58b82dac1e1dc5e08a005a14bbcafecbd9e2a", "target": 0, "func": "static int write_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 599, "substitutes": {"argc": ["flaglc", "flagC", "argsz", " argC", "axw", "arglc", "argsl", "catw", "argumentl", " arglc", " argw", " argz", "argumentv", "argz", "axc", "axC", "argumentC", " argl", "flagc", "catl", "flagl", "argsc", "argl", "argumentz", "argumentlc", "catc", "axl", "argw", "argsv", "catC", "argC", "argumentc"], "argv": [" argp", " arg2", "argsV", "logc", "arpv", "arpp", "arkc", "argp", "regvs", "arp2", "logv", "argV", "regv", "argsp", "argm", "argsm", "argumentv", "argsvs", "argumentV", " argvin", "regc", " argm", "agV", "argsc", " argvs", "agc", "argvs", "arg2", "agv", "agm", "logvs", "argsvin", "arkv", "arpc", "args2", "arkvin", "argsv", "argvin", "argumentp", " argV", "argumentc", "regp"], "t1": [" t001", " t3", "T1", "int1", "v2", "t3", "int2", "T001", "int3", " t0", "v3", "t001", "t0", "T3", "T2", "v0", "v1", "T0", "int001"], "t2": ["time3", "time0", " t3", "T1", "time02", "t3", "t02", "T02", " t0", "t0", "T3", "T2", "T0", "time1", " t02", "time2"], "c": ["ec", "vc", "d", "cp", "cod", "cat", "fc", "cd", "l", "code", "pc", "bc", "unc", "z", "p", "g", "n", "dc", "cb", "i", "b", "ce", "C", "cont", "sc", "cache", "cur", "cmp", "ch", "k", "tc", "color", "cs", "con", "co", "cut", "gc", "v", "abc", "cc", "h", "ct", "col", "f", "rc", "lc", "ac", "t", "mc"], "cnt": ["ccount", "ecct", "Ccount", "Count", " ccount", "dcpt", "CNT", " cNT", "lcnt", "cpt", "ecnt", "dcnt", "acnt", "cant", "dcant", "lcount", "Cpt", "acount", "Cnt", "cct", "eccount", " cant", "acNT", "lcct", "dcct", " cpt", "acct", "dcNT", " cct", "acant", "account", "ecount", "dcount", "cNT", "Cant", "lcant", "Cct"], "buf": ["proc", "data", "br", "batch", "cp", "BU", "cat", "ff", "func", "tmp", "bc", "img", "ref", "result", "txt", "window", "box", "iter", "pb", "out", "cb", "rb", "bed", "var", "b", "seq", "cache", "cur", "vec", "bt", "cap", "block", "desc", "buffer", "cv", "err", "bag", "ctx", "pool", "ob", "str", "Buffer", "bin", "wb", "aka", "pkg", "fd", "queue", "nt", "rc", "Buff", "mem", "uf", "cmd", "buff"], "offset": ["bound", "id", "oid", "trace", "tmp", "op", "format", "handle", "p", "window", "order", "set", "path", "needed", "off", "zero", "time", "t", "buffer", "h", "f", "reset", "timeout", "inner", "key", "shift", "meta", "iterator", "at", "iso", "location", "end", "rot", "owner", "first", "loc", "range", "padding", "position", "online", "length", "total", "size", "offer", "addr", "slot", "style", "before", "slice", "seek", "ref", "index", "pointer", "part", "eta", "info", "entry", "pad", "error", "attribute", "office", "offs", "address", "flag", "point", "prefix", "top", "len", "et", "skip", "encrypted", "util", "pos", "start", "extra", "local", "area", "alias", "origin", "Offset", "store", "base"], "count": ["Count", "try", "match", "p", "n", "read", "iter", "sum", "page", "other", "found", "time", "buffer", "pattern", "cond", "currency", "group", "scroll", "batch", "q", "number", "message", "list", "result", "force", "num", "check", "name", "first", "depth", "nt", "max", "nb", "length", "not", "total", "cat", "size", "code", "z", "all", "child", "index", "counter", "part", "find", "info", "cache", "type", "call", "comment", "v", "process", "current", "more", "flag", "len", "cmd", "cycle", "add", "skip", "limit", "collection", "start", "cont", "amount", "parts", "coll", "now", "print", "ct", "ount", "latest", "base"], "optind": ["alternind", " optmind", "potind", "optInd", "optedwind", "optedind", "optimmind", "optreq", "opmind", "argmind", "varInd", "OptInd", " optwind", "potmind", "optedIND", "opindex", "optindex", "optimbind", "opInd", "argindex", " optIND", "optwind", "alternstart", "varindex", "optimind", "argind", " optInd", "optimreq", "optionInd", "alternIND", "arginn", "opsp", "varsp", " optstart", "optstart", "optinn", "optionbind", "alternreq", "optmind", "optIND", "opIND", "optimstart", "potwind", "optionindex", "optbind", "OptIND", "optsp", "optionind", "varind", "Optind", "opinn", "optedmind", "optimindex", "optimIND", "optionmind", "potIND", "optiminn", "argbind", " optreq", "optionsp", "opind"]}}
{"project": "FFmpeg", "commit_id": "56706ac0d5723cb549fec2602e798ab1bf6004cd", "target": 1, "func": "static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)\n\n{\n\n    int compno;\n\n    int x, y;\n\n    int *image_line;\n\n    int frame_index;\n\n    const int numcomps  = image->numcomps;\n\n    uint16_t *frame_ptr = (uint16_t *)frame->data[0];\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        if (image->comps[compno].w > frame->linesize[0] / numcomps) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error: frame's linesize is too small for the image\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        for (y = 0; y < avctx->height; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            frame_index = y * (frame->linesize[0] / 2) + compno;\n\n            for (x = 0; x < avctx->width; ++x) {\n\n                image_line[x] = frame_ptr[frame_index] >> 4;\n\n                frame_index += numcomps;\n\n            }\n\n            for (; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - 1];\n\n            }\n\n        }\n\n        for (; y < image->comps[compno].h; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            for (x = 0; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - image->comps[compno].w];\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 657, "substitutes": {"avctx": ["avconn", "ravjac", "devctx", "wavcmd", "afjp", "svcontext", "wavtx", " avjp", "avtx", "devcontext", "ravtx", "avjp", "wavjp", "exjp", "wavca", "wavconn", "avjac", "afctx", "navctx", "navcontext", "averconn", "devtx", " avtx", "exctx", "devjp", "wavctx", " avca", "avca", " avcontext", "navtx", "svjp", "avercmd", "exconn", "ravca", " avjac", "avcontext", "wavjac", "navjp", "afcontext", "excmd", "svctx", "ravctx", "avcmd", "averjp", "averctx", "svtx", "aftx"], "frame": ["data", "stack", "face", "frames", "trace", "list", "word", "code", "format", "flow", "view", "component", "style", "slice", "row", "window", "Frame", "sequence", "header", "close", "pixel", "force", "rame", "profile", "info", "picture", "scene", "iframe", "shot", "file", "block", "version", "buffer", "fr", "show", "video", "office", "function", "one", "framework", "range", "process", "f", "zone", "line", "reset", "point", "state", "base", "ime", "module", "feature"], "image": ["data", "age", "document", "message", "ma", "inner", "imgur", "size", "Image", "instance", "images", "format", "item", "code", "word", "view", "source", "operator", "p", "object", "img", "figure", "order", "photo", "import", "ami", "memory", "url", "audio", "m", "i", "page", "pixel", "info", " Image", "associated", "picture", "scene", "time", "xml", "http", "file", "entity", "version", "update", "archive", "buffer", "im", "ie", "attribute", "um", "video", "integer", "io", "remote", "print", "v", "value", "article", "media", "event", "model", "t", "ime", "module", "self"], "compno": ["biteno", "compnum", "comnone", "cmpname", "buffn", "comNO", "cmpdo", "cpnumber", "compnumber", "procNO", "comn", "comna", "cpn", "condpo", "compname", "ompnone", "procdo", "compn", "cmpmo", "ompNo", "expno", "componentno", "comdo", "ompna", "compdo", "ompnos", "cmpnet", "cpeno", "compmo", "omppo", "Compno", "compnos", "critko", "condno", "condNO", "ompn", "comnum", "compnet", "condnumber", "compNO", "expnum", "critNO", "bitn", "compnone", "cmpn", "bitnumber", "ompno", "cmpno", " compNO", " compyes", "condyes", "comname", "componentnone", "componentyes", " compnumber", "procpo", "exppo", "ompeno", "procnone", "comno", "ompname", "ompmo", "compeno", "cmpyes", "critno", "cpno", "comyes", "compko", "componentnumber", " compname", " compnos", "comeno", "buffno", "commo", "ompyes", "critpo", "cmppo", "CompNO", " compko", "crityes", "condnum", "compNo", "compo", " compnone", "bitno", "compna", "cpnet", "componentNO", "procnumber", "Compnos", " compna", "comko", "proceno", "comnumber", "comnet", "ompnumber", " compNo", " comppo", "cmpnone", "buffNO", "critnone", "compyes", "cmpna", " compn", "buffname", "CompNo", "cmpeno", "ompNO", "criteno", "componentna", "cmpnumber", "procno", "comppo", " compeno", "cmpNO", "expNO"], "x": ["c", "step", "height", "ext", "p", "only", "n", "dx", "path", "time", "lon", "xml", "xt", "xx", "xp", "rx", "ix", "wx", "h", "fx", "q", "key", "text", "xi", "any", "xs", "act", "m", "ox", "lat", "full", "ce", "check", "at", "ex", "xy", "xxx", "im", "cross", "X", "php", "l", "xxxx", "z", "index", "inx", "xa", "ax", "i", "xe", "history", "el", "en", "yx", "v", "on", "xes", "_", "add", "xc", "lex", "xf", "r", "mx", "tx", "content", "ux", "w", "e", "px", "dr", "xd", "ct"], "y": ["ny", "year", "ty", "uy", "axy", "c", "height", "p", "ley", "py", "n", "out", "yt", "yer", "ey", "k", "xx", "ies", "ry", "by", "ly", "sky", "h", "very", "my", "key", "yl", "iy", "row", "cy", "any", "m", "ady", "ya", "xy", "entity", "hey", "hy", "ys", "yet", "j", "z", "index", "ym", "aily", "i", "asy", "v", "col", "oy", "top", "sys", "hot", "ay", "wy", "gy", "sy", "b", "yn", "fy", "yr", "icy", "vy", "ch", "w", "Y", "yy", "o", "yd", "t", "ye", "yo"], "image_line": ["current_line", "inner_record", "image_____eline", "image_row", "picture2eline", "image_inline", "image_____line", "imageldline", "image2lin", "sequence_node", "sequence_row", "sequence_stroke", "img_lin", "image___node", "sequence_line", "image_liner", "imagelexliner", "current______lines", "image___stroke", "current______line", "sequence___stroke", "current______liner", "picture_line", "sequence___node", "image_eline", "image_ine", "image_node", "inner_lin", "image2eline", "current______link", "picture_lin", "inner_ine", "image______link", " image_node", "sequence___line", "imagelexloop", "picture_eline", "document_line", "img_line", "image_LINE", "current_link", "inner_line", "image______liner", "image_stroke", "document_loop", "image2line", "img_liner", " image_link", "imageldine", "img_node", "current_liner", "image_lines", "image______lines", "document_liner", "image_link", "document_link", "image______line", "image_loop", "imagelexline", "imagelexlink", "sequence_LINE", " image_inline", "sequence_lin", "current_lines", "image___line", "picture2lin", "imageldrecord", "imageldlin", "picture2line", "image_lin", "image_____lin", "image_record"], "frame_index": ["image_size", "frame2ind", " frame_sequence", "frame__offset", " frame_ind", "frame__ind", "image_offset", "image_index", "frame_offset", "frame___i", "frame2index", " frame_Index", "frame___point", "frame2size", "frame_ind", "frame2Index", "line_point", "line_index", "frame___Index", "frame___index", "line_i", "frame__size", "frame__index", "frame_sequence", " frame_size", "frame__Index", "frame_point", "frame_i", "image_Index", "frame_size", "frame_Index", "line_Index"], "frame_ptr": ["framePoptr", "framePoaddr", "frame_row", " frame_rep", " frame_row", "frame_rep", "frame_pointers", "frame_addr", "frame_pointer", " frame_pointers", "framePopointer", " frame_pointer", "framePorow", " frame_addr"]}}
{"project": "FFmpeg", "commit_id": "55815edca038997ec283569a192a3eca7f2143bc", "target": 0, "func": "static void build_feed_streams(void)\n\n{\n\n    FFStream *stream, *feed;\n\n    int i;\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (!stream->is_feed) {\n\n                /* we handle a stream coming from a feed */\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (stream->is_feed) {\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* create feed files if needed */\n\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n\n        int fd;\n\n\n\n        if (url_exist(feed->feed_filename)) {\n\n            /* See if it matches */\n\n            AVFormatContext *s;\n\n            int matches = 0;\n\n\n\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n\n                /* Now see if it matches */\n\n                if (s->nb_streams == feed->nb_streams) {\n\n                    matches = 1;\n\n                    for(i=0;i<s->nb_streams;i++) {\n\n                        AVStream *sf, *ss;\n\n                        sf = feed->streams[i];\n\n                        ss = s->streams[i];\n\n\n\n                        if (sf->index != ss->index ||\n\n                            sf->id != ss->id) {\n\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n\n                                   i, feed->feed_filename);\n\n                            matches = 0;\n\n                        } else {\n\n                            AVCodecContext *ccf, *ccs;\n\n\n\n                            ccf = sf->codec;\n\n                            ccs = ss->codec;\n\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                                if (CHECK_CODEC(time_base.den) ||\n\n                                    CHECK_CODEC(time_base.num) ||\n\n                                    CHECK_CODEC(width) ||\n\n                                    CHECK_CODEC(height)) {\n\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n                                if (CHECK_CODEC(sample_rate) ||\n\n                                    CHECK_CODEC(channels) ||\n\n                                    CHECK_CODEC(frame_size)) {\n\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else {\n\n                                http_log(\"Unknown codec type\\n\");\n\n                                matches = 0;\n\n                            }\n\n                        }\n\n                        if (!matches)\n\n                            break;\n\n                    }\n\n                } else\n\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n\n\n                av_close_input_file(s);\n\n            } else\n\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n\n                        feed->feed_filename);\n\n\n\n            if (!matches) {\n\n                if (feed->readonly) {\n\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n\n                        feed->feed_filename);\n\n                    exit(1);\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 666, "substitutes": {"stream": ["reader", "step", "port", "window", "read", "server", "ream", "iter", "path", "pod", "load", "form", "time", "version", "hook", "response", "spec", "console", "wrapper", "channel", "down", "scroll", "line", "socket", "roll", "message", "test", "list", "follow", "source", "pipe", "iterator", "row", "sequence", "link", "filter", "wind", "ready", "valid", "trans", "normal", "each", "remote", "range", "driver", "tr", "track", "sync", "length", "Stream", "chain", "host", "flow", "view", "seek", "sign", "sample", "lo", "send", "history", "network", "connection", "sw", "pool", "empty", "client", "loop", "draw", "present", "point", "ssl", "forward", "stack", "image", "mount", "instance", "through", "import", "hold", "table", "REAM", "start", "transform", "local", "flash", "post", "poll", "peer", "store", "stage", "clean"], "feed": ["ff", "format", "port", "read", "set", "look", "load", "form", "zero", "hub", "cf", "hook", "buffer", "context", "df", "cond", "github", "wait", "channel", "f", "socket", "push", "test", "follow", "next", "source", "iterator", "row", "service", "pause", "link", "filter", "submit", "full", "family", "tab", "valid", "check", "zip", "accept", "search", "and", "io", "range", "driver", "grow", "Feed", "length", "report", "json", "graph", "host", "flow", "style", "build", "index", "send", "parse", "find", "raft", "entry", "history", "fi", "update", "save", "insert", "fail", "low", "loop", "draw", "mail", "journal", "add", "limit", "drop", "import", "package", "label", "hold", "url", "table", "def", "delete", "transform", "config", "flash", "rss", "pop", "post", "connect", "good", "layout", "account", "control", "allow", "event", "raw", "join", "supp"], "i": ["id", "parent", "try", "c", "p", "init", "n", "ski", "ish", "li", "set", "x", "us", "associated", "k", "iu", "ti", "ind", "uri", "ix", "zi", "h", "ini", "f", "I", "batch", "q", "list", "xi", "ic", "qi", "m", "u", "ui", "it", "ims", "im", "name", "io", "remote", "PI", "\u0438", "ri", "json", "chain", "j", "ati", "l", "ii", "iri", "ji", "record", "to", "slice", "pi", "index", "me", "ci", "ei", "info", "phi", "entry", "ij", "history", "fi", "y", "bi", "hi", "v", "client", "mi", "di", "ai", "si", "point", "multi", "data", "ki", "status", "is", "sim", "g", "ami", "collection", "cli", "gi", "ip", "oi", "ie", "e", "o", "t"], "fd": ["bound", "d", "size", " f", " fid", "dates", "ci", "set", "fs", "form", "find", "new", " mismatch", "iff", "features", "ffff", "diff", "ptr", "err", "ms", "cond", "fe", "fr", "ists", "length", "sofar"], "s": ["ls", "S", "south", "stats", "c", "sv", "z", "es", "css", "g", "p", "service", "n", "sl", "ess", "set", "ds", "ses", "space", "b", "fs", "start", "sc", "series", "ps", "its", "js", "ns", "bs", "sw", "y", "sd", "sam", "ts", "spec", "sports", "sts", "rs", "v", "gs", "f", "source", "sb", "ats", "sq", "os", "socket", "se", "ssl", "self"], "sf": ["ils", "fx", "fw", "isf", "alf", "sh", "sv", "she", "ssl", "tif", "iffs", "xf", "sl", "SF", "xs", "sy", "lf", "fs", "ft", "sk", "sc", "fts", "tf", "fy", "ef", "fi", "sw", "sr", "cf", "sd", "rf", "utf", "sm", "hs", "orf", "src", "si", "f", "sb", "bf", "sq", "so", "esm", "sn", "se", "uf", "fo", "rn", "sp"], "ss": ["sys", "sis", "\u00df", "socket", "sv", "es", "css", "sl", "ass", "ess", "ses", "ds", "sy", "fs", "sc", "aws", "iss", "ps", "js", "bs", "ns", "sw", "pse", "sr", "sd", "rss", "cf", "ms", "oss", "cs", "ts", "hs", "rs", "ress", "hess", "si", "gs", "sb", "sn", "sq", "sol", "SS", "ys", "se", "ssl", "sp"], "ccf": ["cr", "cff", "ecv", "ecf", "ccb", "ecr", "cfc", "ckf", " ccb", " cced", "cb", " ccv", "ckt", " ccr", "cfed", "cked", "ckc", "cf", "cv", "cct", " cct", "ccv", "ccc", "cced", "ecb", "cft", "ccr", " ccc"], "ccs": ["cfos", " ccuts", "cks", "ckf", "ccfs", "ucuts", "occ", "ocf", "ckt", "ucs", "ucos", "rct", "ckc", " ccfs", " ccos", "ccuts", "cfs", "cct", "ucfs", "rcs", "ccc", "cfuts", "ocs", "cffs", "ccos", "rcf", "rcc"]}}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 669, "substitutes": {"env": ["ec", "usr", "et", "net", "rod", "er", "code", "addr", "ut", "tk", "ext", "conn", "org", "eh", "ev", "attr", "window", "vs", "hw", "server", "ah", "erb", "ner", "vt", "np", "cb", "environment", "rb", "esc", "nv", "nw", "msg", "qt", "dh", "vp", "tm", "req", "dev", "forge", "config", "shell", "end", "param", "vm", "disk", "cv", "e", "context", "en", "ctx", "ect", "pkg", "manager", "ew", "v", "uv", "site", "erd", "enter", "worker", "sb", "rc", "esm", "enc", "obj", "eng", "cmd", "era"], "intno": ["portno", "shortn", "indnum", "pointno", "intname", "internum", " intna", "intermo", "inmo", "interNo", "pointnos", "tNo", "inno", " intnumber", "interno", "portn", "innernos", "inteno", "pointnum", "intorno", "intn", "innerNo", "tnum", "interNO", "intern", "shortNo", "intnos", "shortno", " intorno", "inNo", "intnumber", "altNO", "INTNo", "inNO", " intNO", "intnum", "tnos", "interna", "internos", "pointorno", "tno", "innerNO", "intna", " inteno", "portNo", "altno", "indname", "pointna", "internumber", "pointeno", "pointnumber", "indNo", "indno", "altname", "altnos", "intername", "intNO", "innerno", "intmo", "INTeno", " intnum", "INTorno", "portnos", "shortnos", "INTno", "pointNo", " intNo", " intmo", " intname", "intNo", " intnos"], "is_int": ["isGint", " is_ind", "isGinternal", " is_bool", "is_bool", "is_ind", "is_str", "is_intel", " is_str", "isGstr", "is_inter", " is_internal", "is_integer", "isa_inter", "isa_integer", "isa_int", "is_id", "isa_str", " is_id", "is_internal", " is_intel", "isGind"], "error_code": ["error_codes", " error_type", " error_codes", "error_type"], "next_eip": ["next_peip", "next_eep", "next_peipp", "next_eipp", "next_aep", "next_ep", "next_aeipp", "next_seipp", "next_eeiph", "next_erIP", "next_eIP", "next_pep", "next_eriph", "next_seIP", "next_aeip", "next_eeipp", "next_seip", "next_aeIP", "next_peIP", "next_eiph", "next_erip", "next_eripp", "next_eeip", "next_eeIP", "next_seiph"], "is_hw": ["is2hw", "is2pkg", "is_hh", "is_ht", " is_ht", " is_fw", "is2hh", "is_pkg", " is_float", "is2ht", "is_fw", " is_hh", " is_pkg", "is_float"], "dt": ["mt", "d", "lp", "et", "tt", "tk", "dd", "tif", "dc", "txt", "ds", "td", "dat", "kt", "qt", "dh", "tm", "tp", "dq", "tz", "bt", "dm", "ctl", "dl", "dar", "ctx", "tn", "ect", "rt", "db", "ct", "dp", "iat", "elt", "t", "tc", "DT", "typ"], "ptr": ["fp", "mt", "br", "inst", "ctr", "usr", "eth", "lr", "jp", "shift", "arr", "addr", "ep", "handle", "next", "p", "dep", " addr", "attr", "ref", " pr", "r", "np", "bp", "iter", "pointers", "pointer", "rect", "inters", "deg", "coord", "Ptr", "pos", "cont", "cur", "req", "pad", "pr", " prot", "tp", "ij", "ctl", "xt", "prime", "ts", "fr", "ctx", "adr", "ind", "pt", "loc", " pointer", "dr", "address", "etr", "rel", "expr", "cmd", "tr", "t", "obj", "inter", "sp"], "type": ["day", "id", "Type", "ype", "ty", "test", "size", "op", "status", "code", "format", "count", "style", "p", "ico", "kind", "set", "relation", "family", "info", "pe", "cmp", "tp", "time", "like", "tag", "state", "error", "role", "name", "ver", "TYPE", "ror", "class", "types", "what", "range", "o", "ice", "unit", "t", "rule", "length", "ping", "typ"], "dpl": ["nmultipl", "cdfl", "dsmultipl", " dmultipl", "cpel", "pmultipl", "dfl", "rlp", "dPL", "pplug", "dpel", "rpl", "dplug", " dPL", "cdPL", "cfl", "dspl", "dopl", "dsopl", " dlp", "npl", "cdpl", "ppl", "dcplug", "dlp", "rmultipl", "dcpl", " dpel", "nfl", "cPL", "dmultipl", "dcmultipl", "dcopl", "popl", "dsplug", " dfl", "nlp", "cdpel", "rfl"], "selector": ["selectOR", "Selecter", " selecter", "SELECTor", "Selective", " Selectors", " Selection", " Selecter", "selection", "Selector", "SelectOR", " Selector", "lectOR", "electors", "selectors", "selecter", "election", " selection", "SELECTer", "electer", "lecter", " selectors", "lector", "elector", "selective", "SELECTive", "lective", "SELECTOR"], "cpl": ["ppp", "dfl", " cpp", "dPL", "upt", "cpt", "dcfl", "upal", "dcPL", " cpal", "cfl", " cfl", "ppl", "upl", "dcpr", "dpp", "pPL", "ppr", "pfl", "ufl", "dcpl", "cpal", "cpr", " cpt", "cPL", "dcpp", "dpt", "cpp", " cpr", "dpal"], "ist": ["fp", "oid", "wp", "lift", "list", "IST", "is", "ast", "ism", "tip", "isp", "dist", "set", "iste", "at", "sw", "ip", "xp", "ind", "ists", "osp", "reset", "st", "os", "store", "push", "asm", "sp"], "has_error_code": ["has_success_Code", "has_error_number", "has_error___error", "has_success_error", "has_success_code", "has_success_number", "has_error_codes", "has_error_error", "has_error_Code", "has_error___codes", "has_error___number", "has_error___code", "has_success_codes"], "new_stack": ["newlstack", "from_chain", "from_scope", "new_scope", "newlsp", "from_sp", "newlscope", "new_chain", "from_stack", "newlchain", "new_sp"], "e1": ["te1", "e6", " e6", "te4", "xe6", " e4", "te2", "ee3", "e7", " e7", "ee4", "ee7", "er1", "ee6", "xe1", "er5", "xe4", "E1", "ee1", "xe2", "E2", "e4", "E3", " e5", "er2", "er7", "e5", "ee5", "te3", "E4", "ee2"], "e2": ["te1", "e6", "ee02", "ec7", "ae3", "ec2", "ei3", "E5", "ae1", "er3", "te2", "ee3", "e7", "ec02", " e7", "ee4", "er4", "ee7", "er1", "ectwo", "er02", "ee6", "E02", "ertwo", "E1", "ee1", "ae2", "ei2", "E2", " e5", "E3", "e4", "er2", "ae6", "ei5", " etwo", "er7", "te6", "ei1", "e5", "ee5", "te3", " e02", "E4", "etwo", "ee2", "e02"], "e3": [" e30", "ce8", "E30", "t43", " e4", "E5", "ee3", "e7", "e43", " e7", "ee4", "t1", "t3", "e8", "t5", "t4", "ce2", "t30", "e30", "ee1", "e4", " e5", "E3", "ce3", "ee8", "t7", "ce5", " e43", "e5", "ee5", "E7", "ee43", " e8", "ee2"], "ss": ["sys", "status", "ssh", "sh", "css", "s", "ds", "sc", "iss", "esi", "ps", "bs", "sw", "rss", "oss", "ts", "rs", "osp", "si", "sb", "st", "sq", "os", "SS", "ssl", "ping", "sp"], "old_eip": ["old_eriu", "old_teep", "old_eri", "old_elim", "old_erim", "old_Eep", "old_aeip", "old_Eop", "old_eop", "old___erep", "old_seip", "old_erip", "old_erep", "old_aeap", "old___eiu", "old_eliu", "old___aeap", "old_eap", "old___aeep", "old_eiu", "old_eim", "old_aeep", "old_Eip", "old___eap", "old___eriu", "old_seap", "old_seop", "old_seep", "old_elip", "old_egiu", "old___erim", "old_egep", "old___eim", "old___eip", "old_sei", "old_teip", "old___aeip", "old___erip", "old_egip", "old_ei", "old___eep", "old_egim", "old_Ei", "old_teap", "old_elep", "old_eep", "old_erop"], "esp": ["fp", "lp", "et", "yp", "tmp", "jp", "er", "ep", "ext", "es", "bp", "isp", "ei", "vp", "esi", "ps", "tp", "ip", "err", "xp", "ap", "eps", "osp", "expr", "si", "reset", "resp", "rel", "sp"], "offset": ["fp", "oid", "op", "skip", "shift", "size", "addr", "next", "slot", "slice", "seek", "attr", "ref", "index", "pointer", "pos", "start", "off", "lock", "extra", "ip", "error", "origin", "Offset", "alt", "loc", "address", "scroll", "position", "ot", "timeout", "point", "sp"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n", "idx": 674, "substitutes": {"src": ["input", "inst", "ctr", "stack", "usr", "gin", "addr", "sh", "source", "sec", "pri", "slice", "img", "sup", "sl", "stock", "txt", "iter", "usc", "set", "inc", "ur", "start", "sc", "cur", "ack", "filename", "tp", "sur", "bs", "sub", "ser", "sr", "iv", "sw", "ptr", "ripp", "ipl", "comp", "bg", "rl", "dest", "ind", "rt", "ipp", "ix", "rs", "in", "rc", "sb", "st", "ins", "th", "sq", "sn", "seed", "scan", "sync", "supp"], "dst": ["fut", " dST", "dost", "pbl", "fst", "dhST", "ddST", "dx", "dsend", "dout", " dlt", "dot", "dsot", "debr", "deST", "idx", "idst", "dests", "pst", "dend", "dw", " dbl", " dw", "idw", "pw", "dbr", "dsst", "fdentry", "dST", " dnd", "ddst", "ddend", "ddot", "dhbr", "fdst", "dsts", "dbl", " dbr", " dsts", "fdbr", "dhentry", " dut", "px", " dx", "ddlt", "dest", "fnd", "dut", "dslt", "fot", " dot", "doot", "ddsts", "idbl", " dentry", "fdST", "dhst", "dentry", "dnd", "dlt", "ddbr", " dend", "dond"], "num_pixels": ["num_xpels", "num_meters", "num_npues", "num_pels", "num_npixels", "num_xpours", "num_Pixels", "num_peters", "num_pimens", "num_pours", "num_Pimens", "num_peix", "num_peimens", "num_npels", "num_ppues", "num_ppixels", "num_Peters", "num_xpixels", "num_npours", "num_pues", "num_ppours", "num_xpues", "num_mix", "num_Pix", "num_pix", "num_mixels", "num_peixels", "num_ppels", "num_peeters", "num_mimens"], "palette": ["alue", "alette", "calma", "calue", " palue", " palte", " palellow", "pma", "Palue", "palue", "callette", "alellow", "pette", " palma", "calettes", "Palte", "Palellow", "pallette", "plette", "pettes", "calet", "alet", "alte", "palet", "Palette", " pallette", "palma", "palte", "palellow", "alettes", " palet", " palettes", "palettes", "calette"], "i": ["id", "init", "li", "series", " ti", "iu", "ti", "ind", "uri", "ix", "zi", "ini", "I", "this", " bi", "list", " j", "xi", "ic", "qi", "m", "ui", "it", "ex", "gu", " index", "ims", "im", " p", "io", " err", "ri", "json", "chain", " wi", " m", "ii", " mi", "ji", "pi", "asi", "me", "index", "ci", "ei", "info", "ij", " ii", " pi", "bi", "hi", " I", "go", " ni", "mi", "di", "ai", "si", "point", "multi", "ki", "status", "is", "sim", "g", " di", "ami", "cli", "gi", "ip", "oi", "print", "uli", "in", " multi"]}}
{"project": "FFmpeg", "commit_id": "5cd8afee99c83b62e1474f122d947de7e4ad9ff5", "target": 0, "func": "static inline void codeblock(DiracContext *s, SubBand *b,\n\n                             GetBitContext *gb, DiracArith *c,\n\n                             int left, int right, int top, int bottom,\n\n                             int blockcnt_one, int is_arith)\n\n{\n\n    int x, y, zero_block;\n\n    int qoffset, qfactor;\n\n    IDWTELEM *buf;\n\n\n\n    /* check for any coded coefficients in this codeblock */\n\n    if (!blockcnt_one) {\n\n        if (is_arith)\n\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n\n        else\n\n            zero_block = get_bits1(gb);\n\n\n\n        if (zero_block)\n\n            return;\n\n    }\n\n\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n\n        if (is_arith)\n\n            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n\n        else\n\n            b->quant += dirac_get_se_golomb(gb);\n\n    }\n\n\n\n    b->quant = FFMIN(b->quant, MAX_QUANT);\n\n\n\n    qfactor = qscale_tab[b->quant];\n\n    /* TODO: context pointer? */\n\n    if (!s->num_refs)\n\n        qoffset = qoffset_intra_tab[b->quant];\n\n    else\n\n        qoffset = qoffset_inter_tab[b->quant];\n\n\n\n    buf = b->ibuf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n\n        for (x = left; x < right; x++) {\n\n            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */\n\n            if (is_arith)\n\n                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);\n\n            else\n\n                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);\n\n        }\n\n        buf += b->stride;\n\n    }\n\n}\n", "idx": 677, "substitutes": {"s": ["sys", "ls", "d", "S", "j", "stats", "is", "sh", "sets", "ss", "p", "sv", "settings", "n", "sl", "vs", "ses", "sa", "set", "ds", "sf", "i", "sc", "its", "js", "bs", "ns", "sw", "e", "cs", "ts", "spec", "sm", "hs", "sts", "rs", "v", "h", "gs", "f", "args", "st", "os", "t", "a", "se", "sp"], "b": ["br", "d", "bound", "j", "l", "mb", "eb", "ub", "bc", "bh", "bd", "bm", "p", "g", "n", "ab", "pb", "erb", "bp", "r", "cb", "lib", "rb", "em", "be", "i", "u", "lb", "it", "bar", "bb", "bt", "bs", "amb", "ed", "t", "ch", "bi", "buffer", "bis", "a", "bg", "ob", "wb", "emb", "ba", "db", "bo", "fb", "v", "display", "bl", "h", "o", "B", "ad", "f", "sb", "ac", "nb", "obj", "base", "ib", "buff"], "gb": ["gio", "mb", "ub", "rg", "vg", "eb", "bc", "tg", "sg", "bm", "kb", "py", "g", "erb", "pb", "gpu", "cfg", "cb", "rb", "yg", "csv", "gy", "ubs", "gd", "lb", "eg", "gt", "bb", "xy", "bs", "bt", "ch", "cv", "bg", "gc", "wb", "db", "fb", "GB", "gs", "sb", "cm", "bf", "gm", "gg", "nb", "gh"], "c": ["ec", "vc", "cp", "fc", "cr", "l", "pc", "xc", "bc", "cn", "p", "g", "dc", "ca", "r", "ci", "cb", "csv", "ce", "C", "cont", "sc", "cmp", "ch", "cf", "cv", "tc", "cs", "ctx", "con", "co", "abc", "cu", "cc", "ct", "f", "cm", "rc", "lc", "ac", "t", "mc", "a", "ctrl"], "top": ["j", "parent", "min", "ty", "tmp", "op", "hot", "height", "Top", "north", "slot", "p", "to", "my", "upper", "tip", "localhost", "table", "below", "lat", "num", "above", "bot", "start", "pos", "at", "title", "tp", "toc", "local", "hop", "best", "lower", "origin", "first", "pt", "offset", "target", "client", "sp", "tops", "root", "TOP", "ot", "t"], "bottom": ["total", "south", "tight", "mb", "height", "gravity", "org", "row", "upper", "my", "window", "boost", "bott", "box", "yt", "where", "below", "above", "bot", "off", "Bottom", "zero", "boot", "odd", "base", "board", "level", " Bottom", "origin", "bo", "radius", "offset", "body", "last", "blue", "bill", "loop", "root", "zone", "mobile", "back"], "blockcnt_one": ["blockcnt_One", "blockcount_1", "blockcount_two", "blockcnt_many", "blockcnt_two", "blockcnt_zero", "blockcnt_1", "blockcount_one", "blockcount_One", "blockcount_zero", "blockcount_many"], "is_arith": ["isplacearith", "is_iritch", "is_aritch", "is_drith", "is_darithmetic", "is_arth", "is_irhs", "isplacearich", "is_rich", "is_arITH", "is_arhs", "is_rth", "is_drITH", "isplacedarith", "is_dritch", "is_urich", "is_irth", "isplacearithmetic", "is_erth", "is_eroch", "is_darich", "is_drhs", "is_eract", "is_arich", "is_karith", "is_urth", "is_karITH", "isplacedarithmetic", "is_uract", "is_carich", "is_iract", "is_arcith", "is_aroch", "is_arcth", "is_aract", "is_darth", "is_arcact", "is_iroch", "is_irITH", "is_caract", "is_carith", "is_karhs", "isplacearth", "is_carth", "is_irith", "is_alth", "is_alithmetic", "is_erich", "is_rith", "is_arithmetic", "is_darith", "is_alich", "is_urith", "is_alith", "is_rithmetic", "is_arcoch", "isplacedarich", "is_karitch", "is_erith", "isplacedarth"], "x": ["j", "d", "fx", "ty", "key", "l", "op", "xc", "z", "p", "g", "n", "dx", "xf", "xi", "cy", "index", "lex", "xs", "inx", "xa", "ax", "m", "ox", "i", "lat", "u", "tx", "mx", "ex", "xy", "xml", "k", "ch", "ux", "w", "xt", "xx", "xp", "el", "xxx", "e", "px", "rx", "row", "yx", "ix", "ry", "v", "cross", "xd", "wx", "h", "ick", "ice", "f", "xes", "t", "X"], "y": ["j", "year", "ty", "uy", "et", "axy", "hot", "yl", "ay", "z", "iy", "py", "ery", "cy", "wy", "ym", "yt", "gy", "sy", "ady", "i", "ya", "yn", "yer", "fy", "ey", "yr", "icy", "xy", "vy", "t", "dy", "ch", "kit", "asy", "ies", "Y", "pt", "yx", "ry", "v", "yy", "ly", "sky", "h", "ot", "oy", "ys", "ny", "ye", "my", "ble"], "zero_block": ["positive_block", "positive_bit", "positive_box", "zero_line", "zero67lock", "zeroablebit", "Zero_run", " zero_cap", "zero67run", "zero67cap", "zeroablelock", "zero_group", "zero_bit", "Zero_block", "zero67chain", "zero_sync", "positive_lock", "zeroablebox", "zero67group", "zero_lock", " zero_bit", "zero_cap", "zero67line", " zero_chain", "zero_box", " zero_group", "Zero_lock", "zero_run", "Zero_line", "zeroableblock", "zero67block", " zero_sync", "zero_chain"], "qoffset": ["ueerror", "qualtrace", " qpad", "queryoffset", "quslot", "qslot", "qqstart", "qpoint", "Qarea", "ueoffset", "Qaddr", "qualslot", " qoff", " qslot", "qutrace", "qqurl", " qerror", "qqset", "ckaddr", "qurl", " qset", "qset", "qustart", "qualset", "queryoff", "qualoffset", "quset", "qqoff", " qurl", "qupoint", "qualpoint", " qtrace", "dqstart", " qstart", "ueurl", "qoff", "qaddr", "qualstart", "queryset", "qstart", "quoffset", "qtrace", "qpad", "querystart", "qqoffset", " qpoint", "dqarea", "dqoffset", "qqerror", "ckarea", "Qoffset", "Qstart", "ckoffset", "ckstart", "uepad", "qerror", "qarea", "dqaddr", "qqpad"], "qfactor": ["qclass", " qterm", "sqactor", "zterm", "eqfactor", "eqactor", "sqprocessor", "sqoffset", "aqterm", "queryactor", "qqfactor", "qqrate", " qoperator", "qfloor", "queryprocessor", "eqfloor", "qqfloor", " qactor", "eqterm", " qclass", "queryfactor", "dqactor", "aqoffset", " qrate", "sqclass", "dqterm", "qterm", "qoperator", "aqactor", " qfloor", "qactor", "aqfactor", "sqterm", "eqoffset", "zfactor", "sqfactor", "dqfactor", "eqoperator", "eqrate", "zclass", "qqoperator", "eqprocessor", "dqoffset", "qprocessor", "zactor", "qrate", "queryoffset"], "buf": ["batch", "data", "br", "BU", "xff", "ff", "ctr", "tmp", "mb", "port", "limit", "conv", "img", "window", "read", "pb", "ref", "box", "result", "broad", "np", "out", "iter", "cb", "rb", "pack", "msg", "tab", "off", "cache", "def", "bar", "cur", "vec", "end", "block", "cap", "buffer", "cv", "cast", "err", "cam", "um", "ctx", "pool", "home", "pkg", "Buffer", "emb", "now", "wb", " vec", "queue", "fb", "bn", "raw", "Buff", "keep", "mem", "uf", "cmd", "buff"]}}
{"project": "FFmpeg", "commit_id": "d58a6d8537a6f34941973c5c3be93d484a4d62ed", "target": 1, "func": "static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n\n    FFV1Context *f = avctx->priv_data;\n\n    CABACContext * const c= &f->c;\n\n    AVFrame *pict = data;\n\n    const int width= f->width;\n\n    const int height= f->height;\n\n    AVFrame * const p= &f->picture;\n\n    int used_count= 0;\n\n\n\n    if(avctx->strict_std_compliance >= 0){\n\n        av_log(avctx, AV_LOG_ERROR, \"this codec is under development, files encoded with it wont be decodeable with future versions!!!\\n\"\n\n               \"use vstrict=-1 to use it anyway\\n\");\n\n        return -1;\n\n    }\n\n        \n\n    ff_init_cabac_encoder(c, buf, buf_size);\n\n    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);\n\n    c->lps_state[2] = 1;\n\n    c->lps_state[3] = 0;\n\n    \n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    \n\n    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){\n\n        put_cabac_bypass(c, 1);\n\n        p->key_frame= 1;\n\n        write_header(f);\n\n        clear_state(f);\n\n    }else{\n\n        put_cabac_bypass(c, 0);\n\n        p->key_frame= 0;\n\n    }\n\n\n\n    if(!f->ac){\n\n        used_count += put_cabac_terminate(c, 1);\n\n//printf(\"pos=%d\\n\", used_count);\n\n        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);\n\n    }\n\n    \n\n    if(f->colorspace==0){\n\n        const int chroma_width = -((-width )>>f->chroma_h_shift);\n\n        const int chroma_height= -((-height)>>f->chroma_v_shift);\n\n\n\n        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);\n\n\n\n        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);\n\n        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);\n\n    }else{\n\n        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);\n\n    }\n\n    emms_c();\n\n    \n\n    f->picture_number++;\n\n\n\n    if(f->ac){\n\n        return put_cabac_terminate(c, 1);\n\n    }else{\n\n        flush_put_bits(&f->pb); //nicer padding FIXME\n\n        return used_count + (put_bits_count(&f->pb)+7)/8;\n\n    }\n\n}\n", "idx": 683, "substitutes": {"avctx": ["AVcontext", "averpkg", "cvcmd", "avesys", "AVcv", "avectx", "avconf", "avsys", "wavtx", " savctx", "avtx", "avercfg", "cvjac", "ovctx", "avercontext", " savbc", "avjac", "aveconf", "ovjac", " avcfg", "avertx", "abxc", "avejac", "averbc", "averxc", "savcontext", "abcontext", "avercv", "avetx", " avcv", "abctx", "avbc", "ovcmd", " avtx", "wavctx", "savpkg", " avpkg", " savcontext", " avcontext", "AVtx", "wavcontext", "AVctx", "abjac", "cvconf", "averjac", " avjac", "avcv", "avcontext", "wavsys", "avpkg", "savcfg", "avecontext", "ovconf", "avecmd", "avcfg", "savctx", " savjac", " avbc", "avxc", "avcmd", " avsys", "averctx", " avxc", "cvctx"], "buf": ["batch", "br", "BU", "xff", "tmp", "mb", "bc", "bh", "limit", "text", "img", "window", "ref", "txt", "box", "bp", "cb", "rb", "b", "pos", "cache", "cur", "bar", "pad", "vec", "bs", "block", "cap", "buffer", "cv", "w", "err", "ctx", "len", "wb", "bin", "Buffer", "db", "queue", "fb", "bytes", "bf", "raw", "mem", "uf", "cmd", "buff"], "buf_size": ["buf_max", "bufablelength", " buf_state", "buflenSIZE", "bufablenumber", " buf2max", "uf_number", "uf_SIZE", " buf2SIZE", "buf_SIZE", "bufbufsize", "bufbufmax", " buf_max", "buf2state", "bufablesize", "uf_address", "buf_address", " buf2state", "buf_number", " buf_SIZE", "uf_length", "buf_state", "bufbufSIZE", "buf2max", "buflensize", "bufableSIZE", "buf_length", "buf2size", "buf2SIZE", "buflenaddress", "buflenlength", "bufbufstate", "uf_size", " buf2size"], "data": ["image", "Data", "d", "batch", "values", "message", "device", "list", "value", "DATA", "format", "code", "next", "actions", "text", "init", "window", "ref", "r", "box", "sequence", "table", "dat", "params", "form", "info", "new", "flat", "cache", "picture", "def", "intel", "snap", "pad", "extra", "xy", "mu", "state", "board", "block", "rew", "buffer", "w", "area", "points", "video", " DATA", "str", "first", "bin", "array", "what", "empty", "ata", "bytes", "frame", "media", "png", "button", "raw", "da", "rel", "obj", "a", "json"], "f": ["ff", "fa", "fu", "sf", "out", "fg", "lf", "form", "foreign", "ef", "conf", "cf", "rf", "df", "F", "h", "fd", "fp", "ec", "d", "fx", "fw", "q", "far", "m", "full", "u", "fl", "file", "um", "uf", "j", "l", "flow", "z", "inf", "fac", "fax", "i", "info", "tf", "fi", "y", "fe", "fr", "ctx", "fb", "v", "mac", "bf", "of", "fm", "fc", "fort", "g", "xf", "r", "util", "fab", "b", "ft", "fs", "def", "w", "e", "o", "fen", "t", "feat", "fo"], "c": ["ec", "cp", "fc", "l", "pc", "xc", "bc", "nc", "unc", "conv", "g", "n", "dc", "cus", "uc", "ca", "r", "fac", "ic", "ci", "lib", "m", "com", "i", "b", "u", "ce", "C", "cont", "cache", "etc", "cmp", "conf", "ch", "cf", "cam", "e", "tc", "cv", "cs", "ctx", "con", "co", "gc", "coll", "v", "abc", "cu", "cc", "h", "ct", "icc", "cm", "rc", "lc", "ac", "t", "mc", "a", "chain"], "pict": ["pres", "fc", "stat", "conv", "img", "P", "fac", "txt", "fig", "np", "util", "act", "phy", "kt", "pen", "picture", "vp", "pai", "pr", "fl", "Pict", "fi", "conf", "ch", "cam", "Pic", "ctx", "pl", "pas", "pt", "cu", "h", "ct", "capt", "fen", "pic", "fn", "feat", "ht"], "p": ["fp", "proc", "cp", "public", "parent", "lp", "wp", "l", "op", "jp", "ph", "pc", "py", "n", "P", "pb", "pi", "np", "app", "bp", "pp", "mp", "progress", "m", "i", "b", "u", "part", "policy", "picture", "it", "vp", "at", "att", "pr", "ps", "tp", "ip", "perm", "local", "pa", "ap", "pkg", "pt", "post", "v", "per", "pre", "sp", "h", "o", "dp", "pic", "resp", "par", "rep", "t", "a", "ping", "pro"], "picture_number": ["photo_no", "photo_type", "photo_number", "picture_type", "picture_no", "picture_num", "photo_num"]}}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n", "idx": 686, "substitutes": {"ret": ["mt", "RET", "q", "vector", "tmp", "match", "jp", "quad", "ext", "port", " RET", "fun", "g", "result", "ref", "r", "lt", "deg", "iter", "vt", "out", "res", "secondary", "bit", "lit", "ft", "red", "gt", "ll", " fut", "prot", "Ret", "opt", "final", "rot", "desc", "prime", "rt", "alt", "ter", "re", "reg", "print", "rev", "v", "val", "rets", "rm", "nt", "ry", "expr", "cmd", "arg", "tr", "rem", "reset", "reflect", "repl", "det", "t", "obj", "rep", "flag", "elt", "inter", "ld"]}}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707, "substitutes": {"opaque": ["opaco", "OPque", "popaco", "oraque", "popaques", "oroch", "popaque", "oraques", " opque", "oraco", "compaque", "popque", "popoch", "OPaque", "OPaques", "compoch", "opacity", "compaques", " opaques", "compaco", "opque", "popacity", "opoch", "opaques", "OPacity", " opacity"], "ret": ["success", "mt", "RET", "status", "count", "ext", "ent", "fun", "result", "ref", "after", "lt", "iter", "tree", "out", "set", "res", "fin", "lit", "ft", "red", "cont", "gt", "def", "tf", "Ret", " Ret", "tail", "rot", "desc", "err", "ts", "rev", "rt", "alt", "ter", "re", "val", "arg", "rets", "nt", "hash", "det", "rem", "flag", "reset", "resp", "tr", "elt", "t", "mem", "cmd"], "offset": ["fp", "mt", "data", "oid", "et", "l", "size", "op", "shift", "offer", "addr", "next", "slot", "p", "z", "seek", "row", "ref", "index", "onet", "util", "order", "pointer", "out", "set", "align", "ft", "pos", "start", "off", "at", "iso", "location", "length", "end", "block", "rot", "error", "buffer", " offsets", "origin", "ob", "Offset", "alt", "address", "o", "f", "reset", "sp"], "len": ["ls", "l", "size", "il", "nl", "term", "all", "fun", "n", "ref", "lt", "lim", "Len", "lib", "lf", "ail", "fin", "res", "lit", "pos", "seq", "lan", "ll", "syn", "fl", "lon", "length", "vec", "trans", "err", "el", "en", "mult", "ln", "alt", "rev", "val", "bytes", "nt", "h", "lis", "resp", "elt", "t", "sp"], "acb": ["sacbar", "racmb", "accob", "iacwb", " acba", "acv", "iacab", "sacnb", "Acv", "ancgb", "aconby", "aconbe", "acsb", "iacbd", "acr", " acsb", "aclab", "aclb", "accv", "accsb", "aconp", "acgb", " cacba", "aclob", "aclw", "iacbb", "accg", " acl", "acba", "acwb", " cacnb", "accd", "pacc", "acbp", "jacbe", " cacb", "acrb", "accnb", " acr", " acc", "acobj", "accx", " acwb", "aclba", "acl", "iacnb", "acg", "sacb", " acch", "iacob", "acla", "acbd", "acbol", "accb", "aconb", "acf", "ocb", " acbe", "accbb", "acw", "aclsb", " acnb", "accab", "pacnb", "accmb", "pacbd", "acmb", "accp", "iacf", "acx", " acw", " acbol", "aconbar", "ocr", "acd", "aclnb", "pacp", "pacr", "Acd", "aca", "aclbb", "acc", " cacbb", " acobj", "iacbe", "aclrb", "iacp", "aclp", " acbb", "aclbol", "ancnb", "ancb", "acona", "iacsb", "accl", "acch", "sacbb", "aclc", "pacg", "pacbb", "jacby", "aconf", "acbar", "acbe", "accch", "aconw", "iacgb", "jacb", "aclr", "aconnb", "accc", "iacobj", "acnb", "pacgb", "acabd", "aclf", " acrb", "aconrb", "aconx", "actbar", "acca", "ancwb", "sacby", "aclmb", "aconl", "iacbi", "jacbb", "acby", " acbd", "acabar", "accba", "aconbol", "aclwb", "Acr", "actbd", "ocd", "accbp", "jacbar", "aconbp", "acab", "actnb", "accr", "sacba", "pacbp", "acbi", "aclch", "pacb", "racnb", " aca", "Acb", " acp", "acob", "acong", "aclbi", "aclbp", "racbp", "acbb", "racb", "iacbar", "aconbi", "jacnb", "actb", "ocv", "acp", "iacx", "jacr", "aclbe", "acanb", "pacwb", "iacb", "accf", "pacobj"], "s": ["sys", "ls", "S", "stats", "c", "is", "sv", "ss", "p", "es", "g", "sl", "r", "ashes", "ds", "i", "b", "space", "locks", "fs", "ubs", "less", "us", "ps", "its", "js", "ns", "w", "ms", "sam", "cs", "ts", "ains", "sts", "rs", "h", "bits", "gs", "sb", "ats", "ins", "os", "sq", "states", "t", "acs"], "bs": ["sys", "ls", "br", "outs", "bc", "bh", "bd", "bm", "css", "vs", "bp", "cb", "ds", "b", "locks", "fs", "ubs", "lbs", "BS", "lb", "aws", "obs", "ps", "its", "bb", "js", "bos", "aos", "bt", "ns", "bi", "bis", "irms", "cs", "ts", "ba", "bes", "bps", "ks", "hs", "rs", "vers", "blocks", "bytes", "bl", "bits", "gs", "bas", "sb", "ats", "os", "aus", "acs"]}}
{"project": "qemu", "commit_id": "b6c147622d31272f9728da9ec16d146bf8c45a74", "target": 1, "func": "int qcow2_update_header(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowHeader *header;\n\n    char *buf;\n\n    size_t buflen = s->cluster_size;\n\n    int ret;\n\n    uint64_t total_size;\n\n    uint32_t refcount_table_clusters;\n\n    size_t header_length;\n\n    Qcow2UnknownHeaderExtension *uext;\n\n\n\n    buf = qemu_blockalign(bs, buflen);\n\n\n\n    /* Header structure */\n\n    header = (QCowHeader*) buf;\n\n\n\n    if (buflen < sizeof(*header)) {\n\n        ret = -ENOSPC;\n\n        goto fail;\n\n    }\n\n\n\n    header_length = sizeof(*header) + s->unknown_header_fields_size;\n\n    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);\n\n\n\n    *header = (QCowHeader) {\n\n        /* Version 2 fields */\n\n        .magic                  = cpu_to_be32(QCOW_MAGIC),\n\n        .version                = cpu_to_be32(s->qcow_version),\n\n        .backing_file_offset    = 0,\n\n        .backing_file_size      = 0,\n\n        .cluster_bits           = cpu_to_be32(s->cluster_bits),\n\n        .size                   = cpu_to_be64(total_size),\n\n        .crypt_method           = cpu_to_be32(s->crypt_method_header),\n\n        .l1_size                = cpu_to_be32(s->l1_size),\n\n        .l1_table_offset        = cpu_to_be64(s->l1_table_offset),\n\n        .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),\n\n        .refcount_table_clusters = cpu_to_be32(refcount_table_clusters),\n\n        .nb_snapshots           = cpu_to_be32(s->nb_snapshots),\n\n        .snapshots_offset       = cpu_to_be64(s->snapshots_offset),\n\n\n\n        /* Version 3 fields */\n\n        .incompatible_features  = cpu_to_be64(s->incompatible_features),\n\n        .compatible_features    = cpu_to_be64(s->compatible_features),\n\n        .autoclear_features     = cpu_to_be64(s->autoclear_features),\n\n        .refcount_order         = cpu_to_be32(3 + REFCOUNT_SHIFT),\n\n        .header_length          = cpu_to_be32(header_length),\n\n    };\n\n\n\n    /* For older versions, write a shorter header */\n\n    switch (s->qcow_version) {\n\n    case 2:\n\n        ret = offsetof(QCowHeader, incompatible_features);\n\n        break;\n\n    case 3:\n\n        ret = sizeof(*header);\n\n        break;\n\n    default:\n\n        return -EINVAL;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n    memset(buf, 0, buflen);\n\n\n\n    /* Preserve any unknown field in the header */\n\n    if (s->unknown_header_fields_size) {\n\n        if (buflen < s->unknown_header_fields_size) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n\n        buf += s->unknown_header_fields_size;\n\n        buflen -= s->unknown_header_fields_size;\n\n    }\n\n\n\n    /* Backing file format header extension */\n\n    if (*bs->backing_format) {\n\n        ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n\n                             bs->backing_format, strlen(bs->backing_format),\n\n                             buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* Feature table */\n\n    Qcow2Feature features[] = {\n\n        /* no feature defined yet */\n\n    };\n\n\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n\n                         features, sizeof(features), buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Keep unknown header extensions */\n\n    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {\n\n        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* End of header extensions */\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Backing file name */\n\n    if (*bs->backing_file) {\n\n        size_t backing_file_len = strlen(bs->backing_file);\n\n\n\n        if (buflen < backing_file_len) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        strncpy(buf, bs->backing_file, buflen);\n\n\n\n        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));\n\n        header->backing_file_size   = cpu_to_be32(backing_file_len);\n\n    }\n\n\n\n    /* Write the new header */\n\n    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(header);\n\n    return ret;\n\n}\n", "idx": 710, "substitutes": {"bs": ["ls", "outs", "bc", "bh", "ss", "bm", "als", "vs", "bp", "bles", "ses", "ds", "b", "ubs", "fs", "lbs", "BS", "obs", "ps", "its", "bos", "js", "aos", "ns", "bis", "fps", "cs", "ts", "bes", "hs", "bps", "hz", "rs", "bl", "bits", "gs", "sb", "ats", "os", "aus", "ubis"], "s": ["ls", "p", "es", "ses", "ashes", "params", "series", "its", "http", "cs", "spec", "into", "h", "gs", "sb", "args", "os", "stats", "sv", "settings", "vs", "details", "xs", "ds", "qs", "less", "ims", "bis", "sam", "hs", "sts", "ins", "states", "sq", "sn", "j", "S", "ss", "als", "sl", "comm", "ust", "ns", "y", "ms", "ts", "changes", "results", "of", "_", "sys", "steps", "func", "is", "big", "g", "times", "b", "fs", "cont", "aws", "def", "ps", "parts", "js", "impl", "as", "rs", "bits", "ats", "t", "obj"], "header": ["data", "parent", "document", "head", "key", "holder", "section", "list", "shift", "status", "format", "column", "er", "layer", "port", "term", "row", "window", "pillar", "index", "tree", "table", "memory", "var", "relation", "policy", "profile", "cache", "HEAD", "module", "history", "title", "token", "tag", "tar", "map", "block", "version", "metadata", "comment", "buffer", "Header", "headers", "name", "bo", "member", "dr", "queue", "frame", "hash", "h", "padding", "wrapper", "field", "event", "channel", "handler", "heading", "tr", "master", "cmd"], "buf": ["br", "data", "alloc", "uffer", "tmp", "bc", "bh", "conv", "img", "window", "ref", "pb", "read", "box", "cb", "rb", "late", "b", "pack", "cache", "vec", "uf", "block", "cap", "cf", "buffer", "cv", "foo", "copy", "pool", "ob", "Buffer", "bin", "queue", "utter", "bytes", "bl", "h", "rc", "raw", "Buff", "t", "mem", "map", "cmd", "buff"], "ret": ["mt", "RET", "status", "Return", "result", "ref", "r", "deg", "out", "res", "lit", "ft", "red", "gt", "def", "Ret", " Ret", "err", "alt", "re", "rev", "rt", "reg", "val", "rm", "rets", "nt", "rem", "reset", "flag", "resp", "tr", "elt", "t", "len"], "total_size": [" total_ize", "total67des", "total__Size", "general67des", " total_bytes", "Total_size", "totaledsize", "totalTimestate", " total_Size", "general_position", "totaledSIZE", "total12address", "general67SIZE", "total_SIZE", "general_des", "total12size", "general_size", "Total_address", "total_bytes", "total__bytes", "totalTimesize", "total_state", "total67position", "totaleddes", "total67size", "total__ize", "total_position", "totalTimeaddress", "total12Size", "totalTimeSize", "general67position", "general67size", "total_address", "total67SIZE", "Total_Size", "general_SIZE", "total_Size", "total_des", "total__size", "Total_state", "totaledposition", "total_ize", "total12state"], "refcount_table_clusters": ["refcount_table_glroups", "refcount_table_plroups", "refcount_table_Clusters", "refcount_table_lodes", "refcount_table_Cluster", "refcount_table_plusters", "refcount_table_colodes", "refcount_table_lroups", "refcount_table_cluster", "refcount_table_clients", "refcount_table_coluster", "refcount_table_colroups", "refcount_table_glients", "refcount_table_pluster", "refcount_table_gluster", "refcount_table_clodes", "refcount_table_glodes", "refcount_table_plients", "refcount_table_glusters", "refcount_table_Clients", "refcount_table_colusters", "refcount_table_colients", "refcount_table_lusters", "refcount_table_clroups"], "header_length": [" header_len", "Header_length", "Header_size", "header_len", "Header_width", "header_width", "header_size", "Header_len", " header_size"], "uext": ["UEv", "gev", "ueXT", "UExt", "ubeext", "geext", "UEXT", "uev", "ueext", "gext", "ubeXT", "UEext", "ubev", "geXT", "ubext"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n", "idx": 729, "substitutes": {"host_port": [" host_host", "host_ip", " host_ports", "host_host", " host_PORT", " host_ip", "host_PORT", "host_ports"], "errp": ["rrping", " errping", "derp", " errm", "erpe", "rrp", "erm", " errP", "derm", " errr", "rrP", " errps", "erP", "err", "erp", "errps", "errping", "errm", "erps", "rrps", "derpe", "errpe", "errr", " errpe", "derr", "errP", "erping"], "s": ["ls", "d", "S", " es", "south", "stats", "l", "c", "is", "sv", "ss", "p", "z", "es", "n", "sl", "r", " sets", " parts", "set", "ds", "ips", " ss", "m", "i", "space", "b", " ts", "fs", "less", "su", "tes", "ps", " rs", "js", "ns", "its", " a", " fs", "w", " gets", "fps", "span", "ts", "spec", "e", " inputs", " S", "sts", "rs", "v", "ares", "h", "gs", "f", "ats", "sb", "sq", "os", "t", "socket", "a", " samples", "sp"]}}
{"project": "qemu", "commit_id": "d049bde69d8ab3dfa4edeee48896088ae9feb693", "target": 1, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);\n\n    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);\n\n    uint32_t max_msi, max_msix;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\", ccode));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\",\n\n                            pci_find_device_name((ccode >> 16) & 0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 740, "substitutes": {"dev": ["doc", "proc", "sys", " device", "env", "device", "test", "usb", "adv", "handle", "conn", "ev", "hw", "window", "pi", "server", "app", "any", "debug", "prom", "devices", "var", "phy", "develop", "serial", "info", "md", "valid", "def", "priv", "req", "mem", "pad", "local", "sd", "normal", "cam", "w", "stick", "ver", "Device", "spec", "home", "die", "de", "go", "DEV", "db", "tech", "project", "v", "school", "range", "nt", "hid", "di", " Dev", "driver", "ad", "det", "ve", "scan", "av", "tr", "development", "des", "Dev", "obj", "serv", "cmd", "pro"], "fdt": ["dirtd", "fdm", "rodk", "FDlist", "flwt", "FDtt", "fdT", "inedt", "fredts", "ardout", "dedt", "inedwt", "FDp", "dirts", "condT", "dedts", "fifm", "hdt", "fdlist", "udwt", "dbk", "dbts", "dlwt", "ardtt", "inedlist", "rody", "FDout", "fdts", "fedt", "fdl", "dlout", "fft", "pedt", "fedk", "dirt", "fedT", "fcout", "pedwt", "dirm", "fct", "fdy", "fiftd", "ffp", "fifwt", "rodT", "fcm", "fedy", "fdk", "udT", "dedT", "rodt", "fcwt", "udt", "pedT", "ffout", "dlT", "FDt", "dirwt", "condk", "fdwt", "flT", "flts", "fdtt", "dlt", "ardp", "udout", "diry", "ardt", "fdout", "dbT", "hdT", "fctd", "fdp", "fcts", "fifl", "hdy", "fiflist", "fredt", "fcT", "hdk", "condt", "fift", "fredwt", "dedwt", "fedts", "fftt", "fcy", "FDwt", "fdtd", "flt", "FDl", "condts", "pedts", "inedl", "fredy", "dbt"], "offset": ["id", "oid", "tile", "atomic", "set", "off", "associated", "mounted", "zero", "locked", "scroll", "prototype", "batch", "shift", "count", "row", "num", "tab", "optional", "location", "outer", "final", "ptr", "owner", "range", "padding", "position", "online", "length", "vector", "total", "initial", "size", "offer", "slot", "style", "slice", "seek", "from", "initialized", "index", "pointer", "entry", "pad", "error", "ength", " offsets", "append", "offs", "exclusive", "empty", "address", "point", "len", "encrypted", "attr", "align", "pos", "start", "shared", "extra", "ta", "transform", "alias", "origin", "Offset", "layout", "frequency", "o", "packed", "store", "base"], "sphb": ["sperseg", "shpa", "sPHbr", "ssphp", "ssmphb", "southphfb", "smpha", "southphb", "sspha", "shpi", "sphfb", "sPHg", "shpp", "spersebr", "ssphb", "sperseb", "smphb", "sphbr", "sPHfb", "spersefb", "ssmphi", "southphg", "southperseb", "southpersefb", "smphp", "southphbr", "sphp", "ssmphp", "smphi", "sphg", "ssphi", "sphi", "sPHb", "shpb", "southpersebr", "spha", "ssmpha", "southperseg"], "rp": ["Rpc", "prp", " rpc", " rr", "prpc", "prr", "Rp", "rr", "rpc", "Rr"], "pci_status": ["pdi2status", "pdi_progress", "pci_name", "pci2status", "pdi2name", "pci_stat", "pci2name", "pdi_status", "pci2progress", "pdi_stat", "pdi2progress", "pdi2stat", "pdi_name", "pci_progress", "pci2stat"], "err": ["proc", "br", "arr", "er", "init", "ev", "attr", "txt", "iter", "exc", "cb", "res", "msg", "notice", "cur", "req", "pr", "conf", "ch", "error", "rr", "rev", "Error", "rc", "resp", "rel", "typ"], "buf": ["proc", "br", "ff", "temp", "tmp", "bc", "pipe", "p", "tty", "cb", "b", "msg", "seq", "cache", "vec", "cap", "ch", "buffer", "cv", "ptr", "pool", "str", "Buffer", "queue", "mem", "uf", "cmd", "buff"], "max_msi": ["max_ksI", "max_apsis", "max_ksis", "max_apsI", "max_ksi", "max_tsi", "max_tsis", "max_apsi", "max_msI", "max_msis", "max_tsI"], "max_msix": ["max_msci", "max_psi", "max_fsi", "max_msie", "max_psix", "max_tsi", "max_fsix", "max_tsie", "max_fsci", "max_psie", "max_tsix", "max_tsci", "max_psci", "max_fsie"]}}
{"project": "FFmpeg", "commit_id": "a8d702859b8bd17978fb5d8cb1d6acc363031e80", "target": 1, "func": "static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)\n\n{\n\n    MLPHeaderInfo mh;\n\n    int substr, ret;\n\n\n\n    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)\n\n        return ret;\n\n\n\n    if (mh.group1_bits == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown bits per sample\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group2_bits > mh.group1_bits) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel group 2 cannot have more bits per sample than group 1.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel groups with differing sample rates are not currently supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group1_samplerate == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown sampling rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group1_samplerate > MAX_SAMPLERATE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Sampling rate %d is greater than the supported maximum (%d).\\n\",\n\n               mh.group1_samplerate, MAX_SAMPLERATE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size > MAX_BLOCKSIZE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size, MAX_BLOCKSIZE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size pow2 %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.num_substreams == 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"MLP only supports up to 2 substreams.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.num_substreams > MAX_SUBSTREAMS) {\n\n\n                              \"%d substreams (more than the \"\n\n                              \"maximum supported by the decoder)\",\n\n                              mh.num_substreams);\n\n\n\n\n\n    m->access_unit_size      = mh.access_unit_size;\n\n    m->access_unit_size_pow2 = mh.access_unit_size_pow2;\n\n\n\n    m->num_substreams        = mh.num_substreams;\n\n    m->max_decoded_substream = m->num_substreams - 1;\n\n\n\n    m->avctx->sample_rate    = mh.group1_samplerate;\n\n    m->avctx->frame_size     = mh.access_unit_size;\n\n\n\n    m->avctx->bits_per_raw_sample = mh.group1_bits;\n\n    if (mh.group1_bits > 16)\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n\n    else\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n", "idx": 748, "substitutes": {"m": ["mt", "d", "message", "l", "c", "pc", "p", "bm", "sim", "g", "n", "iam", "all", "pm", "mp", "i", "b", "em", "mx", "md", "cache", "tm", "wm", "mod", "mem", "M", "dm", "perm", "man", "y", "vm", "metadata", "im", "e", "um", "ms", "mo", "nm", "sm", "hm", "mm", "v", "am", "on", "mac", "mat", "mi", "h", "media", "f", "cm", "gm", "om", "t", "esm", "mc", "fm", "module"], "gb": ["Gb", "nb", "mb", "rg", "eb", "vg", "sg", "tg", "bm", "kb", "img", "deg", "cfg", "cb", "rb", "gp", "eg", "gt", "wm", "hub", "gu", " GB", "bg", "gc", " db", "db", "bridge", "GB", "sb", "ram", "gov", "gm", "gg", "gow", "bf", "gam", "uf"], "mh": ["smh", "bmh", "mehash", "rmwh", "mzh", "kmhr", "manoh", "esmh", "bmv", "mutoh", "meh", "tmh", "meoh", "dmh", "mv", "mhs", "amrh", " msh", "munoh", "muthash", " mhz", "mho", "msh", "mtoh", "moh", "vmhash", " mth", "mhas", "mtrh", "permkh", "mthas", "Mh", "bmho", "mht", "hmh", "dmhash", "matesh", "matv", "hmhash", "fmh", "adeh", "hmoh", "tmoh", "remkh", " mih", "dmsh", "fmhash", "mhz", "imh", "kmv", "permh", "smesh", "hmv", " mhs", "nmhash", "esmhash", "imv", " mhash", "amh", "mtih", "tmhas", "remzh", "remh", " mkh", "math", "rmhash", " mhr", "mih", "vmhz", " mzh", "nmoh", " mesh", "matho", "mpl", "vmh", "fmzh", "bmrh", "remhash", "munh", "kmh", "muth", "bmhr", "cmho", "imht", "mesh", "amoh", "mathz", "amht", "mhr", "munhas", "munrh", "amho", "mrh", "manhash", "manho", "mtesh", "hmkh", "mhi", "nmpl", "mth", "manh", "remoh", " mho", "cmrh", "mths", "mutpl", "smoh", "imhs", "cmh", "mekh", "imoh", "adeho", "manwh", "manesh", "hmsh", " mwh", "hmhz", "dmhz", "rmh", "adev", "mkh", "tmrh", "Moh", "rmoh", "imhz", "remho", "Mhash", "imhr", "nmh", "Mpl", "cmhr", "imhi", " mv", "smih", "esmv", "amhr", "mthi", " mht", "adehas", "permho", "mhash", "vmhs", "mthz", "vmv", "vmhi", "kmhs", "mwh", "mathash", "bmhas", "permoh", "esmth", "fmoh", " mhas", "dmv", "dmth", " moh"], "substr": ["ubchar", " subj", "subj", "ublen", " subchar", "subchar", "Subj", "ubstr", "Subchar", "Sublen", "Substr", "ubj", "sublen", " sublen"], "ret": ["mt", "RET", "status", "value", " RET", "result", "ref", "txt", "out", "failed", "res", "cont", "gt", "ll", "mem", "ber", "Ret", "t", "not", " Ret", "err", "mel", "gc", "alt", "rev", "rt", "ter", "print", "val", "rets", "nt", "f", "rem", "reset", "tr", "resp", "det", "rel", "re", "back", "len"]}}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n", "idx": 767, "substitutes": {"s": ["sys", "ls", "S", "c", "is", "sv", "ss", "p", "es", "n", "sl", "ses", "set", "ds", "qs", "i", "b", "fs", "less", "sc", "aws", "ps", "parts", "js", "ns", "bs", "sac", "w", "as", "cs", "ts", "spec", "hs", "sts", "rs", "v", "gs", "f", "ats", "ins", "os", "t", "sn"], "bin": ["data", "stan", "ang", "inner", "net", "comb", "gin", "mon", "size", "bank", "bc", "butt", " ans", "soc", "bm", "conv", "abin", "img", "n", "stat", "txt", "box", "obin", "lib", " Bin", "spin", "dat", "sum", "b", "num", "pac", "inn", "cache", "win", "mem", "rin", "von", "conf", "bi", "bis", "sam", "ann", "tin", "con", "str", "anc", "enc", "reg", "sten", "ebin", "in", "bl", "by", "disc", "src", "binary", "png", "ins", "ram", "bn", "lang", "vin", "nb", "scan", " bins", "buff"], "st": ["mt", "stan", "d", "inst", "stri", "sta", "art", "net", "ste", "et", "usr", "ut", "dt", "rest", "stone", "nd", "step", "sh", "tt", "utt", "sv", "stat", "ast", "tmp", "sl", "stable", "ust", "set", "add", "td", "ST", "ft", "start", "sc", "stop", "sw", "ist", "stream", "ts", "ctx", "sty", "fr", "str", " est", "rt", "stage", "sts", "nt", "irst", "bl", "est", "ost", "ct", "cl", "src", "ot", "th", "sn", "so", "t", "obj", "se", "put", "std", "St", "sp"]}}
{"project": "qemu", "commit_id": "e50d7607f1800c9f9c576229c6119e4c82f456d6", "target": 1, "func": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n", "idx": 781, "substitutes": {"bs": ["ls", "abilities", "bec", "outs", "cks", "bc", "bh", "ss", "bm", "boxes", "vs", "pb", "uts", "bp", "bles", "ses", "ds", "b", "ubs", "fs", "lbs", "BS", "iss", "obs", "ps", "its", "bb", "js", "bos", "ns", "aos", "bi", "bis", "fps", "ms", "irms", "cs", "ts", "bes", "bps", "lines", "hz", "sts", "rs", "bytes", "bl", "bits", "blog", "bing", "bas", "gs", "sb", "bf", "bn", "os", "aus", "ubis"], "sector_num": ["sector_sym", "sector2num", "sector2number", "sector_Num", "ector_Num", "sector_nom", "sector2Num", "sector_mun", "ector_nam", "sectorityhom", "sector_hom", "tar_nom", "ector_num", "riverityNum", "sector_number", "riveritymun", "riverityhom", "sector_un", "sector_prim", "sector2nb", "river_hom", " sector_snap", " sector_nb", " sector_Num", "tar_sym", "river_num", "tar_Num", "sector_nb", "sector_snap", "riveritynum", "ector_un", "sectorityNum", "tar_num", "sectoritynum", " sector_number", "river_mun", "sectoritymun", "river_Num", " sector_prim", "sector_nam"], "nb_sectors": ["nb_psegments", "nb\u05bcseces", "nb_selements", "nb_bectors", "nb_elecs", "nb2vecs", "nb_specors", "nb_spectors", "nb_segments", "nb_nectors", "nb2segments", "nb_spears", "nb_psectors", "nb_nelements", "nb_veitors", "nb_persectors", "nb_esurers", "nb_specs", "nb_sears", "nb_eleors", "nb_veors", "nb_beors", "nb_neors", "nb_spegments", "nb\u05bcpersectors", "nb_seitors", "nb\u05bcsectors", "nb_vecs", "nb_speccs", "nb_seces", "nb_veurers", "nb_pseors", "nb_specctors", "nb2vegments", "nb_electors", "nb_vears", "nb_seors", "nb_elears", "nb2sectors", "nb_escs", "nb2veors", "nb2seors", "nb\u05bcseurers", "nb_perseurers", "nb_velements", "nb_persecs", "nb_speitors", "nb_speors", "nb\u05bcperseces", "nb_becs", "nb_pselements", "nb_specitors", "nb\u05bcperseurers", "nb_esctors", "nb_seurers", "nb_veces", "nb2secs", "nb2vectors", "nb_begments", "nb\u05bcsecs", "nb_esces", "nb_secs", "nb\u05bcpersecs", "nb_perseces", "nb_negments", "nb_vectors", "nb_vegments"], "qiov": ["kovi", "quiev", "fovi", "quiop", "kiev", "Qiv", "kiour", " qiour", "qovi", "Qiop", "kiov", "fiov", "qiour", "Qiov", "quiv", "quiov", "fiour", " qiv", "qiop", " qiev", "qiev", "fiev", "Qiev", "qiv", " qovi", " qiop"], "acb": ["accob", " acba", "acv", " acB", "aicb", "acsb", "racfb", "ACsb", "ainbb", "icbb", " acsb", "accsb", " cacba", "acba", "acwb", "acfb", "ocnb", " cacb", "acrb", "AcB", "accnb", "ocbb", "Acsb", "racrb", "icbc", "astB", "aicv", "accrb", "ainob", " acfb", "acbt", "accbt", "accb", " acbt", " cacv", "aicba", "ocb", "accbb", "ACnb", " acnb", "icb", "accp", "ocba", "icba", "aca", "astb", "acB", " caca", "aica", "astbt", "ocbc", " acbb", "accB", "ACb", "ainbc", "acnb", "accwb", "ainba", " acrb", "ainb", "ainsb", "accfb", "ocsb", "ACB", "ACwb", "acbc", " aca", "racbb", "Acb", " acp", "acob", "Acnb", "acbb", "ocwb", "astp", "racb", " acv", " acob", "acp"], "ret": ["mt", "ctr", "RET", "usr", "try", "ext", "iter", "out", "gt", " fut", "reply", "ber", " Ret", "ry", "rm", "dim", "reset", "resp", "re", "net", "result", "deg", "Ret", "tag", "rev", "alt", "ter", "nt", "max", "arg", "cert", "tr", "elt", "rel", "report", "dt", "rest", "fun", "ref", "res", "tf", "att", "virt", "val", "rets", "det", "rem", "flag", "len", "cmd", "success", "prop", "status", "arr", "value", "after", "r", "txt", "fin", "lit", "ft", "red", "cont", "def", "desc", "ort", "rt", "reg", "print", "pret", "nz", "oret"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794, "substitutes": {"dx": ["dial", "d", "tex", "fx", "ty", "dj", "delay", "xc", "dd", "lex", "eddy", "xi", "xs", "DX", "ax", "dist", "XX", "ox", "lat", "mx", "tx", "nox", "start", "dh", "xe", "pad", "ex", "xy", "dq", "ux", "dl", "xx", "xp", "w", "wd", "px", "rx", "yx", "ix", "dr", "xd", "wx", "dim"], "dy": ["d", "uy", "ty", "isy", "axy", "dj", "dt", "ay", "iy", "py", "dd", "idy", "eddy", "cy", "wy", "ds", "gy", "sy", "ady", "phy", "iny", "dh", "fy", "ey", "xy", "dq", "lon", "dl", "bis", "ury", "addy", "Y", "ry", "dis", "lly", "yy", "ly", "zy", "hy", "dim", "ny", "my"], "x": ["d", "fx", "l", "c", "xc", "z", "p", "lex", "xf", "xi", "xs", "xa", "ax", "path", "ox", "i", "lat", "mx", "tx", "xe", "ex", "xy", "ed", "xml", "xt", "w", "xp", "xx", "px", "rx", "yx", "ix", "ry", "v", "xd", "h", "wx", "ct", "X"], "y": ["sys", "ty", "uy", "axy", "er", "yl", "ay", "p", "iy", "py", "ery", "n", "cy", "wy", "ym", "yt", "gy", "sy", "aily", "m", "i", "iny", "b", "ya", "fy", "ey", "icy", "xy", "vy", "ch", "Y", "ies", "ry", "v", "yy", "h", "ly", "hy", "o", "sky", "col", "by", "yd", "oy", "ot", "ny", "ye", "my", "yan", "top"], "state": ["success", "data", "d", "id", "active", "ty", "test", "key", "status", "size", "value", "code", "count", "port", "next", "style", "stat", "p", "to", "g", "component", "result", "power", "out", "set", "m", "close", "b", "policy", "start", "new", "none", "info", "valid", "lock", "type", "scope", "STATE", "powered", "local", "ch", "error", "update", "w", "future", "color", "State", "name", "resource", "spec", "val", "fire", "in", "h", "current", "zone", "stroke", "states", "unit", "t", "ate", "length"], "bmap": ["bMap", "lbMAP", "bbmap", "bMAP", " bMap", "lbmap", "lbMap", "bbset", "wMap", " bMAP", " bset", "rbmap", "wMAP", "bcap", "bset", "rbcap", "wmap", "rbset", "bbcap", " bcap"], "prev_state": ["viousJsequence", "prev_sequence", "prev___job", " prev_State", "prevJstate", "prev___action", "viousJstate", "prev_status", "vious_status", "final_action", "final_info", "prevJsequence", " prev_job", "final___state", "prev_out", "viousJout", "final_status", "prev___status", "vious_state", "final___action", "prev_action", "final___info", "final_state", "prevJout", "vious_out", "prev___info", " prev_status", "prev_State", "prevJstatus", "prev_job", "viousJstatus", "final___status", "prev_info", "vious_sequence", "prev___state"]}}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n", "idx": 797, "substitutes": {"obj": ["inst", "j", "id", "oid", "tmp", "obo", "vo", "bj", "object", "bh", "org", "ev", "attr", "hw", "ref", "txt", "onet", "any", "act", "cont", "obs", "att", "ex", "xy", "js", "bs", "oc", "ctx", "ob", "Obj", "go", "bo", "od", "nt", "o", "src", "ot", "os", "elt", "json", "typ"], "dev": ["d", "gr", "env", "device", "pro", "buf", "adv", "cho", "conn", "all", "init", "ev", "ow", "build", "hw", "dem", "stable", "out", "devices", "var", "van", "res", "develop", "pack", "serial", "nv", "off", "def", "priv", "prof", "mem", "pad", "boot", "gu", "sw", "normal", "w", "cast", "wd", "cam", "ver", "de", "die", "go", "DEV", "loc", "db", "tech", "rem", "v", "ov", "od", "nt", "cmd", "av", "ve", "tr", "oy", "scan", "pub", "th", "des", "enc", "Dev", "serv", "fo"], "prop": ["proc", "property", "acc", "br", "cp", "ko", "key", " props", "ph", "pro", "op", "jp", "po", "buf", "term", "p", "ev", "attr", "pb", "plot", "cfg", "pp", "mp", "bug", "decl", "coord", "com", "lit", "pos", "priv", "def", "prof", "pr", "ps", "opt", "conf", "ptr", "xp", "Prop", "comp", "pl", "ctx", "con", "spec", "pkg", "coll", "pred", "bo", "pt", "loc", "val", "per", "rop", "sp", "col", "par", "rep", "rel", "feat", "supp", "cmd", "pri"]}}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    /* The request is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n", "idx": 837, "substitutes": {"req": ["ctr", "usr", "gr", "ext", "p", "init", "out", "tek", " resp", "qt", "request", "pr", "job", "dq", "Q", "cond", "comp", "rx", "pkg", "ind", "wx", "resp", "sol", "mem", "q", "test", "dep", "deg", "crit", "dist", "task", "msg", "seq", "requ", "perm", "ptr", "rec", "rr", "esp", "expr", "sel", "sq", "rep", "j", "aux", "pro", "jp", "buf", "quest", "ref", "progress", "comm", "decl", "res", "Requ", "cur", "dev", "err", "fr", "ctx", "str", "eq", "sem", "urg", "worker", "exec", "cmd", "pri", "proc", "wcs", "qq", "term", "conn", "org", "egg", "attr", "query", "txt", "cfg", "exc", " requ", "tx", "exe", "md", "config", "desc", "grab", "reg", "good", "gz", "pub", "alg"], "r": ["reader", "usr", "gr", "ro", "c", "p", "hr", "ren", "ru", "out", "var", "x", "request", "pr", "sr", "rf", "response", "rx", "ry", "rm", "h", "ret", "f", "resp", "re", "mr", "br", "d", "q", "lr", "result", "rb", "m", "requ", "kr", "rec", "rr", "ar", "range", "tr", "rel", "rar", "R", "rd", "j", "cr", "l", "er", "nr", "vr", "all", "ref", "res", "i", "y", "err", "fr", "or", "v", "rem", "rc", "item", "rg", "g", "rer", "attr", "rw", "rate", "b", "red", "w", "e", "rh", "adr", "rt", "reg", "dr", "rs", "o", "t", "obj", "rn"], "s": ["sys", "ls", "S", "q", "south", "stats", "c", "is", "sv", "ss", "p", "settings", "es", "g", "service", "sl", "vs", "app", "ses", "comm", "ds", "qs", "i", "b", "params", "https", "less", "fs", "sc", "ps", "its", "js", "ns", "bs", "sw", "conf", "y", "http", "ims", "sam", "ms", "ts", "cs", "ies", "hs", "sts", "rs", "v", "client", "h", "gs", "sb", "sq", "os", "t", "socket", "serv", "ops", "self", "sp"], "n": ["gn", "ni", "d", "j", "l", "nb", "size", "c", "nc", "non", "cn", "N", "p", "z", "g", "np", "m", "i", "b", "u", "num", "nw", "ne", "yn", "nan", "ns", " na", "w", "nm", "un", "an", "v", " len", "nt", "h", "o", "nu", "norm", "f", " N", "nn", "na", "fn", "t", "a", "len", "sn"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848, "substitutes": {"plow": [" plower", "prowed", "phOW", "peligh", "phov", " pligh", "prow", "plov", "plog", "paligh", " ploor", "puigh", "puow", "plown", "palown", "penow", "palog", "pelow", "palOW", "penog", "power", "palow", "palew", "palowed", "pligh", "prog", "pelew", "plower", "puowed", "pelog", " plOW", " plov", "phew", "explower", "pelowed", "plowed", "prov", "powe", "plOW", "pigh", "phoor", "palov", "phow", "plowe", "expligh", "phog", "pelown", "penowed", "ploor", "penov", "explow", "phowed", " plowe", "plew", "paloor", "puown", "explowe"], "phigh": [" phow", "mphord", "thiz", "procushi", "phushi", "shIGH", "procight", "plushi", "phiresh", "mphig", "pliz", " phushi", "chow", " phight", "phresh", " phith", "thow", "mphiz", "mphIGH", " phIGH", "phiz", "pligh", "khigh", "mphresh", "shiz", "procigh", "khresh", "plong", "phith", " phong", "mphith", "shigh", " phord", "phiIGH", "shith", "chig", " phig", "phong", "phord", "show", "mphow", "plight", "chiz", "phIGH", " phresh", "phiow", " phiz", "chigh", "shig", "phow", "khig", "phiigh", "thig", "plig", "thigh", "procong", "khord", "phig", "phight", "mphigh"], "b": ["br", "j", "d", " m", "l", "eb", " f", "bc", "bh", " bab", "z", "p", "g", "n", " binary", " buffer", " bound", "pb", "r", "bp", "s", "cb", "rb", "m", "i", "be", "u", " that", " msg", "gb", " i", "bb", " base", "t", "bs", "bt", "y", " a", "bi", "e", " body", " d", "a", " h", " p", " y", "bg", "ba", "ob", " t", " db", "db", "fb", "v", " to", " ab", "h", "B", " null", "beta", "f", "bf", "nb", " storage", "base", "ib"], "sa": ["ma", "sta", "mas", "Sa", "eas", "ga", "ama", "sl", "ca", "sea", "aa", "la", "asi", "s", "pi", "sie", "wa", "sy", "asa", "sc", "su", "za", "au", " sd", " si", "gu", "pse", "lab", "sr", "pa", "sd", "sam", " Sa", "as", "ae", "go", "SA", "ja", "ia", "sama", "ha", "mi", "ai", "si", "SI", "na", "so", "sha", "da", "a", "se", "ssl", "sp"], "sb": ["tmp", "lr", "mb", "eb", "bj", "sg", "bc", "sh", "ib", "bh", "sth", "sv", "kb", "rob", "sl", "zb", "pb", "bp", "s", "sf", "cb", "rb", "lb", "sk", "sc", "gb", "bb", "bs", "bt", "sr", "pa", "sd", "bi", "bis", "sam", "bg", "gc", "sm", "fb", "osp", "sbm", "SB", "si", "sn", "bf", "nb", "se", "ssl", "sp"]}}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 855, "substitutes": {"linker": ["inkner", "lockger", "lockers", "drawer", " linkier", "inkger", "inker", "linkner", "loadler", "linkler", "loader", "loadner", " linkger", "drawler", "linkier", "linkers", "drawger", "inkler", "inkers", "linkger", "inkier", "drawner", "lockier", "locker", " linkers", "loadger"], "file": ["fp", "domain", "data", "image", "id", "message", "user", "key", "le", "File", "format", "handle", "ile", "port", "source", "files", "ref", "dir", "read", "out", "path", "action", "table", "link", "page", "full", "family", "type", "filename", "fi", "block", "local", " File", "disk", "buffer", "name", "resource", "iles", "db", "offset", "io", "queue", "range", "angle", "field", "channel", "f", "line", "byte", "module", "chain"], "alloc_align": [" alloc_ign", "auto67aligned", "auto_coord", "alloc2angle", "oc_num", "alloc67angle", "cmp_num", "alloc_aligned", "alloc67aligned", "oc_angle", "alloc_angle", "alloc67align", "alloc_ign", "auto_align", "alloc_aff", "alloc8ign", "alloc_adjust", "cmp_adjust", "alloc_range", "alloc8aff", "alloctnum", "alloc2align", "auto_aligned", "alloctalign", "alloc8angle", " alloc_aff", "alloc8align", "alloctadjust", "auto67align", "auto_angle", "cmp_align", "alloctaligned", "auto67coord", "alloc2aligned", "auto67angle", " alloc_angle", "alloc_coord", "oc_align", "cmp_aligned", "alloc2coord", "alloc_num", "alloc67coord", "oc_range"], "alloc_fseg": ["alloc_tseyg", "alloc_tsebg", "alloc_fpseg", "alloc_fasep", "alloc_fSEg", "alloc_fbep", "alloc_tpseyg", "alloc_tsei", "alloc_fSEi", "alloc_fasei", "alloc_fpseyg", "alloc_fseyg", "alloc_tpseeg", "alloc_fpeyg", "alloc_fpeeg", "alloc_tsegs", "alloc_tsep", "alloc_fSEbg", "alloc_tseg", "alloc_fbeg", "alloc_fasebg", "alloc_tbeg", "alloc_fsegs", "alloc_fpseeg", "alloc_fsei", "alloc_tbep", "alloc_fbegs", "alloc_tpsegs", "alloc_fsep", "alloc_fbeyg", "alloc_fSEp", "alloc_faseg", "alloc_fbeeg", "alloc_fpegs", "alloc_tpseg", "alloc_tbebg", "alloc_fbei", "alloc_fseeg", "alloc_tseeg", "alloc_fpeg", "alloc_fbebg", "alloc_fpsegs", "alloc_fsebg", "alloc_tbei"], "entry": ["try", "match", "rent", "component", "ent", "server", "out", "set", "see", "needed", "form", "deep", "req", "xml", "response", "ries", "ry", "__", "enter", "line", "rance", "our", "q", "inner", "key", "row", "element", "result", "cue", "check", "cell", "ptr", "search", "member", "nt", "self", " Entry", "aux", "section", "record", "index", "parse", "info", "connection", "comment", "error", "attribute", "existent", "office", "insert", "or", "client", "ient", "pair", "se", "card", "inter", "data", "image", "add", "instance", "item", "value", "way", "import", "r", "query", "def", "delete", "ary", "Entry", "desc", "e", "command", "ment", "escape", "print", "field", "RY", "event", "obj", "base"]}}
{"project": "qemu", "commit_id": "95eaa78537c734fa3cb3373d47ba8c0099a36ff0", "target": 1, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->bl.request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {\n\n            bs->bl.max_pdiscard =\n\n                iscsilun->bl.max_unmap * iscsilun->block_size;\n\n        }\n\n        bs->bl.pdiscard_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pdiscard_alignment = iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 860, "substitutes": {"bs": ["ls", "stats", "bec", "banks", "eb", "cks", "bc", "bh", "bd", "ss", "bm", "boxes", "vs", "pb", "bp", "bles", "ds", "qs", "vals", "b", "ubs", "fs", "lbs", "BS", "obs", "ps", "its", "bb", "js", "bos", "aos", "bt", "ns", "ims", "bi", "bis", "irms", "cs", "ts", "bg", "bes", "bps", "sts", "hz", "bl", "bits", "blog", "gs", "sb", "ats", "bn", "ins", "bsp", "aus", "ubis"], "errp": [" errps", "erP", "ErP", "erp", "errP", " errP", "errps", "Erps", "erps", "Erp"], "iscsilun": ["ionicticgun", "isfsolgun", "isecsentunk", "isctilmun", "isssilu", "iscsuund", "iscsinoun", "iscsidun", "isecvaleune", "iscsslun", "iscsimmun", "iscidentund", "uscsinoun", "iscsuccessfulune", "iscuritymun", "uscsilunk", "ischsiluna", "ricsilunt", "iscsilcon", "iscryptund", "isssilgun", "iscgilgun", "iscurityun", "iscsilut", "nicsinun", "iscsisunk", "iscsqluna", "isssidgun", "iscidentun", "isecsilund", "iscsilune", "iscmilune", "iscchlormun", "iscsinun", "iscmilut", "uscinelune", "iscsidung", "issmilun", "iscwashuna", "nicsilun", "nicsilune", "isecvaleun", "iscsentund", "iscinelun", "isecsiuna", "illacsilune", "isecsentund", "issgilun", "isssidu", "isciphanyun", "iscsentgun", "isanchloruna", "iscesiun", "uscsiloun", "micsilune", "iscstatgun", "iscsiuna", "iscsinut", "incsilun", "iscryptung", "uscvaleund", "iscpalune", "riconsequun", "iscchlorun", "iscsilmun", "iscvaleuna", "iscsinmun", "isssiluna", "micsidune", "incsilunn", "uscsilban", "inctiluna", "designsilun", "isconsequun", "ischidentund", "iscsolgun", "iscsilfun", "uscsinun", "iamsilmun", "designmilun", "issgilune", "iamseveremun", "nicsinmun", "iscsiun", "iscvaleunc", "iscesiuna", "iscticun", "iscsilunt", "iscsiden", "iscinelgun", "iscspellgun", "iscsqlund", "illacsuccessfulut", "iscsinuna", "isconsequmun", "iscsevereban", "isclitun", "isclituna", "designsilcon", "designsilund", "uscsilgun", "iscvaleut", "isconsequune", "iscsiduna", "iscseveregun", "isfsiluna", "ischematicun", "isecsilung", "isecsilunt", "ricsilun", "iscchlorcon", "isssilunk", "isecvaleunt", "iscticung", "illacsuccessfulunt", "iscsugun", "micsilu", "iscsiluna", "iscsilung", "iscvaleu", "uscvaleunt", "iscryptgun", "uscinelun", "iscslgun", "iscsilgun", "isssilunc", "uscsilune", "iscgilunc", "iscmilunk", "iscspellund", "iscsuuna", "iscvalegun", "iamsevereund", "nicsilmun", "isssilune", "isansilun", "nicsiluna", "iscurityund", "iscsinund", "isfsilun", "iscsevereund", "iscuritygun", "nicsilut", "iscsuun", "iscsentut", "iscspellunc", "isfsolun", "iscsqlun", "iscmilunt", "iscpalunk", "iscidentmun", "ischematicune", "micsidun", "iscryptun", "iscticuna", "isansiluna", "isctilunt", "isctilune", "ricsilune", "illacsilun", "isfsoluna", "iscticunt", "iscmilmun", "nicsinune", "iscstatut", "iscvaleoun", "iscvaleunn", "iscsinban", "ischematicmun", "iscmilcon", "iscsimun", "isecsilunc", "uscsinund", "iscspellunt", "isssilmun", "isansilen", "designmilmun", "ischsilund", "iscseveremun", "isecsiun", "uscsilun", "nicvaleut", "micsilun", "iscsuccessfulun", "issineluna", "iscsuccessfulunt", "issmilund", "isanchlorung", "issmilune", "isclitund", "iscmilun", "iamseveregun", "iscsolun", "iscvaleunt", "iscidentunk", "iscsentunk", "iscsidune", "iscinelune", "ionicsilgun", "ionicsiluna", "iscsilunk", "iscsiloun", "iscinelu", "iscpalun", "iamsilun", "illacsuccessfulune", "iscgilund", "isecvaleunc", "iscidentung", "isanchloren", "isecsentun", "iscvalefun", "iscslunt", "iscchlorund", "isssilun", "micsiluna", "iscchloroun", "iscchlorung", "uscinelban", "iscgilun", "iscgilunk", "isciphanyund", "iamsevereun", "iscsilunc", "isctilunc", "iscsimgun", "uscineluna", "iscmilund", "riconsequunt", "iscchloruna", "iscsuccessfulut", "issmilunk", "iscsilban", "isclitmun", "micsidu", "iscsevereuna", "iscsisuna", "iscchlorune", "incsilgun", "iscsidu", "designsilmun", "nicvaleuna", "inctilunn", "iscspellfun", "iscsidgun", "ischematicunt", "designmilcon", "iscspellune", "nicsinuna", "iscsilu", "ischsilunk", "riconsequmun", "ionicsilmun", "iscsentun", "issinelund", "isecsiung", "iscryptune", "iscsslune", "ischidentuna", "ionicticmun", "ricsilmun", "iscrypten", "iscsevereun", "uscinelgun", "iscrippund", "isctilun", "iscticmun", "uscsinune", "iscsolunt", "iscryptuna", "issinelmun", "illacsuccessfulun", "isfsilgun", "iscidentuna", "iscinelmun", "iscidentgun", "issgilunc", "ionicticuna", "iscgilune", "uscsinuna", "iscwashmun", "ischidentunk", "issgilgun", "iscsslgun", "iscsentuna", "iscticunn", "iscidentunt", "iscsevereune", "iscinelund", "iscseverefun", "ischsilun", "incsiluna", "iscstatun", "isciphanyuna", "iscsqlunk", "isecsiunt", "iscsuunk", "iscsiung", "iscidentu", "iscsisund", "iscchloren", "iscinelcon", "uscinelund", "uscsilfun", "uscsinunk", "nicvaleun", "iscwashune", "iscvalemun", "ionicticun", "iscspellun", "ischidentun", "issinelun", "uscsilund", "iscsidunt", "isecsiluna", "iscgiluna", "isansilung", "isssidun", "inctilgun", "isanchlorun", "nicsilgun", "iscsilunn", "iscvaleund", "micsiduna", "iscsslund", "iscsinune", "isctiluna", "iscvaleune", "iscvaleunk", "iscsisun", "isssilund", "iscsidund", "iscesiunt", "isciphanyune", "iscsingun", "isconsequunt", "iscrippun", "iscsoluna", "isecsilun", "iamsilgun", "iscesigun", "iscslun", "isecsentuna", "iamsilund", "iscrippuna", "iscwashun", "iscineluna", "designmilund", "isecsilune", "isssiduna", "inctilun", "uscvaleuna", "iscticgun", "iscsinunk", "iscpalund", "illacsilunt", "isfsolunt", "iscsuune", "iscsilund", "isecsilunk", "iscsluna", "isctilgun", "illacsilut", "iscrippunk", "uscsingun", "iscsiunt", "iscsilen", "nicvalegun", "riconsequune", "iscsimuna", "iscsinunt", "ionicsilun", "uscvaleun", "iscstatuna", "uscsilunt", "isctilunn", "isfsilunt", "iscinelban", "uscvaleune", "uscvalefun", "iscvaleun", "uscsiluna"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 883, "substitutes": {"opaque": ["Opface", "operosit", "oposit", "operaque", "iopca", "opca", " Opaque", "oposter", "operoster", " oposit", "Opaque", " opface", "opacity", "iopaques", " Opacity", "Opca", "iopaque", " Opaques", "opaques", "iopacity", " oposter", "Opacity", "Oposter", "Oposit", "Opaques", "opface", " Opca", "operface"], "buf": ["doc", "data", "batch", "br", "q", "cat", "bc", "p", "text", "img", "window", " buffer", "pb", "ref", "cb", "rb", "b", "pack", "cur", "bb", "vec", "uf", " buff", "block", "accept", "cap", "buffer", "cv", "bag", "aka", "Buffer", "wb", "fb", "queue", "v", "raw", "Buff", "mem", "map", "cmd", "buff"], "size": ["code", " name", "count", "news", "z", " sizes", "n", "g", "set", "send", " event", "sum", " Size", "space", " news", "shape", "type", " pos", " error", "time", " resize", " notice", "SIZE", "buffer", "e", "name", "since", "len", "now", " code", "ize", "empty", "fee", " count", "mem", "length", "Size", "sn"], "s": ["sys", "ls", "j", "S", "stats", "c", "is", "sv", "ss", "p", "n", "session", "r", "ses", "sa", "ess", "ds", "i", "b", "fs", "less", "store", "ps", "js", "ns", "state", "w", "sam", "ts", "spec", "sm", "hs", "sts", "rs", "v", "gs", "sb", "sq", "t", "se", "ssl", "sp"], "ret": ["mt", "ctr", "RET", "cat", "try", "mb", "arr", "Return", "ext", "r", "deg", "out", "res", "x", "ft", "num", "red", "cont", "gt", "def", "reply", "att", "Ret", "xt", "err", "str", "rt", "alt", "ry", "val", "v", "rm", "pret", "nt", "nz", "cmd", "arg", "tr", "rem", "flag", "resp", "reset", "elt", "t", "re", "back", "inter"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n", "idx": 886, "substitutes": {"dev": ["proc", "doc", "d", "test", "env", "device", "pro", "adv", "dd", "ev", "ow", "hw", "build", "any", "window", "app", "dem", "debug", "patch", "develop", "serial", "form", "md", "def", "priv", "mem", "pad", "att", "boot", "gu", "end", "conf", "block", "ch", "disk", "w", "cam", "wd", "cast", "stick", "ver", "exec", "spec", "de", "go", "DEV", "pt", "tech", "v", "val", "nt", "draw", "sky", "ad", "av", "ve", "det", "th", "raw", "des", "Dev", "scan", "serv", "cmd"], "errp": ["errpc", " errq", " errpc", "aerp", "errq", "rrpc", "errpre", "errorq", "lerper", " errpre", "lerP", "rrp", " errper", "errorp", "aerpa", " errpa", "rrpost", " errP", "lerp", "errpa", "errorpre", " errpost", " errps", "errpost", "erP", "rrP", "errper", "errorpost", "errorP", "lerpost", "aerps", "erp", "rrq", "errps", "errorps", "erps", "rrps", "erpre", "errorper", "rrpa", "errP", "aerpost", "errorpc"], "dinfo": ["Dinfo", "Dstate", "Ddetails", "fdstate", "DInfo", "dxinf", "ddetails", "orddetails", "dstate", " ddetails", "didstate", "didInfo", "dinf", "didinfo", "fdinfo", "Dinf", "Ddev", "dxdev", "ordInfo", "dInfo", " dInfo", "ordinf", "fdInfo", "dxInfo", "dINFO", " dinf", "fdINFO", "dxinfo", " ddev", "didINFO", "ordinfo", "ddev", "DINFO"], "local_err": ["locallyerr", "local___error", "local___usr", "localableeas", "local___err", "seriallyerr", " local_error", "serial_err", " local_eas", "local_eas", "local___eas", "local___rr", "local____err", "local_conn", "local_bar", "seriallyconn", "localableerr", "thisableerr", "locallyconn", "localableer", "this_err", "serial_conn", " local_rr", "thisablebar", "locallyarr", "local_usr", "local_error", "local____arr", "local____conn", "local_rr", "thisableeas", "this_bar", "localablebar", " local_usr", "this_er", "thisableer", "this_eas", "seriallyarr", "serial_arr", "local_arr", "local_er"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    uint32_t new_vid;\n\n    SheepdogInode *inode;\n\n    unsigned int datalen;\n\n\n\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n\n\n\n    if (s->is_snapshot) {\n\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n\n\n\n        return -EINVAL;\n\n    }\n\n\n\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n\n\n\n    s->inode.vm_state_size = sn_info->vm_state_size;\n\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 899, "substitutes": {"bs": ["ls", "cks", "bc", "bh", "ss", "bm", "als", "vs", "bp", "ds", "b", "ubs", "fs", "lbs", "BS", "obs", "ps", "its", "bos", "ns", "js", "bis", "ms", "cs", "ts", "hs", "rs", "bl", "bits", "blog", "gs", "sb", "os", "aus"], "sn_info": ["zn_list", "snWInfo", "Sn_kind", "skymyInfo", "Sn_info", "sn2inf", " sn_inf", "zn_details", " sn__inf", "sn_error", "rn_about", " sn__Info", "snPinfo", "snPlist", "snWnote", "tn_inf", "sn_note", "sn__info", "sn_about", "Sn_INFO", "sn_description", "snWinf", " sn_Info", "Sn_inf", "sn___details", "snptInfo", "sn_inf", "sky_details", "pn_INFO", "rn_information", "sn2Info", "snmyinfo", "sn2info", "sky_Info", "tn_description", "snmyINFO", "snptinfo", "rn_info", "pn_description", "Sn_Info", " sn__info", "zn_info", " sn_INFO", "sn__inf", "sn_information", "sn_Info", "snmyInfo", "zn___details", "pn_info", "zn___list", "tn_info", " sn_error", "sn__Info", "sn__note", "sn_list", "snmydetails", "sn2note", "snpterror", "sn___list", "snptINFO", "sn_recent", "sky_info", "zn___info", " sn_note", "sn_kind", "skymyinfo", "snmyrecent", "snPdetails", " sn__note", "sn_INFO", "Sn_recent", "sn_details", "snWinfo", "pn_Info", "sn___info", "skymydetails"], "s": ["ls", "c", "ysis", "p", "es", "ses", "gets", "services", "its", "conf", "http", "ports", "cs", "spec", "ains", "ies", "events", "h", "gs", "sb", "os", "so", "a", "serv", "south", "stats", "sv", "settings", "service", "vs", "details", "xs", "ds", "qs", "m", "less", "ex", "ims", "bis", "sam", "hs", "sts", "eps", "ins", "states", "sq", "sn", "S", "l", "ss", "als", "sl", "sa", "comm", "https", "ns", "sw", "y", "ms", "ts", "changes", "v", "tests", "results", "ops", "ssl", "sys", "is", "sim", "g", " ss", "b", "aws", "ps", "parts", "js", "w", "as", "sm", "has", "rs", "bits", "ats", "t"], "ret": ["mt", "j", "usr", "RET", "try", "net", "status", "il", "arr", "Return", "tt", "ext", " RET", "after", "result", "txt", "deg", "lt", "out", "cb", "res", "fin", "x", "ft", "cont", "gt", "ll", "def", "at", "att", "prot", "Ret", "ert", "fl", " Ret", "fi", "ptr", "err", "gc", "rt", "alt", "ter", "del", "print", "val", "rm", "rets", "nt", "nz", "gz", "det", "rem", "flag", "tr", "resp", "cert", "elt", "t", "re", "reset", "back", "len", "cmd"], "fd": ["fp", "d", "rd", "fc", "ff", "cd", "func", "dt", "buf", "deb", "nd", "handle", "bd", "dd", "fun", "fa", "dc", "tty", "dir", "ds", "cb", "td", "lf", "fin", "fed", "fs", "ft", "gd", "fl", "fi", "file", "cf", "hd", "ptr", "dl", "err", "df", "fe", "fr", "ctx", "ln", "db", "io", "ud", "fb", "du", "gz", "f", "FD", "raf", "bf", "fn", "elt", "pid", "resp", "obj", "fm", "uf", "ld"], "new_vid": ["new_vision", "new___vid", "New_vid", "new_uid", "newtvid", "new_pid", "new___uid", "New_vi", "pb___vid", "new_vi", "pb_vid", "new___pid", "pb___pid", "new___vision", "pb___uid", "newtuid", "New_vision", "pb___vi", "newtpid", "pb_pid", "new___vi", "pb_uid", "newtvi", "pb_vi", "New_pid"], "inode": ["ninnode", "binod", "inoration", "insod", " inoe", "innerola", "innodo", "iode", "noder", " inonymous", "node", "anox", "innole", "rinode", "iock", "insodo", "inod", "INode", "ninodo", "sinoder", "inneroe", "inom", "inow", "kinoration", "rinock", "inioice", "into", "inole", "enode", "inonse", "innoice", "intote", " inonse", "anod", "annode", " inock", "sinode", "ninox", "iniodo", "cinox", " inole", "binom", "cinode", "ginod", "loginola", "INox", " inoder", "nox", "anote", " inoration", "kinole", "rinade", "inote", "innoration", "insox", "ninod", "innonymous", "ginode", "nino", "intoder", "inonymous", "iade", "sinod", "ino", "innoder", "INoder", "enod", "rinoder", "INnode", "innox", "inoder", "intode", "bino", "insode", "inola", "kinode", "iniod", "inno", "sinox", "inneronse", "ginox", "anode", "ininode", "INod", "inname", "ninode", "cinod", "innow", "ginnode", "inox", "innnode", "intod", "ano", " iname", "ioder", "kinod", " inom", "iniode", " inade", "innerode", "ninoder", "inade", " ino", "enoder", "ninom", "innote", "iniame", " inod", "iname", "inoe", " inola", "binode", "nod", "innode", "inock", "loginonse", "inionymous", "enow", " inoice", "cinoder", "innod", "inoice", "loginoe", "loginode", "inodo", "intow"], "datalen": ["dalob", "daiallen", " datalength", "dalize", "dallength", "daatallen", "dialig", "datalength", "datsen", "dalens", "datalize", "Dalen", "dalen", "damelize", " dallEN", "daialen", "dallig", "dotalig", "datalig", "datalim", "dblim", "datalener", "datalens", "daatalener", " datalig", "dotalEN", "dotalen", "dotalener", "dalim", "dblen", "dotallen", "datalEN", "Datalob", "dreatength", "datalob", " dalength", "Dalim", "diallen", "damelength", "daleren", "dalerener", " datalize", " dalen", "dulens", "daatalen", " dalize", "dulength", "dalerig", "damelens", "daialener", " datalens", "dblob", "datsig", "dialener", "dotalength", "Datalength", "damelen", " dallen", "dallen", "dalength", "datsength", "Datalen", "dreaten", " dallig", "dulen", "datsEN", "dreatim", " dalens", " dallength", " datalEN", "Datalim", "daatalig", "Dalob", "daialig", "dblength", "dreatob", "datallen", "Dalength", "dialen", "dallEN", "dalerlen", "dulize"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 906, "substitutes": {"vd": ["vc", "d", "rd", "cod", "cd", "rod", "ond", "dt", "managed", "ard", "vr", "bd", "dd", " od", "pdf", "rid", "dk", "vs", "vt", "pty", "td", "idd", "nv", "gd", "dll", "md", "gb", "him", "ced", " sd", "vp", "dh", "ord", "vi", "qt", "dq", " cd", "dri", "lv", "dm", "vm", "sd", "hd", "disk", "dl", "oud", "wd", "vv", "df", "db", "ud", "v", "dr", "vid", "xd", "vision", "od", "vol", "du", "erd", "dds", "ve", "pd", "VD", "ld", "fd"], "saddr": ["saddress", "lsadr", "lsadd", "sadd", "gsaddress", " sarr", "gsadd", " sadd", "lsaddress", "sarr", "nsadd", "nsarr", "lsarr", "gsadr", "sadr", "gsaddr", " saddress", "nsadr", "lsaddr", "nsaddress"], "nsaddr": ["saddress", "xsarr", "msptr", "bsarr", "wscoord", "wsadr", "bsaddr", "wsptr", "bsaddress", "xsaddress", "nsptr", "nscoord", "bscoord", "xscoord", "sptr", "nsarr", "msadr", "msaddress", "xsaddr", "wsarr", "wsaddress", "sadr", "msaddr", "nsadr", "nsaddress"], "wsaddr": ["atsadd", "lsadr", "lsadd", "WSadd", "atsadr", "gsha", "wsadr", "WSptr", "gsadd", "atsaddr", "lsptr", "wsptr", "WSaddr", "nsadd", "wsadd", "nsptr", "atsha", "WSadr", "gsadr", "wsha", "gsaddr", "nsha", "nsadr", "lsaddr"], "nwsaddr": ["nhshop", "nnscap", "nmscap", " nmsaddress", "nawsadr", "nnsaddr", "nwscoord", " nwsadr", " nWscoord", " nWsadr", " nwsaddress", " nwscap", " nmsaddr", " nWsaddress", "nhscap", "nawscoord", "nmshop", "nwsaddress", "nnshop", "nwscap", " nmscap", "nawsaddr", "nhsaddr", "nWsaddress", " nwshop", " nwscoord", "nnsadr", "nWscoord", "nawsaddress", "nnscoord", "nwsadr", "nmsaddr", "nhsaddress", "nmsaddress", "nWsadr", "nwshop", "nWsaddr", "nnsaddress", " nWsaddr", " nmshop"], "errp": [" errpp", "rrpid", "eorcp", "cerpa", "rrr", "errd", "errproc", "ererproc", "rrproc", "rrp", "errpp", "lrp", "cerpp", "cerp", "rrd", " errpa", " errop", "rrop", "errop", "errpa", " errr", "eorproc", "errpid", "erercp", "err", "erp", "eorp", "lrpp", "erop", "eorpid", "ererpid", "errr", "erd", "rrcp", "ererp", "lrpa", "errcp", " errd"], "i": ["c", "ogi", "p", "init", "li", "us", "series", "iu", "ti", "ind", "uri", "ix", "zi", "ini", "I", "this", "key", " j", "xi", "ic", "qi", "m", "u", "ui", "it", "gu", "im", "io", "\u0438", " err", "chain", "l", "ii", "ji", "record", "slice", "pi", "asi", "me", "index", "ci", "ei", "info", "phi", "eu", "fi", "y", "bi", "hi", " I", "go", "v", "client", "mi", "di", "ai", "si", "multi", "ki", "is", "sim", "g", "s", "ami", "b", "cli", "gi", "ip", "oi", "ie", "e", "print", "uli", "in", "t"]}}
{"project": "qemu", "commit_id": "1171ae9a5b132dc631728ff17688d05ed4534181", "target": 0, "func": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n", "idx": 913, "substitutes": {"cpus": ["cpos", "cmpuses", "pucs", "cpcs", "puots", " tcpus", "cpuli", "puuses", " cpuses", "pots", " tcpuli", "cpcu", "cmpcu", " cpuls", " cpuli", " cpos", "cpuls", "puuls", "cpuses", "cmpus", " tcpuls", "puos", "puses", " cpcs", "compu", " tcpos", "puuli", "compcu", " cpots", "cpots", "puus", "pcs", "pucu", "pus", "compus", "compuses", "cmpu", "puu"], "max_cpus": ["max_ponents", "max_caps", "max_cpuonents", "max_cponents", "max4cpus", "max_ipuses", "max_compos", "max_processus", "max_ps", "max_comppu", "max_ipus", "max4processs", "max_cpos", "max4processes", "max_ips", "max4cpos", "max_cpuus", "max_gpus", "max_cpes", "max_cpuses", "max_cpors", "max_pors", "max_compus", "max_cpuu", "max_processos", "max_cpu", "max_capus", "max4processus", "max_compuses", "max_gpu", "max_gps", "max_gppu", "max_compu", "max_compes", "max_comps", "max_cppu", "max_gponents", "max_processes", "max_pus", "max_cappu", "max_ipors", "max4processos", "max_pu", "max4cpes", "max_cps", "max_puses", "max_capu", "max_compors", "max4cps", "max_processs"], "cpu": ["core", "cp", " process", "port", "component", "pu", "gpu", "node", " chip", " proc", " nic", "us", "cum", "comp", "nic", "pkg", " mem", "uu", "mem", "socket", "bean", "percent", " cp", "currently", "u", "num", "linux", "check", "cmp", "tp", "ruby", "gc", "bench", "remote", "what", "thread", "jp", "phys", "hog", "CPU", "processor", "pixel", "cache", "runner", "pool", "clock", "process", "nu", "current", "worker", "pid", "common", "proc", "alloc", "goal", " pc", " quota", " CU", "pc", "instance", " performance", " cu", "util", " ip", "mx", "pai", "prof", "boot", "ip", "oton", " processor", " core", "computer", "\u00e7", "cu", "ct", " runtime", "coin", "CP"], "s": ["ls", "j", "south", "S", "q", "l", "sg", "is", "sv", "ss", "p", "z", "g", "n", "sl", "txt", "set", "ds", "qs", "csv", "sql", "m", "b", "space", "fs", "ps", "js", "ns", "w", "ms", "ts", "spec", "str", "sts", "eps", "rs", "an", "v", "h", "gs", "sb", "ats", "sq", "os", "t", "se", "sp"]}}
{"project": "qemu", "commit_id": "8ad9fa5d8be7fd04e723020088eca664971eb363", "target": 1, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}", "idx": 921, "substitutes": {"command": ["domain", "template", "message", "code", "value", "directory", "Command", "text", "from", "description", "query", "power", "mode", "menu", "sequence", "path", "action", "m", "password", "condition", "start", "request", "type", "execute", "connection", "location", "file", "buffer", "context", "attribute", "pattern", "name", "target", "address", "program", "channel", "help", "direction", "prefix", "exec", "cmd"], "bandwidth_limit": ["bandWidth_limit", "bandwidth_lim", "bandWidth_line", "bandWidth_lim", "bandwidth_block", "bandwidth_policy", "bandWidth_limits", "bandWidth_policy", "bandwidth_line", "bandwidth_limits"], "async": ["nasallel", "masync", "asallel", "ASYyn", "masynchronous", "asaryn", "asarsync", "asarynchron", "nasynchron", " asallel", "ASYynchron", "masallel", " asynchron", "asynchron", "asynchronous", "ASYsync", "nasync", "asarync", "ASsync", "ASyn", "nasynchronous", "assync", "ASynchron", " asynchronous", "ASync", "masynchron", "ASYync", "asyn"], "s": ["ls", "c", "p", "es", "n", "ses", "set", "params", "gets", "sc", "services", "its", "conf", "ports", "cs", "spec", "ies", "h", "gs", "sb", "args", "sol", "os", "d", "stats", "sv", "actions", "settings", "session", "vs", "details", "ers", "ds", "qs", "m", "less", "storage", "ex", "bs", "sing", "ims", "sam", "ties", "hs", "sts", "pers", "ins", "states", "sq", "acs", "self", "S", "l", "rest", "ss", "z", "als", "sl", "sa", "utils", "locks", "ns", "y", "ms", "ts", "changes", "v", "tests", "se", "ops", "sp", "sys", "status", "sh", "is", "stat", "g", "r", "b", "fs", "aws", "ps", "js", "w", "e", "as", "sports", "lines", "rs", "ats", "st", "state"], "f": ["fp", "d", "fc", "alf", "l", "ff", "c", "far", "z", "p", "g", "fa", "xf", "r", "fac", "sf", "m", "lf", "i", "b", "fed", "fs", "ft", "af", "form", "tf", "ef", "fi", "file", "cf", "rf", "w", "fe", "fr", "F", "fb", "v", "o", "fn", "bf", "t", "fm", "uf", "fo", "fd"]}}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924, "substitutes": {}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 937, "substitutes": {"env": ["proc", "ec", "test", "buf", "sh", "conn", "ev", "viron", "def", "cur", "scope", "end", "conf", "kw", "ptr", "err", "e", "en", "ctx", "con", "dest", "v", "te", "Ev", "obj", "eng", "map"], "spapr": ["spajrus", "spaperen", "sparpcr", "spapren", "spaptir", "spapsir", "spapR", "spapeir", "papren", "sparpr", "spaprus", "spaper", "papir", "papr", " spiprus", "spapsR", "spipR", "spajcr", "spiprus", " spipr", "papsr", "spapsr", "spapcr", "spapir", "sparpR", "spipcr", " spapcr", "spapeR", "spipr", " spapR", "spaptr", "spaptR", "spajR", "papR", "spajr", "papsir", "spapsren", "papsR", " spipcr", "papsren", " spaprus", " spipR", "sparprus", "spaptren"], "opcode": ["oprec", "npcodes", "pcodes", "moprec", "mopcodes", "opcodes", "npcc", "opcc", "mopcc", "prec", "mopcode", "pcc", "pcode", "npcode", "nprec"], "args": ["related", "bugs", "values", "aux", "stats", "atts", "arr", "limits", "actions", "seconds", "objects", "words", "workers", "names", "xs", "app", "qs", "roots", "vals", "params", "fs", "fields", "members", "aws", "modules", "parts", "js", "ns", "bs", "users", "conf", "ims", "flags", "arms", "ms", "terms", "ts", "keys", "grades", "ams", "points", "changes", "ras", "range", "ags", "blocks", "bits", "gs", "arg", "days", "apps", "cmd", "Args"], "dev": ["proc", "d", "test", "device", "er", "rent", "usb", "adv", "conn", "dep", "dd", "ev", "hw", "DE", "app", "debug", "dem", "ds", "var", "van", "develop", "def", "priv", "mem", "browser", "gu", "local", "der", "den", "w", "cam", "ptr", "ver", "Device", "home", "de", "go", "DEV", "db", "tech", "ther", "v", "nt", "driver", "av", "ve", "det", "development", "des", "Dev", "obj", "eng", "cmd"], "rtce": ["rte", "tced", "aptced", "rtcer", "ptced", "rtte", "tcer", "rtcy", "mtces", "mtcle", "mtce", "rotced", "ptces", "rotcy", "mtced", "rtcle", "rcer", "rotcer", "tces", "rtced", "tte", "rces", "ptcer", "ptte", "rentced", "aptce", "aptcer", "rotce", "rentce", "ptcy", "ptce", "tce", "rce", "aptcy", "rentcle", "rtces", "tcle", "rentces"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n", "idx": 941, "substitutes": {"obj": ["j", "inst", "oid", "tmp", "instance", "vr", "object", "bh", "p", "org", "conn", "attr", "hw", "ref", "txt", "onet", "og", "act", "cont", "cmp", "att", "impl", "xy", "js", "ex", "opt", "ist", "ctx", "ob", "Obj", "nt", "o", "expr", "ot", "os", "t", "serv", "cmd", "typ"], "v": ["vc", "j", "q", "l", "vu", "vis", "c", "V", "vr", "view", "sv", "qv", "p", "conv", "g", "n", "ev", "vs", "r", "vt", "m", "vim", "b", "nv", "i", "vp", "vi", "tv", "vm", "cv", "w", "h", "uv", "o", "f", "ve", "t"], "opaque": ["opencode", "epcode", "epz", "epaque", "appaz", "openaz", "opz", "opaz", "appcode", "openz", "appaque", "openaque", "appz", "opcode", "epaz"], "name": ["data", "ni", "id", "NAME", "nam", "key", "word", "c", "no", "san", "text", "term", "n", "init", "attr", "names", "path", "black", "ame", "part", "info", "def", "type", " names", "ns", "cap", "comment", "error", " Name", "str", "nm", "Name", "na", "prefix", "t", "mem", "cmd"], "errp": ["usrpa", " Errp", "usrP", "cerpa", " Errps", "rrp", "errorp", "rrper", "cerp", "errorpa", "usrbp", "errpa", "erP", "errper", "erp", "errorps", "errps", "rrps", "cerP", "errbp", "erpa", "cerbp", "erbp", "errorper", "rrpa", "errP", " Errper", " Errpa", "usrp"], "s": ["sys", "sis", "ls", "S", "c", "sg", "is", "sv", "ss", "p", "source", "n", "session", "ses", "ds", "m", "b", "fs", "ps", "js", "ns", "sd", "sam", "ts", "cs", "sm", "rs", "sp", "o", "h", "gs", "sb", "ats", "sq", "os", "t", "serv", "ssl", "sn"]}}
{"project": "FFmpeg", "commit_id": "77d2a1ca595ebe082d35c4b624ac9a9145991494", "target": 1, "func": "ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n\n                    int *seq, int flags, int64_t timestamp)\n\n{\n\n    RMDemuxContext *rm = s->priv_data;\n\n    int ret;\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        rm->current_stream= st->id;\n\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n\n        if(ret)\n\n            return ret < 0 ? ret : -1; //got partial frame or error\n\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n\n            (ast->deint_id == DEINT_ID_INT4) ||\n\n            (ast->deint_id == DEINT_ID_SIPR)) {\n\n            int x;\n\n            int sps = ast->sub_packet_size;\n\n            int cfs = ast->coded_framesize;\n\n            int h = ast->sub_packet_h;\n\n            int y = ast->sub_packet_cnt;\n\n            int w = ast->audio_framesize;\n\n\n\n            if (flags & 2)\n\n                y = ast->sub_packet_cnt = 0;\n\n            if (!y)\n\n                ast->audiotimestamp = timestamp;\n\n\n\n            switch (ast->deint_id) {\n\n                case DEINT_ID_INT4:\n\n                    for (x = 0; x < h/2; x++)\n\n                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n\n                    break;\n\n                case DEINT_ID_GENR:\n\n                    for (x = 0; x < w/sps; x++)\n\n                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n\n                    break;\n\n                case DEINT_ID_SIPR:\n\n                    avio_read(pb, ast->pkt.data + y * w, w);\n\n                    break;\n\n            }\n\n\n\n            if (++(ast->sub_packet_cnt) < h)\n\n                return -1;\n\n            if (ast->deint_id == DEINT_ID_SIPR)\n\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n\n\n             ast->sub_packet_cnt = 0;\n\n             rm->audio_stream_num = st->index;\n\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n\n            int x;\n\n            rm->audio_stream_num = st->index;\n\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n\n            if (ast->sub_packet_cnt) {\n\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n\n                ast->audiotimestamp = timestamp;\n\n            } else\n\n                return -1;\n\n        } else {\n\n            av_get_packet(pb, pkt, len);\n\n            rm_ac3_swap_bytes(st, pkt);\n\n        }\n\n    } else\n\n        av_get_packet(pb, pkt, len);\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n#if 0\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n\n\n            seq |= (timestamp&~0x3FFF);\n\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n\n        }\n\n    }\n\n#endif\n\n\n\n    pkt->pts = timestamp;\n\n    if (flags & 2)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n\n}\n", "idx": 944, "substitutes": {"rm": ["mr", "mt", "arm", "tmp", "mb", "bm", "rom", "drm", "RM", "pm", "ref", "r", "lamm", "pb", "mp", "rb", "m", "res", "rw", "mx", "md", "wm", "asm", "mem", "irm", "dm", "sr", "vm", "mk", "ctx", "rr", "gc", "nm", "rt", "sm", "reg", "rpm", "rs", "am", "ha", "rem", "sb", "ram", "gm", "raf", "re", "fm", "rn"], "ret": ["mt", "j", "RET", "try", "status", "jp", "dt", "Return", " RET", "fun", "ref", "result", "r", "deg", "lt", "nil", "rect", "out", "cb", "lib", "res", "full", "lit", "ft", "red", "gt", "Ret", " Ret", "err", "ort", "tn", "rev", "rt", "alt", "re", "ter", "print", "reg", "val", "v", "rets", "pret", "nt", "nz", "det", "rem", "tr", "reset", "flag", "elt", "t", "len", "cmd"], "x": ["php", "d", "j", "fx", "add", "l", "xc", "step", "xxxx", "z", "p", "g", "n", "lex", "dx", "xi", "xf", "r", "index", "xs", "inx", "any", "xa", "ax", "m", "ox", "i", "mx", "tx", "check", "at", "xe", "ex", "xy", "xml", "xt", "ux", "y", "xxx", "im", "xp", "e", "w", "xx", "el", "px", "rx", " xx", "yx", "ix", "v", "cross", "xd", "on", "h", "wx", "xxxxxxxx", "f", "xes", "t", "X"], "ast": ["aft", "mt", "stan", "bound", "sta", "asts", "ard", "past", "ream", "ief", "sc", "asting", "hop", "cast", "ann", "an", "am", "est", "admin", "art", "asted", "mem", "a", "asm", "ld", "ma", "test", "acl", "list", "any", "pb", "ess", "dist", "act", "at", "ack", "ist", "um", "sam", "and", "each", "nt", "ost", "elt", "esta", "std", "ace", "some", "rest", "addr", "all", "quest", "part", "ord", "ed", "sw", "hd", "err", "best", "ared", "ts", "cest", "str", "amd", "ag", "old", "wal", "ata", "irst", "must", "ram", "na", "aster", "cmd", "mast", "et", "aw", "stone", "nd", "blast", "sh", "tt", "ab", "ase", "tx", "md", "def", "apt", "as", "acy", "ad", "st", "raw", "ac", "store", "AST"], "sub_packet_cnt": ["sub_packet_countcount", "sub_packet_ccount", "sub_packet_nnd", "sub_packet_nnt", "sub_packet_nst", "sub_packet_pnd", "sub_packet_hount", "sub_packet_nount", "sub_packet_curount", "sub_packet_hnd", "sub_packet_cnd", "sub_packet_curcount", "sub_packet_curnt", "sub_packet_curst", "sub_packet_hcount", "sub_packet_count", "sub_packet_pnt", "sub_packet_hnt", "sub_packet_cst", "sub_packet_countount", "sub_packet_ncount", "sub_packet_pount", "sub_packet_pcount", "sub_packet_countst", "sub_packet_countnt"]}}
{"project": "qemu", "commit_id": "92b3eeadd9bc72f1f4e5ba1f62a289dc0190e88f", "target": 1, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 946, "substitutes": {"parent": ["ma", "initial", "net", "tmp", "host", "object", "port", "component", "p", "up", "g", "child", "paren", "server", "page", "mother", "form", "associated", "man", "ip", "local", "owner", "Parent", "pool", "remote", "per", "parents", "root", "peer", "unit", "point", "base", "master", "self"], "part": ["work", "piece", "Part", "word", "value", "host", "object", "component", "joined", "p", "half", "PART", " parts", "path", "other", "star", "start", "pad", "parts", "local", "block", "trans", "name", "comp", "str", "partial", "root", "pair", " PART", "prefix", "art", "base", "join"], "prop": ["proc", "property", "acc", "cp", "func", " props", "op", "jp", "ph", "po", "phys", "buf", "tmp", "term", "p", "stat", "dep", "attr", "fac", "pb", "plot", "cfg", "pp", "mp", "coord", "lit", "pos", "msg", "info", "priv", "def", "req", "att", "prot", "ps", "pr", "perm", "opt", "conf", "desc", "Prop", "comp", "pl", "sty", "pkg", "pred", "pt", "properties", "typ", "expr", "col", "resp", "par", "rep", "rel", "feat", "obj", "supp", "cmd", "pro"]}}
{"project": "qemu", "commit_id": "196fe23734ca8888ca0275ad203ccb0d20907e6d", "target": 1, "func": "static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n", "idx": 961, "substitutes": {"s": ["ls", "d", "S", "q", "c", "is", "sv", "ss", "p", "z", "es", "g", "n", "session", "r", "ses", "sa", "ds", "space", "b", "fs", "sc", "ps", "js", "ns", "state", "y", "w", "ts", "sts", "rs", "v", "h", "sb", "st", "so", "t", "se", "self", "sp"], "req": ["j", "require", "q", "usr", "jp", "qq", "uj", "p", "quest", "attr", "r", "crit", "comm", "decl", "res", "rw", "tx", "msg", "info", "seq", "qt", "request", "quick", "dq", "requ", "js", "conf", "desc", "compl", "err", "rec", "ctx", "rr", "pkg", "ind", "Resp", "reg", "urg", "wx", "resp", "sq", "ire", "rel", "cmd", "pro"], "iu": ["gru", "iao", "ii", "iq", "uin", "inqu", "uj", "wi", "tif", "pu", "xi", "agi", "ic", "ugi", "qi", "ief", "gpu", "ici", "ru", "isu", "fu", "ue", "ei", "eni", "i", "ua", "u", "ui", "qt", "au", "udi", "asu", "ij", "its", "aci", "mu", "rin", "eu", "ou", "ifa", "iov", "ie", "iw", "ti", "ipl", "ipp", "wei", "ia", "tu", "cu", "uu", "ieu", "nu", "hu", "itus", "lu", "gui", "si", "uci", "imei", "ri", "ib"], "rsp": ["wrsp", "RSP", "rjp", "prply", "crsp", "rosp", "rcap", " resp", "Rply", "rstr", " rpc", "rssp", "rply", "rpp", "prme", "srosp", "rrdb", "resp", "rrtr", "wrresp", "rsync", "rpc", "rerosp", "rspl", "rcjp", "rersync", "wrcap", " rpt", " rsw", "rjs", "rersp", "rpar", "wrjs", "rcss", "prpt", "rrply", "rrresp", "rrcap", "srsw", "rrsync", " rosp", "rrpt", "rrsw", " rpl", "crjp", "rspp", "rrme", "rsjp", "prSP", "rrjs", "srSP", "Rsp", "rrpc", "srsp", "rerresp", " rcap", " rme", "rcso", "rpl", " rdb", "srdb", " rSP", "crso", "rme", "rcSP", "prpc", "rrsp", "mrply", "mrSP", "rsss", "rsw", "rcply", "rrpp", "rcsp", "crss", "rrpl", "rpb", "prsp", "prpb", "Rpb", "rso", "prresp", "rSP", "mrsp", "rcpb", " rsync", "rdb", " rresp", " rply", "sresp", "prpar", "srply", "rresp", " rtr", "rpt", "rss", " rpar", "rrosp", "rsso", " rpp", "mrosp", "rtr", " rjs", "rrpar"]}}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963, "substitutes": {"timer": ["mr", "meter", "monitor", "transfer", "message", "builder", "trace", "er", "dt", "tim", "instance", "later", "term", "sim", "actor", "txt", "trigger", "definition", "iter", "server", "her", "counter", "processor", "memory", "icker", "header", "duration", "msg", "older", "controller", "tm", "walker", "tp", "time", "loader", "activity", "writer", "ester", "cell", "vm", "buffer", "player", "ptr", "err", "span", "finder", "runner", "taker", "ter", "manager", "bench", "imer", "Timer", "clock", "wrapper", "handler", "cer", "event", "peer", "dim", "worker", "iler", "timeout", "t", "tc", "ger", "tick", "this"], "count": ["total", "Count", "batch", "number", "message", "ctr", "data", "list", "size", "code", "c", "z", "all", "record", "only", "stat", "n", "index", "counter", "set", "sum", "force", "num", "info", "check", "cache", "found", "amount", "time", "report", "call", "conf", "len", "gc", "now", "empty", "nt", "frequency", "ct", "ount", "hash", "current", "max", "reset", "latest", "nb", "base", "length"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, const char *backing_file_str,\n\n                  const char *filter_node_name, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *iter;\n\n    BlockDriverState *overlay_bs;\n\n    BlockDriverState *commit_top_bs = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        return;\n\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n\n\n\n\n    /* Insert commit_top block node above top, so we can block consistent read\n\n     * on the backing chain below it */\n\n    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,\n\n                                         errp);\n\n    if (commit_top_bs == NULL) {\n\n        goto fail;\n\n\n\n\n\n    commit_top_bs->total_sectors = top->total_sectors;\n\n    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));\n\n\n\n    bdrv_set_backing_hd(commit_top_bs, top, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    s->commit_top_bs = commit_top_bs;\n\n    bdrv_unref(commit_top_bs);\n\n\n\n    /* Block all nodes between top and base, because they will\n\n     * disappear from the chain after this operation. */\n\n    assert(bdrv_chain_contains(top, base));\n\n    for (iter = top; iter != base; iter = backing_bs(iter)) {\n\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n\n         * at s->base (if writes are blocked for a node, they are also blocked\n\n         * for its backing file). The other options would be a second filter\n\n         * driver above s->base. */\n\n        ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                 errp);\n\n        if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n", "idx": 971, "substitutes": {"job_id": [" job_bid", "job_Id", " job_ID", "job_bid", "job_ID", "job2Id", " job_uid", "job_ids", "job2ids", " job_Id", "job2id", " job_ids", "job2bid", "job_uid"], "bs": ["sys", "ls", "stats", "tmp", "bc", "bh", "vs", "ab", "pb", "bp", "box", "bed", "b", "fs", "ubs", "lb", "BS", "lbs", "obs", "ps", "its", "bb", "js", "bt", "bos", "ns", "sub", "local", "bi", "bis", "as", "ts", "cs", "ob", "bin", "bps", "rs", "bits", "blog", "bas", "gs", "sb", "os", "obj", "ubis"], "base": ["sys", "bound", "template", "parent", "id", "basic", "tmp", "bottom", "list", "las", "to", "upper", "server", "bp", "ase", "bit", "b", "space", "fs", "bot", "BS", "Base", "it", "bar", "bare", "boot", "based", "ip", "http", "local", "file", "bat", "bi", "buffer", "kit", "as", "area", "origin", "bal", "bo", "db", "clone", "null", "root", "bas", "super", "socket", "back"], "top": ["sys", "template", "parent", "head", "tmp", "bottom", "status", "op", "jp", "las", "Top", "soc", "p", "meta", "to", "upper", "pb", "server", "table", "part", "above", "bot", "clip", "at", "type", "title", "ps", "job", "tor", "boot", "t", "local", "file", "best", " TOP", "copy", "name", "origin", "there", "first", "pop", "bo", "null", "target", "client", "single", "tops", "root", "TOP", "super", "master", "this", "typ"], "speed": ["interface", "status", "size", "skip", "peed", "height", "tt", "ss", "limit", "seek", "row", "read", "score", " speeds", "start", "sc", "weight", "new", "zero", "type", "Speed", "sw", "ctl", "SIZE", "buffer", "fps", "stream", "fast", "spec", "name", "EED", "priority", "ize", "scale", "scroll", "driver", "screen", "timeout", "state", "sync", "length"], "on_error": [" on_change", " on_err", "onewerr", " onjchange", " on_success", "on_err", " onjsuccess", "on___error", " onjerr", "on___success", "on___change", "onewerror", "onewsuccess", "onjerr", "on___err", "onewchange", "onjerror", "onjchange", "onjsuccess", "on_change", " onjerror", "on_success"], "backing_file_str": ["backing_file_name", "backing_node_url", "backing_node_name", "backing_file_string", "backing_file_url", "backing_node_string", "backing_node_str"], "filter_node_name": ["filter_nodefilestr", "filter_file_list", "filter_nodefiletype", "filter_node_type", "filter_file_str", "filter_nodefilename", "filter_file_type", "filter_node_str", "filter_node_list", "filter_file_name", "filter_nodefilelist"], "errp": [" errphp", "ererps", "nerphp", " errping", "usrpa", " erP", "derp", "orderp", "errphp", " erphp", "derping", "ererP", " erp", "rrp", "nerpa", "usrping", "errorp", " errpa", "errorpa", " errP", "errorping", "errpa", "derP", " errps", " erps", "erP", "rrP", "nerp", "nerps", "ererpa", "errorP", "erp", "orderphp", "orderps", "erphp", "errps", "derpa", "errorps", "errping", "erps", "rrps", "usrps", "ererp", "rrpa", "errP", "orderpa", "usrp"], "s": ["ls", "j", "S", "stats", "c", "sv", "ss", "p", "conv", "g", "n", "r", "ses", "comm", "ds", "qs", "m", "i", "b", "fs", "less", "ps", "its", "js", "ns", "state", "ims", "fps", "cs", "ts", "grades", "sports", "hs", "rs", "single", "h", "gs", "sb", "ats", "os", "sq", "rates", "t", "ssl"], "reopen_queue": ["reopenerque", "reopen_file", "reopen_list", "reopen___q", "reapplyetbutton", "reopen_server", "reopenlyentry", "reclose_q", "reopenINGqueue", "reopenedqueue", "reapplyetque", "reopen_buffer", "reopen_que", "reopenerbuffer", "recreate_queue", "reopen_entry", "reopenablebuffer", "reclose_queue", "reopenetqueue", "reense_component", "reopenlybutton", "reapply_entry", "reopenablequeue", "reopenetbutton", "reopen_collection", "reopen_thread", "reopen___buffer", "reopenINGque", "reopenerue", "reopen___queue", "reopenableue", "reopenedlist", "reopen___list", "reopenableque", "reclose_buffer", "reopenedfile", "reopen_target", "reopenINGserver", "reopen_button", "reapplyetentry", "reclose_server", "reopenerqueue", "reapplyetqueue", "reopenetque", "reopen_ue", "reclose_collection", "recreate_que", "reapply_button", "reopenlyqueue", "reclose_file", "reopenetentry", "reclose_que", "reopen_q", "reapply_que", "reclose_entry", "reclose_list", "reense_target", "reopenedcollection", "reclose_ue", "reopenlyque", "recreate_thread", "reopen_component", "reopenINGentry", "reense_queue", "reapply_queue"], "orig_overlay_flags": ["orig_overline_posts", "orig_overlay_vals", "orig_override_flags", "orig_overplay_flags", "orig_overlay___fs", "orig_overline_files", "orig_overline_flags", "orig_overlay_states", "orig_overlay_flag", "orig_overlay_posts", "orig_overline_states", "orig_overlay_fs", "orig_overlay_links", "orig_overplay_ags", "orig_overplay_args", "orig_overlay___vals", "orig_overlay_ags", "orig_override_bits", "orig_overlaysflags", "orig_overlay_bits", "orig_overlay_files", "orig_overline_links", "orig_override_fs", "orig_overlay_args", "orig_overlaysfiles", "orig_override_vals", "orig_overlay___bits", "orig_overplay_flag", "orig_overlaysstates", "orig_overlay___flags"], "orig_base_flags": ["orig_base2flag", "orig_base32flags", "orig_base32tags", "orig_base_tags", "orig_local00ants", "orig_Base_ants", "orig_base_packages", "orig_baselyants", "orig_base00ants", "orig_Base2files", "orig_base2flags", "orig_local_packages", "orig_base9ants", "orig_local_ants", "orig_Base_flags", "orig_Base2fs", "orig_Base_files", "orig_Base_fs", "orig_base2files", "orig_local00flags", "orig_base_ags", "orig_base_flag", "orig_Base2flag", "orig_Base_ags", "orig_local00packages", "orig_baselyflags", "orig_local_flags", "orig_base_fs", "orig_Base_flag", "orig_base32flag", "orig_baselyags", "orig_base_ants", "orig_base9packages", "orig_base_files", "orig_base00packages", "orig_base00flags", "orig_base9flags", "orig_base2fs", "orig_Base2flags"], "iter": ["sys", "stack", "id", "inner", "initial", "head", "rest", "pri", "iterator", "init", "upper", "server", "stable", "res", "cli", "valid", "extra", "loader", "based", "ip", "accept", "bi", "here", "rev", "loop", "super", "si", "rel", "chain"], "overlay_bs": ["overlayablebos", "overlay32bps", "overlap_lbs", "overlay_lbs", "overhang_bps", "overlap_bs", "overlay_bytes", "overlay32bs", "overlayablebytes", "overline_lbs", "overlay_ns", "overhang_bs", "overlay_BS", "override_ns", "override_bytes", "overlay_bu", "overlay32fs", "overaque_sb", "overline_b", "overlay3ns", "overlay3bos", "overlay_bas", "overlay_sb", "overlayMbs", "overlay___bs", "overlayMBS", "overhang_bu", "overlap_bas", "overlay___b", "overlay3bs", "overlay___lbs", "overlay_bos", "overlay___BS", "overaque_bas", "override_bs", "overlayablens", "override_bos", "overlayablebs", "overlay32bu", "overlay_b", "overaque_bs", "overlay3bytes", "overlayMbas", "overlap_js", "overhang_fs", "overline_BS", "overline_bs", "overlayMsb", "overlay_bps", "overlay_fs", "overlay_js", "overaque_BS"], "commit_top_bs": ["commit_job_pb", "commit_job_BS", "commit_top_pb", "commit_job_bs", "commit_top_BS", "commit_top_obs", "commit_job_obs"], "local_err": [" local___err", "locallyerr", "local___error", "internal_err", "local_ner", " local___error", "localmyrr", "loc_rr", " local_founder", "local_func", "locmyrr", "local___err", "locallyfounder", "local_founder", " local_error", "locmymsg", "locallyerror", "localmyfunc", "local2rr", "loc_func", "locallyner", "locmyerr", "local2err", "locmyfunc", " local_arr", "localmyerr", "local2msg", "local2func", " local___founder", "locallyarr", "local___founder", "internal_buf", "local_usr", "local_error", "internal_usr", " local_ner", "local_buf", "local_rr", "localmymsg", "loc_msg", "local_msg", "local_arr", "loc_err"], "ret": ["sys", "RET", "status", "count", "Return", " RET", "result", "res", " resp", "num", "Ret", "ts", "rev", "rt", "alt", "re", "val", " mem", "rs", " alt", "flag", "resp", "t", "mem", "len"]}}
{"project": "qemu", "commit_id": "2c6942fa7b332a95286071b92d233853e1000948", "target": 0, "func": "int bdrv_is_removable(BlockDriverState *bs)\n\n{\n\n    return bs->removable;\n\n}\n", "idx": 982, "substitutes": {"bs": ["ls", "bc", "bh", "is", "bd", "ss", " BS", "vs", "pb", "ab", "bles", "bp", "ses", "ds", "qs", "b", "ubs", "fs", "lbs", "BS", "iss", "obs", "its", "bb", "bos", "aos", "ns", "bi", "bis", "as", "ts", "ba", "bes", "ks", "sts", "blocks", "bl", "sbm", "gs", "sb", "bn"]}}
{"project": "FFmpeg", "commit_id": "af7d13ee4a4bf8d708f9b0598abb8f6e22b76de1", "target": 1, "func": "static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n\n    return 0;\n\n}", "idx": 1035, "substitutes": {"link": ["image", "age", "Link", "l", "match", "tool", "handle", "ref", "query", "index", "label", "lib", "links", "filter", "load", "lock", "file", "plug", "disk", "group", "frame", "address", "light", "line", "ink", "linked", "map"], "samplesref": ["samplesRef", " samplesre", " sampsRef", " sampsreference", " sampsre", " samplesRef", "samplesre", "soundsre", "sampsref", "sampsRef", "soundsreference", " sampsref", "sampsreference", "soundsRef", " samplesreference", "samplesreference", "soundsref", "sampsre"]}}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n", "idx": 1038, "substitutes": {"options": ["pps", "steps", "values", "abilities", "ptions", "stats", "phones", "atts", "op", "issues", "actions", "meta", "settings", "als", "faces", "checks", "times", "allows", "caps", "details", "weights", "names", "includes", "plates", "roots", "links", "vals", "oops", "params", "fs", "zero", "ps", "parts", "config", "opt", "ims", "errors", "orders", "flags", "terms", "ports", "ts", "finals", "keys", "pins", "points", "changes", "option", "classes", "offs", "aps", "events", "types", "tops", "styles", "versions", "Options", "results", "IONS", "uploads", "args", "os", "rules", "apps", "ices", "items", "lets", "ops", "tools"], "errp": ["ererps", "rrping", "scorepkg", "scorepa", "latepa", "derpb", "scorep", "errorpt", "derwp", "ererpkg", "ferf", "arrcp", "derp", "lrpb", "riskm", "ererfp", "ererpt", "errpkg", "rrp", "rrf", "lrp", "errorp", "arrp", "ererping", "ererm", "latepkg", "errorping", "errpa", "ererpb", "arrf", "erercp", "ererpa", "ferp", "rrm", "rrpt", "errorps", "derpa", "errps", "errping", "errm", "riskfp", "rrps", "errwp", "riskp", "latepat", "ferpa", "riskcp", "errpat", "fercp", "errfp", "rrfp", "arrpa", "errpt", "lrwp", "rrcp", "ererp", "errpb", "ererwp", "lrpa", "latep", "errf", "errcp", "rrpa", "ererpat", "scorepat"], "ov": ["mt", "oid", "OV", "vo", "vr", "hov", "kov", "uj", "erv", "ow", "rov", "lov", "oh", "og", "ovan", " tv", "van", "nv", "ova", "oval", "va", "off", "vp", "VOL", "iv", "tv", "oc", "oi", "iov", "ove", "sov", "ovi", "osh", "aven", "orf", "nov", "vol", "uv", "iev", "ocr", "o", "oo", "av", "gov", "fo"], "obj": ["data", "j", "inst", "tmp", "op", "po", "obo", "arr", "bj", "instance", "object", "org", "n", "attr", "ref", "txt", "onet", "out", "rb", "orig", "cont", "adj", "opp", "obs", "cmp", "att", "pr", "impl", "js", "opt", "Object", "err", "oss", "ctx", "oj", "Obj", "ob", "ind", "str", "bo", "alt", " ob", "od", "nt", "vol", "o", "expr", "Ob", "ot", "ck", "os", "elt", "json", "buff"], "qdict": ["qdb", "sqdict", "qdir", "qudict", "qbody", "iqstr", "qdef", "qtd", "qtdir", "sqstr", "qualdict", "qstr", "iqdef", "qqstr", "dqbody", "qudef", "qqdb", "sqtd", "sqdef", "qubody", "qqdef", "qualdef", "sqds", "qqds", "qudir", "qqdict", "qjson", "qqcompl", " qds", "qualtd", "sqcompl", "dqdict", " qcompl", "qutd", "qudom", "sqjson", "qtbody", "qualjson", "qtdom", "iqcompl", "qdom", "dqdir", "dqdom", "sqdb", " qdb", "iqdict", "qujson", "qtdict", "qds", "qcompl"], "local_err": ["local__rb", "locallyelt", "local_r", "locallyerr", "local___error", " locallyederr", "locallyloc", " locallyedarr", "locallylog", "locallyfee", "local____obj", "local_conf", " local_rb", "local_rb", " local_obj", " local_r", "local____rs", "localisederr", "locityfee", "local___err", "valid___error", "localpyconn", "locallypeer", "valid_loc", "local____rb", "localitypeer", "localxcb", "valid___loc", "valid_err", "locallyerror", "local_rs", "localityerr", "local___rr", "local____err", " local_conn", "local___elt", "loc_fee", "local_conn", "localJconf", "local___arr", "locxcb", "locxconf", "locxerr", "error_fer", "localpyelt", " locally_arr", "locityerr", "localisedfer", "error_err", "locallyconn", "local_gr", "locitylog", "loc_cb", "localedarr", "localJcb", "valid___err", "local___cb", "locallyrr", "local_obj", "localxerr", "error_gr", "local__obj", " local_er", "loc_rs", "local___loc", "locitypeer", "localJrs", "local_fee", " locally_err", " locally_cb", "localityfee", "error_rr", "local_error", "localpyerr", "local_peer", "local____cb", "valid___rr", " locallyedelt", "localedelt", "localisedgr", "localedcb", "local_rr", "localxconf", "loc_peer", "valid_rr", "loc_conf", "localpyr", "local_loc", "valid_error", "local____conf", "local__err", "local_elt", "localederr", "localJerr", "local_cb", "localxrs", " local_elt", "locallyr", " locallyedcb", " locally_elt", "local_fer", "local____er", "localisedrr", "loc_log", "locxrs", "local_arr", "local_log", "localitylog", "loc_err", "local__er", "local_er"]}}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n", "idx": 1040, "substitutes": {}}
{"project": "qemu", "commit_id": "00f4d64ee76e873be881a82d893a591487aa7950", "target": 1, "func": "static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n", "idx": 1046, "substitutes": {"opaque": ["OPosit", "OPatile", "oposit", "opade", " opade", "ropsolete", " Opaque", " oposit", " Opascript", "OPsolete", " opascript", "OPaque", "OPaques", "OPascript", " opatile", "ropade", " Oposit", " opaques", "ropaque", " Opaques", " opsolete", "opsolete", "opaques", "OPade", "ropatile", "opascript", "opatile"], "s": ["sys", "sis", "ls", "S", "stats", "is", "sv", "ss", "p", "es", "als", "g", "sl", "ses", "ess", "sa", "ds", "set", "comm", "m", "i", "b", "fs", "less", "store", "series", "ps", "state", "ns", "bs", "ports", "ts", "spec", "cs", "changes", "hs", "sts", "eps", "rs", "h", "gs", "f", "sb", "ats", "st", "sq", "so", "des", "t", "a", "se", "ssl", "sp"], "data": [" name", "p", "ATA", "n", "out", "td", "output", "buffer", " advertising", "response", "de", " df", "done", "mem", "a", " info", "d", "Data", "list", "result", "kat", "ds", " sd", " extra", "name", " output", " input", "al", "json", "values", "size", "to", "wa", "dat", "res", "info", "new", "cache", "dev", " delta", "ns", "str", "db", " ed", "ata", "da", " dataset", "aw", "no", "DATA", "nd", " dc", "r", " di", "table", "vals", "extra", "def", "defined", "mu", "ta", " dat", "metadata", "w", " d", "good", "o", " td", "ad", "des", "t", " datas"], "ret": ["mt", "j", "ctr", "RET", "cat", "net", "status", "jp", "git", "code", "ext", "sec", " RET", "n", "result", "deg", "lt", "out", "res", "ft", "cont", "gt", "ll", "def", "at", "reply", "Ret", " Ret", "tn", "gc", "rt", "alt", "pt", "rev", "ter", "print", "del", "val", "db", "rets", "dr", "nt", "nz", "det", "cert", "reset", "flag", "tr", "resp", "elt", "t", "re", "back", "len", "inter"]}}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n", "idx": 1056, "substitutes": {"s": ["sys", "ls", "d", "S", "q", "stats", "er", "is", "sh", "sv", "ss", "p", "es", "source", "z", "n", "sl", "vs", "r", "ses", "comm", "set", "ds", "qs", "fs", "less", "store", "ps", "its", "js", "ns", "bs", "sw", "save", "ts", "cs", "sports", "ties", "sm", "hs", "sts", "an", "rs", "h", "gs", "sb", "ats", "st", "os", "sq", "t", "sync", "se", "sp"], "buf": ["doc", "batch", "data", "br", "tmp", "arr", "bc", "text", "window", "result", " buffer", "pb", "ref", "iter", "box", "cb", "rb", "var", "b", "pack", "msg", "orig", "seq", "vp", "bar", "pad", "vec", "uf", "block", "cap", "buffer", "cv", "cast", "ctx", "str", "Buffer", "aka", "que", "queue", "v", "bytes", "uffy", "raw", "Buff", "mem", "map", "cmd", "buff"], "len": [" length", "ls", "l", "size", "il", "L", "c", "count", "nl", "limit", "all", "n", " bl", "ref", "Len", "lib", "lf", " n", "fin", "full", "pos", "elf", "seq", "ll", "lan", "qual", "gen", "Length", "vec", "lon", "length", " l", "hl", "compl", "el", "en", "ln", " el", "un", "v", "val", "nt", "bytes", "low", "h", "f", " clen", "lis", "lc", "elt", "t", "mem"]}}
{"project": "FFmpeg", "commit_id": "5d97d9d53ea1cc2c28411ad734565372ddeccc32", "target": 1, "func": "static int check_checksum(ByteIOContext *bc){\n\n    unsigned long checksum= get_checksum(bc);\n\n//    return checksum != get_be32(bc);\n\n\n\n    av_log(NULL, AV_LOG_ERROR, \"%08X %08X\\n\", checksum, (int)get_be32(bc));\n\n\n\n    return 0;\n\n}\n", "idx": 1059, "substitutes": {"bc": ["ec", "vc", "isc", "fc", "bitcoin", "bec", "BC", "c", "pc", "xc", "nc", "cn", "soc", "dc", "ca", "pb", "bp", "usc", "comm", "cb", "cont", "sc", "bb", "oc", "tc", "arc", "circ", "gc", "bo", "cc", "ct", "icc", "cl", "cm", "gov", "lc", "mc"]}}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n", "idx": 1060, "substitutes": {"s": ["ls", "erences", "c", "p", "es", "n", "ses", "out", "set", "params", "gets", "services", "its", "conf", "ports", "cs", "grades", "ies", "events", "gs", "sb", "args", "os", "a", "d", "mods", "stats", "sand", "sv", "settings", "vs", "details", "ers", "ds", "qs", "less", "reads", "ims", "bis", "ties", "ks", "bes", "hs", "sts", "eps", "pers", "states", "ins", "sq", "S", "sets", "ss", "als", "comm", "i", "locks", "tes", "ns", "sw", "y", "ms", "ts", "changes", "v", "tests", "results", "uploads", "se", "sys", "is", "g", "times", "r", "ids", "b", "fs", "aws", "ps", "parts", "js", "sd", "ads", "comments", "e", "terms", "as", "lines", "rs", "bits", "ats", "des", "t"], "blk": [" blak", "siltk", "Blkid", " bltk", "lockg", "Blck", "clj", " blkid", "lockk", " blker", "plk", "blkt", "plak", "silck", "plkt", "brog", "brck", "bleke", "blak", "blek", "clck", " blck", "clk", "blb", "blck", "bleker", "lockak", "BLck", "slk", "lockkt", "plck", "bleck", "bleak", "Blak", "blker", "blke", "clak", "brk", "plj", "silke", " blg", "brock", "BLak", "brob", "plb", "BLkt", "bleg", "bletk", "slck", "blkid", "Blj", "Blk", "brok", "silk", "plker", "broak", "brokt", "blekt", "BLk", "blg", "brkid", "brak", "Blg", " blj", "slak", "blj", "slg", "Blkt", "brb", " blkt", " blke", "bltk"], "kind": ["ko", "id", "work", "conduct", "key", "style", "ke", "half", "dir", "mode", "rank", "look", "need", "wind", "needed", "family", "kt", "md", "sk", "info", "start", "shape", "type", "cmp", "kw", "k", "context", "mk", "method", "Kind", "spec", "name", "ind", "ks", "kick", "tech", "what", "school", "magic", "rend", "pick", "brand", "sky", "cmd", "K", "make", "th", "direction", "state", "kid", "module", "kernel"], "version": ["software", "size", "virtual", "VERSION", "actor", "description", "major", "server", "mode", "Version", "platform", "controller", "iso", "iv", "tag", "browser", "command", "ver", "spec", "release", "v", "vision", "program", "versions", "brand", "root", "length", "vector"], "serial": ["template", "id", "number", "human", "sex", "device", "quant", "encrypted", "virtual", "chip", "initialized", "description", "custom", "util", "small", "native", "social", "volume", "controller", "series", "history", "special", "dev", "iso", "iv", "ser", "final", "local", "normal", "ver", "specific", "integer", "release", "random", "material", "erial", "mot", "ident", "address", "primary", "morph", "mobile", "raw", "phone", "kid", "vector"], "model": ["data", "template", "id", "image", "software", "human", "device", "size", "virtual", "description", "label", "power", "mode", "machine", "link", "m", "form", "volume", "controller", "mod", "type", "variable", "dev", "product", "tag", "length", "shell", "location", "iso", "map", "file", "command", "name", "ver", "Model", "spec", "models", "address", "brand", "event", "morph", "state", "module", "vector", "feature"], "wwn": ["www", "ewmn", "wmn", "wbgn", " www", "Www", "wbwn", "wbnd", "ewgn", "ewnd", "whnt", "whgn", "wbkn", "wnd", "ewwn", " wnt", "Wmn", "Wnt", "Wkn", "Wnd", "whww", " wgn", "Wgn", "wgn", "wkn", " wkn", " wnd", " wmn", "wnt", "Wwn", "whwn"], "cylinders": ["ylresses", "filinders", "celeds", "clinders", "cylbers", "shellinders", "cyllins", "silinders", "ylriers", "harmeds", "cellections", "cellinders", "harmiants", "fileds", "ylinders", "ylbers", "cylresses", "shellinder", "harminders", "cylriers", " cylinder", "cellriers", "silriers", "cllins", "filiants", "celiants", "fillections", "cellresses", "clinder", "shelllins", "celinders", "harmlections", "cyleds", "cyliants", "cellbers", " cyllins", "silresses", "cyllections", "silbers", "cylinder"], "heads": ["masters", "rows", "leases", "mods", "head", "thens", "atts", "outs", "limits", "aunts", "workers", "uts", "adders", "quarters", "forms", "roots", "maps", "links", "locks", "loads", " Heads", "views", "HEAD", "ths", "reads", "history", "hops", "storms", "utes", "planes", "uses", "docs", "tails", "headed", "fps", "arms", "headers", "pins", "holders", "guards", "offs", "helps", "uds", "cles", "blocks", "h", "olds", "tops", "ocks", "mers", "hours", "cycles"], "secs": ["seqls", "reqds", "secids", " secrs", "reqrs", "secrs", "seqrs", "ecls", " secds", "seqts", "Secs", "secds", "seqs", "ecids", "Secrs", "sects", "secls", " sects", "seqds", "reqs", "reqts", "Secls", "Secids", "ecs", "ecrs", "seqids"], "chs_trans": ["chs_Trans", "chms_tr", "chms_translation", "chs2tr", "chs_tr", "chls_transform", "chs_rel", "chls_Trans", "chs2translation", "chls_trans", "chss_rans", "chss_rel", "chms_trans", "chms_Trans", "chs_rans", "chss_Trans", "chs2transform", "chs2trans", "chs_translation", "chs_transform", "chss_trans", "chs2Trans"], "nb_sectors": ["nb___seors", "nb_seors", "nb_subs", "nb_wevers", "nb_webs", "nb_veors", "nb_sections", "nb_bectors", "nb___sectors", "nb_pegments", "nb_peapters", "nb_veivers", "nb_vevers", "nb_suctors", "nb_Secs", "nb_spectors", "nb_pectors", "nb_segments", "nb_suors", "nb_seapters", "nb_speapters", "nb_beors", "nb_spegments", "nb_severs", "nb_spections", "nb_Sections", "nb_beivers", "nb___webs", "nb___wectors", "nb_vecs", "nb_peivers", "nb_vebs", "nb_pecs", "nb___weors", "nb_sebs", "nb_speors", "nb_seivers", "nb___severs", "nb_Seapters", "nb_suvers", "nb_begments", "nb_wectors", "nb___sebs", "nb_peors", "nb_pections", "nb_secs", "nb_weors", "nb_Sectors", "nb_specs", "nb___wevers", "nb_vectors", "nb_vegments"]}}
{"project": "qemu", "commit_id": "384b557da1a44ce260cd0328c06a250507348f73", "target": 1, "func": "int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n", "idx": 1089, "substitutes": {"dev": ["data", "d", " device", "test", "device", "env", "buf", "adv", "api", "handle", "port", "p", "conn", "g", "ev", "hw", "window", "server", "app", "dem", "out", "devices", "link", "var", "develop", "info", "def", "priv", "mem", "pad", "connection", "conf", "block", "w", "Device", "ctx", "nav", "spec", "bus", "de", "go", "DEV", "db", "pt", "v", "nt", "client", "h", "hid", "event", "ad", "av", "ve", "des", "Dev", "obj", "cmd"], "iova": ["piiva", "diova", "iona", "giova", "vona", "biona", "siov", "piova", "giona", "sioco", "siova", "iovan", " ioco", " iovan", "diiva", "sioa", "iove", "vova", " iov", "pioco", " iiva", "biove", "ioco", "iov", "biova", "giove", " ioa", "ioa", "piov", "diov", "bioa", "pioa", "gioa", "iiva", "voa", "piovan", "diovan", "vove"], "len": ["ls", "l", "size", "iden", "L", "il", "nl", "fun", "n", "lim", "Len", "lib", "lf", "fin", "lit", "num", "pos", "seq", "lan", "ll", "cmp", "gen", "vec", "lon", "length", "hl", "compl", "el", "en", "spec", "ln", "coll", "bin", "un", "loc", "bytes", "nt", "h", "ml", "fn", "lis", "wid", "elt", "enc"], "imsg": [" simgs", "imge", "omsgd", "msgs", "imsge", "emsgs", "omsg", "imsgu", "emsgd", " simG", "imsgs", "emsm", "tmgs", "img", "epsgm", "epsgu", "omsge", "imgent", "imgs", "membersgd", "imsm", "omsgs", "tmgent", "msg", "tmgm", "tmg", "emsgm", "msG", "imsgd", "appsg", " simge", "minsg", "membersm", "imG", "appsgs", "appsgm", "emsg", "imsG", "membersgs", "imsgm", "imsgent", "minsG", "emsge", "minsgm", "omsG", "minsgu", "epsg", "omsgu", "epsG", "appsgent", "imgm", "msge", " simg", "membersg", "omsm", "omsgm"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)\n\n{\n\n    uint32_t val;\n\n    val = gic_dist_readb(opaque, offset);\n\n    val |= gic_dist_readb(opaque, offset + 1) << 8;\n\n    return val;\n\n}\n", "idx": 1107, "substitutes": {"opaque": ["opaco", " opue", "opue", "pc", "ipque", "opc", " opque", "ipaco", " opaco", "pque", "opsque", " Opaque", "obue", "pacity", " opface", " oprox", "paque", "ipface", "opacity", " Opaco", " Opacity", " Opc", "opsaque", "opque", " opc", "ipaque", "paco", "obrox", "opsue", "obque", "oprox", "pface", "opface", "opsrox", " opacity", "obaque"], "offset": ["bound", "parent", "oid", "op", "size", "shift", "offer", "addr", "encrypted", "slot", "p", "kh", "slice", "seek", "row", "from", "style", "index", "pointer", "set", "secondary", "pos", "start", "off", "at", "type", "pad", "optional", "ta", "location", "output", "error", "buffer", "command", "attribute", "oint", "alias", "origin", "Offset", "target", "address", "scroll", "o", "padding", "frequency", "sector", "position", "seed", "timeout", "point", "prefix", "length"], "val": [" value", "ul", " aval", "data", "l", "il", "value", " arg", "z", "Val", "p", "als", "cal", "slot", "sl", " bl", "pol", "AL", "vt", "out", " al", "vals", "oval", "x", "lit", "tx", "valid", "rol", " update", "it", "VAL", "pr", " eval", "vec", "state", "t", "local", "ival", "el", "pal", "pl", "aval", " ret", "ctx", "bal", " v", "ind", "eval", " el", "loc", " vec", "pt", "v", "vol", "bl", "ret", "rel", "sel", "elt", "al", "serv"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 1108, "substitutes": {"str": ["input", "data", "br", "ctr", "gr", "stri", "inst", "list", "arr", "buf", "c", "source", "text", "p", "attr", "r", "Str", "s", "txt", "out", "index", "res", "i", "b", "msg", "pos", "seq", "start", "orig", "cur", "pr", "length", "end", "buffer", "ptr", "cs", "fr", "name", "STR", "gap", "dr", "pre", "vol", "f", "tr", "st", "prefix", "t", "len", "sp"], "endptr": [" endaddr", " endreq", "endstr", "startpointer", "ENDpointer", "endaddr", "endobj", " endpointer", "ENDaddr", " endobj", "EndPtr", "Endptr", "ENDobj", "Endaddr", "endedobj", "ENDPtr", " endPtr", "ENDptr", "startstr", "endPtr", "endedreq", "endpointer", "endedptr", "startreq", "ENDreq", "Endstr", "endedpointer", "endreq", "Endpointer", "startptr", " endstr", "Endreq"], "err": ["mr", "br", "usr", " r", "gr", "cr", "eas", " res", "er", "arr", "nr", " er", " ptr", "ev", "attr", "result", "r", "iter", " rc", "ner", "rank", " Err", "exc", " expr", " ex", "res", " dr", "ox", "msg", "off", " error", "pr", "kr", "conf", "error", "diff", "der", "Er", "fr", " typ", "rr", " result", " fr", " gr", "die", "spr", "Error", "danger", "dr", " terr", "oe", "cer", "norm", "tr", "resp", " cr", " dist", "ger", " wr"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "PXA2xxState *pxa255_init(unsigned int sdram_size)\n\n{\n\n    PXA2xxState *s;\n\n    int iomemtype, i;\n\n    DriveInfo *dinfo;\n\n\n\n    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n\n\n\n    s->env = cpu_init(\"pxa255\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];\n\n\n\n    /* SDRAM & Internal Memory Storage */\n\n    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,\n\n                    qemu_ram_alloc(NULL, \"pxa255.sdram\",\n\n                                   sdram_size) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,\n\n                    qemu_ram_alloc(NULL, \"pxa255.internal\",\n\n                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);\n\n\n\n    s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n\n\n\n    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n\n\n\n    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);\n\n\n\n    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,\n\n                              s->pic[PXA2XX_PIC_MMC], s->dma);\n\n\n\n    for (i = 0; pxa255_serial[i].io_base; i ++)\n\n        if (serial_hds[i]) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 1);\n\n#else\n\n            serial_mm_init(pxa255_serial[i].io_base, 2,\n\n                           s->pic[pxa255_serial[i].irqn], 14745600/16,\n\n                           serial_hds[i], 1, 0);\n\n#endif\n\n        } else {\n\n            break;\n\n        }\n\n    if (serial_hds[i])\n\n        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n\n                        s->dma, serial_hds[i]);\n\n\n\n    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);\n\n\n\n    s->cm_base = 0x41300000;\n\n    s->cm_regs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */\n\n    s->clkcfg = 0x00000009;\t\t/* Turbo mode active */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,\n\n                    pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n\n\n\n    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n\n\n\n    s->mm_base = 0x48000000;\n\n    s->mm_regs[MDMRS >> 2] = 0x00020002;\n\n    s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n\n    s->mm_regs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,\n\n                    pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n\n\n\n    s->pm_base = 0x40f00000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,\n\n                    pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);\n\n    register_savevm(NULL, \"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n\n\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++);\n\n    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);\n\n    for (i = 0; pxa255_ssp[i].io_base; i ++) {\n\n        DeviceState *dev;\n\n        dev = sysbus_create_simple(\"pxa2xx-ssp\", pxa255_ssp[i].io_base,\n\n                                   s->pic[pxa255_ssp[i].irqn]);\n\n        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                             s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save,\n\n                    pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n", "idx": 1119, "substitutes": {"sdram_size": ["sdram_style", "sdstrom_time", "sdram_name", "sdram_time", "sdmem_name", "sdmem_SIZE", "sdram_height", "sdmem_length", "sdgram_size", "sdgram_style", "sdram_SIZE", "sdmem_size", "sdram_length", "sdstrom_height", "sdgram_format", "sdram_format", "sdstrom_size"], "s": ["ls", "c", "p", "es", "n", "ses", "set", "us", "services", "its", "t", "conf", "http", "ports", "cs", "spec", "ies", "ags", "h", "gs", "f", "his", "sb", "args", "so", "os", "a", "q", "stats", "sv", "source", "session", "vs", "details", "qs", "m", "less", "ex", "bs", "tags", "ims", "sam", "hs", "ar", "sts", "eps", "pers", "ins", "sq", "self", "j", "S", "l", "ss", "z", "als", "sl", "sa", "comm", "utils", "csv", "ns", "y", "ts", "changes", "v", "tests", "se", "sp", "scripts", "status", "is", "sh", "g", "simple", "r", "sql", "b", "fs", "aws", "ps", "parts", "js", "w", "e", "as", "sports", "rs", "in", "o", "bits", "ats", "st", "des", "store"], "iomemtype": [" qemtype", " qEMtype", " quotEMname", " qemstyle", " quotemtype", " quotEMstyle", " quotEMtype", " qymname", " qemname", " quotemunit", " qemunit", " qymstyle", " quotemstyle", " quotEMunit", " qEMunit", " qEMname", " qEMstyle", " qymunit", " qemstype", " qemsname", " qymtype", " quotemname", " qemsstyle", " qemsunit"], "i": ["multi", "j", "id", "l", "ii", "c", "is", "p", "sim", "g", "n", "xi", "ic", "index", "pi", "me", "li", "ci", "ami", "m", "b", "x", "info", "ui", "phi", "it", "gi", "ij", "ip", "oi", "y", "ims", "bi", "e", "iu", "ti", "ind", "ix", "v", "zi", "in", "mi", "o", "di", "h", "ini", "ai", "I", "si", "f"], "dinfo": ["Dinfo", "ndby", "ndinfo", "fdinformation", "dhelp", " dhelp", " dtry", " dby", "ardhelp", "rdinfo", "DInfo", "dinformation", "dfo", "Dtry", "ardinfo", " dstat", "Dby", "dinf", "ddinfo", "ardinf", "fdinfo", "dby", "ddinf", "Dinf", "ndinf", "dtry", "rdfo", "rdtry", "dstat", "dInfo", "ddstat", "Dinformation", " dInfo", "Dfo", " dfo", "fdInfo", " dinformation", "ddhelp", " dinf", "ndinformation", "ardstat", "rdinf"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int usb_device_delete_addr(int busnr, int addr)\n\n{\n\n    USBBus *bus;\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n\n\n    bus = usb_bus_find(busnr);\n\n    if (!bus)\n\n        return -1;\n\n\n\n    TAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev->addr == addr)\n\n            break;\n\n    }\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    TAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n    dev->info->handle_destroy(dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 1121, "substitutes": {"busnr": ["bootNR", "busnor", "bridgenor", "blocknor", "bootmor", "bugnr", "bugnor", "bugor", "bridgeNR", "bootnor", "busNR", " busNR", "bugNR", "blockmor", "bootnr", "bootor", "busor", "blockNR", "busmor", " busor", "blocknr", " busnor", "bridgenr", "bridgemor"], "addr": ["id", "work", "add", "eth", "inv", "arr", "host", "ext", "Address", "bind", "attr", "ref", "dir", "r", "set", "url", "act", "res", "x", "tx", "kt", "gt", "at", "ack", "pad", "att", "title", "pat", "ns", "ip", "ptr", "err", "name", "alias", "adr", "len", "gate", "rt", "alt", "ag", "loc", "has", "offset", "ix", "address", "hash", "arp", " address", "inter", "ad", "prefix", "rel", "obj", "map", "cmd"], "bus": ["Bus", "boss", "proxy", "bur", "sum", "us", "lock", "bar", "book", "board", "state", "http", "disk", "stick", "cast", "bo", "vol", "os", "socket", "back", "uss", "br", "usb", "bc", "box", "bug", "full", "ack", "hand", "bs", "file", "cpu", "bal", "loc", "nt", "driver", "chain", "total", "cat", "phys", "buf", "host", "mask", "build", "bool", "used", "cache", "plug", "pool", "db", "bill", "loop", "di", "bu", "data", "stack", "mount", "conn", "way", "util", "lib", "b", "pos", "obs", "boot", "local", "ch", "BUS", "bridge", "good", "bits", "ac", "store", " BUS"], "port": ["pit", "Port", "mt", "parent", "cp", "doc", "interface", "key", "eport", "device", "trace", "buf", "pc", "host", "handle", "next", "p", "ported", "service", "window", "pi", "fat", "server", "seat", "pp", "ping", " sport", "used", "table", "gp", "pose", "page", "pod", "pos", "info", "profile", "it", "type", "pad", "pr", "mit", "tp", "ip", "http", "file", "local", "ptr", "cam", "ports", "ort", "pool", "pt", "project", "db", "queue", "bridge", "per", "null", "v", "client", "PORT", "peer", "ve", "unit", "pid", "point", "t", "socket", "serv", "report", "pport"], "dev": ["doc", "d", "aux", "test", "add", "device", "pro", "prop", "buf", "adv", "nd", "handle", "conn", "ev", "hw", "app", "debug", "out", "dist", "dem", "ds", "var", "Dev", "develop", "info", "md", "off", "def", "priv", "prof", "req", "att", "gu", "sw", "sd", "desc", "comment", "der", "den", "cam", "err", "ver", "nav", "home", "de", "DEV", "db", "pt", "loc", "v", "val", "vision", "vol", "di", "driver", "ad", "det", "ve", "av", "ot", "des", "mem", "obj", "serv", "dis", "cmd"], "nused": ["nuse", "nbused", "noused", "navailable", "numuse", "nbuse", "nouse", "numavailable", "numfree", "numused", "nbavailable", "nofree", "noavailable", "nbfree"], "nfree": [" navailable", "nsused", "ntotal", "navailable", " ntotal", "nsfree", "numtotal", "numavailable", "numused", "numfree", "nsavailable", "nstotal"]}}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_type_number(Visitor *v, const char *name, double *obj,\n\n                                   Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qfloat_from_double(*obj));\n\n}\n", "idx": 1122, "substitutes": {"v": ["vc", "d", "j", "q", "l", "inv", "vis", "c", "V", "vr", "sv", "qv", "p", "conv", "g", "ev", "vs", "r", "vt", "m", "vim", "b", "nv", "u", "vp", "vi", "tv", "vm", "k", "cv", "w", "ver", "ov", "verb", "h", "uv", "f", "av", "vd"], "name": ["data", "j", "id", "NAME", "nam", "ma", "key", "l", "size", "word", "no", "p", "n", "init", "attr", "names", "label", "s", "path", "var", "lat", "b", "x", "ame", "num", "info", "def", "type", "title", "cap", "error", "normal", "w", "str", "pkg", "val", "Name", "named", "prefix", "t", "mem", "a"], "obj": ["proc", "sys", "inst", "fx", "func", "tmp", "po", "bj", "addr", "object", "handle", "tk", "objects", "attr", "ref", "txt", "np", "cb", "act", "pos", "off", "seq", "adj", "def", "obs", "js", "ctx", "str", "pkg", "ob", "Obj", "expr", "src", "fn", "resp", " Obj", "cmd"], "errp": ["rp", "wrP", "errr", "ErP", "rP", "rpb", "Erpb", "errpb", "wrr", "errP", "rr", "wrpb", "Erp", "Err", "wrp"], "qov": [" qkov", "qove", "gove", "quOV", " queryOV", "quov", " qovo", "gova", " queryovo", "quove", "qob", "qOV", " queryov", "quovo", "qova", " queryob", "qkov", "quova", "qukov", " qova", "qovo", " qove", "quob", " qOV", "gkov", " qob", "gov"]}}
{"project": "qemu", "commit_id": "0e01b76e7cc43068f6b8cc05297f61539ccd5279", "target": 1, "func": "static int aio_write_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n\n\n    ctx->blk = blk;\n\n    while ((c = getopt(argc, argv, \"CqP:z\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'z':\n\n            ctx->zflag = 1;\n\n            break;\n\n        default:\n\n\n            return qemuio_command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return qemuio_command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    if (ctx->zflag && optind != argc - 2) {\n\n        printf(\"-z supports only a single length parameter\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag && ctx->Pflag) {\n\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag) {\n\n        int64_t count = cvtnum(argv[optind]);\n\n        if (count < 0) {\n\n            print_cvtnum_err(count, argv[optind]);\n\n\n            return 0;\n\n        }\n\n\n\n        ctx->qiov.size = count;\n\n        blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0,\n\n                             aio_write_done, ctx);\n\n    } else {\n\n        nr_iov = argc - optind;\n\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n\n                                pattern);\n\n        if (ctx->buf == NULL) {\n\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n            return 0;\n\n        }\n\n\n\n        gettimeofday(&ctx->t1, NULL);\n\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                         BLOCK_ACCT_WRITE);\n\n\n\n        blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov,\n\n                       ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    }\n\n    return 0;\n\n}", "idx": 1130, "substitutes": {"blk": [" blak", "lbak", "Blck", " blker", "blkt", "lbw", "Blb", "brck", "lak", "blak", "blek", " blck", "blb", "blck", "BLck", "slk", "bleck", "blker", "bleak", "Blak", "lck", "brkt", "brk", "BLak", " blg", "BLkt", "slkt", "bleg", "Blk", "Blker", "lbk", "lk", "blekt", "BLb", "blew", "BLk", "lkt", "blg", "Blg", "slak", " blw", "Blkt", " blkt", "brker", "lbck", "slb", "blw"], "argc": [" argp", "argxc", "argsz", "argp", "opc", "callc", "arglc", "argsl", "argslc", "argumentxc", "argumentl", " arglc", " argz", "argsp", "argumentv", "callv", "argz", "opp", "calllc", "callxc", "argumentn", " argl", "argn", "opv", "argsc", "argumentc", "argl", "argsn", "argsxc", "argumentz", "opl", "argsv", " argn", " argxc"], "argv": [" argp", "argumentk", "argsV", "argumentvin", "argumentsv", "argumentve", "argumentm", "argp", "argsk", "extc", "argV", "argsp", "argm", "argsm", "argumentv", "argsve", "extvin", "agvin", "argumentV", "argve", "argssv", "targetm", " argk", "argk", "targetve", " argvin", " argm", "argsc", "extsv", "agc", "extv", "argsvin", "agv", "agm", "argsv", "targetv", "argvin", "argumentp", " argV", "argumentc", "targetc"], "nr_iov": [" NR_iv", "nr_voice", "nr__voc", " NR__iov", "nb__ovi", "nr__ovi", " NR__voc", "nr_iv", "nr_iop", " NR_voice", "nr__iv", " NR_iov", " NR__voice", "nb__iv", "nb_iop", "nr__iov", "nr_voc", "nb_ovi", "nr_ovi", " NR_voc", "nb_iv", " NR__iv", "nb__iov", "nr__iop", "nb_iov", "nr__voice", "nb__iop"], "c": ["ec", "vc", "d", "cp", "fc", "pc", "count", "bc", "unc", "p", "g", "n", "dc", "r", "m", "com", "i", "b", "x", "u", "ce", "C", "form", "cache", "cmp", "call", "ch", "k", "cf", "tc", "e", "cs", "con", "co", "v", "abc", "cc", "h", "ct", "o", "f", "rc", "cm", "lc", "ac", "t", "mc", "a"], "ctx": ["cp", "parent", "mom", "handle", "unc", "p", "init", "hw", "kl", "gt", "req", "ctl", "conf", "cf", "context", "xp", "pkg", "ind", "wx", "handler", "help", "yes", "Context", "ck", "resp", "timeout", "jac", "ctrl", "fw", "inner", "tk", "uj", "conv", "np", "crit", "cb", "pause", "act", "kt", "check", "cmp", "mk", "gc", "co", "hs", "loc", "nt", "cm", "warn", "std", "inst", "aux", "ork", "jp", "addr", "dc", "kj", "index", "kk", "utils", "info", "unk", "history", "call", "kw", "tc", "that", "pool", "pt", "btn", "abc", "val", "prefix", "exec", "_", "cmd", "proc", "sys", "alloc", "work", "fc", "func", "bj", "conn", "txt", "util", "cfg", "tx", "def", "tm", "tz", "config", "local", "cv", "command", "canon", "px", "ia", "cu", "cc", "ct", "lc", "iat", "obj"], "optind": ["optPtr", "optedptr", "Optcond", "letptr", "optimmind", "OptInd", "altind", "fitine", "opInd", "fitPtr", "optioncond", "optimsing", "optsing", "altinn", "optmind", "jsonmind", "optioniter", "jsonind", "optimindex", "timeoutPtr", "optedind", "optedPtr", "letind", " optInd", "trysing", "optatt", "optinn", "optedine", "opIND", "tryatt", "timeoutind", "optionindex", "letindex", " optindex", "optedmind", "optedindex", "optiminn", "timeoutmind", "optInd", "optstick", "optiter", "optine", "opindex", "optimind", "tryind", "optptr", "timeoutine", "optionptr", "altIND", "fitind", "optcond", " optinn", "Optind", "fitatt", "optionIND", " optstick", "opind", "optimatt", "optimcond", "optimstick", "fitmind", "optindex", " optIND", "Optinn", "optionInd", "tryine", "optioninn", "optimine", "optIND", "jsoncond", " optcond", "optediter", "OptIND", "optionind", "jsonstick", "fitsing", "letiter", " optmind"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n\n    int64_t cluster_index, uint16_t **refcount_block)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (offset_into_cluster(s, refcount_block_offset)) {\n\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n\n                                        PRIx64 \" unaligned (reftable index: \"\n\n                                        \"%#x)\", refcount_block_offset,\n\n                                        refcount_table_index);\n\n                return -EIO;\n\n            }\n\n\n\n             return load_refcount_block(bs, refcount_block_offset,\n\n                 (void**) refcount_block);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and potentially doing an initial refcount increase. This means that\n\n     *   some clusters have already been allocated by the caller, but their\n\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n\n     *   the search for free clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    *refcount_block = NULL;\n\n\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    if (new_block < 0) {\n\n        return new_block;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* Zero the new refcount block before updating it */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            (s->refcount_block_size - 1);\n\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n\n                              QCOW2_DISCARD_NEVER);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        /* Initialize the new refcount block only after updating its refcount,\n\n         * update_refcount uses the refcount cache itself */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite_sync(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n\n\n        /* The new refcount block may be where the caller intended to put its\n\n         * data, so let it restart the search. */\n\n        return -EAGAIN;\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far */\n\n    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);\n\n\n\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters =\n\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint64_t *new_table = g_try_new0(uint64_t, table_size);\n\n    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n\n\n\n    assert(table_size > 0 && blocks_clusters > 0);\n\n    if (new_table == NULL || new_blocks == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        new_blocks[block++] = cpu_to_be16(1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    g_free(new_blocks);\n\n    new_blocks = NULL;\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    }\n\n    return ret;\n\n}\n", "idx": 1136, "substitutes": {"bs": ["sys", "ls", "outs", "cks", "bc", "bh", "ss", "boxes", "vs", "uts", "bp", "ses", "bles", "ashes", "ds", "b", "locks", "fs", "ubs", "lbs", "BS", "obs", "its", "js", "bos", "aos", "ns", "bt", "bis", "ms", "cs", "ts", "ks", "bes", "hs", "bps", "hz", "sts", "rs", "bl", "bits", "blog", "gs", "sb", "os", "aus", "jac", "acs", "ubis"], "cluster_index": ["cluster_block", "cluster_length", "cluster1index", "cluster0block", "cluster_host", "clstrap67loc", "cluster67Index", "clstrap_Index", "cluster67index", "cluster7host", "cluster7id", "clusterPostindex", "clusters_Index", "clusters_host", "cluster1key", "clstrap_index", "cluster7index", "clusters_index", "cluster_key", "cluster0id", "clusters_id", "cluster7Index", "clusterPostlength", "cluster67loc", "clusterPostid", "clusters_key", "clusterPostIndex", "cluster_id", "cluster_loc", "cluster_Index", "clstrap_loc", "clusters_block", "cluster0key", "clusters_length", "clstrap67index", "cluster1id", "clstrap67Index", "cluster0index", "cluster1block"], "refcount_block": ["refCount_Block", "refCount_chain", "refcache_type", "refount_error", "refcount2block", "refcount_lock", "refcount___Block", "refcount_bin", "refcount_part", "refcountmyblocking", "refcoreedblocking", "refcount_error", "refcountedblock", "refcount___chain", "refcore_filter", "refcache_block", "refcountmyfilter", "refcountyblocking", "refcache_Block", "refount_block", "refcountingpart", "refcount2Block", "refcoreedblock", "refcount_type", "refcache_chain", "refcount2type", "refcount___block", "refount_part", "refCount_block", "refcountingerror", "refcount_map", "refcore_bin", "refcountedblocking", "refcount___type", "refount_lock", "refcore_block", "refcount_filter", "refcountyfilter", "refcoreedfilter", "refcount_chain", "refCount_lock", "refcountedbin", "refCount_map", "refcount___data", "refcount_Block", "refcount_blocking", "refcountyblock", "refcore_blocking", "refcoreedbin", "refcountybin", "refcount___lock", "refcount_data", "refcountmybin", "refCount_data", "refcount2chain", "refcountinglock", "refcountingblock", "refcountmyblock", "refcountedfilter"], "s": ["sys", "ls", "S", "stats", "l", "c", "is", "sv", "ss", "p", "als", "sl", "vs", "details", "ses", "comm", "ashes", "ds", "qs", "b", "fs", "less", "tes", "aws", "ps", "its", "parts", "js", "ns", "sw", "conf", "http", "ims", "bis", "ms", "as", "sam", "cs", "ts", "spec", "changes", "sm", "bes", "hs", "sts", "rs", "v", "ags", "h", "bits", "gs", "sb", "ats", "sn", "os", "sq", "ins", "args", "self", "sp"], "refcount_table_index": ["refcount_block_number", "refcount_table_size", "refcount_table_number", "refcount_block_type", "refcount_table__key", "refcount_Table_Index", "refcount_table__index", "refcount_table_ind", "refcount_table_key", "refcount_Table_ind", "refcount_block_Index", "refcount_block_index", "refcount_table__size", "refcount_table__Index", "refcount_block_key", "refcount_Table_index", "refcount_block_size", "refcount_table_Index", "refcount_table_type", "refcount_block_ind"], "ret": ["mt", "jump", "del", "usr", "RET", "cert", "try", "net", "status", "il", "value", "Return", "ext", "next", " RET", "fun", "result", "ref", "r", "deg", "lt", "out", "res", "ft", "gt", "ll", "def", "mem", "ber", "att", "Ret", "tf", "run", " Ret", "final", "err", "gc", "rt", "re", "alt", "rev", "ter", "print", "ry", "val", "rm", "rets", "arg", "nt", "reg", "hash", "body", "last", "cmd", "det", "rem", "tr", "f", "resp", "reset", "elt", "t", "flag", "back", "len", "inter"]}}
{"project": "FFmpeg", "commit_id": "95801b6a0727d6f7e6f1204ce812b1e81613307d", "target": 1, "func": "static int alac_decode_frame(AVCodecContext *avctx,\n\n                             void *outbuffer, int *outputsize,\n\n                             const uint8_t *inbuffer, int input_buffer_size)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n\n\n    int channels;\n\n    unsigned int outputsamples;\n\n    int hassize;\n\n    int readsamplesize;\n\n    int wasted_bytes;\n\n    int isnotcompressed;\n\n    uint8_t interlacing_shift;\n\n    uint8_t interlacing_leftweight;\n\n\n\n    /* short-circuit null buffers */\n\n    if (!inbuffer || !input_buffer_size)\n\n        return input_buffer_size;\n\n\n\n    /* initialize from the extradata */\n\n    if (!alac->context_initialized) {\n\n        if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: expected %d extradata bytes\\n\",\n\n                ALAC_EXTRADATA_SIZE);\n\n            return input_buffer_size;\n\n        }\n\n        if (alac_set_info(alac)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"alac: set_info failed\\n\");\n\n            return input_buffer_size;\n\n        }\n\n        alac->context_initialized = 1;\n\n    }\n\n\n\n    init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8);\n\n\n\n    channels = get_bits(&alac->gb, 3) + 1;\n\n    if (channels > MAX_CHANNELS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"channels > %d not supported\\n\",\n\n               MAX_CHANNELS);\n\n        return input_buffer_size;\n\n    }\n\n\n\n    /* 2^result = something to do with output waiting.\n\n     * perhaps matters if we read > 1 frame in a pass?\n\n     */\n\n    skip_bits(&alac->gb, 4);\n\n\n\n    skip_bits(&alac->gb, 12); /* unknown, skip 12 bits */\n\n\n\n    /* the output sample size is stored soon */\n\n    hassize = get_bits1(&alac->gb);\n\n\n\n    wasted_bytes = get_bits(&alac->gb, 2); /* unknown ? */\n\n\n\n    /* whether the frame is compressed */\n\n    isnotcompressed = get_bits1(&alac->gb);\n\n\n\n    if (hassize) {\n\n        /* now read the number of samples as a 32bit integer */\n\n        outputsamples = get_bits_long(&alac->gb, 32);\n\n        if(outputsamples > alac->setinfo_max_samples_per_frame){\n\n            av_log(avctx, AV_LOG_ERROR, \"outputsamples %d > %d\\n\", outputsamples, alac->setinfo_max_samples_per_frame);\n\n            return -1;\n\n        }\n\n    } else\n\n        outputsamples = alac->setinfo_max_samples_per_frame;\n\n\n\n    if(outputsamples > *outputsize / alac->bytespersample){\n\n        av_log(avctx, AV_LOG_ERROR, \"sample buffer too small\\n\");\n\n        return -1;\n\n    }\n\n\n\n    *outputsize = outputsamples * alac->bytespersample;\n\n    readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1;\n\n\n\n    if (!isnotcompressed) {\n\n        /* so it is compressed */\n\n        int16_t predictor_coef_table[channels][32];\n\n        int predictor_coef_num[channels];\n\n        int prediction_type[channels];\n\n        int prediction_quantitization[channels];\n\n        int ricemodifier[channels];\n\n        int i, chan;\n\n\n\n        interlacing_shift = get_bits(&alac->gb, 8);\n\n        interlacing_leftweight = get_bits(&alac->gb, 8);\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            prediction_type[chan] = get_bits(&alac->gb, 4);\n\n            prediction_quantitization[chan] = get_bits(&alac->gb, 4);\n\n\n\n            ricemodifier[chan] = get_bits(&alac->gb, 3);\n\n            predictor_coef_num[chan] = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = 0; i < predictor_coef_num[chan]; i++)\n\n                predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16);\n\n        }\n\n\n\n        if (wasted_bytes)\n\n            av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented, unhandling of wasted_bytes\\n\");\n\n\n\n        for (chan = 0; chan < channels; chan++) {\n\n            bastardized_rice_decompress(alac,\n\n                                        alac->predicterror_buffer[chan],\n\n                                        outputsamples,\n\n                                        readsamplesize,\n\n                                        alac->setinfo_rice_initialhistory,\n\n                                        alac->setinfo_rice_kmodifier,\n\n                                        ricemodifier[chan] * alac->setinfo_rice_historymult / 4,\n\n                                        (1 << alac->setinfo_rice_kmodifier) - 1);\n\n\n\n            if (prediction_type[chan] == 0) {\n\n                /* adaptive fir */\n\n                predictor_decompress_fir_adapt(alac->predicterror_buffer[chan],\n\n                                               alac->outputsamples_buffer[chan],\n\n                                               outputsamples,\n\n                                               readsamplesize,\n\n                                               predictor_coef_table[chan],\n\n                                               predictor_coef_num[chan],\n\n                                               prediction_quantitization[chan]);\n\n            } else {\n\n                av_log(avctx, AV_LOG_ERROR, \"FIXME: unhandled prediction type: %i\\n\", prediction_type[chan]);\n\n                /* I think the only other prediction type (or perhaps this is\n\n                 * just a boolean?) runs adaptive fir twice.. like:\n\n                 * predictor_decompress_fir_adapt(predictor_error, tempout, ...)\n\n                 * predictor_decompress_fir_adapt(predictor_error, outputsamples ...)\n\n                 * little strange..\n\n                 */\n\n            }\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        int i, chan;\n\n        for (i = 0; i < outputsamples; i++)\n\n            for (chan = 0; chan < channels; chan++) {\n\n                int32_t audiobits;\n\n\n\n                audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size);\n\n                audiobits = extend_sign32(audiobits, alac->setinfo_sample_size);\n\n\n\n                alac->outputsamples_buffer[chan][i] = audiobits;\n\n            }\n\n        /* wasted_bytes = 0; */\n\n        interlacing_shift = 0;\n\n        interlacing_leftweight = 0;\n\n    }\n\n    if (get_bits(&alac->gb, 3) != 7)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : Wrong End Of Frame\\n\");\n\n\n\n    switch(alac->setinfo_sample_size) {\n\n    case 16:\n\n        if (channels == 2) {\n\n            reconstruct_stereo_16(alac->outputsamples_buffer,\n\n                                  (int16_t*)outbuffer,\n\n                                  alac->numchannels,\n\n                                  outputsamples,\n\n                                  interlacing_shift,\n\n                                  interlacing_leftweight);\n\n        } else {\n\n            int i;\n\n            for (i = 0; i < outputsamples; i++) {\n\n                int16_t sample = alac->outputsamples_buffer[0][i];\n\n                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;\n\n            }\n\n        }\n\n        break;\n\n    case 20:\n\n    case 24:\n\n        // It is not clear if there exist any encoder that creates 24 bit ALAC\n\n        // files. iTunes convert 24 bit raw files to 16 bit before encoding.\n\n    case 32:\n\n        av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\", input_buffer_size * 8 - get_bits_count(&alac->gb));\n\n\n\n    return input_buffer_size;\n\n}\n", "idx": 1137, "substitutes": {"avctx": ["averpkg", "abpkg", "avctl", "avekb", "vercp", "avergc", "avectx", " avcp", " avcpu", "afcmd", "wavcmd", "avectl", "afmsg", " avkb", "avercpu", "avermsg", "wavgc", "avtx", " avsetup", "wavmsg", " avgc", "abcp", "wavca", "avesetup", "avobj", "avcpp", "avjac", "afctx", "afcpp", "avepkg", "wavpkg", "abcontext", "avegc", "avsetup", "aversetup", "avecpp", "avetx", "avkb", "averctl", "abctx", " avpkg", " avtx", "wavctx", "aveca", " avctl", "avca", " avcontext", "verctx", "avmsg", "avcp", "avercmd", "abjac", "avgc", "avcpu", " avjac", "avcontext", "avpkg", "abtx", "avecontext", "abobj", "afpkg", "vercontext", "verjac", "abcpp", "averca", "avecpu", "aveobj", "avcmd", "averctx", "afobj", "abkb", "abgc"], "outbuffer": [" outBuffer", "outputBuffer", " outbuff", "outputstream", "inBuffer", "instream", " outstream", "outputbuff", "outbuff", "outstream", "outputbuffer", "inbuff", "outBuffer"], "outputsize": ["hiddenSize", "hiddensize", "OutputSize", "outputSize", "Outputcount", "inputlength", "Outputsize", "outputcount", "inputcount", "inputSize", "hiddenlength", "outputlength", "inputsize", "Outputlength", "hiddencount"], "inbuffer": ["outbuff", "inbase", "inbuff", "binbuff", "cinbuff", "INbound", "cinbuffer", "cinbuf", "InBuffer", "INbuffer", "Inbase", "Inbuffer", "outBuffer", " inBuffer", "binbuffer", "binbuf", "inBuffer", "inbound", "inbuf", " inbuff", " inbase", " inbound", "outbound", "binBuffer", "cinbase", "Inbuf", "INbuff", "INBuffer", " inbuf", "Inbuff"], "input_buffer_size": ["input_Buffer_height", "input_buffer2SIZE", "input_buffer_string", "input_buffer_count", "input_bufferzSize", "input_cache_Size", "input_queue_len", "input_buffer_Size", "input_buffer2length", "input_buffer2len", "input_buffer_length", "input_buffer2size", "input_cache_string", "input_cache_size", "input_queue_Size", "input_queue_SIZE", "input_Buffer_Size", "input_buffer_ize", "input_buffer_height", "input_bufferzSIZE", "input_Buffer_length", "input_cache_length", "input_Buffer_count", "input_queue_ize", "input_buffer_len", "input_buffer_SIZE", "input_Buffer_SIZE", "input_bufferzsize", "input_bufferzheight", "input_queue_length", "input_Buffer_size", "input_queue_size"], "alac": ["alAc", "aliac", "balca", "calca", "altiac", "c", "aldac", "aracer", "delacer", "malace", "valacc", "halacc", "var", "ilac", " alact", "valace", "calace", "daliac", "alimac", "salsac", "context", "aliam", "stalAc", "ralacc", "salacer", "altaco", "ilacc", "salac", "into", "talAC", "dalacc", "alljac", "calac", "channel", "aleraco", "balac", "aldacc", "salaca", "aliacl", "alAC", "alam", "allAc", "ilsac", "altac", "salmac", "halacer", "salaco", "alaic", "allac", "halacl", "stalic", "salAC", " aliac", "ilact", "salact", "salacc", "alacer", "aleracc", "allacc", "realax", "balacl", "aleracl", "realace", "halAc", "salacl", "alax", "aracl", "alace", "malmac", "realam", "alca", "halac", "aljac", "allic", "aliAC", "alaca", "calacl", "delacl", "halic", "salace", "alerac", "aleriac", "aldAC", "alsac", "arac", "baliac", "info", "new", " alacer", " alacc", "dalaic", "ralsac", "ralact", " aljac", "call", "aleracer", "alacc", "haliac", "halact", "balaic", "balam", "balax", "aliaco", "allacer", " alace", "alica", "stalacer", "allace", "balacc", "exec", "_", "aldact", "valjac", "data", "balAC", "aleract", "balacer", "aleraic", "almac", "alacl", "aliiac", "alaco", "talacl", "alact", "ralac", "balaca", "dalac", "stalac", "cont", "talac", "delac", " alAC", "halaca", "aliace", "alic", "altacer", "balact", "valac", "malacl", "realac", "balace", "aliax", "calAC", "malac", "altacc"], "channels": ["contonents", "achones", " chanes", "chords", "achorts", "contanguages", " champs", "Chonents", "achamps", " chategories", "contannels", "hayers", "horts", "chones", "chorts", "chayers", "chedannels", "achanguages", "contords", "achategories", "chonents", "hones", "honents", "Chords", "hannels", "achannels", "Channels", "chedategories", "changuages", "chedamps", "champs", "Chayers", "chanes", "hords", "contorts", "contones", "chedanes", "chategories", "achanes", "hanguages", "contayers"], "outputsamples": ["Outputsides", "putsfaces", "outputbisamps", "putsents", "outputssamples", "outputresides", "OutputSides", "OutputSls", "outputsorts", "outputgsamples", "inputsamples", "inputssamps", "outputssents", "outputcongs", "OutputSets", "outputnsamps", "outputgsamps", "outputsefaces", "inputsamps", "Outputsents", "Outputnsamples", "outputseonents", "inputssongs", "outputcamps", "outputssongs", "outputconsls", "putssents", "Outputspaces", "outputsamp", "Outputsorts", "putsonents", "outputresamps", "outputspents", "outputstatamples", "inputssamples", "inputssamp", "outputsetsamps", "outputspamples", "outputsamps", "outputcamp", "outputssorts", "putssfaces", "putssonents", "outputbisamples", "outputssfaces", "outputstatents", "putsamples", "outputSets", "outputcamples", "outputgspaces", "Outputnsents", "outputnsents", "outputsongs", "inputsamp", "outputssonents", "outputsls", "outputconsamps", "outputconsets", "OutputSpaces", "outputssamps", "outputstatorts", "outputspaces", "outputspfaces", "outputSamples", "putssamples", "outputstatamps", "inputsongs", "outputsides", "outputbisls", "outputseents", "Outputnsamps", "outputsponents", "outputgsides", "outputrespaces", "outputsents", "outputsets", "Outputsamples", "OutputSamples", "outputsetsongs", "outputSamps", "outputnsamples", "outputssamp", "outputbisets", "outputseamples", "outputnsorts", "Outputnsorts", "outputconsamples", "outputSides", "Outputsamps", "outputresamples", "Outputsls", "outputsetsamples", "outputsfaces", "outputsetsamp", "outputSls", "outputSpaces", "OutputSamps", "outputsonents", "Outputsets"], "hassize": ["hassespace", "shassIZE", "hasespace", "harsiz", " hassized", "hallsizable", "chassize", "chassesiz", " hasspace", " hassizable", "hosspace", "shassesIZE", "hassiz", "halsize", "harsize", "hassesized", "harsIZE", "chassized", "hasscale", "hallsized", "shassize", "hallspace", "hassesizable", "chassiz", "shasspace", "shassiz", "hasesized", "harspace", "hassesiz", "halsized", "harscale", "chassesize", "hasesize", "hossiz", "hallsize", "hassesize", " hassesized", "hossize", "chasscale", "chassescale", "hassizable", "halscale", "hassescale", "hassesIZE", "hossIZE", "hasesizable", "hassIZE", "harsized", "hassized", " hassesizable", "chassesized", " hassespace", "halsiz", "shassesiz", "shassespace", "shassesize", " hassesize", "hasspace"], "readsamplesize": ["checksamplesizes", "readsitesized", "readsitesizes", "readsavesz", "checkspacesize", "readspacesized", "readsamplesizes", "readsitesize", "checkspacesz", "checksamplesized", "checkspacesized", "readsavesized", "readsitesz", "checkspacesizes", "readspacesz", "readspacesize", "checksamplesize", "readsamplesized", "readspacesizes", "readsamplesz", "checksamplesz", "readsavesizes", "readsavesize"], "wasted_bytes": ["wasted_rows", "wasted_byte", "wanted_bits", "wasted_bits", "wasted_values", "wasted_Bytes", "wanted_Bytes", "wushed_values", "wanted_rows", "wushed_byte", "wushed_files", "wasted_files", "wushed_bytes", "wanted_bytes"], "isnotcompressed": ["isnotcomress", "isnoncomacted", "isnoncondressed", "isnoncondressor", "isnotcondressor", "isnoncompression", "isnotcondression", "isnotsupplied", "isnoncomlied", "isnotcompress", "isnoncompressor", "isnoncondress", "isnotcomplied", "isnotsuppressor", "isnoncomressed", "isnotcompacted", "isnotsuppacted", "isnoncompacted", "isnotcondress", "isnotdefress", "isnotsuppression", "isnotCompressed", "isnoncondression", "isnotdefressed", "isnotcompression", "isnotcomlied", "isnotCompress", "isnotsuppress", "isnotcompressor", "isnotsuppressed", "isnoncompressed", "isnoncompress", "isnotcomressed", "isnotcondressed", "isnotdefacted", "isnoncomress", "isnoncomplied", "isnotcomacted", "isnotCompression", "isnotCompressor", "isnotdeflied"], "interlacing_shift": ["interlacing_offset", "interlacing2scale", "interlating_offset", "interlating_weight", "interlacing_scale", "interlacing2weight", "interlacing2shift", "interlacing_weight", "interlating_scale", "interlating_shift", "interlacing2offset"], "interlacing_leftweight": ["interlacing_lowweights", "interlacing_lowmask", "interlacing_leftscale", "interlacing_leftmask", "interlacing_rightweight", "interlacing_rightweights", "interlacing_innerweight", "interlacing_leftweights", "interlacing_innermask", "interlacing_innerscale", "interlacing_lowweight", "interlacing_rightmask", "interlacing_innerweights", "interlacing_rightscale", "interlacing_lowscale"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n", "idx": 1145, "substitutes": {"argc": ["targetn", " argp", "valn", "targetlc", "argcat", "argp", "arglc", "argsl", "argslc", " argac", "valc", "valnc", " arglc", "optc", " argcat", "argnc", "optcs", " argz", " argnc", "argac", "targetac", "targetp", "argz", "lencs", "argsac", "lencat", " argl", "argn", "argsc", " argcs", "argl", "lenc", "valp", "targetnc", "lenz", "targetl", "optcat", "argcs", " argn", "optz", "targetc"], "argv": ["argsvP", " argp", "argsV", "argumentvs", "metv", "opf", "argp", "callc", "opc", "flagvs", "configvin", "argV", "callf", "configc", "configv", "argsvs", "locvs", "metvs", "callv", "callvs", "argm", "argumentv", "firevs", "Argp", " argf", "metvP", "firevin", "callvin", "opvs", " argvin", "argsf", "flagc", "Argvin", "firev", "opv", " argm", "argsc", "argf", "argumentf", " argvs", "argvs", "argvP", "opm", "Argv", "locv", "locc", "Argm", "Argvs", "Argf", "configp", " argvP", "callV", "flagv", "Argc", "metc", "argsv", "argvin", " argV", "argumentc"], "opts": [" opoptions", "optpt", "optioncs", "opercs", "optionins", "optionters", " optts", "opnt", " optoptions", "optcs", " opnt", "optters", "opcs", " oppt", "optionts", "optins", "operins", "operts", "oppt", "operters", " optpt", " optnt", "opoptions", "optnt", "optts", "opins", "opters", "optoptions"], "c": ["vc", "d", "cod", "cat", "fc", "cd", "l", "pc", "count", "bc", "nc", "unc", "cn", "p", "g", "n", "dc", "ic", "r", "ci", "mc", "out", "cb", "m", "com", "i", "b", "x", "ce", "C", "cont", "cache", "etc", "it", "cur", "cmp", "config", "opt", " C", "oc", "ch", "k", "cf", "arc", "e", "w", "cs", "comp", "ctx", "name", "con", "co", "cut", "gc", "v", "abc", "cu", "cc", "o", "ct", "h", "f", "rc", "lc", "ac", "t", "tc", "a", "chain"], "cp": ["fp", "proc", "ctrl", "cat", "lp", "cd", "wp", "ph", "jp", "pc", "p", "dc", "pb", "np", "bp", "cop", "mp", "cfg", "cb", "csv", "hp", "gp", "cmp", "pr", "tp", "zip", "opt", "ip", "oc", "ch", "cf", "cap", "cv", "copy", "ctx", "comp", "cs", "quote", "gc", "pkg", "cu", "cc", "ct", "lc", "tc", "cmd", "CP"], "optind": ["optPtr", "optimmind", "opmind", "servind", "opteddir", " optkind", "ptind", "tipwind", "opInd", "optedinn", "optwind", " optinder", "optinder", "expbind", "servinder", "objInd", "objind", "optmind", "expind", "plotind", "optionPtr", "ptcall", "tipind", "tipindex", "objIND", "plotini", "optionmind", " optatt", "optiminder", "optedind", "optreq", "optcall", "plotInd", "optimkind", "letind", "trymind", "opteddep", " optInd", "optatt", "timeoutcall", "statind", "optinn", "objmind", "ortstick", "optionwind", "fitkind", "opIND", "optedbind", "plotmd", "optimcall", "timeoutind", "optionindex", " optindex", "optmd", "optedmind", "optimIND", "optiminn", " optcall", "opcall", "optInd", "optstick", "timeoutbind", "optimInd", "servdep", "statinder", "servinn", "opindex", "timeoutstick", "optimnt", "ptmind", "optimind", "tryreq", "optkind", " optbind", "statinn", "tryind", "opmd", "letmind", "letdir", "expmind", "optimini", "opini", "trybind", "optbind", "optionmd", " optnt", "optnt", "fitind", "optcond", " optinn", "optionIND", "ptInd", " optstick", "expnt", "opind", "optednt", "optimatt", "optimcond", "optionreq", "optimdir", "ortbind", "fitmind", "optedatt", "opPtr", "optindex", "optedcond", "optimbind", " optIND", "letnt", "ortcall", "ortind", "opwind", "optini", "optedinder", "optionInd", " optdir", "tipInd", "optimmd", "optionbind", "optIND", " optPtr", " optcond", "optdir", "fitIND", "optionind", "statdep", "optedreq", " optmind", "optdep"], "sp": ["proc", "pres", "j", "sync", "inst", "lp", "SP", "yp", "jp", "pc", "ep", "ssh", "sh", "sv", "soc", "p", "sl", "index", "np", "bp", "pol", "pp", "isp", "mp", "ng", "amp", "spl", "space", "pos", "sk", "sc", "policy", "sil", "snap", "ps", "tp", "syn", "scope", "pat", "sw", "ip", "push", "pse", "ch", "sd", "cap", "ptr", "xp", "sam", "ap", "span", "pl", "ind", "sm", "pt", "spe", "loc", "esp", "asp", "Sp", "pre", "osp", "vol", "rel", "si", "dim", " esp", "par", "bsp", "top", "serv", "se"]}}
{"project": "qemu", "commit_id": "6240d6467077a12c24878bab645d8e2983e4975a", "target": 0, "func": "static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,\n\n                                    uint32_t val)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr;\n\n    int reload = 0;\n\n\n\n    DPRINTF(\"write \" TARGET_FMT_plx \" %08x\\n\", addr, val);\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case TIMER_LIMIT:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter MSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else {\n\n            // set limit, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = val & TIMER_MAX_COUNT32;\n\n            if (!s->limit)\n\n                s->limit = TIMER_MAX_COUNT32;\n\n            ptimer_set_limit(s->timer, s->limit >> 9, 1);\n\n        }\n\n        break;\n\n    case TIMER_COUNTER:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter LSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else\n\n            DPRINTF(\"not user timer\\n\");\n\n        break;\n\n    case TIMER_COUNTER_NORST:\n\n        // set limit without resetting counter\n\n        s->limit = val & TIMER_MAX_COUNT32;\n\n        if (!s->limit)\n\n            s->limit = TIMER_MAX_COUNT32;\n\n        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);\n\n        break;\n\n    case TIMER_STATUS:\n\n        if (slavio_timer_is_user(s)) {\n\n            // start/stop user counter\n\n            if ((val & 1) && !s->running) {\n\n                DPRINTF(\"processor %d user timer started\\n\", s->slave_index);\n\n                ptimer_run(s->timer, 0);\n\n                s->running = 1;\n\n            } else if (!(val & 1) && s->running) {\n\n                DPRINTF(\"processor %d user timer stopped\\n\", s->slave_index);\n\n                ptimer_stop(s->timer);\n\n                s->running = 0;\n\n            }\n\n        }\n\n        break;\n\n    case TIMER_MODE:\n\n        if (s->master == NULL) {\n\n            unsigned int i;\n\n\n\n            for (i = 0; i < s->num_slaves; i++) {\n\n                if (val & (1 << i)) {\n\n                    qemu_irq_lower(s->slave[i]->irq);\n\n                    s->slave[i]->limit = -1ULL;\n\n                }\n\n                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {\n\n                    ptimer_stop(s->slave[i]->timer);\n\n                    ptimer_set_limit(s->slave[i]->timer,\n\n                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);\n\n                    DPRINTF(\"processor %d timer changed\\n\",\n\n                            s->slave[i]->slave_index);\n\n                    ptimer_run(s->slave[i]->timer, 0);\n\n                }\n\n            }\n\n            s->slave_mode = val & ((1 << s->num_slaves) - 1);\n\n        } else\n\n            DPRINTF(\"not system timer\\n\");\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid write address \" TARGET_FMT_plx \"\\n\", addr);\n\n        break;\n\n    }\n\n}\n", "idx": 1167, "substitutes": {"opaque": ["iopus", "opaco", "OPque", "OPatile", "oatile", "OPaco", "iopque", "oaque", "OPaque", "OPaques", "oaques", " opatile", "OPus", "ose", " opaques", "iopaco", "opque", "iopaque", "opse", "oque", "ous", "OPse", "opaques", " opse", "opus", "oaco", "opatile"], "addr": ["mt", "alloc", "add", "eth", "arr", "ay", "seek", "attr", "ref", "hw", "r", "align", "coord", "var", "res", "x", "kt", "tx", "pos", "rol", "ord", "ack", "mem", "pad", "ip", "trans", "ptr", "err", "ctx", "alias", "adr", "now", "rt", "loc", "offset", "ix", "dr", "rs", "address", "hash", "src", "inter", "ad", "max", "tr", "rc", "elt", "oad", "map", "cmd"], "val": ["data", " value", "test", "key", "value", "buf", "count", "z", "Val", "cal", "ref", "index", "pol", "vt", "act", "vals", "var", "res", "x", "bit", "tx", "num", "seq", "valid", "rol", "it", "req", "VAL", "cmp", "dev", "local", "ival", "err", "grad", "ctx", "bal", "alt", "eval", "bin", "hz", "v", "vol", "fee", "sel", "rel", "ret", "arg", "Value", "elt", "al", "mem", "serv", "len", "cmd", "pri"], "s": ["ls", "aunts", "p", "es", "n", "ses", "set", "sie", "params", "services", "series", "its", "conf", "cs", "ies", "h", "gs", "sb", "args", "os", "serv", "stats", "sv", "settings", "service", "vs", "details", "xs", "ess", "ers", "ds", "qs", "m", "less", "bs", "ims", "bis", "sam", "ties", "hs", "ar", "sts", "pers", "ins", "sq", "j", "S", "l", "ss", "z", "als", "sl", "comm", "tes", "ns", "sw", "y", "ms", "ts", "changes", "v", "se", "ssl", "sp", "sys", "is", "g", "b", "fs", "aws", "ps", "parts", "js", "as", "sports", "sm", "has", "rs", "bits", "ats", "t"], "saddr": ["sqref", "saddress", "svptr", "Sattr", "svaddr", "sqaddr", "Ssrc", "taddress", "svref", " sconn", "sqptr", "paddress", "psrc", "Saddr", "sref", "Sdr", " sptr", "svconn", "tdr", "ssrc", "sconn", "taddr", "sqconn", " sdr", "sptr", "paddr", "sdr", "pattr", " saddress", "Saddress", " sref", "sattr"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n", "idx": 1194, "substitutes": {"env": ["proc", "stack", "gear", "buf", "code", "web", "ev", "window", "vs", "txt", "cb", "environment", "info", "def", "bar", "dev", "end", "disk", "cv", "context", "e", "w", "en", "buffer", "name", "v", "h", "uv"]}}
{"project": "qemu", "commit_id": "b591dc59bc98ee558db4ca512aa117748ebfdeef", "target": 0, "func": "static void temp_allocate_frame(TCGContext *s, int temp)\n\n{\n\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n\n    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);\n\n    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)\n\n        tcg_abort();\n\n    ts->mem_offset = s->current_frame_offset;\n\n    ts->mem_reg = s->frame_reg;\n\n    ts->mem_allocated = 1;\n\n    s->current_frame_offset += sizeof(tcg_target_long);\n\n}\n", "idx": 1215, "substitutes": {"s": ["sys", "ls", "S", "stats", "l", "c", "sg", "is", "sv", "ss", "source", "es", "z", "p", "g", "n", "times", "vs", "ses", "comm", "set", "ds", "qs", "m", "i", "b", "fs", "less", "aws", "ps", "ex", "its", "js", "ns", "bs", "sw", "state", "conf", "ims", "ms", "cs", "spec", "hs", "sts", "rs", "v", "h", "gs", "sb", "ins", "st", "sq", "os", "so", "t", "ats", "a", "se", "ops"], "temp": ["id", "test", "Temp", "tmp", "size", "tim", "c", "unc", "perature", "unt", "fac", "deg", "emp", "vt", "set", "coord", "m", "dat", " Temp", "mod", "type", "time", "perm", "cell", "tar", "level", "cum", "ptr", "nom", "Temperature", "pt", "pre", "cu", "wr", "current", "max", "tr", "ac", "t", "tc", "tem", "typ"], "ts": ["mt", "ls", "mint", "stats", "outs", "tt", "ss", "als", "ics", "TS", "ots", "times", "uts", "vs", "vt", "out", "td", "fs", "tx", "ols", "tes", "gt", "Ts", "fts", "ps", "tp", "its", "tz", "js", "ta", "tv", "tar", "bs", "opt", "ns", "ims", "ptr", "tl", "amps", "ms", "ports", "cs", "tn", "alt", "pt", " t", "hs", "sts", "rs", "nt", "ret", "te", "gs", "wt", "ats", "ins", "tr", "os", "tis", "t", "tc", "acs", "ops"]}}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n", "idx": 1227, "substitutes": {"device": ["image", "template", "number", "document", "interface", "test", "directory", "component", "description", "DE", "query", "package", "mode", "devices", "path", "link", "phy", "pod", "serial", "family", "pe", "volume", "controller", "pad", "network", "product", "dev", "connection", "location", "block", "error", "disk", "buffer", "command", "Device", "resource", "spec", "remote", "display", "address", "hid", "driver", "model", "position", "mobile", "drive", "android", "module", "feature"], "has_base": [" has_back", " has_bas", "has_bas", "has_based", " has_based", "has_back"], "base": ["bound", "image", "id", "template", "batch", "basic", "br", "bottom", "use", "phrase", "handle", "source", "absolute", "only", "p", "create", "relative", "server", "bp", "ase", "stable", "common", "used", "reverse", "bit", "b", "full", "force", "real", "family", "profile", "Base", "extra", "bare", "bar", "type", "based", "shell", "file", "pa", "local", "bi", "buffer", "kit", "area", "name", "alias", "support", "bal", "remote", "bid", "last", "address", "root", "bas", "unit", "prefix", "background", "back", "chain"], "errp": ["errpc", " errpp", "rrpart", " errpad", "rerp", " errpc", "scorepc", "scorep", "eorpart", " errpar", "rerP", " errpat", " erp", "lerpad", "lerP", "rrp", "errpp", "errorp", " errpa", "rrpad", "rerpad", " errP", "lerpa", "eorps", "lerp", "errpa", " erpart", "errpart", " errps", " erps", " erpad", "scorepp", "scorepar", "eorp", "rerpa", "scoreps", "errorps", "errps", "rrps", "errorpar", "errpar", "eorpad", "errpat", " erpat", "errpad", " erpp", "errP", "scorepat", "errorpc"], "bs": ["sys", "ls", "stats", "eb", "outs", "cks", "bc", "bh", "socket", "is", "bm", "vs", "pb", "bp", "s", "ds", "cb", "bed", "qs", "b", "ubs", "fs", "lbs", "BS", "gb", "iss", "obs", "ps", "its", "bb", "js", "ns", "bos", "aos", "bi", "bis", "ms", "ts", "cs", "ctx", "bal", "bus", "bes", "bps", "bo", "sts", "hz", "rs", "bl", "bits", "gs", "bas", "sb", "bu", "bn", "aus", "ubis", "obj"], "base_bs": ["base_ls", "base_abs", " base_bits", " base_base", "base_js", "relative_BS", " base_ns", "b_cs", "b_bs", " base_abs", "b_ls", "relative_bis", "base_ns", "base_bis", " base_bb", "relative_bs", "b_bits", "base_bits", "base_ts", "base_bb", "base_cs", "relative_js", "base_base", "base_BS", " base_ts"], "local_err": ["local_diff", "local_r", "specific____error", "local____notice", " local_r", "specific_err", "specific_order", " local_cfg", "specific____order", " local_error", "local_attr", "local__rr", " local_diff", "localingdiff", "localinger", "local____err", "local42attr", "local_sys", " local_attr", "local____order", "local42er", " local_rr", " local_er", "local____error", "local_error", "localingerr", "local_cfg", " local_sys", "local_rr", "specific____err", "local_order", "specific____notice", "local__err", "localingsys", "local42cfg", "local_notice", "specific_notice", "specific_error", "local__r", "local42err", "local__error", "local_er"]}}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF &&\n\n        msi_init(dev, 0, 1, true, false) >= 0) {\n\n        /* TODO check for errors */\n\n        s->msi_in_use = true;\n\n    }\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 1277, "substitutes": {"dev": ["p", "ev", "hw", "window", "app", "out", "var", "develop", "vp", "req", "conf", "disk", "cam", "stick", "ver", "spec", "de", "h", "os", "mem", "Dev", "scan", "serv", "test", " device", "dem", "ds", "phy", "serial", "gu", "tech", "nt", "hid", "driver", "av", "device", "er", "adv", "dd", "pad", "att", "sw", "Device", "ctx", "home", "go", "pt", "db", "v", "draw", "det", "ve", "ram", "cmd", "proc", "conn", "g", "debug", "devices", "md", "def", "sd", "desc", "w", "DEV", "o", "ad", "raw", "des", "pro"], "errp": ["rp", "erP", "errr", "rP", "err", "erp", "errP", "rr", " errP", " errr"], "d": ["data", "j", "dt", "c", "p", "g", "n", "r", "ds", "m", "b", "dh", "dm", "sd", "w", "e", "de", "db", "dr", "v", "h", "di", "ad", "f", "D", "t", "dn"], "s": ["ls", "p", "es", "ses", "set", "params", "store", "gets", "services", "its", "k", "ports", "cs", "spec", "ies", "an", "h", "gs", "f", "sb", "args", "os", "serv", "mods", "stats", "sv", "settings", "session", "vs", "details", "ds", "qs", "m", "ex", "bs", "ims", "bis", "sam", "ties", "bes", "hs", "sts", "ins", "sq", "sync", "self", "j", "S", "l", "er", "ss", "als", "sa", "comm", "utils", "i", "tes", "ns", "sw", "y", "ms", "ts", "changes", "v", "ares", "se", "ssl", "sp", "sys", "is", "g", "b", "fs", "shared", "aws", "ps", "js", "sd", "ads", "w", "as", "sports", "rs", "bits", "ats", "des", "t", "obj"]}}
{"project": "qemu", "commit_id": "e0891bd8bfd3349fc3fecde30e51900059f53f11", "target": 0, "func": "static inline int num_effective_busses(XilinxSPIPS *s)\n\n{\n\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n\n}\n", "idx": 1290, "substitutes": {"s": ["sys", "sis", "ls", "S", "c", "is", "sv", "ss", "p", "es", "sl", "r", "ses", "ers", "set", "ds", "qs", "fs", "less", "aws", "ps", "parts", "js", "ns", "ims", "ms", "as", "ts", "sports", "ains", "ies", "hs", "sts", "rs", "ares", "h", "gs", "sb", "ins", "ats", "sol", "sq", "rates", "t", "a"]}}
{"project": "FFmpeg", "commit_id": "04dcdc464087eece349f30db42bab903cd077778", "target": 1, "func": "FFTContext *av_fft_init(int nbits, int inverse)\n\n{\n\n    FFTContext *s = av_malloc(sizeof(*s));\n\n\n\n    if (s && ff_fft_init(s, nbits, inverse))\n\n        av_freep(&s);\n\n\n\n    return s;\n\n}\n", "idx": 1307, "substitutes": {"nbits": ["inbytes", "nnints", "nbbytes", "nbbits", "numints", "nnbool", "nbool", "nbytes", "nparts", "nnbytes", "nbints", "inints", " nparts", "inbits", "inparts", "nbparts", "numbytes", "nints", " nints", " nbytes", "numbits", " nbool", "numbool", "nnbits"], "inverse": [" inversible", "dinhibit", "Inhibit", "dinvert", " inverted", "invert", " inversion", "inverted", " inhibit", "Inversion", " invert", "Inverted", "Inversible", "inversible", "edInvert", "edInverted", "edInversion", "inhibit", "edInverse", "inversion", "dinversible", "Invert", "Inverse", "dinverse"], "s": ["sys", "ls", "j", "S", "q", "d", "stats", "serv", "l", "c", "is", "sv", "ss", "p", "es", "als", "g", "n", "ast", "r", "comm", "ds", "m", "i", "b", "x", "fs", "less", "sc", "ps", "its", "js", "ns", "bs", "w", "as", "ts", "cs", "hs", "has", "sts", "v", "rs", " is", "h", "gs", "f", "sb", "ats", "sq", "os", "t", "a", "self"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1308, "substitutes": {"var": ["vc", "addr", " variable", " Var", " cur", "widget", "fac", "node", "iter", " val", "Var", "star", "ars", "tab", "bar", " tmp", "type", "variable", "bb", "car", "iv", "ptr", "name", "ver", "spec", "array", "ar", " vec", "v", " bar", "val", "prev", "par", "ac", "serv", "map", "obj", "self"]}}
{"project": "FFmpeg", "commit_id": "89325417e7b33f4b08171d9d609c48662d96b2d3", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n    if (bytestream2_get_bytes_left(&s->g) < 36) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for SIZ\\n\");\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {\n        avpriv_request_sample(s->avctx, \"Large Dimensions\");\n        return AVERROR_PATCHWELCOME;\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              ncomponents);\n        return AVERROR_PATCHWELCOME;\n    s->ncomponents = ncomponents;\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for %d components in SIZ\\n\", s->ncomponents);\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n    if (i == possible_fmts_nb) {\n        if (ncomponents == 4 &&\n            s->cdy[0] == 1 && s->cdx[0] == 1 &&\n            s->cdy[1] == 1 && s->cdx[1] == 1 &&\n            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {\n            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n                s->cdef[0] = 0;\n                s->cdef[1] = 1;\n                s->cdef[2] = 2;\n                s->cdef[3] = 3;\n                i = 0;\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d\\n\"\n               \"cdx[0]: %d, cdy[0]: %d\\n\"\n               \"cdx[1]: %d, cdy[1]: %d\\n\"\n               \"cdx[2]: %d, cdy[2]: %d\\n\"\n               \"cdx[3]: %d, cdy[3]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               s->cdx[0],\n               s->cdy[0],\n               ncomponents > 1 ? s->cdx[1] : 0,\n               ncomponents > 1 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0,\n               ncomponents > 3 ? s->cdx[3] : 0,\n               ncomponents > 3 ? s->cdy[3] : 0);\n        return AVERROR_PATCHWELCOME;\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;", "idx": 1318, "substitutes": {"s": ["ls", "erences", "c", "sg", "es", "n", "ses", "set", "params", "us", "gets", "services", "its", "t", "conf", "ords", "ports", "cs", "ies", "ags", "gs", "png", "sb", "args", "os", "serv", "a", "my", "mods", "stats", "sv", "vs", "details", "ers", "ds", "qs", "ants", "less", "bs", "ims", "bis", "sam", "hs", "sts", "eps", "styles", "pers", "ins", "states", "sq", "acs", "S", "l", "er", "sets", "ss", "als", "comm", "locks", "tes", "new", "ns", "err", "ms", "ts", "changes", "tests", "results", "uploads", "rates", "_", "ops", "sys", "status", "is", "g", "ids", "fs", "aws", "def", "ps", "parts", "js", "ads", "comments", "terms", "as", "sports", "uint", "rs", "bits", "ats", "des", "state", "jpg"], "i": ["j", "ati", " m", "ii", " mi", "c", " j", "p", "xi", "pi", "ci", "m", "phi", "it", " ti", "ip", " ii", " pi", "bi", "im", "ti", " v", "v", "mi", "ai", "I", "si", " bi"], "ncomponents": ["numcpensions", "ncommlements", "nomplements", "numcponents", "numcponent", "ncompients", "numcomponent", "dndiffients", "nexponents", "ncommonents", "nompresses", "ncomorts", "ncpients", "Ncompensions", " nCompaints", "nomports", "ncommresses", "nomponents", "dncomplements", "ncomonent", "ndiffients", "ndifflements", "ncompensions", "nCompaints", "dncomponents", "dndifflements", "dndiffonents", "nCompones", "ndeepensions", "numcpients", "ncpaints", "ncponents", "nexpaints", "numcompients", "ncompresses", " ncompients", "nomponent", "nComplements", "ncpensions", "Ncomports", "Ncompones", "ncports", " ncompensions", " nComponents", "nCompixels", "ndiffresses", "ncommients", "ndeeponents", "Ncomonents", "nompixels", "numcomponents", "Ncomponents", "Ncomorts", " nomponents", "ncomponent", " nCompensions", "nexplements", "ncompones", "nompensions", "ncompaints", "ncplements", "ndeeports", "ncomonents", "Ncomensions", "nexpensions", "ncpixels", "dncompients", " nompixels", " nomports", " nComplements", "ncompixels", " nompients", "ncomensions", "ndeepones", "ncomports", " ncomplements", "ncomplements", " ncompixels", " ncomports", "Ncomones", "nComports", "ncponent", "ncomones", "nCompensions", "ndiffonents", "ncomients", "nompients", " ncompaints", "nCompients", "numcompensions", "dncompresses", "dndiffresses", "nComponents"], "possible_fmts": ["possible_fmcs", "possible_nmts", "possible_nmters", "possible_fmters", "possible_mters", "possible__nmts", "possible__fmts", "possible_mts", "possible__nmters", "possible_cmts", "possible_fmats", "possible_nmcs", "possible_mats", "possible__fmats", "possible_cmcs", "possible_nmats", "possible__fmters", "possible_cmats", "possible_mcs", "possible__nmats", "possible_cmters", "possible__fmcs", "possible__nmcs"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 1335, "substitutes": {"job": ["jump", "journal", "j", "batch", "jam", "work", "image", "jp", "web", "org", "row", "build", "node", "jar", "task", "b", "lock", "obs", "dq", "jobs", "hub", "cell", "Job", "block", "command", "ob", "band", "db", "queue", "group", "low", "process", "gov", "jj", "map", "cmd"], "speed": ["efficiency", "species", "sex", "distance", "gain", "size", "status", "peed", "delay", "percent", "port", "ss", "gravity", "limit", "seek", "power", "rank", "send", "score", "rate", "sum", " speeds", "force", "start", "sk", "weight", "performance", "shape", "Speed", "shock", "time", "sw", "powered", "slow", "mph", "fps", "command", "fast", "spec", "sports", "wage", "EED", "spe", "priority", "scale", "when", "frequency", "ly", "kick", "density", "length", "capacity"], "errp": [" errping", " errbp", " errpar", " erP", "ererbp", " erp", "ererP", "iterP", " erpar", "ererping", " errP", "iterping", "errping", "ererpar", "errbp", "errpar", "iterp", " erbp", "ererp", "errP"], "s": ["sys", "ls", "j", "S", "q", "c", "is", "sv", "ss", "p", "g", "sl", "r", "ds", "m", "b", "fs", "sc", "ps", "js", "ns", "bs", "ms", "cs", "ts", "sm", "hs", "rs", "v", "h", "gs", "f", "sb", "sq", "t", "a", "sp"]}}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_int(int *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;\n\n        else\n\n            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;\n\n        return;\n\n    }\n\n\n\n    extend97_int(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n}\n", "idx": 1338, "substitutes": {"p": ["fp", "php", "d", "cp", "j", "q", "lp", "wp", "l", "result", "op", "jp", "pc", "c", "up", "g", "n", "pn", "pm", "P", "pi", "pb", "bp", "np", "progress", "pp", "out", "mp", "app", "hp", "params", "pg", "x", "new", "pe", "cache", "vp", "it", "at", "pad", "pr", "ps", "tp", "ip", "perm", "pa", "ist", "xp", "ap", "pkg", "pt", "post", "ar", "pre", "dp", "f", "pd", "par", "t", "a", "sp"], "i0": ["pi90", "di00", "e0", "si00", "ini000", "ti000", "pi2", "oiStart", "iu0", "ui0", "ip000", "i000", "ui000", "piStart", "zi1", "e2", "ci2", "si0", "piator", "ip0", "bi0", "ti00", "xi1", "iarg", " iator", "ci00", "i00", " iZero", "xi0", "iiZero", "pi0", "li00", "iu25", "ii0", "biarg", "ti1", "si50", "xiZero", "ci1", "di0", "pi1", "pi25", "ui00", "oi25", "ci50", "e90", "iu1", "ii00", "pi00", " i00", " i000", " i50", "i90", "bi1", "ti0", "si1", "ci90", "iator", "ziator", "iStart", "li1", "i2", "oi0", "li000", "ini00", "li0", "xiarg", "oi1", "ip00", "i50", "zi0", "bi00", "xi00", "xi000", "iuStart", "ii1", "ii000", "i25", "iZero", "iiarg", "pi000", "di000", "ini0", "e1", "ci0"], "i1": ["i127", "ui1", "di91", "lied", "uiOne", "mi1", "ri1", "li91", "ic001", "liOne", "pi2", "oi11", "li4", "ui0", "ri001", "i91", "ied", " i001", "diOne", "ic1", "mi001", "iOne", "xi1", "piob", "int1", "li127", "hi1", "ri100", "inted", " iob", "pi001", "xi001", "xi0", " i4", "int127", "pi0", "ic0", "i100", "li001", "di1", "oied", "oi127", "hi91", "i4", "di0", "i001", "ione", "pi1", "isone", "mi0", "ai001", "iob", "icob", "pione", "xi91", "ai1", "mione", "hi001", "ic2", "ui4", "li1", "i2", "is0", "int11", " i91", "li0", "ui91", "oi1", "ri0", "li11", "is1", "i11", " i2", "ai91", "ic100", "is001", "li100"], "i": ["id", "c", "ogi", "init", "ski", "li", "iii", "x", "us", " vi", " ti", "iu", "ti", "ind", "uri", "ix", "zi", "ini", "I", "f", "ik", " bi", "q", "key", " j", "iy", "xi", "ic", "ico", "qi", "m", "u", "ui", "it", "gu", "im", " li", "io", "\u0438", "ri", "ql", "j", "ii", "iri", " mi", "ji", "er", "to", "pi", "asi", "me", "ci", "ei", "phi", "ij", "fi", " ii", "y", " pi", "bi", "hi", " I", "go", "v", " ni", "mi", "di", "ai", "si", "point", "multi", "ni", "ki", "status", "il", "is", "g", "s", "cli", "gi", " si", "ip", "oi", "ie", "ia", "in", "o", "t"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r=  ((uint32_t*)src)[i]&0xFF;\n\n\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\n\n\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n", "idx": 1341, "substitutes": {"dst": [" dlist", "ddlist", " dend", "ddsrc", " dout", "dict", "dout", "pst", "dend", "dlist", "pict", "stout", " dict", " dsrc", "stST", "dST", "ddst", "ddend", "dsrc", "stst", "dbst", "pout", "stict", "dbsrc", " dST", "dblist", "dbend", "pST"], "src": ["sys", "input", "inst", "ctr", "usr", "aux", "tmp", "bh", "source", "sec", "img", "sl", "times", "r", "s", "rect", "usc", "rb", "ur", "cont", "sc", "cur", "req", "sur", "config", "iv", "sr", "ch", "hl", "ptr", "copy", "ipl", "rl", "dest", "str", "RC", "rs", "null", "in", "rc", "sb", "st", "ins", "sq", "secure", "supp"], "i": ["id", "p", "init", "li", "x", " ti", "iu", "ti", "span", "ind", "ix", "zi", "h", "ini", "his", "I", "my", " bi", "batch", "ma", "xi", "ic", "qi", "m", "ui", "it", "ex", "ims", "im", "io", "\u0438", "ri", "json", "chain", "j", " m", "ii", "l", "jp", "ji", "gl", "pi", "index", "me", "ci", "ei", "phi", "ij", " ii", "y", " pi", "bi", "ms", " I", "v", "mi", "di", "ai", "si", "multi", "ki", "status", "is", "sim", "s", "ami", "b", "cli", "gi", "ip", "oi", "e", "ia", "uli", "o", " multi", "t"]}}
{"project": "qemu", "commit_id": "35b6e94ba50cd92600a85eef444bc31df8999de1", "target": 0, "func": "static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n", "idx": 1351, "substitutes": {"errp": [" errpp", "diep", "rrpb", " errsp", "rrp", "excpa", "errpp", "errorp", " errpa", " errpb", "diesp", "errorpp", "diepa", "errpa", " errps", "errorpb", "diepb", "errsp", "errorps", "errps", "excpb", "rrps", "errpb", "excp", "excsp", "rrpp"], "fid": ["duid", "fduid", "fpid", "orfbegin", " fbid", "fId", "lfcmd", "orfId", "fvid", "fuid", "fenq", "tfpid", "facid", "confID", "fcmd", " fId", "facdid", "fbegin", "lfId", "dID", "orfid", "confid", "foId", "Fid", " fID", "lfbid", "Fidem", "FId", "fenid", "FID", "tfidem", "orfpid", " fidem", "dq", "fdid", "hpid", "Fbegin", "lfdid", "fenID", "lfvid", "did", "fenuid", "tfid", "facID", "confcmd", "hID", "fdq", " fvid", "faccmd", "lfid", "fobid", "fidem", "hId", "tfoid", " fbegin", "Fpid", "lfID", "hid", "fovid", "fID", "Foid", "fq", " foid", "foid", "fdID", "confdid", "fbid", " fpid"]}}
{"project": "qemu", "commit_id": "bd3be4dbbf0491d6db8bf326706747b4629ace4b", "target": 0, "func": "static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    virtio_cleanup(vdev);\n\n    v9fs_device_unrealize_common(s, errp);\n\n}\n", "idx": 1360, "substitutes": {"dev": ["doc", "proc", "data", "d", "test", "env", "device", "pro", "p", "dd", "ev", "hw", "dem", "vt", "Dev", "res", "develop", "off", "md", "def", "priv", "att", "pad", "ch", "w", "cam", "wd", "ver", "spec", "de", "go", "DEV", "nt", "ad", "ve", "tr", "th", "des", "mem", "serv", "cmd"], "errp": ["errpc", " errping", " errpp", " Errp", " ErrP", "nerpp", "derp", "derping", "errpre", "ererpp", "errpp", "derpp", "errorp", "ererpre", "ererpc", " errP", "nerpc", "errorpp", "derP", "errorpre", " Errpp", "nerp", "errping", " Errping", "nerpre", "ererp", "errP", "errorpc"], "vdev": ["mdevice", "vdevice", " vdevice", " vev", "vev", " vdat", "Vdat", "mdata", "Vdev", "vardata", "vardat", "vardev", "mdev", "vtdev", "Vdata", "vtdata", "vtev", "varev", "vdata", "mev", " vdata", "vtdevice", "Vev", "vdat"], "v": ["vc", "j", "d", "q", "l", "c", "V", "sv", "z", "p", "g", "n", "ev", "vs", "r", "vt", "m", "var", "i", "b", "x", "u", "vp", "tv", "y", "vm", "w", "e", "cv", "ver", "h", "uv", "f", "av", "t"], "s": ["ls", "S", "q", "c", "is", "sv", "ss", "p", "n", "sl", "vs", "m", "i", "b", "fs", "us", "ps", "ns", "bs", "state", "w", "sam", "ts", "cs", "sts", "rs", "h", "gs", "f", "sb", "ats", "t", "sp"]}}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n", "idx": 1373, "substitutes": {"s": ["ls", "d", "S", "c", "sv", "ss", "p", "z", "n", "r", "ses", "comm", "ds", "qs", "m", "i", "b", "fs", "less", "aws", "ps", "js", "ns", "e", "as", "ts", "cs", "hs", "sts", "v", "rs", "in", "gs", "f", "ins", "ats", "sb", "sq", "os", "t", "a"], "pkt": ["ipacket", "ppqt", "ipet", " pet", "ppkt", "packet", "mqt", " packet", "pqt", "ppet", "pet", " pqt", "ipkt", "macket", "mkt", "ipqt", "met", "ppacket"], "ipmovie": ["hipjob", "ipprage", "hipfilm", "ippvideo", "ippMovie", "hipmovie", " ipfilm", "ippmovie", "ipjob", "IPmovie", "hiprage", "IPMovie", "ippjob", "ippfilm", "IPvideo", "ipfilm", "ijob", " ipvideo", "ipvideo", "imovie", "iprage", "IPfilm", " ipMovie", "irage", "ifilm", "ipMovie"], "pb": ["fp", "batch", "cp", "lp", "wp", "jp", "buf", "pc", "eb", "ub", "bj", "bh", "tk", "xb", "apy", "p", "pm", "ab", "np", "bp", "pp", "mp", "cb", "rb", "lb", "gb", "vp", "tp", "pa", "ctx", "pl", "pool", "ob", "pkg", "wb", "bps", "fb", "orp", "pan", "sb", "nb", "PB", "ib", "uf", "typ"], "ret": ["mt", "usr", "RET", "try", "summary", "ext", "aj", "out", "off", "gt", " fut", "reply", "reason", " Ret", "xt", "pas", "hash", "reset", "resp", "mem", "re", "back", " res", "result", "deg", "num", "at", "Ret", "pat", "alt", "del", "rev", "ter", "nt", " alt", "arg", "cert", "tr", "elt", "rep", "aux", "cat", "alf", "jp", "dt", "rest", " RET", "fun", "ref", "res", "att", "prot", "vet", "tn", "str", "val", "rets", "det", "rem", "flag", "cmd", "eth", "prop", "status", "arr", "Return", "ft", "red", "cont", "def", "ert", "desc", "rt", "ben", "print", "dr", "pret", "nz", "t"]}}
{"project": "FFmpeg", "commit_id": "46e3883519b7592e946258c68d072abd89e583c8", "target": 1, "func": "static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size)\n\n{\n\n    int samples    = s->packet.frame_duration;\n\n    int redundancy = 0;\n\n    int redundancy_size, redundancy_pos;\n\n    int ret, i, consumed;\n\n    int delayed_samples = s->delayed_samples;\n\n\n\n    ret = opus_rc_init(&s->rc, data, size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* decode the silk frame */\n\n    if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        if (!swr_is_initialized(s->swr)) {\n\n            ret = opus_init_resample(s);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n\n\n        samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output,\n\n                                            FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND),\n\n                                            s->packet.stereo + 1,\n\n                                            silk_frame_duration_ms[s->packet.config]);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error decoding a SILK frame.\\n\");\n\n            return samples;\n\n        }\n\n        samples = swr_convert(s->swr,\n\n                              (uint8_t**)s->out, s->packet.frame_duration,\n\n                              (const uint8_t**)s->silk_output, samples);\n\n        if (samples < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Error resampling SILK data.\\n\");\n\n            return samples;\n\n        }\n\n\n        s->delayed_samples += s->packet.frame_duration - samples;\n\n    } else\n\n        ff_silk_flush(s->silk);\n\n\n\n    // decode redundancy information\n\n    consumed = opus_rc_tell(&s->rc);\n\n    if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8)\n\n        redundancy = opus_rc_p2model(&s->rc, 12);\n\n    else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8)\n\n        redundancy = 1;\n\n\n\n    if (redundancy) {\n\n        redundancy_pos = opus_rc_p2model(&s->rc, 1);\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID)\n\n            redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2;\n\n        else\n\n            redundancy_size = size - (consumed + 7) / 8;\n\n        size -= redundancy_size;\n\n        if (size < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid redundancy frame size.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (redundancy_pos) {\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_celt_flush(s->celt);\n\n        }\n\n    }\n\n\n\n    /* decode the CELT frame */\n\n    if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) {\n\n        float *out_tmp[2] = { s->out[0], s->out[1] };\n\n        float **dst = (s->packet.mode == OPUS_MODE_CELT) ?\n\n                      out_tmp : s->celt_output;\n\n        int celt_output_samples = samples;\n\n        int delay_samples = av_audio_fifo_size(s->celt_delay);\n\n\n\n        if (delay_samples) {\n\n            if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n                av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples);\n\n\n\n                for (i = 0; i < s->output_channels; i++) {\n\n                    s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0,\n\n                                                delay_samples);\n\n                    out_tmp[i] += delay_samples;\n\n                }\n\n                celt_output_samples -= delay_samples;\n\n            } else {\n\n                av_log(s->avctx, AV_LOG_WARNING,\n\n                       \"Spurious CELT delay samples present.\\n\");\n\n                av_audio_fifo_drain(s->celt_delay, delay_samples);\n\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return AVERROR_BUG;\n\n            }\n\n        }\n\n\n\n        opus_raw_init(&s->rc, data + size, size);\n\n\n\n        ret = ff_celt_decode_frame(s->celt, &s->rc, dst,\n\n                                   s->packet.stereo + 1,\n\n                                   s->packet.frame_duration,\n\n                                   (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0,\n\n                                   celt_band_end[s->packet.bandwidth]);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (s->packet.mode == OPUS_MODE_HYBRID) {\n\n            int celt_delay = s->packet.frame_duration - celt_output_samples;\n\n            void *delaybuf[2] = { s->celt_output[0] + celt_output_samples,\n\n                                  s->celt_output[1] + celt_output_samples };\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                s->fdsp->vector_fmac_scalar(out_tmp[i],\n\n                                            s->celt_output[i], 1.0,\n\n                                            celt_output_samples);\n\n            }\n\n\n\n            ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n    } else\n\n        ff_celt_flush(s->celt);\n\n\n\n    if (s->redundancy_idx) {\n\n        for (i = 0; i < s->output_channels; i++)\n\n            opus_fade(s->out[i], s->out[i],\n\n                      s->redundancy_output[i] + 120 + s->redundancy_idx,\n\n                      ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx);\n\n        s->redundancy_idx = 0;\n\n    }\n\n    if (redundancy) {\n\n        if (!redundancy_pos) {\n\n            ff_celt_flush(s->celt);\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                opus_fade(s->out[i] + samples - 120 + delayed_samples,\n\n                          s->out[i] + samples - 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          ff_celt_window2, 120 - delayed_samples);\n\n                if (delayed_samples)\n\n                    s->redundancy_idx = 120 - delayed_samples;\n\n            }\n\n        } else {\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float));\n\n                opus_fade(s->out[i] + 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          s->out[i] + 120 + delayed_samples,\n\n                          ff_celt_window2, 120);\n\n            }\n\n        }\n\n    }\n\n\n\n    return samples;\n\n}", "idx": 1377, "substitutes": {"s": ["ls", "c", "p", "es", "n", "ses", "us", "gets", "ions", "its", "conf", "cs", "spec", "ains", "events", "ags", "h", "gs", "sb", "args", "os", "serv", "a", "stats", "sv", "settings", "vs", "details", "xs", "ds", "qs", "ants", "m", "less", "bs", "ims", "bis", "ties", "bes", "hs", "sts", "ins", "sq", "self", "S", "l", "ss", "als", "comm", "tes", "ns", "sw", "ms", "ts", "changes", "v", "ares", "ops", "sys", "is", "g", "times", "b", "fs", "aws", "ps", "parts", "js", "ads", "comments", "as", "sports", "rs", "ows", "ats", "t"], "data": ["image", "Data", "batch", "message", "input", "d", "buf", "value", "DATA", "format", "text", "p", "sample", "window", "ref", "r", "box", "dat", "none", "new", "extra", "def", "type", "pad", "rew", "buffer", " DATA", "str", "bin", "empty", "ata", "bytes", "in", "padding", "o", "raw", "base"], "size": ["number", "message", "l", "shift", "format", "count", "z", "to", "g", "n", "sample", "send", "m", "small", "sum", "space", "num", "shape", "type", "time", "SIZE", "e", "name", "len", "offset", "ize", "body", "scale", "too", "empty", "bytes", "padding", "fee", "max", "dim", "mem", "area", "length", "capacity", "Size"], "redundancy_size": ["redundancy_len", "redundantly_len", "redundantly_pos", "redundantly_size"], "redundancy_pos": ["redundancies_loc", "redundancies_position", "redundancy_position", "redundancy_loc", "redundancies_type", "redundancies_pos", "redundancy_type"], "ret": ["mt", "usr", "RET", "try", "summary", "mb", "format", "iter", "out", "gt", " Ret", "response", "ry", "rm", "hash", "f", "reset", "resp", "mem", "re", "back", "net", "count", "result", "deg", "cb", "ll", "it", "Ret", "gc", "alt", "rev", "ter", "get", "nt", "arg", "tr", "elt", "report", "j", "rest", "nl", "ref", "utils", "res", "prot", "ts", "str", "val", "last", "rets", "rem", "flag", "len", "cmd", "sys", "status", "arr", "value", "limit", "txt", "url", "ft", "def", "rt", "reg", "print", "pret", "nz", "t", "obj"], "i": ["j", "id", "ii", "p", "g", "n", "init", "pi", "index", "r", "m", "b", "it", "ij", "t", "ip", "im", "iu", "ir", "ind", "ix", "v", "mi", "si", "I", "f", "iat"], "consumed": ["cserved", "Consume", "consumption", "Consceived", "Consumption", "consume", "preserved", "consuming", "resuming", "offsumed", "coserved", "offsume", "cosumed", "resume", "offsceived", "resceived", "resumed", "csented", "cosumption", " consented", "Consumed", "offsumption", "reserved", "Conserved", "consented", "presumed", "conserved", "csumed", " consuming", "presumption", "csumption", " conserved", "presume", " consumption", "cosuming", "resumption", "consceived", "resented"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n", "idx": 1381, "substitutes": {"queue": ["consumer", "batch", "journal", "q", "message", "required", "list", "buf", "server", "menu", "ue", "sequence", "processor", "collection", "space", "Queue", "grid", "cue", "cache", "qu", "job", "dq", "Q", "config", "archive", "file", "block", "buffer", "command", "quit", "complete", "pool", "quote", "ques", "priority", "que", "client", "loop", "process", "channel", "topic", "line", "store", "module"], "next": ["success", "forward", "data", "j", "public", "net", "head", "key", "tmp", "jp", "code", "nd", "nl", "sec", "EXT", "to", "n", "result", "nil", "index", "node", "txt", " NEXT", "ng", "out", "sequence", "set", "used", "link", "Next", "ne", "start", "new", "valid", "entry", "seq", "info", "reply", "network", "gen", "job", "front", "normal", "future", "response", "fr", "first", "going", "null", "nt", "primary", "current", "nn", "fn", "gov", "prev", "missing", "latest", "button", "base", "self"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)\n\n{\n\n    int   band, result=0, numSubbands, lastTonal, numBands;\n\n\n\n    if (codingMode == JOINT_STEREO && channelNum == 1) {\n\n        if (get_bits(gb,2) != 3) {\n\n            av_log(NULL,AV_LOG_ERROR,\"JS mono Sound Unit id != 3.\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (get_bits(gb,6) != 0x28) {\n\n            av_log(NULL,AV_LOG_ERROR,\"Sound Unit id != 0x28.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* number of coded QMF bands */\n\n    pSnd->bandsCoded = get_bits(gb,2);\n\n\n\n    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);\n\n    if (result) return result;\n\n\n\n    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);\n\n    if (pSnd->numComponents == -1) return -1;\n\n\n\n    numSubbands = decodeSpectrum (gb, pSnd->spectrum);\n\n\n\n    /* Merge the decoded spectrum and tonal components. */\n\n    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);\n\n\n\n\n\n    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */\n\n    numBands = (subbandTab[numSubbands] - 1) >> 8;\n\n    if (lastTonal >= 0)\n\n        numBands = FFMAX((lastTonal + 256) >> 8, numBands);\n\n\n\n\n\n    /* Reconstruct time domain samples. */\n\n    for (band=0; band<4; band++) {\n\n        /* Perform the IMDCT step without overlapping. */\n\n        if (band <= numBands) {\n\n            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);\n\n        } else\n\n            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));\n\n\n\n        /* gain compensation and overlapping */\n\n        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),\n\n                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),\n\n                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));\n\n    }\n\n\n\n    /* Swap the gain control buffers for the next frame. */\n\n    pSnd->gcBlkSwitch ^= 1;\n\n\n\n    return 0;\n\n}\n", "idx": 1404, "substitutes": {"q": ["iq", "c", "qq", "p", "g", "query", "qi", "qs", "m", "u", "qt", "aq", "qu", "Q", "dq", "k", "ch", "w", "pkg", "eq", "ix", "v", "h", "o", "ck", "sq", "t", "Query"], "gb": ["Gb", "fc", "cd", "mb", "rg", "eb", "vg", "sg", "tg", "bd", "bm", "kb", "gif", "img", "py", "g", "cz", "pb", "cfg", "rect", "cb", "rb", "html", "phy", "gd", "cgi", "eg", "gt", "bb", "bt", "hub", "gnu", "cv", "goo", "um", "bg", "gc", "hm", "db", "io", "hz", "fb", "bytes", "GB", "gs", "binary", "sb", "cm", "bn", "raw", "gg", "gm", "nb", "bf", "vd", "asm", "gh"], "pSnd": ["pSetold", "expSendsd", "pNSND", "pmSfd", "expSst", "pInst", "pSendst", "pInsond", "pNSvd", "pcNvd", "expSsd", "pSetND", "pSetgn", "pSld", "pSold", "pAssst", "pSnw", " pSND", "PSgn", "lpSnd", "pNgn", "pSysnd", "pUst", "pDesst", "lpSnow", "pcNnt", "pSignnw", "pSnow", "pInsdd", "pInnt", "pAssnd", "PSnt", " pSdi", "jSind", "pEsnt", "pRsst", "pSourcend", "PRsnt", "pmSst", "PInND", "pInsst", "pWinnd", "jRsnt", "pSourceND", "pSchest", " pSnow", "pSst", "PInnd", "pLnt", "pInond", "pSND", "pSchend", "pmSdd", "pCsond", "pSourcest", "pcSvd", "pCSnd", "expSendnd", "pUnd", "pInnd", "pSetst", "pSdd", "pSendsd", "pSendnd", "jSND", "PSst", "pSchefd", "jSnt", " pSetnt", "lpSendcond", "pIndi", "pInsnd", "pSunw", "pSond", "pSessiongn", "lpSendsend", "pCsst", "pInsnt", "pSdi", "pkgInsnd", "pScond", "pSetsend", "pSsrc", "pSessionND", "pNSst", "pcNgn", "pSendND", "pSgn", "pPsst", "pRsind", "lpSendnd", "PSvd", "pcSnt", "lpSond", "pcNnd", "pDessrc", "PRsnd", "pWinst", "expSND", "pCSst", "PRsst", "pPssend", "pSetnd", "pRswin", "pkgInsst", "pcSgn", "pSunow", "PInst", "pRsnt", " pSnt", "pSourceold", "jSnd", "pSchedd", "pCSwin", "pCind", "pSind", "jRsND", "pmSchest", "lpSendnow", "pEsND", "lpSendst", "lpScond", "lpSendond", " pSnw", "pSetld", "pSvd", "pkgInsnt", "pCsend", "pSignnd", "pcSnd", "pSysvd", "pRsnd", "PInvd", "pSfd", "pSetind", "pSendcond", "pSsd", "pSwin", "pSendond", " pSetnd", "pSignst", "pmSchend", "pkgInsond", "PRswin", " pSsend", "expSendND", "pNnt", "PSetgn", "pSysgn", "pInvd", "pLgn", "pSessionnt", " pSold", "pCsnd", "pDesND", "pSessionnd", "pSnt", "pCnd", "pkgSnd", "lpSsend", "pInND", "pLst", " pSst", "expSendst", "pSessionvd", "pWinsend", "PSetst", "PSwin", "jRsind", "pCSnt", "pSund", "pUond", "pAsssend", "pCND", " pSsrc", "pCnt", "pEsnd", "pInsfd", "pInssend", "pkgSst", " pSld", "pInsnow", "pSessiondi", "pSetsd", "lpSst", "pNnd", "pNvd", "jRsnd", "pmSchedd", "PSnd", "pLnd", "pSendnow", "pUsend", " pSetsend", "expSnd", "pkgSond", "pDesnd", "pAsscond", " pSond", "pkgSnt", "pmSnd", "pWinond", "pRssrc", " pSetND", "PSND", "pPsnt", "PSetnt", "pSsend", "pPsnd", "pSignnow", "pSysnt", "pEssend", "pRsND", "pSendsend", "pCssend", "pSetnt", "PSetnd", "pmSchefd", "pNSnd", "pSust"], "pOut": ["POutput", " pout", "cpOutput", "PIn", "pIn", " pOutput", "pOutput", "cpout", "cpIn", "POut", " pIn", "mOut", "cpOut", "mIn", "mout", "pout", "Pout"], "channelNum": ["Channelnum", "channelNumber", "channelMon", " channelNumber", "chanNum", "channum", " channelnum", "ChannelNum", "chNum", "chanNumber", "chNumber", "chanMon", "chanNUM", "channelnum", "ChannelMon", "chanNo", " channelMon", "ChannelNumber", "chNUM", "channelNUM", "channelNo", "chNo", " channelNUM", " channelNo"], "codingMode": ["CodeMethod", "CordingMODE", "codedMODE", "CodingMode", "CodingMODE", "CordingMode", "Cordingmode", "codedMode", "cachingMode", "codingMODE", "CodeMode", "cordingMode", "cachingMODE", "CordingMethod", "Codemode", "cordingMethod", "codeMethod", "codeMode", "codingMethod", "CodeMODE", "cachingMethod", "codedMethod", "codeMODE", "codemode", "cachingmode", "codedmode", "CodingMethod", "cordingMODE", "codingmode", "Codingmode", "cordingmode"], "band": ["bound", "rad", "ard", "column", "step", "component", "bind", "node", "cloud", "weight", " step", "job", "board", "version", "disk", "ann", "ind", "ud", "channel", "art", "back", " channel", "batch", "d", "number", "key", " bin", "bd", "row", "plot", "bug", "filter", "kt", "bolt", "tag", "cell", "bright", "bid", "display", "brand", "brain", "byte", "day", "chain", "ide", "cd", "ond", "rod", "word", " column", "slot", "slice", "broad", "index", "power", "atch", "pixel", " coefficient", "part", "unk", "ord", "ask", "product", "connection", "block", "lag", " Band", "bin", "db", "flag", "card", "und", "work", "nd", "jack", "Band", "bands", "mid", "bit", "b", "plugin", " bit", "dom", "flash", "dB", "bridge", "frequency", "field", "stage"], "numSubbands": ["numberBframes", "numberSubbands", "numUBplanes", "numberSubframes", "numSuperbands", "numSplanes", "numSimages", "numSuperimages", "nSubplanes", "numSubimages", "numUBands", "numSbands", " numUBands", "nSuperands", "numSuperands", "numBframes", "numsubframes", "numberSubimages", "numsubimages", " numSubands", "numBplanes", "numberBimages", "nSuperimages", "numSubplanes", "numUBimages", "nSubbands", "numUBbands", "numBimages", "numSands", "numSuperplanes", "nSuperplanes", "nSuperbands", " numUBbands", "numberBbands", "nSubands", "nSubimages", "numBbands", "numsubbands", " numSubplanes", "numSuperframes", " numSubimages", " numUBplanes", " numUBimages", "numSubands", "numSubframes"], "lastTonal": ["lastVTones", "leftTonal", " lasttional", " lastRona", "lastNional", "lastETonal", " lastRally", "lastNona", " lastTally", "lastTonic", "lastRional", "lastRzon", "lasttones", "lastTimeoned", "lastTally", "leftEToned", "leftTional", "lastRones", "lasttonal", " lastRonal", "lastTional", "lastTiona", "lastTially", "lastVToned", "lastTandem", "lastVTandem", " lasttonic", "lasttandem", "lastVTonal", "lastRonal", "leftETonal", "lastRally", "lastLoned", "lastTimeones", "lastTones", "lastTona", "lastLional", "leftTzon", "lastTionic", "lasttonic", "lastRona", "lastNones", " lastTona", "lastRoned", "lastETzon", " lasttandem", " lastTional", " lasttonal", " lastTandem", " lastTonic", " lasttones", "lastTimeonal", "lastNonal", "leftETional", "lastRonic", "leftToned", "lasttoned", "lastNonic", "lastLonal", "lastTimeandem", "lastEToned", "lastNally", " lastToned", "lastLzon", "lastToned", " lastRonic", "lastTzon", " lasttoned", "lasttional", "lastETional", " lastTones", "leftETzon"], "numBands": ["numNannels", "NUMBonents", " numMones", "numTatches", "numMards", "numTodes", "numBRones", "numTones", "numbounds", "numChannels", "numChasks", " numModes", "numBeounds", "numBeonents", " numbands", "numBodes", " numBones", " numMards", "numNasks", " numBodes", "numMands", "numMannels", "numMbands", "numChards", " numbounds", "numBounds", " numBasks", " numMannels", "NUMBounds", " numBounds", "numNards", "numBRatches", "numNands", "numChounds", "NUMBeounds", " numMasks", "numBRands", "numTands", "NUMBebands", "numbbands", "NUMBands", "numModes", "numBones", "numTasks", "numBRasks", "numBatches", "numMonents", "numChodes", "numBannels", "numbasks", "numBeands", "NUMBeonents", " numBbands", "numBebands", " numMands", " numBatches", "numChones", "numbands", "numBasks", " numBards", "numChbands", " numbasks", "numMounds", "numChands", "numBbands", "NUMBbands", "numBards", " numBannels", "NUMBeands", "numMones", " numbbands", "numBonents", "numMasks"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n", "idx": 1420, "substitutes": {"md": ["mt", "nd", " dd", "bd", "dd", "dem", "ds", "td", "dh", " mm", "dm", "hd", "metadata", "mk", "df", "sm", "mn", "mm", "od", "ad", "det", "pd", "MD", "mc", "met", "cmd", "ld", "dn"], "val": [" aval", " value", "key", "value", " arg", "slot", "p", "Val", "ref", "index", "pol", "vt", "vals", "lit", "num", "pos", " Val", "mod", "VAL", "pr", " eval", "state", "fi", " index", "ival", "ctx", "bal", " v", "eval", "pt", "reg", "loc", "v", "vol", "sel", "col", "arg", "ee", "si", "al", "serv"], "env": ["proc", "ec", "bean", "data", "po", "tmp", "proven", "buf", "qv", "conn", "org", "cal", "eh", "ev", "window", "txt", "ah", "open", "vt", " ens", "cb", "environment", "nv", "em", "msg", "entry", "cur", "bar", "dev", "ef", "eu", "conf", "cv", "e", "ptr", "context", "en", "ctx", " en", "ped", "enc", "manager", "db", "ew", "v", "ten", "uv", "event", "ve", "gov", "state", "obj", "eng", "cmd", "sp"]}}
{"project": "FFmpeg", "commit_id": "b8664c929437d6d079e16979c496a2db40cf2324", "target": 0, "func": "static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)\n\n{\n\n    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);\n\n    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);\n\n}\n", "idx": 1426, "substitutes": {"dst": [" ddest", "adht", "idot", "dost", "idsrc", "ddest", "dust", "drest", "idrest", "mdst", "ldst", "dht", "nst", "idst", "dot", "idsts", "adst", "dhsts", "dtsrc", "pst", "nsts", " dstr", "ldsts", "dct", "dhost", "pest", "ddstr", "adost", "dhct", " dsrc", "mdstr", "ddst", " dest", "dsts", " dht", " dsts", "dsrc", "dest", "ldost", "post", "ldct", "dtst", "dtrest", " dot", "mddest", " dust", " dost", "dddest", "idust", "dtust", " dct", "pht", "dhst", " drest", "not", "adest", "dstr"], "block": ["proc", "Block", "batch", "data", "list", "inv", "word", "bc", "view", "bm", "isk", "row", "window", "BL", "box", "open", "label", "link", "filter", "b", "panel", "pack", "load", "part", "lock", "profile", "check", "info", "zero", "def", "type", "config", "ip", "file", "disk", "buffer", "bus", "array", "bin", "bo", "group", "range", "frame", "blocks", "vol", "bl", "hash", "event", "model", "sync", "join", "map", "chain"], "stride": ["strider", "trider", "STRipe", " strize", "stime", "tride", "STRide", "STRize", "STRider", "trize", "arrhide", "STRice", "wrice", "drride", " strine", " strider", " strime", "STRride", "dride", "wrride", " strride", "strhide", "STRage", "wride", "errider", "stipe", " strage", "shrride", "stize", "arrride", " strope", "striipe", "STRine", "strine", " strhide", " stripe", "striide", "stider", "strice", "shrice", "stide", " strice", "stine", "arride", "shrider", "strope", "striope", "strize", "drice", "arrider", "stage", "drider", "trride", "trice", "stripe", "strage", "striride", "STRope", "erride", "shride", "strime", "strride", "wrider", "erripe", "STRime", "STRhide", "errride"]}}
{"project": "qemu", "commit_id": "b86160555f8d1fe11d6bcec393e08e645d7e1e8d", "target": 1, "func": "static void integratorcp_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    const char *kernel_cmdline = args->kernel_cmdline;\n\n    const char *initrd_filename = args->initrd_filename;\n\n    ARMCPU *cpu;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);\n\n    qemu_irq pic[32];\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"arm926\";\n\n    }\n\n    cpu = cpu_arm_init(cpu_model);\n\n    if (!cpu) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(ram, NULL, \"integrator.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero*/\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n    /* And again at address 0x80000000 */\n\n    memory_region_init_alias(ram_alias, NULL, \"ram.alias\", ram, 0, ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);\n\n\n\n    dev = qdev_create(NULL, TYPE_INTEGRATOR_CM);\n\n    qdev_prop_set_uint32(dev, \"memsz\", ram_size >> 20);\n\n    qdev_init_nofail(dev);\n\n    sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000);\n\n\n\n    dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000,\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ),\n\n                                qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),\n\n                                NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].used)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &integrator_binfo);\n\n}", "idx": 1434, "substitutes": {"args": ["doc", "values", "aux", "atts", "arr", "images", "limits", "actions", "settings", "objects", "words", "flows", "names", "comm", "ants", "vals", "params", "full", "eds", "locks", "ars", "md", "aws", "units", "parts", "js", "users", "bs", "orders", "ads", "ians", "err", "terms", "amps", "flags", "ims", "ts", "points", "ams", "changes", "ras", "aps", "GS", "ags", "GV", "bits", "results", "yes", "gs", "arg", "yrs", "ins", "apps", "cmd", "Args"], "cpu_model": ["memory_machine", "cpuLEvector", "cpu_package", "apache00param", "cpu_mode", "cpu00param", "cpu_method", "cpu_Model", "cpu00package", "memorylemachine", "pu_model", "cpu_param", "apache00model", "pu_string", "cpu00model", "cpulemode", "apache_model", "cpuLEmode", "pu_module", "memoryletype", "cpu_vector", "cpu_type", "apache00package", "cpu_string", "apache_mode", "pu_library", "cpu00mode", "memorylemodel", " cpu_mode", "pu_mode", "apache_param", "cpulemodel", "cpuletype", "cpuitymode", "cpuitypackage", " cpu_Model", "cpu_library", "memory_type", "cpuLEmodule", "cpulemachine", "cpuityparam", "pu_vector", "apache_package", "cpu_module", "cpu_machine", "memorylemode", "memory_mode", "pu_method", "cpuitymodel", "cpuLEmodel", "apache00mode", "memory_model"], "kernel_filename": ["ernel_file", "kernelityfilename", "ernel_family", "kernel_family", "kernel_source", "kernelitymodel", "ernel_filename", "kernel_model", "knowledgeityfilename", "kernel_file", "knowledgeitymodel", "kernelacfilename", "kernelitysetup", "kernelacfile", "kernel_setup", "knowledge_setup", "knowledge_model", "kernelablefamily", "knowledge_filename", "kernelacmodel", "knowledgeityfile", "kernelacsetup", "kernelablefilename", "knowledgeitysetup", "kernelityfile", "kernelablefile", "knowledge_file", "kernelablesource", "ernel_source"], "kernel_cmdline": ["kernel_bindLine", "kernel_bindlines", "kernel_bindline", "kernel_catlines", "kernel_commandlines", "kernel_catline", "kernel_cpline", "kernel_commandLine", "kernel_cplines", "kernel_catpoint", "kernel_commandline", "kernel_cmdlines", "kernel_cpLine", "kernel_cmdpoint", "kernel_commandpoint", "kernel_cmdLine", "kernel_bindpoint"], "initrd_filename": ["initrd_file", "initrd__filename", "initrdistfilename", "initrb_directory", "initrdetyjson", "initrdistdirectory", "initrd_fn", "initrh_files", "initrd__json", "initrh__directory", "initrh__files", "initrdetyfiles", "initrd_json", "initrdistfn", "initrh__filename", "initrh_json", "initrb_file", "initrd__directory", "initrb_filename", "initrd_directory", "initrdetyfilename", "initrh_filename", "initrd__files", "initrh_directory", "initrdetydirectory", "initrb_fn", "initrh__json", "initrd_files", "initrdistfile"], "cpu": ["proc", "core", "sys", "cp", "aux", "device", "phys", "c", "pc", " CPU", "cn", "chip", "pu", "hw", "gpu", "CPU", "util", "node", "processor", "memory", "pixel", "linux", "cache", "pai", "prof", "cow", "boot", "tp", "crypt", "mu", "uart", "nice", "cum", "cam", "ctx", "aco", "nic", "computer", "gc", "bo", "apache", "mac", "clock", "cu", "uu", "null", "process", "os", "mem", "socket", "density"], "address_space_mem": ["address_space__mb", "address_space2mem", "address_space___mem", "address_space_memory", "address_space__memory", "address_space2mc", "address_part2memory", "address_space__mem", "address_part2mc", "address_space_ram", "address_space_gem", "address_part_mc", "address_part_mem", "address_system_mb", "address_space_mb", "address_system_memory", "address_part2mem", "address_space2memory", "address_space___gem", "address_system_gem", "address_space2mb", "address_space___reg", "address_space2ram", "address_part_memory", "address_part2ram", "address_system_reg", "address_system_mem", "address_part_ram", "address_space_mc", "address_space_reg"], "ram": ["core", "ma", "mb", "ro", "room", "rom", "sim", "iam", "row", "ran", "hw", "rain", "mc", "rank", "lam", "path", "memory", "sum", "ra", "ank", "tar", "gram", "gem", "vm", "disk", "cam", "sam", "RAM", "rum", "resource", "gc", "ras", "bin", "region", "reg", "mm", "am", "rm", "mac", "process", "program", "Ram", "sky", "dim", "na", "raw", "mem", "scan", "tem", "gra"], "ram_alias": ["mem_role", "mem_ali", "mem_prefix", "ram_role", "mem_shadow", "mem_alias", "mem_ias", "ram_ias", "rammmias", "ram_prefix", "rammmrole", "rammmshadow", "mem_ghost", "ram_shadow", "rammmalias", "ram_ghost", "ram_ali"], "pic": ["sys", "fc", " pc", "pc", "p", "ics", "py", "eric", "ic", "pi", "iac", "fig", "agic", "pict", "mic", " nic", "icon", "picture", "Pict", "ig", "fi", "oc", "script", "arc", "cam", "peg", "Pic", "pins", "pl", "px", "nic", "gc", "wic", "cu", "pin", "icc", "si", "ac", "mc", "sci", "sp"], "dev": ["data", "d", "env", "device", "pro", "vo", "adv", "conn", "dd", "pu", "ev", "ow", "hw", "window", "row", "gpu", "dem", "ds", "var", "van", "unknown", "serial", "def", "priv", "mem", "pad", "iv", "gu", "push", "sd", "hd", "disk", "der", "cam", "w", "ptr", "wd", "stick", "ver", "Device", "home", "de", "go", "DEV", "db", "v", "vision", "nt", "ad", "av", "rem", "ve", "des", "Dev", "serv"], "i": ["multi", "j", " m", "ii", "l", "c", " j", "is", "z", "wi", "sim", "p", "n", "xi", "ic", "pi", "index", "s", "ci", "li", " di", "ami", "m", " e", "ei", "x", "cli", "us", "ui", "gi", "it", "ij", "ex", " ti", "ip", " ii", "gu", "y", " pi", " l", "ims", "bi", " x", "im", "e", "ms", "ti", "iu", " I", " v", "ind", "ix", "v", "zi", "in", "mi", "di", "ini", "\u0438", "ai", "I", "si", " k", "t", "a", " bi"]}}
{"project": "qemu", "commit_id": "30c367ed446b6ea53245589a5cf373578ac075d7", "target": 1, "func": "static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n", "idx": 1435, "substitutes": {"obj": ["sys", "j", "oid", "tmp", "inv", "vo", "vr", "object", "bh", "conn", "p", "org", "attr", "hw", "any", "ref", "onet", "act", "unknown", "cont", "obs", "vp", "it", "cmp", "priv", "ex", "js", "iv", "xy", "ctx", "Obj", "ob", "bo", "nt", "o", "av", "os", "t", "cmd"], "v": ["vc", "d", "j", "q", "l", "vu", "c", "V", "vr", "sv", "p", "conv", "g", "n", "ev", "vs", "r", "vt", "m", "vim", "b", "x", "vp", "vi", "vy", "tv", "vm", "cv", "w", "o", "uv", "h", "f"], "opaque": ["opoxy", "popaques", "popaque", "oaque", "pacity", "oacity", "oaques", "paque", "opacity", "oplface", "oplaque", "popacity", "oplacity", "popoxy", "opaques", "buffacity", "oploxy", "buffface", "buffaque", "pface", "opface", "oplaques", "ooxy"], "name": ["domain", "data", "NAME", "nam", "key", "size", "word", "value", "no", "format", "pro", "san", "n", "attr", "description", "names", "label", "path", "m", "ame", "part", "family", "info", "none", "qual", "type", " names", "title", "reason", "tag", "local", "cap", "error", "comment", "version", "normal", " Name", "alias", "str", "nm", "am", "group", "category", "in", "Name", "named", "prefix", "mem", "property"], "errp": ["attrpt", "ererps", "errorr", "diep", "derpb", "errorpt", "derp", " errm", "errphp", "errpre", "dieP", "ererphp", "errorp", "ererpre", " errpa", "attrp", "ermpre", "erm", " errP", " errpb", "diepa", "errpa", "derP", "errorpre", " errr", " errps", "errorP", "err", "diepb", "erp", "ermp", "errorps", "derpa", "errps", "ermphp", "errm", "attrP", "errorm", "errr", " errpt", "errpt", "attrps", "ermps", "errpb", "ererp", "errP", "errorphp"], "dev": ["proc", "d", "env", "device", "pro", "buf", "addr", "conn", "dep", "ev", "attr", "hw", "dem", "vt", "nv", "unknown", "md", "def", "priv", "mem", "gu", "conf", "sd", "desc", "w", "cam", "wd", "ver", "Device", "home", "de", "go", "DEV", "tech", "od", "eng", "nt", "det", "ve", "av", "os", "des", "Dev", "dis", "fo"], "prop": ["proc", "cp", "key", "pro", "ph", "op", " props", "po", "buf", "tmp", "term", "p", "pri", "dep", "ev", "attr", "pb", "claim", "cfg", "kind", "m", "lit", "pos", "info", "priv", "def", "prof", "pr", "ps", "opt", "conf", "desc", "Prop", "ctx", "comp", "spec", "prov", "pkg", "pred", "pt", " Prop", "properties", "col", "pid", "cmd", "property"], "peers_ptr": ["peersPobj", "peersPptr", "peers_obj", "pelers_tr", "peersPpt", "peer_tmp", "peersPtmp", "peers_tr", "peers_tmp", "peer_ptr", "pelers_arr", "peers_p", "peer_pt", "peers_pt", "pelers_ptr", "peers_arr", "pelers_p", "peer_obj"], "ptr": ["proc", "br", "ctr", "eth", "func", "tmp", "arr", "jp", "addr", "vr", "port", "p", "attr", "ref", "hw", "pointers", "inters", "pointer", "Ptr", "pos", "dh", "cur", "pad", "pr", "tp", "iv", "kw", "xt", "err", "prime", "pend", "ts", "ctx", "adr", "dest", "rev", "pt", "dr", "sp", "expr", "ret", "pers", "src", "__", "tr", "th", "rep", "inter", "pert", "pri"], "local_err": ["local_r", "initial___Er", "local2error", "local2buf", "local___msg", "localErer", " local_r", "initial___msg", "local___r", "localErerr", "local___err", "initial_msg", "initial___err", "local_mr", " local_error", "localErEr", "local__rr", " local_mr", "initial_arr", "local_priv", "local___buf", "local___arr", "localErarr", "local2err", "local___er", "initial_Er", " local_rr", "localErmsg", "local__mr", "local2er", " local_er", "local2priv", "initial___arr", "localErerror", "local_error", "local_buf", "local_rr", "local__err", "local2r", "localErpriv", "local_Er", "initial_err", " local_priv", " local_buf", "local___Er", "local_msg", "local_arr", "local__error", "local_er"], "id": ["ide", "oid", "key", " tid", "iden", "no", "addr", " rid", "is", "port", "p", "rid", " fid", " lid", "ref", "index", "Id", "ider", " pid", "url", "mid", " mid", "ids", "num", "gd", "tx", "orig", " org", " done", "it", "type", "pad", "time", "tag", "ip", "did", "uid", " offset", "sid", "vid", "bid", "od", "ident", "h", "hid", "ick", "ID", "peer", "wid", "pid", "kid", "ime", "len", "fd"], "hubport": ["hubPORT", "homepool", "ubport", "ubclient", "hostPORT", "hubserver", "broadport", "ubPort", "homePort", "busserver", " hubPORT", "hubpage", "busport", "hubconnection", "ubconnection", "broadclient", "homestate", "hostconnection", "hubstate", "hostserver", " hubserver", "hubPort", "buspage", "broadserver", "hubpool", "hostPort", "busconnection", "ubpage", " hubPort", "homePORT", "hubclient", "homeport", " hubstate", "ubserver", "ubstate", "homeserver", "homeclient", "broadpool", "hostport", "ubPORT", "hostpage", "ubpool"]}}
{"project": "FFmpeg", "commit_id": "16c429166ddf1736972b6ccce84bd3509ec16a34", "target": 1, "func": "static av_cold int png_dec_end(AVCodecContext *avctx)\n\n{\n\n    PNGDecContext *s = avctx->priv_data;\n\n\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n\n    av_frame_free(&s->previous_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n\n    av_frame_free(&s->last_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->picture);\n\n    av_frame_free(&s->picture.f);\n\n    av_freep(&s->buffer);\n\n    s->buffer_size = 0;\n\n    av_freep(&s->last_row);\n\n    s->last_row_size = 0;\n\n    av_freep(&s->tmp_row);\n\n    s->tmp_row_size = 0;\n\n    av_freep(&s->extra_data);\n\n    s->extra_data_size = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 1439, "substitutes": {"avctx": [" avkt", "avctl", " avreq", "ravcpp", "avcomp", "avcli", "invcli", "avconn", "avectx", "averkt", "averproc", "avectl", "avecomp", "avecc", "avercpp", "avercomp", "aveconn", "avercontext", "avcpp", "ravcli", "avproc", "avercli", "aveproc", "ravproc", "invcmd", "avecpp", "averconn", "averctl", " avcomp", " avctl", " avcontext", "avereq", "avercmd", "invctx", "avekt", "avcontext", "avcc", "avecontext", "avreq", "avercc", "avkt", " avcmd", "avecli", "invcontext", "averreq", "ravcc", " avcli", "avcmd", "ravconn", "averctx", "ravctx"], "s": ["sys", "ls", "S", "stats", "erences", "l", "is", "sv", "ss", "scl", "es", "als", "g", "z", "session", "sl", "vs", "details", "ass", "ess", "comm", "ds", "qs", "b", "params", "fs", "less", "us", "tes", "aws", "services", "ps", "its", "parts", "js", "ns", "bs", "sw", "sd", "ims", "comments", "w", "ms", "sam", "as", "ts", "cs", "spec", "changes", "hs", "has", "sts", "eps", "rs", "h", "bits", "results", "pers", "gs", "ats", "sb", "ins", "sq", "os", "sync", "ops"]}}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n", "idx": 1457, "substitutes": {"chr": ["chrt", "childrt", " Chr", "cheor", "echrb", "chear", " chrt", "chrs", " chrs", " Chor", "chrd", "echar", "childR", "chrb", "Chrb", "Char", "ichr", "echrs", "echr", "childr", "childrl", " Char", "ichrl", " chrb", " chrl", "Chr", "ichrt", " Chrd", "ichR", " chor", " chrd", "chrl", " chR", "cher", "chor", "cherd", "chR", "Chrs"], "s": ["sys", "ls", "j", "S", "serv", "stats", "l", "is", "sv", "ss", "es", "n", "service", "sl", "vs", "details", "comm", "set", "ds", "qs", "m", "b", "fs", "less", "https", "services", "ps", "js", "ns", "bs", "y", "bis", "sam", "ports", "cs", "ts", "spec", "sports", "changes", "hs", "sts", "rs", "client", "gs", "sb", "ats", "args", "sq", "so", "ins", "store", "states", "sync", "se", "self"]}}
{"project": "FFmpeg", "commit_id": "73a60633143b7c51333a0772b45a47282ac445b6", "target": 1, "func": "static int probe_file(WriterContext *wctx, const char *filename)\n\n{\n\n    AVFormatContext *fmt_ctx;\n\n    int ret, i;\n\n    int section_id;\n\n\n\n    do_read_frames = do_show_frames || do_count_frames;\n\n    do_read_packets = do_show_packets || do_count_packets;\n\n\n\n    ret = open_input_file(&fmt_ctx, filename);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n#define CHECK_END if (ret < 0) goto end\n\n\n\n    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));\n\n    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));\n\n    selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));\n\n\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        if (stream_specifier) {\n\n            ret = avformat_match_stream_specifier(fmt_ctx,\n\n                                                  fmt_ctx->streams[i],\n\n                                                  stream_specifier);\n\n            CHECK_END;\n\n            else\n\n                selected_streams[i] = ret;\n\n            ret = 0;\n\n        } else {\n\n            selected_streams[i] = 1;\n\n        }\n\n    }\n\n\n\n    if (do_read_frames || do_read_packets) {\n\n        if (do_show_frames && do_show_packets &&\n\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n\n        else if (do_show_packets && !do_show_frames)\n\n            section_id = SECTION_ID_PACKETS;\n\n        else // (!do_show_packets && do_show_frames)\n\n            section_id = SECTION_ID_FRAMES;\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_header(wctx, section_id);\n\n        ret = read_packets(wctx, fmt_ctx);\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_footer(wctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_programs) {\n\n        ret = show_programs(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_streams) {\n\n        ret = show_streams(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_chapters) {\n\n        ret = show_chapters(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_format) {\n\n        ret = show_format(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\nend:\n\n    close_input_file(&fmt_ctx);\n\n    av_freep(&nb_streams_frames);\n\n    av_freep(&nb_streams_packets);\n\n    av_freep(&selected_streams);\n\n\n\n    return ret;\n\n}\n", "idx": 1469, "substitutes": {"wctx": ["rwtx", "wcmp", "rwkb", "wordctx", "wactx", "wlc", "wordcas", "rwtxt", " wcas", "wdctx", "wtx", "rwcontext", "Wcas", "wordcontext", "wscm", "wcas", "watxt", "wdcm", "wordtx", " wlc", "wcontext", "wtxt", "Wcmp", "walc", "Wcontext", " wtxt", "wskb", " wtx", "wdkb", " wcm", "wdcmp", "wscmp", " wcmp", "Wtx", "wcm", "rwlc", "Wctx", "rwctx", "wsctx", " wcontext", "wacm", "rwcmp", "wkb", "rwcm"], "filename": ["fp", "ames", "fil", "kan", "FIL", "directory", "source", "ename", "fle", "txt", "kl", "kj", "path", "ame", "bol", "title", "file", "username", "name", "nom", "ln", "nm", "FN", "til", "Filename", "src", "sbm", "png", "abl", "fn", "prefix", "jpg"], "fmt_ctx": ["fmt_tz", "ftx_cpp", "fprintfkcpp", "fmt___cb", "fmt___tx", "fmtktx", "fmt5tx", "fmtDctx", "fmtkns", "fmt___ctx", "fmt_ns", "ftx_context", "flt_tx", "fprintf_ctx", "fmt_tmp", "fmtkctx", "fmt_tx", "fMT_tx", "flt_ctx", "fmtTchan", "fmt_chan", "fmt5ctx", "fmtTtx", "fMT_obj", "fprintfkctx", "fprintfktx", "ftx_obj", "fprintf_cpp", "firm_cmd", "fmt_cmd", "flt_cb", "flt_context", "fmt___context", "fmt5kw", "fprintfkns", "fmtkcpp", "fprintf_tx", "fmt_kw", "fmt2ctx", "firm_ctx", "fmt_cb", "fmt2context", "fmt_context", "fmt_cfg", "firm_resp", "fmt_cpp", "fmtTctx", "ftx_conn", "fmtTtz", "fmt2tx", "fmt_conn", "fmtDtz", "fMT_context", "ftx_cfg", "fmtDtx", "ftx_tx", "fMT_ctx", "fprintf_ns", "firm_tmp", "fmt_resp", "fmt_obj", "fmt5conn", "fmtDchan", "ftx_kw", "ftx_ctx", "fmt2obj"], "ret": ["mt", "usr", "RET", "try", "mb", "out", "set", "x", "gt", " Ret", "xt", "ry", "rm", "hash", "f", "__", "reset", "resp", "re", "mem", "back", "net", "result", "deg", "ll", "Ret", "final", "gc", "ter", "alt", "get", "nt", "arg", "tr", "elt", "j", "jp", "dt", "nr", " RET", "ref", "index", "utils", "res", "att", "fi", "err", "vet", "ts", "val", "rets", "det", "rem", "flag", "len", "cmd", "status", "arr", "value", "Return", "ft", "red", "cont", "def", "rt", "reg", "print", "dr", "mat", "t"], "i": ["multi", "batch", "j", "id", "try", "l", "ii", "ki", "ji", "c", "is", "z", "p", "sim", "n", "xi", "ic", "index", "pi", "me", "iter", "qi", "ci", "li", "m", "ei", "x", "u", "cli", "ui", "info", "phi", "it", "gi", "ij", "ip", "oi", "fi", "y", "ims", "bi", "im", "iu", "ti", "ir", "ind", "uri", "io", "ix", "remote", "zi", "in", "mi", "ini", "di", "ai", "I", "si", "f", "ri", "point", "t", "inter"], "section_id": ["sectionitytype", "section_num", "sector_ids", "sectionityids", "room_dir", "section_type", "section_mid", "section2index", "section2name", "section_index", " section_ID", "room_id", "section_name", "section2id", "sector_ID", "sector_id", " section_name", "sector_type", "room_ids", " section_index", "section_ID", "sector_uid", "sectionitytry", "room_num", "section2ids", " section_mid", "sector_try", "sector_name", "section_ids", "section_dir", " section_ids", "section_uid", "sectionityid", "section_try"], "selected_streams": ["selected_pathensions", "selected_reamts", "selected_streamensions", "selected_streamments", "selected_streamS", "selected_buildts", "selected_sws", "selected_paths", "selected_integn", "selected_integis", "selected_logS", "selected_framesl", "selected_streamis", "selected_pathS", "selected_streameds", "selected_Streamensions", "selected_streamts", "selected_followl", "selected_builders", "selected_framesments", "selected_threadments", "selected_pathis", "selected_threaders", "selected_buildeds", "selected_swis", "selected_builds", "selected_streaml", "selected_streamn", "selected_integs", "selected_framess", "selected_reameds", "selected_streamers", "selected_threads", "selected_pathn", "selected_reams", "selected_StreamS", "selected_Streams", "selected_reamers", "selected_swS", "selected_threadl", "selected_swn", "selected_logs", "selected_follows", "selected_logensions", "selected_integS", "selected_threadeds", "selected_threadts", "selected_followments"]}}
{"project": "qemu", "commit_id": "51b0c6065aa6e47a47094d73e24be298a4a7f3a1", "target": 1, "func": "static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n\n                                          target_phys_addr_t end_addr)\n\n{\n\n    KVMState *s = kvm_state;\n\n    unsigned long size, allocated_size = 0;\n\n    KVMDirtyLog d;\n\n    KVMSlot *mem;\n\n    int ret = 0;\n\n\n\n    d.dirty_bitmap = NULL;\n\n    while (start_addr < end_addr) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n\n        if (mem == NULL) {\n\n            break;\n\n        }\n\n\n\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n\n        if (!d.dirty_bitmap) {\n\n            d.dirty_bitmap = qemu_malloc(size);\n\n        } else if (size > allocated_size) {\n\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n\n        }\n\n        allocated_size = size;\n\n        memset(d.dirty_bitmap, 0, allocated_size);\n\n\n\n        d.slot = mem->slot;\n\n\n\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n\n            ret = -1;\n\n            break;\n\n        }\n\n\n\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n\n                                      mem->start_addr, mem->memory_size);\n\n        start_addr = mem->start_addr + mem->memory_size;\n\n    }\n\n    qemu_free(d.dirty_bitmap);\n\n\n\n    return ret;\n\n}\n", "idx": 1473, "substitutes": {"start_addr": ["target_block", "start_pad", "startlyhandle", " start_address", "start_pos", "startptaddress", "end_pos", "st_addr", "startingaddr", " start_ord", "start_hash", "start_ptr", "startptaddr", "start_ord", "end_handle", " start_pad", "startingelt", "start_phys", "starting_ord", "start_handle", "start_map", "startpthandle", "target_ord", "startpthash", "startingpad", "startlyaddress", "start_block", "starting_elt", "starting_addr", "st_address", "start_elt", "startlyaddr", "target_ptr", "end_address", "startingaddress", "st_phys", "startingphys", " start_elt", "startlyhash", "end_hash", "target_addr", "starting_map", "startptpos", "start_address"], "end_addr": ["endipaddress", "endingiploc", "end_name", " end_mem", "endingipmt", "end_mt", " end_address", "endiparp", "endipres", "end_loc", "endipname", "ending_res", "endingipres", "end_address", "ending_mt", " end_date", "endableaddr", "endablemt", "endpyres", "end_res", "end_arp", "end_mem", "endpyaddr", "endpyloc", "ending_addr", "endpymt", "end_date", "endableres", "endiploc", "endableloc", " end_arp", "endipmt", "ending_loc", "endingipaddr", "endipaddr", " end_name"], "s": ["sys", "j", "S", "q", "south", "c", "is", "ss", "p", "g", "n", "sl", "r", "comm", "ds", "m", "i", "space", "b", "fs", "sc", "ps", "js", "ns", "t", "w", "sam", "ts", "spec", "str", "spe", "sm", "hs", "sts", "rs", "v", "h", "gs", "sb", "os", "sq", "state", "socket"], "size": ["chain", "south", "number", "city", "message", "l", "shift", "use", "count", "height", "sh", "z", "news", "g", "n", "index", "set", "send", "score", "see", "small", "sum", "space", "sent", "num", "export", "needed", "info", "new", "weight", "cache", "zero", "shape", "type", "storage", "scope", "length", "SIZE", "en", "span", "name", "ity", "member", "offset", "ize", "scale", "empty", "bytes", "address", "fee", "max", "si", "dim", "zone", "grow", "t", "area", "len", "capacity", "Size", "sp"], "d": ["j", "rd", "l", "dt", "dj", "c", "nd", " dd", "bd", "z", "p", "dd", "dict", "n", "dx", "dc", "ded", "result", "g", "dump", "r", "debug", "ds", "td", "m", "dat", " dr", "b", " dw", "gd", "red", "md", "dh", "def", "mod", "dq", "dev", "ed", "dm", "y", "k", "sd", "did", "diff", "dl", "w", "hd", "df", "de", "ind", "db", "dr", "v", "h", "di", "dn", "du", "done", "ad", "f", "dim", "D", "pd", "da", "o", "ld", "fd"], "mem": ["mt", "mb", "hw", "sum", "hist", "ann", "emb", "ind", "med", "rm", "am", "dim", "resp", "serv", "my", "deg", "lim", "dem", "m", "msg", "known", "im", "um", "sam", "gc", "member", "loc", "mm", " Mem", "nt", "mc", "mop", "j", "addr", "slot", "all", "Mem", "mp", "memory", "cache", "snap", "gem", "ms", "pool", "nm", "go", "mac", "val", "address", "mi", "rem", "ram", "imm", "met", "doc", "data", "alloc", "arm", "temp", "tim", "item", "term", "sim", "iam", "txt", "em", "mx", "md", "tm", "js", "metadata", "sm", "reg", "mat", "raw", "t", "buff"]}}
{"project": "FFmpeg", "commit_id": "eb465b8c56d455fddf0f4f9f2625e2fe3ff7ea06", "target": 1, "func": "static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],\n\n                   int dst_stride[3], int src_stride[3], int width,\n\n                   int height, uint8_t *qp_store, int qp_stride)\n\n{\n\n    int x, y, i, j;\n\n    const int count = 1<<p->log2_count;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int is_chroma = !!i;\n\n        int w = width  >> (is_chroma ? p->hsub : 0);\n\n        int h = height >> (is_chroma ? p->vsub : 0);\n\n        int stride = p->temp_stride[i];\n\n        int block = BLOCK >> (is_chroma ? p->hsub : 0);\n\n\n\n        if (!src[i] || !dst[i])\n\n            continue;\n\n        for (y = 0; y < h; y++) {\n\n            int index = block + block * stride + y * stride;\n\n\n\n            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );\n\n            for (x = 0; x < block; x++) {\n\n                p->src[i][index     - x - 1] = p->src[i][index +     x    ];\n\n                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];\n\n            }\n\n        }\n\n        for (y = 0; y < block; y++) {\n\n            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);\n\n            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);\n\n        }\n\n\n\n        p->frame->linesize[i] = stride;\n\n        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));\n\n    }\n\n\n\n    if (p->qp)\n\n        p->frame->quality = p->qp * FF_QP2LAMBDA;\n\n    else {\n\n        int qpsum=0;\n\n        int qpcount = (height>>4) * (height>>4);\n\n\n\n        for (y = 0; y < (height>>4); y++) {\n\n            for (x = 0; x < (width>>4); x++)\n\n                qpsum += qp_store[x + y * qp_stride];\n\n        }\n\n        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;\n\n    }\n\n//    init per MB qscale stuff FIXME\n\n    p->frame->height = height;\n\n    p->frame->width  = width;\n\n\n\n    for (i = 0; i < count; i++) {\n\n        const int x1 = offset[i+count-1][0];\n\n        const int y1 = offset[i+count-1][1];\n\n        const int x1c = x1 >> p->hsub;\n\n        const int y1c = y1 >> p->vsub;\n\n        const int BLOCKc = BLOCK >> p->hsub;\n\n        int offset;\n\n        AVPacket pkt;\n\n        int got_pkt_ptr;\n\n\n\n        av_init_packet(&pkt);\n\n        pkt.data = p->outbuf;\n\n        pkt.size = p->outbuf_size;\n\n\n\n        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];\n\n        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];\n\n        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];\n\n        p->frame->format  = p->avctx_enc[i]->pix_fmt;\n\n\n\n        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);\n\n        p->frame_dec = p->avctx_enc[i]->coded_frame;\n\n\n\n        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];\n\n\n\n        for (y = 0; y < height; y++)\n\n            for (x = 0; x < width; x++)\n\n                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];\n\n\n\n        if (!src[2] || !dst[2])\n\n            continue;\n\n\n\n        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];\n\n\n\n        for (y = 0; y < height>>p->vsub; y++) {\n\n            for (x = 0; x < width>>p->hsub; x++) {\n\n                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];\n\n                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];\n\n            }\n\n        }\n\n    }\n\n\n\n    for (j = 0; j < 3; j++) {\n\n        int is_chroma = !!j;\n\n        if (!dst[j])\n\n            continue;\n\n        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],\n\n                      width  >> (is_chroma ? p->hsub : 0),\n\n                      height >> (is_chroma ? p->vsub : 0),\n\n                      8-p->log2_count);\n\n    }\n\n}\n", "idx": 1476, "substitutes": {"p": ["cp", "parent", "op", "c", "n", "P", "bp", "app", "pg", "page", "vp", "xp", "ap", "pkg", "pre", "h", "f", "pd", "resp", "this", "fp", "br", "d", "q", "pm", "np", "pb", "m", "policy", "it", "at", "tp", "pa", "dp", "rep", "self", "php", "wp", "l", "jp", "power", "progress", "patch", "parse", "part", "info", "cache", "ctx", "v", "current", "point", "sp", "proc", "public", "lp", "pc", "up", "g", "r", "pp", "b", "pe", "ps", "ip", "local", "command", "post", "o", "t", "ping", "pro"], "dst": [" ddest", "lsts", "dsdest", "Ddest", "ddest", "drc", " drc", "iddest", "idst", "lst", "lsc", "idsts", "dssts", "dsst", "dsts", "Dsts", "dsrc", "Dst", "Dsc", "Drc", "dsc", "idsc", "ldest", " dsts"], "src": ["proc", "sys", "input", "inst", "usr", "sync", "ctr", "stack", "tmp", "host", "addr", "sh", "source", "sec", "stat", "slice", "img", "rob", "sl", "stock", "s", "iter", "rect", "dist", "lib", "url", "look", "reverse", "load", "sc", "seq", "obs", "cur", "scene", "syn", "sur", "bs", "sub", "ser", "sr", "config", "trans", "ch", "desc", "content", "ptr", "buffer", "stream", "comp", "via", "rl", "dest", "str", "rt", "bin", "loc", "rs", "in", "target", "stab", "rc", "sb", "st", "ins", "sn", "secure", "serv", "ssl", "std", "supp"], "dst_stride": ["dst_strIDE", "dst_encIDE", "dst_stringIDE", "dst_drride", "dst_dride", "dst_strride", "dst_stringride", "dst_encider", "dst_drIDE", "dst_encride", "dst_strider", "dst_drider", "dst_stringider", "dst_encide", "dst_stringide"], "src_stride": ["src_striade", "src_Strride", "src_ride", "src_striider", "src_striime", "src_rride", "src_stringider", "src_strade", "src_Strider", "src_strride", "src_striride", "src_strider", "src_stringade", "src_rider", "src_stringride", "src_Strade", "src_striide", "src_strime", "src_Strime", "src_rime", "src_Stride", "src_stringide"], "height": ["total", "ty", "bottom", "he", "Height", "size", "count", "view", "row", "resolution", "window", "yt", "rank", "memory", "html", "volume", "ih", "shape", "history", "ch", "block", "dimension", "depth", "angle", "padding", "h", "sky", "hang", "dim", "th", "capacity", "density", "length", "gh", "ht"], "qp_store": ["qop_source", "qp__source", "qp_Store", "qp_source", "qp_base", "qp__base", "qp2store", "qop_store", "qp2source", "qp2Store", "qp__Store", "qp__store", "qop_base", "qp2base", "qop_Store"], "qp_stride": ["qp_arrider", "qp_lenim", "qp_arrim", "qp_trride", "qp_lenide", "qp_trider", "qp_arrride", "qp_strim", "qp_strider", "qp_lenride", "qp_lenider", "qp_tride", "qp_strride", "qp_trim", "qp_arride"], "x": ["fx", "key", "l", "xt", "add", "item", "value", "c", "xc", "z", "g", "n", "dx", "xf", "xi", "lex", "index", "r", "xa", "ax", "act", "m", "ox", "lat", "mx", "tx", "nex", "u", "at", "xe", "ex", "xy", "time", "content", "k", "ch", "ux", "w", "e", "xp", "el", "xx", "xxx", "px", "rx", "yx", "ix", "v", "on", "xd", "cross", "o", "wx", "h", "ice", "f", "xes", "t", "X"], "y": ["year", "ty", "key", "uy", "isy", "axy", "hot", "yl", "no", "ay", "z", "iy", "py", "ley", "my", "row", "cy", "index", "wy", "ym", "yt", "gy", "sy", "aily", "ady", "b", "page", "ya", "iley", "it", "yer", "type", "ey", "yr", "xy", "vy", "ed", "dy", "ch", "block", "entity", "w", "e", "kit", "a", "Y", "ies", "io", "ry", "v", "yy", "o", "h", "sky", "by", "ly", "hy", "oy", "ot", "ys", "ny", "yi", "ye", "yet", "yo"], "i": ["id", "try", "c", "wi", "n", "init", "iter", "ish", "li", "k", "iu", "ti", "ir", "ind", "uri", "ix", "zi", "h", "ini", "I", "f", "ik", "a", "batch", "list", "xi", "any", "ic", "qi", "m", "u", "ui", "it", "ex", "ims", "im", "bis", "io", "\u0438", "ri", "yi", "l", "ii", "iq", "ji", "iri", "index", "pi", "me", "asi", "ci", "ei", "info", "ij", "history", "bi", "err", "hi", "v", "mi", "di", "ai", "si", "multi", "ki", "status", "item", "is", "sim", "g", "ami", "b", "cli", "gi", "ip", "oi", "ie", "ia", "in", "o", "iat"], "j": ["jump", "q", "l", "jp", "ji", "z", "aj", "g", "n", "r", "m", "b", "pos", "it", "J", "ij", "jl", "js", "k", "ch", "jc", "ind", "v", "col", "f", "rel", "jj"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "int main(void)\n\n{\n\n    int nf;\n\n    Suite *s;\n\n    SRunner *sr;\n\n\n\n    s = qfloat_suite();\n\n    sr = srunner_create(s);\n\n\n\n    srunner_run_all(sr, CK_NORMAL);\n\n    nf = srunner_ntests_failed(sr);\n\n    srunner_free(sr);\n\n\n\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n\n}\n", "idx": 1487, "substitutes": {"nf": ["niefr", " nrf", "Nfe", " nF", "niefe", "Nf", "nonfe", " nfo", "nnfo", "Nrf", "lnf", "lnfe", "nF", "nfr", " nfe", "nxf", "nonrf", "nfo", "lnxf", "nfe", "Nfr", "niexf", "nief", "Nxf", "dnF", "nnxf", "dnf", "nnF", "dnfo", "nrf", "lnfr", "nonf", "nnf", "dnxf", " nxf"], "s": ["sys", "ls", "S", "is", "sv", "ss", "als", "g", "n", "sl", "r", "ses", "ers", "ds", "space", "fs", "us", "new", "iss", "ps", "its", "js", "ns", "bs", "ms", "ts", "cs", "ies", "hs", "sts", "rs", "gs", "f", "si", "sb", "ins", "ats", "os", "sq", "t", "ys"], "sr": ["mr", "usr", "gr", "cr", "lr", "rg", "nr", "vr", "sv", "hr", "sl", "r", "ru", "sf", "rb", "rw", "asper", "yr", "sur", "ser", "kr", "rf", "rh", "shr", "SR", "fr", "rr", "rx", "rl", "adr", "rt", "spr", "hs", "rs", "rm", "ker", "gs", "tr", "sol", "nor", "rar", "rn"]}}
{"project": "qemu", "commit_id": "d78c19b5cf4821d0c198f4132a085bdbf19dda4c", "target": 0, "func": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    IOMMUTLBEntry entry;\n\n    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;\n\n\n\n    if (index >= tcet->nb_table) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-bounds IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcet->table[index] = tce;\n\n\n\n    entry.target_as = &address_space_memory,\n\n    entry.iova = ioba & page_mask;\n\n    entry.translated_addr = tce & page_mask;\n\n    entry.addr_mask = ~page_mask;\n\n    entry.perm = spapr_tce_iommu_access_flags(tce);\n\n    memory_region_notify_iommu(&tcet->iommu, entry);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 1497, "substitutes": {"tcet": ["ticect", "pcset", "ncset", "encet", "sicect", " tcot", "fcett", "ticET", "tcette", " tconet", "cusET", "ancet", "fcet", "usercette", "ticet", "TCET", "tcett", "usercET", "sicet", "ucet", "tced", "lcET", "encset", "tconet", "ncet", "fcET", "camET", "cusets", "usercect", "TCet", "ticett", "camet", "encety", "ncect", " tcET", "tocect", "tcety", "lcet", "ancect", "tciet", "camiet", "ctet", "tcot", "lcect", "TCot", "ancET", "ucets", "ctot", "TCett", "fcect", "pcet", "sicette", "sicET", "tcET", "encect", "TCets", "ucett", "ucET", "tociet", "cusett", "tcect", " tced", "usercet", "TCette", "ncety", "pcect", "pcety", "tcets", "TConet", "TCiet", "TCect", "tcset", "tocET", "cuset", "TCed", "lced", "camect", "ancett", "ctonet", " tcect", "ctET", "tocet"], "ioba": ["iioba", " ioy", " iobe", "iioby", "iiobar", "lialeb", "iiob", "liobar", "tioba", "iiouf", " ialeb", "ioby", " ionga", " iouf", " ioby", "iob", "sioba", "iioy", "ialeb", "xioba", " iob", "iuoba", "xiobar", "ionga", " iibi", "iobe", "itiazo", "iobar", "siobar", "sionga", "xiob", "iowa", "iuowa", "iazo", "tiowa", "itiouf", "iuobe", "iibi", "sialeb", "iuibi", "ioy", "iouf", "xioy", "tiibi", "lioba", " iobar", " iazo", "lionga", "tiobe", " iowa", "itioba", "itioby", "iiazo"], "tce": ["tmce", "fke", "wke", "ccer", " tCE", "wCE", "tcer", "mce", "ktce", "mCE", " tces", "tmace", "Tcer", "fces", "tcoe", "pces", "tmcer", "Tce", "tces", " tke", "cce", "tmCE", "teCE", " tcer", "fCE", "cces", "pcoe", " tace", "mces", "ktcer", "ccoe", "tecer", "pce", "wce", "fce", "tece", "ktcoe", "mcer", "Tace", "teces", "tace", "wcer", "ktces", "TCE", "tCE", "wces", "pcer", "tke"], "entry": ["try", "match", "ent", "set", "see", "response", " ace", "ry", " estimate", "enter", "line", "rance", " row", " enter", "key", "list", "row", "element", "result", "ce", "check", "cue", "cell", "entity", "search", "option", "member", "ew", " slot", "ident", "nt", "ace", "aux", "word", "er", " entrance", "record", " keyword", "index", " argument", "comment", "error", "attribute", "existent", " segment", "insert", "or", "address", "oe", "pair", "se", "inter", "add", "phrase", " ep", "way", "import", "query", "table", " candidate", "cont", "delete", "ary", " office", "writer", "Entry", "desc", "ie", "e", "ment", "escape", "print", "primary", "RY", "event", "obj"]}}
{"project": "qemu", "commit_id": "f73a2575a3bce8a3c487331c918d2c0f9b2e489d", "target": 0, "func": "static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr,\n\n                            target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong pteh = args[2];\n\n    target_ulong ptel = args[3];\n\n    target_ulong i;\n\n    uint8_t *hpte;\n\n\n\n    /* only handle 4k and 16M pages for now */\n\n    if (pteh & HPTE_V_LARGE) {\n\n#if 0 /* We don't support 64k pages yet */\n\n        if ((ptel & 0xf000) == 0x1000) {\n\n            /* 64k page */\n\n        } else\n\n#endif\n\n        if ((ptel & 0xff000) == 0) {\n\n            /* 16M page */\n\n            /* lowest AVA bit must be 0 for 16M pages */\n\n            if (pteh & 0x80) {\n\n                return H_PARAMETER;\n\n            }\n\n        } else {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    /* FIXME: bounds check the pa? */\n\n\n\n    /* Check WIMG */\n\n    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {\n\n        return H_PARAMETER;\n\n    }\n\n    pteh &= ~0x60ULL;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n    if (likely((flags & H_EXACT) == 0)) {\n\n        pte_index &= ~7ULL;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        for (i = 0; ; ++i) {\n\n            if (i == 8) {\n\n                return H_PTEG_FULL;\n\n            }\n\n            if (((ldq_p(hpte) & HPTE_V_VALID) == 0) &&\n\n                lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n                break;\n\n            }\n\n            hpte += HASH_PTE_SIZE_64;\n\n        }\n\n    } else {\n\n        i = 0;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n            return H_PTEG_FULL;\n\n        }\n\n    }\n\n    stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel);\n\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n\n    stq_p(hpte, pteh);\n\n\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    args[0] = pte_index + i;\n\n    return H_SUCCESS;\n\n}\n", "idx": 1500, "substitutes": {"env": ["ec", "eas", "er", "code", "buf", " environment", "era", "inv", "operator", "conn", "org", "init", "ev", "window", "vs", "server", "ah", "viron", "environment", "engine", "em", "policy", "vp", "network", "dev", "ef", "t", "shell", "end", "conf", "man", "vm", "context", "e", "w", "setup", "en", "den", "equ", "ctx", "origin", "con", "manager", "ew", "v", "h", "uv", "erd", "te", "event", "ve", "estate", "state", "obj", "eng", "map", "cmd", "Environment", "sp"], "spapr": ["spspr", "spapR", " spaprd", "spsprs", "spsprd", "spopR", "spiprd", " spaprs", "spipR", "spaprd", " spipr", "spoprd", "spspR", " spiprd", "spoprs", "spipr", " spapR", " spiprs", " spipR", "spopr", "spaprs", "spiprs"], "opcode": ["popco", "opco", "opsco", "pco", "pcodes", "opcodes", "popcode", "opsec", "opssec", "popsec", "opscodes", "popcodes", "opscode", "pcode", "psec"], "args": ["related", "bugs", "values", "aux", "func", "atts", "limits", "actions", "objects", "files", "words", "workers", "names", "xs", "qs", "roots", "vals", "params", "fs", "fields", "members", "aws", "units", "modules", "parts", "js", "ns", "bs", "users", "conf", "ims", "err", "flags", "arms", "ms", "as", "ts", "grades", "points", "ams", "cs", "ties", "ras", "changes", "facts", "range", "ags", "blocks", "bits", "results", "gs", "arg", "cmd", "Args"], "i": ["multi", "j", "id", "ni", "d", "l", "ii", "c", "is", "p", "sim", "g", "xi", "pi", "index", "qi", "ci", "li", "m", "ei", "b", "x", "u", "cli", "ui", "info", "phi", "it", "gi", "ip", "fi", "gu", "y", "k", "bi", "e", "hi", "iu", "ti", "io", "ix", "v", "zi", "in", "mi", "o", "di", "ini", "ai", "I", "si", "f", "t", "this"], "hpte": ["hapte", "hptonor", "Hported", "hapten", "hptyee", " hpter", "hptyes", " hctee", "Hporte", "Hportee", "hpt_", "hpointee", "hspte", " hptest", "hpport_", "hportse", "hptes", "hiptee", "hputor", "hptyeg", "hitopen", "htoped", "hpute", "ohshot_", "hptonen", "hporteng", "hshot_", " hctest", " hportse", "hepte", "hapted", "hcter", "hputen", "hptor", " hporter", "hpointe", "hporter", " hptee", "Hpted", " hportee", "hportes", "hcte", "hitope", "ohpt_", "hptone", "hpteg", "hpteng", "hipte", " hporte", "hsptoneg", "hpportee", "hptse", "hapteng", "hptoneg", "hsptonen", "hpportse", "hepteng", " hported", "hporte", "hspten", "hapter", "hportest", "hipten", "hpporte", "htopen", "hepted", "hpointes", " hctes", "hitoped", " hcte", "hpted", "heptee", "hpter", "hpointer", "hctes", "hpten", "hsptor", "hsptone", " hporteng", " hptes", "hpointed", "hapt_", " hpted", " hpteng", "hporten", "hptee", "haptee", "haptes", "hportee", "hptyest", "hported", " hcter", "haptse", "htopee", "hipted", "hptyen", "hsptonor", "hctee", "hpporter", "htope", "Hpter", " hptse", "hctest", "Hporter", "hptest", "hspteg", "hitopee", "Hptee", "Hpte", "hptye", "hptyor", "hputeg"]}}
{"project": "qemu", "commit_id": "ffe30937c89dd67a53bf3f35b962701cd9d8f70e", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 1507, "substitutes": {"ctx": ["sys", "stack", "cp", "cas", "func", "jp", "c", "pc", "xc", "bc", "nc", "handle", "cn", "conn", "p", "conv", "kb", "ca", "hw", "np", "kl", "txt", "cfg", "cb", "x", "tx", "kt", "sc", "req", "cmp", "history", "config", "ctl", "kw", "cf", "context", "cv", "tc", "setup", "wd", "xp", "cpu", "pkg", "obj", "rt", " cx", "cc", "cu", "nt", "wx", "ct", "gz", "cm", "Context", "resp", "mc", "jac", "cmd", "sp"], "ret": ["mt", "sys", "RET", "try", "tmp", "status", "jp", "buf", "conn", "result", "ref", "txt", "out", "vt", "res", "ft", "gb", "gt", "etc", "def", "mem", "Ret", "tor", "cv", "buffer", "cpu", "rx", "gc", "obj", "alt", "rt", "rev", "reg", "get", "ry", "v", "val", "rets", "null", "nt", "nz", "ct", "expr", "arg", "rc", "rem", "reset", "resp", "elt", "t", "re", "tc", "uf", "cmd"], "arg1": [" arg01", "arg3", "doc1", "args0", " arg8", "ument2", "tag1", "arg0", "ument25", "argument0", "args1", "args3", "argument3", "t3", "arg01", "ument1", " arg0", "t2", "arg25", "doc01", "tag2", "doc8", "argument01", "arg8", "argument1", "argument2", "tag3", " arg25", " arg3", "ument3", "args2", "doc0", "t25", "argument8"], "arg2": ["arg3", "param1", "param02", " arg5", "args02", "tag1", "arg0", "args1", " arg02", "argument0", "args3", "tag0", "args5", "param3", " arg0", "arg5", "argument5", "tag2", "param2", "argument1", "argument2", "tag3", " arg3", "args2", "arg02", "tag02", "tag5"], "add_ca": ["addtcu", "create__ca", "addCalluca", "add_cu", "drawtaco", "create_ba", "create__ba", "add__ca", "addCallba", "add__uca", "add_aco", "add_ba", "addbedba", "add___cu", "drawtlocal", "addbedpa", "draw_cu", "addCallca", "create_uca", "add__pa", "addtaco", "create_pa", "add__ba", "addCallpa", "create_ca", "drawtca", "add___aco", "attach_Ca", "attach_ca", "create__uca", "attach_cas", "add_local", "create__pa", "addtca", "add___ca", "addbedca", "draw_ca", "draw_local", "add_pa", "draw_aco", "add___local", "drawtcu", "addtlocal", "add_uca", "addbeduca", "add_cas", "add_Ca"], "compute_ca": ["computeableco", "computationableac", "computed___ca", "comperve___ci", "compute_ac", "comperve_ca", "computationableca", "compute_cm", "compute___ca", "compute_car", "compute___pa", "computeablece", "computationablece", "compute_aca", "computeableba", "computation_ac", "computation_co", "comperve_mc", "compute___mc", "compress_car", "compute_ci", "comperve___ca", "computed_ca", "compute___car", "computed___pa", "compress___ca", "compute_ce", "compress_ca", "computeableac", "compress___car", "computeableca", "computation_ca", "compress_cm", "computed_aca", "computeablemc", "comperve___ba", "compress___cm", "computationableco", "compute_mc", "comperve_ci", "computation_ce", "comperve___mc", "compute_pa", "compute___ci", "computed_pa", "compute___cm", "compress_aca", "compute___ba", "compress___aca", "compute_co", "compute___aca", "comperve_ba", "computed___aca", "computeableci", "compute_ba"], "compute_ov": ["compute___kov", "computes_uv", "compUTE_uv", "compute_ola", "computelyother", "computeableoss", "compute_os", "computation___ola", "computeingov", "compile_av", "computation_ola", "compute_kov", "computation_kov", "computeateoss", "compUTEingvo", "compute_other", "computation_av", "compUTEingoss", "compile_ov", "compUTEinguv", "compUTEingov", "computeateuv", "computeableov", "computation___ov", "compute___ov", "computeatevo", "computelyav", "computeateov", "computeableova", "computes_ob", "computes_ov", "compute_vo", "computeinguv", "computes_ova", "compute_uv", "computation_ov", "computeingvo", "compute_oss", "compute___ola", "compUTE_oss", "compute___av", "computelyos", "computation___av", "compile_other", "compute_ob", "computation___kov", "compUTE_ov", "computeableuv", "compUTE_vo", "compute_ova", "computelyov", "compile_os", "computeablevo", "compute_av", "computeingoss", "computeableob"], "t0": ["m0", " tok", "dtok", "at1", "Top", "it0", " t3", " top", "t3", "Tout", "t5", "T255", "th0", "p0", "t2", "t13", "Tthis", "tcok", "p4", "T2", " t2", "wt255", "ttZero", "tt5", "tId", "th1", "atZero", " tout", " t5", "p1", "dt0", "tt255", "it13", " t9", "tk", "at3", "wt15", "tZero", " t4", "ttout", " t000", "T5", "m13", "t255", "mk", "Tk", "dt1", "tt15", "at0", " tId", "tt4", "t9", "l4", " tale", "T15", "tale", "TZero", "wt2", "wt1", "m9", "wtale", "tc0", "t15", "T9", "tt000", "th2", "tc1", "T000", "t000", "l1", "T3", "tt0", "ttthis", "dtId", "wt13", "top", "tt1", "l0", " tthis", " t255", "m15", " tk", "it15", "p3", "T1", "m1", "tout", "at15", "t4", "T4", "tcId", "ttop", "ttk", "thale", "tthis", "m2", "l2", "th255", "wt0", "T0", "p2", "it1", "tok", "thk"], "t1": ["p1", "te1", "arg9", " t8", "l0", "te8", "arg3", " tob", "rt1", " t001", " t9", "t01", "Tone", "p3", "arg0", " t01", "rt01", "T1", "tdn", " tn", " t3", "T01", "v2", "Tob", "t3", "l01", "pt001", "td0", "T9", "tone", "p0", " tone", "t2", "t8", "tob", "T001", "T8", "t001", "l1", "te0", "tn", "pt1", "T3", "T2", "tdob", " t2", "v0", "v001", "rt0", "td001", "t9", "v1", "T0", "teone", "p2", "ptn", "td01", "td1"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t*)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    mm_end = end - 7;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            \"movq       %%mm0, %%mm6    \\n\\t\"\n\n            \"movq       %%mm3, %%mm7    \\n\\t\"\n\n\n\n            \"movq         8%1, %%mm0    \\n\\t\"\n\n            \"movq         8%1, %%mm1    \\n\\t\"\n\n            \"movq         8%1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r), \"m\"(mmx_null)\n\n            :\"memory\");\n\n        /* borrowed 32 to 24 */\n\n        __asm__ volatile(\n\n            \"movq       %%mm0, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"movq       %%mm6, %%mm0    \\n\\t\"\n\n            \"movq       %%mm7, %%mm1    \\n\\t\"\n\n\n\n            \"movq       %%mm4, %%mm6    \\n\\t\"\n\n            \"movq       %%mm5, %%mm7    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm1, %%mm3    \\n\\t\"\n\n\n\n            STORE_BGR24_MMX\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s)\n\n            :\"memory\");\n\n        d += 24;\n\n        s += 8;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n    }\n\n}\n", "idx": 1508, "substitutes": {"src": ["sys", "input", "inst", "ctr", "usr", "source", "sv", "ss", "img", "sl", "r", "out", "rb", "b", "x", "ur", "start", "sc", "gb", "cur", "obs", "sur", "bs", "sw", "sr", "rl", "dest", "ind", "rt", "RC", "rs", "in", "rc", "sb", "st", "tr", "ins", "rn", "sn"], "dst": ["bbl", "bST", "bsts", " dST", " dbl", "Dth", "dssts", "dsst", "dST", "dsts", "bth", "Dsts", "dbl", "DST", " dth", "Dst", "dth", "bst", "dsbl", " dsts", "dsST"], "src_size": ["src_Size", " src_height", "sys_size", " src_Size", "src_length", " src_length", "src_height", "src_SIZE", "sys_SIZE", "src_limit", "sys_limit"], "end": ["END", "id", "ff", "size", "rest", "nd", "z", "ent", "p", "ss", "all", "set", "send", "m", "ending", "b", "start", "ended", "ex", "stop", "ed", "w", "e", "en", "End", "dest", "offset", "v", "last", "eng", "h", "est", "max", "ad", "st", "begin", "t", "se", "length"], "mm_end": ["MM_End", "mm2END", " mm_END", "mm_begin", "mm2start", "mm_length", "mm_ends", "mm_End", "mm2End", "mm_END", "mem_end", "mm_start", "mem_length", " mm_End", "MM_start", "mm2end", " mm_start", "mem_ends", "MM_end", "MM_begin"], "d": ["j", "l", "dt", "c", "z", "p", "dd", "g", "n", "dc", "r", "ds", "m", "i", "b", "x", "dm", "k", "sd", "w", "e", "v", "h", "di", "o", "ad", "f", "D", "st", "da", "t", "a", "dn"], "s": ["sys", "ls", "S", "q", "j", "south", "l", "size", "c", "is", "sv", "ss", "p", "source", "es", "g", "n", "sl", "r", "mys", "set", "ds", "m", "i", "b", "x", "u", "fs", "start", "tes", "sym", "ps", "its", "js", "ns", "ims", "w", "e", "ms", "ts", "cs", "ies", "hs", "sts", "v", "rs", "h", "gs", "si", "sb", "ins", "st", "t", "a", "se", "sp"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_dgram_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai, *peer = NULL, *local = NULL;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock = -1, rc;\n\n\n\n    /* lookup peer addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = \"localhost\";\n\n    }\n\n    if (port == NULL || strlen(port) == 0) {\n\n        fprintf(stderr, \"inet_dgram: port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: peer (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, peer);\n\n    }\n\n\n\n    /* lookup local addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    ai.ai_family = peer->ai_family;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"localaddr\");\n\n    port = qemu_opt_get(opts, \"localport\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = NULL;\n\n    }\n\n    if (!port || strlen(port) == 0)\n\n        port = \"0\";\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: local (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, local);\n\n    }\n\n\n\n    /* create socket */\n\n    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n", "idx": 1519, "substitutes": {"opts": ["opermes", " opcons", "optfs", "OPps", "imtes", "opspx", "opTS", "Opnt", "iopTS", "opt", "opsTS", "oppt", "Opouts", "imt", "experts", "opfs", "OPs", "opth", " opfs", "opsmes", "opsth", " opbs", "opps", "expernt", "optioncons", " ops", "prots", "opsgs", "Opts", "opbs", "imTS", "ioptes", "opttes", "optes", "operouts", "OPpt", "imts", "OpTS", "optTS", "opsmits", "opsouts", "operth", "opcons", "opmes", "props", " opmes", "optbs", "optionfs", "opnt", " opnt", "iopts", "operts", "propt", "optgs", "operpx", "Opmes", "optcons", "optnt", "OPts", "optionbs", "ops", "Opth", " opmits", " opps", "opsts", "experTS", "iopt", "operTS", " oppt", "optionts", "opgs", "opsnt", "pros", "optt", "opmits", "Oppx", "expergs", "oppx", "optts", "opouts", "Opmits"], "ai": ["ka", "trace", "api", "AE", "aj", "ain", " pa", "server", "aug", "iii", "aki", "cgi", "pac", "auc", " a", "ae", "ti", "an", "am", "admin", "hai", "a", "asm", "aste", " bi", "htt", "link", "mic", "aim", "ui", "aci", "tp", " ta", " na", "pa", "im", "ar", "arp", "av", "aus", "acs", "ak", " ad", "aux", "cas", "ati", "iq", " mi", " au", "asi", "aa", "me", "ci", "sa", "ao", "oa", "ei", "dat", " ac", "i", "info", "aq", "ait", "air", " sa", "bi", "hi", "address", "mi", "di", "AI", "ias", "auth", " ba", "arm", "add", "aaa", "ay", "iam", "ais", "attr", "ca", "ami", "asc", "ua", "ali", "au", "pai", "wm", "ta", "config", "aos", "irm", " an", "alias", "adr", "ia", "ha", " am", "ac"], "peer": ["proc", "reader", "fp", "ace", "parent", "usr", "message", "inner", "user", "holder", "er", "instance", "pc", "host", "component", "soc", "p", "meta", "actor", "rer", "attr", "ca", "server", "node", "package", "proxy", "table", "header", "i", "other", "pod", "part", "family", "pe", "type", "tp", "ser", "player", "context", "ptr", "owner", "e", "attribute", "name", "ctx", "ae", "pool", "pkg", "remote", "group", "per", "target", "client", "address", "channel", "ker", "root", "primary", "worker", "prefix", "socket", "master", "this", "self"], "local": ["inner", "pc", "mask", "dir", "localhost", "server", "node", "lib", "link", "native", "other", "lock", "shared", "cache", "loader", "file", "global", "loc", "remote", "client", "primary", "sel", "raw", "lang", "ac", "socket", "master", "self"], "addr": ["id", "Address", "bind", "hw", "iter", "off", "http", "wd", "ap", "ae", "pkg", "ix", "hash", "admin", "art", "az", "a", "ld", "fx", "dir", "coord", "aim", "at", "ack", "ptr", "rr", "alt", "loc", "offset", "ar", "arp", " address", "ost", "elt", "rel", "ace", "host", "nl", "ref", "amp", "oa", "ord", "att", "pad", "ns", "err", "str", "aer", "ag", "db", "mac", "on", "urg", "address", "aud", "src", "prefix", "map", "cmd", "add", "eth", "arr", "conn", "attr", "r", "align", "url", "tx", "pos", "dh", "au", "ip", "adr", "rt", "dr", "rs", "ress", "ad", "ac", "oad", "obj", "area"], "port": ["mt", "cp", "trace", "component", "p", "pn", "order", "server", "path", "proxy", " sport", "page", "pod", "pg", "form", "pr", "version", "ports", "peg", "pkg", "queue", "per", "nel", "timeout", "socket", "br", "q", "number", "net", "eport", "key", "test", "shift", "phy", "export", "tp", "file", "ptr", "get", "offset", "padding", "dp", "position", "tr", "unit", "rel", "secure", "length", "total", "host", "to", "tty", "pi", "part", "type", "pad", "pse", "porter", "pool", "until", "pt", "target", "address", "col", "mobile", "pid", "point", "phone", "len", "pport", "Port", "public", "eth", "pc", "limit", "ported", "select", "pp", "be", "pos", "ip", "nat", "ort", "project", "null", " Port", "PORT", "tel", "t", "ping", "pro"], "uaddr": ["usrc", "pusrc", " usrc", "uaddress", "puaddress", " uaddress", "puaddr"], "uport": ["uPORT", " uPORT", " uPort", "UPort", "pPORT", "pPort", "Uport", "uPort", "pport", "UPORT"], "rc": ["ec", "cor", "isc", "fc", "ro", "pc", "c", "nc", "bc", "row", "init", "dc", "ref", "result", "r", "uc", "cb", "rb", "res", "sc", "ok", "cur", "ack", "roc", "config", "irc", "error", "err", "arc", "rh", "cs", "rec", "rr", "rx", "rl", "gc", "co", "rt", "RC", "ror", "loc", "ry", "rs", "cc", "src", "col", "ck", "resp", "ac", "sync", "rn"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_file_size(FTPContext *s)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    char *res = NULL;\n\n    const int size_codes[] = {213, 0};\n\n\n\n    snprintf(command, sizeof(command), \"SIZE %s\\r\\n\", s->path);\n\n    if (ftp_send_command(s, command, size_codes, &res)) {\n\n        s->filesize = strtoll(&res[4], NULL, 10);\n\n    } else {\n\n        s->filesize = -1;\n\n        av_free(res);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    av_free(res);\n\n    return 0;\n\n}\n", "idx": 1525, "substitutes": {"s": ["sys", "ls", "S", "q", "l", "c", "sg", "is", "sv", "ss", "p", "g", "n", "session", "service", "r", "details", "ses", "ess", "set", "ds", "qs", "m", "b", "fs", "https", "sc", "aws", "services", "ps", "its", "js", "ns", "bs", "sw", "scope", "http", "y", "w", "bis", "sam", "ports", "cs", "ts", "spec", "go", "hs", "sts", "eps", "rs", "client", "h", "o", "gs", "f", "ats", "sb", "sq", "so", "esm", "t", "sync", "asm", "ops", "self", "sn"], "command": ["domain", "template", "message", "key", "size", "code", "value", "format", "directory", "Command", "height", "which", "service", "description", "result", "query", "package", "power", "mode", "menu", "sequence", "table", "password", "condition", "form", "usage", "controller", "request", "delete", " Command", "type", "history", "execute", "config", "call", "error", "normal", "buffer", "attribute", "response", "method", "name", "pattern", "resource", "function", "statement", "empty", "address", "position", "clear", "direction", "prefix", "capacity", "length", "cmd", "chain"], "res": ["mr", "pres", "sys", "j", "proc", "usr", "Res", "gr", "RES", "arr", "rest", "er", "sec", "p", "resources", "ev", "result", "ref", "resh", "r", "times", "vs", "out", "ds", "vals", "respons", "tx", "pos", "red", "us", "req", "mem", "cons", "ps", "js", "bs", "ser", "err", "ms", "cs", "fr", "pas", "rev", "reg", "remote", "rs", "ress", "val", "nt", "vol", "results", "ret", "rem", "ins", "reset", "rc", "resp", "rep", "des", "re", "serv", "cmd", "rek"], "size_codes": ["size2code", " size_values", "size2values", "size_values", "size_bits", "size2codes", "size2odes", "size_code", " size_odes", "size_odes", " size_bits", " size_code"]}}
{"project": "qemu", "commit_id": "68d45bb61c5bbfb3999486f78cf026c1e79eb301", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)\n\n{\n\n    TCGReg datalo, datahi, addrlo, rbase;\n\n    TCGReg addrhi __attribute__((unused));\n\n    TCGMemOpIdx oi;\n\n    TCGMemOp opc, s_bits;\n\n#ifdef CONFIG_SOFTMMU\n\n    int mem_index;\n\n    tcg_insn_unit *label_ptr;\n\n#endif\n\n\n\n    datalo = *args++;\n\n    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);\n\n    addrlo = *args++;\n\n    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);\n\n    oi = *args++;\n\n    opc = get_memop(oi);\n\n    s_bits = opc & MO_SIZE;\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    mem_index = get_mmuidx(oi);\n\n    addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, true);\n\n\n\n    /* Load a pointer into the current opcode w/conditional branch-link. */\n\n    label_ptr = s->code_ptr;\n\n    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);\n\n\n\n    rbase = TCG_REG_R3;\n\n#else  /* !CONFIG_SOFTMMU */\n\n    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;\n\n    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {\n\n        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);\n\n        addrlo = TCG_REG_TMP1;\n\n    }\n\n#endif\n\n\n\n    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {\n\n        if (opc & MO_BSWAP) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0));\n\n        } else if (rbase != 0) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo));\n\n            tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0));\n\n        } else if (addrlo == datahi) {\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n        } else {\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n        }\n\n    } else {\n\n        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];\n\n        if (!HAVE_ISA_2_06 && insn == LDBRX) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0));\n\n            tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0);\n\n        } else if (insn) {\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n        } else {\n\n            insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n            insn = qemu_exts_opc[s_bits];\n\n            tcg_out32(s, insn | RA(datalo) | RS(datalo));\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,\n\n                        s->code_ptr, label_ptr);\n\n#endif\n\n}\n", "idx": 1533, "substitutes": {"s": ["sys", "ls", "S", "south", "stats", "er", "c", "is", "sv", "ss", "p", "es", "source", "g", "n", "scl", "z", "simple", "r", "ses", "out", "set", "ds", "qs", "comm", "m", "b", "x", "space", "fs", "less", "us", "ps", "its", "js", "ns", "sw", "y", "ims", "w", "e", "as", "cs", "ts", "sm", "hs", "sts", "rs", "v", "single", "h", "o", "gs", "f", "ats", "sb", "ins", "sq", "os", "t", "a", "ssl", "self"], "args": ["aux", "stats", "func", "atts", "arr", "aw", "limits", "actions", "seconds", "objects", "faces", "checks", "workers", "names", "caps", "pointers", "icks", "qs", "ants", "params", "eds", "gets", "ars", "fields", "aws", "members", "parts", "js", "ns", "axis", "tags", "kw", "ims", "orders", "ians", "flags", "amps", "terms", "ts", "cs", "points", "ams", "keys", "grades", "changes", "types", "GS", "tests", "ags", "abis", "blocks", "properties", "posts", "bits", "gs", "arg", "ats", "yrs", "acs", "cats", "Args"], "is_64": ["is_63", " is_32", " is_864", "is_32", "is_864", "is_24", "Is_24", "Is_64", " is_63", "Is_864"], "datalo": ["buffla", "Datla", "datacha", "datalin", "datale", "codalo", " datla", " datacha", "buffacho", "ttahi", "Datalo", "datla", "buffalo", "Datalan", "Datacho", "datao", " datacho", " datale", "ttalin", "codahi", "buffale", "Datahi", "Datalin", "ttalan", "dateahi", "Datale", "codao", " datao", "datalan", " datalin", "datacho", " datalan", "dateao", "dateacha", "ttalo", "datealo", "codacha"], "datahi": ["ratagi", "dataah", "ratahi", "rataxy", "dataowa", "dtah", "datama", "dtowa", "catahi", "datagi", "catagi", "catama", "dtagi", "dtama", "datah", "dataman", "dataaman", "ratama", " datah", "cataxy", "dtahi", "dataahi", "datowa", "dataxy", " dataman", "dtaxy", " datowa", "dtaman"], "addrlo": ["addrso", "addrlow", "addlo", "alignli", "attrlo", "attrso", "addrloop", "addhi", "addrln", " addrlow", " addrla", "attrLO", "addrno", "drlow", "addso", "alignno", "addrelo", "addresslo", "addrLo", "adelo", "ressla", " addrLO", "ranklo", "offsetlo", "adrLo", "drli", "alignlow", " addrln", "actla", "offsetelo", "rankloop", "rankla", "rankstro", "ressloop", "drno", " addrLo", "addrla", "attrno", " addrstro", "addno", "offsetno", "addrLO", "actlo", "adno", "offsetla", "attrhi", "ressstro", "actro", " addrelo", "adrno", "addrro", "orderlo", "alignlo", "actLO", "adlo", "attrlow", "orderli", "addrli", " addrloop", "resslo", "adrlo", "actno", "orderLo", "orderln", "addrstro", "adrso", "addressno", "addressso", "adrln", "attrro", "actlow", " addrro", " addrso", "drlo", "adrli", "addressla", " addrli", "adla", " addrno"], "rbase": ["lbalance", "rarbase", "mrBase", "Rstart", "rarbalance", " rbalance", "rcdomain", "ropad", "nrbas", "mbase", "Rspace", "nrbase", "rspace", "rbit", "rbas", " rstart", "mrstart", "rstore", "lbase", "robase", "rarpad", "robalance", " rbal", "mrstore", "mrspace", "mrbalance", "rbal", "rcbase", " rstore", " rbit", " rbas", "Rbit", "rarbas", "rdomain", "nrbal", "rcbal", "Rbase", "lBase", "rstart", "rcbas", "lstore", "rbalance", "rBase", "nrdomain", "mbas", " rdomain", " rBase", "mrbit", " rspace", "robas", "rpad", "mbalance", "mrbase", "mpad"], "addrhi": ["memhei", " addrHi", "addresslo", "memhi", "addlo", "ptrlo", "ptrhi", "addrHI", "addressHI", "memlo", "memHI", " addrhigh", " addrhei", "addHi", "addresshi", "addrhei", "addhi", "ptrhigh", "maphei", "addresshei", "addrhigh", "maphigh", "addrphi", "addressHi", "addphi", "addrHi", "maphi", "addressphi", "maplo", " addrHI", " addrphi", "ptrhei"], "oi": ["ni", "oid", "coe", "ki", "ori", " tid", " mi", "oji", "iri", "obo", "ogi", " ki", "xi", "eric", "asi", "pi", "oa", "ami", "itime", "ei", "eni", "i", "avi", "afi", "eta", "oni", "ui", "odi", " vi", "phi", "udi", "iso", "ois", " ii", "igi", "ilo", "bi", "bis", "oin", "ti", "oci", "ovi", "emi", "rio", "osi", " ni", "o", "mi", " orient", "ini", " iso", "si", "obi"], "opc": [" popc", "ospcp", "opco", " ipco", "OPf", "OPcp", "opscs", "ipf", "copfc", "opf", "opcp", "ipcs", "opca", " ipcs", "opsf", " opci", "opsc", "operca", " ipf", "Opcs", " popcs", "OPfc", "OPca", "opcs", "osppc", "copca", "Oppc", "ospcs", " opcs", " popf", " ipc", "OPpc", "operfc", "ospc", "ipco", "opci", "OPci", "Opc", "OPcs", "OPc", " popco", "copc", "copci", "ipc", "operc", "opfc", "opsci", " opf", "Opcp", "operci", "oppc"], "s_bits": ["s_flags", "s_its", "s_bytes", " s_values", " s_maps", " s_flags", "s_values", "s___bits", " s_tops", " s_bit", " s_its", "s___tops", "s_bs", "s_tops", "s_bit", "s_maps", "s___bytes", " s_bs", " s_bytes"], "mem_index": ["mem_position", "mem67info", " mem_Index", "mem2value", "mem2info", "memipvalue", "mem2Index", "memipIndex", "mem_label", "Mem_Index", "Mem_index", "mem_Index", "mem67Index", "mem2index", "mem67index", " mem_value", " mem_position", "Mem_info", "mem_info", " mem_label", "memipindex", "mem_value"], "label_ptr": ["label__ptr", "lab_ptr", "label_pos", "label__pt", "label_pt", "label__pointer", "label_pointer", "lab_pointer", "label_pr", "lab_str", " label_pos", " label_pointer", "label_str", " label_pr", "lab_pt", "label__str"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,\n\n                                   GetBitContext *gb)\n\n{\n\n    int i;\n\n    MMCO *mmco = sl->mmco;\n\n    int nb_mmco = 0;\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields\n\n        skip_bits1(gb); // broken_link\n\n        if (get_bits1(gb)) {\n\n            mmco[0].opcode   = MMCO_LONG;\n\n            mmco[0].long_arg = 0;\n\n            nb_mmco          = 1;\n\n        }\n\n        sl->explicit_ref_marking = 1;\n\n    } else {\n\n        sl->explicit_ref_marking = get_bits1(gb);\n\n        if (sl->explicit_ref_marking) {\n\n            for (i = 0; i < MAX_MMCO_COUNT; i++) {\n\n                MMCOOpcode opcode = get_ue_golomb_31(gb);\n\n\n\n                mmco[i].opcode = opcode;\n\n                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {\n\n                    mmco[i].short_pic_num =\n\n                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &\n\n                            (sl->max_pic_num - 1);\n\n#if 0\n\n                    if (mmco[i].short_pic_num >= h->short_ref_count ||\n\n                        !h->short_ref[mmco[i].short_pic_num]) {\n\n                        av_log(s->avctx, AV_LOG_ERROR,\n\n                               \"illegal short ref in memory management control \"\n\n                               \"operation %d\\n\", mmco);\n\n                        return -1;\n\n                    }\n\n#endif\n\n                }\n\n                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||\n\n                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {\n\n                    unsigned int long_arg = get_ue_golomb_31(gb);\n\n                    if (long_arg >= 32 ||\n\n                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&\n\n                                             long_arg == 16) &&\n\n                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"illegal long ref in memory management control \"\n\n                               \"operation %d\\n\", opcode);\n\n                        return -1;\n\n                    }\n\n                    mmco[i].long_arg = long_arg;\n\n                }\n\n\n\n                if (opcode > (unsigned) MMCO_LONG) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"illegal memory management control operation %d\\n\",\n\n                           opcode);\n\n                    return -1;\n\n                }\n\n                if (opcode == MMCO_END)\n\n                    break;\n\n            }\n\n            nb_mmco = i;\n\n        }\n\n    }\n\n\n\n    sl->nb_mmco = nb_mmco;\n\n\n\n    return 0;\n\n}\n", "idx": 1540, "substitutes": {"h": ["j", " inh", "zh", "l", "he", "ph", "host", "ssh", "sh", "bh", "p", "kh", "g", "eh", "hw", "oh", "ah", "H", "s", "hh", "her", "hp", "m", "dh", "ih", "http", "ch", "k", "hd", "hl", "rh", "hi", "hal", "hm", "hs", "hz", "v", "ha", "o", "HH", "this", "ht"], "sl": ["ls", "zh", "l", "sh", "bh", "isl", "nl", "Sl", "sv", "slice", "slot", "gl", "kl", "s", "li", "sql", "spl", "sk", "SL", "SSL", "sch", "jl", "syn", "fl", "sw", "sr", "hl", "sing", "dl", "tl", "sd", "pl", "ln", "rl", "sm", "sle", "spot", "bl", "sel", "ml", "cl", "sb", "sn", "sol", "so", "lc", "serv", "se", "ssl", "sp"], "gb": ["Gb", "sys", "mb", "rg", "eb", "vg", "sg", "bc", "tg", "bm", "kb", "py", "g", "gif", "cz", "pb", "cfg", "ng", "cb", "rb", "csv", "yg", "html", "pg", "b", "gd", "eg", "gt", "storage", "bb", "bt", "bs", "gu", "hub", " GB", "vm", "goo", "bg", "gc", "wb", "db", "fb", "jpg", "gz", "GB", "gs", "sb", "args", "gm", "gow", "gg", "bf", "gam", "vd", "asm", "uf", "gh"], "i": ["id", "ori", "n", "init", "li", "x", "series", " ti", "iu", "ti", "ind", "uri", "ix", "zi", "ini", "I", "f", " bi", "batch", "key", "list", " j", "xi", "ic", "qi", "m", "ui", "it", "ims", "im", " li", "\u0438", "ri", "chain", "j", " m", "ii", "iri", " mi", "ji", "pi", "asi", "me", "index", "ci", "ei", "info", "phi", "ij", "fi", " ii", "y", " pi", "bi", "hi", " I", "mi", "di", "ai", "si", "prefix", "multi", "ki", "status", "is", "sim", "sql", "cli", "gi", " si", "ip", " iter", "in", " multi"], "mmco": ["mmmo", "MMpo", "mbpo", "memcon", "mmCO", " mmcon", "tmfo", "mbcos", "mbmo", " mmCO", "mmci", "memfo", "memcoe", "memCO", "emco", "mopci", "temco", "mmmco", "mopgo", "MMcon", "mmaco", "tmcos", "mmgo", "memco", "temCO", "emso", "mmfo", "mopco", " mmcos", "MMfo", "mmmCO", "mmmfo", "moppo", "memaco", "mopfo", "mmso", "mmmso", " mmgo", " mmpo", "mmcon", "mbfo", "memgo", "temcos", "tmco", "mopCO", "mmCo", "mmmgo", "mindCO", "mindcos", "mlCo", "memso", "memmo", "mlCO", "mmmcos", "MMcos", "mmmmo", "mmpo", "mmmcoe", "memCo", " mmfo", "emcoe", "mmmpo", "mmcos", "MMco", "mlco", "tmpo", "mlcos", " mmCo", "mindco", "mempo", " mmso", "mopcos", "mbaco", "mbco", "temci", "MMso", "mmcoe", "mmmCo", "mbCO", "emCo", "MMgo", "mmmaco", "memcos", "mindci"]}}
{"project": "qemu", "commit_id": "e40a67beeda6aa6e735546e9f08f3db41e23592a", "target": 0, "func": " void cpu_sh4_invalidate_tlb(CPUSH4State *s)\n\n{\n\n    int i;\n\n\n\n    /* UTLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n    /* ITLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n\n\n    tlb_flush(s, 1);\n\n}\n", "idx": 1557, "substitutes": {"s": ["sys", "S", "south", "q", "stats", "status", "c", "sand", "is", "sv", "ss", "p", "g", "n", "r", "details", "ses", "set", "ds", "m", "b", "space", "params", "fs", "store", "sc", "aws", "esi", "series", "ps", "js", "ns", "state", "conf", "w", "e", "ts", "str", "sts", "rs", "v", "h", "gs", "sb", "st", "os", "sq", "sol", "t", "a", "se"], "i": ["p", "init", " ki", "ski", "li", "x", " ti", "iu", "ti", "span", "ind", "uri", "ix", "zi", "ini", "I", "my", "this", " bi", "batch", "ma", "xi", "ic", "any", "qi", " ex", "m", "ui", "it", "ex", "gu", " index", "ims", "im", " li", "io", "remote", " is", "PI", "\u0438", "ri", "json", "chain", " wi", " m", "ii", "iq", " mi", "ji", "slice", "pi", "index", "me", "ci", "ei", "info", "phi", "ij", "history", "fi", " ii", " it", " pi", "y", "bi", "err", "hi", "ms", " I", "mac", "v", " ni", "loop", "mi", "di", "ai", "si", "point", "multi", "ki", "is", "sim", " di", "ami", "cli", "gi", " si", "ip", "oi", "ie", "e", " my", " iter", "print", "in", " multi"], "entry": ["ace", "inner", "try", "key", "er", "match", "instance", "component", "record", "ent", "row", "element", "window", "import", "result", "tree", "ue", "engine", "table", "link", "see", "export", "check", "ary", "connection", "cell", "Entry", "ie", "command", "search", "attribute", "response", "e", "ment", "member", "or", "escape", "print", "ry", "nt", "field", "RY", "oe", "ient", "pair", "enter", "line", "point", "obj", "join", "inter"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_finish(uint32_t sum)\n\n{\n\n    while (sum>>16)\n\n\tsum = (sum & 0xFFFF)+(sum >> 16);\n\n    return ~sum;\n\n}\n", "idx": 1573, "substitutes": {"sum": ["doc", "total", "input", "ul", "mean", "Sum", "add", "temp", "tmp", "size", "mon", "aw", "c", "shift", "count", "status", "ss", "up", "sim", "text", "cal", "upt", "n", "upper", "result", "fac", "util", "ass", "out", "sa", "set", "carry", "unknown", "num", "msg", "us", "sc", "su", "umm", "zero", "hist", "new", "snap", "cmp", "cache", "mu", "state", "comment", "cum", "um", "sam", "ms", "now", "go", "med", "mm", "tu", "null", "val", "in", "vol", "hash", "good", "must", "uv", "si", "raw", "t", "mem", "subject", "share"]}}
{"project": "qemu", "commit_id": "45eb768c706d3a5fbe55224c589e8b4e252781d9", "target": 0, "func": "static void pci_init_mask_bridge(PCIDevice *d)\n\n{\n\n    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n\n       PCI_SEC_LETENCY_TIMER */\n\n    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n\n\n\n    /* base and limit */\n\n    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n\n    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n\n    pci_set_word(d->wmask + PCI_MEMORY_BASE,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n\n\n    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */\n\n    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);\n\n\n\n    /* Supported memory and i/o types */\n\n    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;\n\n    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n\n\n/* TODO: add this define to pci_regs.h in linux and then in qemu. */\n\n#define  PCI_BRIDGE_CTL_VGA_16BIT\t0x10\t/* VGA 16-bit decode */\n\n#define  PCI_BRIDGE_CTL_DISCARD\t\t0x100\t/* Primary discard timer */\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t/* Secondary discard timer */\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t/* Discard timer status */\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t/* Discard timer SERR# enable */\n\n/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n */\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    /* Below does not do anything as we never set this bit, put here for\n\n     * completeness. */\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n", "idx": 1616, "substitutes": {"d": ["id", "rd", "q", "add", "er", "dt", "c", "rest", "nd", "bd", "z", "p", "dd", "all", "n", "dx", "dc", "result", "r", "details", "debug", "out", "ds", "send", "td", "m", "dat", "b", "md", "new", "dh", "mod", "at", "dL", "dq", "ed", "dm", "end", "dy", "dom", "sd", "did", "dl", "df", "dos", "ind", "de", "db", "fd", "dr", "od", "o", "di", "dp", "du", "draw", "ad", "done", "D", "pd", "da", "ld", "dn"]}}
{"project": "qemu", "commit_id": "2b48e10f888059a98043b4816769fa2a326a1d2c", "target": 0, "func": "static TranslationBlock *tb_alloc(target_ulong pc)\n\n{\n\n    TranslationBlock *tb;\n\n    TBContext *ctx;\n\n\n\n    assert_tb_locked();\n\n\n\n    tb = tcg_tb_alloc(&tcg_ctx);\n\n    if (unlikely(tb == NULL)) {\n\n        return NULL;\n\n    }\n\n    ctx = &tcg_ctx.tb_ctx;\n\n    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {\n\n        ctx->tbs_size *= 2;\n\n        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);\n\n    }\n\n    ctx->tbs[ctx->nb_tbs++] = tb;\n\n    tb->pc = pc;\n\n    tb->cflags = 0;\n\n    tb->invalid = false;\n\n    return tb;\n\n}\n", "idx": 1621, "substitutes": {"pc": ["proc", "ec", "vc", "cp", "isc", "PC", "fc", "lp", "c", "bc", "unc", "p", " xp", "dc", " dc", "pn", "ic", "pb", "pi", " rc", " lac", "mc", "pp", "pointer", " proc", " ac", "tx", "sc", "vp", "pr", "tp", " cs", "pa", "ptr", "arc", "cs", "px", " p", "gc", "pt", "cu", "cc", "pan", " cc", "pic", "rc", "lc", "pid", "ac", "tc"], "tb": ["teba", "tdbb", " tbt", "tbl", "traceb", "tracebh", "twb", "ttb", "tbb", "ntbb", "tba", "tmb", "Tb", "Tba", "tenbr", "entbi", "atb", "atbe", "tracebd", " twb", "ptb", "tdbm", "temb", "tebm", "tenbe", "trb", "tpb", " tbh", "tbt", "tbd", "wtb", "tbi", "tenbh", "ttwb", "tipb", "tdbl", " trb", "tbm", "ntbl", "tenbd", " tpb", "otsb", "otbl", " tbe", "ertb", "tdb", "ntb", "tracebb", "wtba", "wtbi", "tsba", " tbl", "ptba", "ptbl", "Tbl", "tsb", "atbr", "tipba", "atbt", "entb", "ptbr", " tbd", "tdba", "tsbm", "otb", "tbe", "tbr", "entrb", " tbi", "Tbr", "tenbt", "tipbt", "tenbb", "ertbr", "tdmb", "entbt", "teb", "tenb", "tdsb", "wtrb", "ttbr", "ertwb", "ertpb", "tsmb", " tbb", "otbb", " tbr", "ntsb", " tba", "ttpb", "entbl", "entba", "tbh", "tipbl"], "ctx": ["cp", "ctr", "c", "unc", "p", "kb", "hw", "kl", "pg", "x", "sc", "qt", "req", "ctl", "conf", "cf", "context", "xp", "pkg", "ind", "bo", "wx", "Context", "resp", "timeout", "jac", "ctrl", "bc", "np", "pb", "qa", "cb", "act", "kt", "cmp", "voc", "xy", "ptr", "mk", "gc", "co", "loc", "nt", "expr", "cm", "mc", "inst", "aux", "jp", "addr", "nc", "utils", "etc", "ns", "kw", "dl", "that", "anc", "abc", " cx", "worker", "exec", "cmd", "sys", "wcs", "work", "fc", "bj", "xc", "nd", "conn", "org", "ca", "cfg", "tx", "tz", "scope", "cv", "cu", "cc", "ct", "lc", "tc"]}}
{"project": "qemu", "commit_id": "9cbaacf999b01b27dc3a22502705178057af66de", "target": 0, "func": "static void gpollfds_from_select(void)\n\n{\n\n    int fd;\n\n    for (fd = 0; fd <= nfds; fd++) {\n\n        int events = 0;\n\n        if (FD_ISSET(fd, &rfds)) {\n\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &wfds)) {\n\n            events |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &xfds)) {\n\n            events |= G_IO_PRI;\n\n        }\n\n        if (events) {\n\n            GPollFD pfd = {\n\n                .fd = fd,\n\n                .events = events,\n\n            };\n\n            g_array_append_val(gpollfds, pfd);\n\n        }\n\n    }\n\n}\n", "idx": 1626, "substitutes": {"fd": ["ff", "delay", "port", "unc", "fa", "td", "lf", "form", "ctl", "cf", "disk", "wd", "df", "ind", "ud", "ini", "f", "pd", "fn", "vd", "ld", "fp", "d", "cod", "fx", " f", "bd", "dir", "ds", "wind", "fed", " FD", "fl", "ptr", "den", "du", "FD", "elt", "rd", "cd", "dt", "dd", " fid", " dur", "dc", "dat", "gd", "ord", "dev", "fi", "did", "ffff", "hd", "dl", "compl", "fe", "fr", "db", " ed", "draw", "bf", "pid", "da", "proc", "fc", "nd", "fin", "fs", "md", "def", "desc", "sd", " d", "poll", " td", " ff"]}}
{"project": "FFmpeg", "commit_id": "89f464e9c229006e16f6bb5403c5529fdd0a9edd", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    TiffContext *const s = avctx->priv_data;\n\n    AVFrame *const p = data;\n\n    ThreadFrame frame = { .f = data };\n\n    unsigned off;\n\n    int le, ret, plane, planes;\n\n    int i, j, entries, stride;\n\n    unsigned soff, ssize;\n\n    uint8_t *dst;\n\n    GetByteContext stripsizes;\n\n    GetByteContext stripdata;\n\n\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n\n\n\n    // parse image header\n\n    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid TIFF header\\n\");\n\n        return ret;\n\n    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {\n\n        av_log(avctx, AV_LOG_ERROR, \"IFD offset is greater than image size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    s->le          = le;\n\n    // TIFF_BPP is not a required tag and defaults to 1\n\n    s->bppcount    = s->bpp = 1;\n\n    s->photometric = TIFF_PHOTOMETRIC_NONE;\n\n    s->compr       = TIFF_RAW;\n\n    s->fill_order  = 0;\n\n    free_geotags(s);\n\n\n\n    // Reset these offsets so we can tell if they were set this frame\n\n    s->stripsizesoff = s->strippos = 0;\n\n    /* parse image file directory */\n\n    bytestream2_seek(&s->gb, off, SEEK_SET);\n\n    entries = ff_tget_short(&s->gb, le);\n\n    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)\n\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < entries; i++) {\n\n        if ((ret = tiff_decode_tag(s, p)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    for (i = 0; i<s->geotag_count; i++) {\n\n        const char *keyname = get_geokey_name(s->geotags[i].key);\n\n        if (!keyname) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Unknown or unsupported GeoTIFF key %d\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Type of GeoTIFF key %d is wrong\\n\", s->geotags[i].key);\n\n            continue;\n\n        }\n\n        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);\n\n        if (ret<0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Writing metadata with key '%s' failed\\n\", keyname);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (!s->strippos && !s->stripoff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Image data is missing\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    /* now we have the data and may start decoding */\n\n    if ((ret = init_image(s, &frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->strips == 1 && !s->stripsize) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Image data size missing\\n\");\n\n        s->stripsize = avpkt->size - s->stripoff;\n\n    }\n\n\n\n    if (s->stripsizesoff) {\n\n        if (s->stripsizesoff >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,\n\n                         avpkt->size - s->stripsizesoff);\n\n    }\n\n    if (s->strippos) {\n\n        if (s->strippos >= (unsigned)avpkt->size)\n\n            return AVERROR_INVALIDDATA;\n\n        bytestream2_init(&stripdata, avpkt->data + s->strippos,\n\n                         avpkt->size - s->strippos);\n\n    }\n\n\n\n    if (s->rps <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"rps %d invalid\\n\", s->rps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    planes = s->planar ? s->bppcount : 1;\n\n    for (plane = 0; plane < planes; plane++) {\n\n        stride = p->linesize[plane];\n\n        dst = p->data[plane];\n\n        for (i = 0; i < s->height; i += s->rps) {\n\n            if (s->stripsizesoff)\n\n                ssize = ff_tget(&stripsizes, s->sstype, le);\n\n            else\n\n                ssize = s->stripsize;\n\n\n\n            if (s->strippos)\n\n                soff = ff_tget(&stripdata, s->sot, le);\n\n            else\n\n                soff = s->stripoff;\n\n\n\n            if (soff > avpkt->size || ssize > avpkt->size - soff) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid strip size/offset\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,\n\n                                         FFMIN(s->rps, s->height - i))) < 0) {\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return ret;\n\n                break;\n\n            }\n\n            dst += s->rps * stride;\n\n        }\n\n        if (s->predictor == 2) {\n\n            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"predictor == 2 with YUV is unsupported\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            dst   = p->data[plane];\n\n            soff  = s->bpp >> 3;\n\n            if (s->planar)\n\n                soff  = FFMAX(soff / s->bppcount, 1);\n\n            ssize = s->width * soff;\n\n            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||\n\n                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j++)\n\n                        dst[j] += dst[j - soff];\n\n                    dst += stride;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n\n            dst = p->data[plane];\n\n            for (i = 0; i < s->height; i++) {\n\n                for (j = 0; j < stride; j++)\n\n                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];\n\n                dst += stride;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->planar && s->bppcount > 2) {\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[2]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[2]);\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[1]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[1]);\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 1628, "substitutes": {"avctx": ["avctl", "aircmd", "abconn", "aircu", "avconn", "avectx", "afcmd", "avectl", "ravctl", "airobj", "avtx", "airctx", "avcu", "verctl", "Avcontext", "avobj", "avecu", "afctx", "ravhistory", "afctl", "avehistory", "abcontext", "averctl", "abctx", " avctl", " avtx", " avcontext", "verctx", "avercmd", "averobj", "Avconn", "avcontext", "verconn", "afconn", "abtx", "Avctl", "afcontext", "avecmd", " avconn", "vercontext", "avhistory", "avercu", "afcu", "averhistory", "ravctx", "aveobj", "avcmd", "averctx", "Avctx", "aftx"], "data": ["d", "Data", "image", "message", "id", "size", "value", "buf", "DATA", "format", "next", "text", "record", "only", "window", "read", "result", "ref", "r", "pointer", "out", "action", "table", "dat", "header", "form", "extra", "pad", "content", "length", "file", "block", "rew", "buffer", "response", "stream", "name", "str", "first", "bin", "offset", "body", "empty", "ata", "frame", "bytes", "in", "o", "padding", "feed", "f", "raw", "t", "a", "map"], "got_frame": ["ret_data", "got_next", "gotacnext", "gotacframe", "gotactype", "got__next", "got__frame", "ret_frame", "got_type", "ret_next", "ret_type", "got__data", "got__type", "gotacdata", "got_data"], "avpkt": [" avpct", " avpuf", "avjpuf", "avcpct", "avPuf", "avbacket", " avPdu", "avPmt", " avPkt", "avPdu", " avppt", "avPwt", " avPpt", "avpatpt", "avbet", "avcpacket", "avpatacket", "avopet", " avpet", "avjpdu", "avpatct", "avpuf", " avPet", " avpmt", "avjpmt", "avpatuf", " avpquet", "avopmt", "avjpacket", "avPquet", "avPet", "avjpkt", " avPacket", " avPquet", "avPacket", "avpdu", " avPuf", "avcpet", "avcpkt", " avpacket", "avpmt", "avjpet", "avpwt", "avopacket", " avpwt", "avPct", "avPpt", "avbkt", " avPmt", "avcppt", " avpdu", " avPwt", "avpacket", "avcpwt", "avpct", " avPct", "avcpquet", "avPkt", "avppt", "avpquet", "avpatkt", "avpatdu", "avpet", "avbwt", "avpatquet", "avopkt"], "s": ["ls", "c", "es", "n", "ses", "set", "params", "ars", "services", "its", "conf", "ports", "cs", "ains", "ies", "ags", "h", "gs", "sb", "args", "os", "a", "d", "q", "mods", "stats", "sv", "settings", "session", "vs", "details", "ess", "ers", "ds", "qs", "m", "less", "bs", "ims", "sam", "hs", "sts", "ins", "sq", "ys", "S", "sets", "ss", "als", "comm", "space", "ns", "sw", "ms", "ts", "changes", "v", "tests", "results", "uploads", "rates", "se", "ops", "sp", "sys", "status", "is", "g", "ids", "b", "fs", "aws", "ps", "parts", "js", "as", "has", "rs", "bits", "ats", "t", "obj"], "p": ["fp", "cp", "q", "d", "lp", "l", "jp", "pc", "c", "g", "n", "P", "pb", "r", "bp", "np", "pp", "m", "b", "pe", "vp", "ps", "tp", "pa", "w", "ap", "v", "h", "o", "f", "t", "sp"], "off": ["ele", "xff", "ff", "alf", "size", "op", "offer", "no", "shift", "addr", "er", "ext", "aj", "fun", "half", "from", "eff", "open", "out", "set", "oa", "res", "lf", "load", "pos", "start", "new", "ok", "zero", "def", "ord", "pad", "att", "ex", "dev", "OFF", "end", "err", "w", "el", "now", "offs", "offset", "un", "ew", "on", "empty", "low", "o", " OFF", "te", "det", "reset", "line", "raw", "Off", "t", "of", "a", "len", "cmd"], "le": ["ele", "able", "l", "er", "ole", "ile", "nl", "ke", "let", "lex", "n", "la", "fle", "lt", "li", "lo", "ue", "ble", "leg", "out", "be", "led", "ce", "start", "pe", "ll", "lege", "ne", "ge", "t", "ed", "end", " l", "Le", "e", "ptr", "el", "les", "ale", "lem", "tle", "de", "del", "ell", "offset", "sle", "bytes", "oe", "ly", "te", "ve", "ler", "line", "elt", "little", "se", "len", "LE"], "ret": ["success", "RET", "try", "net", "prop", "status", "alf", "value", "ext", "port", "result", "ref", "deg", "out", "res", "fin", "ft", "red", "cont", "over", "gt", "ll", "def", "plain", "it", "mem", "att", "prot", "Ret", "ber", "ure", " Ret", "fi", "fr", "pas", "alt", "rt", "rev", "ter", "del", "print", "dr", "val", "last", "rets", "reg", "nt", "det", "rem", "reset", "flag", "tr", "resp", "elt", "rel", "re", "back"], "plane": ["ane", "shift", "mask", "source", "pipe", "slice", "fine", "drop", "mode", "spin", "clip", "flat", "pe", "shape", "ge", "fl", "axis", "perm", "pa", "origin", "depth", "frame", "png", "ve", "dim", "flag", "pose"], "planes": ["packages", "rows", "frames", "images", "lists", "faces", "files", "boxes", "codes", "names", "photos", "bands", "ips", "maps", "groups", "pages", "services", "flat", "heads", "pieces", "anes", "ports", "pins", "lines", "versions", "bits", "ops"], "i": ["id", "c", "init", "li", "x", "us", "k", "iu", "ti", "ind", "ix", "zi", "h", "ini", "I", "q", "xi", "ic", "qi", "m", "ui", "it", "im", "\u0438", "chain", "ii", "iq", "ji", "pi", "index", "me", "ci", "ei", "info", "new", "ij", "y", "bi", "hi", "v", "mi", "di", "ai", "si", "of", "jj", "_", "multi", "ni", "ki", "is", "sim", "g", "r", "ami", "b", "cli", "cont", "gi", "def", "ip", "oi", "w", "e", "in", "o", "raw", "t"], "j": ["jump", "ni", "q", "l", "jp", "ji", "jit", "dj", "z", "g", "n", "kj", "r", "m", "b", "pos", "J", "jl", "ij", "job", "js", "k", "bi", "jc", "ind", "jac", "jj", "json"], "entries": ["estrys", "entsrys", "ientries", " entrys", "Entriers", "Entrys", "entrys", "entsies", "Entents", "ntrys", "entsents", "entrs", " entrance", "Entries", "Entrance", "Entried", " entried", " entriers", "entrance", "ENTies", "estries", "entry", "enties", "ntrance", "ENTrys", "ENTries", "Entry", "entried", "Entrs", " entrs", "entriers", "Enties", "entsries", "estents", "ientriers", "ENTry", "ntries", "entsry", "entents", "entsriers", "estriers", "ntrs", "ientried", "ientrys"], "stride": ["trride", "trice", "strider", "divide", "stider", "strice", "trider", "tride", "stide", "divider", "divice", "stice", "divride", "strride"], "soff": ["SOffer", " soffer", "SOeff", "SOff", " sof", "soeff", "soffer", "sef", "seff", "SOf", "sof", " soeff", "seffer", "seeff"], "ssize": ["typeside", "rsside", "typesize", "psize", "rssiz", "ssized", "rssize", "typesized", "psiz", "ssiz", "typesiz", "sside", "rssized", "pside", "psized"], "dst": ["dbct", "dbst", "hbl", "hsw", "dbl", "hct", " dbl", "dct", " dct", "dsw", "hst", "dbsw", " dsw", "dbbl"], "stripsizes": ["strippides", "stripsides", "stripesides", "rippizes", "strippizes", "ripsizes", "striposize", "striposizers", "stripesizers", "stripesize", "rippize", "stripesizes", "ripsizers", "stripsizers", "rippizers", "striposizes", "ripsides", "striposides", "strippizers", "rippides", "strippize", "ripsize", "stripsize"], "stripdata": ["cliptable", "clipfields", "solidfields", "solidtable", "stripfields", "solidsize", "sticksize", "sticktable", "stickfields", "stickdata", "soliddata", "stripsize", "striptable", "clipsize", "clipdata"], "keyname": ["keylamed", "okeynename", "keyynname", "keynname", "kevernamer", "keyerename", "kevernamed", "okeydename", "keyeramed", "keyylamer", "keynamed", "keydAME", "keydename", "okeyname", "keyynamed", "keyylname", "keyyname", "okeydAME", "keylame", "keydamed", "okeynAME", "keyame", "keynamer", "keylname", "keyename", "keylamer", "keyamed", "kevername", "keyamer", "okeydamed", "keynename", "okeynamed", "keyerAME", "keyylamed", "keyerame", "keyylame", "keydame", "keyAME", "kevernname", "keyynamer", "okeydame", "keynAME"]}}
{"project": "FFmpeg", "commit_id": "bd255f9feb4deea4c990e582f0ba3b90d7b64b4c", "target": 0, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n\n                                              int *got_picture_ptr,\n\n                                              AVPacket *avpkt)\n\n{\n\n    int ret;\n\n\n\n    *got_picture_ptr = 0;\n\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n\n        return -1;\n\n\n\n    avctx->pkt = avpkt;\n\n    apply_param_change(avctx, avpkt);\n\n\n\n    avcodec_get_frame_defaults(picture);\n\n\n\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n\n                                         avpkt);\n\n        else {\n\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n\n                                       avpkt);\n\n            picture->pkt_dts             = avpkt->dts;\n\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n\n            picture->width               = avctx->width;\n\n            picture->height              = avctx->height;\n\n            picture->format              = avctx->pix_fmt;\n\n        }\n\n\n\n        emms_c(); //needed to avoid an emms_c() call before every return;\n\n\n\n        if (*got_picture_ptr)\n\n            avctx->frame_number++;\n\n    } else\n\n        ret = 0;\n\n\n\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n\n     * make sure it's set correctly */\n\n    picture->extended_data = picture->data;\n\n\n\n    return ret;\n\n}\n", "idx": 1657, "substitutes": {"avctx": [" avreq", "avefunc", "avectx", " avcpu", "varcontext", "navtxt", "aveconf", "avercontext", "avjac", "navsys", "avejp", "ajsys", "avertx", "navctx", "avetxt", "svcfg", "vrjac", "devsys", "navtx", "navcb", "wavcc", "wavjac", "avpkg", "savjp", "savcfg", "avecontext", " avcb", "avtxt", "vercontext", "varctx", "verjac", "avercu", "navcfg", "avercfg", "vertx", " avloc", "avsys", "wavtx", "avercpu", "devcontext", "avtx", "avcu", "ajcu", " avjp", "ajtx", " avcfg", "avwx", "ajctx", "vartx", "avercb", "abctx", "navwx", " avcontext", "actcrit", "avloc", "varpool", "navtmp", "avercc", "afcontext", "avetmp", "ajjac", "svjac", " avcc", "avertxt", "aftx", "wavfunc", "avconf", "avewx", "wavcmd", "avertc", "aversys", "ajtmp", " avcrit", "navcc", "avcrit", "aveloc", "avepkg", "avtc", "navcontext", "abcc", "avetx", "vrcfg", "avercrit", "navfunc", "wavctx", "wavtmp", "verctx", "avercmd", "averjac", " avkw", "acttx", "vrtx", "savcrit", "avekw", "averkw", "avcc", "abtx", "avcb", " avcmd", "avcfg", "varjac", "actctx", "avertmp", " avconf", "avcmd", "navcu", "avtmp", "savctx", "vartxt", "avepool", "actpkg", "devctx", "vrctx", "avecc", "avjp", "devtc", "afctx", "avfunc", "ajcontext", "avejac", "savcontext", "abcontext", "avecfg", "wavcfg", "averpool", "avkw", " avpkg", " avtx", "avereq", "wavcontext", "avcpu", "navjac", "abcpu", "ajcfg", " avjac", "actcontext", "averwx", "avcontext", "afloc", "avecrit", "avreq", "avecmd", "ajtc", "averreq", "avpool", "svctx", "actconf", "averctx", "svtx"], "picture": ["image", " profile", "piece", "summary", "format", "through", "style", "stat", "record", "person", "pdf", "professional", "secure", "description", "figure", "pi", "photo", "details", " Picture", "query", "import", "power", "pty", "relative", "important", "share", "pause", "audio", "pict", "password", "iture", "family", "policy", "profile", "pen", "info", "performance", "vp", "def", "shape", "foreign", "history", "Picture", "note", "file", "comment", "private", "video", "support", "print", "friendly", "frame", "proof", "media", "camera", "contact", "png", "position", "pic", "feat", "remember", "join", "feature"], "got_picture_ptr": ["got_pic_ptr", "got_profile_pos", "got_profile_ptr", "got_profile_ctr", "got_picture_Ptr", "got_pic_src", "got_profile_pad", "got_profile_pointer", "got_picture_bc", "got_picture_src", "got_picture_pad", "got_pic_pointer", "got_picture_addr", "got_profile_offset", "got_picture_pointer", "got_profile_addr", "got_profile_bc", "got_profile_Ptr", "got_picture_pos", "got_pic_Ptr", "got_picture_offset", "got_picture_ctr"], "avpkt": ["avpck", "avPnt", "avppelt", "avwpett", "avnpacket", "avwpck", "avppacket", "ahput", "avetput", "wavppket", "avpackmit", "afpkt", "ahjput", "avckt", "avpodkt", "avppct", "avwpctx", "avtpacket", "avepett", "avpkg", "afppct", "airnpacket", "avecpkat", "avcpck", "afpkg", "avepkl", "avppnt", "avpacket", "ajpett", "avdacket", "afppkt", "avwput", "airpck", "avppkg", "avecpkt", "avPett", "ahpck", "avpackst", "ahjpkt", "ahjpck", "avPst", "ajpackst", "avpkl", "avjpctx", "avcut", "wavppacket", "avecpkl", "ajpackett", "ajpst", "avpartconn", "avcett", "avepkat", "avtpct", "afppnt", "ajpackkt", "airpacket", "avdkt", "avcacket", "avpelt", "avppst", "avpackkt", "avpackett", "avPkg", "airnpkt", "avtpett", "ajpmit", "aveput", "avcpkl", "avpctx", "avppket", "avpkat", "avpconn", "avepacket", "avpett", "ahjpctx", "avpodkat", "wavpkt", "avpnt", "avwpacket", "wavpelt", "ajpackmit", "avnpck", "airnpck", "avpayket", "avppmit", "avcpctx", "avjpck", "avdett", "afppkg", "avpodconn", "ahpctx", "avdck", "avjput", "avetpkt", "avcpconn", "avwpket", "avwpkt", "avnpett", "avppkt", "airpett", "avtpkg", "avPct", "avecpconn", "avpmit", "avetpacket", "avpst", "airpkt", "avpct", "avcpkat", "ajpkt", "avtpnt", "afpct", "avPmit", "avpartkl", "avpodkl", "airnpett", "avpayacket", "avtput", "avetpett", "avpket", "wavpacket", "avput", "ahpkt", "avjpkt", "avpartkat", "avtpkt", "avepconn", "avwpelt", "avpayelt", "avcpkt", "afpnt", "avpaykt", "wavpket", "avcput", "avnpkt", "avppett", "wavppkt", "avepkt", "avppck", "avpartkt", "avPkt", "wavppelt"], "ret": ["success", "mt", "usr", "RET", "summary", "fun", "sort", "result", "ref", "r", "out", "res", "fin", "lit", "ft", "cont", "gt", "ll", "def", "mem", "att", "reply", "Ret", "ert", "uf", "final", "desc", "al", "ort", "len", "gc", "pas", "rev", "rt", "alt", "ter", "del", "print", "get", "val", "rm", "rets", "pret", "nt", "det", "rem", "cert", "reset", "resp", "tr", "flag", "t", "re", "back", "report"], "frame_number": ["frame__number", "frame2index", "frame2number", "frame2num", "picture_index", "frame2count", "picture_number", "frame_index", "frame__num", "frame_num", "frame__index", "frame_count", "frame__count", "picture_num", "picture_count"]}}
{"project": "qemu", "commit_id": "87e459a810d7b1ec1638085b5a80ea3d9b43119a", "target": 1, "func": "static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,\n\n                                      MegasasCmd *cmd)\n\n{\n\n    struct mfi_pd_info *info = cmd->iov_buf;\n\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n\n    uint64_t pd_size;\n\n    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);\n\n    uint8_t cmdbuf[6];\n\n    SCSIRequest *req;\n\n    size_t len, resid;\n\n\n\n    if (!cmd->iov_buf) {\n\n        cmd->iov_buf = g_malloc0(dcmd_size);\n\n        info = cmd->iov_buf;\n\n        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */\n\n        info->vpd_page83[0] = 0x7f;\n\n        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info std inquiry\");\n\n            g_free(cmd->iov_buf);\n\n            cmd->iov_buf = NULL;\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info std inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) {\n\n        megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83));\n\n        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n\n        if (!req) {\n\n            trace_megasas_dcmd_req_alloc_failed(cmd->index,\n\n                                                \"PD get info vpd inquiry\");\n\n            return MFI_STAT_FLASH_ALLOC_FAIL;\n\n        }\n\n        trace_megasas_dcmd_internal_submit(cmd->index,\n\n                                           \"PD get info vpd inquiry\", lun);\n\n        len = scsi_req_enqueue(req);\n\n        if (len > 0) {\n\n            cmd->iov_size = len;\n\n            scsi_req_continue(req);\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    }\n\n    /* Finished, set FW state */\n\n    if ((info->inquiry_data[0] >> 5) == 0) {\n\n        if (megasas_is_jbod(cmd->state)) {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n\n        } else {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n\n        }\n\n    } else {\n\n        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n\n    }\n\n\n\n    info->ref.v.device_id = cpu_to_le16(pd_id);\n\n    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n\n    blk_get_geometry(sdev->conf.blk, &pd_size);\n\n    info->raw_size = cpu_to_le64(pd_size);\n\n    info->non_coerced_size = cpu_to_le64(pd_size);\n\n    info->coerced_size = cpu_to_le64(pd_size);\n\n    info->encl_device_id = 0xFFFF;\n\n    info->slot_number = (sdev->id & 0xFF);\n\n    info->path_info.count = 1;\n\n    info->path_info.sas_addr[0] =\n\n        cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n    info->connected_port_bitmap = 0x1;\n\n    info->device_speed = 1;\n\n    info->link_speed = 1;\n\n    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);\n\n    g_free(cmd->iov_buf);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    cmd->iov_buf = NULL;\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 1672, "substitutes": {"sdev": ["pdevice", " sde", "sev", "sgu", "dsdevice", "jsdev", "jsde", " sdevice", "pserv", "sbus", " svision", "jsvision", "osserv", "sysdev", "pgu", "sysbus", "osvision", "sdevice", "dsev", "sve", " sve", " sev", "svdev", "dsdev", " sbus", "svserv", "jsdevice", "osde", "svdevice", "pdev", "osdev", "ssdev", "sysdevice", "dsve", "ssdevice", "sserv", "sde", "osgu", "osdevice", "svision", "ssbus", "svgu"], "lun": ["mLUN", "leoud", "lUN", "slUN", "Lunc", " lsun", "ploud", "ploun", "Luna", " lon", "Lug", "LUN", "llun", "eluna", "elun", "lnunc", "llon", " lUN", "Lon", "lnUN", "lmun", "plun", "leout", "mLun", " lout", "lon", " loun", "lnun", "slun", "loud", "leoun", "slunt", "leun", "elmun", " lunc", "mLuna", "loun", "lunc", "mLmun", "luna", "llUN", "lsun", "elUN", "Lsun", "lout", " loud", "lug", "slon", "llsun", "Lmun", "Lunt", "plout", " lug", "lunt", " lunt", "Lun", "lnug"], "cmd": ["mt", "cp", "ctr", "mom", "ext", "bind", "form", "fresh", "Cmd", "job", "dq", "opt", "dm", "ctl", "cf", "comp", "pkg", "ind", "ck", "resp", "kick", "ctrl", "batch", "crit", "cb", "phy", "force", "kt", "msg", "tab", "cmp", "mk", "quit", "range", "nt", "cm", "grow", "report", "json", "std", "cat", "cr", "cd", "buf", "addr", "host", "build", "comm", "send", "utils", "controller", "call", "update", "err", "ctx", "target", "client", "urg", "det", "exec", "conn", "txt", "cfg", "kind", "cli", "cont", "md", "def", "config", "desc", "command", "cc", "ct", "control", "raw", "obj", "news"], "info": ["id", "try", "op", "api", "p", "init", "order", "app", "iter", "ignore", "time", "state", "conf", "ti", "ind", "fee", "by", "help", "admin", "f", "mem", "key", "list", "count", "meta", "tif", "dict", "details", "ready", "num", "tab", "check", "it", "note", "recent", "name", "loc", "json", "j", "basic", "information", "addr", "Info", "inf", "ref", "index", "i", "cache", "type", "history", "fi", "update", "error", "comment", "det", "of", "auth", "data", "no", "stat", "conn", "query", "important", "debug", "kind", "bit", "unknown", "notice", "def", "config", "ip", "local", "metadata", "INFO", "now", "good", "about", "t", "fo", "buff"], "pd_size": ["pd_ize", "PD_Size", "PD_size", "PD_ize", "pd_len", "PD_len", "pd_Size"], "cmdbuf": [" cmdwindow", "cmdqueue", "ctbuffer", " cmdBuffer", " cmdbuffer", "cmddb", "commbuffer", "ctbuf", "ctbuff", "commandbuf", "reqqueue", "commdb", "cmdBuffer", "commbuf", "ctlbuffer", " cmdbuff", "ctBuffer", "mdbc", "mddb", "mdfb", "cmdbuff", "commwindow", "mdbuff", "mdwindow", " cmdbox", "commbc", "cmdbc", "cmdfb", "mdbox", "commandbuffer", "mdbuf", "commandBuffer", "cmdbuffer", "commanddb", "commbox", "cmdbox", "ctlbc", "reqbuf", "reqbuffer", "mdqueue", "ctlbuf", "commandbc", "commandbuff", "commandqueue", "cmdwindow", " cmdbc", "reqbuff", "mdbuffer", "commfb", " cmddb", "ctlfb"], "req": [" requisite", "j", "require", "q", "usr", "aux", "ctr", "required", "func", "iq", "jp", "qq", "ext", "quest", "progress", "crit", "dist", " requ", "res", " resp", "need", "tx", "needed", "red", "msg", "seq", "md", "qt", "request", "fresh", "def", "cmp", "dq", "requ", "js", "call", "conf", "desc", "compl", "err", "ptr", "cond", "rec", "comp", "ctx", "rr", "rx", "str", "pkg", "ind", "rt", "eq", "urg", "wx", "expr", "gz", "repl", "resp", "par", "rep", "rel", "sq"], "len": ["data", "ls", "l", "size", "nl", "all", "fun", "gl", "ref", "lim", "Len", "lib", "html", "lf", "var", "fin", "num", "pos", "seq", "ll", "qual", "cmp", "vec", "lon", "length", "fl", "err", "compl", "dl", "el", "en", "pl", "comp", "ln", "str", "coll", "rev", "del", "offset", "val", "bytes", "nt", "low", "gz", "ret", "f", "rc", "fn", "resp", "lang", "elt", "wid", "mem", "ld", "sp"], "resid": ["Resnum", "revnum", "resnum", "resids", "revid", "resident", "Resident", "revident", " resids", " resnum", "revids", "Resid", " resident", "Resids"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_isel(DisasContext *ctx)\n\n{\n\n    int l1, l2;\n\n    uint32_t bi = rC(ctx->opcode);\n\n    uint32_t mask;\n\n    TCGv_i32 t0;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    mask = 0x08 >> (bi & 0x03);\n\n    t0 = tcg_temp_new_i32();\n\n    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);\n\n    if (rA(ctx->opcode) == 0)\n\n        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);\n\n    else\n\n        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n", "idx": 1710, "substitutes": {"ctx": ["sys", "cp", "wcs", "work", "jp", "c", "pc", "xc", "bc", "nc", "bh", "addr", "conn", "kg", "kb", "lex", "dc", "hw", "kj", "np", "kl", "cfg", "mc", "crit", "cb", "act", "tx", "kt", "nw", "info", "qt", "etc", "cur", "check", "req", "cmp", "history", "config", "kw", "ctl", "conf", "desc", "context", "xp", "grad", "pkg", "anc", "std", "abc", " cx", "cc", "nt", "cu", "wx", "ct", "cl", "ck", "lc", "resp", "prefix", "exec", "tc", "cmd", "typ"], "l1": ["l0", " LOne", " L2", "sl01", " l81", "sl81", "mOne", "m1", "L1", "l3", "v2", "t1", "t3", "l01", " L3", " L1", " l01", "t2", "sl1", " l0", "L2", " lOne", "sl2", "m2", "m3", "l81", "L3", "v01", "v81", "v1", " l3", "lOne", "L0"], "l2": ["nl2", "l0", "li1", "el1", "list", " l02", "li3", "l6", "ltwo", "L02", "lst", "L1", "l3", "nl02", " l0", "nl0", "L2", "nltwo", "l02", "nl6", "el2", "li2", " l6", "eltwo", " ltwo", "nl1", "L3", "L6", "Lst", "el02", " l3", "L0", " lst"], "mask": ["mt", "ma", "key", "hide", "mut", "mb", "match", "count", "bm", "sign", "Mask", "bool", "fac", "label", "window", " Mask", "mode", "m", "bit", "sum", "filter", "pack", "form", "sk", "lock", "weight", "miss", "zero", "ask", "wm", "type", "cache", "mu", "perm", "conf", "ch", "level", "flags", "mk", "ms", " masks", "gc", "gate", "scale", " masked", "hash", "bits", "cm", "flag", "tr", "mc", "mas", "map"], "t0": ["p1", "f8", "te1", "o00", "l0", "f2", " t8", "tdau", " t2000", "timeau", " tk", "tk", "f1", "p3", "time0", " t3", "te2", "t00", "f0", " tau", "th00", "t2000", "time5", "td2000", "t1", "t3", "t5", "td0", "th0", "ok", " tzero", "t2", "p0", "td5", "t8", " t00", "thzero", " t1", "te0", "l00", "ozero", " t2", "te00", "p8", "tau", "p2", "o0", "time2000", "tzero", "f3", "thk", " t5"]}}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void stream_process_mem2s(struct Stream *s,\n\n                                 StreamSlave *tx_dev)\n\n{\n\n    uint32_t prev_d;\n\n    unsigned char txbuf[16 * 1024];\n\n    unsigned int txlen;\n\n    uint32_t app[6];\n\n\n\n    if (!stream_running(s) || stream_idle(s)) {\n\n        return;\n\n    }\n\n\n\n    while (1) {\n\n        stream_desc_load(s, s->regs[R_CURDESC]);\n\n\n\n        if (s->desc.status & SDESC_STATUS_COMPLETE) {\n\n            s->regs[R_DMASR] |= DMASR_HALTED;\n\n            break;\n\n        }\n\n\n\n        if (stream_desc_sof(&s->desc)) {\n\n            s->pos = 0;\n\n            memcpy(app, s->desc.app, sizeof app);\n\n        }\n\n\n\n        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;\n\n        if ((txlen + s->pos) > sizeof txbuf) {\n\n            hw_error(\"%s: too small internal txbuf! %d\\n\", __func__,\n\n                     txlen + s->pos);\n\n        }\n\n\n\n        cpu_physical_memory_read(s->desc.buffer_address,\n\n                                 txbuf + s->pos, txlen);\n\n        s->pos += txlen;\n\n\n\n        if (stream_desc_eof(&s->desc)) {\n\n            stream_push(tx_dev, txbuf, s->pos, app);\n\n            s->pos = 0;\n\n            stream_complete(s);\n\n        }\n\n\n\n        /* Update the descriptor.  */\n\n        s->desc.status = txlen | SDESC_STATUS_COMPLETE;\n\n        stream_desc_store(s, s->regs[R_CURDESC]);\n\n\n\n        /* Advance.  */\n\n        prev_d = s->regs[R_CURDESC];\n\n        s->regs[R_CURDESC] = s->desc.nxtdesc;\n\n        if (prev_d == s->regs[R_TAILDESC]) {\n\n            s->regs[R_DMASR] |= DMASR_IDLE;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 1712, "substitutes": {"s": ["ls", "c", "aunts", "p", "es", "ses", "services", "its", "state", "http", "conf", "ports", "cs", "spec", "ains", "events", "an", "h", "gs", "sb", "os", "socket", "serv", "south", "stats", "sv", "ast", "vs", "details", "xs", "ds", "qs", "m", "less", "storage", "bs", "ims", "bis", "search", "sam", "hs", "sts", "ins", "sq", "esm", "sync", "self", "S", "l", "ss", "z", "als", "sl", "comm", "i", "tes", "views", "ns", "sw", "y", "ms", "ts", "changes", "v", "tests", "se", "ssl", "ops", "sp", "sys", "is", "g", "r", "b", "fs", "aws", "ps", "parts", "js", "comments", "sports", "rs", "bits", "ats", "t"], "tx_dev": ["TX2dev", "mm_ev", "tx2dev", "TX2device", "tx_device", "txxlink", "tx2div", "mm_div", "tx2ev", "tx_link", "tx_div", "tx2device", "TX_dev", "txxdevice", "tx2Dev", "TX2link", "mm_Dev", "tx_Dev", "TX_link", "txxdev", "mm_dev", "tx_ev", "TX_device", "tx2link"], "prev_d": ["prev___D", "prev__D", "prev__p", "prev___d", "pre___d", "prev_dh", "next_D", "pre_p", "pre_r", "next_d", "next___v", "prev_D", "prev___v", "pre___D", "next___d", "vious_dh", "prev_l", "prev__r", "vious_d", "next_v", "next___r", "prev___p", "pre_d", "pre___r", "pre_D", "next___D", "vious_D", "prev__v", "prev_v", "prev_p", "next_r", "prev_r", "prev___r", "pre___p", "prev__d", "vious_l"], "txbuf": ["txtdoc", "txtBuffer", "txtvec", "txtb", "TXbuf", "ctxbuffer", "txqueue", "xbuf", " txbuff", "ctxqueue", " txlim", "TXb", "txBuffer", " txstr", "txtbuf", "TXvec", " txdb", "xbuff", "ctxbuff", "txdoc", "txtlim", "txbuffer", "TXbuffer", "xlen", "txdb", "txtstr", " txvec", "txtqueue", "ctxstr", " txqueue", " txb", "ctxlen", "txb", "ctxBuffer", "ctxdoc", "txtbuffer", " txBuffer", "txvec", " txbuffer", "txlim", "ctxlim", "ctxdb", "txbuff", "xdb", " txdoc", "txstr", "ctxbuf"], "txlen": ["txtvec", "deflen", "txLen", "TxLen", "actbuf", "defbuf", "rxLen", "txlan", "TXbuf", "txmn", "xbuf", "txtlen", "transcompl", "txl", "translength", "Txlen", " txlim", "txlf", "rxbuf", "txlength", "txtbuf", "ctxlan", "TXlength", "ctxLen", "Txl", "Txlim", "txtlength", "actlen", "rxen", "TXlen", "translen", "ctxlength", "TXLen", "rxlim", "txtcompl", "transvec", "xlen", "transLen", "ctxvec", "ctxbuf", "xlan", " txLen", " txlength", " txen", "rxlen", "ctxlen", " txlf", "transmn", "rxl", "txlim", " txl", " txmn", "txvec", "rxlength", "actlf", "txcompl", "TXen", "txen", "actlength", "txtlan", "ctxcompl", "TXmn", "xlength", "deflength", "defLen", "rxlf"], "app": ["proc", "stack", "acc", "j", "q", "arr", "buf", "ext", "conn", "all", "p", "ev", "attr", "window", "APP", "pp", "mp", "out", "m", "res", "var", "b", "pack", "tx", "form", "msg", "tab", "seq", "cache", "win", "req", "snap", "ps", "dev", "js", "bb", "cell", "App", "cap", "apply", "sam", "ap", "ms", "comp", "append", "db", "reg", "aps", "mac", "v", "pre", "display", "sp", "application", "allow", "prev", "raw", "ac", "apps", "mem", "base", "map", "buff"]}}
{"project": "FFmpeg", "commit_id": "a70a3f0b4dc488ad04f81c16479c74f57b17e06f", "target": 0, "func": "static int adpcm_decode_init(AVCodecContext * avctx)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n\n\n    if(avctx->channels > 2U){\n\n        return -1;\n\n    }\n\n\n\n    c->channel = 0;\n\n    c->status[0].predictor = c->status[1].predictor = 0;\n\n    c->status[0].step_index = c->status[1].step_index = 0;\n\n    c->status[0].step = c->status[1].step = 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_CT:\n\n        c->status[0].step = c->status[1].step = 511;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1713, "substitutes": {"avctx": [" avkt", "Avcmp", " avreq", "afaddr", "avectx", "afjp", " avkb", "Avcontext", "aveconf", "avejp", "avercontext", "afconf", "avertx", "avkb", "wavreq", "aveaddr", "avekl", "avpkg", "avecontext", "evcmp", " avcb", "avkt", "afpkg", "Avcb", "avervals", "averpkg", "afcb", "avercp", "wavtx", " avjp", "avtx", "ajctx", " avcontext", "afkt", "evcontext", "afcontext", "avecmp", "ajaddr", "Avctx", "aftx", "ajconf", "avconf", "wavcp", " avvals", "avepkg", "wavpkg", "avetx", "wavctx", "evctx", "avcp", "avekt", "avekw", "averkw", "afcmp", "avcb", "avkl", "avekb", " avcp", " avcmp", "avjp", "averkl", "afctx", "ajcontext", "evkb", "wavkl", "avkw", " avpkg", " avtx", "wavcontext", "avcontext", "avreq", "wavvals", "wavkw", "avaddr", "averreq", "avvals", "avcmp", "averctx"], "c": ["cor", "ec", "cp", "vc", "fc", "cr", "pc", "xc", "bc", "nc", "unc", "p", "dc", "ca", "ic", "uc", "ci", "cb", "com", "ce", "C", "cont", "sc", "form", "etc", "cache", "at", "cmp", "config", "content", "oc", "conf", "call", "ch", "cf", "tc", "cv", "arc", "cs", "ctx", "con", "gc", "co", "anc", "coll", "enc", "abc", "cu", "cc", "ct", "cl", "cm", "rc", "lc", "ac", "t", "mc", "ctrl", "chain"]}}
{"project": "qemu", "commit_id": "e5fda03839e3c61b01d6c60de5625501d01c69d0", "target": 1, "func": "static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n\n{\n\n    read_local_name_rp params;\n\n    params.status = HCI_SUCCESS;\n\n    memset(params.name, 0, sizeof(params.name));\n\n    if (hci->device.lmp_name)\n\n        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n\n\n\n    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);\n\n}\n", "idx": 1721, "substitutes": {"hci": ["ghci", "Hco", "hii", "hcu", "hec", "khii", " hce", "Hcci", "achci", "Hcli", " hadi", "hecu", "ghadi", " hcu", "heci", "hcli", "hcci", "ccci", "rhcin", " hcin", " hco", "hece", "cce", "cci", "hco", "hc", "rhci", "Hci", "rhcci", " hii", "hcin", "ccu", " hcli", "khc", "hce", "achcci", " hcci", " hc", "hadi", "heii", "achcli", "ghcin", "rhadi", "achco", "khcu", "ghcci", "hecci", "khci"], "params": ["pps", "ls", "tmp", "p", "options", "docs", "ports", "pins", "spec", "pas", "properties", "args", "par", "asm", "stats", "las", "actions", "settings", "result", "vs", "names", "details", "AMS", "pretty", "shape", "users", "tags", "ims", "errors", "Par", "name", "ams", " p", "mm", "padding", "styles", "posts", " parameters", "json", "cas", "size", "pointer", "parse", "info", "new", "units", "type", "ctx", "points", " param", "changes", "types", "results", "ops", "tracks", "data", "packages", "times", "vals", "pos", "members", "ps", "parts", "config", "param", "comments", "terms", "keys", "lines", "rs", "layout", "state", "obj"]}}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static bool vnc_should_update(VncState *vs)\n\n{\n\n    switch (vs->update) {\n\n    case VNC_STATE_UPDATE_NONE:\n\n        break;\n\n    case VNC_STATE_UPDATE_INCREMENTAL:\n\n        /* Only allow incremental updates if the output buffer\n\n         * is empty, or if audio capture is enabled.\n\n         */\n\n        if (!vs->output.offset || vs->audio_cap) {\n\n            return true;\n\n        }\n\n        break;\n\n    case VNC_STATE_UPDATE_FORCE:\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 1726, "substitutes": {"vs": ["nets", "vc", "ls", "wcs", "stats", "atts", "vr", "sv", "ss", "qv", "lists", "ics", "caps", "xs", "ses", "vt", "ds", "qs", "blogs", "vals", "fs", "lbs", "obs", "vp", "its", "js", "bs", "ns", "otes", "ims", "VS", "fps", "terms", "ms", "cs", "ts", "ks", "hs", "sts", "eps", "v", "rs", "vers", "posts", "gs", "sb", "ins", "Vs", "serv"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 1736, "substitutes": {"str": ["input", "data", "stri", "br", "ctr", "gr", "list", "arr", "buf", "source", "text", "g", "attr", "r", "Str", "s", "iter", "txt", "out", "res", "i", "b", "msg", "pos", "start", "seq", "cur", "pr", "length", "end", "buffer", "ptr", "e", "cs", "fr", "STR", "print", "sp", "f", "tr", "st", "prefix", "t", "len", "chain"], "endptr": [" endreq", "startpointer", "endaddr", " endpointer", "ENDaddr", "endedpoint", "endedattr", "enderpoint", "Endser", "Endptr", "endedPtr", "startser", "ENDPtr", "ENDptr", "endPtr", " endattr", "endedreq", "endpointer", "endedptr", "endattr", "enderptr", " endser", "startreq", "enderPtr", "endser", "endedaddr", "endedpointer", "endreq", "ENDpoint", "endpoint", "Endpointer", "enderreq", "enderpointer", "startptr", "enderattr", "enderaddr", "Endreq"], "err": ["br", "ctr", " r", "gr", "cr", " res", "er", "arr", "nr", " er", " ptr", "ev", "attr", "result", "resh", "r", "iter", "exc", "erer", "act", "res", " dr", "i", "ox", "msg", "erm", "viol", "it", "req", "cmp", " error", "pr", "kr", "ch", "error", "errors", "diff", "der", "Er", "ptr", "fr", "rr", " fr", " gr", "spr", "or", "Error", "dr", "rs", " terr", "urg", "fee", "oe", "cer", "tr", "rc", "resp", " cr", "elt", "re", "obj", "rn"]}}
{"project": "qemu", "commit_id": "aaf89c8a49a8c1259b6b181d701070c6df83f3d7", "target": 0, "func": "static void test_migrate(void)\n\n{\n\n    char *uri = g_strdup_printf(\"unix:%s/migsocket\", tmpfs);\n\n    QTestState *global = global_qtest, *from, *to;\n\n    unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d;\n\n    gchar *cmd;\n\n    QDict *rsp;\n\n\n\n    char *bootpath = g_strdup_printf(\"%s/bootsect\", tmpfs);\n\n    FILE *bootfile = fopen(bootpath, \"wb\");\n\n\n\n    got_stop = false;\n\n    g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1);\n\n    fclose(bootfile);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcsource,debug-threads=on\"\n\n                          \" -serial file:%s/src_serial\"\n\n                          \" -drive file=%s,format=raw\",\n\n                          tmpfs, bootpath);\n\n    from = qtest_start(cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=kvm:tcg -m 150M\"\n\n                          \" -name pcdest,debug-threads=on\"\n\n                          \" -serial file:%s/dest_serial\"\n\n                          \" -drive file=%s,format=raw\"\n\n                          \" -incoming %s\",\n\n                          tmpfs, bootpath, uri);\n\n    to = qtest_init(cmd);\n\n    g_free(cmd);\n\n\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    global_qtest = to;\n\n    rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\"\n\n                  \"'arguments': { \"\n\n                      \"'capabilities': [ {\"\n\n                          \"'capability': 'postcopy-ram',\"\n\n                          \"'state': true } ] } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* We want to pick a speed slow enough that the test completes\n\n     * quickly, but that it doesn't complete precopy even on a slow\n\n     * machine, so also set the downtime.\n\n     */\n\n    global_qtest = from;\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_speed',\"\n\n              \"'arguments': { 'value': 100000000 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    /* 1ms downtime - it should never finish precopy */\n\n    rsp = qmp(\"{ 'execute': 'migrate_set_downtime',\"\n\n              \"'arguments': { 'value': 0.001 } }\");\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n\n\n    /* Wait for the first serial output from the source */\n\n    wait_for_serial(\"src_serial\");\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate',\"\n\n                          \"'arguments': { 'uri': '%s' } }\",\n\n                          uri);\n\n    rsp = qmp(cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    wait_for_migration_pass();\n\n\n\n    rsp = return_or_event(qmp(\"{ 'execute': 'migrate-start-postcopy' }\"));\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    if (!got_stop) {\n\n        qmp_eventwait(\"STOP\");\n\n    }\n\n\n\n    global_qtest = to;\n\n    qmp_eventwait(\"RESUME\");\n\n\n\n    wait_for_serial(\"dest_serial\");\n\n    global_qtest = from;\n\n    wait_for_migration_complete();\n\n\n\n    qtest_quit(from);\n\n\n\n    global_qtest = to;\n\n\n\n    qtest_memread(to, start_address, &dest_byte_a, 1);\n\n\n\n    /* Destination still running, wait for a byte to change */\n\n    do {\n\n        qtest_memread(to, start_address, &dest_byte_b, 1);\n\n        usleep(10 * 1000);\n\n    } while (dest_byte_a == dest_byte_b);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n    /* With it stopped, check nothing changes */\n\n    qtest_memread(to, start_address, &dest_byte_c, 1);\n\n    sleep(1);\n\n    qtest_memread(to, start_address, &dest_byte_d, 1);\n\n    g_assert_cmpint(dest_byte_c, ==, dest_byte_d);\n\n\n\n    check_guests_ram();\n\n\n\n    qtest_quit(to);\n\n    g_free(uri);\n\n\n\n    global_qtest = global;\n\n\n\n    cleanup(\"bootsect\");\n\n    cleanup(\"migsocket\");\n\n    cleanup(\"src_serial\");\n\n    cleanup(\"dest_serial\");\n\n}\n", "idx": 1760, "substitutes": {"uri": ["domain", "folder", "id", "iri", "URI", "directory", "handle", "uni", "ref", "dir", "query", "nil", "path", "url", "i", "afi", "ur", "ui", "filename", "connection", "ip", "http", "file", "username", " URI", "name", "resource", "uid", "origin", "io", "remote", "uu", "address", "du", "unit", "ri", "pid", "prefix"], "global": ["parent", "user", "tmp", "g", "gl", "session", "util", "external", "msg", "unique", "cache", "foreign", "module", "gu", "final", "local", "general", "origin", "gc", "go", "io", "remote", " local", "client", "prefix", "Global", "master", "common"], "from": ["bound", "using", "false", "initial", "add", "no", "source", "before", "org", "init", "only", "after", "out", "set", "path", "From", "form", "start", "new", "us", "with", "off", "at", "base", "end", "local", "normal", "owner", "as", "fr", "origin", "and", "or", "un", "old", "range", "in", "by", "f", "por", "reset", "st", "so", "state", "of", "a", "this", "self"], "to": ["sys", "total", "bound", "To", "test", "try", "tmp", "pro", "op", "no", "tk", "tt", "p", "TO", "after", "pb", "ont", "out", "table", "b", "with", "info", "new", "gt", "phi", "it", "at", "tp", "dev", "ta", "tom", "tz", "toc", "range", "ts", "that", "via", "co", "until", "bo", "pt", "tu", "into", "too", "target", "nt", "client", "o", "by", "must", "eto", "st", "timeout", "t", "obj", "top"], "dest_byte_a": ["dest_byte2b", "dest_byte_A", "dest_byte2A", "dest_byte2a"], "dest_byte_b": ["dest_byte2b", "dest_byte2c", "dest_byte2a"], "dest_byte_c": ["dest_byte2b", "dest_bytes1c", "dest_bytes_c", "dest_bytes1a", "dest_byte1c", "dest_bytes1e", "dest_bytes_e", "dest_byte1e", "dest_byte1a", "dest_bytes_a", "dest_bytes_b", "dest_byte1b", "dest_byte_e", "dest_byte2c", "dest_bytes1b", "dest_byte2e", "dest_byte2a"], "dest_byte_d": ["dest_byte3d", "dest_char_d", "dest_byte3c", "dest_byte_data", "dest_char_data", "dest_char_c", "dest_byte3data"], "cmd": ["mt", "cp", "ctr", "try", "tmp", "op", "handle", "ext", "bind", "init", "out", "path", "html", "cgi", "qt", "req", "Cmd", "job", "dq", "xml", "conf", "ctl", "cf", "xp", "method", "comp", "pkg", "ind", "ret", "args", "mem", "kick", "batch", "text", "pipe", "css", "dir", "cb", "act", "phy", "msg", "tab", "cmp", "mk", "name", "rev", "nt", "arg", "cert", "json", "cd", "addr", "fun", "ref", "comm", "send", "res", "call", "err", "ctx", "target", "col", "exec", "data", "prop", "term", "conn", "txt", "cfg", "url", "cli", "tx", "cont", "md", "def", "quick", "js", "command", "rpm", "ct", "gz", "norm", "MD", "raw", "obj", "base"], "rsp": ["drSP", "relpr", "armp", "relserv", "rcserv", "nresp", "qsp", "RSP", "rjp", " rsm", "rosp", "rrpr", "drmp", " rmp", " resp", "rsm", "drply", "Risp", "qsh", "relosp", "rcesp", "rssp", "vrosp", "rply", "rrsh", "srosp", "msp", "hsp", "rp", "rrsm", "arSP", " rjp", "rsmp", "drserv", "resp", "rdpt", " rlp", "rpr", "rlp", " rpt", "srisp", "Rosp", "hSP", "rcpt", "srsm", " risp", "qosp", " rserv", "rsosp", " rp", "mjp", "rrply", "dmp", "srmp", " rsh", "prisp", "drsm", " rosp", "reSP", "nrsp", "qply", "dSP", "rspr", "nrmp", "rrmp", "mmp", " rbr", "prSP", "arsp", "srSP", "rsserv", "rdserv", "Rsp", "rsSP", "rrserv", "srsp", "reisp", "rrp", "rrSP", "reosp", " rSP", "prbr", "rserv", "drosp", "rcSP", "rdmp", "rbr", "rrsp", "rdsp", "qSP", "rmp", "vrSP", "rclp", "rcsp", "drpr", "djp", "arply", "prsp", "drlp", "vrsp", "rSp", "drsh", "rSP", "rrisp", "Rsm", "RSp", "rsply", " rply", "qp", "relsp", "srply", "mSP", "hSp", "hosp", "rpt", "rrosp", "rsh", "risp", "srpr", "vrSp", "rcmp", "rrbr", "dsp", "drsp", " rpr"], "bootpath": [" bootname", "Bootpath", "buspath", "ootPath", "Bootfile", "Bootdir", "ootdir", "busfile", "ootpath", " bootPath", " bootdir", "rootfile", "rootpath", "rootname", "ootname", "BootPath", "busPath", "busdir", "ootfile", "rootPath", "bootdir", "bootPath", "bootname"], "bootfile": [" bootline", "Bootpath", "ootf", "buspath", "Bootfile", " bootFile", "bootFile", "busfile", "ootpath", "Bootf", "BootFile", "ootline", "bootline", "busline", "ootbuffer", "bootbuffer", " bootf", "ootfile", "bootf", "busbuffer", " bootbuffer", "ootFile", "busFile"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n\n                                          bool tso_enable)\n\n{\n\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n\n    uint16_t l3_proto;\n\n\n\n    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n\n\n\n    if (!tso_enable) {\n\n        goto func_exit;\n\n    }\n\n\n\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n\n                          pkt->l4proto);\n\n\n\nfunc_exit:\n\n    return rc;\n\n}\n", "idx": 1770, "substitutes": {"pkt": ["rkt", "pekt", "qnt", "racket", "Packet", "Pkg", "Pwk", " pmsg", "ppdu", " pct", " pet", "pft", "qacket", "pdu", " pck", "rck", " pwk", "cpnt", " pft", "Pft", "Pkt", "ppkt", "packwk", "cpck", "pemsg", "packkg", "qct", "packet", " pkg", " pdu", "pct", "pmsg", "peft", "Pct", "Pdu", "ppwk", "pkg", "packkt", "Pet", "pnt", " packet", "rnt", "pwk", "packnt", "pck", "ppet", "pet", "Pnt", " pnt", "qkt", "Pmsg", "cpacket", "cpkt", "pewk"], "tso_enable": ["tco_complete", "tco_ve", "tsoienable", "tso_force", "tco_success", "tsoienabled", "tso_enabled", "tsopleve", "tco_enabled", "tsoiforce", "tso_success", "tco_enable", "tso_complete", "tco_force", "tsopleenabled", "tsoisuccess", "tso_ve", "tsopleenable", "tsoplecomplete"], "l3_proto": ["l3_prob", "l3_pubbo", "l3_grol", "l3_perto", "l3_grob", "l3_progo", "l3_groTO", "l3_propco", "l3_rote", "l3_proco", "l3_propbo", "l3_groto", "l3_pubgo", "l3_perco", "l3_pute", "l3_proTO", "l3_probo", "l3_procto", "l3_prto", "l3_propto", "l3_procb", "l3_prote", "l3_prgo", "l3_puto", "l3_prol", "l3_roto", "l3_rogo", "l3_procl", "l3_perbo", "l3_pugo", "l3_rob", "l3_pergo", "l3_pubto", "l3_pub", "l3_prb", "l3_prte", "l3_pubco", "l3_propgo", "l3_procTO"]}}
{"project": "qemu", "commit_id": "5e30a07d6d70d3073ff61e6db79d61c2b688502f", "target": 1, "func": "static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    switch (cmd[0] >> 5) {\n\n    case 0:\n\n        req->cmd.xfer = cmd[4];\n\n        req->cmd.len = 6;\n\n        /* length 0 means 256 blocks */\n\n        if (req->cmd.xfer == 0)\n\n            req->cmd.xfer = 256;\n\n        break;\n\n    case 1:\n\n    case 2:\n\n        req->cmd.xfer = cmd[8] | (cmd[7] << 8);\n\n        req->cmd.len = 10;\n\n        break;\n\n    case 4:\n\n        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);\n\n        req->cmd.len = 16;\n\n        break;\n\n    case 5:\n\n        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);\n\n        req->cmd.len = 12;\n\n        break;\n\n    default:\n\n        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);\n\n        return -1;\n\n    }\n\n\n\n    switch(cmd[0]) {\n\n    case TEST_UNIT_READY:\n\n    case START_STOP:\n\n    case SEEK_6:\n\n    case WRITE_FILEMARKS:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case VERIFY:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case LOAD_UNLOAD:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG:\n\n    case MOVE_MEDIUM:\n\n    case UPDATE_BLOCK:\n\n        req->cmd.xfer = 0;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME:\n\n        req->cmd.xfer = 1;\n\n        break;\n\n    case READ_CAPACITY:\n\n        req->cmd.xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        req->cmd.xfer = 6;\n\n        break;\n\n    case READ_POSITION:\n\n        req->cmd.xfer = 20;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        req->cmd.xfer *= 40;\n\n        break;\n\n    case MEDIUM_SCAN:\n\n        req->cmd.xfer *= 8;\n\n        break;\n\n    case WRITE_10:\n\n    case WRITE_VERIFY:\n\n    case WRITE_6:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case READ_10:\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case INQUIRY:\n\n        req->cmd.xfer = cmd[4] | (cmd[3] << 8);\n\n        break;\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (req->dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            req->cmd.xfer = cmd[9] | (cmd[8] << 8);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1783, "substitutes": {"req": ["usr", "gr", "mom", "ext", "app", "tek", "var", "needed", "qt", "request", "dq", "conf", "http", "comp", "pkg", "ind", "alg", "queue", "rend", "wx", "ret", "resp", "agg", "require", "q", "uj", "dep", "crit", "dist", "rb", "task", "msg", "seq", "cmp", "requ", "rec", "rr", "expr", "ocr", "sq", "rel", "aux", "pro", "jp", "rest", "addr", "quest", "ref", "progress", "comm", "decl", "res", "cur", "compl", "ctx", "fr", "eq", "urg", "client", "prev", "prefix", "exec", "proc", "wcs", "temp", "required", "inv", "qq", "conn", "org", "query", "r", "txt", "exc", "rw", "tx", "md", "quick", "config", "desc", "grab", "rt", "reg", "rpm", "good", "buff"], "cmd": ["mt", "ctr", "cp", "try", "op", "pay", "handle", "ext", "bind", "init", "off", "qt", "gt", "fresh", "Cmd", "job", "dq", "xml", "ctl", "grad", "cond", "pkg", "ind", "rm", "bytes", "help", "ret", "args", "mem", "serv", "ctrl", "ht", "batch", "cod", "text", "dep", "dict", "mg", "crit", "cb", "act", "phy", "force", "kt", "msg", "tab", "seq", "cmp", "mk", "quit", "bg", "del", "nt", "std", "cat", "iq", "buf", "dt", "addr", "adv", "rest", "fun", "vt", "comm", "send", "cur", "att", "gen", "call", "err", "ctx", "go", "pt", "mac", "old", "low", "urg", "col", "det", "exec", "map", "prop", "inv", "hot", "term", "conn", "img", "txt", "og", "cfg", "hold", "pack", "cli", "cont", "md", "def", "quick", "js", "wo", "content", "desc", "command", "now", "dr", "good", "ct", "control", "raw", "module", "news", "buff"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)\n\n{\n\n    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));\n\n\n\n    if (!p_new)\n\n        return -1;\n\n\n\n    p_new->data = p_data;\n\n\n\n    if (!queue->p_head)\n\n        queue->p_head = p_new;\n\n    else\n\n        queue->p_tail->next = p_new;\n\n    queue->p_tail = p_new;\n\n\n\n    ++queue->size;\n\n    return 0;\n\n}\n", "idx": 1791, "substitutes": {"queue": ["stack", "batch", "q", "message", "user", "trace", "required", "list", "status", "match", "buf", "component", "widget", "select", "server", "qa", "menu", "tree", "ue", "sequence", "table", "collection", "space", "force", "Queue", "grid", "profile", "msg", "cache", "request", "bar", "entry", "history", "Q", "dq", "state", "archive", "file", "block", "buffer", "future", "command", "context", "complete", "quote", "manager", "library", "priority", "que", "remote", "console", "empty", "frame", "display", "process", "channel", "client", "forced", "worker", "line", "flag", "thread", "prefix", "store", "database", "master"], "p_data": ["pi_ret", "pmyata", "pimybuf", "post_ata", "pimydata", "post_next", "pmyret", "pi_data", "p_next", "pmyvalue", "p_buf", "pmydata", "p_value", "p_ata", "post_data", "post_value", "pmynext", "pimyret", "pi_buf", "pmybuf", "p_ret"], "p_new": [" p2node", " p_non", "tp_and", "pa_old", "polynew", "pfold", "p2local", "pafNew", "pa_New", " p_fresh", "p_good", "p2blank", "p_non", "p2old", "tp_next", "p_blank", "p_node", "p_New", "pa_dot", "pcolynow", " p2blank", "paxydev", "tp_new", " p2new", "paxydot", "p_old", "p2data", "pflocal", "pcolynew", "paxygood", "pa_local", "p_valid", "pfNew", "p2new", "p2New", "p_fresh", "pOKblank", "p2node", "pa_dev", "paflocal", "p2and", "pc_new", "p_dev", "paxynew", "p_next", " p2data", "paxynext", " p_node", "tp_good", "p2good", " p_New", "pa_new", "pafold", "pOKdata", "polynow", "pc_now", "p_dot", "pOKnode", "pcolyvalid", "p2next", "p_local", "pafnew", "pOKnew", "p_and", "pfnew", "p_now", "polyvalid", "paxyand", " p_blank", "pc_valid"], "size": ["data", "id", "number", "head", "l", "le", "c", "count", "z", "n", "index", "small", "sent", "pos", "weight", "speed", "length", "SIZE", "name", "offset", "body", "ize", "depth", "empty", "state", "len", "capacity", "Size", "sn"]}}
{"project": "qemu", "commit_id": "6977afda16c1e09dfbce4bdd877459a287269b72", "target": 1, "func": "int kvmppc_reset_htab(int shift_hint)\n\n{\n\n    uint32_t shift = shift_hint;\n\n\n\n    if (!kvm_enabled()) {\n\n        /* Full emulation, tell caller to allocate htab itself */\n\n        return 0;\n\n    }\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n\n        int ret;\n\n        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n\n        if (ret == -ENOTTY) {\n\n            /* At least some versions of PR KVM advertise the\n\n             * capability, but don't implement the ioctl().  Oops.\n\n             * Return 0 so that we allocate the htab in qemu, as is\n\n             * correct for PR. */\n\n            return 0;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n        return shift;\n\n    }\n\n\n\n    /* We have a kernel that predates the htab reset calls.  For PR\n\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n\n     * this era, it has allocated a 16MB fixed size hash table already. */\n\n    if (kvmppc_is_pr(kvm_state)) {\n\n        /* PR - tell caller to allocate htab */\n\n        return 0;\n\n    } else {\n\n        /* HV - assume 16MB kernel allocated htab */\n\n        return 24;\n\n    }\n\n}\n", "idx": 1802, "substitutes": {"shift_hint": ["shift_thints", "shift_thunt", "shift_winter", "shift_hunt", "shift_hlalt", "shift_wint", "shift_hINT", "shift_wints", "shift_shint", "shift_hlINT", "shift_hinter", "shift_hints", "shift_thinter", "shift_hlint", "shift_shINT", "shift_halt", "shift_hlints", "shift_wunt", "shift_thint", "shift_shints", "shift_shalt"], "ret": ["mt", "j", "RET", "aux", "try", "status", "jp", "code", "value", "no", "fun", "result", "ref", "r", "deg", "lt", "iter", "out", "res", "x", "lit", "ft", "num", "red", "cont", "gt", "reply", "mem", "Ret", " Ret", "state", "lv", "desc", "ptr", "tn", "rev", "rt", "re", "get", "ter", "print", "alt", "val", "fail", "rets", "pret", "nt", "nz", "det", "tr", "rem", "reset", "resp", "flag", "elt", "t", "back", "len", "inter"]}}
{"project": "FFmpeg", "commit_id": "dc64f203a62083c3d5f81e8201018279c29581af", "target": 1, "func": "static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n\n    PTXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n\n    uint8_t *ptr;\n\n\n\n\n\n    offset          = AV_RL16(buf);\n\n    w               = AV_RL16(buf+8);\n\n    h               = AV_RL16(buf+10);\n\n    bytes_per_pixel = AV_RL16(buf+12) >> 3;\n\n\n\n    if (bytes_per_pixel != 2) {\n\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n\n\n    if (buf_end - buf < offset)\n\n\n    if (offset != 0x2c)\n\n        av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\");\n\n\n\n    buf += offset;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    for (y=0; y<h; y++) {\n\n        if (buf_end - buf < w * bytes_per_pixel)\n\n            break;\n\n#if HAVE_BIGENDIAN\n\n        unsigned int x;\n\n        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)\n\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n\n#else\n\n        memcpy(ptr, buf, w*bytes_per_pixel);\n\n#endif\n\n        ptr += stride;\n\n        buf += w*bytes_per_pixel;\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return offset + w*h*bytes_per_pixel;\n\n}", "idx": 1804, "substitutes": {"avctx": ["avctl", "avconn", "avectx", "ajreq", "averconfig", "avectl", "afcfg", "cvcmp", "avercontext", "avejp", "avjac", "avobj", "avertx", "avehandle", "navctx", "ahjac", "averctl", "navcmp", "aveca", "avca", "navtx", "savconf", "cvcontext", "wavobj", "wavjac", "avpkg", "savcfg", "avecontext", "afpkg", "wavconfig", "avercu", "averca", "savobj", "wavcmp", "navcfg", "vercmp", "avercfg", "cvctx", "averpkg", "ahcp", "avconfig", "avercp", "wavtx", " avjp", "avtx", "avcu", "ajcu", "ravcu", "wavjp", "avhandle", "ajtx", " avcfg", "ajctx", " avcontext", "verjp", "verpkg", "ajjp", "afreq", "navconn", "averhandle", "afcontext", "avecmp", "ajjac", "averjp", "ravcontext", "aftx", "aveconfig", "avconf", "wavcp", "wavcmd", "ravcp", "ahcontext", "ahctx", "avepkg", "wavpkg", "wavctl", "avetx", "savpkg", "wavctx", "verctx", "avcp", "navreq", "averjac", "averconf", "cvtx", "avcfg", "ajcmd", " avconf", "avcmd", "navcu", "savctx", "savcu", " avcp", " avcmp", "avjp", "wavca", "aveconn", "afcp", "wavconn", "afctx", "ajcontext", "avejac", "avecp", "avercmp", "savcontext", "wavhandle", " avpkg", " avtx", "wavcontext", "navjac", "ajcfg", "ajpkg", " avjac", "avcontext", "savcp", "avreq", " avcu", "avecmd", "aveobj", "avcmp", "averctx", "ravctx"], "data": ["id", "format", "window", "read", "options", "page", "buffer", "body", "group", "bytes", "channel", "done", "feed", "f", "a", "share", "batch", "d", "Data", "message", "list", "images", "next", "actions", "text", "file", "name", "first", "frame", "padding", "root", "rel", "length", "values", "device", "size", "record", "to", "action", "dat", "res", "i", "info", "cache", "pad", "str", "bin", "empty", "ata", "media", "current", "pic", "ops", "map", "image", "input", "value", "DATA", "query", "r", "package", "table", "extra", "def", "content", "video", "o", "raw", "t", "obj", "join"], "data_size": ["data_length", "data_Size", " data_length", "data_shape", " data_shape", " data_Size"], "avpkt": [" avpct", "avPett", "ahvpkt", "avcpct", "ahpwk", " avPkt", " avPwk", "avcpett", " avppt", " avPpt", "avvpkt", "ahpett", "ahpct", "ahpkt", "avpwk", "avcpwk", "avPwk", "avpett", "avbppt", "ahvpct", "avcpkt", "avbpct", "avbpwk", "avbpkt", "avPct", "avPpt", "avcppt", " avpwk", "avpct", "avvpct", " avPct", "avvpwk", "ahvpwk", "avPkt", "avppt", "avvpett", "ahvpett"], "buf": ["tmp", "port", "window", "bp", "iter", "off", "cap", "front", "buffer", "cam", "cast", "que", "queue", "bytes", "mem", "sofar", "br", "batch", "shift", "bc", "result", "pb", "box", "cb", "rb", "coord", "msg", "seq", "end", "aka", "loc", "tr", "nb", "length", "uf", "addr", "ref", "broad", "cache", "cur", "pad", "err", "ctx", "ob", "wb", "bin", "db", "empty", "src", "late", "len", "cmd", "doc", "alloc", "limit", "img", "txt", "rw", "b", "pos", "orig", "vec", "bt", "desc", "cv", "Buffer", "bl", "raw", "Buff", "buff"], "s": ["sys", "ls", "S", "stats", "c", "is", "sv", "ss", "details", "ess", "ds", "i", "b", "fs", "tx", "ps", "js", "ns", "conf", "comments", "ms", "cs", "ts", "hs", "sts", "rs", "pers", "gs", "si", "sb", "ats", "os", "sq", "t", "acs", "sp"], "picture": ["fp", "image", "document", "piece", "information", "style", "stat", "record", "img", "P", "np", "photo", "figure", "query", "conference", "share", "pict", "family", "policy", "profile", "info", "pen", "vp", "pr", "Picture", "fi", "pa", "context", "ctx", "video", "protected", "v", "frame", "media", "camera", "png", "pic", "point", "feature", "sp"], "p": ["fp", "d", "cp", "j", "lp", "wp", "l", "pro", "op", "jp", "pc", "c", "g", "P", "r", "np", "pi", "pb", "pp", "m", "i", "b", "pg", "part", "vp", "pr", "ps", "tp", "ip", "pa", "ap", "pl", "pkg", "pt", "v", "pre", "o", "f", "pic", "rep", "t", "a", "ping", "sp"], "offset": ["fp", "image", "xff", "tile", "et", "size", "op", "code", "format", "shift", "addr", "skip", "slot", "meta", "seek", "attr", "ref", "window", "index", "crop", "pointer", "set", "coord", "pos", "start", "off", "adjusted", "zero", "pad", "location", "length", "OFF", "end", "error", "rot", "buffer", "attribute", "area", "origin", "reference", "Offset", "option", "loc", "offs", "empty", "ata", "address", " seek", "o", "padding", "scroll", "f", "position", "reset", "point", "prefix", "base", "len", "sp"], "w": ["height", "wn", "wi", "n", "hw", "window", "wl", "buffer", "wd", "iw", "wx", "f", "png", "a", "d", "fw", "W", "m", "nw", "we", "ex", "xy", "ew", "wid", "wp", "l", "size", "word", "words", "wa", "new", "sw", "kw", "hi", "wb", "v", "wal", "wr", "_", "wcs", "ww", "g", "img", "r", "wh", "rw", "win", "def", "wo", "wt", "raw", "obj", "jpg"], "h": ["j", "q", "l", "he", "high", "size", "c", "height", "bh", "sh", "z", "kh", "hr", "uh", "n", "g", "hw", "r", "oh", "ah", "hh", "H", "ish", "wh", "m", "html", "b", "him", "ih", "it", "hei", "history", "k", "ch", "hd", "hl", "hop", "hi", "hal", "hs", "hm", "v", "ha", "hash", "o", "hang", "length", "ht"], "y": ["sys", "ny", "j", "ty", "try", "uy", "key", "size", "axy", "hot", "c", "height", "ay", "iy", "py", "sim", "n", "cy", "any", "index", "yt", "gy", "sy", "m", "ady", "i", "b", "ya", "it", "yer", "type", "at", "ey", "yr", "fy", "xy", "vy", "icy", "ch", "k", "e", "kit", "asy", "Y", "ies", "ry", "v", "yy", "by", "sky", "ot", "very", "oy", "t", "ye", "my"], "stride": ["strider", "rider", "stie", "strange", "STRide", "STRider", " strange", "Stride", "STRride", " strie", "Strange", " strride", "rride", "Strride", "strIDE", "stange", "stider", "ride", "stide", "Strie", "stIDE", "STRIDE", "strride", "rIDE", "strie"], "bytes_per_pixel": ["bytes_Per_device", "bytes_per_Pixel", "bytes_PER_pixel", "bytes_Per_channel", "bytes_per_char", "bytes_per___pixel", "bytes_per_page", "bytes_per_tile", "bytes_PER_image", "bytes_of_chip", "bytes_per2Pixel", "bytes_per__char", "bytes_per2page", "bytes_perTimedevice", "bytes_per_color", "bytes_per_channel", "bytes_perTimechannel", "bytes_PER_char", "bytes_PER_cell", "bytes_Per_Pixel", "bytes_PER_color", "bytes_Per_pixel", "bytes_per__pixel", "bytes_per___tile", "bytes_per__color", "bytes_per_device", "bytes_per_chip", "bytes_PER_tile", "bytes_per_image", "bytes_per2pixel", "bytes_Per_page", "bytes_of_color", "bytes_per___image", "bytes_per_cell", "bytes_of_pixel", "bytes_perTimepixel"], "ptr": ["fp", "proc", "br", "ctr", "alloc", "tmp", "addr", "vr", "handle", "row", "seek", "attr", "ref", "np", "r", "pointers", "iter", "rect", "pointer", "inters", "index", "td", "Ptr", "pos", "pad", "pr", "tp", "end", "buffer", "pend", "copy", "ctx", "cut", "pt", "loc", "dr", "address", "ret", "cmd", "src", "tr", "rep", "store", "obj", "push", "inter", "pert"], "x": ["fx", "key", "try", "xc", "height", "xxxx", "ext", "z", " ax", "my", "dx", "xf", "xi", "any", "index", "xs", "inx", "xa", "ax", "m", "ox", "lat", "i", "mx", "pixel", "tx", " X", " tx", " i", "ex", "xy", "ux", "xt", "xxx", "xp", "xx", "el", " dx", "px", "rx", " xx", "yx", "ix", "v", " cx", "on", "xd", "wx", "xxxxxxxx", "xes", "X"]}}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 1817, "substitutes": {"bs": ["ls", "bc", "ss", "bm", "als", "vs", "bp", "ds", "b", "ubs", "fs", "lbs", "BS", "iss", "obs", "asis", "ps", "its", "bos", "ns", "aos", "js", "bis", "ts", "cs", "bes", "bps", "hs", "blocks", "bl", "bits", "blog", "bing", "gs", "sb", "ats", "aus"], "s": ["sys", "sis", "ls", "S", "j", "stats", "l", "c", "sv", "ss", "p", "z", "als", "g", "n", "es", "sl", "ses", "ess", "comm", "ds", " ss", "m", "b", "fs", "less", "aws", "ps", "its", "js", "ns", "y", "ims", "w", "ts", "cs", "spec", "ies", "hs", "sts", "rs", "v", "h", "gs", "ats", "ins", "sq", "os", "t", "a", "se", "ops"]}}
{"project": "qemu", "commit_id": "c88305027d5a8dbeaacf04ad2ceba79a5c5fb91e", "target": 1, "func": "POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    cc->has_work = cpu_has_work_POWER9;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n\n    /* segment page size remain the same */\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n    pcc->radix_page_info = &POWER9_radix_page_info;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n", "idx": 1822, "substitutes": {"oc": ["doc", "ec", "vc", "cp", "oid", "alloc", "isc", "ocation", "PC", "pc", "c", "bc", "nc", "unc", "soc", "org", "uc", "og", "oco", "OC", "ok", "voc", "roc", "osc", "tc", "arc", "oci", "aco", "ous", "ob", "co", "loc", "od", "o", "oe", "ocr", "rc", "ot", "ac", "oad", "mc"], "data": ["doc", "d", "Data", "device", "DATA", "result", "ds", "dat", "res", "dll", "cache", "def", "dev", "mu", "output", "rec", " DATA", "bus", "bin", "ata", "di", "raw", "da", "des", "obj"], "dc": ["doc", "ec", "vc", "d", "cp", "fc", "cd", "dt", "pc", "c", "bc", "DC", "nc", "dd", "uc", "ca", "iac", "ds", "dat", "dm", "desc", "tc", "df", "rec", "co", "dr", "mac", "disc", "dp", "di", "rc", "lc", "da", "mc", "cca"], "pcc": ["nacc", "pcca", "hpc", "gfc", "cck", "ppc", "hct", "yacc", "ycca", "pinggc", " pucc", "pCC", "tacc", "Pcc", "pingcc", " pct", "PCC", "tcc", " pCC", "tct", "tcca", "pingcca", "nck", "cCC", " pck", "ccca", "ncca", "Ppc", "pac", " pfc", "gcca", "pfc", "nCC", "Pgc", " pacc", "ycc", "gacc", "pingCC", " pac", "yct", "gcc", "pct", "cct", "Pct", " pgc", " ppc", "Pck", "pingct", "pacc", "hcca", "pucc", "cucc", " pcca", "cac", "pck", "ccc", "pingucc", "ncc", "pgc", "npc", "pingck", "hcc", "nfc", "hac", "hfc", "nct", "cpc"], "cc": ["ec", "vc", "acc", "cp", "isc", "fc", "pc", "CC", "c", "nc", "bc", "uc", "ci", "pp", "sc", "cci", "roc", "ctl", "cf", "tc", "cs", "co", "gc", "cu", "ct", "rc", "ck", "cm", "lc", "ac", "mc", "cca"]}}
{"project": "FFmpeg", "commit_id": "f028d4d1c393a13c66e828d45ba8412c0b4df6da", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!s->pb->eof_reached) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition->essence_offset) {\n\n                compute_partition_essence_offset(s, mxf, &klv);\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    return mxf_parse_structural_metadata(mxf);\n\n}\n", "idx": 1878, "substitutes": {"s": ["sys", "ls", "d", "S", "south", "j", "stats", "c", "sg", "is", "source", "ss", "p", "es", "scl", "sv", "n", "z", "g", "simple", "r", "details", "xs", "ses", "ds", "qs", "m", "b", "fs", "gets", "tes", "aws", "ps", "its", "parts", "js", "ns", "bs", "sw", "http", "local", "ims", "w", "bis", "ms", "fps", "cs", "ts", "ctx", "sports", "changes", "hs", "events", "sts", "an", "rs", "v", "in", "o", "h", "gs", "f", "ats", "sb", "ins", "sq", "os", "t", "a", "this", "self"], "ap": ["pro", "op", "ep", " sp", "up", "np", "bp", "mp", "pp", "amp", "hp", "dat", " mp", "att", "ps", "tp", "ip", "cap", "pa", "pl", " p", "ar", "aps", "am", "ata", "al", "tap", "sp"], "mxf": ["Mfif", "mlf", "wfw", " mze", "kxf", "tmfo", "anxf", "cmfo", "mxd", "dxf", "cmcf", "klf", "yfw", "kfo", "mailaf", "Maf", " mcf", "rmfc", "dfe", "imxf", " mfx", "Mfo", "imfe", "imfo", "jfw", "mfo", "jfx", "Mze", "bmcf", "mailcf", "mze", "kfx", "bmze", "mtxf", " mfo", "mailxf", "manfo", "Mxf", "mfw", "wfc", "mxff", "imxff", "wfx", "dxff", "rmfx", "yfx", "rmxf", "manxf", "anfx", "manxe", "anfw", "anxd", "cmaf", "yxf", "mfc", "maf", "tmfx", "bmxe", "mtxff", "mcf", "rmfw", "mtfo", "jfc", " mlf", " mxe", "manfw", "manxd", "mfx", "cmxf", "Mxe", " maf", "dfo", "jxf", "manfx", "manlf", "yxd", "tmxe", "mtfe", "mfif", "bmxf", "mailfif", "mfe", " mfif", "tmxf", "wxf", "mxe", "Mcf"], "klv": ["okvl", "arklr", "isklv", "isklr", "arkley", "mlf", "unklv", "arklev", "unkv", "unkernal", "iklf", "iklr", "dktif", "akLV", "oklev", "unkvl", "akvv", "isklvl", "asklr", "klf", "unklev", "ikvv", "ekwl", "kLV", "arkvl", "dklr", "kvl", "ekLV", "kvv", "oklv", "unktif", "aklv", " kley", " klad", "kernal", "mlv", "klev", "klr", "mLV", "arkll", "asklv", "ekvv", "wklv", "unklu", "kelvl", "asklein", "kll", "klein", "unkvv", "okvv", " kvv", "askvl", "askll", "dkv", "candLV", "tkvl", "cklein", "kevP", "akls", "eklv", "wkvv", " kvP", "dklv", "isklu", "klvl", "kvP", "aklr", "unklamm", "mkLV", "mvl", "candlamm", "tklv", "tkLV", "kley", " kll", "ikll", "klu", "dkll", "iklv", "klamm", "asklev", "wklf", " kv", "arkvv", " kvl", "aclv", "klig", "cklev", " ktif", " klu", "mklamm", "mkernal", "cklv", "dklu", "unklig", "arklu", "ikwl", "eklr", "cklig", "kelu", "mklv", "tklf", " kls", " kLV", "eklf", "akwl", "oklf", "unklr", "unkLV", "unklad", "unklvl", "kelv", "kwl", "kls", "ktif", "wkLV", " klvl", "okll", "klad", " klr", "acvP", "unklf", "ekls", "ikvl", "aclu", "ikLV", "dkley", " klf", "iklev", "aklf", "asklig", "candlv", "unklein", "candernal", "aclvl", "kv", "oklad", "arklv"], "metadata": ["multi", "mt", "data", "ka", "tmp", "summary", "meta", "ATA", "definition", "csv", "m", "header", "eta", "msg", "info", "md", "storage", "cmp", "dm", "xml", "tar", "name", "adata", "ata", "primary", "properties", "met", "json"]}}
{"project": "FFmpeg", "commit_id": "1577526b47439f33a999339efdec5d624b70e1da", "target": 1, "func": "static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    opj_image_cmptparm_t cmptparm[4] = {{0}};\n    opj_image_t *img;\n    int i;\n    int sub_dx[4];\n    int sub_dy[4];\n    int numcomps;\n    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;\n    sub_dx[0] = sub_dx[3] = 1;\n    sub_dy[0] = sub_dy[3] = 1;\n    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;\n    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;\n    numcomps = desc->nb_components;\n    switch (avctx->pix_fmt) {\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_YA8:\n    case AV_PIX_FMT_GRAY16:\n    case AV_PIX_FMT_YA16:\n        color_space = CLRSPC_GRAY;\n        break;\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_RGB48:\n    case AV_PIX_FMT_RGBA64:\n    case AV_PIX_FMT_GBR24P:\n    case AV_PIX_FMT_GBRP9:\n    case AV_PIX_FMT_GBRP10:\n    case AV_PIX_FMT_GBRP12:\n    case AV_PIX_FMT_GBRP14:\n    case AV_PIX_FMT_GBRP16:\n    case AV_PIX_FMT_XYZ12:\n        color_space = CLRSPC_SRGB;\n        break;\n    case AV_PIX_FMT_YUV410P:\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9:\n    case AV_PIX_FMT_YUV422P9:\n    case AV_PIX_FMT_YUV444P9:\n    case AV_PIX_FMT_YUVA420P9:\n    case AV_PIX_FMT_YUVA422P9:\n    case AV_PIX_FMT_YUVA444P9:\n    case AV_PIX_FMT_YUV420P10:\n    case AV_PIX_FMT_YUV422P10:\n    case AV_PIX_FMT_YUV444P10:\n    case AV_PIX_FMT_YUVA420P10:\n    case AV_PIX_FMT_YUVA422P10:\n    case AV_PIX_FMT_YUVA444P10:\n    case AV_PIX_FMT_YUV420P12:\n    case AV_PIX_FMT_YUV422P12:\n    case AV_PIX_FMT_YUV444P12:\n    case AV_PIX_FMT_YUV420P14:\n    case AV_PIX_FMT_YUV422P14:\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"The requested pixel format '%s' is not supported\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt));\n    }\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = sub_dx[i];\n        cmptparm[i].dy = sub_dy[i];\n        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];\n        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];\n    }\n    img = opj_image_create(numcomps, cmptparm, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    img->x0 = 0;\n    img->y0 = 0;\n    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;\n    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;\n    return img;\n}", "idx": 1883, "substitutes": {"avctx": ["AVcontext", "avconn", "averdesc", "avectx", " avcmp", "AVdesc", "avtx", "avecc", "avjp", "avercontext", "avejp", "afctx", "avertx", "AVcmp", "avercmp", "avecfg", "AVconn", "averconn", " avcontext", "AVtx", "AVctx", "avcontext", "avcc", "afdesc", "savcfg", "savjp", "avercc", "savcc", "afcontext", " avconn", "avcfg", "savctx", "averjp", "avcmp", "averctx", "aftx", "avercfg", "avdesc"], "parameters": ["paramences", "configeters", "pences", "pparams", " paramparams", "peters", " paramences", "configences", " parameter", "parameter", "configeter", "paramparams", "peter", "configparams"], "desc": ["doc", "cor", "ec", "DES", "env", "buf", "sec", "conn", "dep", "dict", "dc", "description", "dir", "txt", "Desc", "util", "dem", "crit", "dist", "decl", "cfg", "asc", "ds", "esc", "res", "info", "sc", "cont", "def", "req", "cmp", "dev", "writer", "conf", "comment", "der", "cam", "ptr", "rec", "ctx", "or", "reg", "loc", "disc", "driver", "col", "rem", "fn", "des", "enc", "mem", "cmd", "TOR"], "cmptparm": ["cmptparam", "cmptparms", "cmphopparam", "cmphparm", "cmptpparam", "cmphoparms", "cmphoparm", "cmptcparm", "cmphpparam", "cmptoparms", "cmptParam", "cmptcparms", "cmphoparam", "cmptcparam", "cmphparms", "cmptParms", "cmphparam", "cmptoparm", "cmptcpparam", "cmptParm", "cmptPparam", "cmptoparam", "cmptopparam"], "img": ["image", "j", " im", "tmp", "ut", "buf", "images", "view", "ext", "conv", "ref", "np", "mp", "m", "orig", "cur", "map", "ch", "im", "imp", "bg", "src", "pic", "gm", "obj", "jpg", "fm", "uf"], "i": ["j", "l", "ii", "ki", "c", " j", "p", "n", "pi", "index", "r", "ci", "li", "m", "b", "phi", "it", " ii", "bi", "im", "v", "o", "mi", "di", "ai", "I", "si", "t"], "sub_dx": ["ub___der", "sub_dis", "fun_dy", "ub___dy", "subgrdx", "subLxd", "ub_dx", "sub___dx", "sub___der", "super_dim", "sub_der", "ub_des", "Sub_dis", "sub_fx", "sub___des", "fun67wx", "sub67yx", "Sub_fx", "sub_wx", "sub_xy", "sub_xx", "fun_dx", "sub_xd", "subLxy", "subLdx", "ub_dy", "Sub_dx", "ub___des", "sub67fx", "fun67yx", "sub67dx", "ub___dx", "sub_des", "sub___yx", "fun67dx", "super_xx", "Sub_xd", "ub_der", "sub67wx", "subLfx", "super_dx", "Sub_yx", "sub_yx", "subgryx", "Sub_xy", "fun_wx", "sub___wx", "subgrfx", "sub___dy", "fun67dy", "sub67dis", "super_fx", "sub67dy", "sub_dim", "subgrdis", "fun_yx"], "sub_dy": ["sub_lon", "sub_y", "sub_slow", "sub_dis", "sub0db", "sub67my", "sam_ey", "clip_den", "sub___slow", " sub_xy", "sub0dy", "sub_ty", "sub_ey", "soc_slow", "soc_xy", "sub___yy", "sam_y", "sam_dy", "sam_my", "sub_xy", "sub___ty", "subJmy", "subJey", "sub_dl", "sub_den", "sub___den", "sub___xy", "clip42den", "sub_db", "subJdy", "sub___my", "sub42my", "clip42dy", "exec_slow", "exec_dy", "clip42my", "clip_my", "clip_lon", "subJy", "clip42lon", "sub42dy", "sub67ey", "sub_yy", "clip_dy", "sub___lon", " sub_yy", "soc_dy", "exec_db", "sub___dy", "sub0slow", "sub___dl", "soc_ty", "sub_my", "sub0dis", " sub_dl", "sub42den", "sub67dy", "sub42lon", "exec_dis", "sub67y"], "numcomps": ["numComms", "NUMComPS", "NUMcomPS", "numcomppos", "NUMcomps", "NUMComps", "NUMComms", "numCOMPS", "NUMcomms", "numcompPS", "numcompos", "numComps", "numCOMms", "numcomPS", "numcompps", " numCompos", " numcomms", "numCOMps", " numComPS", "numcomms", " numComps", "NUMCompos", " numComms", "numCompos", "numcompms", "numCOMpos", " numcompos", "numComPS", "NUMcompos", " numcomPS"]}}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static int xen_platform_initfn(PCIDevice *dev)\n\n{\n\n    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = d->pci_dev.config;\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n\n\n    pci_config_set_prog_interface(pci_conf, 0);\n\n\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n\n\n    pci_register_bar(&d->pci_dev, 0, 0x100,\n\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);\n\n\n\n    /* reserve 16MB mmio address for share memory*/\n\n    pci_register_bar(&d->pci_dev, 1, 0x1000000,\n\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);\n\n\n\n    platform_fixed_ioport_init(d);\n\n\n\n    return 0;\n\n}\n", "idx": 1894, "substitutes": {"dev": ["doc", "proc", "device", "buf", "adv", "conn", "dd", "p", "ev", "hw", "app", "dem", "debug", "devices", "Dev", "def", "pad", "conf", "sd", "w", "cam", "cast", "ver", "spec", "de", "go", "DEV", "db", "v", "nt", "ad", "ve", "raw", "des", "mem", "obj", "push", "pro"], "d": ["j", "l", "dt", "c", "rest", "nd", "bd", "z", "p", "dd", "dict", "n", "dc", "dx", "r", "debug", "ds", "send", "dat", "m", "b", "gd", "md", "dh", "t", "dm", "dom", "y", "sd", "did", "w", "e", "dos", "ind", "de", "db", "fd", "dr", "v", "o", "di", "done", "h", "ad", "f", "D", "pd", "da", "des", "ld", "dn"], "pci_conf": ["pcm_con", "pdi_conf", "pci_conn", "pci__conn", "pci_con", "pai_conf", "pai_conn", "pcgi_con", "pcgi_cfg", "pci__config", "pci_prop", "pdi_con", "pdi_prop", "pcm_conn", "pdi_tab", "pcm_conf", "pai_config", "pci__conf", "pci_tab", "pcgi_config", "pci_config", "pcgi_conf", "pdi_config", "pci_cfg", "pci__con", "pcm_cfg", "pci__cfg", "pai_cfg"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n", "idx": 1896, "substitutes": {"fs_ctx": ["fsjtx", "fs__cc", "os_pkg", "os_cc", "fs__ctx", "fs__tx", "fsjrec", "cs_context", "cs_tx", "cs_ctx", "fs_pkg", "fs_context", "cs_rec", "fs_rec", "os_tx", "fs__pkg", "fs_cc", "fsjctx", "fs_tx", "fsjcontext", "os_ctx"], "oldpath": ["oldth", "olddir", "OLDPath", "Oldname", "oldPath", "oldname", "Oldth", "OLDname", "olderdir", "OLDpath", "olderPath", " oldPath", "Olddir", "Oldpath", " oldth", "OldPath", " olddir", "olderpath", " oldname", "olderth"], "dir_path": [" dir_name", "dir2file", "dirlyfile", "dirlypt", "dir_name", " folder_Path", "dir2name", " folder_path", "dir2Path", "dir_Path", "dir_pt", "dir2path", " dir_Path", "dirlyPath", " folder_pt", "dirlypath", "dir_file", "dir2pt", " folder_file"], "name": ["data", "id", "NAME", "nam", "key", "size", "word", "format", "ext", "source", "text", "n", "dir", "names", "node", "label", "path", "ame", "part", "none", "new", "info", "type", "snap", "title", "filename", "time", "file", "version", "comment", "alias", "nm", "one", "ident", "nu", "Name", "root", "missing", "prefix", "base"], "credp": [" cedpy", "cradp", "cpreds", "cpredpi", "crace", "creditphp", "cedpy", "cbedp", " cedp", " crode", " credphp", "crodp", "cbeds", " cpredpi", "creditpi", "crodphp", "cracpi", " crede", "ceds", "cpredp", "cpredpy", " creds", "credphp", "cracp", "cbedpy", "cpredinfo", "credite", " credinfo", "cpredc", " credpy", " crodinfo", "cradphp", "crede", "cedc", "crade", " cpredp", "crodinfo", "cradinfo", "cedp", " crodp", "cracphp", "credpy", "creds", "cprede", "credc", "cpredphp", " credc", " ceds", "crode", " credpi", " cedc", "cbedc", "credpi", " cprede", "creditp", "credinfo", " cpredphp", " crodphp"], "retval": ["RETvals", "retVAL", "returnVal", " retvals", "retlen", "reval", "Retpol", " retlen", "Retval", "relen", "interval", "RETvalue", "reteval", " retry", "interry", " Retvals", "rtpol", "RetVAL", "retpol", "returnvalue", " Retval", "retvalue", " reteval", "altvalue", " Retvalue", "altval", "altVAL", "returnval", "retvals", "rtvalue", "reVal", "retVal", "intervalue", " RetVal", " Retlen", "rtval", " retVAL", "intervals", "altVal", "retry", "returnpol", "RetVal", " retvalue", "RETval", "reeval", "revvalue", "Retvalue", "revval", "revvals", "rtVal", "revry", " Reteval", " retVal", "RETVal"], "fullname": ["longn", "flatname", "flatn", "shortname", " fullame", "fullnamed", "relame", "longnamed", "Fullname", "fullNAME", "fulnamed", "fullame", "longpath", "relname", "shortName", "longame", " fullpath", "flatName", "relNAME", "fullstring", "relName", "flatpath", " fullNAME", "relpath", "longName", "fullpath", "fullName", " fullstring", "longstring", "fuln", "flatnamed", "shortame", "fulame", "shortpath", "longname", "flatstring", "fulName", "fulname", "fulln", " fullName", "Fullpath", "fulNAME", "Fullame", "FullName", "fulpath"], "target": ["data", "template", "ARGET", "parent", "id", "goal", "trace", "prop", "match", "managed", "format", "host", "handle", "mask", "port", "source", "next", "component", "to", "seek", "window", "Target", "focus", "node", "result", "pointer", "stable", "path", "table", "proxy", "gt", "bolt", "controller", "type", "title", "scope", "transform", "location", "token", "output", "binding", "normal", "buffer", "context", "that", "alias", "origin", "resource", "dest", "global", "arget", "remote", "range", "null", "rel", "root", "peer", "arg", "direction", "top", "subject", "this", "touch"]}}
{"project": "qemu", "commit_id": "ea486926b07d2ebd73ef67315ebb1eecf39faf5a", "target": 0, "func": "static int vfio_enable_intx(VFIODevice *vdev)\n\n{\n\n    VFIOIRQSetFD irq_set_fd = {\n\n        .irq_set = {\n\n            .argsz = sizeof(irq_set_fd),\n\n            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,\n\n            .index = VFIO_PCI_INTX_IRQ_INDEX,\n\n            .start = 0,\n\n            .count = 1,\n\n        },\n\n    };\n\n    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);\n\n    int ret;\n\n\n\n    if (vdev->intx.disabled || !pin) {\n\n        return 0;\n\n    }\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */\n\n    ret = event_notifier_init(&vdev->intx.interrupt, 0);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: event_notifier_init failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);\n\n    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);\n\n\n\n    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {\n\n        error_report(\"vfio: Error: Failed to setup INTx fd: %m\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /*\n\n     * Disable mmaps so we can trap on BAR accesses.  We interpret any\n\n     * access as a response to an interrupt and unmask the physical\n\n     * device.  The device will re-assert if the interrupt is still\n\n     * pending.  We'll likely retrigger on the host multiple times per\n\n     * guest interrupt, but without EOI notification it's better than\n\n     * nothing.  Acceleration paths through KVM will avoid this.\n\n     */\n\n    vfio_mmap_set_enabled(vdev, false);\n\n\n\n    vdev->interrupt = VFIO_INT_INTx;\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    return 0;\n\n}\n", "idx": 1900, "substitutes": {"vdev": [" vhost", " vdes", "vdevice", "vplayer", "vvdev", "vserial", "ivdevice", "wdevice", " vev", "vev", "vmcomment", "mver", "vstore", "vmdev", "ivdebug", "mdev", "uvdev", " vplayer", "ivplayer", "cvde", "tserv", " vserial", "vcinfo", " vapp", " vdata", " vserv", "vrdev", "vcam", "vcdevice", "svDEV", "vd", "whost", " vdef", "vhost", "mdevice", "ovdev", "pdevice", "cvgo", "vserv", "vcapp", "vmcam", " vdevice", " vpatch", "tvserver", "tvdev", "vdef", "ovadd", "pev", "vcver", "voldevice", " vaddr", "formdevice", "invdev", "vmctx", "vde", "ovpatch", "cvdata", "formstore", "maddr", " vvar", " vde", "vaddr", "tdev", "invcam", "wdev", "wstore", "uvserv", "vccomment", " vinfo", "invplayer", "vvadd", "vdata", "svstore", "vserver", "tev", "tvcam", "vmaddr", "hserv", "vcast", "wserv", "vcomment", "mvar", "ivdev", " vd", "vcev", " vver", "uvdevice", "uvcast", " vctx", "vdebug", "vver", "haddr", " vserver", "mserv", "vccast", "uvd", "vmpatch", " vgo", "vcaddr", "hdev", "svdev", "wcast", "vpatch", "vapp", "ivcam", "vctx", "vpay", "vmserver", "mDEV", "uvserial", "pdev", "formdes", "vcpatch", "volvar", "vgo", "vdes", "vDEV", " vstore", " vdebug", "mstore", "wev", "vcdev", "hdevice", "vvdef", "pserv", "tvctx", "vadd", "vvpatch", "vrdata", "waddr", " vcam", "vvar", "vchost", "cvdev", "md", "wdes", "voladdr", "formdebug", "ovdef", "formpay", " vpay", "ivpay", "vcserial", "formdev", " vDEV", " vcast", "svdevice", "minfo", "tdevice", "vinfo", "invserver", "vrgo", "voldev", "uvapp", "vrde", " vadd", "ivserver", " vcomment"], "ret": ["mt", "j", "RET", "cat", "status", "jp", "no", "nl", " RET", "result", "ref", "txt", "bool", "out", "res", "num", "cont", "gt", "ll", "zero", "mem", "Ret", "locked", " Ret", "end", "err", "compl", "got", "bad", "str", "alt", "rt", "re", "ter", "print", "ry", "v", "val", "rets", "grain", "nt", "backed", "hash", "fail", "det", "tr", "reset", "flag", "cert", "elt", "t", "len"]}}
{"project": "qemu", "commit_id": "fc89efe693278c79273f3bbf6b581e8a749c85b0", "target": 0, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    /* mvc and memmove do not behave the same when areas overlap! */\n\n    } else if ((dest < src) || (src + l < dest)) {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if ((dest + 8 <= src) || (src + 8 <= dest)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version with byte accesses which always work */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 1902, "substitutes": {"env": ["ager", "ec", "enh", "usr", "et", "net", "er", "code", "buf", "dt", "gear", "conn", "org", "init", "eh", "ev", "attr", "window", "erb", "vs", "server", "ah", "package", "ner", "vt", "viron", "cb", "environment", "ami", "esc", "nv", "pg", "msg", "qt", "him", "vp", "req", "loader", "dev", "ef", "config", "shell", "outer", "param", "vm", "desc", "vv", "context", "e", "w", "err", "en", "ctx", "con", "En", "gate", "EN", "manager", "ew", "v", "console", "h", "erd", "enter", "worker", "rc", "estate", "obj", "cmd", "Environment", "dn"], "l": ["ls", "d", "ul", "j", "lp", "le", "lr", "vl", "L", "list", "c", "size", "layer", "nl", "z", "p", "all", "g", "n", "sl", "r", "kl", "lt", "s", "li", "lo", " L", "m", "b", "x", "lit", "lb", "lock", "ll", "fl", "local", "level", "hl", "dl", "tl", "el", "al", "w", "e", "pl", "ln", "len", "loc", "v", "loop", "lin", "h", "ly", "cl", "o", "lu", "f", "lc", "lang", "t", "length", "ld"], "dest": ["mt", "cp", "parent", "usr", "tmp", "port", "p", "n", "route", "iter", "out", "gt", "sur", "output", "spec", "nom", "pas", "est", "mem", "d", "test", "comb", "source", "dep", "tif", "sort", "result", "np", "deg", "dist", "coord", "num", "nw", "it", "end", "trans", "ptr", "gate", "alt", "del", "loc", "remote", "nt", "tr", "th", "rel", "std", "Dest", "rest", "addr", "host", "to", "dc", "decl", "dat", "priv", "gen", "dev", "err", "home", "str", "wb", "go", "v", "target", "master", "ssl", "sp", "success", "proc", "temp", "prop", "nd", "r", "lit", "pos", "orig", "win", "them", "ser", "local", "desc", "w", "pl", "resource", "origin", "null", "good", "site", "st", "t", "slave", "obj", "pro"], "src": ["ctr", "usr", "tmp", "init", "nil", "iter", "set", "sc", "req", "sur", "sr", "spec", "comp", "ipp", "ind", "RC", "sb", "scan", "inner", "test", "source", "sv", "conv", "sort", "np", "dist", "rb", "inc", "tp", "iv", "sub", "trans", "ptr", "loc", "ident", "sel", "ins", "sq", "th", "rel", "sync", "supp", "std", "sn", "inst", "rest", "addr", "slice", "from", "sl", "SOURCE", "cur", "syn", "err", "tn", "rl", "str", "target", "rc", "sp", "pri", "sys", "input", "sec", "img", "attr", "r", "txt", "s", "url", "lit", "start", "cont", "orig", "filename", "ser", "desc", "resource", "origin", "via", "rt", "rs", "ebin", "in", "site", "st", "typ"], "i": ["multi", "j", "batch", "q", "id", "ii", "ki", "ji", " j", "is", "p", "sim", "wi", "n", "init", "xi", "ic", "pi", "index", "me", "qi", "ci", "li", "iter", "ami", "m", "ei", "b", "x", "u", "cli", "ui", "phi", "it", "gi", "ij", " ti", "ip", " ii", "y", " x", "im", "bi", "hi", "iu", "ti", "ie", " I", "ind", "io", "ix", "v", "zi", "in", "mi", "o", "ini", "di", "ai", "I", "si", "\u0438", "f", "ri", "t"]}}
{"project": "qemu", "commit_id": "ba0e276db4b51bd2255a5d5ff8902c70d32ade40", "target": 0, "func": "void helper_store_fpcr (uint64_t val)\n\n{\n\n#ifdef CONFIG_SOFTFLOAT\n\n    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);\n\n#endif\n\n    switch ((val >> 58) & 3) {\n\n    case 0:\n\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n\n        break;\n\n    case 1:\n\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n\n        break;\n\n    case 2:\n\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n\n        break;\n\n    case 3:\n\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n\n        break;\n\n    }\n\n}\n", "idx": 1905, "substitutes": {"val": ["data", " value", " aval", "vc", " ty", "l", "status", "item", "value", "buf", " arg", "V", "p", "Val", "cal", "ref", "kl", "pol", "vt", "vals", "b", "x", "tx", "num", "valid", "def", " tx", "VAL", "pr", " eval", "xy", "dev", " x", "el", "pl", " v", "eval", "v", "vol", "fee", "sel", "cl", "Value", "sol", "resp", "elt", "al"]}}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "func": "void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n", "idx": 1909, "substitutes": {"tcet": ["acel", "xcets", "ccets", "TCets", "acet", "tcel", "tcelist", "ccET", "xcET", "xcelist", "xcet", "ccet", "tcets", " tcelist", "TCet", "ccel", "acets", " tcET", " tcets", "TCET", "TCelist", " tcel", "acET", "tcET"], "bypass": ["byforce", "Bypass", "trypass", " bygrade", " byforce", "tryskip", "tryPass", "disableghost", "bableghost", "byPass", "nonforce", "byride", "Byghost", "disablePass", "aspass", " byswitch", "asPass", "byghost", "bygrade", "bablePass", "nonpass", "asswitch", "bablepass", "disablepass", "byskip", "disableride", "ByPass", "nonPass", " byskip", " byPass", "Byride", "asforce", "trygrade", "byswitch", "Byskip", "Bygrade", "nonswitch", "bableride"]}}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_wakeup_request(WakeupReason reason)\n\n{\n\n    if (!is_suspended) {\n\n        return;\n\n    }\n\n    if (!(wakeup_reason_mask & (1 << reason))) {\n\n        return;\n\n    }\n\n    runstate_set(RUN_STATE_RUNNING);\n\n    monitor_protocol_event(QEVENT_WAKEUP, NULL);\n\n    notifier_list_notify(&wakeup_notifiers, &reason);\n\n    reset_requested = 1;\n\n    qemu_notify_event();\n\n    is_suspended = false;\n\n}\n", "idx": 1917, "substitutes": {"reason": ["template", "number", "message", "Reason", "status", "size", "code", "cause", "value", "no", "mask", "component", "why", "description", "result", "index", "crit", "kind", "res", "condition", "need", "msg", "lock", "ASON", "request", "req", "reply", "type", "note", "connection", "block", "comment", "level", "command", "asons", "method", "cond", "name", " reasoning", "bid", "group", "category", "process", "IND", "flag", "reset", "thread", "state", "re", "because", "rule", "report", "cmd"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int rtsp_listen(AVFormatContext *s)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char proto[128], host[128], path[512], auth[128];\n\n    char uri[500];\n\n    int port;\n\n    int default_port = RTSP_DEFAULT_PORT;\n\n    char tcpname[500];\n\n    const char *lower_proto = \"tcp\";\n\n    unsigned char rbuf[4096];\n\n    unsigned char method[10];\n\n    int rbuflen = 0;\n\n    int ret;\n\n    enum RTSPMethod methodcode;\n\n\n\n    if (!rt->protocols) {\n\n        rt->protocols = ffurl_get_protocols(NULL, NULL);\n\n        if (!rt->protocols)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),\n\n                 &port, path, sizeof(path), s->filename);\n\n\n\n    /* ff_url_join. No authorization by now (NULL) */\n\n    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,\n\n                port, \"%s\", path);\n\n\n\n    if (!strcmp(proto, \"rtsps\")) {\n\n        lower_proto  = \"tls\";\n\n        default_port = RTSPS_DEFAULT_PORT;\n\n    }\n\n\n\n    if (port < 0)\n\n        port = default_port;\n\n\n\n    /* Create TCP connection */\n\n    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,\n\n                \"?listen&listen_timeout=%d\", rt->initial_timeout * 1000);\n\n\n\n    if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE,\n\n                         &s->interrupt_callback, NULL, rt->protocols)) {\n\n        av_log(s, AV_LOG_ERROR, \"Unable to open RTSP for listening\\n\");\n\n        return ret;\n\n    }\n\n    rt->state       = RTSP_STATE_IDLE;\n\n    rt->rtsp_hd_out = rt->rtsp_hd;\n\n    for (;;) { /* Wait for incoming RTSP messages */\n\n        ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen);\n\n        if (ret < 0)\n\n            return ret;\n\n        ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method,\n\n                                 sizeof(method), &methodcode);\n\n        if (ret) {\n\n            av_log(s, AV_LOG_ERROR, \"RTSP: Unexpected Command\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if (methodcode == ANNOUNCE) {\n\n            ret       = rtsp_read_announce(s);\n\n            rt->state = RTSP_STATE_PAUSED;\n\n        } else if (methodcode == OPTIONS) {\n\n            ret = rtsp_read_options(s);\n\n        } else if (methodcode == RECORD) {\n\n            ret = rtsp_read_record(s);\n\n            if (!ret)\n\n                return 0; // We are ready for streaming\n\n        } else if (methodcode == SETUP)\n\n            ret = rtsp_read_setup(s, host, uri);\n\n        if (ret) {\n\n            ffurl_close(rt->rtsp_hd);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1937, "substitutes": {"s": ["sys", "ls", "S", "south", "serv", "stats", "c", "sg", "is", "sv", "ss", "p", "es", "source", "n", "service", "vs", "r", "server", "ses", "set", "ds", "space", "fs", "aws", "ps", "its", "ex", "js", "ns", "sw", "sr", "conf", "w", "ms", "as", "ts", "cs", "ctx", "sm", "hs", "sts", "rs", "in", "h", "src", "gs", "f", "ats", "ins", "sb", "os", "sq", "args", "t", "socket", "a", "ssl"], "rt": ["mt", "vc", "rd", "art", "et", "ro", "dt", "vr", "tt", "rid", "hw", "r", "txt", "lt", "RT", "rect", "vt", "yt", "rb", "res", "rw", "ox", "tx", "kt", "ft", "gt", "etc", "tm", "ack", "rin", "bt", "opt", "sr", "rot", "rf", "ant", "rh", "apt", "rec", "fr", "rr", "rx", "rl", "adr", "reg", "dr", "rs", "rm", "nt", "irt", "te", "wt", "rc", "ot", "RW", "reflect", "t", "re", "NT", "ht", "rule", "cmd", "rn"], "proto": ["protno", "protTO", "protto", "rfrom", "priocol", "protfrom", "prito", "rto", "protco", "profrom", "rtp", "PROTO", "protname", "phyocol", "PROto", "Proco", "proo", "proco", "prto", "Proo", "proocol", "protp", "phyto", " propo", "PROco", "rocol", "PROocol", "prno", " proTO", "ProTO", " proocol", "PROpo", "protocol", "Proocol", "Proto", "protpo", "prifrom", "pritp", "proname", "Prono", " proname", "procol", "prottp", "propo", "proTO", "phyname", "prono", "pro"], "host": ["domain", "user", "phys", "Host", "addr", "handle", "room", "source", "height", "conn", "center", "bind", "service", "window", "index", "localhost", "server", "url", "gen", "hand", "subject", "ip", "http", "file", "hop", "context", "owner", "name", "origin", "home", "container", "loc", "null", "ha", "target", "client", "address", "h", "ost", "root", "src", "handler", "socket", "serv", "chain"], "path": ["data", "template", "id", "message", "test", "prop", "phrase", "format", "handle", "api", "Path", "text", "p", "route", "near", "query", "dir", "ath", "package", "url", "link", "password", "info", "history", "config", "transform", "ip", "file", "context", "pattern", "name", "alias", "resource", "loc", "address", "PATH", "handler", "prefix", "subject", "length", "cmd", "chain"], "auth": ["arch", "uth", "cp", "id", "user", "usr", "cas", "acl", "aux", "UTH", "phys", "addr", "api", "conn", "stat", "iam", "security", "attr", "ath", "url", "act", "password", "afi", "info", "priv", "token", "config", "ip", "http", "conf", "username", "Auth", "ctx", "pas", "author", "loc", "authent", "ha", "pass", "client", "hash", "h", "handler", "rc", "lang", "ac", "ssl", "cmd", "ht"], "uri": ["id", "usr", "user", "iri", "URI", "handle", "source", "service", "description", "ref", "dir", "url", "link", "i", "password", "ur", "ui", "info", "phi", "reason", "filename", "location", "connection", "ip", "http", "file", "username", "context", "command", " URI", "name", "resource", "origin", "ir", "remote", "address", "handler", "src", " ur", "ri", "pid", "prefix", "subject", "cmd"], "port": ["trust", "then", "cp", "interface", "trace", "format", "handle", "component", "p", "window", "localhost", "server", "proxy", "page", "duration", "time", "version", "ports", "line", "timeout", "socket", "number", "message", "eport", "count", "ile", "row", "export", "force", "policy", "it", "file", "rot", "ptr", "option", "remote", "padding", "position", "unit", "report", "length", "size", "slot", "index", "pi", "type", "connection", "priority", "scale", "client", "address", "date", "pid", "point", "len", "pport", "Port", "age", "public", "pc", "ORT", "limit", "import", "ip", "local", "ort", "print", "PORT", "peer", "state", "feature"], "tcpname": ["ktcpdomain", "Tcpnames", "tpno", "tmpnames", "ptprocnam", "Tmpno", "tpnames", "timpName", "tpName", " tpName", "tccnam", "tappName", "tappnam", "ktappnam", "tcpnam", "twpnames", "ptcpno", "tmpName", " tpnam", "ptcpname", "tprocno", "Tmpname", "Tcpno", "tappname", "ktappname", "ktcpname", "tcpName", " tcpnam", "ptprocno", "tmpdomain", "twpno", "timpname", "ptprocname", "tpname", "tprocName", "ktappdomain", "tpnam", "tappdomain", "twpname", "tmpno", "tccdomain", "tccname", "timpnames", " tcpName", "ptcpnam", "ptcpName", " tpnames", "ktcpnam", "tcpdomain", " tcpnames", "tprocname", "ktappName", "tprocnam", "TcpName", "ktcpName", "tcpno", "Tmpnames", "twpName", "tccName", "tcpnames", "tmpname", " tpname", "ptprocName", "timpnam", "TmpName", "Tcpname"], "lower_proto": ["lower_proot", "lower_proocol", "lower_transto", "lower_protocol", "lower_Probo", "lower_Proto", "lower_procto", "lower_prococol", "lower_protTo", "lower_transot", "lower_predo", "lower_transocol", "lower_procdo", "lower_Proocol", "lower_propTo", "lower_preocol", "lower_preto", "lower_probo", "lower_protto", "lower_ProTo", "lower_prebo", "lower_propto", "lower_procbo", "lower_Prodo", "lower_protot", "lower_propocol", "lower_propot", "lower_proTo", "lower_prodo"], "rbuf": ["erbff", "bbbuf", "buf", "erbuffy", "rabbuf", "rcbuf", "rbux", "rcuf", "erbbuf", "bbuff", "erbbuff", "rcuff", "rbuff", "robuf", "cbuf", "robuffy", "rcuffy", "rabuff", "rbbuff", "robuff", "rbff", "rbbuf", "cbbuf", "cbuff", "rabuffy", "erbuf", "bbuf", "rbuffy", "cbuffy", "rabuf", "bbux", "robbuff", "erbuff", "robbuf", "bff", "robff", "erbux", "cbux"], "method": ["proc", "message", "prop", "code", "format", "term", "service", "attr", "package", "Method", "url", "mid", "msg", "mod", "type", "METHOD", "man", "param", "command", "class", "handler", "rc", "timeout", "mem", "module", "cmd", "property"], "ret": ["success", "mt", "j", "id", "RET", "usr", "cat", "try", "il", "status", "dt", "ext", " RET", "fun", "result", "ref", "r", "after", "iter", "out", "url", "res", "lit", "ft", "new", "gt", "entry", "it", "def", "ll", "mem", "ber", "att", "Ret", "run", "reply", "at", "ure", "end", "err", "ort", "str", "alt", "ter", "rev", "print", "ry", "val", "rm", "rets", "pass", "nt", "arg", "hash", "det", "tr", "reset", "flag", "resp", "rem", "elt", "t", "re", "back", "len"], "methodcode": ["statuscode", "statusdesc", "methodno", "classcode", "classdesc", "classno", "methoddesc", "methodclass", "resultcode", "statusno", "resultno", "resultclass", "classclass", "statusclass", "resultdesc"]}}
{"project": "FFmpeg", "commit_id": "365ef88d5df4756942324b633cc439154e468276", "target": 1, "func": "int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,\n\n                            VLC *vlc, const float *level_table,\n\n                            const uint16_t *run_table, int version,\n\n                            WMACoef *ptr, int offset, int num_coefs,\n\n                            int block_len, int frame_len_bits,\n\n                            int coef_nb_bits)\n\n{\n\n    int code, level, sign;\n\n    const uint32_t *ilvl = (const uint32_t *) level_table;\n\n    uint32_t *iptr = (uint32_t *) ptr;\n\n    const unsigned int coef_mask = block_len - 1;\n\n    for (; offset < num_coefs; offset++) {\n\n        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);\n\n        if (code > 1) {\n\n            /** normal code */\n\n            offset                  += run_table[code];\n\n            sign                     = get_bits1(gb) - 1;\n\n            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;\n\n        } else if (code == 1) {\n\n            /** EOB */\n\n            break;\n\n        } else {\n\n            /** escape */\n\n            if (!version) {\n\n                level = get_bits(gb, coef_nb_bits);\n\n                /** NOTE: this is rather suboptimal. reading\n\n                 *  block_len_bits would be better */\n\n                offset += get_bits(gb, frame_len_bits);\n\n            } else {\n\n                level = ff_wma_get_large_val(gb);\n\n                /** escape decode */\n\n                if (get_bits1(gb)) {\n\n                    if (get_bits1(gb)) {\n\n                        if (get_bits1(gb)) {\n\n                            av_log(avctx, AV_LOG_ERROR,\n\n                                   \"broken escape sequence\\n\");\n\n                            return -1;\n\n                        } else\n\n                            offset += get_bits(gb, frame_len_bits) + 4;\n\n                    } else\n\n                        offset += get_bits(gb, 2) + 1;\n\n                }\n\n            }\n\n            sign                    = get_bits1(gb) - 1;\n\n            ptr[offset & coef_mask] = (level ^ sign) - sign;\n\n        }\n\n    }\n\n    /** NOTE: EOB can be omitted */\n\n    if (offset > num_coefs) {\n\n        av_log(avctx, AV_LOG_ERROR, \"overflow in spectral RLE, ignoring\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1945, "substitutes": {"avctx": ["AVcontext", "avctl", "vcontext", "avectx", "AVctl", "vrctx", "svcontext", "vtx", "avtx", "vrctl", "vrcmp", "avercontext", " avcfg", "afctx", "afctl", "AVcmp", "avercmp", "avecfg", "svcmp", "avercv", "avetx", " avtx", "svcv", " avcontext", "AVctx", "vctx", "avcv", "avcontext", "avecontext", "afcmp", "afcontext", "avcfg", "vrcontext", "svctx", "avcmp", "averctx", "AVcv", "vcfg"], "gb": ["Gb", "mb", "kb", "py", "bp", "td", "html", "pg", "eg", "gt", "hub", "vm", "goo", "bytes", "gs", "binary", "sb", "args", "asm", "vg", "bc", "pb", "deg", "cb", "rb", "yg", "phy", "storage", "bs", "gnu", "um", "ruby", "bg", "gc", "io", "range", "bn", "nb", "uf", "gh", "gin", "buf", "git", "bool", "csv", "gp", "gd", "ctx", "db", "fb", "bf", "gm", "ib", "ssl", "sp", "sys", "eb", "pc", "rg", "tg", "gif", "g", "img", "cfg", "rect", "lib", "b", "tm", "bb", "bt", "cv", "px", "bridge", "gom", "bits", "gz", "GB", "gg"], "vlc": ["tlt", "tlc", "tllc", "VLm", "plc", "wlci", "wlc", "flcs", "pllc", "flci", "VLlc", "flc", "tlcs", "wlt", "vlcs", "tll", "tlci", "plm", "VLl", "vlm", "vlt", "wlcs", "vll", "tlm", "flt", "vllc", "pll", "vlci", "VLc"], "level_table": ["level_free", "frame_free", "level_buffer", "levelNamecontainer", "level_container", "run_tab", "level_cache", "frame_container", "level2table", "frame_buffer", "frame_table", "level_list", "levelNametable", "level2free", "levelNamefree", "level_tab", "levelNamebuffer", "run_list", "level2buffer", "level2container", "run_cache"], "run_table": [" run___total", "run___tab", "run___list", " run___table", " run_list", "running_list", "running_table", "run2total", "running_total", "runlisttotal", "run_tab", "run2list", "runlistlist", "run___total", "run_tree", " run___list", "run2tab", "runingtotal", "run2table", " run_tab", "runlisttable", " run_total", "runninglisttree", "run_total", "runingtab", "run___table", "runingtree", "runninglisttable", "runlisttree", "runinglist", "run_list", "running_tree", "runninglisttotal", " run___tab", "runninglistlist", "runingtable"], "version": ["number", "grade", "message", "status", "size", "VERSION", "major", "index", "order", "package", "power", "mode", "Version", "server", "sequence", "condition", "supported", "family", "type", "time", "python", "vert", "ver", "support", "release", "v", "depth", "vers", "vision", "channel", "versions", "compatible", "sector", "current", "position", "flag", "point", "length", "vector", "feature"], "ptr": ["fp", "proc", "br", "alloc", "ctr", "eth", "lr", "arr", "buf", "pc", "addr", "vr", "attr", "ref", "pointers", "np", "pi", "bp", "rect", "pointer", "vt", "iter", "Ptr", "pos", "pad", "pr", "ps", "tp", "err", "ts", "ctx", "pl", "adr", "cut", "rt", "pt", "loc", "dr", "expr", "src", "inter", "tr", "bf", "elt", "inters", "ctrl", "pert"], "offset": ["id", "trace", "port", "unc", "ski", "order", "set", "path", "off", "output", "buffer", "scroll", "reset", "timeout", "batch", "number", "message", "key", "shift", "count", "next", "iterator", "row", "coord", "num", "at", "iso", "location", "outer", "end", "entity", "option", "alt", "loc", "range", "padding", "position", "sync", "length", "vector", "size", "addr", "mask", "slot", "to", "seek", "slice", "index", "pointer", "i", "unk", "type", "pad", "error", "attribute", "append", "onto", "address", "flag", "point", "prefix", "top", "et", "instance", "encrypted", "attr", "align", "table", "url", "pos", "start", "amount", "OFF", "command", "alias", "origin", "Offset", "cut", " seek", "o", "sector", "peer", "seed", "store", "base"], "num_coefs": ["num_coaffs", "num_coefes", "num_coeffS", "num_coafferences", "num_coefeds", "num_coefS", "num_coffS", "num_coafeds", "num_coafits", "num_coafes", "num_coffs", "num_coeferences", "num_coepS", "num_coffines", "num_coeceds", "num_coeffes", "num_coefits", "num_coeces", "num_coeffines", "num_coeffeds", "num_coaffines", "num_coepes", "num_coeps", "num_coeffs", "num_coafs", "num_coecits", "num_coecs", "num_coeffits", "num_coefines", "num_coffes", "num_cofferences", "num_coefferences"], "block_len": [" block_Len", "block_min", "frame_length", "frame_min", "block_Len", " block_length", "frame_len", "frame_fl", "block_size", "block_length", " block_size", "block_fl"], "frame_len_bits": ["frame_Len_bits", "frame_fin_its", "frame_len_its", "frame_fin_frames", "frame_len_frames", "frame_Len_its", "frame_Len_parts", "frame_Len_frames", "frame_fin_bits", "frame_fin_bytes", "frame_len_parts", "frame_len_bytes", "frame_Len_bytes"], "coef_nb_bits": ["coef_cb_bytes", "coef_cb_rows", "coef_nb2rows", "coef_nb3rows", "coef_nb2bytes", "coef_nb2bits", "coef_nb_its", "coef_nr_its", "coef_nb_rows", "coef_cb2rows", "coef_nbjbits", "coef_nb3bits", "coef_cb2bytes", "coef_nr_bytes", "coef_nb3bytes", "coef_nr_checks", "coef_nr_bits", "coef_nbjchecks", "coef_nbjbytes", "coef_nbjits", "coef_nb_checks", "coef_nb_bytes", "coef_cb_bits", "coef_cb2bits"], "code": ["success", "age", "cod", "id", "coe", "number", "cycle", "test", "key", "cd", "size", "status", "c", "pc", "count", "value", "sec", "n", "Code", "create", "index", "order", "result", "sequence", "change", "i", "close", "x", "condition", "page", "ce", "ne", "check", "cache", "scene", "type", "zip", "iso", "call", "ch", "comment", "ie", "e", "xxx", "xx", "error", "color", "len", "co", "go", "ode", "currency", "remote", "loc", "frame", "cc", "ice", "zone", "line", "length"], "level": ["id", "lvl", "le", "l", "test", "high", "status", "key", "limit", "cost", "cal", "index", "label", "fac", "kl", "change", "link", "lock", "pe", "info", "volume", "qual", "type", "Level", "variable", "scope", "tag", "local", "error", "color", "role", "levels", "pl", "len", "coll", "loc", "print", "scale", "val", "depth", "low", "vol", "vel", "max", "f", "line", "state", "stage", "length"], "sign": ["trust", "id", "ign", "step", "port", "significant", "change", "dig", "SIGN", "sum", "form", "lock", "sc", "ann", "spec", "round", "ind", "body", "alpha", "pres", "shift", "sort", "fix", "inc", "mod", "cmp", "shape", "tag", "sub", "Sign", "warn", "length", "min", "size", "mask", "style", "index", "sa", "rank", "close", "condition", "part", "type", "sw", "comment", "save", "diff", "err", "scale", "val", "sem", "se", "len", "add", "value", "r", "s", "kind", "score", "bit", "pack", "pos", "ig", "ser", "sd", "zone"], "ilvl": ["illvl", "inelwl", "ilkl", "ialvr", "illv", "inellv", "inelvl", "tillv", "illkl", "ilvr", "iolvp", "illwl", "iallv", "ilvp", "iolvl", "inelkl", "ialvl", "ialvp", "iollv", "illlv", "tilwl", "tilkl", "tilvp", "ilwl", "tilvr", "iolvr", "tilvl"], "iptr": ["iftrs", "esprt", "iftR", "astr", "iptn", "iftr", "iptR", "astR", "istrt", "iptrs", "istR", "astn", "inetn", "iftn", "astrt", "inetrs", "istn", "espr", "inetR", "iptrt", "espn", "espR", "inetr", "istr", "istrs"]}}
{"project": "FFmpeg", "commit_id": "9241cd2095fe8395e02be5556d657d06f65ba91f", "target": 0, "func": "int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,\n\n                         AVFilterInOut *open_inputs,\n\n                         AVFilterInOut *open_outputs, AVClass *log_ctx)\n\n{\n\n    int index = 0, ret;\n\n    char chr = 0;\n\n\n\n    AVFilterInOut *curr_inputs = NULL;\n\n\n\n    do {\n\n        AVFilterContext *filter;\n\n        filters += strspn(filters, WHITESPACES);\n\n\n\n        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if (filter->input_count == 1 && !curr_inputs && !index) {\n\n            /* First input can be omitted if it is \"[in]\" */\n\n            const char *tmp = \"[in]\";\n\n            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n                goto fail;\n\n        }\n\n\n\n        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        filters += strspn(filters, WHITESPACES);\n\n        chr = *filters++;\n\n\n\n        if (chr == ';' && curr_inputs) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",\n\n                   filters - 1);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        index++;\n\n    } while (chr == ',' || chr == ';');\n\n\n\n    if (chr) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",\n\n               filters - 1);\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {\n\n        /* Last output can be omitted if it is \"[out]\" */\n\n        const char *tmp = \"[out]\";\n\n        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail:\n\n    avfilter_graph_free(graph);\n\n    free_inout(open_inputs);\n\n    free_inout(open_outputs);\n\n    free_inout(curr_inputs);\n\n    return ret;\n\n}\n", "idx": 1946, "substitutes": {"graph": ["ograph", "Graph", "image", "parent", "document", "handle", "g", "widget", "window", "query", "node", "tree", "raph", "set", "path", "collection", "x", "pg", "cache", "zero", "network", "history", "config", "connection", "man", "script", "context", "pool", "connect", "h", "draw", "feed", "igraph", "subject", "map", "json", "self"], "filters": ["wallets", "giftered", "filterters", " filts", "butgers", " Filts", "buters", "waltering", "helters", "battons", " filers", "Filers", "buttered", "colters", "fifts", "FILizers", " filtered", "FILors", "filners", "Fillets", "FILtering", "fifmers", "filtereners", "filizers", "filtons", "filors", "butTER", "batters", "FILters", "FILTER", "filvers", "lifctions", "Filgers", "filtertered", "lifterms", "filmers", " filots", "colTER", "fungers", "waltered", "giftering", "filTER", "FILchers", "Filtered", "FILts", "lifts", " filgers", "walchers", "fifterms", "Filvers", "lifots", "FILners", "filers", "lifgers", "Filtons", "funtering", "heltering", " filterms", "FILlets", "filctions", "walers", "gifters", "fifters", "fileners", "miters", " Filizers", "liftering", "filts", "Filots", "Filters", "fifeners", "Filts", "filtering", "walners", " Filters", "mitters", "helts", "funtered", "FILtered", "mittons", "mitvers", "Filizers", " filmers", "Filchers", "funters", "buttering", "gifgers", "filots", "filchers", "filterterms", "Filners", "lifmers", "helctions", "fillets", "batvers", "butors", "filgers", "walters", " Filchers", "FILers", "lifters", "colors", "Filtering", "lifers", " fileners", "fiftered", "Filctions", "colers", "filterms", "filtered", "baters", "butters", "walts"], "open_inputs": ["open_controls", "open_inputums", "open_graphS", "open_streams", "open__outputS", "open_dirts", "open_outputsets", "open__inputxs", "open_contextxs", "open_contexts", "open_contextes", "open_inputed", "open_outputts", "open_configs", "open_interestxs", "open_inputts", "open_configts", "open_inputes", "open_streames", "open__outputxs", "open_outputums", "open_interestts", "open__inputts", "open_controled", "open_dirs", "open_dires", "open_configsets", "open_outputes", "open_outputed", "open_contextums", "open_outputS", "open_contextS", "open_outputxs", "open__outputs", "open_graphed", "open__outputts", "open__inputs", "open_interestS", "open_outputis", "open_interestums", "open_configes", "open_inputxs", "open_controlts", "open_streamis", "open_contextts", "open_contextis", "open_controlS", "open_dirsets", "open_interests", "open_inputS", "open_inputis", "open__inputS", "open_inputsets", "open_graphts", "open_graphs", "open_streamts"], "open_outputs": ["open_outputts", "open_pooles", "open_configs", "open_controls", "open_configes", "open_controlts", "open_periods", "open_inputts", "open_inputters", "open_inputties", "open_periodties", "open_periodes", "open_inputes", "open_controles", "open_configts", "open_periodts", "open_poolts", "open_outputes", "open_OutputS", "open_outputters", "open_inputS", "open_configties", "open_outputS", "open_hiddents", "open_outputties", "open_Outputs", "open_outputds", "open_hiddenS", "open_Outputes", "open_inputds", "open_Outputters", "open_pools", "open_Outputds", "open_hiddens", "open_Outputts", "open_poolters", "open_controlds", "open_hiddenes"], "log_ctx": [" log2gc", "logpttx", "note_pkg", "log2obj", "prop_gc", "log_pkg", "logtctx", "prop_tx", "link_sys", "logpycfg", "propttx", "logmycat", "LOG_jp", "proptconn", "loggrctx", "log2conn", "log_gc", "log_jp", "noteingpkg", "loglogctx", " log_context", "proptgc", "note_ctx", "log2gc", "logingpkg", "LOG_ctx", "noteinggz", "linkptctl", "note_kw", "logdconn", "link_cfg", "logtgc", "logpyobj", "logmyjp", "prop_ctx", " log_conn", "log_conn", "net_ctx", "logtconn", "logingkw", "loggrconn", "link_ctl", "loglogcontext", "log_kw", "log_gz", "logptctx", "logptcss", "log5pkg", "logingctx", "linkptsys", "log_cfg", "logttx", "logdcontext", "log2tx", "com_kt", " log2context", "LOG_pkg", "logptsys", "log5jp", "logloggc", "log_ctl", "logpyctl", "com_obj", "linkptctx", "LOG_cat", " log2ctx", "loggrcss", "net_tx", " log_tx", "loggrtx", "logpyctx", "note_gz", "logmyctx", "proptctx", "log5ctx", "com_ctx", "log_obj", "log_kt", " log2pkg", "net_conn", "linkptcfg", "com_context", "loglogpkg", "link_ctx", "noteingctx", " log_pkg", "logpysys", "noteingkw", "log5cat", "logdctx", "log_css", "logpycontext", "log_sys", " log_gc", "log2context", "log_tx", "logptconn", "log_context", "log2kt", "logmypkg", "logpykt", "logptcfg", "log2pkg", "loginggz", "log2ctx", "logptctl", "log_cat", "net_css", "logdtx", "prop_conn"], "ret": ["success", "mt", "RET", "net", "try", "status", "arr", "dt", "git", "addr", "conn", "fun", "tif", "ref", "result", "txt", "deg", "bool", "progress", "res", "ft", "cont", "flat", "gt", "ll", "def", "at", "mem", "att", "Ret", " Ret", "opt", "not", "tail", "desc", "err", "compl", "vet", "gc", "rt", "rev", "alt", "del", "reg", "print", "get", "val", "rm", "rets", "dr", "nt", "mat", "hash", "det", "rem", "reset", "tr", "cert", "resp", "elt", "arg", "re", "flag", "back", "len", "cmd"], "curr_inputs": ["curr_columnes", "curr_outputves", "curr_lookts", "curr_rawS", "curr_inputes", "curr_inputS", "curr_raws", "curr_dirs", "curr_lookries", "curr_subjects", "curr_poolves", "curr_outputs", "curr_columnS", "curr_graphts", "curr_inputles", "curr_columnts", "curr_columnves", "curr_subjectts", "curr_graph_", "curr_outputes", "curr_outputries", "curr_lookS", "curr_contextts", "curr_dirS", "curr_pools", "curr_poolts", "curr_input_", "curr_outputS", "curr_inputts", "curr_dirles", "curr_dirts", "curr_graphs", "curr_contextes", "curr_contextries", "curr_context_", "curr_outputles", "curr_inputries", "curr_graphS", "curr_contextles", "curr_inputves", "curr_contextS", "curr_rawes", "curr_contexts", "curr_outputts", "curr_looks", "curr_rawts", "curr_output_", "curr_graphes", "curr_columns", "curr_subjectS"], "filter": ["batch", "chain", "parent", "fil", "ff", "test", "op", "match", "format", "handle", "term", "p", "conv", "pipe", "init", "select", "sort", "query", "table", "link", "condition", "find", "profile", "flat", "check", "cache", "tf", "tag", "config", "transform", "file", "block", "cf", "context", "buffer", "attribute", "pkg", "cut", "process", "Filter", "channel", "hash", "handler", "root", "loop", "f", "json", "map", "cmd"], "tmp": ["proc", "batch", "input", "data", "fake", "test", "temp", "buf", "tt", "term", "pipe", "img", "attr", "result", "txt", "np", "node", "mp", "out", "table", "buff", "var", "params", "msg", "new", "cache", "snap", "cmp", "filename", "bt", "perm", "buffer", "err", "mk", "name", "ctx", "pkg", "dest", "alt", "nm", "dirty", "uv", "expr", "src", "stuff", "timeout", "prefix", "t", "obj", "split", "sp"], "index": ["success", "j", "id", "number", "image", "parent", "active", "key", "list", "status", "size", "count", "handle", "height", "slice", "n", "row", "read", "order", "iter", "open", "out", "node", "set", "i", "x", "condition", "num", "page", "pos", "start", "connected", "connection", "location", "end", "version", "level", "error", "context", "buffer", "search", "name", "ctx", "ion", "ind", "offset", "ix", "depth", "connect", "loop", "hash", "address", "max", "position", "seed", "timeout", "state", "Index", "length"]}}
{"project": "qemu", "commit_id": "6b9b8758c15f3bc2875dbd6e2d03c5362b8d6902", "target": 0, "func": "static int virtio_net_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    int i;\n\n\n\n    /* This will stop vhost backend if appropriate. */\n\n    virtio_net_set_status(vdev, 0);\n\n\n\n    unregister_savevm(qdev, \"virtio-net\", n);\n\n\n\n    if (n->netclient_name) {\n\n        g_free(n->netclient_name);\n\n        n->netclient_name = NULL;\n\n    }\n\n    if (n->netclient_type) {\n\n        g_free(n->netclient_type);\n\n        n->netclient_type = NULL;\n\n    }\n\n\n\n    g_free(n->mac_table.macs);\n\n    g_free(n->vlans);\n\n\n\n    for (i = 0; i < n->max_queues; i++) {\n\n        VirtIONetQueue *q = &n->vqs[i];\n\n        NetClientState *nc = qemu_get_subqueue(n->nic, i);\n\n\n\n        qemu_purge_queued_packets(nc);\n\n\n\n        if (q->tx_timer) {\n\n            timer_del(q->tx_timer);\n\n            timer_free(q->tx_timer);\n\n        } else {\n\n            qemu_bh_delete(q->tx_bh);\n\n        }\n\n    }\n\n\n\n    g_free(n->vqs);\n\n    qemu_del_nic(n->nic);\n\n    virtio_cleanup(vdev);\n\n\n\n    return 0;\n\n}\n", "idx": 1981, "substitutes": {"qdev": ["qqDEV", "vDEV", "eqpay", "dqpro", "vdevice", "qudev", "sqval", "iqev", "iqcam", "sqev", "iqdevice", "dqblock", "qval", "dqval", "iqdev", "qblock", "qDev", "dqpay", "qupay", "qqDev", "qpay", "qDEV", "qtblock", "vDev", "qtev", "qcam", "Qev", "qpro", " qcam", "sqblock", "qqdev", "Qcam", "qev", "dqev", "qupro", "Qdevice", "dqdev", "Qdev", "eqpro", " qdevice", "dqdevice", "qtdev", "eqdev", "qtval", "qqdevice", " qev", " qDEV", "sqdev", "qudevice", " qDev", "qdevice", "eqdevice"], "n": ["gn", "j", "number", "net", "l", "nb", "c", "no", "non", "cn", "N", "conn", "nl", "p", "g", "ren", "all", "init", "z", "np", "node", "names", "ng", "out", "nah", "comm", "m", "nv", "b", "num", "ne", "nw", "none", "new", "ll", "nan", "network", "ns", "note", "conf", "local", "y", "general", "normal", "w", "en", "name", "nav", "tn", "ln", "nm", "mn", "an", "v", "on", "nt", "h", "ct", "dn", "nu", "norm", "f", "wn", "nn", "na", "fn", "nor", "t", "obj", "a", "sn"], "vdev": [" vdes", "svde", "vdevice", "vserv", "wev", " vdevice", "wdevice", " vev", "vev", "vcdev", "Vdef", "dde", " vdis", "vcdis", "Vdev", "vcdef", "Vdis", " vgo", "vde", "vdis", "dev", " vde", "svdev", "dserv", "wdev", "qev", "svserv", "wgo", "qgo", "Vdes", "svev", " vserv", "vgo", "vdes", "ddev", "vcdes", " vdef", "qdevice", "vdef"], "i": ["id", "c", "p", "init", "li", "x", "us", " ti", "iu", "ti", "ind", "ix", "zi", " count", "ini", "I", "my", " bi", "batch", "key", " j", "xi", "ic", "qi", "m", "ui", "it", "ex", " status", "im", " v", " li", "\u0438", " err", "ri", "chain", "j", " m", "l", "ii", " mi", "ji", "pi", "asi", "me", "index", "ci", "ei", "info", "phi", "ij", " ii", "y", " pi", "bi", "hi", " I", "v", " ni", "mi", "di", "ai", "si", "multi", "ki", "is", "sim", "gi", " pos", " si", "ip", " my", " iter", "print", "in", "o", " multi", "t"], "q": ["ql", "j", "cp", "iq", "c", "qq", "z", "p", "g", "quest", "query", "qi", "qa", "pp", "comm", "ue", "qs", "x", "qt", "check", "it", "aq", "req", "qu", "dq", "requ", "Q", "conf", "ch", "k", "cf", "w", "quit", "pkg", "que", "eq", "queue", "v", "ry", "ve", "ck", "sq", "quant", "cmd"], "nc": ["ec", "vc", "isc", "NC", "c", "pc", "xc", "bc", "cn", "nl", "unc", "dc", "ic", "np", "ng", "nv", "ne", "qt", "yn", "ns", "tc", "cv", "cs", "ctx", "nic", "gc", "anc", "mn", "cc", "nt", "nz", "ct", "nn", "nec", "enc", "mc", "rn", "sn"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n", "idx": 1983, "substitutes": {"dest": ["proc", "sys", "d", "usr", "test", "Dest", "temp", "prop", "rest", "host", "port", "source", "sort", "result", "window", "way", "deg", "out", "dist", "decl", "coord", "dat", "msg", "orig", "new", "cont", "priv", "req", "foreign", "gen", "dev", "sur", "transform", "trans", "desc", "w", "ptr", "pl", "spec", "origin", "nom", "pas", "gate", "global", "v", "null", "target", "nt", "good", "est", "tr", "st", "gov", "master", "chain"], "src": ["proc", "sys", "input", "inst", "usr", "stack", "inner", "cp", "try", "func", "tmp", "phys", "rest", "addr", "source", "sec", "conv", "sv", "img", "attr", "txt", "s", "dist", "lib", "lat", "load", "msg", "start", "sc", "orig", "cont", "cur", "gt", "req", "gen", "syn", "iv", "ser", "sub", "sr", "http", "trans", "ptr", "copy", "spec", "comp", "origin", "via", "rl", "pkg", "rt", "loc", "rs", "in", "target", "cc", "uv", "rc", "sb", "st", "seed", "sq", "scan", "rel", "th", "obj", "sync", "warn", "std", "supp"], "size": ["south", "number", "message", "c", "format", "count", "sh", "gravity", "style", "g", "n", "sort", "window", "pi", "s", "mode", "send", "m", "small", "sum", "ui", "weight", "shape", "type", "network", "scope", "length", "dimension", "SIZE", "context", "offset", "ize", "v", "scale", "empty", "group", "sp", "fee", "si", "dim", "zone", "state", "sync", "len", "capacity", "Size", "sn"], "u": ["ul", "d", "l", "ut", "c", "uni", "p", "g", "edu", "fu", "ue", "i", "us", "ui", "su", "ou", "mu", "eu", "gu", "k", "w", "iu", "unic", "uid", "uri", "U", "tu", "uu", "v", "cu", "o", "uv", "nu", "du", "lu", "uci", "t"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_create_branch(BDRVSheepdogState *s)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid;\n\n    char *buf;\n\n\n\n    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,\n\n                      SD_INODE_SIZE, 0, s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n\n\n    s->is_snapshot = false;\n\n    ret = 0;\n\n    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);\n\n\n\nout:\n\n    g_free(buf);\n\n\n\n    return ret;\n\n}\n", "idx": 1990, "substitutes": {"s": ["ls", "c", "p", "es", "n", "ses", "set", "gets", "services", "its", "conf", "cs", "spec", "ies", "events", "an", "h", "gs", "sb", "os", "so", "a", "serv", "south", "stats", "sand", "sv", "source", "settings", "details", "ds", "qs", "less", "ex", "bs", "ims", "bis", "sam", "ties", "hs", "sts", "ins", "states", "sq", "S", "l", "ss", "als", "comm", "https", "ns", "sw", "ms", "ts", "changes", "v", "se", "ops", "sys", "is", "g", "b", "fs", "aws", "ps", "parts", "js", "orders", "as", "sm", "rs", "ats", "st", "state"], "ret": ["mt", "usr", "RET", "try", "port", "out", "gt", " fut", " Ret", "opt", "got", "pas", "backed", "rm", "done", "f", "reset", "re", "result", "deg", "sat", "ll", "it", "at", "Ret", "fl", "final", "gc", "alt", "del", "rev", "ter", "nt", " alt", "cert", "tr", "elt", "not", "uf", "j", "git", "dt", "nl", " RET", "bool", "ref", "lt", "vt", "res", "plain", "tf", "att", "fi", "err", "ts", "tn", "val", "v", "rets", "det", "flag", "len", "inter", "cmd", "status", "Return", "after", "r", "rect", "fin", "lit", "ft", "red", "cont", "over", "def", "tor", "bt", "nat", "rt", "ben", "print", "ct", "t"], "fd": ["fp", "d", "rd", "id", "fc", "ff", "cd", "func", "dt", "addr", "handle", "port", "bd", "conn", "dd", "fa", "dir", "fat", "pointer", "ds", "dig", "cb", "td", "dat", "lf", "fin", "fed", "fs", "ft", "gd", "af", "kt", "fl", "writer", "fi", "cf", "hd", "disk", "ptr", "dl", "buffer", "sd", "df", "fe", "fr", "ctx", "ln", "fred", "db", "io", "ud", "fb", "gz", "handler", "f", "FD", "fn", "bf", "pid", "da", "elt", "fm", "uf", "ld"], "vid": ["doc", "feat", "vc", "id", "oid", "cod", "temp", " tid", "vis", "vo", "vr", "rid", "ref", "vt", " pid", " tv", "mid", "UID", " guid", "seq", "lan", "vp", "vi", "voc", "von", "virt", "tv", "cam", "ti", "ctx", " virt", "uid", " wid", " v", "rev", "sid", "bid", "VID", "v", "val", "vol", "fee", "uv", "wid", "pid", "kid", "vd", " vend", "len", " id"], "buf": ["doc", "br", "batch", "alloc", "data", "cp", "xff", "ff", "tmp", "alph", "bc", "port", "bd", "img", "window", "ref", "pb", "txt", "bp", "cb", "rb", "var", "b", "msg", "tab", "seq", "orig", "vec", "uf", "cap", "block", "cf", "buffer", "cv", "w", "ptr", "cam", "bag", "err", "ctx", "ob", "wb", "bin", "Buffer", "queue", "v", "bridge", "fb", "bytes", "gz", "f", "bf", "raw", "Buff", "mem", "map", "cmd", "buff"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994, "substitutes": {"dev": ["proc", "d", " device", "device", "ach", "conn", "p", "dep", "ev", "ow", "hw", "act", "md", "priv", "mem", "pad", "att", "cam", "w", "wd", "ver", "Device", "de", "go", "DEV", "or", "v", "od", "nt", "ad", "av", "os", "ac", "Dev", "serv", "dis", "pro"], "prop": ["doc", "proc", "property", "cp", "test", " props", "op", "sec", "term", "pri", "p", "attr", "cfg", "pos", "def", "priv", "pr", "ps", "conf", "Prop", "spec", "sty", "comp", "pkg", "pred", "pt", "or", "rop", " Prop", "col", "prev", "feat", "cmd", "pro"], "str": ["doc", "br", "ctr", "data", "list", "arr", "buf", "c", "p", "text", "txt", "Str", "r", "s", "out", "res", "b", "msg", "cont", "seq", "desc", "w", "err", "name", "fr", "spec", "STR", "ar", "vol", "sp", "f", "tr", "st", "raw", "enc", "chain"], "ptr": ["proc", "inst", "ctr", "eth", "arr", "buf", "jp", "addr", "handle", "sh", "p", "dep", "ref", "resh", "deg", "np", "index", "pointer", "dist", "Ptr", "pos", "dh", "pad", "pr", "ps", "tp", "t", "prime", "buffer", "ts", "ctx", "ind", "pt", "offset", "tr", "th", "rep", "rel", "obj", "inter", "pert", "sp"], "fmt": ["tfMT", "tfmt", "vMT", "Fprintf", "ftm", "gformat", "gMT", " fstr", "fformat", "vformat", "gstr", "fMT", " fMT", "Ftm", "tftm", "Fformat", "Fmt", "tfformat", "fstr", "gmt", " ftm", " fformat", "FMT", "vstr", "vmt"]}}
{"project": "FFmpeg", "commit_id": "2f76157eb05bf63725f96167feda6b2e07501c7e", "target": 1, "func": "av_cold int swri_rematrix_init(SwrContext *s){\n\n    int i, j;\n\n    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);\n\n    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    s->mix_any_f = NULL;\n\n\n\n    if (!s->rematrix_custom) {\n\n        int r = auto_matrix(s);\n\n        if (r)\n\n            return r;\n\n    }\n\n    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++) {\n\n            double rem = 0;\n\n\n\n            for (j = 0; j < nb_in; j++) {\n\n                double target = s->matrix[i][j] * 32768 + rem;\n\n                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);\n\n                rem += target - ((int*)s->native_matrix)[i * nb_in + j];\n\n            }\n\n        }\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s16;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float));\n\n        s->native_one    = av_mallocz(sizeof(float));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((float*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_float;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_float;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){\n\n        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(double));\n\n        if (!s->native_matrix || !s->native_one)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < nb_out; i++)\n\n            for (j = 0; j < nb_in; j++)\n\n                ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((double*)s->native_one) = 1.0;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_double;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_double;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n\n        // Only for dithering currently\n\n//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_one)\n\n            return AVERROR(ENOMEM);\n\n//         for (i = 0; i < nb_out; i++)\n\n//             for (j = 0; j < nb_in; j++)\n\n//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);\n\n    }else\n\n        av_assert0(0);\n\n    //FIXME quantize for integeres\n\n    for (i = 0; i < SWR_CH_MAX; i++) {\n\n        int ch_in=0;\n\n        for (j = 0; j < SWR_CH_MAX; j++) {\n\n            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);\n\n            if(s->matrix[i][j])\n\n                s->matrix_ch[i][++ch_in]= j;\n\n        }\n\n        s->matrix_ch[i][0]= ch_in;\n\n    }\n\n\n\n    if(HAVE_YASM && HAVE_MMX)\n\n        return swri_rematrix_init_x86(s);\n\n\n\n    return 0;\n\n}\n", "idx": 1998, "substitutes": {"s": ["ls", "erences", "c", "sg", "p", "es", "n", "ses", "set", "gets", "services", "its", "conf", "ports", "cs", "spec", "ains", "ies", "h", "gs", "args", "sb", "os", "a", "stats", "sv", "source", "settings", "vs", "details", "ers", "ds", "qs", "m", "ants", "less", "ex", "bs", "ims", "bis", "ties", "hs", "sts", "ins", "sq", "acs", "self", "S", "er", "ss", "als", "sl", "comm", "tes", "ns", "ms", "ts", "changes", "v", "tests", "se", "ops", "sys", "status", "is", "b", "fs", "aws", "ps", "parts", "js", "w", "as", "sports", "has", "rs", "in", "bits", "ats", "alls", "t"], "i": ["multi", "batch", "id", "ii", "ki", "status", "ji", "is", "p", "sim", "g", "n", "xi", "ic", "pi", "index", "asi", "me", "li", "out", "ci", "ami", "qi", "m", "ei", "b", "x", "u", "cli", "us", "ui", "info", "gi", "it", "phi", "ij", "ip", " ii", "y", "ims", "bi", "im", "ie", "hi", "iu", "ti", "ind", "uri", "ix", "ia", "v", "in", "zi", "mi", "h", "o", "ini", "di", "ai", "si", "I", "\u0438", "ik", "ri", "yi"], "j": ["jump", "br", "q", "key", "l", "jp", "ji", "dj", "bj", "c", "jit", "next", "z", "p", "uj", "aj", "g", "n", "kj", "out", "m", "b", "x", "other", "it", "ge", "J", "ij", "jl", "pr", "js", "note", "y", "ch", "k", "jo", "bi", "ie", "je", "jc", "fr", "oj", "ion", "str", "ind", "bo", "pt", "jet", "ja", "ix", "v", "vol", "o", "by", "obj", "jac", "jj", "json"]}}
{"project": "qemu", "commit_id": "1a0e4c8b02ea510508970c333ee610a90b921cbb", "target": 1, "func": "void s390_machine_reset(void)\n\n{\n\n    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));\n\n\n\n    qemu_devices_reset();\n\n    s390_cmma_reset();\n\n    s390_crypto_reset();\n\n\n\n    /* all cpus are stopped - configure and start the ipl cpu only */\n\n    s390_ipl_prepare_cpu(ipl_cpu);\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);\n\n}\n", "idx": 2009, "substitutes": {"ipl_cpu": ["cel____pu", "cel____coin", "ipl____pu", "fl_proc", "cel____cum", "pl_cu", "ipl____coin", "fl_pu", "ipl____cum", "cel____cpu", "ipl____cpu", "ipl_coin", "pl_pu", "ipl_cu", "cel_cpu", "pl_cpu", "ipl_process", "cel_pu", "fl_processor", "ipl_processor", "fl_cpu", "cel_coin", "ipl_pu", "ipl_proc", "ipl_cum", "cel_cum", "pl_process"]}}
{"project": "FFmpeg", "commit_id": "73f863d751df84db7a0ca1bd83cdff1b95dc94dd", "target": 1, "func": "static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n\n                            uint8_t *dst, int stride, int16_t *block)\n\n{\n\n    int i, num_coeff;\n\n\n\n    /* Is it a skip block? */\n\n    if (get_bits1(gb)) {\n\n        /* This is a P-frame. */\n\n        ctx->frame->key_frame = 0;\n\n        ctx->frame->pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        return 0;\n\n    }\n\n\n\n    memset(block, 0, sizeof(*block) * 64);\n\n\n\n    num_coeff = get_bits(gb, 7);\n\n    if (num_coeff > 64)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < num_coeff; i++)\n\n        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *\n\n                                     ctx->qmat[ff_zigzag_direct[i]];\n\n\n\n    fic_idct_put(dst, stride, block);\n\n\n\n    return 0;\n\n}\n", "idx": 2010, "substitutes": {"ctx": ["ka", "cp", "ctrl", "acl", "jp", "pc", "c", "xc", "bc", "nc", "tk", "conn", "dc", "hw", "ic", "ca", "cfg", "ci", "mc", "cb", "act", "tx", "kt", "tm", "req", "cmp", "ij", "kw", "ctl", "conf", "cf", "cv", "context", "setup", "mk", "xp", "cam", "pkg", "anc", "gc", "loc", "abc", "cu", "cc", " cx", "wx", "ct", "cmd", "cm", "Context", "ck", "ac", "iat", "exec", "tc", "jac", "obj"], "gb": ["Gb", "mb", "eb", "rg", "vg", "bc", "tg", "bd", "kb", "gif", "g", "erb", "pb", "cfg", "cb", "rb", "yg", "gy", "pg", "gd", "eg", "gt", "bb", "bt", "bs", "gu", "bg", "gc", "wb", "db", "fb", "bridge", "gs", "GB", "sb", "gow", "bf", "gg", "gm", "nb", "ib", "uf", "gh"], "dst": [" ddest", "stend", "stsrc", "dsdest", " Dst", "Ddest", "ddest", "Dest", "dsest", " Dsrc", "sthost", "dend", "dhost", " Dend", " dsrc", "dsst", " dest", " dhost", "dsrc", "dest", "Dst", "dssrc", "stst", "Dsrc", " Dhost", " dend"], "stride": ["Strime", " strension", "styleension", "strided", "strension", "styleided", "styleride", "windowension", " strine", "sline", "Strides", " strime", "Stride", " strides", " strride", "slides", " strided", "strine", "Strine", "windowided", "windowride", "strides", "slime", "strime", "strride", "windowide", "styleide", "slide"], "block": ["Block", "data", "chain", "image", "batch", "q", "list", "word", "buf", "object", "mask", "view", "bc", "p", "row", "ref", "BL", "box", "node", "out", "set", "link", "bit", "b", "x", "pack", "pixel", "load", "lock", "check", "def", "ack", "type", "snap", "config", "ip", "k", "buffer", "bin", "array", "bo", "group", "frame", "blocks", "bl", "hash", "field", "cl", "line", "mem", "obj", "sync", "join", "map", "self", "byte"], "i": ["multi", "j", "id", "l", "ii", "ki", "iq", " mi", "c", " j", "ji", "status", "is", "p", "sim", "g", "init", "xi", "pi", "asi", "me", "index", "qi", "ci", "li", "ami", "m", "ei", "x", "cli", "ui", "info", "phi", "it", "gi", "ij", " ti", "ip", " ii", "gu", "y", " pi", "bi", "im", "hi", "iu", "ti", "span", "ind", "uri", "ix", "v", "in", "zi", " ni", "mi", "di", "ini", "o", "\u0438", "ai", "I", "si", "ri", "t", "yi", "this", " bi"], "num_coeff": ["num_Coef", "num_locefficient", "num_coefficients", "num_locff", "num_COff", "num_Coefficients", "num2coffe", "num2Coeff", "num2Coffe", "num2coef", "num2Coefficient", "num2Coff", "num2coff", "num_cosefficient", "num_coffe", "num_COefficients", "num_cosefficients", "num_COeff", "num_coff", "num_Coff", "num2coeff", "num2Coef", "num_Coefficient", "num_COefficient", "num_loceff", "num2coefficient", "num_COef", "num_coefficient", "num_Coffe", "num_cosef", "num_coef", "num_Coeff", "num_locffe", "num_coseff"]}}
{"project": "FFmpeg", "commit_id": "604c9b1196c70d79bbbc1f23e75f6a8253a74da3", "target": 1, "func": "void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)\n\n                        ff_rtsp_tcp_write_packet(s, rtsp_st);\n\n                    avio_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    avio_close(rtpctx->pb);\n\n                }\n\n                avformat_free_context(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n\n                ff_rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            ffurl_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}\n", "idx": 2027, "substitutes": {"s": ["sys", "ls", "S", "stats", "c", "is", "sv", "ss", "p", "es", "settings", "n", "init", "times", "r", "xs", "set", "ds", "ops", "m", "b", "fs", "less", "aws", "ps", "its", "js", "ns", "bs", "conf", "w", "e", "ms", "ts", "cs", "spec", "sports", "hs", "has", "sts", "rs", "gs", "ats", "sb", "st", "sq", "os", "t", "ssl", "self"], "send_packets": ["send_packsodes", "send_pageset", "send_packageset", "send_packet", "send_packset", "sendablepacksodes", "send_pagesETS", "send_payets", "send_payet", "sendablepacksets", "send_packsets", "send_packsETS", "send_payorts", "sendablepacksETS", "send_packETS", "send_pagesets", "sendablepackets", "send_packagesets", "send_packorts", "sendablepackETS", "send_packagesETS", "send_messodes", "send_payETS", "sendablepacket", "sendablepackset", "send_messet", "send_packodes", "send_packsorts", "send_pagesodes", "send_packagesorts", "send_messets", "sendablepackodes", "send_messETS"], "rt": ["mt", "vc", "rd", "aux", "art", "net", "et", "tmp", "dt", "ro", "vr", "tt", "trak", "r", "txt", "RT", "rect", "vt", "rb", "rw", "lat", "ox", "tx", "kt", "gt", "it", "tm", "req", "ack", "rin", "boot", "tp", "bt", "rage", "rot", "rf", "hd", "rh", "apt", "rec", "ctx", "rr", "rx", "rl", "pt", "dr", "rs", "nt", "irt", "ret", "wt", "tr", "ot", "st", "rc", "rn", "t", "feat", "NT", "cmd", "ht"], "i": ["multi", "batch", "j", "id", "ki", "ii", " mi", "c", " j", "ji", "port", "p", "sim", "n", "xi", "ic", "pi", "index", "qi", "me", "li", "ci", "out", "m", "x", "u", "us", "ui", "phi", "it", "gi", "ij", " si", " ti", "ip", " ii", "oi", "y", " pi", "fi", "ims", "bi", "im", "hi", "iu", "ti", "name", " I", " iter", "ind", "go", " li", "ix", "print", "v", "in", "client", " ni", "o", "mi", "ini", "di", "ai", "I", "si", " multi", "t", " bi"], "rtsp_st": ["rtsp____st", "rtspid_dist", "rtssp_st", "rtsp_tmp", "rtsp0sh", "rtsp__st", "rtsp3str", "rtspknt", "rtsp_dest", "rtsppystream", "rtspeak_stan", "rtsh_obj", "rtspkstone", "rtsp___st", "rtsp_stream", "rtsmppyobj", "rtsh_st", "rtsp7st", "rtsppyobj", "rtspn_stri", "rtsp_ST", "rtspn0nt", "rtsmppytmp", "rtscp_ST", "rtsmp_st", "rtsp0sw", "rtspn_st", "rtspn0st", "rtspkstatus", "rtsp_status", "rtsmp_stream", "rtspksth", "rtspn_sh", "rtsp__obj", "rtssp_sty", "rtsmp_tmp", "rtsping_dest", "rtsp7stan", "rtsp_stri", "rtssp____rest", "rtspn0sw", "rtspn0sh", "rtsp___stream", "rtspid_ct", "rtspn_str", "rtspn_stable", "rtspjste", "rtsp7ST", "rtsp_sty", "rtsp__stream", "rtsh_str", "rtsp_stable", "rtssp____int", "rtsp_sw", "rtspkstan", "rtsp_stone", "rtsmppystream", "rtsp_rest", "rtscp_st", "rtsppyst", "rtspn_end", "rtspc_st", "rtsp0nt", "rtsp3st", "rtspn_std", "rtspid_st", "rtsp_ct", "rtsp___tmp", "rtspn_sw", "rtsp_stan", "rtsp_inst", "rtsprenth", "rtsp7est", "rtsp___obj", "rtssp_rest", "rtssp____sty", "rtsping_st", "rtsp_th", "rtsp_est", "rtscp_stan", "rtspeak_sth", "rtsp____rest", "rtspkstable", "rtsp__tmp", "rtsprenct", "rtssp_int", "rtspjst", "rtsp____int", "rtsp_nt", "rtsp_obj", "rtsp_str", "rtsping_str", "rtspkste", "rtsmp_obj", "rtsprendist", "rtsppytmp", "rtspjstri", "rtspkstri", "rtsp0st", "rtsp3dest", "rtsp_int", "rtssp____st", "rtspid_th", "rtspc_ste", "rtspkst", "rtspn_nt", "rtsp3inst", "rtsp_end", "rtspeak_stone", "rtsp_dist", "rtsmppyst", "rtspeak_st", "rtsprenst", "rtsp____sty", "rtspjstatus", "rtspc_status", "rtsping_inst", "rtscp_est", "rtsp_std", "rtsp_sh", "rtspc_stri", "rtsp_sth", "rtsp_ste"], "rtpctx": ["rtlpctx", "rtphvals", "rtlpcas", "rtpatchctx", "irtvpcoll", "randpactx", "rxpingvals", "mitplc", "randpctx", "rxpingtimeout", "rxpingcu", "rtvpcache", "rtlpcoll", "rtphtimeout", "rtjpcv", "rxpvals", "ritpyconf", "rtjpfw", "rtpnvals", "rtpingbc", "rtpcache", "irtpctx", "irtvploc", "rtpconf", "mitpcv", "iterpcmd", "rtvploc", "iterpactx", "rtpnp", "rtpatchcache", "rtparc", "rtlpcmd", "rtpibc", "mitpictx", "irtvpctx", "rtpcas", "mitpifw", "rtvpfw", "mitpilc", "iterpcas", "rtjpctx", "mitpicv", "rtpacmd", "rtpatchloc", "ritpctx", "iterpctx", "ritpbc", "irtpcache", "rtploc", "rtpatimeout", "rtlptimeout", "rtpbc", "rxpingctx", "rtpingnp", "randpacoll", "rtplc", "rtpynp", "irtvpcache", "rtphctx", "ritpnp", "rtpacoll", "randpahandler", "rtpiconf", "rtpcmd", "rxpctx", "rtphcu", "rtpaircache", "rtpyconf", "rtpairctx", "rtpinp", "rtpahandler", "randptimeout", "iterparc", "rtvpctx", "randpatimeout", "iterpacmd", "rtpingconf", "rtpairloc", "rtpingvals", "rtpactx", "rtjphandler", "rxpcu", "rtpncu", "rtpybc", "ritpybc", "randphandler", "rtjpcoll", "rtprc", "irtploc", "rtpingctx", "ritpconf", "irtpcoll", "rtvpcoll", "iterpacas", "rtlphandler", "rtpicv", "rtpingtimeout", "rtpyctx", "rtpilc", "rtphandler", "rtpbrc", "rtpntimeout", "rtpacas", "rtpifw", "rtpcv", "rtpfw", "rtjptimeout", "rxptimeout", "mitpfw", "rtjplc", "rtlprc", "randpcoll", "rtpaircoll", "rtpbcas", "rtvpcv", "rtpictx", "mitpctx", "rtpcu", "rtpvals", "rtpatchcoll", "rtpnctx", "rtptimeout", "rtpbctx", "iterprc", "rtvplc", "rtpbcmd", "ritpyctx", "ritpynp", "rtpcoll", "rtpingcu"], "ptr": ["proc", "fp", "alloc", "ctr", "tmp", "arr", "buf", "pc", "addr", "port", "p", "row", "ref", "pb", "pointers", "iter", "pointer", "inters", "td", "var", "Ptr", "tx", "dh", "pad", "pr", "ps", "dev", "vec", "buffer", "ts", "ctx", "fr", "pl", "adr", "ped", "pt", "fd", "dr", "address", "src", "tr", "ck", "mem", "obj", "inter", "sp"]}}
{"project": "qemu", "commit_id": "64c9bc181fc78275596649f591302d72df2d3071", "target": 0, "func": "static void do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n\n\n    assert(p->ep->nr == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            usb_device_handle_control(s, p, request, value, index,\n\n                                      s->setup_len, s->data_buf);\n\n            if (p->status == USB_RET_ASYNC) {\n\n                return;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            p->actual_length = 0;\n\n        }\n\n        break;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len) {\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            }\n\n            return;\n\n        }\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n\n\n    default:\n\n        p->status = USB_RET_STALL;\n\n    }\n\n}\n", "idx": 2047, "substitutes": {"s": ["ls", "c", "es", "n", "ses", "set", "gets", "its", "state", "http", "conf", "ports", "cs", "spec", "ies", "h", "gs", "sb", "os", "a", "south", "stats", "sv", "vs", "details", "xs", "ds", "qs", "m", "full", "less", "bs", "tags", "ims", "bis", "bes", "hs", "sts", "ins", "states", "ys", "self", "S", "l", "er", "ss", "als", "comm", "i", "https", "ns", "sw", "y", "ms", "ts", "changes", "tests", "se", "ops", "ssl", "sp", "sys", "is", "g", "r", "b", "fs", "aws", "ps", "parts", "js", "browser", "local", "comments", "as", "sports", "rs", "bits", "ats", "st", "t"], "p": ["fp", "php", "d", "cp", "j", "q", "wp", "lp", "pro", "op", "jp", "pc", "c", "port", "up", "g", "tip", "pm", "P", "pb", "np", "bp", "pi", "pp", "mp", "app", "r", "patch", "gp", "m", "i", "b", "x", "vp", "it", "at", "ps", "tp", "ip", "y", "pa", "local", "w", "ap", "pkg", "post", "v", "pre", "o", "h", "dp", "f", "peer", "resp", "point", "t", "rep", "ping", "sp"], "request": ["input", "q", "message", "hello", "seek", "quest", "QUEST", "query", "child", "claim", "package", "order", "read", "set", "change", "task", "rate", "question", "condition", "access", "req", "reason", "time", "requ", "call", "version", "buffer", "command", "response", "method", "reference", "each", "Request", "get", "bid", "frame", "address", "event", "position", "reset", "point", "prefix", "push", "cmd"], "value": ["success", "data", "values", "number", "message", "test", "hello", "ceive", "status", "operator", "multiple", "result", "create", "ue", "set", "action", "change", "see", "volume", "variable", "VALUE", "update", "version", "save", "buffer", "command", "attribute", "response", "function", "example", "get", "val", "v", "address", "current", "ve", "position", "Value", "length", "vector"], "index": ["success", "data", "id", "input", "number", "then", "key", "size", "status", "code", "seek", "row", "ref", "query", "order", "set", "link", "i", "condition", "num", "find", "pos", "info", "zero", "axis", "location", "end", "update", "error", "context", "ion", "ind", "author", "loc", "offset", "val", "connect", "address", "position", "timeout", "point", "prefix", "Index", "length"]}}
{"project": "FFmpeg", "commit_id": "f566ac48ce450b013ffd5547ace48df8c47981c6", "target": 0, "func": "static int get_video_buffer(AVFrame *frame, int align)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n\n    int ret, i;\n\n\n\n    if (!desc)\n\n        return AVERROR(EINVAL);\n\n\n\n    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if (!frame->linesize[0]) {\n\n        ret = av_image_fill_linesizes(frame->linesize, frame->format,\n\n                                      frame->width);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        for (i = 0; i < 4 && frame->linesize[i]; i++)\n\n            frame->linesize[i] = FFALIGN(frame->linesize[i], align);\n\n    }\n\n\n\n    for (i = 0; i < 4 && frame->linesize[i]; i++) {\n\n        int h = FFALIGN(frame->height, 32);\n\n        if (i == 1 || i == 2)\n\n            h = -((-h) >> desc->log2_chroma_h);\n\n\n\n        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);\n\n        if (!frame->buf[i])\n\n            goto fail;\n\n\n\n        frame->data[i] = frame->buf[i]->data;\n\n    }\n\n    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {\n\n        av_buffer_unref(&frame->buf[1]);\n\n        frame->buf[1] = av_buffer_alloc(1024);\n\n        if (!frame->buf[1])\n\n            goto fail;\n\n        frame->data[1] = frame->buf[1]->data;\n\n    }\n\n\n\n    frame->extended_data = frame->data;\n\n\n\n    return 0;\n\nfail:\n\n    av_frame_unref(frame);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 2049, "substitutes": {"frame": ["trace", "format", "step", "component", "window", "node", "page", "load", "rame", "form", "request", "req", "version", "cf", "cast", "response", "comp", "ind", "console", "wrapper", "channel", "f", "line", "fw", "ma", "message", "frames", "list", "next", "row", "session", "result", "sequence", "ox", "force", "ce", "msg", "picture", "movie", "file", "name", "remote", "range", " timeframe", "self", "ace", "word", "code", "flow", "view", "style", "to", "sample", "ref", "Frame", "pty", "send", "header", "close", "part", "info", "scene", "iframe", "shot", "call", "block", "error", "update", "fr", "one", "fb", "process", "draw", "point", "cmd", "proc", "doc", "data", "image", "cycle", "face", "instance", "term", "table", "profile", "def", "scope", "ie", "e", "role", "show", "video", "event", "zone", "state", "feat", "stage", "base", "module", "feature"], "align": ["xff", "add", "l", "size", "ign", "format", "cal", "adjust", "rac", "label", "box", "aligned", "hold", "coord", "aff", "form", "cmp", "pad", "snap", "rot", " alignment", "len", "margin", "offset", "angle", "in", "padding", "rel", "equal", "col", "ac", "al", "join", "length"], "desc": ["doc", "pres", "cor", "DES", "ec", "proc", "buf", "ext", "sec", "dep", "img", "description", "ref", "ca", "txt", "rib", "Desc", "crit", "dist", "ds", "asc", "esc", "res", "cont", " des", "sc", "seq", "def", "info", "req", "cmp", "ack", "md", "dev", "vec", "sub", "comment", "msg", "der", "cam", "diff", "rec", "name", "comp", "de", "nz", "disc", "col", "rc", "des", "enc", "feat", "obj", "cmd"], "ret": ["success", "mt", "j", "RET", "aux", "net", "l", "try", "status", "il", "arr", "nl", "limit", "conv", "ref", "result", "r", "read", "iter", "progress", "out", "deg", "res", "lit", "ft", "ne", "cont", "red", "gt", "ll", "it", "def", "att", "Ret", "t", " Ret", "ort", "round", "gc", "alt", "rt", "re", "reg", "get", "print", "ry", "val", "v", "rets", "pret", "nt", "rel", "cmd", "det", "rem", "reset", "tr", "resp", "elt", "al", "mem", "len", "inter"], "i": ["id", "try", "ori", "p", "init", "n", "iter", "li", "set", "x", "iu", "ti", "span", "ir", "ind", "uri", "ix", "zi", "h", "ini", "I", "batch", "q", "inner", "key", "xi", "ic", "qi", "m", "u", "ui", "it", "ims", "im", "name", "io", "remote", "\u0438", "ri", "chain", "j", "l", "ii", "iri", "er", "ji", "pi", "index", "me", "ci", "ei", "info", "phi", "ij", "fi", "y", "bi", "hi", "v", "loop", "mi", "di", "ai", "si", "multi", "ki", "status", "is", "sim", "g", "cli", "gi", "ip", "oi", "ie", "dr", "in", "t"]}}
{"project": "qemu", "commit_id": "1eabfce6d53cb02066dbb0ac8471f8593ff24a24", "target": 0, "func": "static int kvm_get_msrs(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n\n    int ret, i;\n\n    uint64_t mtrr_top_bits;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n\n    }\n\n    if (has_msr_tsc_deadline) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n\n    }\n\n    if (has_msr_feature_control) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n\n    }\n\n\n\n\n\n    if (!env->tsc_valid) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n\n        env->tsc_valid = !runstate_is_running();\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n\n    }\n\n#endif\n\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n\n    if (has_msr_async_pf_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n\n    }\n\n    if (has_msr_pv_eoi_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n\n    }\n\n    if (has_msr_kvm_steal_time) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n\n    }\n\n    if (has_msr_architectural_pmu) {\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n\n        }\n\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n\n        }\n\n    }\n\n\n\n    if (env->mcg_cap) {\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n\n        }\n\n    }\n\n\n\n    if (has_msr_hv_hypercall) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n\n    }\n\n    if (has_msr_hv_vapic) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n\n    }\n\n    if (has_msr_hv_tsc) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n\n    }\n\n    if (has_msr_hv_crash) {\n\n        int j;\n\n\n\n        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_runtime) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        uint32_t msr;\n\n\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_stimer) {\n\n        uint32_t msr;\n\n\n\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n\n             msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_mtrr) {\n\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    /*\n\n     * MTRR masks: Each mask consists of 5 parts\n\n     * a  10..0: must be zero\n\n     * b  11   : valid bit\n\n     * c n-1.12: actual mask bits\n\n     * d  51..n: reserved must be zero\n\n     * e  63.52: reserved must be zero\n\n     *\n\n     * 'n' is the number of physical bits supported by the CPU and is\n\n     * apparently always <= 52.   We know our 'n' but don't know what\n\n     * the destinations 'n' is; it might be smaller, in which case\n\n     * it masks (c) on loading. It might be larger, in which case\n\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n\n     * we're migrating to.\n\n     */\n\n\n\n    if (cpu->fill_mtrr_mask) {\n\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n\n    } else {\n\n        mtrr_top_bits = 0;\n\n    }\n\n\n\n    for (i = 0; i < ret; i++) {\n\n        uint32_t index = msrs[i].index;\n\n        switch (index) {\n\n        case MSR_IA32_SYSENTER_CS:\n\n            env->sysenter_cs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_ESP:\n\n            env->sysenter_esp = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_EIP:\n\n            env->sysenter_eip = msrs[i].data;\n\n            break;\n\n        case MSR_PAT:\n\n            env->pat = msrs[i].data;\n\n            break;\n\n        case MSR_STAR:\n\n            env->star = msrs[i].data;\n\n            break;\n\n#ifdef TARGET_X86_64\n\n        case MSR_CSTAR:\n\n            env->cstar = msrs[i].data;\n\n            break;\n\n        case MSR_KERNELGSBASE:\n\n            env->kernelgsbase = msrs[i].data;\n\n            break;\n\n        case MSR_FMASK:\n\n            env->fmask = msrs[i].data;\n\n            break;\n\n        case MSR_LSTAR:\n\n            env->lstar = msrs[i].data;\n\n            break;\n\n#endif\n\n        case MSR_IA32_TSC:\n\n            env->tsc = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_AUX:\n\n            env->tsc_aux = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_ADJUST:\n\n            env->tsc_adjust = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_TSCDEADLINE:\n\n            env->tsc_deadline = msrs[i].data;\n\n            break;\n\n        case MSR_VM_HSAVE_PA:\n\n            env->vm_hsave = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_SYSTEM_TIME:\n\n            env->system_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_WALL_CLOCK:\n\n            env->wall_clock_msr = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_STATUS:\n\n            env->mcg_status = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_CTL:\n\n            env->mcg_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_EXT_CTL:\n\n            env->mcg_ext_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_MISC_ENABLE:\n\n            env->msr_ia32_misc_enable = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SMBASE:\n\n            env->smbase = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_FEATURE_CONTROL:\n\n            env->msr_ia32_feature_control = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_BNDCFGS:\n\n            env->msr_bndcfgs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_XSS:\n\n            env->xss = msrs[i].data;\n\n            break;\n\n        default:\n\n            if (msrs[i].index >= MSR_MC0_CTL &&\n\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n\n            }\n\n            break;\n\n        case MSR_KVM_ASYNC_PF_EN:\n\n            env->async_pf_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_PV_EOI_EN:\n\n            env->pv_eoi_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_STEAL_TIME:\n\n            env->steal_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n\n            env->msr_global_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n\n            env->msr_global_status = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\n            env->msr_global_ovf_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_HYPERCALL:\n\n            env->msr_hv_hypercall = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_GUEST_OS_ID:\n\n            env->msr_hv_guest_os_id = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n\n            env->msr_hv_vapic = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_REFERENCE_TSC:\n\n            env->msr_hv_tsc = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_VP_RUNTIME:\n\n            env->msr_hv_runtime = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SCONTROL:\n\n            env->msr_hv_synic_control = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SVERSION:\n\n            env->msr_hv_synic_version = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIEFP:\n\n            env->msr_hv_synic_evt_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIMP:\n\n            env->msr_hv_synic_msg_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_CONFIG:\n\n        case HV_X64_MSR_STIMER1_CONFIG:\n\n        case HV_X64_MSR_STIMER2_CONFIG:\n\n        case HV_X64_MSR_STIMER3_CONFIG:\n\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_COUNT:\n\n        case HV_X64_MSR_STIMER1_COUNT:\n\n        case HV_X64_MSR_STIMER2_COUNT:\n\n        case HV_X64_MSR_STIMER3_COUNT:\n\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case MSR_MTRRdefType:\n\n            env->mtrr_deftype = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix64K_00000:\n\n            env->mtrr_fixed[0] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_80000:\n\n            env->mtrr_fixed[1] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2053, "substitutes": {"cpu": ["core", "cp", "c", "component", "p", "pu", "hw", "gpu", "server", "machine", "lock", "zero", "req", "vm", "cum", "disk", "comp", "pkg", "hz", "queue", "console", "uu", "ck", "os", "mem", "socket", "net", "percent", "upt", "np", "lua", "none", "linux", "tp", "cell", "ilo", "aco", "ruby", "gc", "frame", "thread", "kernel", "ork", "device", "jp", "hog", "virtual", "CPU", "processor", "pixel", "cache", "hap", "history", "ctx", "pool", "mac", "clock", "process", "exec", "cmd", "proc", "arch", "stack", "alloc", "pc", "xc", "conn", "docker", "util", "pp", "cli", "prof", "boot", "local", "rpm", "cu", "library"], "env": ["proc", "ec", "ework", "net", "inv", " environment", "buf", "eas", "ext", "conn", "eh", "ev", "attr", "window", "vs", "node", "cfg", "vt", "viron", "environment", "nv", "pe", "def", "priv", "win", "dev", "ef", "config", "opt", "conf", "context", "e", "en", "ctx", "spec", "except", "con", "db", "ew", "gov", "mem", "eng", "map", "cmd"], "msrs": ["tsrs", " msRS", "Msrs", "msRS", "MsRs", "tsr", "MsRS", "msRs", "tsRS", " msRs", "Msr", "tsRs"], "ret": ["RET", "net", " RET", "result", "out", "set", "res", "vals", "ft", "new", "ll", "mem", "Ret", "fi", "rt", "re", "ry", "val", "nt", "nz", "mi", "reset", "flag", "t"], "i": ["id", "l", "ii", "c", "p", "n", "init", "xi", "pi", "index", "m", "b", "x", "ij", "fi", "ip", "bi", "im", "ir", "ix", "v", "mi", "ai", "I", "si", "t"], "mtrr_top_bits": ["mtrr_top_bytes", "mtrr_top2bit", "mtrr_top2flags", "mtrr_TOP32bits", "mtrr_top_flags", "mtrr_TOP32flags", "mtrr_TOP_bytes", "mtrr_top2bytes", "mtrr_top32bytes", "mtrr_top_bit", "mtrr_TOP32bytes", "mtrr_TOP_flags", "mtrr_top32bit", "mtrr_top2bits", "mtrr_top32bits", "mtrr_TOP_bits", "mtrr_top32flags", "mtrr_TOP_bit", "mtrr_TOP32bit"]}}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n", "idx": 2063, "substitutes": {"mr": ["mt", "br", "MR", "gr", "mir", "lr", "rg", "vr", "mor", "bm", "drm", "RM", "hr", "r", "mp", "m", "mx", "older", " MR", "wm", "mar", "pr", "kr", "sr", "rh", "mk", "shr", "rr", "adr", "rl", "hm", "mn", "dr", "rs", "rm", " rm", "MT", "ml", "rem", "Mr", "tr", "gm", "mc", "rar", "rn"]}}
{"project": "FFmpeg", "commit_id": "73dacabfc9b9ef1fd2c08105fdab6238ee29c2fc", "target": 0, "func": "av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n\n{\n\n    int i;\n\n\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n\n    if (f->slice_count <= 0) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < f->slice_count; i++) {\n\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n\n        int sx          = i % f->num_h_slices;\n\n        int sy          = i / f->num_h_slices;\n\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n\n        f->slice_context[i] = fs;\n\n        memcpy(fs, f, sizeof(*fs));\n\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n\n\n        fs->slice_width  = sxe - sxs;\n\n        fs->slice_height = sye - sys;\n\n        fs->slice_x      = sxs;\n\n        fs->slice_y      = sys;\n\n\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n\n                                      sizeof(*fs->sample_buffer));\n\n        if (!fs->sample_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2083, "substitutes": {"f": ["fp", "d", "j", "aff", "fw", "fc", "ff", "alf", "c", "flow", "z", "all", "p", "tif", "fa", "g", "inf", "xf", "ref", "fac", "sf", "fit", "b", "fab", "m", "lf", "fg", "x", "full", "form", "ft", "fed", "af", "elf", "info", "tf", "fl", "ef", "fi", "conf", "file", "cf", "rf", "diff", "w", "e", "um", "df", "fe", "fr", "F", "fb", "v", "fee", "h", "bf", "ac", "t", "of", "base", "fm", "uf", "fo", "fd"], "i": ["multi", "batch", "j", "id", "l", "ii", "ki", "iq", "ori", "c", " j", "ji", "is", "z", "p", "sim", "to", "n", "xi", "ic", "pi", "asi", "qi", "me", "li", "ci", "ski", "index", "s", "ami", "m", "ei", "b", "x", "cli", "us", "ui", "phi", "it", "gi", "ij", "aci", " ti", "ip", " ii", "oi", "y", "bi", "im", "e", "iu", "ti", "span", "ind", "ix", "print", "v", "ia", "uli", "zi", "mi", "di", "ini", "\u0438", "ai", "si", "I", "yi", "chain"], "fs": ["fp", "sys", "ls", "wcs", "fw", "FS", "fc", "frames", "outs", "fits", "flows", "ics", "files", "iffs", "css", "faces", "vs", "irs", "sf", "ums", "ds", "qs", "lf", "res", "vals", "less", "obs", "cells", "ps", "js", "bs", "ns", "fl", "Fs", "uses", "features", "cf", "ims", "rss", "fps", "ms", "ports", "cs", "fr", "ts", "keys", "ks", "hs", "fb", "rs", "ows", "vers", "bytes", "fee", "bits", "gs", "args", "ats", "bf", "os", "ys", "sync", "uf", "fo", "fd"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        s->frc = value & 0x3f;\n\n        break;\n\n    case 0x04:\t/* VRC */\n\n        if ((value ^ s->vrc) & 1) {\n\n            if (value & 1)\n\n                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)\n\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n\n                                ((omap_clk_getrate(s->clk) >> 3) /\n\n                                 /* Pre-multiplexer divider */\n\n                                 ((s->gcr & 2) ? 1 : 154) /\n\n                                 /* Octave multiplexer */\n\n                                 (2 << (value & 3)) *\n\n                                 /* 101/107 divider */\n\n                                 ((value & (1 << 2)) ? 101 : 107) *\n\n                                 /*  49/55 divider */\n\n                                 ((value & (1 << 3)) ?  49 : 55) *\n\n                                 /*  50/63 divider */\n\n                                 ((value & (1 << 4)) ?  50 : 63) *\n\n                                 /*  80/127 divider */\n\n                                 ((value & (1 << 5)) ?  80 : 127) /\n\n                                 (107 * 55 * 63 * 127)));\n\n            else\n\n                printf(\"%s: silence!\\n\", __FUNCTION__);\n\n        }\n\n        s->vrc = value & 0x7f;\n\n        break;\n\n    case 0x08:\t/* GCR */\n\n        s->gcr = value & 3;\n\n        break;\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 2084, "substitutes": {"opaque": ["Oplay", "OPque", "plc", "oraque", "pc", "popaque", "orlay", " opque", "opc", "pque", "popace", "oposter", "Opaque", "OPaque", "OPaques", "opace", "Opace", "paque", "opacity", "paques", " opaques", "oracity", "opque", " opc", "poplay", "poster", "OPoster", "popacity", "oplay", "opaques", " oposter", "Opacity", "plaque", "orace", "plque"], "addr": ["mt", "alloc", "id", "work", "add", "eth", "phys", "host", "handle", "Address", "seek", "attr", "hw", "ref", "r", "index", "order", "pointer", "set", "align", "coord", "res", "x", "tx", "pos", "start", "off", "at", "ack", "pad", "hl", "ptr", "err", "ctx", "adr", "gc", "now", "gate", "alt", "loc", "offset", "ix", "v", "rs", "target", "address", "arp", "hash", " address", "src", "ad", "rc", "ac", "store", "mem", "obj", "map", "cmd"], "value": ["parent", "try", "ceive", "format", "height", "port", "x", "weight", "vp", "time", "VALUE", "version", "buffer", "Value", "property", "number", "message", "key", "test", "hello", "count", "operator", "create", "ue", "num", "name", "option", "padding", " address", "max", "position", "unit", "length", "json", "vector", "byte", "self", "total", "values", "word", "code", "all", "index", "power", "memory", "entry", "type", "dev", "block", "attribute", "one", "val", "v", "address", "data", "image", "status", "item", "ay", "bit", "python", "w", "function", "field", "direction", "state", "rule"], "size": ["number", "message", "vector", "code", "count", "shift", "style", "z", "slot", "n", "index", "send", "sum", "space", "num", "weight", "shape", "type", "scope", "length", "SIZE", "buffer", "name", "offset", "ize", "body", "scale", "address", "padding", "fee", "zone", "mem", "len", "capacity", "Size", "sp"], "s": ["sys", "ls", "j", "S", "stats", "l", "c", "is", "sv", "ss", "p", "conv", "es", "g", "simple", "service", "sl", "source", "vs", "r", "sort", "comm", "ds", "qs", "utils", "m", "i", "params", "b", "fs", "store", "aws", "services", "ps", "js", "ns", "bs", "state", "w", "bis", "ms", "sam", "ts", "spec", "cs", "changes", "sm", "hs", "ies", "sts", "rs", "h", "bits", "gs", "ats", "sb", "os", "sq", "sol", "t", "socket", "sync", "ssl", "sp"]}}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void predictor_decode_mono(APEContext *ctx, int count)\n\n{\n\n    APEPredictor *p = &ctx->predictor;\n\n    int32_t *decoded0 = ctx->decoded[0];\n\n    int32_t predictionA, currentA, A, sign;\n\n\n\n    currentA = p->lastA[0];\n\n\n\n    while (count--) {\n\n        A = *decoded0;\n\n\n\n        p->buf[YDELAYA] = currentA;\n\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n\n\n        currentA = A + (predictionA >> 10);\n\n\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n\n\n        sign = APESIGN(A);\n\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n\n\n        p->buf++;\n\n\n\n        /* Have we filled the history buffer? */\n\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n\n            memmove(p->historybuffer, p->buf,\n\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n\n            p->buf = p->historybuffer;\n\n        }\n\n\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n\n        *(decoded0++) = p->filterA[0];\n\n    }\n\n\n\n    p->lastA[0] = currentA;\n\n}\n", "idx": 2093, "substitutes": {"ctx": ["cp", "cas", "wp", "tmp", "jp", "pc", "c", "xc", "nc", "bc", "unc", "conn", "conv", "hw", "np", "txt", "pb", "act", "x", "tx", "info", "req", "cmp", "config", "kw", "k", "cf", "context", "tc", "setup", "cv", "pkg", "anc", "obj", "gc", "loc", "abc", " cx", "cc", "ct", "cm", "Context", "lc", "resp", "mc", "jac", "cmd"], "count": ["acc", "Count", "d", "number", "try", "add", "size", "code", "c", "z", "all", "n", "counter", " c", " Count", "num", "find", "force", "start", "cont", "check", "cache", "amount", "call", "conf", "OUNT", "cond", "con", " call", "ind", "now", "depth", "always", "process", "ount", "f", " cc", "thread", " num", "nb", "length", "cmd"], "p": ["cp", "op", "c", "port", "n", "P", "bp", "app", "pg", "vp", "pr", "http", "xp", "ap", "comp", "pkg", "pre", "per", "h", "f", "pd", "resp", "fp", "br", "d", "q", "pm", "pb", "np", "m", "policy", "it", "at", "tp", "perm", "pa", "get", "dp", "rep", "self", "php", "j", "wp", "l", "jp", "er", "pi", "power", "progress", "patch", "i", "parse", "part", "info", "cache", "y", "pt", "process", "sp", "proc", "public", "lp", "pc", "up", "g", "after", "r", "debug", "pp", "ps", "ip", "local", "w", "post", "o", "t", "ping", "pro"], "decoded0": ["decoded1", "depodedZero", "depuatedZero", "decodeZero", "depuated180", "decayedZero", "depoded180", "decuated180", "decocatedZero", "depoded1", "depuated0", "decode1", "deccoded2", "explayed2", "decayeder", "depuated1", "explayed0", "decuatedZero", "decoding180", "decuated0", "decuated1", "deccodeder", "decayed0", "exploded2", "decoding1", "explodedZero", "decoded2", "explayedZero", "explodeder", "decodingZero", "decocated2", "decodedZero", "depoded0", "deccodedZero", "decode180", "deccoded0", "decoded180", "decode0", "decoding0", "decodeder", "exploded0", "decayed2", "decocateder", "explayeder", "decocated0"], "predictionA": ["indicationAA", "preditionAU", "PredictedB", "predictedAA", "indicationAU", "predictionAn", "predicionB", "predisonA", "predictionaryA", "predisonSA", "predictionL", "predicationAA", "predisonAA", "predictionaryB", "predicionL", "PredictionL", "predicationAU", "predictedGA", "predictionGA", "predictedAn", "indicationSA", "predisonAU", "predictionSA", "PredictionB", "preditionSA", "preditionA", "preditionAA", "predicationSA", "predictedA", "indictionA", "PredictedA", "predictionAU", "predicationB", "predictionaryAA", "predicationGA", "predictedL", "predictionaryAn", "PredictionAA", "indicationA", "PredictedAn", "PredictionA", "predictedB", "PredictedAA", "predicionA", "PredictedL", "predicionAn", "predictionB", "predictionaryGA", "PredictedGA", "PredictionAn", "predicationA", "predictionaryL", "indictionAA", "indictionSA", "predictionAA", "PredictionGA", "indictionAU"], "currentA": ["activeAA", "reportedCA", "currentB", " currentCA", "currentG", "curB", " currentG", "reportedSA", "CurrentB", "currentAA", "CurrentA", "reportedA", "currentlyA", "reportedArray", "reportedB", "curCA", " currentSA", "reportedN", "curA", "CurrentArray", " currentC", "curG", "currentSA", "current_", "currentlyArray", " currentArray", "activeA", "reportedG", "currentN", "currentlyC", "currentArray", "currentlySA", " currentAA", "CurrentAA", "active_", " currentB", "currentCA", "reportedAA", "reportedC", "reported_", "activeN", " current_", " currentN", "currentC"], "A": ["S", "AC", "At", "ACC", "V", "The", "ASC", "This", "AN", "N", "ACA", "P", "GA", "H", "CA", "AU", "X", "Alpha", "HA", "AT", "An", "C", "AA", "M", "AM", "Array", "NA", "AB", "T", "AR", "EA", "AF", "MA", "SA", "U", "E", "LA", "B", "AI", "AS", "As", "BA", "JA", "TA", "D", "RA", "AP", "I", "AV", "a", "R", "PA"], "sign": ["pres", "trust", "S", "min", "ign", "code", "shift", "mask", "sh", "operator", "ss", "style", "tick", "sort", "r", "order", "fix", "s", "sa", "rank", "dig", "act", "SIGN", "sum", "close", "pack", "space", "form", "pos", "sk", "sc", "check", "force", "sch", "mod", "type", " SIGN", "shape", "tag", "transform", "sw", "Sign", "comment", "just", "save", "diff", "ann", "grad", "vert", "spec", "ind", "SA", "wrap", "scale", "angle", "ident", "alpha", "draw", "sq", "state", "secure", "warn", "a", "se", "length", "sp"], "buf": ["bound", "ctr", "env", "fam", "window", "reb", "var", "fg", "off", "hist", "req", "cap", "buffer", "cam", "ver", "nom", "pkg", "emb", "queue", "br", "batch", "fw", "comb", "bern", "bc", "bh", "plot", "lim", "box", "cb", "rb", "coord", "num", "seq", "rab", "bs", "um", "bg", "aka", "rev", "loc", "av", "bn", "uf", "addr", "gl", "fac", "comm", "bed", "cache", "cur", "gen", "mus", "block", "err", "home", "wb", "ba", "bin", "db", "fb", "urg", "abet", "bas", "rc", "bu", "bf", "len", "cmd", "doc", "prop", "arr", "img", "forest", "fab", "hend", "orig", "vec", "desc", "cv", "grab", "bag", "bl", "blog", "gz", "norm", "Buff", "feat", "obj", "buff"]}}
{"project": "FFmpeg", "commit_id": "17ee7b5515cd1006a1f7ba4a9cced14f6526c1b0", "target": 0, "func": "static void print_report(AVFormatContext **output_files,\n\n                         AVOutputStream **ost_table, int nb_ostreams,\n\n                         int is_last_report)\n\n{\n\n    char buf[1024];\n\n    AVOutputStream *ost;\n\n    AVFormatContext *oc;\n\n    int64_t total_size;\n\n    AVCodecContext *enc;\n\n    int frame_number, vid, i;\n\n    double bitrate, ti1, pts;\n\n    static int64_t last_time = -1;\n\n    static int qp_histogram[52];\n\n\n\n    if (!is_last_report) {\n\n        int64_t cur_time;\n\n        /* display the report every 0.5 seconds */\n\n        cur_time = av_gettime();\n\n        if (last_time == -1) {\n\n            last_time = cur_time;\n\n            return;\n\n        }\n\n        if ((cur_time - last_time) < 500000)\n\n            return;\n\n        last_time = cur_time;\n\n    }\n\n\n\n\n\n    oc = output_files[0];\n\n\n\n    total_size = avio_size(oc->pb);\n\n    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too\n\n        total_size= avio_tell(oc->pb);\n\n\n\n    buf[0] = '\\0';\n\n    ti1 = 1e10;\n\n    vid = 0;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        float q= -1;\n\n        ost = ost_table[i];\n\n        enc = ost->st->codec;\n\n        if(!ost->st->stream_copy && enc->coded_frame)\n\n            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;\n\n        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"q=%2.1f \", q);\n\n        }\n\n        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            float t = (av_gettime()-timer_start) / 1000000.0;\n\n\n\n            frame_number = ost->frame_number;\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"frame=%5d fps=%3d q=%3.1f \",\n\n                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);\n\n            if(is_last_report)\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"L\");\n\n            if(qp_hist){\n\n                int j;\n\n                int qp= lrintf(q);\n\n                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))\n\n                    qp_histogram[qp]++;\n\n                for(j=0; j<32; j++)\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%X\", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n\n            }\n\n            if (enc->flags&CODEC_FLAG_PSNR){\n\n                int j;\n\n                double error, error_sum=0;\n\n                double scale, scale_sum=0;\n\n                char type[3]= {'Y','U','V'};\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"PSNR=\");\n\n                for(j=0; j<3; j++){\n\n                    if(is_last_report){\n\n                        error= enc->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0*frame_number;\n\n                    }else{\n\n                        error= enc->coded_frame->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0;\n\n                    }\n\n                    if(j) scale/=4;\n\n                    error_sum += error;\n\n                    scale_sum += scale;\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%c:%2.2f \", type[j], psnr(error/scale));\n\n                }\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"*:%2.2f \", psnr(error_sum/scale_sum));\n\n            }\n\n            vid = 1;\n\n        }\n\n        /* compute min output value */\n\n        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);\n\n        if ((pts < ti1) && (pts > 0))\n\n            ti1 = pts;\n\n    }\n\n    if (ti1 < 0.01)\n\n        ti1 = 0.01;\n\n\n\n    if (verbose || is_last_report) {\n\n        bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n\n\n\n        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n\n            \"size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s\",\n\n            (double)total_size / 1024, ti1, bitrate);\n\n\n\n        if (nb_frames_dup || nb_frames_drop)\n\n          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \" dup=%d drop=%d\",\n\n                  nb_frames_dup, nb_frames_drop);\n\n\n\n        if (verbose >= 0)\n\n            fprintf(stderr, \"%s    \\r\", buf);\n\n\n\n        fflush(stderr);\n\n    }\n\n\n\n    if (is_last_report && verbose >= 0){\n\n        int64_t raw= audio_size + video_size + extra_size;\n\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\\n\",\n\n                video_size/1024.0,\n\n                audio_size/1024.0,\n\n                extra_size/1024.0,\n\n                100.0*(total_size - raw)/raw\n\n        );\n\n    }\n\n}\n", "idx": 2110, "substitutes": {"output_files": ["output_frames", "output_fs", "outputingreports", "out_fs", "outputingfile", "out_files", "Output_reports", "Output_tags", "output_file", "outputingfiles", "output_tags", "Output_file", "out_frames", "output_reports", "outputingtags", "Output_files", "out_file"], "ost_table": ["stream_database", "ostgdatabase", "ost_Table", "ostgchain", "ostsdatabase", "ostslist", "ostsTable", "stream_list", "ost_database", "ostglist", "ostgtable", "stream_table", "ast_table", "ast_chain", "ost_list", "ostlyTable", "ast_database", "ost_chain", "oststable", "ast_list", "ostlytable", "stream_Table", "ostlylist", "ostlydatabase"], "nb_ostreams": ["nb_streams", "nb_ostreamS", "nb_oststreamses", "nb_oststreamers", "nb_osteadls", "nb_ostlogers", "nb_streamers", "nb_ststreamS", "nb_ostREAMses", "nb_ostreamfiles", "nb_ostREAMfiles", "nb_osteads", "nb_streamfiles", "nb_ststreamses", "nb_ostrogers", "nb_oststreams", "nb_ststreamls", "nb_ststreamfiles", "nb_ostlogs", "nb_ststreamers", "nb_streamls", "nb_streamses", "nb_ststreams", "nb_osteadses", "nb_ostREAMs", "nb_ostrogS", "nb_oststreamS", "nb_ostrogs", "nb_streamS", "nb_osteadfiles", "nb_ostreamers", "nb_ostlogS", "nb_ostREAMls", "nb_oststreamfiles", "nb_ostreamls", "nb_ostreamses", "nb_oststreamls"], "is_last_report": ["is_last_run", "is_last_log", "is_last___update", "is_first_log", "is_lastflightReport", "is_lastfulreported", "is_last___log", "is_last___run", "is_last_print", "is_first_print", "is_first_reported", "is_last_Report", "is_last_update", "is_first_update", "is_lastflightreport", "is_last_try", "is_last___print", "is_lastflightprint", "is_last_reported", "is_first_run", "is_lastfullog", "is_lastflighttry", "is_first_try", "is_last___report", "is_first_report", "is_last___reported", "is_first_Report", "is_lastfulreport", "is_lastfulrun"], "buf": ["usr", "tmp", "window", "iter", "var", "pg", "bar", " buff", "cap", "vv", "buffer", "cast", "pkg", "emb", "queue", "mem", "br", "batch", "bh", "text", "conv", "row", " buffer", "result", "pb", "box", "cb", "rb", "msg", "tab", "seq", "bs", "foo", "gc", "uv", "tr", "bn", "uf", "ref", " cmd", "bed", "cache", "cur", "etc", "priv", "err", "ctx", "pool", "str", "nm", "wb", "bin", "db", "fb", "bu", "map", "cmd", "proc", "data", "prop", "eb", "img", "txt", "rw", "b", "tx", "orig", "vec", "bt", "desc", "cv", "bag", "Buffer", "gz", "raw", "Buff", "obj", "buff"], "ost": ["pres", "OST", "oid", "ocol", "sta", "ori", "op", "host", "tt", "utt", "org", "ast", "rob", "ont", "bott", "ream", "yt", "ust", "ict", "ogg", "iot", "obs", "voc", "roc", "oster", "olog", "iv", "ist", "hop", "otype", "oss", "stream", "ort", "ous", "ob", "ind", "post", "loc", "iop", "ott", "or", "ora", "od", "nt", "irst", "rend", "o", "est", "src", "ot", "st", "os", "oad", "obj", "rog", "\u00f3", "typ"], "oc": ["ec", "alloc", "oid", "op", "c", "pc", "nc", "bc", "unc", "soc", "org", "dc", "ic", "og", "mc", "oco", "ox", "ogg", "OC", "ok", "cur", "voc", "roc", "toc", "osc", "irc", "oci", "rec", "aco", "nic", "ob", "co", "anc", "loc", "od", "cc", "o", "ct", "ocr", "rc", "ot", "aic", "os", "ac", "obj", "rog"], "total_size": ["totallogsize", "total12no", "totalLmem", "max_fee", "total_fee", "otal_no", "total_bytes", "totalLsize", "private_size", "total27time", "otal_status", "totallognumber", "total_news", "totalLfee", "total_mem", "total27fee", "max_mem", "otal_news", "total_loss", "totalLtime", "private_scale", "total_time", "total66status", "total_scale", "total12news", "total66no", " total_bytes", "total27mem", "total12status", "total12size", "total66size", "total27size", "total_number", "otal_size", "total66news", "max_size", "total_no", "total_status", " total_number", "totallogbytes", "max_time", "total_body", "private_body", "private_loss"], "enc": ["ec", "vc", "acc", "cod", "isc", "pres", "ang", "fc", "env", "et", "pc", "c", "rent", "nc", "sec", "conn", "ent", "conv", "ev", "rac", "ic", "onet", "ENC", "util", "exc", "lib", "act", "esc", "inc", "ict", "Enc", "etc", "ack", "cmp", "vec", "kw", "oder", "en", "rec", "ctx", "equ", "coll", "anc", "loc", "ew", "abc", "ct", "rc", "lang", "ac", "obj", "eng", "auth", "ens"], "frame_number": ["frame___correct", "word_reference", "frame___number", "frame_reference", " frame_note", " frame_num", "word_number", " frame_reference", " frame_key", "frameletnumber", "frame___reference", "frame_string", "frame_position", "frame_num", " frame_string", " frame_no", "frame___no", "frame_no", "word_num", "word_no", "frame_note", "frameletno", " frame_position", "frame_key", " frame_correct", "frameletposition", "frame_correct"], "vid": ["ec", "vc", "id", "oid", "serv", "cat", "vis", "vo", "vr", "port", "rid", "ev", "ci", "vt", "kind", "mid", "act", "van", "seq", "lan", "vp", "volume", "gi", "voc", "vi", "mit", "virt", "vec", "iv", "voice", "tv", "version", "cam", "cv", "hi", "ver", "ctx", "uid", "rev", "sid", "v", "VID", "bid", "vision", "vol", "uv", "unit", "pid", "iat", "feat", "vd"], "i": ["multi", "id", "ii", "ki", "iri", "ji", "c", "ori", "is", "p", "sim", "n", "init", "xi", "ic", "index", "pi", "me", "qi", "ci", "li", "m", "ei", "b", "x", "us", "ui", "info", "phi", "it", "gi", "ij", "t", "ip", "oi", "fi", "y", "bi", "im", "e", "hi", "ti", "ind", "go", "ix", "v", "zi", "in", "mi", "ini", "di", "o", "\u0438", "ai", "I", "si", "ri", "iat", "jj", "chain"], "bitrate": ["boardrating", "framerates", "boardstep", "bitrates", "bitstep", " bitstep", " bitrating", "framestep", "framerate", "framerating", "bitrating", " bitrates", "boardrates", "boardrate"], "ti1": ["te1", "ta01", "TI0", "ita1", "te2", "TI3", "ti3", "ta2", "ta3", "ita2", "TI2", "TI01", "ita01", "ti2", "TI1", "ta0", "te0", "ti01", "ti0", "ta1", "te3"], "pts": ["pkges", "ipts", "iptts", "iptps", "iptes", "ctes", "cts", "ptps", "ctps", "pkgps", "ptes", "ptts", "pkgs", "ctts", "pkgts"], "qp_histogram": ["qp_historyob", "qp2histogram", "qp2historyric", "qp_memogram", "qp2historyob", "qp_histograms", "qp_highogram", "qp2histob", "qp2historyogram", "qp_historyogram", "qp_highric", "qp_historyograms", "qp_historyric", "qp_histob", "qp_memograms", "qp2histograms", "qp_highograms", "qp_highob", "qp_histric", "qp_memric", "qp_memob", "qp2historyograms", "qp2histric"], "cur_time": ["Cur_message", "ctrlysize", "ctrlytimes", "curlytimes", "cur_system", "Cur_Time", "last_time", "curlytimer", "curttime", "cur_Time", "req_timer", "curlytime", "ctr_memory", "Cur_time", "curlyTime", "curMtime", "last_t", "req_time", "curMsize", "ctr_size", "curtime", " cur_id", "curlysize", "last_tim", "ctrlytime", "curlymessage", "last_system", "ctr_times", "cur_tim", "ctrlymemory", "reqlysize", "cur_ime", " cur_ime", "curtid", "cur_message", "cur_memory", "req_size", "curMmemory", "reqlytimer", "cur_times", "reqlytime", "cur_id", "cur_size", "ctr_time", "cur_timer", "curMtimes", "curlymemory", "cur_t"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_strong_loop_filter(uint8_t *src,\n\n                                                     const int step,\n\n                                                     const int stride,\n\n                                                     const int alpha,\n\n                                                     const int lims,\n\n                                                     const int dmode,\n\n                                                     const int chroma)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < 4; i++, src += stride){\n\n        int sflag, p0, q0, p1, q1;\n\n        int t = src[0*step] - src[-1*step];\n\n\n\n        if (!t)\n\n            continue;\n\n\n\n        sflag = (alpha * FFABS(t)) >> 7;\n\n        if (sflag > 1)\n\n            continue;\n\n\n\n        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +\n\n              26*src[ 0*step] + 25*src[ 1*step] +\n\n              rv40_dither_l[dmode + i]) >> 7;\n\n\n\n        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +\n\n              26*src[ 1*step] + 25*src[ 2*step] +\n\n              rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);\n\n            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);\n\n        }\n\n\n\n        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +\n\n              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;\n\n        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +\n\n              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);\n\n            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);\n\n        }\n\n\n\n        src[-2*step] = p1;\n\n        src[-1*step] = p0;\n\n        src[ 0*step] = q0;\n\n        src[ 1*step] = q1;\n\n\n\n        if(!chroma){\n\n            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +\n\n                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;\n\n            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +\n\n                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;\n\n        }\n\n    }\n\n}\n", "idx": 2115, "substitutes": {"src": ["ctr", "usr", "tmp", "c", "init", "iter", "out", "load", "sc", "req", "its", "sur", "sr", "ctl", "http", "comp", "rx", "ipp", "ind", "pkg", "sb", "scan", "bc", "bh", "source", "conv", "sort", "ic", "np", "usc", "dist", "cb", "lat", "seq", "it", "ack", "cmp", "tp", "iv", "ist", "ptr", "bis", "stream", "rec", "dest", "loc", "ost", "sel", "ins", "tr", "th", "secure", "warn", "sync", "length", "sn", "inst", "aux", "ii", "size", "phys", "rest", "addr", "slice", "sl", "stock", "decl", "dat", "etc", "cur", "ij", "syn", "sw", "hl", "rl", "str", "bin", "rc", "ssl", "pri", "proc", "sys", "input", "ul", "fc", "bj", "sec", "stat", "img", "txt", "s", "lib", "b", "cont", "impl", "bb", "ser", "desc", "ipl", "via", "rt", "rs", "stab", "st", "obj", "supp"], "step": ["STEP", "match", "delay", "height", "window", "read", "iter", "set", "path", "change", "load", "lock", "weight", "trip", "time", "axis", "version", "wait", "group", "pass", "scroll", "dim", "push", "touch", "roll", "batch", "d", "key", "test", "shift", "watch", "row", "session", "filter", "tab", "check", "shape", "mod", "tower", "tag", "trans", "ride", "move", "depth", "frame", "driver", "track", "sync", "length", "sleep", "chain", "ste", "device", "slice", "progress", "pointer", "patch", "dat", "space", "run", "block", "error", "save", "lag", "update", "str", "scale", "val", "loop", "draw", "split", "tick", "inter", "steps", "input", "add", "temp", "skip", "status", "layer", "drop", "way", "mode", "debug", "start", "stop", "ip", "Step", "post", "print", "stroke", "walk", "seed", "st", "store", "stage", "base"], "stride": ["strider", "stides", "stension", "strided", "STRide", "strension", "STRided", "STRider", "arrides", " strider", "STRride", "stringides", "stringride", " strride", "arrride", "striider", " strided", "striided", "stringide", "striide", "stide", "arride", "strides", "stringension", "striride", "arrension", "strride"], "alpha": ["acc", "ma", "acl", "rad", "height", "p", "attr", "la", "fac", "pi", "qa", "xa", "asc", "wa", "factor", "filter", "Alpha", "weight", "extra", "phi", "at", "ta", "mu", "base", "axis", "pha", "lambda", "area", "alias", "ar", "offset", "scale", "val", "angle", "beta", "ho", "si", "ac", "da", "al", "a"], "lims": ["lamls", "lamS", "limsi", "LimS", "lamresses", "limfs", "Limresses", "locls", "locts", "limjs", "tabi", "tabs", "limS", " limms", " limjs", "reqd", " limins", "limitsments", "locins", "Limgs", "limresses", "tabsi", "limi", "margids", " limls", "limins", " slimments", "Limsi", " limits", "lams", " slimfs", "margs", "Limits", "margfs", "reqresses", "Limins", "locits", "limits", "locs", "Limsd", "limments", "limids", "locms", "limgs", "Limts", "rends", "limms", "Limd", "lamjs", "reqs", "lamd", "limts", "limls", " slimsi", " slimids", "limd", "lamts", "limsd", "rendsd", " slimgs", "limitsfs", "rendts", "Limms", "tabgs", "margments", " slims", "rendgs", "locsd", "locgs", "Lims", "locjs", "limitss", "reqS", " limts", "Limi", " slimi", "limitsids"], "dmode": ["cmodule", "edmode", "doption", "dsche", "Dsym", "dtype", " dtype", "cdim", "Ddim", "ttype", " dmod", " dmodule", "lsche", "tmodule", "hsym", "hMODE", "hmodule", "hsche", "Dmode", "dmod", "hmod", "ctype", "cmode", "DMODE", "rmodule", " dMODE", " dsym", "dsym", "hmode", "tmode", " doption", "lmod", "lmodule", " ddim", "lmode", "edmod", "toption", "Dmod", "cMODE", "edmodule", "edsche", "rmod", "Dmodule", "dMODE", "coption", "rmode", "ddim", "dmodule", "Doption"], "chroma": ["chromi", "comi", "coma", "normi", "cmpa", "comb", "normo", "chromb", "cmpo", "como", "cmpi", "chromo", "cmpb", "norma", "normb"], "i": ["multi", "j", "id", "l", "ii", "status", "er", "c", " j", "is", "p", "sim", "init", "n", "xi", "ic", "pi", "index", "me", "s", "li", "ci", "out", "m", "x", "cli", "us", "ui", "info", "phi", "it", "gi", "series", "ex", " ti", "ip", " ii", "version", "bi", "im", "ie", "err", "iu", "ti", "complete", "hi", "ind", "go", "io", "ix", "v", "zi", "in", "mi", "o", "ini", "di", "by", "ai", "I", "si", "h", "t", "json", "a", "inter"], "sflag": ["tsFlag", "slimit", "tsflag", "esFlag", "statsflag", "eFlag", "Slimit", "Sflags", " sstatus", " sflags", "alsflag", "statsFlag", "eflags", "statsflags", "tsflags", "SFlag", "Sflag", " sFlag", "esstatus", "sflags", "symFlag", "estatus", " solean", "sbool", "sstatus", "esflags", "alsstatus", "eflag", "symflags", "statslimit", "symolean", "alsbool", "Sstatus", " sbool", "solean", "esflag", "elimit", "symflag", "alsFlag", "sFlag", "tsolean"], "p0": ["ipzero", "pingzero", "pr15", "P00", " p15", "ip0", "pi90", "ip1", "P1", "ipno", "ping0", "pr000", " p90", "pi1", "pa0", "pa000", "pzero", "pt000", "ipnull", "P0", "qnull", "pt0", " p00", "pp0", "pingno", "pa1", "ip000", "pno", "ptno", "pp1", "p000", "p15", "pa15", "p00", "pr1", "P90", " p000", "ptzero", "pp00", "ping000", "p90", "pi0", "pnull", "pr0", " pnull"], "q0": ["qZero", "quor", "qee", "eq000", "qt5", "qtentry", "qu5", "qk", "sqee", "qt0", "qu0", "q2", "pentry", "quZero", "eq5", "quee", "qor", " qZero", "qu1", "q000", "eq0", "sq0", "p5", " qor", "g1", "quk", "quentry", "qt1", "g0", " q2", "sqk", "q5", "pZero", "p000", "eq1", "qu2", "sq2", "qentry", "g000", " qk", "por", " qee", "g5"], "p1": ["cp01", "cp1", "pOne", "P1", "lp0", "p81", "qone", "q2", "pp2", "pi1", " p01", "pi81", " p81", "prup", " p2", "ppOne", "P0", "cp81", "POne", "pione", "ppup", "pr2", "pr100", "pp0", "qup", "pp100", "lpOne", "P2", " pOne", "qOne", "pp1", "pi01", "q100", "pone", "p100", "cpone", "lpone", "lp1", "pr1", "p2", " pone", "pup", "p01"], "q1": ["qn", "pOne", "p10", "qu0", "qone", "pn", " qOne", "quone", "qu1", "qu10", " qn", " qone", "qOne", " q10", "qun", "pone", "q10", "quOne"]}}
{"project": "qemu", "commit_id": "03fcbd9dc5084ff4676c153fbe04fb0fcf939d09", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)\n\n{\n\n    DeviceClass *dc;\n\n    const char *driver, *path;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        error_setg(errp, QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    dc = qdev_get_device_class(&driver, errp);\n\n    if (!dc) {\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path, errp);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n\n                       driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus || qbus_is_full(bus)) {\n\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n\n                       dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    if (!migration_is_idle()) {\n\n        error_setg(errp, \"device_add not allowed while migrating\");\n\n        return NULL;\n\n    }\n\n\n\n    /* create device */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n\n\n\n\n\n    }\n\n\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n\n\n    /* set properties */\n\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        dev->opts = NULL;\n\n\n    }\n\n    return dev;\n\n\n\nerr_del_dev:\n\n    error_propagate(errp, err);\n\n    object_unparent(OBJECT(dev));\n\n    object_unref(OBJECT(dev));\n\n    return NULL;\n\n}", "idx": 2124, "substitutes": {"opts": ["ioppt", "spets", "iopouts", "okTS", "alcs", "optpt", "optls", "optvals", "iopvals", " opets", "iopps", "props", " opps", "opps", "optouts", "OPps", "spetions", "alics", "opets", "copps", "okts", "proTS", "options", "prots", "ops", "optcs", " opvals", "OPls", "OPics", "iopts", "opcs", "opTS", "alts", " oppt", "iopTS", "opgs", "OPTS", "okets", "proals", "pros", "opals", "optgs", "iops", "iopgs", "oppt", "copTS", "alps", "OPcs", " opgs", "opvals", "optTS", " opTS", "iopls", "optics", " options", "copts", "optps", "optals", "iopcs", "opics", " opouts", "speTS", "OPts", "OPs", "copals", "optts", "oktions", "opls", "opouts", "speets"], "errp": [" errv", " errcp", "aerP", "arrp", " errpa", "rerpa", "ererpart", "errpe", " errpress", " errpe", "aerpress", "rerpe", "rrpa", "errP", "errcp", "dangerp", "tracebp", "dangerpart", "rerp", "rrping", "derpid", "errorpe", "aerp", "arrcp", "derping", "errorp", "ererpre", " errP", "errpid", "ierp", "rrpt", "terpre", "derpa", "errpress", "derpy", "ererp", "dangerpre", " errbp", "ierpt", "ierping", "rerpy", "ererbp", "errpre", "ererP", "rerpress", "terpa", "rrp", "derpt", "aerpart", "tracep", "errpy", "errorpy", "errpa", "rerpid", "dangerpa", "ererpa", "errorP", "tracepa", "ererv", " errpart", "arrpid", "terp", "tracecp", "errpt", "arrpy", " errpy", "ierpa", "derp", "rerP", "ererpy", "errpart", "errorv", "traceP", "rerpart", "errv", "errping", "rerv", "errbp", "arrpa", "terpart", "arrP"], "dc": ["doc", "ec", "vc", "d", "cp", "design", "ctr", "cat", "fc", "cd", "cr", "dt", "c", "pc", "bc", "DC", "nc", "deck", "dd", "css", "ga", "ca", "dir", "cfg", "mc", "ds", "coord", "dat", "cot", "sc", "controller", "cmp", "kw", "cf", "desc", "disk", "cam", "cs", "df", "ctx", "coll", "gc", "db", "dr", "currency", "cc", "fee", "disc", "di", "ct", "dp", "draw", "rc", "cm", "lc", "ac", "da", "tc", "cmd", "cca"], "driver": ["reader", "d", "cp", "cd", " drivers", "device", "test", "drivers", "host", "addr", "operator", "handle", "source", "DR", "conn", "dd", "route", "select", "dir", "definition", "label", "box", "iter", "window", "description", "kind", "dist", "engine", "proxy", "ds", "Driver", "url", "service", "store", "controller", "config", "writer", "browser", "connection", "desc", "error", "der", "owner", "method", "finder", "str", "manager", "db", "class", "project", "river", "dr", "bridge", "target", "wrapper", "creator", "field", "control", "handler", "root", "direction", "direct", "prefix", "drive", "track", "cmd"], "path": ["data", "template", "parent", "input", "mount", "inner", "id", "key", "c", "host", "port", "p", "Path", "route", "ref", "dir", "ath", "box", "pointer", "kind", "url", "where", "collection", "full", "form", "type", "history", "config", "axis", "transform", "local", "binding", "context", "arc", "pattern", "method", "name", "alias", "spec", "str", "pkg", "anc", "pt", "loc", "partial", "cross", "PATH", "root", "cert", "th", "raw", "prefix", "length", "cmd", "chain"], "dev": ["jump", "data", "aux", "env", "test", "device", "pro", "prop", "adv", "conn", "dd", "dep", "init", "ev", "ow", "hw", "way", "dem", "stable", "debug", "dist", "ds", "res", "var", "develop", "serial", "def", "priv", "mem", "ex", "iv", "gu", "sw", "dm", "sd", "w", "wd", "cam", "ver", "Device", "die", "de", "del", "DEV", "go", "tech", "db", "ov", "v", "val", "nt", "cmd", "ad", "ve", "tr", "scan", "pub", "os", "des", "development", "Dev", "obj", "dis", "fo"], "bus": ["vc", "handle", "port", "Bus", "bind", "cus", "proxy", "load", "us", "lock", "bar", "board", "hub", "http", "disk", "stick", "cast", "kit", "bird", "bo", "pass", "vol", "handler", "os", "socket", "back", "test", "bc", "dir", "box", "bug", "cb", "full", "valid", "bolt", "hand", "bs", "bal", "loc", "bid", "root", "chain", "cat", "phys", "buf", "host", "bool", "used", "cache", "type", "gen", "uses", "block", "ctx", "home", "db", "loop", "di", "proc", "sys", "mount", "func", "prop", "jack", "conn", "docker", "way", "util", "lib", "b", "tx", "boot", "local", "binding", "BUS", "alias", "bridge", "null", "ac", "state", "join", " BUS", "buff"], "err": ["mr", "ec", "usr", "cr", "test", "eas", "arr", "buf", "er", "conn", "ev", "attr", "r", "iter", "cfg", "exc", "cb", "res", "msg", "req", "kr", "conf", "dy", "error", "errors", "der", "rr", "rx", "die", "rev", "loc", "Error", "rs", "rc", "resp", "obj", "cmd"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,\n\n                              int buf_size, int buf_size2)\n\n{\n\n    RVDecContext *rv = avctx->priv_data;\n\n    MpegEncContext *s = &rv->m;\n\n    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;\n\n\n\n    active_bits_size = buf_size * 8;\n\n    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);\n\n    if (s->codec_id == AV_CODEC_ID_RV10)\n\n        mb_count = rv10_decode_picture_header(s);\n\n    else\n\n        mb_count = rv20_decode_picture_header(rv);\n\n    if (mb_count < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"HEADER ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->mb_x >= s->mb_width ||\n\n        s->mb_y >= s->mb_height) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"POS ERROR %d %d\\n\", s->mb_x, s->mb_y);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    mb_pos = s->mb_y * s->mb_width + s->mb_x;\n\n    left   = s->mb_width * s->mb_height - mb_pos;\n\n    if (mb_count > left) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"COUNT ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {\n\n        // FIXME write parser so we always have complete frames?\n\n        if (s->current_picture_ptr) {\n\n            ff_er_frame_end(&s->er);\n\n            ff_MPV_frame_end(s);\n\n            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;\n\n        }\n\n        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)\n\n            return ret;\n\n        ff_mpeg_er_frame_start(s);\n\n    } else {\n\n        if (s->current_picture_ptr->f.pict_type != s->pict_type) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    av_dlog(avctx, \"qscale=%d\\n\", s->qscale);\n\n\n\n    /* default quantization values */\n\n    if (s->codec_id == AV_CODEC_ID_RV10) {\n\n        if (s->mb_y == 0)\n\n            s->first_slice_line = 1;\n\n    } else {\n\n        s->first_slice_line = 1;\n\n        s->resync_mb_x      = s->mb_x;\n\n    }\n\n    start_mb_x     = s->mb_x;\n\n    s->resync_mb_y = s->mb_y;\n\n    if (s->h263_aic) {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_aic_dc_scale_table;\n\n    } else {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;\n\n    }\n\n\n\n    if (s->modified_quant)\n\n        s->chroma_qscale_table = ff_h263_chroma_qscale_table;\n\n\n\n    ff_set_qscale(s, s->qscale);\n\n\n\n    s->rv10_first_dc_coded[0] = 0;\n\n    s->rv10_first_dc_coded[1] = 0;\n\n    s->rv10_first_dc_coded[2] = 0;\n\n    s->block_wrap[0] =\n\n    s->block_wrap[1] =\n\n    s->block_wrap[2] =\n\n    s->block_wrap[3] = s->b8_stride;\n\n    s->block_wrap[4] =\n\n    s->block_wrap[5] = s->mb_stride;\n\n    ff_init_block_index(s);\n\n\n\n    /* decode each macroblock */\n\n    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {\n\n        int ret;\n\n        ff_update_block_index(s);\n\n        av_dlog(avctx, \"**mb x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n\n\n        s->mv_dir  = MV_DIR_FORWARD;\n\n        s->mv_type = MV_TYPE_16X16;\n\n        ret = ff_h263_decode_mb(s, s->block);\n\n\n\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n\n        // bitstream size\n\n        if (ret != SLICE_ERROR) {\n\n            int v = show_bits(&s->gb, 16);\n\n\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n\n\n            if (!v)\n\n                ret = SLICE_END;\n\n        }\n\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n\n            active_bits_size = buf_size2 * 8;\n\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n\n                   8 * buf_size, active_bits_size);\n\n            ret = SLICE_OK;\n\n        }\n\n\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x,\n\n                   s->mb_y);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            ff_h263_update_motion_val(s);\n\n        ff_MPV_decode_mb(s, s->block);\n\n        if (s->loop_filter)\n\n            ff_h263_loop_filter(s);\n\n\n\n        if (++s->mb_x == s->mb_width) {\n\n            s->mb_x = 0;\n\n            s->mb_y++;\n\n            ff_init_block_index(s);\n\n        }\n\n        if (s->mb_x == s->resync_mb_x)\n\n            s->first_slice_line = 0;\n\n        if (ret == SLICE_END)\n\n            break;\n\n    }\n\n\n\n    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,\n\n                    ER_MB_END);\n\n\n\n    return active_bits_size;\n\n}\n", "idx": 2130, "substitutes": {"avctx": ["avContext", "aveconfig", "avctl", "avconfig", "awctl", "avconn", "avectx", "averkt", " avconfig", "averconfig", "avectl", "vrctx", "afcfg", "avertc", "awContext", "awctx", "awcontext", "avtx", "avercfg", "awpkg", "navconfig", "aveconn", "awcfg", "avercontext", "avjac", "afctx", " avContext", "wavcfg", "wavpkg", "avtc", "navctx", "avetc", "avecfg", "avetx", "awjac", "navkt", " avctl", "averctl", " avtx", "wavctx", " avcontext", "wavreq", "avepid", "avereq", "vrtx", "avekt", "vrconfig", "avcontext", "afjac", "avpkg", "wavjac", "avpid", "avecontext", "avreq", "wavpid", "afpkg", "avkt", "averpid", " avconn", "navtc", "avcfg", "vrcontext", "averreq", "averContext", "averctx", "awconn"], "buf": ["br", "data", "tmp", "bc", "img", "ref", " buffer", "pb", "txt", "bp", "cb", "rb", "b", "msg", "seq", "vec", "uf", "block", "cap", "buffer", "cv", "wb", "Buffer", "fb", "queue", "v", "bytes", "bl", "rc", "bf", "raw", "Buff", "mem", "map", "cmd", "buff"], "buf_size": ["buffer_index", "buf_index", "buf_SIZE", "buf_time", "buf_Size", "buf_len", "buf_start", "buf_ize", " buf_SIZE", " buf_start", "buffer_SIZE", "buffer_size", " buf_Size", "buffer_len", "buffer_time", "buffer_ize"], "buf_size2": ["buf_type3", "buf_size4", "buf_SIZE1", "buf_SIZE2", "buf_type4", "buf_size1", "buf_type2", "buf_size3", "buf_SIZE3", "buf_SIZE4", "buf_type1"], "rv": [" rch", "prv", "rcvc", "arf", "rccv", "rcch", "prvr", "srv", "srvc", "drv", "srcv", "srch", "srV", "arcv", " rcv", " rvc", "rf", "arv", "rV", " rf", "drcv", "rch", "prcv", "rcv", " rV", "drvr", "rvc", "arV", "srf", "rvr", " rvr", "prV", "drV"], "s": ["sis", "ls", "c", "sg", "aunts", "p", "es", "n", "ses", "set", "params", "store", "us", "gets", "sc", "its", "state", "http", "conf", "ports", "cs", "spec", "ies", "events", "ags", "h", "gs", "sb", "args", "os", "a", "south", "mods", "stats", "ands", "sv", "source", "actions", "vs", "details", "xs", "ds", "qs", "m", "less", "ears", "bs", "tags", "ims", "sam", "hs", "sts", "eps", "ins", "states", "sq", "self", "j", "S", "l", "sets", "ss", "als", "comm", "i", "https", "views", "ns", "sw", "ms", "ts", "ctx", "changes", "v", "tests", "results", "ssl", "sys", "is", "g", "times", "r", "ids", "b", "fs", "aws", "ps", "parts", "js", "ads", "w", "terms", "as", "sports", "has", "rs", "ows", "o", "bits", "ats", "t", "obj", "news"], "mb_count": ["mb64more", "mb6count", "mb_more", "mb67found", "mb6loc", "bb_counter", "mm_time", "mm32counter", "mb64count", "ob64count", "bb_current", "bar_count", "mb7loc", "mbllcount", "mb_success", "embed_size", "mbCountcount", "mbitycurrent", "ob_loc", "embedashn", "mb64found", "bar64more", "ob_found", "mbitycounter", "embed_n", "mm32count", "embed_count", "mbashsize", "mbityCount", "mb32time", "mb_current", "mbashcount", "mb7found", "mbashn", "mm_success", "mb_n", "mm_count", "embedashcount", "mbCounttime", "mbllcounter", "ob64len", "ob_count", "mb32counter", "mb_size", "bar64found", "bar_more", "ob_len", "mb7count", "embed_start", "mb32success", "mbashstart", "mb_found", "embedashstart", "bar_found", "mm32time", "mbllsuccess", "mb_loc", "mb_len", "ob64found", "mb6found", "mbCountsuccess", "embedashsize", "bar64count", "mbitycount", "ob64loc", "mb_counter", "mb67count", "mblltime", "bb_Count", "mb6len", "mb_time", "mb64len", "mb7len", "mb67more", "mm_counter", "mb_start", "mbCountcounter", "mb32count", "bb_count", "mb_Count", "mb64loc", "mm32success"], "mb_pos": ["jpg67pos", "jpg_mon", "kb_pos", "kb_start", "jpg67info", "mbacpos", "mb_Pos", "mb_col", "mb_neg", "jpg_pos", "mb_mon", "emb_pos", "mb_info", "kb_loc", "kb_unit", "mbacunit", "mb67info", "emb_col", "mb67mon", "mb_start", "jpg_info", "mb_loc", "emb_neg", "jpg67mon", "mb67pos", "mbacstart", "emb_Pos", "mb_unit", "mbacloc"], "start_mb_x": ["start_mb_y", "start_mm_x", "start_mm_y", "start_mm_ex", "start_mb_ex"], "active_bits_size": ["active_bytes_ize", "active_bytes_size", "active_bits_SIZE", "active_bits_max", "active_bits_ize", "active_bytes_type", "active_bytes_max", "active_bits_type", "active_bytes_SIZE"], "ret": ["mt", "RET", "try", "status", "jp", "f", "nl", " RET", "fun", "result", "txt", "progress", "out", "cb", "res", "ft", "cont", "new", "gt", "ll", "def", "it", "tf", "Ret", " Ret", "not", "t", "err", "mel", "rev", "re", "rt", "alt", "ter", "val", "rets", "nt", "det", "rem", "reset", "cert", "resp", "tr", "elt", "rel", "mem", "flag", "back", "len"], "mb_x": ["mbajxy", "ib_xi", "ib_xs", "emb_y", "mboxx", "mb_ix", "emb_x", "ib_y", "mboxix", "mbxix", "MB_ix", "emb_ex", "mb_ex", "mbxex", "emb_px", "mbajy", "mbxy", "mb_px", "mboxwidth", "mb_xs", "MB_x", "MB_ex", "mbajx", "mbxx", "mb_xi", "ib_ix", "mb_w", "mboxxi", "mb_xy", "emb_xy", "MB_y", "mb_width", "ib_w", "emb_width", "ib_width", "mbajex", "ib_x"], "mb_y": ["kb_ya", "kbJx", "mb__yy", "mbJx", "broad_ye", "mbJy", "mobi_sy", "kbJy", "tmp_y", "mobi_y", "kbJny", "mb_ny", "MB_height", "broad_y", "mb_height", "mb__height", "mb_cy", "kb_y", "kb_x", "tmp_height", "mbJya", "tmp_yy", "MB_x", "mb__ny", "mbJny", "mb__y", "mb_sy", "mb_ya", "kbJya", "mb_ye", "MB_yy", "broad_x", "mobi_cy", "tmp_ny", "MB_y", "broad_yy", "kb_ny", "mb_yy"]}}
{"project": "qemu", "commit_id": "bd88c780e6a17188f7fd676f3a056e5db21500e0", "target": 1, "func": "static inline int cpu_gdb_index(CPUState *cpu)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    return cpu->host_tid;\n\n#else\n\n    return cpu->cpu_index + 1;\n\n#endif\n\n}\n", "idx": 2133, "substitutes": {"cpu": ["proc", "core", "cp", "ork", "jp", "phys", "pc", "c", "component", "p", "pu", "hw", "gpu", "CPU", "processor", "gp", "pixel", "linux", "pai", "prof", "cmp", "physical", "tp", "config", "vm", "copy", "comp", "runner", "nic", "pool", "gc", "pkg", "bench", "mac", "rpm", "clock", "cu", "uu", "queue", "process", "frame", "ck", "os", "pid", "prefix", "socket", "cmd"]}}
{"project": "FFmpeg", "commit_id": "26227d91865ddfbfe35c9ff84853cc469e1c7daf", "target": 1, "func": "static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)\n\n{\n\n    unsigned nz = idx >> 12;\n\n\n\n    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));\n\n\n\n    return dst + 4;\n\n}\n", "idx": 2142, "substitutes": {"dst": ["dcr", " dlist", " dST", "bsts", "drabn", "dost", "pdlist", " dbsp", "fdx", "idcr", "dict", " dbn", "idst", "dx", "pdsts", "idict", "idsts", "adst", "delct", "doST", "adput", "dsput", "idct", " dsc", "dlist", "dct", "delbr", "dhbsp", "dbr", " dict", " dsrc", "dsst", "pdx", "adbr", "fdsts", "dST", "dsbr", "dsts", " dsp", "dobr", " dcr", "draST", "dobn", "dhict", "fdst", "dhcr", " dbr", "dbn", " dsts", " dx", "idbr", "dsrc", "drabr", "drast", "fdlist", "idsp", "bst", "delst", "dbsp", "pdst", "adST", " dput", "dsc", "idbsp", "idsc", " dct", "dsp", "delsc", "bsp", "dput", "bsrc", "dhst", "dsST", "idsrc"], "idx": [" idctx", "IDx", "indn", "ridn", "aidxf", "Idxf", "indxc", "idctx", "indxp", "Idxy", "IDxe", " idxs", " idxy", "identxs", "Idctx", "idxs", "identxc", "IDv", " idxe", "Idfx", " idxf", "idxe", "idxc", " idxp", "IDxf", "aidx", "identx", "Idx", "indxs", " idxc", "indx", "idfx", "idxf", " idv", "idn", "Idxe", "IDfx", "aidxs", "aidxy", "identxp", "ridxs", "Idxs", " idfx", "ridxc", "ridx", " idn", "idxp", "idxy", "idv", "IDctx", "Idv"], "sign": ["pres", "id", "add", "pay", "ign", "code", "use", "shift", "mask", "sh", "operator", "sv", "ss", "z", "style", "sort", "sl", "secure", "sa", "decl", "rank", "sql", "sy", "asc", "var", "sum", "SIGN", "close", "pack", "form", "sc", "sch", "mod", "shape", "tag", "sub", "Sign", " sig", "sd", "script", "save", "desc", "comment", "flags", "diff", "spec", "status", "go", "scale", "ident", "trade", "draw", "rc", "flag", "sq", "se", "sp"]}}
{"project": "qemu", "commit_id": "93bb1315250dd010e65dc067af103cbaf0de03ae", "target": 1, "func": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}", "idx": 2148, "substitutes": {"mon": ["meter", "monitor", "mt", " vis", "ston", "mint", "net", "mut", " serv", " Mon", " monitor", "tim", "inv", " matt", " mu", "san", "sim", "hog", "mont", "onet", "util", "m", "dat", "monkey", "mun", " man", "mer", "chron", "met", "annot", "von", "mu", "man", "dm", "wat", "dom", "mag", "den", "sam", "ann", "mons", "MON", "med", "Mon", "mn", "mm", " mem", "mat", "mi", "di", "admin", "det", " mom", "tem"], "qdict": ["queryd", "querydict", " qmap", " qdir", "qdir", "dqd", "dqdir", " qd", "qd", "qmap", "querydir", "dqdict", "dqmap", "querymap"], "list": ["List", "parent", "summary", "format", "n", "iter", "li", "out", "set", "lam", "see", "load", "form", "lock", "t", "elist", "spec", "pkg", "alist", "queue", "pre", "scan", "batch", "test", "count", "detail", "lists", "row", "result", "act", "m", "link", "lat", "filter", "full", "none", "valid", "seq", "check", "listed", "file", "ist", "stream", "and", "range", "sync", "chain", "l", "code", "view", "LIST", "all", "record", "index", "lt", " playlist", "info", "new", "flat", "type", "block", "level", "dl", "old", "v", "loop", "single", "pair", "present", "top", "len", "map", "stack", "ul", "lp", "add", "L", "arr", "stat", "r", "table", "collection", "cli", "cont", "def", "local", "copy", "pl", "coll", "print", "null", "bl", "st", "state", "feat", "obj", "rule"], "err": ["mr", "sys", "usr", "alloc", "test", "inv", "er", "arr", "buf", "status", "aaa", "ev", "attr", "result", "r", "order", "iter", "cfg", "exc", "coord", "res", "msg", "notice", "ok", "bar", "req", "found", "ex", "kr", "oc", "conf", "error", "errors", "der", "Er", "e", "rr", "str", "die", "coll", "Error", "dr", "rs", "empty", "urg", "good", "oe", "resp", "report", "cmd"]}}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    TrimContext       *s = ctx->priv;\n\n    int64_t start_sample, end_sample = frame->nb_samples;\n\n    int64_t pts;\n\n    int drop;\n\n\n\n    /* drop everything if EOF has already been returned */\n\n    if (s->eof) {\n\n        av_frame_free(&frame);\n\n        return 0;\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        pts = av_rescale_q(frame->pts, inlink->time_base,\n\n                           (AVRational){ 1, inlink->sample_rate });\n\n    else\n\n        pts = s->next_pts;\n\n    s->next_pts = pts + frame->nb_samples;\n\n\n\n    /* check if at least a part of the frame is after the start time */\n\n    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {\n\n        start_sample = 0;\n\n    } else {\n\n        drop = 1;\n\n        start_sample = frame->nb_samples;\n\n\n\n        if (s->start_sample >= 0 &&\n\n            s->nb_samples + frame->nb_samples > s->start_sample) {\n\n            drop         = 0;\n\n            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts + frame->nb_samples > s->start_pts) {\n\n            drop = 0;\n\n            start_sample = FFMIN(start_sample, s->start_pts - pts);\n\n        }\n\n\n\n        if (drop)\n\n            goto drop;\n\n    }\n\n\n\n    if (s->first_pts == AV_NOPTS_VALUE)\n\n        s->first_pts = pts + start_sample;\n\n\n\n    /* check if at least a part of the frame is before the end time */\n\n    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {\n\n        end_sample = frame->nb_samples;\n\n    } else {\n\n        drop       = 1;\n\n        end_sample = 0;\n\n\n\n        if (s->end_sample != INT64_MAX &&\n\n            s->nb_samples < s->end_sample) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts < s->end_pts) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_pts - pts);\n\n        }\n\n\n\n        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);\n\n        }\n\n\n\n        if (drop) {\n\n            s->eof = 1;\n\n            goto drop;\n\n        }\n\n    }\n\n\n\n    s->nb_samples += frame->nb_samples;\n\n    start_sample   = FFMAX(0, start_sample);\n\n    end_sample     = FFMIN(frame->nb_samples, end_sample);\n\n    av_assert0(start_sample < end_sample);\n\n\n\n    if (start_sample) {\n\n        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        av_frame_copy_props(out, frame);\n\n        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,\n\n                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                        frame->format);\n\n        if (out->pts != AV_NOPTS_VALUE)\n\n            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },\n\n                                     inlink->time_base);\n\n\n\n        av_frame_free(&frame);\n\n        frame = out;\n\n    } else\n\n        frame->nb_samples = end_sample;\n\n\n\n    s->got_output = 1;\n\n    return ff_filter_frame(ctx->outputs[0], frame);\n\n\n\ndrop:\n\n    s->nb_samples += frame->nb_samples;\n\n    av_frame_free(&frame);\n\n    return 0;\n\n}\n", "idx": 2157, "substitutes": {"inlink": [" inlock", "InLink", " inink", "Inline", "INline", "INcheck", "INlink", "cinink", "conink", "Inlinks", "conlock", "Inlink", "inlinks", "cinLink", "inlock", "cinline", "conlink", "INlinks", "INLink", "inink", "cinlink", "INlock", "cinlock", "cincheck", " incheck", "inLink", "conline", "incheck", " inlinks", " inLink"], "frame": ["data", "image", "document", "message", "face", "frames", "trace", "list", "word", "flow", "component", "style", "session", "sample", "window", "Frame", "fram", "sf", "sequence", "set", "link", "header", "page", "space", "x", "force", "rame", "policy", "profile", "info", "ce", "ence", "request", "scene", "iframe", "movie", "time", "state", "length", "fi", "file", "block", "version", "error", "vm", "context", "e", "fps", "buffer", "response", "fr", "show", "video", "function", "remote", "framework", "fb", "range", "process", "channel", "event", "f", "zone", "line", "point", "t", "base", "module", "feature"], "ctx": ["sys", "cp", "tmp", "c", "xc", "nc", "conn", "conv", "p", "init", "xs", "ds", "cb", "act", "tx", "sc", "cmp", "tz", "ns", "config", "bs", "k", "cf", "context", "tc", "cv", "cs", "pkg", "loc", "ia", " cx", "cc", "ct", "gs", "cm", "Context", "ck", "lc", "ac", "t", "mc", "cmd"], "s": ["sis", "ls", "c", "p", "es", "seconds", "n", "sf", "ses", "set", "x", "series", "its", "time", "t", "fps", "cs", "spec", "ies", "h", "gs", "f", "sb", "args", "os", "so", "a", "d", "q", "stats", "sv", "source", "actions", "settings", "service", "sort", "vs", "xs", "ess", "ds", "qs", "m", "less", "bs", "ims", "hs", "sts", "states", "ins", "sq", "j", "S", "l", "size", "sets", "ss", "z", "als", "sl", "sample", "i", "space", "info", "ns", "sw", "y", "ms", "ts", "changes", "v", "se", "sp", "sys", "steps", "is", "sim", "g", "r", "sql", "ids", "b", "fs", "ps", "parts", "js", "sd", "w", "e", "terms", "as", "sm", "rs", "bits", "ats", "state"], "start_sample": ["end_sam", "start_sequence", "before_error", "end_server", "start_sam", "start_Sample", "beforejservice", "start_channel", "end_snap", "starting_sequence", "start_tile", "startvalsample", "startaychannel", "startjmouse", "start_integer", "reset_sample", "before_service", "starttwindow", "starting_string", "start_sound", "start_binary", "start_mouse", "before_sample", "reset_example", "art_sam", "art_window", "startaysample", "end_sample", "starttsample", "end_profile", "starting_sam", "startmysystem", "starting_service", "start_snap", "start_error", "end_package", "start_server", "starttsam", "startmytile", "startjerror", "start_service", "start_tone", "start_depth", "reset_tile", "beforejsample", "end_Sample", "reset_Sample", "art_sample", "beforejerror", " start_channel", "start_example", "start_seed", "end_seed", "startjsample", "beforejmouse", "end_sequence", "reset_integer", "startjservice", "startaybinary", "resetvalexample", "resetvalsample", "start_system", "start_average", "start_string", "startvalexample", "reset_system", "starting_tone", "start_profile", "resetvalSample", "startvalSample", "before_mouse", "startmysample", "startmyinteger", "start_package", "end_depth", "starting_sample", "end_sound", " start_binary", "start_window", "end_average"], "pts": ["pps", "ptxs", "pointjs", "ppments", "aptices", "posials", "ntets", "ointts", "ppjs", "pointords", "pointsets", "cmdjs", "ptts", "ntxs", "pkgts", "ptports", "cmdis", "ptps", "roundries", "iptports", "pointments", "ports", "pkgs", "iptis", "iptsets", "oints", "posss", "ointials", "pkgices", "cmds", "posps", "cts", "ctts", "aptts", "poss", "ntments", "ntS", "iptes", "iptets", "ptries", "ptices", "posxs", "iptts", "iptjs", "ctports", "posts", "aptis", "nts", "ptials", "iptss", "ppords", "ptrs", "pointts", "eptries", "ppes", "ptrts", "roundts", "ptords", "ntps", "ntports", "ointss", "ointets", "ptes", "ntords", "pointes", "rounds", "aptjs", "iptials", "iptxs", "ppts", "apts", "points", "ctss", "iptS", "iptps", "epts", "ppices", "ptres", "ntts", "ipts", "portts", "ptsets", "iptries", "ptments", "cmdts", "ntjs", "ptets", "pkges", "ointS", "ptss", "ptrsets", "portxs", "eptts", "ptjs", "ptis", "ointps", "ptS", "ntss", "aptes"], "drop": ["disable", "batch", "stack", "trace", "try", "dust", "skip", "hide", "list", "dro", "delay", "stone", "op", "shift", "port", " dropped", "slot", "layer", "pped", "slice", "paste", "sample", "create", "crop", "hold", "Drop", "pause", "carry", "change", "leave", "red", "throw", "delete", "ignore", "shape", "zip", "stop", "push", "hop", "error", " cond", "dl", "comment", "err", "move", "foo", "dropping", "ion", "pop", " clip", "gap", "dr", "null", "rop", "burn", "field", "loop", "dp", "driver", "allow", "drops", "col", "dim", "grow", "keep", " Drop", "trap", "report", " dropping"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,\n\n                               const TCGArg * const args, uint16_t dead_args,\n\n                               uint8_t sync_args)\n\n{\n\n    int flags, nb_regs, i;\n\n    TCGReg reg;\n\n    TCGArg arg;\n\n    TCGTemp *ts;\n\n    intptr_t stack_offset;\n\n    size_t call_stack_size;\n\n    tcg_insn_unit *func_addr;\n\n    int allocate_args;\n\n    TCGRegSet allocated_regs;\n\n\n\n    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];\n\n    flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);\n\n    if (nb_regs > nb_iargs) {\n\n        nb_regs = nb_iargs;\n\n    }\n\n\n\n    /* assign stack slots first */\n\n    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);\n\n    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & \n\n        ~(TCG_TARGET_STACK_ALIGN - 1);\n\n    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);\n\n    if (allocate_args) {\n\n        /* XXX: if more than TCG_STATIC_CALL_ARGS_SIZE is needed,\n\n           preallocate call stack */\n\n        tcg_abort();\n\n    }\n\n\n\n    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;\n\n    for(i = nb_regs; i < nb_iargs; i++) {\n\n        arg = args[nb_oargs + i];\n\n#ifdef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset -= sizeof(tcg_target_long);\n\n#endif\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            temp_load(s, ts, tcg_target_available_regs[ts->type],\n\n                      s->reserved_regs);\n\n            tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);\n\n        }\n\n#ifndef TCG_TARGET_STACK_GROWSUP\n\n        stack_offset += sizeof(tcg_target_long);\n\n#endif\n\n    }\n\n    \n\n    /* assign input registers */\n\n    tcg_regset_set(allocated_regs, s->reserved_regs);\n\n    for(i = 0; i < nb_regs; i++) {\n\n        arg = args[nb_oargs + i];\n\n        if (arg != TCG_CALL_DUMMY_ARG) {\n\n            ts = &s->temps[arg];\n\n            reg = tcg_target_call_iarg_regs[i];\n\n            tcg_reg_free(s, reg, allocated_regs);\n\n\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                if (ts->reg != reg) {\n\n                    tcg_out_mov(s, ts->type, reg, ts->reg);\n\n                }\n\n            } else {\n\n                TCGRegSet arg_set;\n\n\n\n                tcg_regset_clear(arg_set);\n\n                tcg_regset_set_reg(arg_set, reg);\n\n                temp_load(s, ts, arg_set, allocated_regs);\n\n            }\n\n\n\n            tcg_regset_set_reg(allocated_regs, reg);\n\n        }\n\n    }\n\n    \n\n    /* mark dead temporaries and free the associated registers */\n\n    for(i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n        if (IS_DEAD_ARG(i)) {\n\n            temp_dead(s, &s->temps[args[i]]);\n\n        }\n\n    }\n\n    \n\n    /* clobber call registers */\n\n    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {\n\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {\n\n            tcg_reg_free(s, i, allocated_regs);\n\n        }\n\n    }\n\n\n\n    /* Save globals if they might be written by the helper, sync them if\n\n       they might be read. */\n\n    if (flags & TCG_CALL_NO_READ_GLOBALS) {\n\n        /* Nothing to do */\n\n    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {\n\n        sync_globals(s, allocated_regs);\n\n    } else {\n\n        save_globals(s, allocated_regs);\n\n    }\n\n\n\n    tcg_out_call(s, func_addr);\n\n\n\n    /* assign output registers and emit moves if needed */\n\n    for(i = 0; i < nb_oargs; i++) {\n\n        arg = args[i];\n\n        ts = &s->temps[arg];\n\n        reg = tcg_target_call_oarg_regs[i];\n\n        assert(s->reg_to_temp[reg] == NULL);\n\n\n\n        if (ts->fixed_reg) {\n\n            if (ts->reg != reg) {\n\n                tcg_out_mov(s, ts->type, ts->reg, reg);\n\n            }\n\n        } else {\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ts->reg] = NULL;\n\n            }\n\n            ts->val_type = TEMP_VAL_REG;\n\n            ts->reg = reg;\n\n            ts->mem_coherent = 0;\n\n            s->reg_to_temp[reg] = ts;\n\n            if (NEED_SYNC_ARG(i)) {\n\n                tcg_reg_sync(s, reg, allocated_regs);\n\n            }\n\n            if (IS_DEAD_ARG(i)) {\n\n                temp_dead(s, ts);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2182, "substitutes": {"s": ["sys", "ls", "S", "stats", "c", "sg", "is", "sv", "ss", "p", "source", "es", "g", "n", "session", "z", "ses", "set", "ds", "m", "b", "x", "fs", "less", "us", "sc", "services", "ps", "its", "js", "ns", "conf", "y", "ims", "w", "ms", "cs", "spec", "hs", "sts", "eps", "rs", "h", "gs", "sb", "ins", "sq", "os", "t", "a", "self"], "nb_oargs": ["nb67itarg", "nb_itarg", "nb_pojobs", "nb_oiframes", "nb_oaargs", "nb_mochanges", "nb_poarg", "nb_iants", "nb__ids", "nb_oaissues", "nb_ods", "nb_moargs", "nb_oads", "nb_oaws", "nb_oants", "nbableoargs", "nb_itarr", "nb67itissues", "nb_ocarg", "nb67itargs", "nb_iaws", "nb67itarr", "nb_moarg", "nb__iarg", "nb_ojobs", "nb_iarg", "nb__oarg", "nbableoarg", "nb_ijobs", "nb_oiarg", "nb_itissues", "nb__iargs", "nb67oarg", "nb_iissues", "nb_ichanges", "nb_ocargs", "nb_oarg", "nb__ods", "nb_itargs", "nb__oargs", "nb67oargs", "nbableochanges", "nbableoochanges", "nbableooarg", "nb_ooarg", "nb_oaframes", "nbableooargs", "nb_oarr", "nb_iframes", "nb67oissues", "nb_ids", "nb_ocjobs", "nb_oissues", "nb_iarr", "nb_moaws", "nb__iframes", "nb_oframes", "nbableooaws", "nb_ooargs", "nbableoaws", "nb_ooaws", "nb_poants", "nb__oframes", "nb_poargs", "nb_ochanges", "nb_oochanges", "nb_oaarr", "nb_oaarg", "nb_oiargs", "nb67oarr", "nb_ocants", "nb_oids"], "nb_iargs": ["nb_oitems", "nb_tivalues", "nb___icvalues", "nb_icassets", "nb___iaux", "nb___iatts", "nb_iArgs", "nb08phiassets", "nb_oArgs", "nb_iitems", "nb_inievents", "nb_piaux", "nb_oxs", "nb____ievents", "nb_icaux", "nb_mievents", "nb_tiaux", "nb_oevents", "nb_miitems", "nb_ixs", "nb_ivalues", "nb____ixs", "nb_Iargs", "nb_iuevents", "nb_iassets", "nb____iArgs", "nb_ievents", "nb_ciamps", "nb_siamps", "nb___iuargs", "nb_miresults", "nb_iuatts", "nb08iassets", "nb_iuxs", "nb_iresults", "nb08phiarr", "nb_iniitems", "nb__iitems", "nb_icamps", "nb_iaux", "nb_IArgs", "nb__iArgs", "nb_piarg", "nb___icresults", "nb_iniactions", "nb_miamps", "nb___iactions", "nb_icvalues", "nb08iarr", "nb_piArgs", "nb_oaux", "nb_iarg", "nb_iuArgs", "nb_mivalues", "nb___icaux", "nb_iuargs", "nb_ibArgs", "nb08phiargs", "nb_Iatts", "nb_iniargs", "nb08iamps", "nb__iargs", "nb_iniorders", "nb_iniArgs", "nb____iuargs", "nb_Iactions", "nb___iuArgs", "nb_miargs", "nb_oarg", "nb__oargs", "nb_icarr", "nb_iorders", "nb_iatts", "nb_idargs", "nb__oorders", "nb____iuevents", "nb_ciargs", "nb_ciarr", "nb_icresults", "nb_piitems", "nb___icargs", "nb_icargs", "nb___iresults", "nb_idaux", "nb____iargs", "nb___iargs", "nb_idarg", "nb_ibxs", "nb_ibevents", "nb_ciassets", "nb___iuatts", "nb08phiamps", "nb____iuArgs", "nb_oorders", "nb__iorders", "nb_iarr", "nb_tiresults", "nb_iniamps", "nb_siargs", "nb_phiargs", "nb___iArgs", "nb___ivalues", "nb_iniatts", "nb_ibargs", "nb_sievents", "nb_iamps", "nb_iactions", "nb_phiassets", "nb__oitems", "nb_piargs", "nb_phiarr", "nb_phiamps", "nb__oArgs", "nb___iuactions", "nb_piorders", "nb____iuxs", "nb_tiargs", "nb_idorders", "nb_siitems", "nb08iargs", "nb_miaux", "nb_iuactions"], "args": ["data", "values", "rows", "aux", "stats", "frames", "atts", "arr", "actions", "settings", "objects", "vs", "xs", "qs", "vals", "ids", "params", "fs", "fields", "aws", "members", "units", "its", "parts", "js", "users", "ns", "ims", "orders", "terms", "amps", "arms", "ms", "keys", "cs", "ams", "points", "as", "grades", "changes", "uments", "types", "rs", "tests", "ags", "bits", "results", "gs", "items", "Args"], "dead_args": ["dead67posts", "raw_flags", "dead67args", "dead67flags", "deadmmargs", "raw_args", "raw_posts", "deadmmkeys", "dead_flags", "dead_posts", "dead67keys", "dead_keys", "deadmmposts", "raw_keys", "deadmmflags"], "sync_args": ["sync12args", "sync12arg", "load_args", "sync12flags", "sync_flags", "load_arg", "load_vals", "sync2args", "load_flags", "sync_arg", "sync2vals", "sync2flags", "sync12vals", "sync2arg", "sync_vals"], "flags": ["stats", "frames", "atts", "status", "mask", "actions", "names", "xs", "weights", "options", "kind", "Flags", "ants", "vals", "params", "fs", "ui", "fields", "weight", "members", "heads", "cons", "features", "tags", "lag", "comments", "ports", "cs", "keys", "types", "ints", "ags", "bits", "flag", "ats", "FLAG", "items", "ops"], "nb_regs": ["nb_regns", "nb_resps", "nb_recps", "nb_locins", "nb_signists", "nb_resS", "nb_legS", "nb_memS", "nb_refrs", "nb_indies", "nb_regxs", "nb_argists", "nb_REGrs", "nb_regS", "nb_regds", "nb_ress", "nb_memxs", "nb_effs", "nbTsignS", "nb_effS", "nb_locS", "nb_Regles", "nb_registerps", "nb_reges", "nb_signs", "nb_indS", "nbTsignists", "nb_legds", "nb_locis", "nbptregles", "nbTregs", "nb_regn", "nb_mems", "nbTregists", "nbTsignds", "nbTregds", "nb_argS", "nbptreges", "nb_indxs", "nb_memies", "nbptpatternes", "nb_signS", "nb_regins", "nbptpatternns", "nb_regis", "nb_patternns", "nb_regles", "nb_reses", "nb_patterns", "nb_recS", "nb_locrs", "nb_resns", "nb_regps", "nb_locps", "nb_Regs", "nb_patternes", "nbptregs", "nbptpatterns", "nb_registerS", "nb_registern", "nb_REGs", "nb_argds", "nbTsigns", "nb_recs", "nb_legists", "nbTregS", "nb_regrs", "nbptregns", "nb_REGins", "nbptpatternles", "nb_resles", "nb_effxs", "nb_refins", "nb_patternles", "nb_locs", "nb_Regns", "nb_Reges", "nb_signds", "nb_registers", "nb_loces", "nb_REGis", "nb_inds", "nb_refis", "nb_recn", "nb_args", "nb_refs", "nb_legs", "nb_regists", "nb_regies", "nb_effies"], "i": ["multi", "j", "id", "ii", "iri", "instance", "is", "sim", "n", "xi", "ic", "pi", "index", "qi", "me", "ci", "li", "Ni", "m", "ei", "x", "u", "cli", "us", "ui", "phi", "it", "gi", "ij", "ip", "fi", "gu", "y", "ims", "bi", "im", "ie", "e", "iu", "ti", "ir", "ind", "ix", "ia", "zi", "in", "mi", "ini", "di", "\u0438", "o", "ai", "si", "I", "point"], "reg": ["br", "REG", "inst", "func", "Reg", "addr", "stat", "g", "init", "row", "ref", "r", "link", "res", "var", "eg", "def", "mod", "req", "tag", "ig", "block", "rec", "name", "str", "gc", "re", "region", "or", "loc", "val", "ress", "urg", "ct", "ret", "rem", "tr", "rc", "rel", "mem", "obj", "typ"], "arg": [" agg", "cand", "ace", "j", "ma", "key", "temp", "prop", "op", "arr", "word", "jp", " ag", " marg", " ax", "p", "g", "attr", "ass", "Arg", "ax", " var", "act", "var", "star", "parse", "gt", "ark", "ack", "pat", " exc", "ig", "tag", " prop", "call", " tag", " beg", "emb", " doc", "ag", "ar", " ar", " cand", "argument", "val", "v", "arp", "field", "ret", "cmd", "col", "f", "flag", " pad", "ac", " act", "t", "par", " prog", "agg", " aux"], "ts": ["mt", "ls", "mint", "tmp", "tt", "ss", "ics", "als", "TS", "times", "uts", "txt", "vs", "ds", "td", "fs", "tx", "tes", "tips", "Ts", "fts", "tm", "ps", "its", "tp", "tz", "bs", "js", "ns", "ims", "tl", "ms", "cs", "pt", "hs", "aps", "sts", "rs", "tops", "gs", "ats", "tr", "tis", "ys", "t", "tc", "acs", "ets"], "stack_offset": ["pack__start", "pack__offset", "pack_offset", "stack_size", "stack_off", "Stack_size", "stackxaddr", "ack_size", "ack_start", "stack_length", "stack_Offset", "stack_start", "Stack_Offset", "stackxoffset", "stackxstart", "ack_off", "stack__addr", "stackxindex", "pack__addr", "pack_start", "ack_offset", "Stack_length", "Stack_offset", "pack_addr", "stack_index", "stack__index", "stack__offset", "stack__start", "stack_addr", "pack__index", "pack_index"], "call_stack_size": ["call_space_Size", "call_track_size", "call_track_depth", "call_stackzinfo", "call_stackzSIZE", "call_codezSIZE", "call_code_size", "call_code_SIZE", "call_track_Size", "call_stack_addr", "call_space_size", "call_stack_info", "call_stackzsize", "call_codezSize", "call_stack_Size", "call_stack_type", "call_code_info", "call_stack_SIZE", "call_space_offset", "call_codezsize", "call_space_SIZE", "call_space_addr", "call_code_Size", "call_stack_depth", "call_codezinfo", "call_space_type", "call_stack_offset", "call_stackzSize", "call_track_SIZE"], "func_addr": ["unc_addr", "func__ref", "fun__address", "fun__ref", "fun_addr", "fun__addr", "unc_address", "fun_ref", "func__address", "func_ref", "fun_address", "unc_ptr", "func_address", "func__addr", "func_ptr"], "allocate_args": ["allocated_ags", "allocate____flags", "allocate67jobs", "allocate67arg", "allocated_flags", "allocate___args", "allocate____arg", "allocate_flags", "allocate_facts", "alloca_arg", "allocate_parts", "allocate___ags", "allocate_jobs", "allocated_facts", "allocate____facts", "allocated_arg", "alloca_ags", "allocated_jobs", "allocate_arg", "allocated_args", "allocate____args", "allocate67facts", "allocate67args", "alloca_args", "alloca_parts", "allocate____ags", "allocate___flags", "allocate___arg", "allocate____jobs", "allocate_ags"], "allocated_regs": ["allocated_locp", "allocated_mems", "allocated_locs", "allocated_recp", "allocated_regn", "allocated_memp", "allocated_recn", "allocated_locn", "allocated_memn", "allocated_regp", "allocated_recs"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static void curl_multi_do(void *arg)\n\n{\n\n    BDRVCURLState *s = (BDRVCURLState *)arg;\n\n    int running;\n\n    int r;\n\n\n\n    if (!s->multi) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        r = curl_multi_socket_all(s->multi, &running);\n\n    } while(r == CURLM_CALL_MULTI_PERFORM);\n\n\n\n    curl_multi_read(s);\n\n}\n", "idx": 2187, "substitutes": {"arg": ["doc", "cand", "arr", "ay", "g", "attr", "ref", "og", "Arg", "ng", "ass", "i", "pg", "star", "parse", "new", "it", "ge", "ary", "ig", "oc", "param", "str", "ray", "ag", "reg", "ar", "argument", "val", "group", "fire", "arp", "event", "ad", "__", "args", "ac", "agg", "a"], "s": ["sys", "sis", "ls", "S", "j", "q", "is", "sv", "ss", "p", "es", "sl", "ses", "ess", "comm", "ds", "sa", "set", "m", "b", "less", "sc", "aws", "iss", "ps", "js", "ns", "bs", "state", "y", "bis", "sam", "as", "ts", "spec", "a", "str", "sm", "hs", "ar", "sts", "rs", "ares", "gs", "sb", "ats", "st", "sq", "os", "args", "t", "serv", "se", "self", "sp"], "running": ["multi", "total", "Running", "using", "active", "checked", "inner", "l", "including", "successful", "reading", "starting", "all", "loaded", "blocking", "performing", "stable", "runs", "calling", "m", "ending", "ready", "ered", "valid", "playing", "run", "available", "enabled", "called", "done", "current", "loading", "working", "standing", " Running", "started", "state"], "r": ["mr", "br", "d", "rd", "gr", "q", "l", "er", "ro", "c", "nr", "rg", "p", "n", "attr", "result", "rb", "m", "res", "i", "u", "it", "run", "pr", "R", "sr", "err", "e", "rr", "str", "rt", "ror", "or", "ar", "dr", "v", "rs", "h", "ret", "rc", " err", "t", "re", "rar", "rn"]}}
{"project": "FFmpeg", "commit_id": "f95cfff07765912676cc613b55e2234b5d70f1bd", "target": 0, "func": "static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)\n\n{\n\n    static int hinted = 0;\n\n    int ret = 0;\n\n    AVDictionaryEntry *e;\n\n    const AVOption *o = NULL;\n\n    const char *option = NULL;\n\n    const char *codec_name = NULL;\n\n    char buff[1024];\n\n    AVCodecContext *ctx;\n\n    AVDictionary **dict;\n\n    enum AVCodecID guessed_codec_id;\n\n\n\n    switch (type) {\n\n    case AV_OPT_FLAG_VIDEO_PARAM:\n\n        ctx = config->dummy_vctx;\n\n        dict = &config->video_opts;\n\n        guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_video_codec_id : AV_CODEC_ID_H264;\n\n        break;\n\n    case AV_OPT_FLAG_AUDIO_PARAM:\n\n        ctx = config->dummy_actx;\n\n        dict = &config->audio_opts;\n\n        guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ?\n\n                           config->guessed_audio_codec_id : AV_CODEC_ID_AAC;\n\n        break;\n\n    default:\n\n        av_assert0(0);\n\n    }\n\n\n\n    if (strchr(opt, ':')) {\n\n        //explicit private option\n\n        snprintf(buff, sizeof(buff), \"%s\", opt);\n\n        codec_name = buff;\n\n        option = strchr(buff, ':');\n\n        buff[option - buff] = '\\0';\n\n        option++;\n\n        if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0)\n\n            return ret;\n\n        if (!ctx->codec || !ctx->priv_data)\n\n            return -1;\n\n    } else {\n\n        option = opt;\n\n    }\n\n\n\n    o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);\n\n    if (!o && (!strcmp(option, \"time_base\")  || !strcmp(option, \"pixel_format\") ||\n\n               !strcmp(option, \"video_size\") || !strcmp(option, \"codec_tag\")))\n\n        o = av_opt_find(ctx, option, NULL, 0, 0);\n\n    if (!o) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                            &config->errors, \"Option not found: %s\\n\", opt);\n\n        if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) {\n\n            hinted = 1;\n\n            report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL,\n\n                                \"If '%s' is a codec private option, then prefix it with codec name, \"\n\n                                \"for example '%s:%s %s' or define codec earlier.\\n\",\n\n                                opt, avcodec_get_name(guessed_codec_id) ,opt, arg);\n\n        }\n\n    } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, \"Invalid value for option %s (%s): %s\\n\", opt,\n\n                arg, av_err2str(ret));\n\n    } else if ((e = av_dict_get(*dict, option, NULL, 0))) {\n\n        if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-'))\n\n            return av_dict_set(dict, option, arg, AV_DICT_APPEND);\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors,\n\n                \"Redeclaring value of the option %s, previous value: %s\\n\",\n\n                opt, e->value);\n\n    } else if (av_dict_set(dict, option, arg, 0) < 0) {\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2188, "substitutes": {"opt": ["j", "cp", "aux", "ff", "prop", "op", "tmp", "buf", "opted", "ext", "cho", "term", "text", "p", "attr", "ref", "tip", "txt", "iter", "options", "crit", "intern", "var", "tx", "off", "gt", "etc", "it", "Opt", "optim", "anon", "name", "str", "ption", "alt", "pt", "bin", "rt", "offset", "val", "OP", "pot", "ost", "expr", "Option", "timeout", "prefix", "mem", "obj", "cmd", "typ"], "arg": ["aux", "key", "head", "op", "arr", "use", "attr", "ref", "Arg", "ax", "bit", "tag", "call", "param", "err", "bin", "reg", "argument", "val", "target", "arp", "event", "args", "flag", "rc", "enc", "mem", "cmd"], "type": ["id", "Type", "parent", "ype", "ty", "key", "test", "op", "size", "value", "format", "count", "style", "p", "index", "kind", "action", "family", "info", "pe", "time", "tag", "state", "y", "file", "error", "buffer", "name", "TYPE", "or", "class", "types", "what", "range", "null", "sp", "t", "rule", "length", "ping", "feature", "typ"], "config": ["c", "format", "drivers", "init", "rac", "google", "set", "change", "params", "req", "reason", "t", "state", "conf", "context", "spec", "con", "pkg", "ind", "admin", "args", "ec", "net", "bc", "text", "settings", "policy", "check", "known", "cmp", "storage", "setup", "greg", "gate", "apache", "get", "remote", "json", "acc", "figure", "fig", "Config", "comm", "dat", "info", "adj", "cache", "etc", "network", "history", "connection", "comment", "diff", "attribute", "support", "anc", "client", "address", "FIG", "rc", "reflect", "prefix", "exec", "cmd", "doc", "add", "sec", "conn", "cfg", "lib", "exc", "collection", "unknown", "cont", "param", "desc", "command", "complete", "correct", "null", "cc", "connect", "ct", "control", "store", "tc", "subject"], "e": ["ele", "et", "er", "c", "p", "es", "ent", "n", "ev", "element", "ue", "ei", "x", "pe", "ef", "eu", "ed", "ie", "el", "en", "ae", "ea", "de", "E", "oe", "ee", "f"], "o": ["j", "d", "et", "po", "op", "l", "vo", "c", "p", "n", "O", "onet", "out", "lo", "oa", "m", "i", "u", "iso", "k", "oin", "mo", "ob", "bo", "or", "go", "io", "offset", "v", "oe", "h", "oo", "f", "ot", "os", "om", "t", "obj", "a", "fo"], "option": ["cp", "ff", "tmp", "op", "cho", "order", "menu", "options", "zero", "buffer", "answer", "timeout", "second", "number", "key", "result", "question", "usage", "none", "optional", "tag", "name", "ion", "alt", "offset", "OP", "position", "put", "byte", "total", "section", "operation", "slot", "description", "index", "pointer", "action", "i", "condition", "entry", "connection", "comment", "error", "attribute", "bin", "or", "consider", "empty", "flag", "prefix", "point", "value", "term", "table", "unknown", "TION", "archive", "param", "command", "alias", "ption", "argument", "null", "field", "event", "Option"], "codec_name": ["codecnamename", "codec_format", "codec_names", "codec_word", "codecNameword", "codecnameinfo", "codec_wrapper", "codEC_id", "codec__wrapper", "codecNamename", "codecnamenames", "codec__info", "codEC_name", "codec__name", "codEC__name", "codecNameid", "codecNamenames", "codec_Name", "codEC_info", "codec__id", "codEC__wrapper", "codec_info", "codecnamewrapper", "codEC__info", "codecnameid", "codEC__id", "codec_id", "codEC_wrapper", "codecnameword"], "buff": ["ff", "uff", "tmp", "op", "mb", "butt", "ext", "p", "bind", "window", "iter", "options", "needed", "form", "off", "buffer", " Buff", "ind", "bo", "h", "ret", "f", "mem", "batch", "text", " buffer", "pb", "box", "cb", "tab", "bs", "font", "ptr", "loc", "offset", "nt", " buf", "enc", "uf", "j", "aux", "size", "buf", "inf", "ref", "i", "tf", "kw", "comment", "fr", "IT", "ob", "str", "bin", "fb", "selected", "prefix", "len", "cmd", "data", "temp", "eb", "nd", "txt", "pp", "b", "ary", "bb", "ip", "flash", "desc", "Buffer", "rt", "null", "raw", "Buff", "obj"], "ctx": ["sys", "cp", "alloc", "func", "tmp", "op", "buf", "bc", "handle", "unc", "conn", "conv", "p", "init", "dc", "hw", "window", "np", "txt", "util", "cfg", "crit", "cb", "act", "x", "tx", "kt", "sc", "qt", "req", "voc", "ij", "tz", "ns", "kw", "conf", "k", "cf", "ctl", "cv", "context", "tc", "mk", "setup", "pool", "pkg", "co", "anc", "bo", "rt", "loc", "std", "cu", "cc", "nt", "wx", "ct", "handler", "ck", "resp", "ac", "iat", "mem", "obj", "uf", "cmd"], "dict": ["doc", "data", "d", "und", "cd", "buf", "dt", "p", "dd", "ent", "conn", "bind", "inf", "dir", "txt", "details", "ds", "table", "dat", "ict", "tx", "def", "conf", "hd", "context", "w", "df", "rec", "cond", "pkg", "coll", "db", "dr", "nt", "hash", "h", "ct", "di", "ad", "state", "mem", "obj", "map", "cmd"], "guessed_codec_id": ["guessed_codec_ids", "guessed_codecoename", "guessed_codec_flag", "guessed_codian_name", "guessed_codec_type", "guessed_codoc_flag", "guessed_codec_link", "guessed_codoc_id", "guessed_codian_id", "guessed_codecoeinfo", "guessed_codian_link", "guessed_codec_info", "guessed_codoc_ids", "guessed_codoc_type", "guessed_codoc_name", "guessed_codoc_info", "guessed_codecoeid", "guessed_codecoeflag", "guessed_codec_class", "guessed_codian_class", "guessed_codec_name"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)\n\n{\n\n    CPUMoxieState *env = &cpu->env;\n\n\n\n    /* Local cache for the instruction opcode.  */\n\n    int opcode;\n\n    /* Set the default instruction length.  */\n\n    int length = 2;\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    /* Examine the 16-bit opcode.  */\n\n    opcode = ctx->opcode;\n\n\n\n    /* Decode instruction.  */\n\n    if (opcode & (1 << 15)) {\n\n        if (opcode & (1 << 14)) {\n\n            /* This is a Form 3 instruction.  */\n\n            int inst = (opcode >> 10 & 0xf);\n\n\n\n#define BRANCH(cond)                                                         \\\n\n    do {                                                                     \\\n\n        int l1 = gen_new_label();                                            \\\n\n        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \\\n\n        gen_goto_tb(env, ctx, 1, ctx->pc+2);                                 \\\n\n        gen_set_label(l1);                                                   \\\n\n        gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \\\n\n        ctx->bstate = BS_BRANCH;                                             \\\n\n    } while (0)\n\n\n\n            switch (inst) {\n\n            case 0x00: /* beq */\n\n                BRANCH(TCG_COND_EQ);\n\n                break;\n\n            case 0x01: /* bne */\n\n                BRANCH(TCG_COND_NE);\n\n                break;\n\n            case 0x02: /* blt */\n\n                BRANCH(TCG_COND_LT);\n\n                break;\n\n            case 0x03: /* bgt */\n\n                BRANCH(TCG_COND_GT);\n\n                break;\n\n            case 0x04: /* bltu */\n\n                BRANCH(TCG_COND_LTU);\n\n                break;\n\n            case 0x05: /* bgtu */\n\n                BRANCH(TCG_COND_GTU);\n\n                break;\n\n            case 0x06: /* bge */\n\n                BRANCH(TCG_COND_GE);\n\n                break;\n\n            case 0x07: /* ble */\n\n                BRANCH(TCG_COND_LE);\n\n                break;\n\n            case 0x08: /* bgeu */\n\n                BRANCH(TCG_COND_GEU);\n\n                break;\n\n            case 0x09: /* bleu */\n\n                BRANCH(TCG_COND_LEU);\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /* This is a Form 2 instruction.  */\n\n            int inst = (opcode >> 12 & 0x3);\n\n            switch (inst) {\n\n            case 0x00: /* inc */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_addi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x01: /* dec */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned int v = (opcode & 0xff);\n\n                    tcg_gen_subi_i32(REG(a), REG(a), v);\n\n                }\n\n                break;\n\n            case 0x02: /* gsr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_ld_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            case 0x03: /* ssr */\n\n                {\n\n                    int a = (opcode >> 8) & 0xf;\n\n                    unsigned v = (opcode & 0xff);\n\n                    tcg_gen_st_i32(REG(a), cpu_env,\n\n                                   offsetof(CPUMoxieState, sregs[v]));\n\n                }\n\n                break;\n\n            default:\n\n                {\n\n                    TCGv temp = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                    tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                    gen_helper_raise_exception(cpu_env, temp);\n\n                    tcg_temp_free_i32(temp);\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* This is a Form 1 instruction.  */\n\n        int inst = opcode >> 8;\n\n        switch (inst) {\n\n        case 0x00: /* nop */\n\n            break;\n\n        case 0x01: /* ldi.l (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x02: /* mov (register-to-register) */\n\n            {\n\n                int dest  = (opcode >> 4) & 0xf;\n\n                int src = opcode & 0xf;\n\n                tcg_gen_mov_i32(REG(dest), REG(src));\n\n            }\n\n            break;\n\n        case 0x03: /* jsra */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc + 6);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n\n\n                gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2));\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x04: /* ret */\n\n            {\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                /* The new $sp is the old $fp.  */\n\n                tcg_gen_mov_i32(REG(1), REG(0));\n\n\n\n                /* Pop the frame pointer.  */\n\n                tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n\n\n                /* Pop the return address and skip over the static chain\n\n                   slot.  */\n\n                tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t1);\n\n\n\n                tcg_temp_free_i32(t1);\n\n\n\n                /* Jump... */\n\n                tcg_gen_exit_tb(0);\n\n\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x05: /* add.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_add_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x06: /* push */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                tcg_gen_subi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x07: /* pop */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                TCGv t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx);\n\n                tcg_gen_addi_i32(t1, REG(a), 4);\n\n                tcg_gen_mov_i32(REG(a), t1);\n\n                tcg_temp_free_i32(t1);\n\n            }\n\n            break;\n\n        case 0x08: /* lda.l */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x09: /* sta.l */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0a: /* ld.l (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld32u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0b: /* st.l */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x0c: /* ldo.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld32u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0d: /* sto.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st32(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x0e: /* cmp */\n\n            {\n\n                int a  = (opcode >> 4) & 0xf;\n\n                int b  = opcode & 0xf;\n\n\n\n                tcg_gen_mov_i32(cc_a, REG(a));\n\n                tcg_gen_mov_i32(cc_b, REG(b));\n\n            }\n\n            break;\n\n        case 0x19: /* jsr */\n\n            {\n\n                int fnreg = (opcode >> 4) & 0xf;\n\n\n\n                /* Load the stack pointer into T0.  */\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_movi_i32(t1, ctx->pc+2);\n\n\n\n                /* Make space for the static chain and return address.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 8);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(t1, REG(1), ctx->memidx);\n\n\n\n                /* Push the current frame pointer.  */\n\n                tcg_gen_subi_i32(t2, REG(1), 4);\n\n                tcg_gen_mov_i32(REG(1), t2);\n\n                tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx);\n\n\n\n                /* Set the pc and $fp.  */\n\n                tcg_gen_mov_i32(REG(0), REG(1));\n\n                tcg_gen_mov_i32(cpu_pc, REG(fnreg));\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x1a: /* jmpa */\n\n            {\n\n                tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1b: /* ldi.b (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1c: /* ld.b (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld8u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1d: /* lda.b */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x1e: /* st.b */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x1f: /* sta.b */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x20: /* ldi.s (immediate) */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n                tcg_gen_movi_i32(REG(reg), val);\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x21: /* ld.s (register indirect) */\n\n            {\n\n                int src  = opcode & 0xf;\n\n                int dest = (opcode >> 4) & 0xf;\n\n\n\n                tcg_gen_qemu_ld16u(REG(dest), REG(src), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x22: /* lda.s */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x23: /* st.s */\n\n            {\n\n                int dest = (opcode >> 4) & 0xf;\n\n                int val  = opcode & 0xf;\n\n\n\n                tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx);\n\n            }\n\n            break;\n\n        case 0x24: /* sta.s */\n\n            {\n\n                int val = (opcode >> 4) & 0xf;\n\n\n\n                TCGv ptr = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx);\n\n                tcg_temp_free_i32(ptr);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x25: /* jmp */\n\n            {\n\n                int reg = (opcode >> 4) & 0xf;\n\n                tcg_gen_mov_i32(cpu_pc, REG(reg));\n\n                tcg_gen_exit_tb(0);\n\n                ctx->bstate = BS_BRANCH;\n\n            }\n\n            break;\n\n        case 0x26: /* and */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_and_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x27: /* lshr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shr_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x28: /* ashl */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_shl_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x29: /* sub.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_sub_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2a: /* neg */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_neg_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2b: /* or */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_or_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2c: /* not */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_not_i32(REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2d: /* ashr */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv sv = tcg_temp_new_i32();\n\n                tcg_gen_andi_i32(sv, REG(b), 0x1f);\n\n                tcg_gen_sar_i32(REG(a), REG(a), sv);\n\n                tcg_temp_free_i32(sv);\n\n            }\n\n            break;\n\n        case 0x2e: /* xor */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_xor_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x2f: /* mul.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                tcg_gen_mul_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x30: /* swi */\n\n            {\n\n                int val = cpu_ldl_code(env, ctx->pc+2);\n\n\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(temp, val);\n\n                tcg_gen_st_i32(temp, cpu_env,\n\n                               offsetof(CPUMoxieState, sregs[3]));\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_SWI);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x31: /* div.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_div(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x32: /* udiv.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x33: /* mod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_rem_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x34: /* umod.l */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n                tcg_gen_remu_i32(REG(a), REG(a), REG(b));\n\n            }\n\n            break;\n\n        case 0x35: /* brk */\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BREAK);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n            }\n\n            break;\n\n        case 0x36: /* ldo.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld8u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x37: /* sto.b */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st8(REG(b), t1, ctx->memidx);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x38: /* ldo.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x39: /* sto.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        default:\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n             }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return length;\n\n}\n", "idx": 2190, "substitutes": {"cpu": ["proc", "core", "cp", "alloc", "ork", "pc", "xc", "nc", "conn", "pu", "upt", "hw", "np", "onet", "CPU", "gpu", "node", "pp", "processor", "linux", "hap", "aq", "cmp", "cum", "cam", "cv", "aco", "gc", "apache", "clock", "cu", "cc", "process", "ct", "ck", "ac", "mem", "jac"], "ctx": ["proc", "cp", "ctrl", "cas", "alloc", "jp", "pc", "xc", "nc", "bc", "tk", "conn", "kh", "hw", "window", "np", "index", "txt", "cfg", "crit", "cb", "act", "x", "tx", "kt", "sc", "cmp", "config", "ctl", "kw", "context", "tc", "cv", "xp", "setup", "comp", "std", "obj", "pkg", "gc", "loc", "cu", "cc", "nt", "wx", "ct", "Context", "ck", "mc", "jac", "cmd", "sp"], "env": ["proc", "ec", "eas", "er", "buf", "gear", "code", "next", "conn", "ent", "eh", "ev", "init", "window", "vas", "node", "cfg", "vt", "viron", "environment", "nv", "tx", "neck", "pe", "entry", "priv", "dev", "scope", "config", "end", "conf", "context", "ptr", "en", "equ", "EN", "gov", "obj", "eng", "map", "cmd"], "opcode": ["bitCode", "OPcode", "opertext", "hopmode", " opCode", "hoptag", "coptag", "ipCode", "operse", "opertag", "pc", "opstr", "opercode", "hoplink", "opCode", "opc", "pcode", "opercoded", "bitaque", "opcoded", "Opaque", "ipcode", "OPCode", "OPaque", "hopc", "optag", " opcoded", "hopse", "OpCode", "wordcode", "operstr", "wordcoded", "opermode", "hoptext", "opaque", "coptext", "pse", "opmode", "operCode", "wordse", "Opc", " opc", "opse", "Opse", "ipc", "OPse", "operc", "optext", " opmode", "oplink", "hopcode", "operbyte", " opse", "opbyte", "copbyte", " opstr", "plink", "hopstr", "bitcode", "bitse", "operlink", "copcode", "hopCode", "Opcode", "hopbyte"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)\n\n{\n\n    int rex;\n\n\n\n    if (opc & P_GS) {\n\n        tcg_out8(s, 0x65);\n\n    }\n\n    if (opc & P_DATA16) {\n\n        /* We should never be asking for both 16 and 64-bit operation.  */\n\n        assert((opc & P_REXW) == 0);\n\n        tcg_out8(s, 0x66);\n\n    }\n\n    if (opc & P_ADDR32) {\n\n        tcg_out8(s, 0x67);\n\n    }\n\n\n\n    rex = 0;\n\n    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */\n\n    rex |= (r & 8) >> 1;                /* REX.R */\n\n    rex |= (x & 8) >> 2;                /* REX.X */\n\n    rex |= (rm & 8) >> 3;               /* REX.B */\n\n\n\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n\n       that are ORed in merely indicate that the REX byte must be present;\n\n       those bits get discarded in output.  */\n\n    rex |= opc & (r >= 4 ? P_REXB_R : 0);\n\n    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);\n\n\n\n    if (rex) {\n\n        tcg_out8(s, (uint8_t)(rex | 0x40));\n\n    }\n\n\n\n    if (opc & (P_EXT | P_EXT38)) {\n\n        tcg_out8(s, 0x0f);\n\n        if (opc & P_EXT38) {\n\n            tcg_out8(s, 0x38);\n\n        }\n\n    }\n\n\n\n    tcg_out8(s, opc);\n\n}\n", "idx": 2195, "substitutes": {"s": ["sys", "ls", "S", "q", "stats", "er", "c", "sg", "is", "sv", "ss", "p", "es", "g", "n", "vs", "ses", "ers", "ds", "qs", "m", "b", "fs", "us", "tes", "sc", "ps", "its", "js", "ns", "bs", "sw", "ims", "w", "e", "ms", "as", "cs", "ts", "ains", "ies", "ties", "hs", "sts", "rs", "v", "h", "gs", "sb", "ats", "ins", "os", "sq", "t", "tains"], "opc": ["optca", "Opsc", "optc", "iopr", "opcc", "copct", "coppc", "hoppc", "copca", "opcu", " opcs", "mpct", "Opca", "OPci", "hopcc", "opct", "ipc", "opfc", "opgc", "optrc", "Opcp", "Opdc", "mppc", "iopci", "OPdc", "copfc", "opC", "ipca", "opsc", "copcc", "Opcs", "ipgc", "Opgc", "mpc", "optfc", " opr", " opcp", "hopct", "Opc", "OPcs", "hopci", " opcu", "oprc", "opr", "OpC", "optsc", " opct", "copcs", "Oprc", "optci", "optdc", "iopC", "OPct", " opci", "copC", "Opfc", "opdc", "hopcu", "OPfc", "opcs", "mpfc", "hopcs", "opci", "copci", "ipcu", "copsc", "OPcc", "oppc", "copcp", "iopct", "opcp", "ipcs", "OPr", "opca", "iopc", "OPrc", "hopc", " opC", "OPca", "Oppc", "hopgc", "OPpc", "ipct", "OPc", "copc", "iopcs", "Opci", "OPC", "hopca"], "r": ["mr", "d", "q", "l", "er", "ro", "c", "p", "g", "n", "ru", "rb", "m", "res", "i", "b", "u", "ra", "pr", "y", "w", "e", "rr", "rx", "rt", "or", "reg", "ar", "ry", "v", "h", "f", "t", "re", "R"], "rm": ["mr", "mt", "rd", "arm", "cr", "lr", "mb", "rim", "bm", "rom", "RM", "pm", "mg", "mp", "xa", "cb", "rb", "m", "mx", "tx", "md", "tm", "mem", "xe", "dm", "err", "mk", "rr", "rx", "rl", "nm", "rt", "sm", "reg", "mn", "rpm", "orm", "mi", "ml", "rem", "cm", "re", "rn"], "x": ["q", "l", "xc", "z", "p", "n", "lex", "dx", "xi", "xs", "xa", "ax", "m", "ox", "i", "b", "mx", "tx", "xe", "ex", "xy", "y", "xt", "w", "xx", "rx", "ix", "ry", "v", "wx", "f", "st", "t", "re", "X"], "rex": ["aux", "eas", "rez", "xc", "xb", "xxxx", " dex", "rison", "lex", "dx", "docker", "xi", "axe", "broad", "xs", "flex", "maybe", "xa", "ax", "fax", "pex", " re", " ex", "ox", "rax", "com", "mx", "res", "nex", "EX", "exe", "gb", "gre", "bolt", "def", "xe", "ex", "xy", "rett", "gex", "euro", "rew", "xx", "nexus", "el", "crow", " Rex", "cre", "Rex", "rx", "io", "xd", "bytes", "wx", "wr", "sky", "xxxxxxxx", "yes", "iban", "ye", "xes", "ck", "des", "re", "aus", "dis", "json", "oxy"]}}
{"project": "qemu", "commit_id": "d0d5d0e31a874d592741a088c2c5071bae164dbf", "target": 1, "func": "qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n\n                            uint64_t bytes, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QEMUIOVector hd_qiov;\n\n    struct iovec iov;\n\n    z_stream strm;\n\n    int ret, out_len;\n\n    uint8_t *buf, *out_buf;\n\n    uint64_t cluster_offset;\n\n\n\n    if (bytes == 0) {\n\n        /* align end of file to a sector boundary to ease reading with\n\n           sector based I/Os */\n\n        cluster_offset = bdrv_getlength(bs->file->bs);\n\n        return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL);\n\n    }\n\n\n\n    buf = qemu_blockalign(bs, s->cluster_size);\n\n    if (bytes != s->cluster_size) {\n\n        if (bytes > s->cluster_size ||\n\n            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)\n\n        {\n\n            qemu_vfree(buf);\n\n            return -EINVAL;\n\n        }\n\n        /* Zero-pad last write if image size is not cluster aligned */\n\n        memset(buf + bytes, 0, s->cluster_size - bytes);\n\n    }\n\n    qemu_iovec_to_buf(qiov, 0, buf, bytes);\n\n\n\n    out_buf = g_malloc(s->cluster_size);\n\n\n\n    /* best compression, small window, no zlib header */\n\n    memset(&strm, 0, sizeof(strm));\n\n    ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n\n                       Z_DEFLATED, -12,\n\n                       9, Z_DEFAULT_STRATEGY);\n\n    if (ret != 0) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    strm.avail_in = s->cluster_size;\n\n    strm.next_in = (uint8_t *)buf;\n\n    strm.avail_out = s->cluster_size;\n\n    strm.next_out = out_buf;\n\n\n\n    ret = deflate(&strm, Z_FINISH);\n\n    if (ret != Z_STREAM_END && ret != Z_OK) {\n\n        deflateEnd(&strm);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    out_len = strm.next_out - out_buf;\n\n\n\n    deflateEnd(&strm);\n\n\n\n    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {\n\n        /* could not compress: write normal cluster */\n\n        ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        goto success;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    cluster_offset =\n\n        qcow2_alloc_compressed_cluster_offset(bs, offset, out_len);\n\n    if (!cluster_offset) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    cluster_offset &= s->cluster_offset_mask;\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    iov = (struct iovec) {\n\n        .iov_base   = out_buf,\n\n        .iov_len    = out_len,\n\n    };\n\n    qemu_iovec_init_external(&hd_qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n\n    ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\nsuccess:\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(buf);\n\n    g_free(out_buf);\n\n    return ret;\n\n}\n", "idx": 2213, "substitutes": {"s": ["sys", "ls", "j", "S", "abilities", "stats", "l", "is", "sv", "ss", "p", "es", "als", "settings", "n", "vs", "details", "xs", "ses", "ds", "i", "b", "fs", "less", "aws", "ps", "its", "parts", "js", "bs", "ns", "sw", "bis", "ms", "as", "cs", "ts", "ies", "changes", "bes", "hs", "sts", "rs", "bits", "gs", "sb", "ins", "sn", "os", "sq", "ats", "args", "so", "states", "ssl", "self", "sp"], "hd_qiov": ["hd_iqiour", "hd_giov", "hd_gigroup", "hd_qigroup", "hd_qqrir", "hd_qiour", "hd_qqiov", "hd_iqiov", "hd_grir", "hd_qqiour", "hd_iqrir", "hd_iqigroup", "hd_giour", "hd_qqigroup", "hd_qrir"], "iov": ["iao", "uj", "conv", "rov", "roman", "rolet", "ibl", "rir", "ij", "vec", "iv", "tv", "chrom", "ovi", "iour", "iro", "IO", "iop", "io", "river", "ibr", "rio", "nov", "iev", "sbm", "iol", "ivic", "vector"], "strm": [" ostrm", "strr", " stdm", "strrm", "glmt", "trmt", "trm", "stringam", "stim", "srmat", "stemm", "arrsm", "schemm", "stram", " stmm", "arrm", "strdm", "stmo", " STRdm", " strM", "stemim", "srmo", "STRM", "strmo", "STRm", "charum", "stmt", "frmp", " strmp", "arrmm", "strf", "sram", "stringim", " ostrdm", " strgm", "trM", "strM", "stringmt", "strim", "stringmat", "strsm", "srsm", " stm", "slM", "srim", "schesm", "STRf", " STRmd", "frr", "Strmt", " ostrmd", "stemmp", "crmt", "stm", "charf", "crM", "charm", "crm", " stmd", "srcm", "Strm", " strsm", "strn", "strman", "stemgm", "STRmt", " strmt", "sprn", "stringmo", "slmt", "stcm", "frM", "stringcm", "sprM", "glrm", "STRum", "stringsm", "glum", " strmat", "schem", "Strsm", "stgm", "strgm", "glm", "schemt", "stringm", " STRm", "charmt", "slsm", "sprmt", "trn", " ostrmm", " strman", "sprrm", "strmat", "strmt", "strmp", "StrM", "sprm", "crsm", " strum", "sprum", "slm", "stam", " strf", "stemman", "strmd", "stemM", "frm", "strcm", " STRmm", "arrmt", " strr", "stman", "stemr", "STRn", "STRrm", "strmm", " strim", "strum", "srm", "stringgm", "stringmm"], "ret": ["mt", "RET", "try", "summary", "ext", "out", " resp", "gt", " fut", "ber", " Ret", "opt", "pas", "ry", "backed", "hash", "reset", "resp", "mem", "re", "back", "net", " res", "result", "deg", "sat", "ll", "Ret", "pat", "rev", "ter", "alt", "del", "tech", "nt", " alt", "arg", "tr", "cert", "elt", "j", "cat", "dt", " RET", "fun", "ref", "RT", "res", "att", "prot", "error", "err", "vet", "ts", "pt", "val", "rets", "det", "rem", "len", "cmd", "sys", "after", "leg", "ft", "red", "cont", "def", "ert", "desc", "rt", "print", "pret", "nz", "t"], "out_len": ["out32lim", "out___loc", " out_mult", " out_ln", "out___len", "out___mult", "out_loc", " out_lim", "out_lim", "out_ln", "out32ln", "out_mult", "out32len", " out_loc"], "buf": ["doc", "br", "batch", "data", "alloc", "ctr", "xff", "tmp", "mb", "bc", "img", "init", "window", "ref", "pb", "result", "box", "lim", "iter", "out", "txt", "cb", "rb", "var", "b", "msg", "orig", "off", "seq", "bar", "vec", "bs", "uf", "length", "map", "block", "buffer", "cv", "err", "ctx", "nom", "ob", "pkg", "Buffer", "bin", "emb", "wb", "offset", "queue", "fb", "bytes", "raw", "Buff", "mem", "len", "cmd", "buff"], "out_buf": ["in_buf", " out_buffer", "out2cb", " out_cb", "in_cb", "out2buf", "out2buffer", " out_queue", "out_uf", "out_queue", "out_cb", "out_buffer", " out_uf", "in_buffer", "out2uf", "in_uf"], "cluster_offset": ["cluster_length", "clust_pos", "cluster_origin", "cluster_pos", "cluster__origin", "cluster_size", "clocker_length", "cluster8Offset", "cluster8position", "cluster_Offset", "clust_origin", "clocker_size", "cluster__position", "cluster8offset", "clust_offset", "cluster__offset", "cluster__Offset", "clocker_offset", "cluster_shift", "clocker_shift", "clust_Offset", "clust_position", "cluster8origin", "cluster_position"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 2229, "substitutes": {"ctx": ["batch", "cp", "wcs", "today", "work", "tmp", "jp", "xc", "nc", "bc", "bh", "conn", "p", "kb", "kh", "hw", "txt", "np", "xs", "kl", "cfg", "bp", "cb", "act", "x", "tx", "kt", "sc", "gt", "etc", "req", "cmp", "history", "xy", "js", "kw", "ctl", "cf", "context", "xp", "mk", "dl", "cpu", "pkg", "obj", "anc", "ind", "gc", "std", "abc", "cc", "urg", "nt", "wx", "ct", "cm", "ck", "warn", "prefix", "iat", "tc", "jac", "cmd"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2246, "substitutes": {"ysrc": ["inssrc", "essrc", "mysusc", "ysr", "iessrc", "syssrc", "myssrc", "ysusc", "iesource", "iesrc", "insr", "insrc", "esusc", "sysrc", "yssrc", "insusc", "mysrc", "mysource", "sysusc", "esource", "sysr", "iesusc", "ysource", "iesr", "esrc"], "usrc": ["tssrc", "tsrt", "usrs", "aussrc", "ausrs", "ausrc", "usrt", "tsrc", "usesource", " usource", "usersource", "usesrs", "ussrc", "userssrc", "usersrc", " usrt", "usesrc", " ussrc", "usessrc", "usersrt", "usource", "tsource", " usrs", "ausource"], "vsrc": [" vctr", "vserv", "fsource", "Vsrc", " vsource", "cvsource", "sctr", "vrc", "cvsrc", " vaddr", "Vaddr", "fsrc", "vctr", "fserv", "vsource", "Vrc", "cvserv", "vaddr", " vrc", "saddr", "ssrc", "Vctr", "src", "frc", " vserv", "cvrc"], "dst": [" ddest", "dcr", "lsts", "dsdest", "dost", "sdcr", "sdsts", "ddest", "dust", "sddest", "lcr", "lst", "doST", "yST", "dsst", "dST", " dcr", "doust", "dsts", "dodest", "yust", "ydest", "yst", "ldest", "sdst", " dsts", "dsST", "dsust"], "height": ["rows", "ty", "zh", "size", "he", "Height", "inches", "count", "gravity", "uh", "resolution", "cy", "build", "window", "wh", "dist", "yt", "gy", "html", "family", "volume", "ih", "shape", "hei", "history", "y", "ch", "w", " heights", "headers", "radius", "hz", "depth", "loss", "ows", "h", "hang", "stroke", "dim", "density", "length", "gh", "ht"], "lumStride": ["lumstr", "lumRestride", "lumStbe", "lumStrat", "lumStrride", "limStr", "limStrr", "limStrat", "lumRestrat", "lumstbe", "lumRestr", "limStrbit", "lumstride", "limStbit", "lumSTide", "lumstrat", "limStrride", "lumstbit", "limStbe", "limStrrat", "lumStbit", "lumRestide", "limStride", "lumSTbit", "lumStrr", "lumStrrat", "lumStrbe", "lumStr", "limStrbe", "lumSTride", "lumStrbit", "lumSTbe", "limStide", "lumstide", "lumStide"], "chromStride": ["chromStrr", "chromStine", "chromStrlen", "chromStrip", "chromStide", "romStrine", "romStride", "chromstr", "chromStlen", "chromChrip", "chromSTr", "chromstride", "chromRestide", "chromSTride", "romStrride", "romStide", "chromStrine", "chromChine", "chromRestrip", "chromSTlen", "romStlen", "romStine", "chromChride", "romStr", "chromStrride", "romStrrip", "chromstlen", "romStrip", "chromstide", "chromChide", "romStrlen", "chromRestride", "chromSTide", "chromStrrip", "chromRestine", "romStrr", "chromStr"], "dstStride": ["destStrr", "dstStrip", "dndStr", "dstRestrip", "destStride", "dndStrip", "dstChrip", "dstRestide", "destStide", "dstRestride", "dndStrride", "dstStr", "dndStrrip", "dststide", "destStrrip", "dststr", "dstRestr", "dstStrrip", "dstChr", "dndStride", "dstStrride", "destStrride", "dstChide", "destStr", "dndStrr", "destStrip", "dstStrr", "dststrip", "dstStide", "dstChride", "dststride", "dndStide"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static gboolean ga_channel_open(GAChannel *c, const gchar *path,\n\n                                GAChannelMethod method, int fd)\n\n{\n\n    int ret;\n\n    c->method = method;\n\n\n\n    switch (c->method) {\n\n    case GA_CHANNEL_VIRTIO_SERIAL: {\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NONBLOCK\n\n#ifndef CONFIG_SOLARIS\n\n                           | O_ASYNC\n\n#endif\n\n                           );\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n#ifdef CONFIG_SOLARIS\n\n        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);\n\n        if (ret == -1) {\n\n            g_critical(\"error setting event mask for channel: %s\",\n\n                       strerror(errno));\n\n            close(fd);\n\n            return false;\n\n        }\n\n#endif\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_ISA_SERIAL: {\n\n        struct termios tio;\n\n\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n        tcgetattr(fd, &tio);\n\n        /* set up serial port for non-canonical, dumb byte streaming */\n\n        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |\n\n                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |\n\n                         IMAXBEL);\n\n        tio.c_oflag = 0;\n\n        tio.c_lflag = 0;\n\n        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;\n\n        /* 1 available byte min or reads will block (we'll set non-blocking\n\n         * elsewhere, else we have to deal with read()=0 instead)\n\n         */\n\n        tio.c_cc[VMIN] = 1;\n\n        tio.c_cc[VTIME] = 0;\n\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n\n        tcflush(fd, TCIFLUSH);\n\n        tcsetattr(fd, TCSANOW, &tio);\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_UNIX_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n\n\n            fd = unix_listen(path, NULL, strlen(path), &local_err);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    case GA_CHANNEL_VSOCK_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n            SocketAddress *addr;\n\n            char *addr_str;\n\n\n\n            addr_str = g_strdup_printf(\"vsock:%s\", path);\n\n            addr = socket_parse(addr_str, &local_err);\n\n            g_free(addr_str);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n\n\n            fd = socket_listen(addr, &local_err);\n\n            qapi_free_SocketAddress(addr);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    default:\n\n        g_critical(\"error binding/listening to specified socket\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2265, "substitutes": {"c": ["ec", "d", "cp", "cr", "fc", "l", "cd", "code", "p", "g", "n", "dc", "r", "s", "ci", "m", "com", "b", "ce", "C", "cont", "sc", "form", "cache", "cur", "can", "config", "content", "ch", "cf", "cv", "e", "cam", "cs", "ctx", "con", "co", "anc", "gc", "v", "abc", "cc", "h", "ct", "cl", "o", "f", "rc", "cm", "lc", "ac", "t", "mc", "this", "self"], "path": ["template", "d", "mount", "eth", "key", "prop", "host", "format", "directory", "p", "Path", "route", "ref", "ath", "txt", "dir", "r", "kind", "m", "password", "full", "entry", "ATH", "ex", "config", "file", "local", "context", "w", "wd", "pattern", "name", "pkg", "bin", "pt", "loc", "PATH", "root", "rc", "th", "prefix", "join", "cmd", "self", "chain"], "method": ["id", "message", "key", "func", "prop", "status", "instance", "code", "op", "format", "use", "mask", "port", "source", "sign", "sort", "service", "attr", "package", "Method", "mode", "set", "action", "mid", "m", "md", "hod", "access", "tm", "mod", "type", "METHOD", "mem", "time", "man", "call", "version", "level", "command", "name", "via", "nom", "function", "month", "go", "sm", "manager", "class", "med", "member", "magic", "process", "channel", "tr", "th", "direction", "master", "module", "property"], "fd": ["id", "ff", "handle", "port", "unc", "fa", "td", "lf", "form", "ctl", "cf", "disk", "wd", "df", "wait", "ind", " df", "ud", "fee", "handler", "f", "fn", "socket", "ld", "fp", "dial", "d", "FH", "bd", "tif", "dir", "ds", "cb", "wind", "fed", "fl", "end", "file", "ptr", "stream", "ln", "FD", " dst", "uf", "std", "cd", "dt", "buf", "dd", "fun", " fid", "dc", "dat", "gd", "fi", "hd", "dl", "ctx", "fr", "db", "fb", "draw", "erd", "bf", "pid", "fm", "fc", "func", "nd", "fin", "fs", "dra", "writer", "sd", "dr", "gz", " ff", "lc", "dn"], "ret": ["mt", "RET", "try", "nil", "out", "proxy", "gt", "locked", " Ret", "got", "true", "pas", "backed", "rm", "f", "reset", "resp", "re", "back", "net", "result", "failed", "sat", "num", "valid", "ll", "Ret", "final", "ured", "alt", "ter", "get", "grain", "nt", "tr", "cert", "elt", "secure", "std", "verified", "j", "nl", " RET", "fun", "ref", "bool", "lt", "res", "entry", "vet", "val", "fail", "rets", "det", "rem", "flag", "success", "func", "status", "Return", "rect", "url", "fin", "lit", "ft", "red", "cont", "def", "ert", "nat", "desc", "rt", "reg", "print", "t"], "tio": ["nio", "otiol", " tiao", " tao", "tsao", "mintiol", " tii", "Tio", "nso", " tios", "cIO", "TIO", "ertio", "vtIO", "mintao", "ftio", "qtiao", "niop", "wtiol", "ertao", "Tso", "tempia", "ftia", "Tios", " tiot", "Tiot", "mintiot", "tif", "vtii", " tiol", "wtiao", "wtif", "ertiot", "nios", "Tao", " tso", "tsio", "wtio", "nIO", " tia", "tii", "otiao", "ertiol", "ciop", "tsia", "tiot", "vtia", "cios", "otIO", "tempiao", "tiol", "niol", "tios", "tia", "Tiol", "ftii", "wtIO", "Tiop", "tempao", "qtiot", " tIO", "mintio", "vtao", "tempio", "Tia", "ftIO", "nao", "tiao", "tao", "nif", "cio", "nia", "tiop", "wtios", "qtia", " tif", "qtio", "tIO", "tsios", "vtio", "tempiot", "tso", "vtiao", "otio"]}}
{"project": "qemu", "commit_id": "17ad9b358bceba78ae80f2963c6036eab726010c", "target": 0, "func": "static int ram_save_block(QEMUFile *f)\n\n{\n\n    RAMBlock *block = last_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n\n\n    if (!block)\n\n        block = QLIST_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                    DIRTY_MEMORY_MIGRATION)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                      DIRTY_MEMORY_MIGRATION);\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n            }\n\n\n\n            break;\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QLIST_NEXT(block, next);\n\n            if (!block)\n\n                block = QLIST_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_block || offset != last_offset);\n\n\n\n    last_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 2280, "substitutes": {"f": ["fp", "d", "fx", "fw", "q", "fc", "ff", "l", "c", "z", "g", "xf", "fac", "sf", "out", "lf", "b", "af", "fs", "ft", "tf", "ef", "fi", "conf", "file", "y", "cf", "rf", "w", "e", "df", "fr", "F", "fb", "v", "h", "o", "fn", "bf", "ac", "t", "of", "fm", "uf", "fo", "fd"], "block": ["id", "piece", "mb", "object", "blocking", "node", "out", "set", "load", "lock", "volume", "book", "man", "version", "buffer", "response", "bo", "an", "group", "hash", "channel", "line", "batch", "number", "list", "shift", "bc", "row", "box", "blank", "link", "full", "relation", "none", "check", "tag", "file", "um", "OCK", "name", "bus", "un", "offset", "mm", "range", "frame", "position", "length", "byte", "chain", "word", "buf", "mask", "view", "record", "index", "BL", "header", "condition", "part", "cache", "snap", "type", "network", "comment", "empty", "address", "loop", "model", "point", "prefix", "map", "Block", "image", "holder", "status", "instance", "no", "commit", "r", "label", "b", "pack", "profile", "start", "def", "scope", "config", "ip", "bridge", "null", "blocks", "bl", "field", "cl", "event", "raw", "state", "base", "join", "module"], "mr": ["mt", "br", "fp", "usr", "MR", "gr", "cr", "lr", "mb", "rg", "pc", "vr", "bm", "hr", "drm", "r", "mp", "rb", "mid", "m", "mx", "ur", "mer", "wm", "asm", "tm", "pr", "kr", "sr", "mk", "ms", "shr", "fm", "rr", "adr", "rl", "hm", "mn", "dr", "rs", "rm", "mm", "ml", "ocr", "Mr", "cm", "tr", "gm", "mc", "rar", "rn"], "p": ["fp", "j", "cp", "q", "d", "art", "lp", "wp", "l", "jp", "pc", "c", "n", "P", "pb", "np", "r", "pi", "bp", "pp", "pointer", "s", "m", "page", "b", "i", "part", "pos", "pe", "vp", "pad", "pr", "ps", "tp", "ip", "pa", "ptr", "ap", "press", "pkg", "pt", "v", "par", "point", "t", "pid", "ping", "sp"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n\n    size_t len)\n\n{\n\n    hwaddr mapped_len = 0;\n\n    struct iovec *ventry;\n\n    assert(pkt);\n\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n\n\n    if (!len) {\n\n        return true;\n\n     }\n\n\n\n    ventry = &pkt->raw[pkt->raw_frags];\n\n    mapped_len = len;\n\n\n\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n\n    ventry->iov_len = mapped_len;\n\n    pkt->raw_frags += !!ventry->iov_base;\n\n\n\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2297, "substitutes": {"pkt": ["npdu", "repkt", "cnt", "Packet", "ykt", "prokt", "npact", "preacket", "repwk", " ptx", "prekt", " pct", "ppconn", " pet", "pdu", " pck", "ynt", "proacket", "repct", "pact", " pwk", "Pconn", "tpkt", "ckt", "produ", "Pkt", "ppnt", "ppkt", "proact", " pdu", "fconn", "packet", " pconn", "pconn", " pact", "facket", "yct", "pct", "fkt", "Pct", "Pck", "ctx", "Pet", "pnt", " packet", "pwk", "yacket", "prent", "pck", "repacket", "Pnt", "preconn", "pet", "ppet", "npkt", " pnt", "fct", "cacket", "npacket", "ppck", "tpct", "Ptx", "tpwk", "ptx", "ppacket", "tpacket"], "pa": ["ka", "ma", "lp", "po", "pc", "p", "pu", "la", "ca", "pi", "bp", "pol", "sa", "Pa", "ara", "eta", "va", "ra", "pe", "pai", "pr", "ps", "ta", "ppa", "ap", "ea", "ba", "ia", "ha", "pet", "opa", "ica", "mi", "pan", "ai", "ada", "na", "apa", "PA"], "len": [" length", "fp", "ls", "lp", "l", "et", "size", "list", "L", "count", "nl", "all", "p", "n", "lic", "kl", "lt", "lim", "Len", "pp", "li", "lf", "fin", "num", "pos", "gt", "ll", "lan", "cmp", "pad", "vec", "t", "length", "lon", "wl", " l", "hl", "al", "compl", "cap", "el", "en", "pl", "ln", "str", "coll", "pre", "nt", "padding", "h", " le", " clen", "resp", "wid", "elt", "enc", "mem", "sp"], "ventry": [" ventre", "venty", "identery", "vestdry", "questried", "therery", "victric", "gentary", "therant", "renttry", "vestry", "genty", " ventity", "rentry", "ventity", " ventdry", "ventRY", "rentRY", " venty", " venttry", "emptity", "victry", " ventri", "emptre", "identy", "montri", "ventdry", "ventric", "antric", "montried", "antried", "emptry", "rentity", "rentre", "ventery", "identried", "ventant", "ventre", "identry", "virtry", "gentry", "montry", "gentRY", "antry", "rentary", "renty", "questery", "thertry", "venttry", "virtant", "gentant", "virttry", "ventri", "ventried", "therry", "montdry", "victried", "vestri", " ventary", " ventRY", "vestried", "gentery", " ventried", "ventary", "victy", "empty", "questy", "virtery", "anty", "gentried", "genttry", "gentric", "questry"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *buf1, const uint16_t *ubuf0,\n\n                     const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                     const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                     const uint16_t *abuf1, uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target)\n\n{\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n\n\n        output_pixels(i * 4, Y1, U, Y2, V);\n\n    }\n\n}\n", "idx": 2298, "substitutes": {"i": ["multi", "batch", "j", "id", "q", "key", "l", "ii", "status", "ki", "ji", "c", "item", "is", "p", "sim", "g", "xi", "ic", "pi", "index", "me", "qi", "li", "ci", "ami", "m", "ei", "x", "u", "cli", "ui", "info", "phi", "it", "gi", "ij", "ip", " ii", "oi", "y", "bi", "im", "iu", "ti", "span", "name", "ind", "go", "uri", "io", "ix", "ia", "zi", "in", "mi", "o", "ini", "di", "by", "ai", "I", "si", "\u0438", "ri", "t", "a", "my", "this", "chain"]}}
{"project": "FFmpeg", "commit_id": "2207ea44fb4fad4d47646a789bc244e3e84c1726", "target": 0, "func": "static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,\n\n                                              int linesize,\n\n                                              int block_w, int block_h,\n\n                                              int src_x, int src_y,\n\n                                              int w, int h,\n\n                                              emu_edge_core_func *core_fn)\n\n{\n\n    int start_y, start_x, end_y, end_x, src_y_add = 0;\n\n\n\n    if (src_y >= h) {\n\n        src_y_add = h - 1 - src_y;\n\n        src_y     = h - 1;\n\n    } else if (src_y <= -block_h) {\n\n        src_y_add = 1 - block_h - src_y;\n\n        src_y     = 1 - block_h;\n\n    }\n\n    if (src_x >= w) {\n\n        src   += w - 1 - src_x;\n\n        src_x  = w - 1;\n\n    } else if (src_x <= -block_w) {\n\n        src   += 1 - block_w - src_x;\n\n        src_x  = 1 - block_w;\n\n    }\n\n\n\n    start_y = FFMAX(0, -src_y);\n\n    start_x = FFMAX(0, -src_x);\n\n    end_y   = FFMIN(block_h, h-src_y);\n\n    end_x   = FFMIN(block_w, w-src_x);\n\n    av_assert2(start_x < end_x && block_w > 0);\n\n    av_assert2(start_y < end_y && block_h > 0);\n\n\n\n    // fill in the to-be-copied part plus all above/below\n\n    src += (src_y_add + start_y) * linesize + start_x;\n\n    buf += start_x;\n\n    core_fn(buf, src, linesize, start_y, end_y,\n\n            block_h, start_x, end_x, block_w);\n\n}\n", "idx": 2300, "substitutes": {"buf": ["fp", "batch", "br", "alloc", "ctr", "cp", "ff", "tmp", "addr", "bc", "bh", "port", "img", "ref", "out", "cb", "rb", "coord", "b", "pack", "pos", "seq", "cache", "cur", "at", "vec", "uf", "end", "block", "buffer", "cv", "ptr", "cam", "copy", "ctx", "bg", "dest", "Buffer", "bin", "db", "loc", "queue", "v", "bl", "rc", "bn", "Buff", "mem", "map", "buff"], "src": ["proc", "sys", "input", "inst", "usr", "ctr", "inner", "rest", "addr", "source", "stat", "conv", "img", "sort", "sl", "sup", "r", "txt", "s", "send", "url", "rb", "buff", "cb", "b", "ur", "cont", "sc", "rol", "cur", "filename", "syn", "sur", "bs", "ser", "sub", "sr", "iv", "desc", "ptr", "buffer", "stream", "comp", "bg", "dest", "pkg", "bin", "rt", "loc", "rs", "urg", "rc", "sb", "sn", "raw", "ins", "st", "sq", "scan", "sync", "supp"], "linesize": ["linesiz", "linesization", "filesized", "inesiz", " linesiz", " linespace", "pointsize", "linespace", "linesized", "inesized", "pointsizer", "linesIZE", "inesize", "pagespace", "filesIZE", "pagesizer", "elinesized", " linesIZE", "pagesize", "elinesize", "pointsization", " linesization", "pagesization", "inespace", "elinesiz", "elinesIZE", " linesizer", "pointspace", "filespace", "filesize", " linesized", "inesIZE", "linesizer"], "block_w": ["Block_w", " block_wx", "blockletwe", "block_sw", " block_width", "lock_w", "block08wp", "block_iw", "block_wh", " block_wh", "block_we", "chain_iw", "chain_w", "chain_h", "chain_wp", "block_wp", "Block_W", "blockletW", "block_width", "lock_width", "block08h", "block_W", " block_sw", "blockletsw", "block08iw", "lock_h", " block_W", " block_we", "block08w", "block_wx", "lock_W", "Block_wh", "blockletw"], "block_h": ["block4h", "Block_oh", "block_he", "device00rh", "block_y", "Block_w", "blockdbh", "block_host", "device_rh", "bl4w", "device00history", "Block_html", "blockleth", "block5y", "bl_w", "block5h", "chain_host", "bl_hi", "bl_h", "block48bh", "block_wh", "Block_hr", "chain_x", " block_wh", "bl4h", "chain_w", "block48rh", "block_oh", "block_history", "chain_h", "block4hi", "device_y", "blockdbw", " block_bh", "block_x", "block00rh", "block_hr", "block00history", "Block_he", "block4w", "blockdbhr", "block5rh", "bl_y", "block_html", "block_bh", "block48w", "block20h", "device_history", "device00h", "block20oh", "device00y", "bl4y", "block4y", "device_h", "block48h", "block_hi", "block_rh", "blocklethtml", "block20he", "bl4hi", "Block_h", "blockdbhtml", "block00h", " block_rh", "blocklethr", " block_hi", "block20w", "block00y", "block5history", "blockletw"], "src_x": ["srcityy", " src_xi", "srcjix", "sys_xs", "src_xs", "src00xi", "src_j", "start__ex", "src09ex", "src__xf", "src__xi", "src_z", "start__x", "src_xp", "source_z", "src_xt", "start_w", "src00x", "srcjx", "sys_w", " src__y", "source_xf", "src__y", "src_tx", "rc_w", "srcabley", "rc_j", "rc_ex", "src_ex", "src__z", "sys_x", "srcityw", "src_xf", "src_width", "src__xp", " src__x", "src_ix", "rc_xi", "src00xp", "srcablex", "source_x", "src_column", "rc_tx", "start_ex", "rc_rx", "start__w", "source_y", "rc_x", "source_column", "start__y", "srcablej", "srcabletx", "rc_ix", "src_xx", "rc_width", "src__w", " src_xp", "sys_y", "src__ex", "src_w", "srcjxt", "src_rx", " src__xp", "rc_y", "srcjwidth", "rc_xt", "src09xx", "src09rx", " src__xi", "src_xi", "srcityx", "rc_xx", "source_ex", "src09x", "src00y", "src__x", "srcityxs"], "src_y": ["seq_yy", "seq_name", "seedamemy", "src_ty", "feat08ey", "src_ry", "srcamex", "seed_my", "src_h", "lit_yn", "src_yr", "feat08yl", "seed_ty", "src_ch", "feat08y", "src___ry", " src_content", "feat_yl", "lit_yr", "srcjy", "src__y", "src___iy", "start_ye", "srcabley", "src_my", "seq_y", "src08yl", "src_yl", "srcpty", "src08yy", "src___by", "srcablery", "src__ey", "lit_h", "srcablehot", "src___ye", "src_yt", "src___yy", "start_ey", "src_by", "rc_iy", "srcamety", "feat_y", "rc_ch", "feat_ey", " src_ye", "srcjey", "rc_x", " src_yy", " src_hot", "srcamey", "src_ey", "src_hot", "start__y", "start__ey", "src_iy", "src___ly", "src__h", "src08yt", "src___ch", "seedamey", "src_content", "src_yy", "lit_y", "src08y", "src08name", "seed_x", " src_ry", "srcptyn", "rc_y", "src_yn", "src___y", "start_by", "start__h", "src08yn", "src_ly", "seq_yt", "src___hot", "srcableyy", "start_ly", "srcamemy", "srcjh", "seedamety", "srcptyr", "src08ey", "seed_y", "src_name", "start_h", "feat08yn", "seedamex", "src_ye", "feat_yn", "src___x", "srcpth"], "w": ["wcs", "fw", "wp", "l", "ww", "word", "aw", "wn", "p", "wi", "g", "n", "ow", "window", "hw", "r", "wh", "W", "wa", "m", "rw", "x", "nw", "weight", "win", "sw", "wl", "kw", "rew", "wd", "iw", "wb", "ew", "v", "wal", "mm", "wr", "wx", "wt", "wk", "raw", "tw"], "h": ["q", "head", "l", "zh", "ph", "he", "high", "c", "host", "height", "bh", "sh", "z", "p", "kh", "g", "n", "window", "resh", "oh", "ah", "hh", "H", "ish", "r", "m", "b", "x", "ih", "hei", "history", "hub", "y", "ch", "k", "hl", "hd", "rh", "hi", "hal", "hm", "hs", "hz", "v", "ha", "hash", "o", "ho", "th", "gh", "ht"], "core_fn": ["core___func", " core_func", "core_unc", "core_fc", "core___unc", " core_unc", " core_fc", "core___fm", " core_fm", "core_fm", "core___fn", "core_func"], "start_y": ["startxy", "it_Y", "startpyY", "startpyym", "startxsy", "it_sy", "start___y", "it_y", "start___yy", "start__x", "itxY", "start__ys", "start_vy", "start_ye", "start___vy", "startFy", "end_ye", "start_ys", "start___Y", "itxsy", "start_sy", "start_ym", "startpyy", "start_Y", "startFY", "it_ym", "start_yy", "start_ry", "start_ny", "end_ny", " start_yy", " start_ys", "startpysy", "starting_x", "startxY", "start__y", "start__yy", "end_Y", "itxym", "itxy", "startFx", "start___ys", "start___x", "starting_yy", "startxym", "startFny", "starting_y", "end_vy", "starting_ry", "start___ye"], "start_x": ["startxy", "entry_x", "end_ex", "startxxi", "start___lat", "begin_X", "startpyxt", "end_xy", "startxex", "start___xt", "start___y", "entry_xt", "start_lex", " start_ix", "begin_ix", "startxx", "startpyy", "start_ix", "start_ex", "start_X", "end_X", "begin_x", "entrypyxt", "entrypyx", "start_lat", "begin_lex", "entry_y", "start___x", "entrypylat", "entrypyy", "end_xp", "startpyx", "entry_lat", "end_xi", "start_ox", " start_ox", "startpylat", "start_xp", "start_xi", "start_xy", "start_xt"], "end_y": ["end___y", "endjy", "end___ch", "ended_ey", "start_yy", "endjx", "start_ya", "start_ry", "endTy", "end_ny", "ended_ny", "endJy", "end_yy", "endTY", "endJya", "endTey", "ended_Y", "end___x", "end_Y", "end___ry", "end_ya", "end_ry", "endjry", "endjch", "endJyy", "start_Y", "ended_y", "end_ch", "endTny", "start_ch", "end_ey", "endJx"], "end_x": ["end_ex", " end_ax", "END_y", "end___y", "END_x", "end___x", "endxxp", "END_X", "start_ex", "endxx", "endxex", "end_w", " end_ex", " end_w", " end_ox", "end_X", "end___ox", "end_ax", "end_ox", "endxxi", "end_xp", "END_ox", "end_xi", "start_xp", "start_xi", "end___X"]}}
{"project": "FFmpeg", "commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "target": 1, "func": "static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2325, "substitutes": {"c": ["ec", "vc", "d", "cp", "fc", "cr", "cd", "pc", "bc", "nc", "cn", "p", "cal", "n", "dc", "ca", "ci", "mc", "m", "com", "b", "ce", "C", "cont", "etc", "cache", "cur", "call", "conf", "ch", "cf", "w", "e", "cv", "cam", "cs", "ctx", "con", "co", "coll", "enc", "anc", "gc", "v", "abc", "cu", "cc", "h", "ct", "cl", "rc", "cm", "lc", "ac", "t", "tc"], "bw": ["bbld", "bbwd", "mwd", " bsw", "hwin", " bwe", "bew", "bkw", "bld", "btW", " bwd", " bld", "bwin", "hw", "bgw", "bgwin", "mkw", "bW", "btsw", "bgwe", "bbW", "bbkw", "mW", "btw", "bbw", "bsw", "bwd", " bW", "bgew", " bwin", "hwe", "bwe", " bkw", "btld", "mw", " bew", "bbsw", "hew"], "bh": ["br", "oth", "zh", "ubb", "bj", "bc", "bm", "kh", "uh", "hr", "bone", "broad", "bp", "ah", "hh", "cb", "rb", "phy", "b", "lb", "phi", "bol", "ih", "dh", "ths", "bb", "bt", "bs", "hub", "bi", "bis", "hi", "igh", "bo", "bang", "bl", "h", "hang", "sbm", "sb", "bf", "wid", "nb", "ht"], "blocks": ["rows", "sections", "frames", "outs", "bc", "limits", "books", "actions", "bm", "flows", "faces", "lists", "boxes", "checks", "times", "workers", "weights", "stores", "ashes", "devices", "maps", "builders", "locks", "groups", "pages", "cells", "views", "units", "heads", "Blocks", "modules", "bs", "jobs", "users", "block", "rooms", "plugins", "levels", "headers", "classes", "aps", "lines", "types", "chains", "bys", "bytes", "bits", "styles", "elines", "ocks", "ins", "lets", "ubis"], "i": ["id", "p", "n", "init", "ski", "iter", "li", "x", "us", " ti", "iu", "ti", "ind", "uri", "ix", "zi", "ini", "I", "f", " bi", "batch", "q", "key", "list", " j", "source", "xi", "ic", "qi", "m", "ui", "it", "gu", "ims", "im", "name", "\u0438", "ri", "yi", "j", "ii", "iri", "ji", "pi", "asi", "index", "me", "ci", "ei", "info", "phi", "ij", "fi", " ii", "y", "bi", "ms", " I", "v", "mi", "di", "ai", "si", "multi", "ki", "status", "is", "sim", "g", "s", "ami", "gi", "ip", "oi", "print", "in", "t"]}}
{"project": "qemu", "commit_id": "cf29a570a7aa7abab66bf256fdf9540873590811", "target": 1, "func": "static void quorum_vote(QuorumAIOCB *acb)\n\n{\n\n    bool quorum = true;\n\n    int i, j, ret;\n\n    QuorumVoteValue hash;\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n    QuorumVoteVersion *winner;\n\n\n\n    if (quorum_has_too_much_io_failed(acb)) {\n\n        return;\n\n    }\n\n\n\n    /* get the index of the first successful read */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (!acb->qcrs[i].ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    assert(i < s->num_children);\n\n\n\n    /* compare this read with all other successful reads stopping at quorum\n\n     * failure\n\n     */\n\n    for (j = i + 1; j < s->num_children; j++) {\n\n        if (acb->qcrs[j].ret) {\n\n            continue;\n\n        }\n\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n\n        if (!quorum) {\n\n            break;\n\n       }\n\n    }\n\n\n\n    /* Every successful read agrees */\n\n    if (quorum) {\n\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n\n        return;\n\n    }\n\n\n\n    /* compute hashes for each successful read, also store indexes */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (acb->qcrs[i].ret) {\n\n            continue;\n\n        }\n\n        ret = quorum_compute_hash(acb, i, &hash);\n\n        /* if ever the hash computation failed */\n\n        if (ret < 0) {\n\n            acb->vote_ret = ret;\n\n            goto free_exit;\n\n        }\n\n        quorum_count_vote(&acb->votes, &hash, i);\n\n    }\n\n\n\n    /* vote to select the most represented version */\n\n    winner = quorum_get_vote_winner(&acb->votes);\n\n\n\n    /* if the winner count is smaller than threshold the read fails */\n\n    if (winner->vote_count < s->threshold) {\n\n        quorum_report_failure(acb);\n\n        acb->vote_ret = -EIO;\n\n        goto free_exit;\n\n    }\n\n\n\n    /* we have a winner: copy it */\n\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n\n\n\n    /* some versions are bad print them */\n\n    quorum_report_bad_versions(s, acb, &winner->value);\n\n\n\nfree_exit:\n\n    /* free lists */\n\n    quorum_free_vote_list(&acb->votes);\n\n}\n", "idx": 2328, "substitutes": {"acb": ["abdb", "Acdb", "actp", "accbe", "sacnb", " cacbc", " acd", "aicb", "acssb", "Acp", "aconbe", "acsb", "pacdb", "acr", " acsb", "aclb", "pacbc", "accsb", "aconp", "acgb", " cacba", "accg", "acba", "actmb", "acwb", "macsb", "sacbd", "aconbc", "sacwb", "accbo", " cacb", "acrb", "accnb", " acr", "Acbd", " acwb", "ancdb", "aconbd", "facw", "racrb", "Acsb", "acg", "sacb", "accrb", "Acba", "aconwb", "ancp", "abw", "acsnb", "macb", "acbd", "sacB", "acond", "pacbar", "aconb", "accb", "acf", "pacrb", "aicba", "accbr", "acw", "accbb", "acbr", "aclsb", "pacnb", "sacrb", "icb", "accmb", "acmb", "sacgb", "ancr", "accp", "actB", " acw", "aconbar", "ancrb", "ancbb", "facnb", "acd", "pacp", "pacr", "acB", "accbd", "acbo", "aclbb", "ancba", "actbe", "acdb", "aicnb", "Acgb", "aconba", "aclp", "accw", "Acbe", "facsb", "ancb", "accB", "racsb", "racp", "sacbb", "pacbb", "acsw", "sacsb", "aconf", "aclbr", "abbo", "acbar", "acbe", " cacbar", "aconsb", " acbo", "aclr", "sacdb", "acnb", " acf", "accwb", "aclf", " acrb", "aconrb", "icbe", "sacd", "aclB", "sacbe", "aconr", "pacsb", "accba", "aclwb", "actbd", "macnb", "facb", "aicsb", "aconbb", "accr", "Acbb", "sacba", "pacb", "acongb", "racnb", "acbc", "acondb", "Acb", " acp", "macba", "sacp", "icdb", "acong", "pacba", "abb", "icrb", "racbd", "abrb", "acbb", "racb", "pacbe", "actb", "aclg", "aclbe", "acp", "abbe", "sacmb", "sacbr", "accf"], "i": ["id", "try", "ori", "p", "init", "n", "iter", "ish", "li", "x", "us", "iu", "ti", "ir", "ind", "uri", "ix", "zi", "h", "ini", "I", "f", "ik", "my", "this", "q", "xi", "ic", "qi", "m", "ui", "it", "ex", "ims", "im", "um", "name", "io", "\u0438", "ri", "chain", "l", "ii", "iq", "ji", "z", "pi", "index", "me", "ci", "ei", "info", "phi", "ij", "fi", "y", "bi", "hi", " I", "v", "mi", "di", "ai", "si", "point", "_", "multi", "ki", "il", "is", "sim", "ami", "start", "gi", "ip", "oi", "ie", "dr", "ia", "in", "o"], "j": ["jump", "br", "q", "key", "l", "try", "add", "jp", "ji", "dj", "bj", "jit", "next", "z", "uj", "aj", "p", "g", "n", "to", "index", "kj", "li", "m", "res", "b", "x", "other", "u", "it", "J", "ij", "jl", "job", "pr", "js", "y", "k", "jo", "block", "je", "jc", "fr", "oj", "ind", "ja", "v", "o", "t", "obj", "jac", "jj", "json", "sp"], "ret": ["mt", "trust", "RET", "tmp", "format", "ext", "iter", "gt", "reply", " Ret", "orum", "got", "rx", "ry", "rm", "reset", "resp", "re", "back", "result", "deg", "cb", "it", "Ret", "final", "tail", "ptr", "quit", "ruby", "rev", "alt", "ter", "grain", "magic", "nt", "arg", "tr", "elt", "rep", "git", "fun", "ref", "res", "priv", "rex", "virt", "fi", "err", "vet", "val", "fail", "rets", "rem", "rc", "flag", "repl", "len", "success", "sys", "prop", "status", "leg", "ft", "def", "desc", "rt", "reg", "print", "nz", "pub", "store"], "hash": ["success", "total", "data", "id", "key", "test", "temp", "status", "inv", "shift", "prop", "addr", "ssh", "value", " remainder", "sh", "Hash", "conn", "chip", "ash", "result", "ref", "query", "node", "tree", "out", "html", "res", "sum", "password", "header", "tx", "cmp", "tag", "tv", "output", "final", "tar", "version", "rh", "best", "name", "shr", "alias", "str", "rev", "hz", "mac", "vol", "h", "buster", "sha", "state", "json", " hashing"], "s": ["sys", "ls", "S", "south", "stats", "er", "is", "sets", "sv", "ss", "p", "settings", "es", "g", "n", "sl", "details", "ses", "set", "ds", "qs", "b", "params", "fs", "less", "aws", "iss", "ps", "its", "parts", "js", "ns", "bs", "sw", "state", "orders", "ims", "bis", "ms", "as", "ts", "hs", "sts", "rs", "v", "h", "bits", "gs", "sb", "states", "ats", "sq", "args", "os", "t", "a", "ops", "self"], "winner": ["gain", "init", "upper", "better", "node", "ner", "native", "above", "leader", "hero", "vp", "zero", "fresh", "volume", "riot", "von", "ldon", "version", "vote", "Winner", "nov", "vol", "wrapper", "timeout", "killer", "inner", "next", "soc", "result", "vs", "clus", " winners", "valid", "game", "outer", "owner", "thanks", "rev", "member", "maker", "players", "loss", "root", "nie", "mate", "vector", "initialized", "rank", "sett", "res", "history", "best", "runner", "uno", "v", "worker", "strength", "master", "success", "student", "vo", "stone", "value", "wire", "resolution", "winning", "win", " winning", " veteran", "browser", "writer", "won", "player", "role", "ranking", "origin", "vette", "latest", "generation", "news"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    DeviceState *gpio_dev[7];\n\n    qemu_irq gpio_in[7][8];\n\n    qemu_irq gpio_out[7][8];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    I2CBus *i2c;\n\n    DeviceState *dev;\n\n    int i;\n\n    int j;\n\n\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n\n\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n\n\n\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n\n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(system_memory, 0, flash);\n\n\n\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n\n\n\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n\n                      kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n\n        adc = qdev_get_gpio_in(dev, 0);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n\n                                       0x40030000 + i * 0x1000,\n\n                                       pic[timer_irq[i]]);\n\n            /* TODO: This is incorrect, but we get away with it because\n\n               the ADC output is only ever pulsed.  */\n\n            qdev_connect_gpio_out(dev, 0, adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n\n                                               pic[gpio_irq[i]]);\n\n            for (j = 0; j < 8; j++) {\n\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n\n                gpio_out[i][j] = NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n\n                                 pic[uart_irq[i]]);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void *bus;\n\n            DeviceState *sddev;\n\n            DeviceState *ssddev;\n\n\n\n            /* Some boards have both an OLED controller and SD card connected to\n\n             * the same SSI port, with the SD card chip select connected to a\n\n             * GPIO pin.  Technically the OLED chip select is connected to the\n\n             * SSI Fss pin.  We do not bother emulating that as both devices\n\n             * should never be selected simultaneously, and our OLED controller\n\n             * ignores stray 0xff commands that occur when deselecting the SD\n\n             * card.\n\n             */\n\n            bus = qdev_get_child_bus(dev, \"ssi\");\n\n\n\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n\n\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        DeviceState *enet;\n\n\n\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n\n\n\n        enet = qdev_create(NULL, \"stellaris_enet\");\n\n        qdev_set_nic_properties(enet, &nd_table[0]);\n\n        qdev_init_nofail(enet);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            for (j = 0; j < 8; j++) {\n\n                if (gpio_out[i][j]) {\n\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2329, "substitutes": {"kernel_filename": [" kernel_title", " kernel_file", "ernel_file", "ernel_filename", "kernel_model", "kernel_fn", " kernel_fn", "kernel_file", "ernel_fn", "kernelametitle", "kernelamefile", "kernelamefilename", "kernel_title", "ernel_model", "kernelamefn"], "cpu_model": ["cpu2model", "bootetymode", "cpuerdescription", "bootetymodel", "cpuercontroller", "boot_mode", "cpu_mode", "cpuermodels", "cpuetyfine", "cpu_fine", "boot_Model", "gpu_description", "cpu_controller", "cpu_Model", "boot_fine", "cpu_models", "bootetyModel", "gpu_models", "bootetyfine", "cpuetymode", "cpu_description", "cpuetymodel", "cpu2controller", "cpuetyModel", "boot_model", "cpu2models", "cpuermodel", "cpu2description", "gpu_controller", "gpu_model"], "board": ["reader", "core", "image", "boarding", "list", "Board", "ro", "bank", "flow", "bc", "deck", "bd", "ward", "estro", "style", "row", "window", "box", "BO", "bug", "sequence", "table", "bit", "fish", "lock", "check", "controller", "bolt", "bar", "ack", "boot", "bro", "block", "disk", "buffer", "player", "stream", "runner", "boards", "bo", "body", "bang", "frame", "loop", "program", "control", "ck", "back"], "uart_irq": ["uart__prqs", "uart_prqs", "uart__irq", "uart__irQ", "uart_prQ", "uart_prqi", "uart__irqi", "uart_pirqs", "uart_irqs", "uart_pirqi", "uart__prq", "uart_mrqs", "uart_irqi", "uart__prQ", "uart__irqs", "uart_mrq", "uart_pirQ", "uart_mrQ", "uart__prqi", "uart_prq", "uart_mrqi", "uart_irQ", "uart_pirq"], "timer_irq": ["timer_pirque", "timer_pirq", "timer_hrqs", "timer_irqs", "timer_rqs", "timer_pirqs", "timer_rq", "timer_hrq", "timer_hrql", "timer_irque", "timer_rql", "timer_irql", "timer_pirql", "timer_rque", "timer_hrque"], "gpio_addr": ["gpios_address", "gpio__address", "gpio_cmd", "gpio__cmd", "gpio__addr", "gpio_res", "gpio__res", "gpio_address", "gpios_cmd", "gpios_addr", "gpios_res"], "gpio_irq": ["gpio_pirQ", "gpio_drqs", "gpio2pirQ", "gpio_lrqq", "gpio2pirqs", "gpio_lrQ", "gpio_drQ", "gpio_drqq", "gpio2pirqq", "gpio_drq", "gpio_irqq", "gpio2irqs", "gpio_pirqs", "gpio2irq", "gpio2irQ", "gpio2irqq", "gpio_lrq", "gpio2pirq", "gpio_pirq", "gpio_irQ", "gpio_lrqs", "gpio_pirqq", "gpio_irqs"], "pic": ["php", "fc", "jp", "pc", "p", "ics", "py", "eric", "ic", "pi", "photo", "pb", "pol", "li", "lib", "spin", "pict", "ric", "sc", "picture", "pr", "Picture", "syn", "fi", "pa", "script", "arc", "cam", "peg", "Pic", "pl", "nic", "gc", "pin", "icc", "ican", "fn", "sync", "sp"], "gpio_dev": ["gpio__mem", "gpios2device", "gpios2dev", "gpio2addr", "gpios_dev", "gpio2mem", "gpio_device", "gpio__dev", "gpios2addr", "gpios2mem", "gpio__addr", "gpio__device", "gpio_mem", "gpios_mem", "gpio2device", "gpios_addr", "gpio2dev", "gpios_device"], "gpio_in": ["gpio_din", "gpios_in", "gpio_input", "gpios_input", "gpios_out", "gpios_din"], "gpio_out": ["gpio__out", "gpios_in", "gpio__output", "gpios_out", "gpio__co", "gpios_co", "gpio_output", "gpio_co", "gpios_output", "gpio__in"], "adc": ["adec", "ardci", "adeci", "adcs", "ardf", "radcs", "adf", "radci", "radf", "adef", "adecs", "adci", "radc", "ardcs", "ardc"], "sram_size": ["samp_size", "sgram8Size", "sream2code", "sram_capacity", "sram8Size", "sream_size", "sgram_scale", "sream_SIZE", "sram2len", "sram_SIZE", "sram_len", "sgram_capacity", "sgram8size", "sram_Size", "sram8scale", "samp_length", "sram_storage", "sram2SIZE", "sram_scale", "sram8size", "samp_len", "sgram_size", "sram2length", "sram8capacity", "sram2storage", "sram_length", "sream_storage", "sream2storage", "sram2code", "sram2size", "sgram8scale", "sream_code", "sream2size", "sgram8capacity", "sgram_Size", "sram_code", "sream2SIZE"], "flash_size": ["flash_scale", "flash67index", " flash_data", "flash_global", "flash_data", " flash_index", "flashlexgroup", " flash_SIZE", "flash_Size", "flash67SIZE", " flash_Size", "flash67Size", "flash67group", "flashlexsize", " flash_group", "flash_index", "flashlexindex", "flash_SIZE", "flash67size", " flash_global", "flash67data", "flashlexSIZE", "flash_group", " flash_scale"], "i2c": [" i1b", "i1ca", "i1b", " i2cs", "i1cs", "i3c", "i3cs", "i2ca", " i2ca", "i2cs", "i3b", "i4c", "i4cs", " i1ca", " i2b", "i4b", "i3ca", " i1cs", "i4ca", " i1c", "i2b", "i1c"], "dev": ["device", "pri", "ev", "dc", "dem", "Dev", "res", "fin", "tx", "priv", "def", "boot", "sw", "ch", "sd", "disk", "cam", "DEV", "loc", "tech", "val", "vision", "des", "mem", "serv", "cmd"], "i": ["d", "l", "ii", "c", "z", "p", "pi", "ci", "li", "m", "b", "x", "u", "it", "ij", "fi", "ip", "y", "bi", "ia", "v", "mi", "o", "I", "si", "f", "ik"], "j": ["jump", "d", "q", "l", "ii", "jp", "ji", "uj", "z", "p", "aj", "g", "n", "out", "b", "pos", "lock", "it", "J", "ij", "js", "y", "k", "jc", "v", "obj", "jj"], "sram": ["ssron", "Slam", "tsrom", "tsram", "sream", "ssram", " sream", "psrom", "rsrom", "Sram", "psream", "asram", "tslam", "sron", "asrom", " siam", "rsiam", "siam", "slam", "aslam", "Sgram", "Sron", "psram", "srom", "sgram", "rsram", "rsgram", "psgram", " sgram", "tsgram", "sslam", " srom", "asgram", " slam", "ssgram", " sron", "tsream"], "flash": ["roll", "jump", "roller", "ff", "silver", "high", "flow", "gif", "soft", "fine", "ref", "broad", "small", "fish", "form", "sc", "bolt", "hero", "zero", "tf", "foreign", "shock", "boot", "snap", "fl", "browser", "sw", "trans", "error", "normal", "sharp", "buffer", "fps", "cam", "local", "fast", "fr", "Flash", "fly", "video", "pool", "global", "io", "wave", "bridge", "fire", "low", "loop", "vol", "scroll", "hard", "ram", "raw", "touch", "buff"], "system_memory": ["system2meta", "system_storage", "sys_memory", "sys_management", "system_meta", "sys_meta", "system_mem", "systemlystorage", "system_management", " system_mem", "systemlymeta", "system_database", "system2storage", "system_library", " system_database", "system2memory", "sys_region", " system_library", "systemlymem", "sys_storage", "system2mem", "sys_mem", "system_region", "systemlymemory"]}}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}", "idx": 2334, "substitutes": {"env": ["proc", "ec", "stack", "tmp", "er", "gear", "code", "buf", "web", "sv", "next", "conn", "ent", "ev", "window", "vs", "server", "open", "viron", "exc", "environment", "engine", "esc", "nv", "export", "entry", "def", "bar", "vp", "cur", "dev", "end", "local", "desc", "w", "e", "context", "en", "here", "el", "ctx", "equ", "ptr", "pkg", "gate", "db", "ja", "ew", "v", "queue", "process", "uv", "current", "event", "ve", "enter", "enc", "obj", "self"], "penv": ["penq", "pncil", "fenvr", "pnve", "fenq", "pnvin", "stenvr", "stenv", "phenV", "Pench", "primch", "pnch", "pench", "pnp", "senvin", "pingv", "phenvt", "venv", "pincer", "primvt", "pncer", "fenp", " penf", "penvt", "penvr", "Pencil", "penvin", "pencer", "fenv", "pencil", "pnvr", "senval", "pingvr", "pnl", "pingvt", "senve", "pinl", " pencer", " penp", "venval", "Penvt", "pnf", "pingve", "penve", "Penv", "pnvt", "phenv", "pnq", "penf", "venve", "primV", "penp", " penq", "pnval", "pinv", "stenve", "pnV", "pnv", "penval", "senv", "stenvt", "PenV", " penl", "phencil", "pinf", "venvin", "primv", "penl", " penvr", "penV"], "cpu_index": ["cpuixoffset", "pu_Index", "pu_no", "cpu_id", "cpu_point", "pu_length", "pu_id", "cpu__Index", "pu_ind", "cpu_length", "cpu_number", "pu_offset", "cpu__index", "cpu__ind", "cpu_count", "cpuixindex", "cpu_Index", "CPU_index", "CPU_Index", "cpu_column", "cpu_path", "cpuixdepth", "pu_depth", "cpuixid", "cpu__path", "cpu_offset", "cpu_no", "cpu_depth", "pu_index", "cpu_ind", "pu_column", "pu_path", "CPU_number", "pu_point", "pu_count"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2348, "substitutes": {"ysrc": ["essrc", "mysusc", "ysr", "nsr", "iessrc", "syssrc", "myssrc", "nsrc", "ysusc", "iesource", "iesrc", "esusc", "sysrc", "yssrc", "nsusc", "mysrc", "mysource", "sysusc", "esource", "sysr", "iesusc", "ysource", "iesr", "esrc", "nssrc"], "usrc": ["Usource", "usesource", " usirc", " usource", "usirc", "umsrc", "ussrc", "Ussrc", "usesrc", "usurg", " ussrc", "osrc", "usessrc", "usource", "umsirc", " usurg", "umssrc", "osirc", "umsurg", "ossrc", "osurg", "Usrc"], "vsrc": ["wsource", "pstr", "prc", "fst", " vsource", "wrc", "ssource", "vstr", "vrc", "pst", "fsrc", "psrc", "vsource", " vrs", "vrs", " vrc", "ssrc", " vst", "vst", "src", "srs", "frc", " vstr", "wsrc", "fstr", "wrs"], "dst": [" ddest", "vput", "dsdest", "fdest", "ddest", "drest", "lrest", "fst", "lst", "dsnd", "diddest", "lput", "ftt", "dtt", "dsst", "vdest", "dstt", "didst", "fnd", "vst", "vrest", "didtt", " dput", "ldest", "dput", "dnd", " drest", "didnd"], "height": ["rows", "ty", "zh", "size", "he", "Height", "inches", "count", "gravity", "uh", "resolution", "cy", "build", "window", "wh", "yt", "dist", "gy", "html", "family", "volume", "ih", "shape", "hei", "history", "y", "w", " heights", "hi", "headers", "radius", "hz", "depth", "ows", "h", "HH", "hang", "stroke", "dim", "th", "density", "length", "gh", "ht"], "lumStride": ["lumSTrate", "lumstr", "lumLide", "lumStrride", "limStr", "limStrr", "lomStrid", "lumstrid", "lumStrid", "lumstride", "lumStrrid", "lumSTide", "lumStrrate", "lumLrid", "lomStride", "limStrride", "lomStr", "lumLride", "lomStrride", "limStrrate", "limStride", "lumStrr", "lumLr", "lumstrate", "lumStrate", "lumStr", "limStrate", "lumSTr", "lumSTride", "lomStide", "lomStrr", "limStide", "lomStrrid", "lumstide", "lumStide"], "chromStride": ["chromSpide", "chromStrr", "chromStrip", "chromStrrange", "chromStide", "romStrange", "romStride", "chromstr", "romStrrange", "chromSlide", "romStrrid", "chromstride", "chromSTride", "romStrride", "romStide", "chromstrip", "chromStrrid", "chromStrange", "romStr", "chromStrride", "romStrrip", "romStrip", "chromstide", "chromSlride", "chromSTrid", "chromSlrange", "chromSpride", "chromSpr", "chromSTrange", "chromSprip", "chromSlrid", "chromSTide", "chromStrrip", "chromStrid", "romStrid", "romStrr", "chromStr"], "dstStride": ["destStrr", "dstStrip", "dndStr", "dstRestrip", "destStride", "dstStrno", "dstRestide", "destStide", "dstRestride", "dndStno", "dstStr", "dstRestno", "dndStrride", "dststide", "destStrrip", "dststr", "dstRestr", "dstStrrip", "dststno", "dndStride", "dstStrride", "destStrride", "dstStno", "destStr", "dndStrr", "destStrip", "dstStrr", "dststrip", "dstStide", "dststride", "dndStrno", "dndStide"]}}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n", "idx": 2349, "substitutes": {"cmd": ["ctr", "cod", "parent", "head", "op", "c", "handle", "ext", "conn", "bind", "init", "from", "cfg", "crit", "comm", "send", "cb", "msg", "this", "md", "new", "ok", "def", "cur", "req", "cmp", "Cmd", "cont", "config", "report", "command", "mk", "quit", "ctx", "ind", "target", "urg", "good", "nt", "ct", "handler", "resp", "raw", "obj", "met"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int vqa_decode_init(AVCodecContext *avctx)\n\n{\n\n    VqaContext *s = (VqaContext *)avctx->priv_data;\n\n    unsigned char *vqa_header;\n\n    int i, j, codebook_index;;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    avctx->has_b_frames = 0;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the extradata made it */\n\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n\n\n\n\n\n    /* load up the VQA parameters from the header */\n\n    vqa_header = (unsigned char *)s->avctx->extradata;\n\n    s->vqa_version = vqa_header[0];\n\n    s->width = LE_16(&vqa_header[6]);\n\n    s->height = LE_16(&vqa_header[8]);\n\n\n\n\n\n    s->vector_width = vqa_header[10];\n\n    s->vector_height = vqa_header[11];\n\n    s->partial_count = s->partial_countdown = vqa_header[13];\n\n\n\n    /* the vector dimensions have to meet very stringent requirements */\n\n    if ((s->vector_width != 4) ||\n\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n\n        /* return without further initialization */\n\n\n\n\n\n    /* allocate codebooks */\n\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n\n    s->codebook = av_malloc(s->codebook_size);\n\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n\n\n\n    /* initialize the solid-color vectors */\n\n    if (s->vector_height == 4) {\n\n        codebook_index = 0xFF00 * 16;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 16; j++)\n\n                s->codebook[codebook_index++] = i;\n\n    } else {\n\n        codebook_index = 0xF00 * 8;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 8; j++)\n\n                s->codebook[codebook_index++] = i;\n\n\n    s->next_codebook_buffer_index = 0;\n\n\n\n    /* allocate decode buffer */\n\n    s->decode_buffer_size = (s->width / s->vector_width) *\n\n        (s->height / s->vector_height) * 2;\n\n    s->decode_buffer = av_malloc(s->decode_buffer_size);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n", "idx": 2358, "substitutes": {"avctx": ["abaddr", "abconn", "avconn", "devconn", "avectx", "devctx", "afcmd", "abcm", "apcontext", "avertc", "apjac", "devcontext", "avtx", "abcp", "aveconn", "avercontext", "ajtx", "avjac", "wavaddr", "afctx", "abtmp", "ajctx", "avertx", "ajcontext", "avejac", "aftc", "abcontext", "avtc", "navctx", "avercmp", "avetx", "devtx", "abcmp", "abctx", "navcmp", " avtx", "wavctx", "avercm", "apctx", " avcontext", "avcp", "wavcontext", "navcmd", " avcm", "avercmd", "averjac", " avjac", "ajcp", "aveaddr", "avcontext", "afjac", "avtmp", "avcm", "abtx", "avecontext", "afcmp", "afcontext", " avconn", "avaddr", " avcmd", "avecmp", "navtc", " avtmp", "avertmp", "aptx", "avcmd", "wavcmp", "avcmp", "averctx", "apcp", "aftx"], "s": ["ls", "p", "es", "n", "ses", "set", "store", "gets", "sc", "services", "series", "its", "state", "ports", "cs", "spec", "ies", "ags", "h", "gs", "sb", "args", "so", "os", "mods", "stats", "sv", "source", "settings", "vs", "details", "ess", "ers", "ds", "qs", "ants", "m", "full", "less", "bs", "ims", "bis", "ties", "hs", "ar", "aps", "sts", "eps", "pers", "ins", "states", "sq", "esm", "self", "S", "l", "sets", "ss", "als", "sl", "comm", "views", "ns", "sw", "y", "ms", "ts", "changes", "tests", "results", "rates", "se", "ops", "sys", "status", "is", "g", "ids", "b", "fs", "aws", "ps", "parts", "js", "comments", "terms", "sports", "sm", "rs", "bits", "ats", "des", "t"], "vqa_header": ["vqa___head", "vaxy67head", "vaxy67magic", "vga_player", "vqa_body", "vga_body", "vqa_head", "vqua_version", "vqaptbody", "vaxy_header", "vga_var", "vqa_version", "vqa1filter", "vqa___var", "vqua_source", "vqa____header", "viza_filter", "vqaptheader", "vqa____part", "vqaerformat", "vqa_headers", "vqa_magic", "vqa_source", "vaxy_head", "vga_part", "vtk_header", "vqa___cache", "vqa67header", "vqa____var", "vqa1header", "vqa___magic", "vtk_headers", "vqa_token", "vtk_format", "vqa67head", "vqa67cache", "vga_filter", "vqa67format", "vqa_filter", "vqua_header", "vqa_cache", "vqa1token", "vqa67body", "viza_format", "vaxy_magic", "vqa_format", "vga_dict", "vga_format", "vaxy67cache", "viza_header", "vqa___part", "vqa67filter", "vga_header", "vqa67dict", "vqa67attribute", "vqaerplayer", "vqa___header", "vaxy_cache", "vqa_attribute", "vga_token", "vqua_headers", "vga_head", "vqa_offset", "vqa67player", "vqa_var", "viza_attribute", "vqa1head", "vqa_player", "vqaerheader", "vqa_dict", "vtk_offset", "vqa67magic", "vqaerhead", "vqa_part", "vqaptdict", "vaxy67header"], "i": ["multi", "id", "try", "ii", "ki", "er", "ji", "is", "p", "iy", "g", "init", "xi", "ic", "pi", "r", "qi", "me", "iter", "ci", "li", "index", "iii", "ami", "ei", "m", "b", "x", "cli", "us", "ui", "info", "gi", "it", "phi", "ij", "aci", "ip", " ii", "oi", "y", "ims", "bi", "ie", "e", "im", "iu", "ti", "hi", " li", "io", "ix", "ia", "v", "dr", "zi", "in", "mi", "o", "ini", "di", "\u0438", "ai", "si", "I", "f"], "j": ["jump", "br", "q", "try", "l", "ii", "jp", "ji", "dj", "c", "jit", "bj", "z", "uj", "p", "aj", "g", "n", "kj", "r", "li", "out", "m", "jas", "b", "other", "it", "J", "ij", "jl", "job", "pr", "js", "y", "jo", "bi", "err", "ie", "je", "jc", "fr", "oj", "pt", "ja", "ix", "v", "si", "f", "tr", "rel", "obj", "jj", "json"], "codebook_index": ["codeboard_label", "codebookTindex", "codebook_Index", "codebook\u05bcaddress", "codegroup_ind", "codebookTseed", "codegroup_level", "codebook_buffer", "codebook_ind", "codeboard_key", "codegroup_offset", "coderecord_interface", "codebook_interface", "codeboard_index", "codebookTbuffer", "coderecord_index", "codebook_level", "codebook\u05bcseed", "coderecord_buffer", "codebookTinterface", "codebook_seed", "codebook_offset", "codebuf_index", "codegroup_index", "codebook__label", "codebuf_seed", "codebook\u05bcindex", "codebook_address", "codegroup_key", "codebook\u064eseed", "codebook_instance", "coderecord_seed", "codebook\u064einterface", "codebook__index", "codegroup_Index", "codebuf_instance", "codebook__key", "codebuf_address", "codebook\u064ebuffer", "codebook_key", "codebook\u05bcinstance", "codebook\u064eindex", "codebook_label"]}}
{"project": "FFmpeg", "commit_id": "25bcf24d4d0faf0191923be8afac8f67ca98b500", "target": 0, "func": "static int open_output_file(OptionsContext *o, const char *filename)\n\n{\n\n    AVFormatContext *oc;\n\n    int i, j, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputFile *of;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n    AVDictionary *unused_opts = NULL;\n\n    AVDictionaryEntry *e = NULL;\n\n\n\n    if (configure_complex_filters() < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error configuring filters.\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {\n\n        o->stop_time = INT64_MAX;\n\n        av_log(NULL, AV_LOG_WARNING, \"-t and -to cannot be used together; using -t.\\n\");\n\n    }\n\n\n\n    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {\n\n        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;\n\n        if (o->stop_time <= start_time) {\n\n            av_log(NULL, AV_LOG_WARNING, \"-to value smaller than -ss; ignoring -to.\\n\");\n\n            o->stop_time = INT64_MAX;\n\n        } else {\n\n            o->recording_time = o->stop_time - start_time;\n\n        }\n\n    }\n\n\n\n    GROW_ARRAY(output_files, nb_output_files);\n\n    of = av_mallocz(sizeof(*of));\n\n    if (!of)\n\n        exit_program(1);\n\n    output_files[nb_output_files - 1] = of;\n\n\n\n    of->ost_index      = nb_output_streams;\n\n    of->recording_time = o->recording_time;\n\n    of->start_time     = o->start_time;\n\n    of->limit_filesize = o->limit_filesize;\n\n    of->shortest       = o->shortest;\n\n    av_dict_copy(&of->opts, o->g->format_opts, 0);\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n\n    if (!oc) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n\n\n    of->ctx = oc;\n\n    if (o->recording_time != INT64_MAX)\n\n        oc->duration = o->recording_time;\n\n\n\n    file_oformat= oc->oformat;\n\n    oc->interrupt_callback = int_cb;\n\n\n\n    /* create streams for all unlabeled output pads */\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n\n        FilterGraph *fg = filtergraphs[i];\n\n        for (j = 0; j < fg->nb_outputs; j++) {\n\n            OutputFilter *ofilter = fg->outputs[j];\n\n\n\n            if (!ofilter->out_tmp || ofilter->out_tmp->name)\n\n                continue;\n\n\n\n            switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads,\n\n                                          ofilter->out_tmp->pad_idx)) {\n\n            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;\n\n            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;\n\n            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;\n\n            }\n\n            init_output_filter(ofilter, o, oc);\n\n        }\n\n    }\n\n\n\n    /* ffserver seeking with date=... needs a date reference */\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int err = parse_option(o, \"metadata\", \"creation_time=now\", options);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") && !override_ffserver &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        int j;\n\n        /* special case for files sent to ffserver: we get the stream\n\n           parameters from ffserver */\n\n        int err = read_ffserver_streams(o, oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n        for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n\n            ost = output_streams[j];\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if(ist->st->codec->codec_type == ost->st->codec->codec_type){\n\n                    ost->sync_ist= ist;\n\n                    ost->source_index= i;\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup(\"anull\");\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup(\"null\");\n\n                    ist->discard = 0;\n\n                    ist->st->discard = AVDISCARD_NONE;\n\n                    break;\n\n                }\n\n            }\n\n            if(!ost->sync_ist){\n\n                av_log(NULL, AV_LOG_FATAL, \"Missing %s stream which is required by this ffm\\n\", av_get_media_type_string(ost->st->codec->codec_type));\n\n                exit_program(1);\n\n            }\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        char *subtitle_codec_name = NULL;\n\n        /* pick the \"best\" stream of each type */\n\n\n\n        /* video: highest resolution */\n\n        if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                int new_area;\n\n                ist = input_streams[i];\n\n                new_area = ist->st->codec->width * ist->st->codec->height;\n\n                if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                    new_area = 1;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    new_area > area) {\n\n                    if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                        continue;\n\n                    area = new_area;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_video_stream(o, oc, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            if (idx >= 0)\n\n                new_audio_stream(o, oc, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, \"s\");\n\n        if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    new_subtitle_stream(o, oc, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            if (map->linklabel) {\n\n                FilterGraph *fg;\n\n                OutputFilter *ofilter = NULL;\n\n                int j, k;\n\n\n\n                for (j = 0; j < nb_filtergraphs; j++) {\n\n                    fg = filtergraphs[j];\n\n                    for (k = 0; k < fg->nb_outputs; k++) {\n\n                        AVFilterInOut *out = fg->outputs[k]->out_tmp;\n\n                        if (out && !strcmp(out->name, map->linklabel)) {\n\n                            ofilter = fg->outputs[k];\n\n                            goto loop_end;\n\n                        }\n\n                    }\n\n                }\n\nloop_end:\n\n                if (!ofilter) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Output with label '%s' does not exist \"\n\n                           \"in any defined filter graph, or was already used elsewhere.\\n\", map->linklabel);\n\n                    exit_program(1);\n\n                }\n\n                init_output_filter(ofilter, o, oc);\n\n            } else {\n\n                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;\n\n\n\n                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];\n\n                if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n\n                    continue;\n\n                if(o->   audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                    continue;\n\n                if(o->   video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n                    continue;\n\n                if(o->    data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA)\n\n                    continue;\n\n\n\n                switch (ist->st->codec->codec_type) {\n\n                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;\n\n                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL, \"Cannot map stream #%d:%d - unsupported type.\\n\",\n\n                           map->file_index, map->stream_index);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle attached files */\n\n    for (i = 0; i < o->nb_attachments; i++) {\n\n        AVIOContext *pb;\n\n        uint8_t *attachment;\n\n        const char *p;\n\n        int64_t len;\n\n\n\n        if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not open attachment file %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if ((len = avio_size(pb)) <= 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Could not get size of the attachment %s.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        if (!(attachment = av_malloc(len))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Attachment %s too large to fit into memory.\\n\",\n\n                   o->attachments[i]);\n\n            exit_program(1);\n\n        }\n\n        avio_read(pb, attachment, len);\n\n\n\n        ost = new_attachment_stream(o, oc, -1);\n\n        ost->stream_copy               = 0;\n\n        ost->attachment_filename       = o->attachments[i];\n\n        ost->finished                  = 1;\n\n        ost->st->codec->extradata      = attachment;\n\n        ost->st->codec->extradata_size = len;\n\n\n\n        p = strrchr(o->attachments[i], '/');\n\n        av_dict_set(&ost->st->metadata, \"filename\", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);\n\n        avio_close(pb);\n\n    }\n\n\n\n    for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { //for all streams of this output file\n\n        AVDictionaryEntry *e;\n\n        ost = output_streams[i];\n\n\n\n        if ((ost->stream_copy || ost->attachment_filename)\n\n            && (e = av_dict_get(o->g->codec_opts, \"flags\", NULL, AV_DICT_IGNORE_SUFFIX))\n\n            && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))\n\n            if (av_opt_set(ost->st->codec, \"flags\", e->value, 0) < 0)\n\n                exit_program(1);\n\n    }\n\n\n\n    /* check if all codec options have been used */\n\n    unused_opts = strip_specifiers(o->g->codec_opts);\n\n    for (i = of->ost_index; i < nb_output_streams; i++) {\n\n        e = NULL;\n\n        while ((e = av_dict_get(output_streams[i]->opts, \"\", e,\n\n                                AV_DICT_IGNORE_SUFFIX)))\n\n            av_dict_set(&unused_opts, e->key, NULL, 0);\n\n    }\n\n\n\n    e = NULL;\n\n    while ((e = av_dict_get(unused_opts, \"\", e, AV_DICT_IGNORE_SUFFIX))) {\n\n        const AVClass *class = avcodec_get_class();\n\n        const AVOption *option = av_opt_find(&class, e->key, NULL, 0,\n\n                                             AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ);\n\n        if (!option)\n\n            continue;\n\n        if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Codec AVOption %s (%s) specified for \"\n\n                   \"output file #%d (%s) is not an encoding option.\\n\", e->key,\n\n                   option->help ? option->help : \"\", nb_output_files - 1,\n\n                   filename);\n\n            exit_program(1);\n\n        }\n\n\n\n        // gop_timecode is injected by generic code but not always used\n\n        if (!strcmp(e->key, \"gop_timecode\"))\n\n            continue;\n\n\n\n        av_log(NULL, AV_LOG_WARNING, \"Codec AVOption %s (%s) specified for \"\n\n               \"output file #%d (%s) has not been used for any stream. The most \"\n\n               \"likely reason is either wrong type (e.g. a video option with \"\n\n               \"no video streams) or that it is a private option of some encoder \"\n\n               \"which was not actually used for any stream.\\n\", e->key,\n\n               option->help ? option->help : \"\", nb_output_files - 1, filename);\n\n    }\n\n    av_dict_free(&unused_opts);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid losing precious files */\n\n        assert_file_overwrite(filename);\n\n\n\n        /* open the file */\n\n        if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,\n\n                              &oc->interrupt_callback,\n\n                              &of->opts)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (strcmp(oc->oformat->name, \"image2\")==0 && !av_filename_number_test(filename))\n\n        assert_file_overwrite(filename);\n\n\n\n    if (o->mux_preload) {\n\n        uint8_t buf[64];\n\n        snprintf(buf, sizeof(buf), \"%d\", (int)(o->mux_preload*AV_TIME_BASE));\n\n        av_dict_set(&of->opts, \"preload\", buf, 0);\n\n    }\n\n    oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < o->nb_metadata_map; i++) {\n\n        char *p;\n\n        int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0);\n\n\n\n        if (in_file_index >= nb_input_files) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d while processing metadata maps\\n\", in_file_index);\n\n            exit_program(1);\n\n        }\n\n        copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc,\n\n                      in_file_index >= 0 ?\n\n                      input_files[in_file_index]->ctx : NULL, o);\n\n    }\n\n\n\n    /* copy chapters */\n\n    if (o->chapters_input_file >= nb_input_files) {\n\n        if (o->chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            o->chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i]->ctx->nb_chapters) {\n\n                    o->chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   o->chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (o->chapters_input_file >= 0)\n\n        copy_chapters(input_files[o->chapters_input_file], of,\n\n                      !o->metadata_chapters_manual);\n\n\n\n    /* copy global metadata by default */\n\n    if (!o->metadata_global_manual && nb_input_files){\n\n        av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n        if(o->recording_time != INT64_MAX)\n\n            av_dict_set(&oc->metadata, \"duration\", NULL, 0);\n\n        av_dict_set(&oc->metadata, \"creation_time\", NULL, 0);\n\n    }\n\n    if (!o->metadata_streams_manual)\n\n        for (i = of->ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist;\n\n            if (output_streams[i]->source_index < 0)         /* this is true e.g. for attached files */\n\n                continue;\n\n            ist = input_streams[output_streams[i]->source_index];\n\n            av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    /* process manually set metadata */\n\n    for (i = 0; i < o->nb_metadata; i++) {\n\n        AVDictionary **m;\n\n        char type, *val;\n\n        const char *stream_spec;\n\n        int index = 0, j, ret = 0;\n\n\n\n        val = strchr(o->metadata[i].u.str, '=');\n\n        if (!val) {\n\n            av_log(NULL, AV_LOG_FATAL, \"No '=' character in metadata string %s.\\n\",\n\n                   o->metadata[i].u.str);\n\n            exit_program(1);\n\n        }\n\n        *val++ = 0;\n\n\n\n        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);\n\n        if (type == 's') {\n\n            for (j = 0; j < oc->nb_streams; j++) {\n\n                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n\n                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n                } else if (ret < 0)\n\n                    exit_program(1);\n\n            }\n\n        }\n\n        else {\n\n            switch (type) {\n\n            case 'g':\n\n                m = &oc->metadata;\n\n                break;\n\n            case 'c':\n\n                if (index < 0 || index >= oc->nb_chapters) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Invalid chapter index %d in metadata specifier.\\n\", index);\n\n                    exit_program(1);\n\n                }\n\n                m = &oc->chapters[index]->metadata;\n\n                break;\n\n            default:\n\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", o->metadata[i].specifier);\n\n                exit_program(1);\n\n            }\n\n            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2365, "substitutes": {"o": ["oid", "op", "ro", "c", "n", "ow", "window", "onet", "options", "other", "bo", "h", "te", "f", "ot", "os", "so", "a", "d", "q", "ox", "u", "ok", "it", "iso", "owner", "ion", "mo", "co", "io", "remote", "online", "l", "er", "oS", "to", "O", "ao", "lo", "oa", "info", "cache", "y", "ob", "office", "one", "go", "or", "v", "on", "oe", "oo", "ve", "image", "po", "vo", "no", "b", "ta", "oi", "ie", "w", "original", "t", "obj", "yo", "fo", "ation"], "filename": ["fp", "ames", "unction", "wav", "wcs", "NAME", "fil", "kan", "FIL", "lr", "directory", "unc", "text", "ename", "tif", "n", "ammy", "ren", "fle", "txt", "kl", "names", "kj", "nil", "r", "path", "ame", "msg", "ocument", "title", "println", "mson", "tor", "location", "fi", "output", "file", "username", "xxx", "buffer", "name", "that", "nom", "nm", "FN", "til", "Filename", "sorry", "ews", "f", "fn", "prefix", "jpg", "length", "json", "fd"], "oc": ["ec", "alloc", "oid", "ocation", "op", "pc", "c", "bc", "unc", "soc", "org", "ocon", "dc", "uc", "ic", "og", "oh", "oco", "ox", "OC", "off", "ok", "voc", "roc", "toc", "oi", "osc", "arc", "oci", "ctx", "oj", "ob", "co", "loc", "ov", "cc", "ocr", "oo", "ot", "os", "ac", "om", "obj"], "i": ["ii", "c", "n", "pi", "li", "ci", "b", "x", "it", "ij", " ti", " ii", "y", "iu", " li", "io", "v", "mi", "ai", "I", "si", "t", " bi"], "j": ["jump", "q", "jp", "ji", "bj", "aj", "z", "uj", "g", "n", "kj", "b", "pos", "J", "ij", "jl", "job", "js", "fi", "jc", "ja", "v", "jac", "jj", "json"], "err": ["mr", "ec", "usr", "cr", "lr", "er", "arr", "init", "ev", "attr", "result", "n", "txt", "r", "iter", "ner", "cfg", "cb", "exc", "rb", "res", "msg", "it", "pr", "yr", "kr", "ch", "error", "errors", "der", "Er", "fr", "rr", "ir", "str", "ind", "or", "Error", "dr", "erd", "rc", "resp", "obj", "rn"], "file_oformat": ["file_oform", "file_Ooutput", "file_OFormat", "file_foform", "file_foformat", "file_Oform", "file_oFormat", "file_fooutput", "file_Oformat", "file_foFormat", "file_ooutput"], "of": ["oid", "oha", "ff", "ow", "sf", "lf", "other", "off", "zero", "ef", "cf", "df", "ovi", "Of", "oof", "oln", "osi", "by", "f", "ot", "os", "so", "fd", "ofer", "ol", " fo", "af", "less", "ok", "it", "ll", "own", "owner", "OF", "ar", "root", "uf", "\u00f3", "alf", "iq", "to", "eh", "from", "oh", "oa", "new", "fi", "jo", "el", "fol", "en", "ob", "one", "or", "ov", "on", "orf", "oe", "oo", "ful", "org", "oft", "eff", "og", "def", "wo", "oi", "\u00f6", "raw", "about", "obj", "omp"], "ost": ["sys", "oid", "op", "rest", "host", "tt", "unc", "ast", "ont", "ust", "etc", "obs", "ok", "olog", "oss", "ort", "ous", "ob", "ott", "od", "src", "oo", "ot", "st", "os", "om", "oos"], "ist": ["aft", "fp", "istor", "et", "il", "IST", "is", "isl", "wi", "ic", "ont", "ird", "ust", "pir", "iste", "iss", "its", "ip", "oci", "ir", "iop", "ists", "irst", "est", "isi", "ot", "st", "umi"], "unused_opts": ["unused_prots", "unused_pts", "unused_ops", "unused_copms", "unused_copts", "unused_opfs", "unused_profs", "unused_pros", "unused_pms", "unused_opms", "unused_pfs", "unused_ps", "unused_cops", "unused_copfs", "unused_proms"], "e": ["ec", "ele", "d", "et", "er", "c", "es", "n", "me", "ei", "pe", "xe", "ge", "ef", "ed", "eu", "ie", "el", "en", "ea", "E", "oe", "te", "ee", "se"]}}
{"project": "qemu", "commit_id": "e167adc9d9f5df4f8109aecd4552c407fdce094a", "target": 1, "func": "static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,\n\n                                   unsigned int imms, unsigned int immr)\n\n{\n\n    uint64_t mask;\n\n    unsigned e, levels, s, r;\n\n    int len;\n\n\n\n    assert(immn < 2 && imms < 64 && immr < 64);\n\n\n\n    /* The bit patterns we create here are 64 bit patterns which\n\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n\n     * 64 bits each. Each element contains the same value: a run\n\n     * of between 1 and e-1 non-zero bits, rotated within the\n\n     * element by between 0 and e-1 bits.\n\n     *\n\n     * The element size and run length are encoded into immn (1 bit)\n\n     * and imms (6 bits) as follows:\n\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n", "idx": 2395, "substitutes": {"result": ["data", "message", "test", "list", "ult", "match", "status", "p", "out", "table", "memory", "m", "res", "valid", "cache", "output", "final", "block", "buffer", "complete", "true", "df", "currency", "val", "results", "ret", "answer", "f", "Result", "rc", "mate", "arg", "map", "this", "self"], "immn": ["iamrn", "permN", "Immnl", " immN", " immnm", "imm1", "iamn", "premr", "premn", " immcn", "iamN", "iamnm", "Imm1", "mutr", "mutnl", " immrn", "Immr", "premnm", "immcn", "iamr", "immrn", "permn", "immnl", " immnl", "mut1", "Immn", "iamcn", "permcn", "immN", " imm1", "premN", "immnm", "permrn", "mutn"], "imms": ["imcs", "imsts", "iamm", "ummn", " ims", " imcs", "iammn", "imscs", "limmn", "imsps", "immcs", "ums", " immas", "simfs", " imps", "IMms", "immts", "immms", "imps", "umm", "IMps", "limms", "simps", "ims", "limcs", "simms", " imts", "limps", "iams", "imts", "imsms", " imfs", "simmas", "IMfs", " imm", "IMmas", "imsmn", "immmn", "immas", "imm", "imfs", "umms", "iamms"], "immr": ["attrn", "mmr", "immp", "Immrn", "immm", "imn", "imrn", "immd", "Immrb", "attrrn", " immh", "armm", "imh", " imme", "attrr", "imr", " immrb", "mme", "Immr", " immm", "immrn", "armr", "Immm", "immrb", "imp", " immd", "imme", "Immn", "ime", "Immd", "immh", " immp", "attrm", "armd", "imm", "armrb", "mmp", "mmh"], "mask": ["mt", " metric", "match", "mb", "p", "window", " label", "out", " mc", "set", "sum", "black", "x", "form", "sk", "lock", "weight", "zero", " pixel", "clean", " mark", " ma", "cf", "buffer", " cm", "hash", "f", "share", " chunk", "batch", "q", "ma", "message", "key", "shift", " gate", " Mask", "m", "filter", "cmp", "perm", "um", "gc", "gate", "offset", " masked", " map", "cm", "clear", "mate", "tr", " match", "mass", "z", "sign", "Mask", " sk", "mp", " filter", " scale", "miss", " flag", " key", "ask", "block", "comment", "level", "flags", "ms", "flag", "map", " constraint", "mount", "hide", " mirror", "arr", "mark", "label", "hold", " message", "bit", "pack", "transform", "ch", "allow", " mac"], "e": ["ec", "ele", "d", "ate", "le", "l", "size", "er", "c", "ep", "count", "p", "es", "g", "n", "element", "me", "m", "i", "ei", "x", "u", "eg", "pe", "eu", "ed", "end", "errors", "err", "el", "en", "E", "oe", "o", "h", "te", "ee", "f", "elt", "t", "a", "se"], "levels": ["ls", "values", "steps", "ones", "rows", "lvl", "l", "frames", "ales", "limits", "es", "n", "checks", "times", "codes", "vs", "xs", "ples", "ops", "ds", "links", "vals", "i", "mins", "groups", "fields", "members", "heads", "ps", "modules", "ns", "ims", "level", "errors", "flags", "terms", "ms", "ts", "keys", "points", "lines", "eps", "rs", "ints", "depth", "blocks", "bits", "gs", "xes", "ins", "states", "ens"], "s": ["sys", "ls", "j", "S", "stats", "le", "l", "er", "is", "sv", "ss", "p", "z", "sec", "g", "n", "es", "sl", "upper", "ds", "qs", "m", "i", "b", "less", "ps", "bs", "ns", "sw", "sr", "sing", "ims", "ts", "cs", "spec", "sts", "rs", "h", "gs", "si", "sb", "ins", "st", "sq", "os", "ats", "t", "a", "se", "self", "sp"], "r": ["mr", "ls", "rd", "d", "q", "j", "l", "lr", "er", "ro", "c", "vr", "z", "p", "g", "n", "rb", "m", "rate", "i", "b", "x", "u", "R", "t", "sr", "rf", "err", "w", "rec", "fr", "rr", "rt", "ar", "reg", "dr", "rs", "v", "h", "f", "rc", "rel", "re", "rar"], "len": [" length", "ls", "ele", "d", "lp", "le", "l", "size", "L", "nl", "z", "limit", "n", "sl", "kl", "Len", "m", "lf", "pos", "lan", "ll", "Length", "lon", "length", " l", "level", "err", "compl", "el", "en", "dl", "pl", "ln", "ell", "loc", "offset", "v", "bytes", "oe", "h", " le", " clen", "elt", "t", "ld", "sp"]}}
{"project": "FFmpeg", "commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "target": 1, "func": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n\n                             int poc, int ref_flag)\n\n{\n\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n\n\n    if (ref == s->ref)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!ref) {\n\n        ref = generate_missing_ref(s, poc);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    list->list[list->nb_refs] = ref->poc;\n\n    list->ref[list->nb_refs]  = ref;\n\n    list->nb_refs++;\n\n\n\n    mark_ref(ref, ref_flag);\n\n    return 0;\n\n}\n", "idx": 2400, "substitutes": {"s": ["sys", "ls", "S", "serv", "stats", "c", "is", "sv", "ss", "p", "scl", "source", "g", "n", "r", "ses", "comm", "ds", "m", "i", "space", "fs", "less", "sc", "ps", "js", "ns", "bs", "conf", "ims", "sam", "cs", "ts", "ctx", "spec", "has", "sts", "an", "rs", "v", "h", "gs", "sb", "st", "sq", "os", "t", "obj", "a", "se"], "list": ["ls", "List", "parent", "template", "summary", "format", "p", "n", "li", "out", "set", "page", "state", "spec", "alist", "pre", "this", "batch", "test", "net", "count", "detail", "next", "lists", "result", "details", "sequence", "act", "filter", "ll", "listed", "tag", "file", "ist", "name", "self", "chain", "total", "l", "code", "LIST", "all", "index", "lt", "tree", "info", "cache", "type", "level", "dl", "pool", "v", "loop", "top", "map", "data", "stack", "value", "layer", "stat", "table", "collection", "pos", "def", "config", "local", "video", "coll", "print", "ml", "st", "t", "obj", "base"], "poc": ["proc", "moc", "piot", " POC", "pioca", "pioc", "vpoc", "POC", " Poco", "mOC", "piac", "propOC", "vuc", "proproc", "vpoco", "ppoco", "ppOC", "puc", " proc", "vpOC", "pac", "pocon", "noca", " pot", "pporp", "voc", "porp", "Porp", "nac", " pOC", "ppocon", " pac", "vorp", " Poc", "propoc", "ppuc", "Puc", "poca", " Pocon", "pOC", "mroc", "pot", "propoca", "vpocon", "noc", " poca", "ppoc", "poco", "moca", "Poc", "vOC", "not"], "ref_flag": ["ref_lag", " ref_lag", "ref_Flag", "ref2lag", " ref_Flag", " ref_flags", "ref2flags", "ref_flags", "ref2flag"], "ref": ["id", "tmp", "mb", "ro", "ext", "p", "cal", "page", "ne", "req", "pr", "ef", "conf", "rf", "nav", "comp", "spec", "rm", "by", "ret", "f", "resp", "agg", "mem", "re", "this", "br", "row", "tip", "crit", "cb", "coord", "act", "link", "msg", "tab", "seq", "check", "cmp", "note", "tag", "file", "rec", "alt", "ror", "eval", "rev", "remote", "range", "frame", "arg", "rep", "rel", "rest", "addr", "all", "to", "inf", "index", "res", "find", "info", "cache", "snap", "gen", "call", "block", "diff", "err", "ob", "db", "val", "v", "Ref", "REF", "col", "rem", "repl", "reflect", "map", "doc", "prop", "item", "eb", "value", "term", "g", "img", "r", "url", "b", "be", "lit", "orig", "def", "grab", "reference", "reg", "null", "disc", "obj"], "nb_refs": ["nb_Refos", "nb_ptos", "nb_refts", "nb_colns", "nb_cols", "nb_colts", "nb_defs", "nb_defm", "nb_findds", "nb_mberences", "nb_Refds", "nb_Refs", "nb_deferences", "nb_mbs", "nb_Refi", "nb_refds", "nb_findi", "nb_coli", "nb_References", "nb_refl", "nb_mbl", "nb_findns", "nb_references", "nb_ptts", "nb_refos", "nb_mbm", "nb_Refts", "nb_Refns", "nb_refm", "nb_pti", "nb_colos", "nb_Refm", "nb_Refl", "nb_refns", "nb_defl", "nb_refi", "nb_finds", "nb_pts", "nb_colds"]}}
{"project": "qemu", "commit_id": "fae38221e78fc9f847965f6d18b359b8044df348", "target": 1, "func": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n", "idx": 2415, "substitutes": {"dc": ["ec", "vc", "d", "cp", "fc", "cd", "cr", "dt", "c", "pc", "bc", "DC", "nc", "dd", "ca", "ci", "mc", "comm", "td", "dat", "controller", "dm", "oc", "ctl", "kw", "dl", "df", "cs", "ctx", "gc", "de", "co", "dr", "cc", "di", "dp", "ct", "draw", "disc", "rc", "cm", "lc", "ac", "da", "tc", "cca"], "r": ["mr", "br", "rd", "id", "q", "d", "cr", "usr", "l", "lr", "j", "er", "rg", "c", "nr", "vr", "p", "hr", "g", "n", "rer", "attr", "result", "row", "rank", "rb", "m", "res", "i", "x", "entry", "req", "type", "pr", "sr", "kr", "error", "rf", "err", "e", "w", "role", "rec", "fr", "rr", "ir", "rt", "ror", "or", "ar", "rev", "ry", "rs", "range", "dr", "v", "h", "o", "rel", "rar", "f", "rc", " err", "tr", "ri", "t", "re", "R", "rn"], "tn": ["mt", "TN", "dt", "tt", "tg", "tk", "wn", "utt", "n", "pn", "txt", "np", " tu", "vt", "out", " tv", "td", "tun", " ts", "kt", "tx", "gt", "qt", "tm", "tf", "Sn", "tp", "token", " TN", "tz", " tf", "ctl", "tl", "ts", "nut", "ln", "nm", " t", " tc", "tu", "btn", " out", "nt", "nz", " td", "wt", "nn", "fn", "bn", "t", "tc", "Tu", "tw", "sn"]}}
{"project": "FFmpeg", "commit_id": "b9fa32082c71013e90eab9e9997967d2939cf4a6", "target": 1, "func": "static int vorbis_parse_id_hdr(vorbis_context *vc){\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t bl0, bl1;\n\n\n\n    if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') ||\n\n    (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||\n\n    (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (no vorbis signature). \\n\");\n\n        return 1;\n\n    }\n\n\n\n    vc->version=get_bits_long(gb, 32);    //FIXME check 0\n\n    vc->audio_channels=get_bits(gb, 8);   //FIXME check >0\n\n    vc->audio_samplerate=get_bits_long(gb, 32);   //FIXME check >0\n\n    vc->bitrate_maximum=get_bits_long(gb, 32);\n\n    vc->bitrate_nominal=get_bits_long(gb, 32);\n\n    vc->bitrate_minimum=get_bits_long(gb, 32);\n\n    bl0=get_bits(gb, 4);\n\n    bl1=get_bits(gb, 4);\n\n    vc->blocksize[0]=(1<<bl0);\n\n    vc->blocksize[1]=(1<<bl1);\n\n    if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (illegal blocksize). \\n\");\n\n        return 3;\n\n    }\n\n    // output format int16\n\n    if (vc->blocksize[1]/2 * vc->audio_channels * 2 >\n\n                                             AVCODEC_MAX_AUDIO_FRAME_SIZE) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \"Vorbis channel count makes \"\n\n               \"output packets too large.\\n\");\n\n        return 4;\n\n    }\n\n    vc->win[0]=ff_vorbis_vwin[bl0-6];\n\n    vc->win[1]=ff_vorbis_vwin[bl1-6];\n\n\n\n    if(vc->exp_bias){\n\n        int i, j;\n\n        for(j=0; j<2; j++){\n\n            float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float));\n\n            for(i=0; i<vc->blocksize[j]/2; i++)\n\n                win[i] = vc->win[j][i] * (1<<15);\n\n            vc->win[j] = win;\n\n        }\n\n    }\n\n\n\n    if ((get_bits1(gb)) == 0) {\n\n        av_log(vc->avccontext, AV_LOG_ERROR, \" Vorbis id header packet corrupt (framing flag not set). \\n\");\n\n        return 2;\n\n    }\n\n\n\n    vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->channel_floors  = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->saved           = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->ret             = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->buf             = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->buf_tmp         = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->previous_window=0;\n\n\n\n    ff_mdct_init(&vc->mdct[0], bl0, 1);\n\n    ff_mdct_init(&vc->mdct[1], bl1, 1);\n\n\n\n    AV_DEBUG(\" vorbis version %d \\n audio_channels %d \\n audio_samplerate %d \\n bitrate_max %d \\n bitrate_nom %d \\n bitrate_min %d \\n blk_0 %d blk_1 %d \\n \",\n\n            vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]);\n\n\n\n/*\n\n    BLK=vc->blocksize[0];\n\n    for(i=0;i<BLK/2;++i) {\n\n        vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358)));\n\n    }\n\n*/\n\n\n\n    return 0;\n\n}\n", "idx": 2424, "substitutes": {"vc": ["cp", "c", "ev", "ow", "hw", "var", "dll", "form", "gt", "vp", "ctl", "vm", "cf", "ant", "vv", "xp", "wd", "cs", "ud", "vision", "wx", "sky", "ot", "serv", "vd", "ht", "fw", "vl", "bc", "sv", "watch", "ic", "act", "kt", "ce", "voc", "tp", "VC", "lv", "voice", "mk", "gc", "CV", "uv", "av", "craft", "vr", "dc", "vt", "ci", "fax", "csv", "etc", "vi", "att", "dev", "vet", "ctx", "v", "ve", "rc", "advert", "cmd", "wcs", "fc", "lp", "inv", "pc", "xc", "tt", "pp", "nv", "vy", "irm", "vec", "cv", "vert", "coll", "rt", "ell", "cc", "ct", "ee", "lc"], "gb": ["Gb", "sys", "cd", "mb", "git", "eb", "vg", "pc", "rg", "tg", "bm", "kb", "gif", "g", "img", "py", "attr", "gpu", "deg", "rect", "vt", "cfg", "cb", "rb", "csv", "gp", "html", "gy", "phy", "pg", "gd", "eg", "linux", "gt", "storage", "bb", "xy", "bs", "bt", "gu", "hub", "gnu", "eu", "ch", "vm", "cv", "goo", "um", "ctx", "px", "bg", "ruby", "gc", "wb", "db", "hz", "bytes", "uv", "bits", "GB", "gs", "sb", "bn", "gm", "gg", "bf", "nb", "elt", "raw", "ib", "gh", "buff"], "bl0": ["Bl00", "ble8", "bcinder", "pl0", "lb06", "bl00", "Bl10", "bc0", "gl8", "batch8", "lb6", "lb00", "BL1", "bcZero", "gl00", "abl00", "Bl1", "blinder", "batch5", "abl0", "batch0", "block0", "pl1", "bl000", "gl06", " blZero", "ble10", "ble000", "ble5", "Bl2", "bm3", "bl5", "bc3", "bminder", "block1", " bl10", " bl00", "bl3", "bl06", "Bl0", "bl8", "gl0", "BL0", "abl6", "Bl3", " blinder", "ble00", "bl10", "block3", "gl6", "gl1", " bl3", "bm0", "ble0", "gl5", "blZero", "bl2", "batch000", "gl000", "abl06", "lb0", "pl00", "bl6", " bl2", "BL2", "bmZero"], "bl1": [" bl4", "bleOne", "bl001", "ll2", "pl0", " bl11", "ll3", "gl01", "label01", "ble3", "lb001", "fl1", "batch6", "bl01", "lb6", "ble4", " bl01", "BL1", "Bl1", "ll1", "BL4", "blOne", "pln", "ble2", " bl9", "block2", "lbN", "BlOne", "fl4", "bln", "batch4", "BL11", " bl001", "pl1", "fl11", "bl4", "bl9", "ble6", " blOne", "blen", " bln", "bl11", "abl4", "Bl2", "ll9", "blN", "abl3", "block1", "label6", "bl3", "batch3", "label1", "glN", "BL0", "abl6", "block9", "abl1", "lb1", "block3", "labelN", "gl6", "gl1", "ble1", " bl3", "batch1", "ble0", "bl2", "ble001", "fl0", "pl2", "bl6", " bl2", "lb01", "ble01"], "i": ["ii", "ji", "c", "p", "g", "n", "pi", "r", "li", "ci", "m", "b", "x", "ij", " ii", "y", "k", "bi", "ix", "v", "mi", "o", "ai", "I", "si", "t"], "j": ["jump", "q", "l", "jp", "ji", "dj", "c", "jit", "bj", "jack", "aj", "uj", "z", "p", "g", "n", "kj", "r", "ng", "m", "jas", "b", "msg", "J", "ij", "jl", "job", "js", "y", "ch", "k", "jo", "ie", "jc", "oj", "ind", "ja", "ix", "v", "kid", "jj", "json"], "win": ["proc", "sys", "gn", "gain", "word", "use", "pc", "mask", "Win", "wire", "init", "window", "hw", "write", "pack", "pac", "nw", "lock", "weight", "ll", "pad", "wall", "w", "wd", "bin", "wrap", "wit", "wal", "loss", "windows", "root", "draw", "wk", "mem", "map", "cmd"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,\n\n                                         src - (stride * 2) +\n\n                                         sizeof(uint8_t), stride, dst, stride);\n\n}\n", "idx": 2429, "substitutes": {"dst": [" ddest", "Ddest", "fdest", "ddest", "Dest", "fst", "pdest", "pput", "pst", "mst", "mput", "fsrc", "mest", "pest", "mdest", " dsrc", "fest", " dest", "dsrc", "dest", "Dst", "Dsrc", " dput", "dput"], "src": ["sys", "input", "inst", "ctr", "inner", "fc", "addr", "bc", "sh", "source", "sec", "img", "r", "np", "s", "usc", "dist", "lat", "b", "ur", "start", "sc", "cur", "req", "dq", "sur", "sub", "ser", "sr", "desc", "ptr", "rec", "comp", "rl", "dest", "str", "rt", "now", "RC", "loc", "rs", "in", "urg", "cc", "rc", "sb", "st", "ins", "sq", "supp", "sn"], "stride": ["stringid", "drose", "stides", "strided", "STRide", "stringope", "sided", " drice", "strid", "stice", "STRice", "side", "drid", "drride", "slince", "STRride", " strides", "dride", " strride", "slride", " dride", " strope", " strided", " strince", " strose", "stringide", " strid", "strice", "slose", "stringice", "stide", "sride", " strice", "STRides", "strope", " drid", "strides", " drope", "sid", "strose", "drided", "strride", "strince", "drince", "slide"]}}
{"project": "qemu", "commit_id": "c1bf3531aecf4a0ba25bb150dd5fe21edf406c88", "target": 1, "func": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr,\n\n                               int queues)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n    int i;\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n\n                 i, chr->label);\n\n\n\n        nc->queue_index = i;\n\n\n\n        s = DO_UPCAST(VhostUserState, nc, nc);\n\n        s->chr = chr;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n\n\n\n    return 0;\n\n}\n", "idx": 2451, "substitutes": {"peer": ["proc", "parent", "pro", "er", "instance", "pc", "host", "holder", "port", "component", "p", "conn", "server", "node", "me", "package", "pp", "pod", "nw", "pe", "tp", "dev", "connection", "context", "cv", "owner", "ctx", "pool", "pkg", "ter", "remote", "target", "client", "ker", "primary", "channel", "camera", "enter", "point", "socket", "chain"], "device": ["id", "user", "directory", "pipe", "description", "window", "node", "server", "package", "mode", "label", "power", "devices", " dev", "phy", "password", "pod", "serial", "family", "pe", "controller", "product", "dev", "location", " Device", "command", "attribute", "owner", "Device", "resource", "DEV", "address", "slave", "drive"], "name": ["data", "id", "parent", "NAME", "nam", "user", "key", "number", "size", "word", "no", "port", "text", "n", "names", "node", "package", "server", "order", "path", "password", "ame", "unknown", "family", "info", "new", "type", "title", "dev", "time", "location", "t", "file", "local", "version", "comment", "error", "w", "alias", "nm", "ment", "group", "pass", "address", "Name", "event", "prefix", "phone", "mem", "length"], "chr": ["chrt", "Chdr", "chedr", " Chr", "CHrs", "phrc", "phrb", " chrt", "CHrb", "CHr", "chrs", " chrs", "chro", " chro", "Chrl", " Chdr", "chrb", "Char", "Chrb", " Chrt", "chrc", "cherl", " Char", "chdr", "Chrt", " chdr", " chrb", "Chrc", "CHR", "cheR", " chrl", "ChR", "Chr", "cherr", " chrc", "phr", "cherro", "Chro", "Chrs", "chrl", " chR", "cher", "cherrb", "chR", "phrs", "cherdr"], "queues": ["queued", "querforces", "Queued", "queueqs", "requforces", "querues", "requued", "queqs", "Queves", "Queue", "queves", "Queues", "queueforces", "queumers", "requues", "requumers", "quesves", "quesued", "quesues", "requves", "requqs", "querqs", "queue", "quesue", "querumers", "queueumers", "queforces", "requue", "queueues"], "nc": ["NT", "net", "nb", "NC", "nr", "pc", "xc", "bc", "c", "cn", "nl", "conn", "unc", "conv", "n", "nih", "cus", "pn", "nil", "np", "init", "txt", "ng", "comm", "cb", "CN", "nv", "nex", "ne", "sc", "qt", "yn", "ll", "cons", "roc", "ns", "oc", "ctl", "auc", "cv", "cs", "ctx", "Ns", "nic", "con", "co", "anc", "nm", "gc", "obj", "mn", "cc", "nt", "nz", "ct", "nn", "fn", "nec", "ck", "bn", "enc", "mc", "yo", "cmd", "rn"], "s": ["sys", "ls", "j", "S", "stats", "c", "socket", "is", "sv", "ss", "p", "es", "n", "vs", "ses", "sa", "set", "ds", "b", "fs", "less", "sc", "uns", "iss", "ps", "js", "ns", "bs", "oss", "sam", "cs", "ts", "hs", "sts", "rs", "sp", "h", "o", "gs", "ats", "sq", "so", "os", "ys", "acs", "ssl", "news", "sn"], "i": ["multi", "j", "id", "number", "l", "ii", "ki", "iq", "c", "is", "port", "z", "p", "sim", "to", "g", "n", "xi", "ic", "pi", "index", "qi", "me", "li", "ci", "counter", "ei", "m", "x", "cli", "ui", "phi", "it", "gi", "ij", "ex", " ti", "ip", " ii", "gu", "y", "ims", "bi", "im", "e", "hi", "ms", "ti", "iu", " I", "ind", "ix", "queue", "v", "zi", "in", " ni", "mi", "di", "o", "ini", "h", "ai", "I", "si", "point", "t", "my"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flv_probe(AVProbeData *p)\n\n{\n\n    const uint8_t *d;\n\n\n\n    if (p->buf_size < 6)\n\n        return 0;\n\n    d = p->buf;\n\n    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {\n\n        return AVPROBE_SCORE_MAX;\n\n    }\n\n    return 0;\n\n}\n", "idx": 2466, "substitutes": {"p": ["fp", "proc", "cp", "q", "j", "wp", "op", "jp", "pc", "c", "up", "n", "P", "pb", "r", "bp", "app", "progress", "pp", "mp", "np", "m", "b", "part", "ps", "pat", "pa", "w", "e", "ap", "pl", "press", "pkg", "post", "pt", "v", "pre", "sp", "dp", "pers", "ad", "f", "pd", "rep", "t", "a", "pro"], "d": ["data", "j", "rd", "q", "l", "dt", "c", "nd", "bd", "z", "dd", "all", "dict", "n", "dc", "g", "r", "dump", "debug", "dist", "ds", "dig", "dat", "m", "b", "md", "new", "dh", "ord", "it", "dra", "ade", "dq", "ed", "y", "sd", "did", "desc", "dl", "w", "df", "dos", "str", "ind", "del", "db", "fd", "loc", "dr", "v", "vol", "di", "done", "ad", "f", "dim", "D", "da", "t", "json", "ld"]}}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static void scsi_read_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad read tag 0x%x\\n\", tag);\n\n        /* ??? This is the wrong error.  */\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_read_request(r);\n\n}\n", "idx": 2471, "substitutes": {"d": ["data", "l", "dt", "c", "p", "dep", "dd", "g", "n", "dx", "dc", "ds", "m", "dat", "b", "md", "dh", "dra", "dev", "dm", "sd", "did", "w", "e", "del", "db", "fd", "dr", "v", "h", "di", "ad", "f", "D", "t", "dn"], "tag": ["mt", "data", "id", "cat", "key", "test", "po", "match", "code", "word", "value", "tg", "term", "row", "attr", "tty", " TAG", "label", "TAG", "bug", "debug", "sum", "pg", "Tag", "num", "msg", "qual", "zero", "at", "type", "pad", "token", "tags", "t", "tail", "version", "error", "peg", "name", " Tag", "bad", "ag", "reg", "offset", "field", "arg", "date", "ype", "feat", "length", "cmd"], "s": ["sys", "ls", "sis", "S", "south", "stats", "c", "sg", "is", "sv", "ss", "es", "sl", "ses", "set", "ds", "qs", "space", "less", "su", "iss", "ps", "ns", "sr", "ts", "spec", "sts", "rs", "v", "h", "gs", "ats", "ins", "st", "sq", "os", "so", "state", "self"], "r": ["mr", "br", "rd", "q", "j", "cr", "l", "lr", "er", "rg", "ro", "c", "vr", "p", "g", "n", "ren", "attr", "result", "rb", "m", "res", "rw", "b", "u", "ur", "request", "req", "run", "pr", "R", "sr", "k", "err", "w", "e", "rec", "fr", "rr", "rt", "ar", "dr", "rs", "rm", "v", "h", "rel", "f", "rc", "repl", "t", "re", "rar", "rn"]}}
{"project": "FFmpeg", "commit_id": "13ccba50d45662a15777b549b2fcd9b4621b0e01", "target": 0, "func": "static void opt_output_file(void *optctx, const char *filename)\n\n{\n\n    OptionsContext *o = optctx;\n\n    AVFormatContext *oc;\n\n    int i, err;\n\n    AVOutputFormat *file_oformat;\n\n    OutputStream *ost;\n\n    InputStream  *ist;\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    oc = avformat_alloc_context();\n\n    if (!oc) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n\n\n    if (last_asked_format) {\n\n        file_oformat = av_guess_format(last_asked_format, NULL, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Requested output format '%s' is not a suitable output format\\n\", last_asked_format);\n\n            exit_program(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    } else {\n\n        file_oformat = av_guess_format(NULL, filename, NULL);\n\n        if (!file_oformat) {\n\n            fprintf(stderr, \"Unable to find a suitable output format for '%s'\\n\",\n\n                    filename);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->oformat = file_oformat;\n\n    av_strlcpy(oc->filename, filename, sizeof(oc->filename));\n\n\n\n    if (!strcmp(file_oformat->name, \"ffm\") &&\n\n        av_strstart(filename, \"http:\", NULL)) {\n\n        /* special case for files sent to avserver: we get the stream\n\n           parameters from avserver */\n\n        int err = read_avserver_streams(oc, filename);\n\n        if (err < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    } else if (!o->nb_stream_maps) {\n\n        /* pick the \"best\" stream of each type */\n\n#define NEW_STREAM(type, index)\\\n\n        if (index >= 0) {\\\n\n            ost = new_ ## type ## _stream(oc);\\\n\n            ost->source_index = index;\\\n\n            ost->sync_ist     = &input_streams[index];\\\n\n            input_streams[index].discard = 0;\\\n\n        }\n\n\n\n        /* video: highest resolution */\n\n        if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) {\n\n            int area = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                    ist->st->codec->width * ist->st->codec->height > area) {\n\n                    area = ist->st->codec->width * ist->st->codec->height;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(video, idx);\n\n        }\n\n\n\n        /* audio: most channels */\n\n        if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) {\n\n            int channels = 0, idx = -1;\n\n            for (i = 0; i < nb_input_streams; i++) {\n\n                ist = &input_streams[i];\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO &&\n\n                    ist->st->codec->channels > channels) {\n\n                    channels = ist->st->codec->channels;\n\n                    idx = i;\n\n                }\n\n            }\n\n            NEW_STREAM(audio, idx);\n\n        }\n\n\n\n        /* subtitles: pick first */\n\n        if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) {\n\n            for (i = 0; i < nb_input_streams; i++)\n\n                if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n                    NEW_STREAM(subtitle, i);\n\n                    break;\n\n                }\n\n        }\n\n        /* do something with data? */\n\n    } else {\n\n        for (i = 0; i < o->nb_stream_maps; i++) {\n\n            StreamMap *map = &o->stream_maps[i];\n\n\n\n            if (map->disabled)\n\n                continue;\n\n\n\n            ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index];\n\n            switch (ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_VIDEO:    ost = new_video_stream(oc);    break;\n\n            case AVMEDIA_TYPE_AUDIO:    ost = new_audio_stream(oc);    break;\n\n            case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break;\n\n            case AVMEDIA_TYPE_DATA:     ost = new_data_stream(oc);     break;\n\n            default:\n\n                av_log(NULL, AV_LOG_ERROR, \"Cannot map stream #%d.%d - unsupported type.\\n\",\n\n                       map->file_index, map->stream_index);\n\n                exit_program(1);\n\n            }\n\n\n\n            ost->source_index = input_files[map->file_index].ist_index + map->stream_index;\n\n            ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index +\n\n                                           map->sync_stream_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    av_dict_copy(&oc->metadata, metadata, 0);\n\n    av_dict_free(&metadata);\n\n\n\n\n\n    output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);\n\n    output_files[nb_output_files - 1].ctx       = oc;\n\n    output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;\n\n    output_files[nb_output_files - 1].recording_time = o->recording_time;\n\n    output_files[nb_output_files - 1].start_time     = o->start_time;\n\n    output_files[nb_output_files - 1].limit_filesize = limit_filesize;\n\n    av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);\n\n\n\n    /* check filename in case of an image number is expected */\n\n    if (oc->oformat->flags & AVFMT_NEEDNUMBER) {\n\n        if (!av_filename_number_test(oc->filename)) {\n\n            print_error(oc->filename, AVERROR(EINVAL));\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n\n        /* test if it already exists to avoid loosing precious files */\n\n        if (!file_overwrite &&\n\n            (strchr(filename, ':') == NULL ||\n\n             filename[1] == ':' ||\n\n             av_strstart(filename, \"file:\", NULL))) {\n\n            if (avio_check(filename, 0) == 0) {\n\n                if (!using_stdin) {\n\n                    fprintf(stderr,\"File '%s' already exists. Overwrite ? [y/N] \", filename);\n\n                    fflush(stderr);\n\n                    if (!read_yesno()) {\n\n                        fprintf(stderr, \"Not overwriting - exiting\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                }\n\n                else {\n\n                    fprintf(stderr,\"File '%s' already exists. Exiting.\\n\", filename);\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* open the file */\n\n        if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {\n\n            print_error(filename, err);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    oc->preload= (int)(mux_preload*AV_TIME_BASE);\n\n    oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE);\n\n    oc->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* copy chapters */\n\n    if (chapters_input_file >= nb_input_files) {\n\n        if (chapters_input_file == INT_MAX) {\n\n            /* copy chapters from the first input file that has them*/\n\n            chapters_input_file = -1;\n\n            for (i = 0; i < nb_input_files; i++)\n\n                if (input_files[i].ctx->nb_chapters) {\n\n                    chapters_input_file = i;\n\n                    break;\n\n                }\n\n        } else {\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid input file index %d in chapter mapping.\\n\",\n\n                   chapters_input_file);\n\n            exit_program(1);\n\n        }\n\n    }\n\n    if (chapters_input_file >= 0)\n\n        copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]);\n\n\n\n    /* copy metadata */\n\n    for (i = 0; i < nb_meta_data_maps; i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            exit_program(1);\\\n\n        }\n\n\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = oc;\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy && nb_input_files)\n\n        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n    if (metadata_streams_autocopy)\n\n        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist = &input_streams[output_streams[i].source_index];\n\n            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_width   = 0;\n\n    frame_height  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    chapters_input_file = INT_MAX;\n\n    limit_filesize = UINT64_MAX;\n\n\n\n    av_freep(&meta_data_maps);\n\n    nb_meta_data_maps = 0;\n\n    metadata_global_autocopy   = 1;\n\n    metadata_streams_autocopy  = 1;\n\n    metadata_chapters_autocopy = 1;\n\n    av_freep(&streamid_map);\n\n    nb_streamid_map = 0;\n\n\n\n    av_dict_free(&codec_names);\n\n\n\n    av_freep(&forced_key_frames);\n\n    reset_options(o);\n\n}\n", "idx": 2502, "substitutes": {"optctx": ["optioncmp", "optcp", " opttx", "opcontext", "opcp", "objcp", "optioncontext", " optcc", "opcmp", "opcc", "optx", " optcmp", "optcc", "optioncc", "optcmp", " optcp", "opctx", "objtx", "optionctx", "opttx", " optcontext", "optcontext", "objctx", "objcontext"], "filename": ["ames", "NAME", "format", "unc", "ename", "n", "ren", "ammy", "rather", "nil", "localhost", "kl", "path", "println", "username", "buffer", "fps", "there", "nom", "uri", "AME", "f", "png", "fn", "asm", "fp", "FIL", "lr", "LCS", "tif", "session", "upload", "names", "lua", "mpeg", "sequence", "msg", "stem", "location", "file", "name", "aka", "FN", "what", "position", "abl", "length", "json", "wine", "kan", "size", "word", "directory", "seek", "fle", "kj", "processor", "csv", "oval", "ame", "INAL", "SOURCE", "title", "finals", "existent", "nm", "til", "src", "prefix", "master", "unction", "journal", "wav", "wcs", "fil", "status", "amen", "txt", "mson", "metadata", "severe", "origin", "amer", "ername", "ja", "Filename", "null", "original", "jpg", "generation", "wikipedia", "dn"], "o": ["ec", "d", "oid", "po", "op", "c", "p", "n", "O", "ic", "og", "oa", "m", "ox", "u", "ou", "opt", "k", "w", "e", "oin", "ob", "co", "bo", "go", "io", "v", "od", "h", "oo", "f", "ot", "os", "t", "obj"], "oc": ["doc", "ec", "vc", "ko", "alloc", "cp", "ocation", "oid", "ocol", "AC", "op", "vo", "c", "pc", "nc", "bc", "unc", "soc", "org", "cms", "dc", "ic", "ico", "og", "mc", "oco", "ox", "pg", "tx", "ce", "ogg", "OC", "ok", "voc", "roc", "opt", "toc", "osc", "irc", "arc", "oci", "circ", "canon", "ctx", "aco", "nic", "ob", "co", "coll", "anc", "go", "oly", "loc", "abc", "ocr", "oo", "rc", "ot", "aic", "os", "ac", "oad", "obj", "yo"], "i": ["multi", "batch", "id", "ii", "instance", " mi", "c", "ji", "is", "p", "sim", "init", "xi", "pi", "r", "index", "iter", "qi", "ci", "li", " di", "me", "ami", "m", "ei", "x", "ui", " vi", "phi", "gi", "it", "ij", " ti", " si", "ip", " ii", " index", "y", " x", "bi", "iu", "ti", "ind", "uri", " li", "ix", "zi", "mi", "ini", "di", "ai", "si", "I", "t", " bi"], "err": ["mr", "proc", "br", "ni", "ctr", "usr", "core", "cr", "try", "func", "lr", "ori", "er", "arr", "buf", "nr", "test", "aaa", "init", "ev", "attr", "result", "r", "txt", "pi", "iter", "order", "ner", "cfg", "bug", "cb", "rb", "score", "coord", "ei", "res", "erer", "late", "msg", "notice", "priv", "req", "yr", "dev", "kr", "conf", "rank", "error", "rss", "ptr", "Er", "fr", "eor", "rr", "ir", "ind", "rev", "Error", "dr", "rs", "fee", "gz", "rc", "resp", "elt", "obj", "my", "len", "cmd"], "file_oformat": ["file_oplan", "file____oiformat", "file_opformat", "file_OFormat", "file_fform", "file_voformat", "file____oatt", "file_oiatt", "file____oformat", "file_osformat", "file_tmat", "file_nform", "file_oiformat", "file_oversion", "file_etype", "file_osterm", "file____oiform", "file_tformat", "file_oft", "file_osversion", "file_onetformat", "file_opcondition", "file_tform", "file_ntype", "file_fformat", "file_onetprintf", "file_voterm", "file_oiform", "file_ojoin", "file_Oformat", "file_oijoin", "file_oprintf", "file_ocondition", "file_eFormat", "file_ospattern", "file_oform", "file_objplan", "file_onetmat", "file_onetform", "file_Oform", "file_Omat", "file_eformat", "file_oiplan", "file_vomat", "file_Opattern", "file_osform", "file_Otype", "file_objformat", "file_nFormat", "file____oipattern", "file____oform", "file_nft", "file_osatt", "file_objcondition", "file_objjoin", "file_tprintf", "file_fFormat", "file_omat", "file_Oversion", "file_oatt", "file_oFormat", "file_Oatt", "file_osmat", "file_oipattern", "file_opplan", "file_oterm", "file_opjoin", "file_eform", "file____oiatt", "file_nformat", "file_Oterm", "file_osprintf", "file_oicondition", "file____opattern", "file_opattern", "file_voversion", "file_otype", "file_fft"], "ost": ["sys", "oth", "oid", "OST", "op", "ond", "rest", "host", "tt", "ast", " nost", "unt", "ont", "onet", "bott", "yt", "ust", "ox", "oop", "rol", "rost", "voc", "oster", "opt", "otype", "oss", "stream", "umn", "sty", "ous", "ob", "ott", "od", "irst", "ocr", "oo", "ot", "st", "os", "vest", "\u00f3"], "ist": ["fp", "isc", "isd", "wp", "ister", "istor", "et", "rist", "htt", "IST", "is", "wi", "ast", "ism", "ic", "dit", "ust", "pir", "isting", "iste", "ui", "hist", "it", "ert", "aci", "xit", "ip", "osit", "irc", "exist", "elist", "oci", "ista", "ir", "ind", "alist", "pas", "iop", "ists", "ia", "irst", "ilst", "est", "isi", "st", "iat", "pect", "art", "std", "istant"]}}
{"project": "qemu", "commit_id": "8653c0158c23ec592f0041ab48b83d6cc6d152fe", "target": 0, "func": "static int spawn_thread(void)\n\n{\n\n    pthread_attr_t attr;\n\n    int ret;\n\n\n\n    cur_threads++;\n\n    idle_threads++;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return ret;\n\n}\n", "idx": 2523, "substitutes": {"attr": ["mt", "acc", "alloc", "ctrl", "gr", "temp", "tmp", "atts", "arr", "prop", "addr", "vr", "aaa", "tt", "tk", "ext", "p", "stat", "sort", "ev", "txt", "r", "emp", "rb", "dat", "aff", "var", " att", "b", "params", "msg", "tab", "md", "adj", "bar", "req", "ack", "att", "pr", "cmp", "tag", "opt", "perm", "kw", "cap", "desc", "err", "ptr", "attribute", "apt", "rr", "rl", "str", "pkg", "rt", "alt", "val", "rm", "rs", "ct", "wr", "rel", "arg", "tr", "abl", "args", "imm", "t", "obj", "ak", "cmd", "typ"], "ret": ["mt", "usr", "RET", "cat", "et", "l", "status", "match", "Return", " RET", "result", "bool", "r", "out", "res", "ft", "cont", "gt", "ll", "att", "Ret", " Ret", "xt", "err", "bis", "pas", "rt", "re", "alt", "rev", "ter", "print", "ry", "val", "rm", "rets", "rs", "nt", " alt", "arg", "tr", "por", "cert", "rem", "flag", "elt", "t", "len"], "cur_threads": ["cur_Threads", "cur_counteds", "cur_ctes", "cur_threades", "cur_counts", "cur_countes", "cur_Threades", "cur_threadries", "cur_threadeds", "cur_Threadeds", "cur_cts", "cur_countries", "cur_ctries", "cur_Threadries", "cur_cteds"], "idle_threads": ["idle_processs", "idle_Threadeds", "idle_poolries", "idle_threadries", "idle_Threads", "idle_Threades", "idle_pooleds", "idle_processeds", "idle_pooles", "idle_processries", "idle_threades", "idle_Threadries", "idle_processes", "idle_pools", "idle_threadeds"]}}
{"project": "FFmpeg", "commit_id": "52a213865670ae69c1852d4d04cf41f8929abbd0", "target": 0, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf      = pb->buf_ptr,\n\n                             .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2534, "substitutes": {"st": ["mt", "stan", "inst", "usr", "sta", "ste", "et", "rest", "ub", "nd", "sth", "sh", "stat", "s", "stable", "ust", "set", "ST", "kt", "store", "tx", "start", "sc", "at", "storage", "ack", "stop", "t", "state", "sw", "ist", "cast", "stream", "str", "rt", "pt", "sts", "nt", "irst", "sp", "est", "ost", "src", "sb", "th", "sn", "art", "stage", "std", "St"], "pkt": ["rkt", "paymit", "racket", "rmsg", "Packet", "opkt", "Pwk", " pmsg", "appwk", " pct", "opacket", "opmsg", "opnt", " pet", "ppmsg", "paykt", "pdu", "PKT", "pKT", "appKT", "payacket", " pwk", "cpnt", "appkt", " pmit", "Pkt", "ppnt", "ppkt", " pdu", "packet", "appnt", "pct", "pmsg", " pKT", "Pdu", "wct", "Pct", "Pet", "pnt", " packet", "rnt", "pwk", "ppet", "pet", "Pnt", " pnt", "paynt", "wkt", "Pmsg", "cpmit", "pmit", "cpacket", "cpkt", "wnt", "wdu", "ppacket"], "desc": ["doc", "ec", "data", "DES", "cd", "summary", "buf", "ript", "ext", "bd", "meta", "text", "sec", "dict", "dc", "description", "sort", "dir", "txt", "Desc", "uc", "label", "out", "dist", "set", "ds", "asc", "esc", "msg", "cont", "sc", "seq", "annot", "md", "cmp", "sub", " Desc", "comment", "metadata", "dl", "err", "ptr", "attr", "ribe", "rec", "name", "str", "nt", "bl", "disc", "raw", "des", "mem", "obj"], "ret": ["mt", "j", "RET", "tmp", "status", "arr", "buf", "summary", "jp", "Return", "nl", "sec", "fun", "ref", "result", "r", "txt", "lt", "res", "lit", "ft", "cont", "gt", "ll", "mem", "Ret", " Ret", "uf", "xt", "err", "ptr", "gc", "rt", "rev", "alt", "val", "rets", "nt", "nz", "rem", "resp", "elt", "rel", "re", "des", "len"], "ast": ["aft", "mt", "ace", "bound", "mast", "active", "ma", "sta", "art", "interface", "acl", "list", "asts", "aw", "rest", "ard", "addr", "nd", "past", "tt", "quest", "asted", "ref", "ab", "ah", "ief", "ess", "ust", "dist", "Ast", "act", "af", "tx", "asting", "annot", "at", "pat", "ait", "amb", "ed", "wat", "ist", "aid", "cast", "as", "ts", "ctx", "embed", "and", "anc", "each", "amd", "bart", "am", "old", "nt", "ost", "est", "must", "ad", "ac", "aster", "store", "AST", "esta", "a", "asm", "master", "std"], "sub_demuxer": ["sub_promuxed", "sub_demixie", "sub_demucers", "sub_demxer", "sub_Demuxe", "sub_Demuxer", "sub_demuce", "sub_demxe", "sub_demucer", "sub_DemluxER", "sub_demuxers", "sub_Demluxers", "sub_demxie", "sub_demxers", "sub_demluxers", "sub_demuxier", "sub_demluxed", "sub_promuxer", "sub_demuxER", "sub_demuploade", "sub_demuxie", "sub_demluxer", "sub_promxe", "sub_demxier", "sub_demixed", "sub_promuxie", "sub_promuxe", "sub_DemuxER", "sub_promxed", "sub_Demluxe", "sub_Demuxers", "sub_demluxier", "sub_promxer", "sub_demuxed", "sub_demluxER", "sub_demuploader", "sub_demxed", "sub_Demluxer", "sub_demixe", "sub_demuxe", "sub_demixer", "sub_demluxe", "sub_demuploadier", "sub_demluxie", "sub_demxER", "sub_demuploaders", "sub_promxie", "sub_demucER"], "time_base": ["time2base", "time_bas", " time_area", " time2base", "time_real", "time_pad", " time2bas", " time2frame", " time_bas", "time_area", "timepobas", "timepopad", "timeporeal", "time2frame", "timepobase", " time_frame", " time_pad", "time2bas", " time_real", "time_frame"], "pb": ["proc", "fp", "cp", "lp", "wp", "tmp", "jp", "buf", "pc", "ub", "bj", "bc", "eb", "tk", "mb", "tg", "p", "kb", "py", "erb", "np", "bp", "ab", "pp", "mp", "cb", "rb", "patch", "td", "pg", "b", "tx", "lb", "tab", "gb", "vp", "tf", "tp", "bb", "bs", "pa", "buffer", "tc", "cv", "ap", "ptr", "ctx", "px", "pool", "ob", "pkg", "emb", "gc", "pt", "db", "fb", "dp", "stab", "sb", "nb", "tap", "PB", "ib", "uf", "apa", "sp"], "pd": ["d", "cp", " pdf", "cd", "po", "dt", "dj", "pc", " dd", "bd", "p", "dd", " od", "pdf", "dx", " dc", "edd", "pm", "np", "pi", "pp", "ds", "td", "dat", " dw", "DT", "md", "dh", "vp", " sd", " np", "pe", "pr", "ps", "tp", "dq", "pat", " cd", "ctl", " PD", "sd", "dl", "pard", "df", "ctx", "PD", " md", "fd", " df", "ud", "xd", " td", "dp", "ad", "vd", " prod"]}}
{"project": "qemu", "commit_id": "1f8431f42d833e8914f2d16ce4a49b7b72b90db0", "target": 0, "func": "bool machine_iommu(MachineState *machine)\n\n{\n\n    return machine->iommu;\n\n}\n", "idx": 2535, "substitutes": {"machine": ["domain", "proc", "monitor", "template", "parent", "message", "instance", "value", "match", "component", "sim", "node", "me", "power", "dem", "server", "table", "engine", "m", "policy", "Machine", "achine", "shell", "STATE", "vm", "command", "agent", "one", "sm", "manager", "process", "channel", "handler", "money", "zone", "model", "state", "mc", "base", "module"]}}
{"project": "qemu", "commit_id": "cc68890166c2c1c5003e3eeb8535e1872e239a95", "target": 0, "func": "static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)\n\n{\n\n    uint32_t rd;\n\n    TCGv tmp, tmp2;\n\n\n\n    /* M profile cores use memory mapped registers instead of cp15.  */\n\n    if (arm_feature(env, ARM_FEATURE_M))\n\n\treturn 1;\n\n\n\n    if ((insn & (1 << 25)) == 0) {\n\n        if (insn & (1 << 20)) {\n\n            /* mrrc */\n\n            return 1;\n\n        }\n\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n\n        return 0;\n\n    }\n\n    if ((insn & (1 << 4)) == 0) {\n\n        /* cdp */\n\n        return 1;\n\n    }\n\n    if (IS_USER(s) && !cp15_user_ok(insn)) {\n\n        return 1;\n\n    }\n\n    if ((insn & 0x0fff0fff) == 0x0e070f90\n\n        || (insn & 0x0fff0fff) == 0x0e070f58) {\n\n        /* Wait for interrupt.  */\n\n        gen_set_pc_im(s->pc);\n\n        s->is_jmp = DISAS_WFI;\n\n        return 0;\n\n    }\n\n    rd = (insn >> 12) & 0xf;\n\n\n\n    if (cp15_tls_load_store(env, s, insn, rd))\n\n        return 0;\n\n\n\n    tmp2 = tcg_const_i32(insn);\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        tmp = new_tmp();\n\n        gen_helper_get_cp15(tmp, cpu_env, tmp2);\n\n        /* If the destination register is r15 then sets condition codes.  */\n\n        if (rd != 15)\n\n            store_reg(s, rd, tmp);\n\n        else\n\n            dead_tmp(tmp);\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        gen_helper_set_cp15(cpu_env, tmp2, tmp);\n\n        dead_tmp(tmp);\n\n        /* Normally we would always end the TB here, but Linux\n\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n\n        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||\n\n                (insn & 0x0fff0fff) != 0x0e010f10)\n\n            gen_lookup_tb(s);\n\n    }\n\n    tcg_temp_free_i32(tmp2);\n\n    return 0;\n\n}\n", "idx": 2538, "substitutes": {"env": ["ec", "et", "net", "er", "code", "buf", "conn", "g", "eh", "ev", "ener", "window", "vs", "hw", "server", "ah", "ner", "vt", "viron", "ds", "environment", "nv", "sc", "dev", "config", "state", "eu", "conf", "param", "context", "e", "w", "setup", "en", "cv", "ens", "ctx", "equ", "EN", "esp", "v", "h", "erd", "te", "ve", "esm", "enc", "eng", "eve", "cmd", "Environment", "sp"], "s": ["proc", "sys", "j", "S", "stats", "er", "c", "sg", "is", "sv", "ss", "p", "es", "settings", "g", "n", "vs", "r", "ses", "ds", "qs", "m", "i", "b", "sc", "services", "ps", "its", "js", "ns", "state", "http", "w", "e", "ms", "ts", "cs", "spec", "ctx", "hs", "sts", "v", "rs", "tests", "h", "gs", "sb", "ins", "args", "sq", "os", "t", "a", "self", "sp"], "insn": ["stsn", "pinsn", "intsnor", "ainsnor", "insgn", "Insn", "INSn", "intsnm", "outsgn", "insner", "statsn", "ipsn", "linsns", "pinsnum", "pinsne", "insns", "linsnum", "linssn", "lsn", "intersn", "rstn", "linsyn", "rsgn", "INScan", "linso", "statsner", "retso", "inso", "valsnor", "factso", "linsnr", "emsnm", "INSgn", "rsn", "linsne", "insN", "outsnr", "INSnr", "insnm", "intersne", "pinsgn", "intsne", "Insgn", "pinsns", "insnum", "factsnw", "statsgn", "lsgn", "emsne", "stsgn", "rssn", " insgn", "retssn", "Insns", "alsn", "INSdn", "inscan", "argsgn", "outssn", "factssn", "insnr", "interssn", "outsnor", "insyn", "Inssn", " inssn", "retsn", "insnor", "valscan", "INSyn", "outsne", "linsnw", "emsn", " insns", "valsdn", "stssn", "intersnor", "instn", " insne", " insnr", "INSnor", "linsN", "linsgn", "factsn", "ipscan", "csn", "linsn", "insnw", "argsn", "ipsnor", "retsnw", "Insner", "alsgn", "lsns", "INSnum", "intsn", "lssn", "argsyn", " insnor", "ainsne", "pinsN", "alsne", "pinsnr", "linsner", "statssn", "csne", "outsn", "ainssn", " insN", "ainsn", "valsn", "ststn", "emsnor", "linstn", "csgn", "INSsn", "outsnm", "insne", "inssn", "insdn", "argssn", "ipsdn"], "rd": ["mr", "d", " r", "cr", "cd", "lr", "rod", " red", "ard", "nd", "bd", "rust", "dd", "hr", "rid", "rob", "ren", "r", "ru", "ird", "rb", "mid", "td", "rw", "red", "ra", "rat", "ring", "ord", "RD", "ld", "dra", "md", "run", "sr", "rf", "rss", "ptr", "rh", " d", "fr", "rr", "round", "rx", "rt", "dr", "rs", "rm", "xd", "rend", "nder", "erd", "rc", "ri", "std", "rn", "fd"], "tmp": ["cp", "mint", "mb", "p", "out", "td", " resp", "vp", " np", "cow", "nom", "pkg", "wx", "ret", "resp", "mem", "tem", " sp", "result", "np", "appy", "rb", "rup", "msg", "cmp", "tp", "zip", "perm", "ptr", "mk", "mm", "nt", "tr", "nb", "trap", "obj", "jp", "buf", " cached", "vt", "mp", "csv", "new", "etc", "cache", "snap", "ctx", "tn", "v", "sp", "temp", "aaa", "tt", "tg", "term", "img", "attr", "txt", "dump", "emp", "rw", "tm", " mp", "tv", "tar", "cv", " temp", " ret", "rt", "utm", "gz", "st", "t", "tc", "buff"], "tmp2": ["temp8", "temp4", "cmp1", "tmp5", "mp3", " tmp3", "tmpTwo", "td3", "temp_", "temp2", " tmp1", " tmpTwo", " tmp8", " tmp4", "cmp3", "tmp4", "mp4", "mp1", "cmp5", "temp1", "mp_", "cmp2", "temp3", "tmp8", " tmp5", "tmp1", "mp8", " tmp_", "tmp3", "td2", "mp2", "mpTwo", "tdTwo", "mp5", "tmp_", "td1"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n", "idx": 2564, "substitutes": {"id": ["d", "oid", "key", " tid", " rid", "rid", "Id", "mid", "ids", "tag", "ip", "end", "aid", "name", "uid", "sid", "db", "vid", "ident", "h", "ID", "ad", "wid", "pid", "kid", "cmd"], "backend": [" backends", " backender", "backEND", " backEND", "BackEND", "bookended", "bookender", "Backends", "Backended", "backender", "backends", "backended", "bookend", " backended", "frontEND", "frontend", "Backend", "booketh", " backeth", "frontends", "Backeth", "backeth", "Backender", "frontended"], "ret": ["mt", "RET", "et", "ut", "unt", "read", "vt", "res", "lit", "etc", "def", "mem", "att", "Ret", "rt", "rev", "reg", "val", "pet", "det", "pub", "rc", "resp", "des", "t", "re", "back"], "errp": ["Erpa", " Errp", "errjp", " errjp", "Erp", "ErP", " Errr", " errpa", " errP", "errpa", " errr", " errps", "Erjp", "erP", " Errjp", "erp", "errps", "erps", "erpa", "errr", "errP", "Erps", " Errpa", "Err"]}}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    int fd = -1, ret;\n\n    USBHostDevice *dev = NULL;\n\n    struct usbdevfs_connectinfo ci;\n\n    char buf[1024];\n\n    int bus_num, addr;\n\n    char product_name[PRODUCT_NAME_SZ];\n\n\n\n    dev = qemu_mallocz(sizeof(USBHostDevice));\n\n    if (!dev)\n\n        goto fail;\n\n\n\n#ifdef DEBUG_ISOCH\n\n    printf(\"usb_host_device_open %s\\n\", devname);\n\n#endif\n\n    if (usb_host_find_device(&bus_num, &addr,\n\n                             product_name, sizeof(product_name),\n\n                             devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buf, sizeof(buf), USBDEVFS_PATH \"/%03d/%03d\",\n\n             bus_num, addr);\n\n    fd = open(buf, O_RDWR | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        perror(buf);\n\n        return NULL;\n\n    }\n\n\n\n    /* read the device description */\n\n    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));\n\n    if (dev->descr_len <= 0) {\n\n        perror(\"usb_host_device_open: reading device data failed\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    {\n\n        int x;\n\n        printf(\"=== begin dumping device descriptor data ===\\n\");\n\n        for (x = 0; x < dev->descr_len; x++)\n\n            printf(\"%02x \", dev->descr[x]);\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n    dev->fd = fd;\n\n    dev->configuration = 1;\n\n\n\n    /* XXX - do something about initial configuration */\n\n    if (!usb_host_update_interfaces(dev, 1))\n\n        goto fail;\n\n\n\n    ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n        goto fail;\n\n    }\n\n\n\n#ifdef DEBUG\n\n    printf(\"host USB device %d.%d grabbed\\n\", bus_num, addr);\n\n#endif\n\n\n\n    ret = usb_linux_update_endp_table(dev);\n\n    if (ret)\n\n        goto fail;\n\n\n\n    if (ci.slow)\n\n        dev->dev.speed = USB_SPEED_LOW;\n\n    else\n\n        dev->dev.speed = USB_SPEED_HIGH;\n\n    dev->dev.handle_packet = usb_generic_handle_packet;\n\n\n\n    dev->dev.handle_reset = usb_host_handle_reset;\n\n    dev->dev.handle_control = usb_host_handle_control;\n\n    dev->dev.handle_data = usb_host_handle_data;\n\n    dev->dev.handle_destroy = usb_host_handle_destroy;\n\n\n\n    if (product_name[0] == '\\0')\n\n        snprintf(dev->dev.devname, sizeof(dev->dev.devname),\n\n                 \"host:%s\", devname);\n\n    else\n\n        pstrcpy(dev->dev.devname, sizeof(dev->dev.devname),\n\n                product_name);\n\n\n\n#ifdef USE_ASYNCIO\n\n    /* set up the signal handlers */\n\n    sigemptyset(&sigact.sa_mask);\n\n    sigact.sa_sigaction = isoch_done;\n\n    sigact.sa_flags = SA_SIGINFO;\n\n    sigact.sa_restorer = 0;\n\n    ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: sigaction failed\");\n\n        goto fail;\n\n    }\n\n\n\n    if (pipe(dev->pipe_fds) < 0) {\n\n        perror(\"usb_host_device_open: pipe creation failed\");\n\n        goto fail;\n\n    }\n\n    fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);\n\n    fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK);\n\n    qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev);\n\n#endif\n\n    dev->urbs_ready = 0;\n\n    return (USBDevice *)dev;\n\nfail:\n\n    if (dev)\n\n        qemu_free(dev);\n\n    close(fd);\n\n    return NULL;\n\n}\n", "idx": 2583, "substitutes": {"usb_host_device_open": ["usb_host_device__init", "usb_host_dev_close", "usb_host_dev__Open", "usb_host_dev_init", "usb_host_device2Open", "usb_host_dev__close", "usb_host_device_close", "usb_host_device2init", "usb_host_device__open", "usb_host_device2open", "usb_host_device_Open", "usb_host_device__Open", "usb_host_device__close", "usb_host_dev_open", "usb_host_dev_Open", "usb_host_device_init", "usb_host_dev__open", "usb_host_device2close", "usb_host_dev__init"], "devname": ["devlen", "evname", "evNAME", " devnames", "propname", "devstr", "devnames", "devName", "devicelen", "propName", "camName", "evstr", "evnames", "propno", " devlen", " devName", "evlen", "evno", "camnames", "deviceName", "devicename", " devstr", "propstr", "devNAME", "camname", " devNAME", "evName", "camNAME", "devno", " devno"], "ret": ["success", "mt", "usr", "RET", "try", "net", "tmp", "status", "Return", "nl", " RET", "fun", "tif", "ref", "result", "txt", "out", "failed", "url", "sat", "res", "fin", "ft", "cont", "valid", "gt", "def", "att", "Ret", "pat", " Ret", "not", "fi", "nat", "desc", "err", "ptr", "got", "complete", "rt", "alt", "del", "re", "get", "backed", "val", "rm", "rets", "nt", "rel", "det", "tr", "flag", "cert", "resp", "rem", "elt", "t", "mem", "reset", "back", "len", "cmd"], "dev": ["user", "env", "tmp", "api", "handle", "port", "cho", "ev", "ow", "window", "hw", "server", "app", "out", "td", "var", "develop", "form", "req", "conf", "disk", "cam", "cast", "wd", "ver", "nav", "de", "h", "sky", "mem", "scan", "Dev", "d", "test", " device", "bd", "row", "dem", "link", "serial", "gu", "end", "final", "normal", "ptr", "den", "tech", "remote", "nt", "dn", "driver", "av", "tr", "self", "device", "all", "dd", "build", "controller", "priv", "att", "pad", "sw", "comment", "hd", "err", "Device", "home", "go", "db", "v", "ov", "val", "od", "di", "draw", "det", "ve", "rem", "dis", "master", "cmd", "doc", "proc", "data", "sys", "alloc", "eth", "add", "temp", "vo", "sh", "conn", "attr", "query", "package", "util", "debug", "unknown", "start", "def", "local", "ch", "sd", "w", "command", "DEV", "disc", " Dev", "ad", "raw", "des", "store", "slave", "obj", "fo", "pro"], "ci": ["ni", "vc", "ace", "ati", "ii", "ki", " mi", "c", "dc", " ki", " dc", "ic", "pi", "cfg", " di", " mc", "li", "ami", " c", "wa", "i", " nic", " cf", "cli", "cgi", "info", " vi", " sd", "cci", "vi", " i", "aci", " cd", " si", "fi", " ii", " cs", " ti", " pi", "iw", " sc", "ti", "cs", "ctx", "CI", "co", " ca", "io", "ia", "cu", "cc", " circ", " ni", "mi", "di", "ini", "icc", "ai", "si", " cc", "cm", "lc", "mc", "ctrl", " pci"], "buf": ["doc", "proc", "br", "batch", "cp", "alloc", "data", "xff", "ff", "eth", "func", "tmp", "code", "text", "p", "img", " buffer", "result", "np", "pb", "ah", "txt", "iter", "window", "ref", " cmd", "cb", "rb", "path", "var", "rw", "b", "tx", "msg", "tab", "cur", "bar", "priv", "def", "filename", "vec", " buff", "map", "cap", "desc", "block", "font", "buffer", "err", "cv", "w", "ptr", "cam", "cf", "ctx", "str", "pkg", "nm", "Buffer", "db", "fd", "queue", "fb", "bytes", " buffers", "rc", "raw", "Buff", "mem", "uf", "cmd", "buff"], "bus_num": [" bus2num", " bus_no", "bus2num", "BUS_mon", "BUS_name", "BUS_number", " bus_number", " bus2number", "bus_Num", "BUS_num", " bus_Num", "bus_number", " bus2Num", "bus_name", "bus2Num", "bus2number", "bus_mon", "bus_no", "bus2no"], "addr": ["mt", "id", "alloc", "eth", "add", "phys", "host", "nl", "Address", "dd", "attr", "ref", "dir", "order", "hw", "align", "url", "act", "var", "tx", "store", "pos", "ord", "ack", "pad", "att", "ip", "ptr", "name", "ctx", "alias", "adr", "pkg", "now", "alt", "rev", "rt", "loc", "offset", "ag", "dr", "ar", "mac", "address", "arp", "rel", "src", "ad", "ac", "iat", "mem", "a", "len", "cmd"], "product_name": ["product_Name", " product2path", "device_Name", "device_names", "component_type", "productnamedata", "productNameName", " product2name", "product_names", "product_path", "product2Name", "product_NAME", "productNamename", " product2data", " product_path", "device_NAME", "component_number", "product_type", "product2data", "product2path", "product_number", " product_Name", "productnameName", "component_name", "device_name", "productnamepath", "product2name", "product_data", "productnamename", " product2Name", "productNamedata", " product_data", "productNamepath"], "x": ["batch", "j", "fx", "key", "xc", "mix", "xxxx", " ax", "lex", "dx", "n", "xi", "any", "index", "xs", "inx", "xa", "ax", " c", "ox", "i", " n", "mx", "tx", "nex", " X", " tx", " w", "ey", " i", "ex", "xy", "qu", "axis", "ux", "xt", "y", "xxx", "xx", "xp", " dx", "ctx", "px", "rx", " xx", " v", " y", "yx", "ix", "\u00e7", " cx", "xd", "wx", "ct", "ick", "xxxxxxxx", " k", "xes", "t", "X"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN square root */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 2594, "substitutes": {"env": ["ec", "stack", "er", "code", "ep", "nc", "conn", "org", "eh", "ev", "window", "vs", "hw", "server", "ah", "app", "her", "viron", "set", "exc", "environment", "engine", "esc", "em", "store", "eg", "pe", "sc", "entry", "dev", "end", "conf", "vm", "desc", "context", "e", "en", "ctx", "En", "EN", "ew", "v", "ov", "esp", "queue", "h", "erd", "te", "ee", "enter", "sb", "gov", "Ev", "enc", "obj", "serv", "eng"], "arg": ["doc", "op", "arr", "tg", "p", "conn", "g", "ref", "pb", "og", "fac", "Arg", "out", "ax", "b", "gt", "it", "bar", "ig", " Arg", "tag", "param", "w", "ann", "grad", "fe", "ag", "ar", "reg", "argument", "v", "target", " targ", "in", "arp", "field", " larg", "args", "f", "flag", "obj", "uf", "cmd"], "farg": [" ferr", "parp", "uarg", "Fparam", "vflag", "fargument", "rfasc", "varg", "marg", "fagg", "fenarp", "fparam", "barg", "narp", " fparam", "Farg", "fenarc", "bArg", "floatargument", " fcall", "barp", "fdargs", "narg", "fargs", "masc", "floaterr", "fbargument", "marp", "varp", "fenarg", "rfarp", "marc", " fArg", "fdarp", "fberr", "margs", "nflag", "farp", " fargument", " farp", "uagg", "uflag", "margument", "fcall", "pargument", "pArg", "parg", "ferr", "floatcall", "farc", "bargument", "Fargs", "vagg", "uarp", "fdparam", "floatarg", "fasc", "nagg", "fbarg", "rfarc", "fdargument", "rfarg", "fenasc", "fdarg", "fflag", " fargs", "fbcall", "fArg"], "f32": ["fc34", " f40", "f48", "f40", "fc32", "float40", " f34", "fc64", "float32", "float34", "fac40", "y64", "float48", "fac34", "flet", "fac64", "f31", "y34", " flet", "faclet", "fc31", "fac32", "fac48", " f48", "floatlet", " f31", "y31", "float64", "f64", "f34", "y32", " f64"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "int gen_new_label(void)\n\n{\n\n    TCGContext *s = &tcg_ctx;\n\n    int idx;\n\n    TCGLabel *l;\n\n\n\n    if (s->nb_labels >= TCG_MAX_LABELS)\n\n        tcg_abort();\n\n    idx = s->nb_labels++;\n\n    l = &s->labels[idx];\n\n    l->has_value = 0;\n\n    l->u.first_reloc = NULL;\n\n    return idx;\n\n}\n", "idx": 2602, "substitutes": {"s": ["sys", "S", "q", "south", "c", "sv", "ss", "p", "es", "conv", "g", "n", "sl", "ess", "comm", "ds", "qs", "space", "x", "fs", "less", "tx", "sc", "ps", "js", "ns", "bs", "sw", "conf", "ims", "ms", "cs", "ts", "ctx", "spec", "sm", "hs", "sts", "rs", "gs", "sb", "sq", "os", "t", "se"], "idx": ["Idxc", "uidxs", "Idy", "kidy", "kidxs", "iddx", "uidxes", " fidxs", "idix", " idxs", "idy", "Idix", "idex", "inddx", "indix", "kidix", "idxs", " idy", "uidx", "idexs", " iddx", "idxc", "kidx", "Idx", "indxs", " idxc", " fidix", "indx", "idxes", "idexc", "Idxs", "indxes", "idey", " fidx", " idix", "uiddx", " idxes"], "l": ["ls", "j", "lp", "le", "lr", "L", "il", "yl", "ol", "c", "nl", "p", "g", "sl", "la", "label", "kl", "li", "lam", "i", "b", "u", "lit", "lb", "ll", "dL", "lv", "al", "dl", "tl", "el", "pl", "ln", "rl", "ell", "v", "lin", "o", "ml", "lu", "lc", "lang", "t", "ld"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t sector_num, int nb_sectors,\n\n                            int64_t *cluster_sector_num,\n\n                            int *cluster_nb_sectors)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_sector_num = sector_num;\n\n        *cluster_nb_sectors = nb_sectors;\n\n    } else {\n\n        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;\n\n        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);\n\n        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +\n\n                                            nb_sectors, c);\n\n    }\n\n}\n", "idx": 2604, "substitutes": {"bs": ["sys", "ls", "bc", "bh", "ss", "bm", "vs", "bp", "s", "ds", "b", "ubs", "fs", "lbs", "BS", "iss", "its", "bb", "js", "ns", "aos", "bos", "bi", "bis", "ms", "irms", "cs", "ts", "ks", "bps", "rs", "bits", "gs", "sb", "bn", "aus", "ys", "base", "ubis"], "sector_num": ["sectorationnum", "sector2num", "section_num", "sector2number", "sectorPunit", "sector2mon", "sector___num", "sectoritydec", "sectorationmsg", "sectoritymon", "sectoripmat", "sectorationdec", "section_number", "sector_mon", "ector_num", "sector_number", "sector_pos", "section_dec", "ector_pos", "sectorippos", "sectoripnumber", "sector_dec", "sectorationnumber", "section_msg", "sector___number", "sectoripnum", "sector___unit", "sector2dec", "sector___temp", "sector_unit", "ector_unit", "ector_temp", "ector_mat", "sectorPtemp", " sector_mon", "sectorPnumber", " sector_dec", "sectoritynum", " sector_number", "sector_msg", "sector_temp", "sectoritynumber", "sector_mat", "ector_number", "sectorPnum"], "nb_sectors": ["nb_sections", "nb_necs", "nb_vevers", "nb_pegments", "nb_pevers", "nb_pectors", "nb_spectors", "nb_segments", "nb_nectors", "nb_spegments", "nb_severs", "nb_pellers", "nb_spellers", "nb_nevers", "nb_vecs", "nb_psections", "nb_pecs", "nb_psectors", "nb_nellers", "nb_vellers", "nb_psecs", "nb_secs", "nb_psevers", "nb_pections", "nb_specs", "nb_sellers", "nb_vections", "nb_vectors", "nb_vegments"], "cluster_sector_num": ["cluster_sector___name", "cluster_sector_net", "cluster_sector_info", "cluster_ser_loc", "cluster_sector___number", "cluster_ector_n", "cluster_sector_n", "cluster_section_n", "cluster_section_no", "cluster_ser_mon", "cluster_ser_number", "cluster_sector___num", "cluster_ector_name", "cluster_sector___mon", "cluster_sector_mon", "cluster_ector_no", "cluster_ector_num", "cluster_ser_n", "cluster_sector___loc", "cluster_sector_name", "cluster_ser_name", "cluster_sector_loc", "cluster_sector___n", "cluster_sector_number", "cluster_ser_num", "cluster_ser_net", "cluster_sector___net", "cluster_sector___info", "cluster_section_info", "cluster_sector_no", "cluster_sector___no", "cluster_section_num"], "cluster_nb_sectors": ["cluster_nb_veors", "cluster_nb_vevers", "cluster_nb_segments", "cluster_nb2pectors", "cluster_nb_nevers", "cluster_nb_pectors", "cluster_nb_severs", "cluster_nb2secs", "cluster_nb_pevers", "cluster_nb_vectors", "cluster_nb_necs", "cluster_nb2peors", "cluster_nb_secs", "cluster_nb2severs", "cluster_nb_neors", "cluster_nb2sectors", "cluster_nb_seors", "cluster_nb_peors", "cluster_nb_vecs", "cluster_nb_negments", "cluster_nb2pevers", "cluster_nb_pecs", "cluster_nb_vegments", "cluster_nb2pecs", "cluster_nb2seors", "cluster_nb_nectors", "cluster_nb_pegments"], "bdi": ["bsi", "bgadi", "bDI", " bsi", "fdi", "bidi", "fci", "ibdi", "vsi", "didi", "badi", "bci", "binfo", "ladi", " binfo", "absi", "ldu", "vdi", " bDi", "ibci", "bDi", "ibDi", "obdi", "fDI", "finfo", " bDI", "bgdu", "bgdi", "obci", "abdi", "bydu", "byadi", "vidi", "ibidi", "obDI", "vDi", "bydi", "abDi", "dci", "ldi", "abidi", "ddi", " bci", "obinfo", " bidi", "lidi", "dDi", "bdu", "byidi", "bgidi"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 2620, "substitutes": {"cpu": ["proc", "core", "cp", "alloc", "ork", "phys", "jp", "pc", "conn", "hog", "pu", "xi", "hw", "np", "gpu", "CPU", "util", "processor", "linux", "hap", "aq", "boot", "tp", "mu", "cum", "setup", "aco", "ctx", "gc", "pkg", "apache", "bench", "mac", "clock", "cu", "uu", "process", "nu", "ck", "cmd", "pri"], "start1": ["read01", "Start01", " start2", "partone", "offsetOne", "read1", "start2", "readOne", "startone", "startOne", " start01", "stop2", "offset1", "stop0", " startOne", " startone", "stop1", " start0", "Start1", "Start2", "start01", "stop01", "start0", "part01", "part1", "Start0", "partOne", "readone"], "length": ["total", "number", "l", "size", "count", "height", "ENGTH", "limit", "term", "sequence", "collection", "full", "idth", "duration", "phi", "shape", "type", "amount", "history", "pad", "product", "Length", "stop", "ength", "buffer", "available", "len", "library", "offset", "depth", "ngth", "angle", "frequency", "h", "padding", "enth", "position", "capacity"], "env": ["proc", "ec", "stack", "doc", "rule", "buf", "code", "gear", "ent", "conn", "org", "eh", "ev", "window", "vs", "np", "node", "ah", "order", "ner", "vt", "viron", "her", "txt", "environment", "engine", "qa", "menu", "nv", "pen", "pe", "cache", "req", "dev", "ef", "config", "eu", "scope", "end", "wall", "entity", "desc", "disk", "context", "e", "den", "buffer", "en", "here", "equ", "ob", "emb", "global", "EN", "db", "ew", "v", "door", "oe", "uv", "te", "ee", "state", "mem", "obj", "eng", "Environment", "ens"], "mmu_idx": ["mmu_partxes", "mmu_randi", "mmu_idy", "mmu_partw", "mmu_uidi", "mmu_idw", "mmu_identxc", "mmu_Idxes", "mmu_idsix", "mmu_sidexes", "mmu_partx", "mmu_needx", "mmu_iddx", "mmu_indxs", "mmu_sidex", "mmu_needix", "mmu_partxc", "mmu7idi", "mmu_sidew", "mmu_idsy", "mmu_needxes", "mmu7den", "mmu_ideix", "mmu_idn", "mmu_idix", "mmu7dei", "mmu_uiddx", "mmu_Idxs", "mmu_randx", "mmu_idsx", "mmu_index", "mmu_randdx", "mmu_idexs", "mmu_dedx", "mmu_identxes", "mmu_dei", "mmu_needxs", "mmu_idex", "mmu_idi", "mmu_idsxs", "mmu_ridix", "mmu7iddx", "mmu_idsex", "mmu_idez", "mmu7idx", "mmu7idn", "mmu_Idy", "mmu_identx", "mmu_indy", "mmu_idz", "mmu_Idx", "mmu_idxes", "mmu_idxs", "mmu7dedx", "mmu7dex", "mmu_sidexc", "mmu_ridx", "mmu_ridxs", "mmu_randn", "mmu_uidx", "mmu_identw", "mmu_den", "mmu_uidn", "mmu_Idex", "mmu_indx", "mmu_ridz", "mmu_dex", "mmu_Idix", "mmu_idxc", "mmu_Idz"], "i": ["multi", "php", "j", "parent", "q", "ni", "ii", "ki", "iq", "MI", "is", "p", "sim", "to", "g", "init", "xi", "ic", "pi", "qi", "me", "ci", " di", "li", "ami", "m", "ei", "b", "x", "cli", "ui", "info", "phi", "it", "gi", "series", "ex", "ip", " ii", "oi", "y", "gu", "fi", "ims", "bi", "im", "iu", "ti", "spec", "ity", "ind", "uri", "ix", "dr", "v", "print", "remote", "zi", "in", "client", "mi", "di", "ini", "\u0438", "ai", "si", "I", "dim", "f", "ri", "chain"]}}
{"project": "qemu", "commit_id": "e0ef439588ce1ede747f82b77d893190c1cc9f4d", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 2622, "substitutes": {"s": ["sys", "ls", "j", "S", "c", "sv", "ss", "p", "es", "sl", "sa", "ds", "i", "b", "space", "fs", "less", "aws", "ps", "js", "bs", "ns", "sam", "ts", "cs", "hs", "sts", "rs", "v", "ares", "gs", "sb", "ats", "sn", "sq", "t", "ssl", "sp"], "rule": ["proc", "ace", "require", "key", "test", "section", "match", "style", "record", "row", "route", "r", "trigger", "order", "node", "ase", "decl", "link", "filter", "condition", "parse", "policy", "pe", "entry", "def", "request", "reason", "run", "config", "tag", "call", "file", "block", "error", "comment", "command", "callback", "role", "rec", "spec", "se", "rr", "sche", "co", "rl", "fr", "ror", "function", "ULE", "statement", "option", "offset", "range", "group", "when", "ule", "handler", "event", "line", "rules", "state", "re", "Rule", "module", "feature", "chain"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 2624, "substitutes": {"dev": ["proc", "sys", "d", "device", "buf", "usb", "adv", "conn", "dd", "p", "ev", "hw", "window", "dem", "devices", "Dev", "md", "def", "priv", "pad", "conf", "sd", "disk", "w", "cam", "wd", "Device", "ver", "ctx", "spec", "de", "go", "DEV", "db", "v", "nt", "ad", "ve", "scan", "des", "mem", "obj", "serv", "pro"], "s": ["sis", "j", "S", "d", "ls", "stats", "l", "c", "is", "sv", "ss", "p", "es", "ast", "n", "session", "sl", "r", "ses", "ess", "comm", "ds", "qs", "m", "i", "b", "params", "fs", "less", "aws", "services", "ps", "js", "ns", "sd", "ims", "w", "e", "ms", "sam", "ts", "spec", "hs", "sts", "rs", "v", "h", "gs", "f", "sb", "args", "sq", "os", "t", "a", "self", "sp"]}}
{"project": "qemu", "commit_id": "f02ca5cbeaf86038834c1953247a1579d7921927", "target": 0, "func": "static inline void tcg_out_ld_ptr(TCGContext *s, int ret,\n\n                                  tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with offset %ld\\n\", __func__, arg);\n\n    if (arg != (arg & 0xfff))\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));\n\n    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |\n\n              INSN_IMM13(arg & 0x3ff));\n\n#else\n\n    tcg_out_ld_raw(s, ret, arg);\n\n#endif\n\n}\n", "idx": 2628, "substitutes": {"s": ["sys", "S", "c", "is", "ss", "p", "es", "z", "g", "n", "r", "ses", "set", "ds", "qs", "i", "b", "x", "fs", "us", "sc", "ps", "ex", "js", "ns", "sw", "y", "w", "ms", "ts", "cs", "sm", "hs", "sts", "rs", "v", "h", "gs", "sb", "os", "sq", "t", "sync", "se", "self", "sp"], "ret": ["mt", "j", "d", "RET", "q", "cat", "sys", "aux", "l", "usr", "status", "nl", " RET", "g", " def", "result", "ref", "r", "out", "res", "lit", "ft", "red", "gt", "def", "att", "Ret", " Ret", "al", "err", "ptr", "ts", "rt", "re", "alt", "reg", "rev", "ry", "val", "dr", "rets", "nt", "ct", "rc", "flag", "reset", "resp", "tr", "st", "t", "mem", "len", "std", "ld"], "arg": ["usr", "op", "p", "Arg", "out", "var", "pg", "x", "gt", "opt", "emb", "f", "args", "agg", "par", "mem", "deg", "bug", "act", "num", "ok", "at", "ack", "tag", "alt", "ar", "loc", "mm", "arp", " larg", "al", "j", "l", " op", "jp", "addr", " ag", "ref", "ax", "parse", " flag", " args", " argument", " Arg", "call", "lag", "ag", "mac", "v", "val", "target", " targ", "flag", "inter", "cmd", "doc", "prop", "arr", "sec", "g", "attr", "r", "asc", "ig", "param", "local", "pl", "reg", "argument", "in", " reg", "good", "field", "ad", "t", "alg"]}}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "int xen_config_dev_blk(DriveInfo *disk)\n\n{\n\n    char fe[256], be[256];\n\n    int vdev = 202 * 256 + 16 * disk->unit;\n\n    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;\n\n    const char *devtype = cdrom ? \"cdrom\" : \"disk\";\n\n    const char *mode    = cdrom ? \"r\"     : \"w\";\n\n\n\n    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),\n\n\t     \"xvd%c\", 'a' + disk->unit);\n\n    xen_be_printf(NULL, 1, \"config disk %d [%s]: %s\\n\",\n\n                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);\n\n    xen_config_dev_dirs(\"vbd\", \"qdisk\", vdev, fe, be, sizeof(fe));\n\n\n\n    /* frontend */\n\n    xenstore_write_int(fe, \"virtual-device\",  vdev);\n\n    xenstore_write_str(fe, \"device-type\",     devtype);\n\n\n\n    /* backend */\n\n    xenstore_write_str(be, \"dev\",             disk->bdrv->device_name);\n\n    xenstore_write_str(be, \"type\",            \"file\");\n\n    xenstore_write_str(be, \"params\",          disk->bdrv->filename);\n\n    xenstore_write_str(be, \"mode\",            mode);\n\n\n\n    /* common stuff */\n\n    return xen_config_dev_all(fe, be);\n\n}\n", "idx": 2632, "substitutes": {"disk": ["core", "p", "node", "raid", "load", "cloud", "volume", "fork", "req", "wd", "df", "github", "spec", "vol", "pick", "sky", "license", "pd", "wk", "drive", "vd", "d", "bank", "service", "upload", "dir", "ds", "link", "policy", "check", "yard", "storage", "ank", "cell", "file", "band", "mm", "display", "hard", "sync", "device", "directory", "dd", "pdf", "pi", "definition", "power", "part", "grid", "info", "network", "dev", "diff", "dl", "Disk", "pread", "draw", "dis", "sys", "image", "transfer", "work", "isk", "docker", "pack", "def", "delete", "boot", "config", "local", "cdn", "in", "disc", "draft", "download"], "fe": ["ele", "ace", "fc", "le", "ane", "Fe", "eb", " me", "ze", "che", "eeee", "vre", "fine", "fle", "me", "ue", "ife", "ume", "ft", "ige", "ce", "ne", "pe", "eg", "au", "xe", "we", "ge", "bee", "eu", "fi", "ie", "e", "fer", "ffe", "ae", "ene", "fr", "fm", "se", "ale", "ped", "ces", "de", "que", "fb", " Fe", " pe", "wen", "fre", "fee", "oe", "ly", "te", "f", "ee", "ve", "bf", "FE"], "be": ["Be", "ide", "br", "ate", "le", "try", "ane", "ut", "eb", "are", "ze", "ube", "he", "use", "ote", "bc", "che", "ke", "abe", "me", "ue", "ere", "com", "b", "ce", "ne", "pe", "it", "we", "ber", "ge", "ome", "ade", "bb", "ser", "bi", "e", "BE", "en", "ae", "sche", "ob", "co", "de", "one", "bo", "bes", "db", "mes", "ize", "ode", "eng", "bl", "oe", "ly", "by", "ape", "te", "stab", "ee", "ve", "ot", "bf", "st", "ck", "une", "ute", "re", "se", "ble"], "devtype": ["avype", "avtype", "evype", "evname", "developkind", "evtyp", "evkind", "devkind", "devtyp", " devkind", "developtyp", "devype", " devType", "devType", " devname", "developtype", "developname", "evType", " devype", "evtype", "devname", " devtyp", "avname", "avType"], "mode": ["data", "sex", "key", "test", "device", "status", "size", "format", "mask", "MODE", "attr", "me", "power", "path", "m", "force", "md", "pe", "rol", "mod", "type", "filename", "time", "dev", "perm", "Mode", "metadata", "command", "role", "name", "de", "option", "mm", "driver", "te", "direction", "mem", "module", "cmd", "pro"]}}
{"project": "qemu", "commit_id": "cd42d5b23691ad73edfd6dbcfc935a960a9c5a65", "target": 0, "func": "static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,\n\n                                                  TranslationBlock *tb,\n\n                                                  int search_pc)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    struct DisasContext ctx, *dc = &ctx;\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, k;\n\n    uint32_t next_page_start;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    pc_start = tb->pc;\n\n    dc->tb = tb;\n\n\n\n    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->ppc = pc_start;\n\n    dc->pc = pc_start;\n\n    dc->flags = cpu->env.cpucfgr;\n\n    dc->mem_idx = cpu_mmu_index(&cpu->env);\n\n    dc->synced_flags = dc->tb_flags = tb->flags;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->singlestep_enabled = cs->singlestep_enabled;\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"-----------------------------------------\\n\");\n\n        log_cpu_state(CPU(cpu), 0);\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    k = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n\n\n    if (max_insns == 0) {\n\n        max_insns = CF_COUNT_MASK;\n\n    }\n\n\n\n    gen_tb_start();\n\n\n\n    do {\n\n        check_breakpoint(cpu, dc);\n\n        if (search_pc) {\n\n            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n            if (k < j) {\n\n                k++;\n\n                while (k < j) {\n\n                    tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n                }\n\n            }\n\n            tcg_ctx.gen_opc_pc[k] = dc->pc;\n\n            tcg_ctx.gen_opc_instr_start[k] = 1;\n\n            tcg_ctx.gen_opc_icount[k] = num_insns;\n\n        }\n\n\n\n        if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n            tcg_gen_debug_insn_start(dc->pc);\n\n        }\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) {\n\n            gen_io_start();\n\n        }\n\n        dc->ppc = dc->pc - 4;\n\n        dc->npc = dc->pc + 4;\n\n        tcg_gen_movi_tl(cpu_ppc, dc->ppc);\n\n        tcg_gen_movi_tl(cpu_npc, dc->npc);\n\n        disas_openrisc_insn(dc, cpu);\n\n        dc->pc = dc->npc;\n\n        num_insns++;\n\n        /* delay slot */\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                dc->tb_flags &= ~D_FLAG;\n\n                gen_sync_flags(dc);\n\n                tcg_gen_mov_tl(cpu_pc, jmp_pc);\n\n                tcg_gen_mov_tl(cpu_npc, jmp_pc);\n\n                tcg_gen_movi_tl(jmp_pc, 0);\n\n                tcg_gen_exit_tb(0);\n\n                dc->is_jmp = DISAS_JUMP;\n\n                break;\n\n            }\n\n        }\n\n    } while (!dc->is_jmp\n\n             && tcg_ctx.gen_opc_ptr < gen_opc_end\n\n             && !cs->singlestep_enabled\n\n             && !singlestep\n\n             && (dc->pc < next_page_start)\n\n             && num_insns < max_insns);\n\n\n\n    if (tb->cflags & CF_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    }\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        gen_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n            break;\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        k++;\n\n        while (k <= j) {\n\n            tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n", "idx": 2634, "substitutes": {"cpu": ["proc", "core", "sys", "cp", "alloc", "net", "device", "jp", "phys", "pc", "c", "nc", " CPU", "chip", "conn", "rom", "pu", "hw", "np", "gpu", "CPU", "onet", "util", "processor", "phy", "cli", "linux", "cmp", "boot", "tp", "mu", "gnu", "ctl", "vm", "cum", "ilo", "cam", "aco", "nic", "pool", "gc", "pkg", "mac", "rpm", "clock", "cu", "cc", "ola", "process", "nu", "cpp", "cmd", "uci", "ck", "library", "kernel"], "tb": ["timba", "ptb", " tbt", "ttbl", "pbl", "tbl", "ptp", "portbi", "treeb", "tpb", "tobl", "pb", "portbf", "portp", "ptba", " tbl", "tbt", "treepb", "ptbf", "ptbl", "Tob", "itbe", "ttb", "toba", "tbi", "Tbl", "ttba", "tp", "tob", "treebt", "timpb", " tfb", "itxb", "timbf", "tbf", "tba", "timbi", "itbl", "Tb", " txb", "itpb", "outb", "Tba", "tobi", "txb", "treefb", "itb", "outbe", " tpb", "ptbi", "ttob", " tba", "outpb", "timfb", "tfb", "timbt", "timp", "pxb", "tbe", "timbl", "timb", "outbl", "portb", " tbe", "ppb", " tbi", "ptob"], "search_pc": ["search__PC", "search_mc", "searchablebc", "search___pb", "find_mc", "find_PC", "search___pc", "search_cc", "find_pb", "search_PC", "searchablepc", "search__pc", " search_cc", "search_pb", "search_bc", "searchablecc", "search__pb", "searchablepb", " search_bc", " search_pb", "find_pc", "search__mc", "search___cc", "search___bc"], "cs": ["sys", "ls", "ec", "cp", "wcs", "cas", "vc", "fc", "pc", "c", "cks", "nc", "css", "cus", "caps", "ci", "mc", "ds", "fs", "sk", "sc", "cmp", "cons", "ps", "js", "ns", "ts", "ks", "sts", "rs", "cu", "cc", "CS", "ck", "lc", "tc", "acs"], "ctx": ["doc", "sys", "d", "parent", "cp", "fc", "c", "pc", "nc", "tk", "unc", "cn", "css", "ca", "txt", "np", "xs", "tx", "cmp", "ns", "kw", "cf", "context", "dl", "cv", "gc", "pkg", " ca", "abc", " cx", "cc", "cu", "ct", " td", "cmd", "gs", " cc", "cm", "lc", "t", "tc", "jac", " context", "obj"], "dc": ["doc", "ec", "d", "design", "document", "cat", "fc", "cd", "cr", "wp", "acl", "dt", "pc", "c", "bc", "DC", "nc", "cn", "dd", "ga", "drm", "docker", "ca", "css", "dir", "cfg", "mc", "ds", "td", "dat", "sc", "def", "kw", "ctl", "desc", "comment", "dl", "cam", "df", "rec", "gc", "db", "dr", "mac", "currency", "mm", "cc", "nz", "central", "di", "dp", "disc", "draw", "dim", "rc", "cm", "lc", "ac", "da", "tc", "cca"], "gen_opc_end": ["gen_opc_stop", "gen_opc_max", "gen_opc__end", "gen_opc_start", "gen_opf_end", "gen_opc__ends", "gen_opc__start", "gen_opf_ends", "gen_opf_start", "gen_opc_ends", "gen_opf_max", "gen_opf_stop", "gen_opc__max"], "pc_start": ["cp_offset", " pc_end", "pc00end", "cp_start", "cp2offset", "pc2index", "pc_stop", "pc2begin", "pc_save", "cp_end", "pc_offset", " pc00start", " pc_save", "cp2start", "pc2offset", " pc00save", " pc00end", "cp_index", "pc_end", "tc_end", "pc00start", "pc2stop", "pc2end", "cp2index", "tc_start", "pc_index", "PC_end", "pc_add", "pc_art", " pc_add", "pc_begin", "PC_start", "pc2start", "PC_begin", "pc00save", "tc_art", "PC_stop", "cp2end"], "j": ["jump", "d", "q", "l", "jp", "ji", "dj", "jit", "shift", "z", "p", "aj", "uj", "g", "n", "ju", "kj", "i", "x", "pos", "start", "adj", "it", "J", "ij", "jl", "job", "js", "y", "ch", "im", "ek", "ja", "v", "sp", "h", "o", "max", "si", "gov", "t", "kid", "jj", "ak", "json"], "k": ["ko", "ka", "q", "key", "kan", "ki", "c", "tk", "km", "p", "ke", "kh", "g", "n", "isk", "dk", "uk", "kj", "kl", "kk", "kind", "tek", "m", "i", "ijk", "kt", "sk", "ku", "unk", "ark", "ask", "ack", "kr", "kw", "mk", "ikk", "ks", "kn", "kick", "ek", "K", "wk", "ik", "ck", "t", "kid", "jj", "ak"], "next_page_start": ["next_pageibsize", "next_Page_point", "next_pages_top", "next_page_size", "next_pageixend", "next_page_end", "next_page_point", "next_pageixpoint", "next_pageibstart", "next_page_top", "next_Page_end", "next_pageixsize", "next_pages_end", "next_pageibend", "next_pages_size", "next_Page_start", "next_pageixstart", "next_pageibtop", "next_pages_start", "next_Page_size"], "num_insns": ["num_psns", "num_minsvs", "num_outsns", "num_pinsn", "num_innz", "num_pinsns", "num_inns", "num_insvs", "num_insamples", "num_minsns", "num_pinsans", "num_psans", "num_inn", "num_inans", "num_inamples", "num_outsvs", "num_invs", "num_pinsamples", "num_insnz", "num_minsnz", "num_psamples", "num_minsn", "num_insans", "num_psn", "num_outsn", "num_outsnz", "num_insn"], "max_insns": ["max_insni", "max_isinys", "max_linsn", "max_insps", "max_inons", "max_linscs", "max_conps", "max_ainsni", "max_ainscs", "max_ainsn", "max_ainsons", "max_insons", "max_incn", "max_isinns", "max_isinn", "max_ainsims", "max_incns", "max_inps", "max_insn", "max_conn", "max_conys", "max_inn", "max_initns", "max_initn", "max_initni", "max_inccs", "max_inni", "max_isinps", "max_inys", "max_linsns", "max_inns", "max_ainsns", "max_conns", "max_incims", "max_inscs", "max_insys", "max_linsons", "max_initcs", "max_incs", "max_insims", "max_inims"], "delayed_branch": ["delayed_blranch", "delayed_brranch", "delayed_dranch", "delayed_branches", "delayed_broanch", "delayed_blanches", "delayed_broranch", "delayed_drranch", "delayed_broanches", "delayed_drag", "delayed_blag", "delayed_broag", "delayed_blanch", "delayed_dranches", "delayed_brag"]}}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    IVShmemState *s = IVSHMEM(dev);\n\n    Error *err = NULL;\n\n    uint8_t *pci_conf;\n\n    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n        PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\n\n    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {\n\n        error_setg(errp,\n\n                   \"You must specify either 'shm', 'chardev' or 'x-memdev'\");\n\n        return;\n\n    }\n\n\n\n    if (s->hostmem) {\n\n        MemoryRegion *mr;\n\n\n\n        if (s->sizearg) {\n\n            g_warning(\"size argument ignored with hostmem\");\n\n        }\n\n\n\n        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);\n\n        s->ivshmem_size = memory_region_size(mr);\n\n    } else if (s->sizearg == NULL) {\n\n        s->ivshmem_size = 4 << 20; /* 4 MB default */\n\n    } else {\n\n        char *end;\n\n        int64_t size = qemu_strtosz(s->sizearg, &end);\n\n        if (size < 0 || *end != '\\0' || !is_power_of_2(size)) {\n\n            error_setg(errp, \"Invalid size %s\", s->sizearg);\n\n            return;\n\n        }\n\n        s->ivshmem_size = size;\n\n    }\n\n\n\n    /* IRQFD requires MSI */\n\n    if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) &&\n\n        !ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        error_setg(errp, \"ioeventfd/irqfd requires MSI\");\n\n        return;\n\n    }\n\n\n\n    /* check that role is reasonable */\n\n    if (s->role) {\n\n        if (strncmp(s->role, \"peer\", 5) == 0) {\n\n            s->role_val = IVSHMEM_PEER;\n\n        } else if (strncmp(s->role, \"master\", 7) == 0) {\n\n            s->role_val = IVSHMEM_MASTER;\n\n        } else {\n\n            error_setg(errp, \"'role' must be 'peer' or 'master'\");\n\n            return;\n\n        }\n\n    } else {\n\n        s->role_val = IVSHMEM_MASTER; /* default */\n\n    }\n\n\n\n    pci_conf = dev->config;\n\n    pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\n\n\n\n    /*\n\n     * Note: we don't use INTx with IVSHMEM_MSI at all, so this is a\n\n     * bald-faced lie then.  But it's a backwards compatible lie.\n\n     */\n\n    pci_config_set_interrupt_pin(pci_conf, 1);\n\n\n\n    memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s,\n\n                          \"ivshmem-mmio\", IVSHMEM_REG_BAR_SIZE);\n\n\n\n    /* region for registers*/\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &s->ivshmem_mmio);\n\n\n\n    memory_region_init(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmem_size);\n\n    if (s->ivshmem_64bit) {\n\n        attr |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n    }\n\n\n\n    if (s->hostmem != NULL) {\n\n        MemoryRegion *mr;\n\n\n\n        IVSHMEM_DPRINTF(\"using hostmem\\n\");\n\n\n\n        mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem),\n\n                                            &error_abort);\n\n        vmstate_register_ram(mr, DEVICE(s));\n\n        memory_region_add_subregion(&s->bar, 0, mr);\n\n        pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar);\n\n    } else if (s->server_chr != NULL) {\n\n        /* FIXME do not rely on what chr drivers put into filename */\n\n        if (strncmp(s->server_chr->filename, \"unix:\", 5)) {\n\n            error_setg(errp, \"chardev is not a unix client socket\");\n\n            return;\n\n        }\n\n\n\n        /* if we get a UNIX socket as the parameter we will talk\n\n         * to the ivshmem server to receive the memory region */\n\n\n\n        IVSHMEM_DPRINTF(\"using shared memory server (socket = %s)\\n\",\n\n                        s->server_chr->filename);\n\n\n\n        if (ivshmem_setup_interrupts(s) < 0) {\n\n            error_setg(errp, \"failed to initialize interrupts\");\n\n            return;\n\n        }\n\n\n\n        /* we allocate enough space for 16 peers and grow as needed */\n\n        resize_peers(s, 16);\n\n        s->vm_id = -1;\n\n\n\n        pci_register_bar(dev, 2, attr, &s->bar);\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n\n                              ivshmem_check_version, NULL, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                error_report(\"could not truncate shared file\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            error_setg(errp, \"could not open shared file\");\n\n            return;\n\n        }\n\n\n\n        if (check_shm_size(s, fd, errp) == -1) {\n\n            return;\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd, attr, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        error_setg(&s->migration_blocker,\n\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n\n        migrate_add_blocker(s->migration_blocker);\n\n    }\n\n}\n", "idx": 2649, "substitutes": {"dev": ["test", "env", "device", "er", "usb", "adv", "vr", "conn", "p", "ev", "hw", "server", "dem", "devices", "phy", "serial", "priv", "def", "vp", "mem", "pad", "iv", "conf", "sd", "cam", "ptr", "w", "Device", "ver", "spec", "de", "DEV", "v", "ad", "ve", "des", "Dev", "scan", "serv", "cmd", "pro"], "errp": ["dangernp", "eorpat", "eorping", "derpb", "errorper", "derp", "derping", "errpre", "ererP", "arrpb", " errpre", "nernp", "nersp", " errper", "errorp", "arrp", "ererping", " errpa", "privP", "privp", " errP", "dangersp", "errorping", "errpa", "dangerpat", "errorpre", "ererpb", "dangerping", "privwp", "nerp", "errper", "ererpa", "eorpoint", "errnp", "eorp", "eorper", "errsp", "dersp", "derpa", "errping", "errwp", "derper", "errpat", "eorpre", "arrpa", "dernp", " errwp", "errpoint", "ererp", "ererwp", "errpb", "errP", "dangerp", "arrping", "nerper", "dangerper", "privpa", "errorpoint", "errorpat", "dangerpoint"], "s": ["ls", "c", "aunts", "p", "es", "n", "ses", "set", "params", "gets", "services", "its", "t", "ports", "cs", "spec", "h", "gs", "his", "args", "sb", "os", "d", "mods", "stats", "sv", "source", "settings", "vs", "details", "xs", "ds", "qs", "m", "less", "ex", "bs", "ims", "sam", "hs", "sts", "eps", "ins", "self", "S", "l", "ss", "als", "sl", "comm", "sym", "ns", "sw", "y", "ms", "ts", "changes", "v", "tests", "results", "rates", "ops", "cmd", "sys", "status", "is", "r", "b", "fs", "aws", "ps", "js", "sd", "w", "sports", "has", "rs", "bits", "ats", "des", "store"], "err": ["sys", "ec", "br", "usr", "cr", "er", "arr", "buf", "ev", "attr", "r", "iter", "cfg", "exc", "cb", "msg", "cur", "kr", "conf", "error", "der", "Er", "rr", "Error", "fee", "gz", "resp", "obj"], "pci_conf": ["pci2info", "ppi_Conf", "ppi_conf", "pci__Conf", "pci_info", "pci__cfg", "pci2Conf", "pci___", "pdi__", "pci__conf", "pci_Conf", "pci__info", "ppi_cfg", "pci_cfg", "pci2cfg", "ppi_info", "pci__", "pci2conf"], "mr": ["mt", "br", "usr", "MR", "gr", "cr", "lr", "mir", "rg", "vr", "mor", "bm", "hr", "r", "mid", "m", "rw", "tm", "wm", "pr", "sr", "kr", "rh", "shr", "rr", "adr", "rl", "mn", "dr", "rs", "rm", "ml", "ocr", "cm", "Mr", "gm", "tr", "mc", "rar", "rn"], "end": ["END", "id", "add", "env", "size", "buf", "use", "format", "nd", "c", "ext", "port", "z", "term", "ent", "p", "window", "set", "send", "ending", "close", "export", "start", "ended", "stop", "length", "w", "e", "pend", "en", "append", "End", "except", "dest", "edge", "post", "offset", "v", "last", "h", "est", "event", "max", "st", "begin", "enc", "eng", "len"]}}
{"project": "qemu", "commit_id": "ab2b9f174db088633922eaa82c2bcffd84e6bb94", "target": 1, "func": "int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)\n\n{\n\n    fprintf_function fprintf_fn = info->fprintf_func;\n\n    void *stream = info->stream;\n\n    int rc;\n\n    uint8_t insn[4];\n\n    const Lm32OpcodeInfo *opc_info;\n\n    uint32_t op;\n\n    const char *args_fmt;\n\n\n\n    rc = info->read_memory_func(memaddr, insn, 4, info);\n\n    if (rc != 0) {\n\n        info->memory_error_func(rc, memaddr, info);\n\n        return -1;\n\n    }\n\n\n\n    fprintf_fn(stream, \"%02x %02x %02x %02x    \",\n\n            insn[0], insn[1], insn[2], insn[3]);\n\n\n\n    op = bfd_getb32(insn);\n\n    opc_info = find_opcode_info(op);\n\n    if (opc_info) {\n\n        fprintf_fn(stream, \"%-8s \", opc_info->name);\n\n        args_fmt = opc_info->args_fmt;\n\n        while (args_fmt && *args_fmt) {\n\n            if (*args_fmt == '%') {\n\n                switch (*(++args_fmt)) {\n\n                case '0': {\n\n                    uint8_t r0;\n\n                    const char *r0_name;\n\n                    r0 = (op >> 21) & 0x1f;\n\n                    r0_name = find_reg_info(r0)->name;\n\n                    fprintf_fn(stream, \"%s\", r0_name);\n\n                    break;\n\n                }\n\n                case '1': {\n\n                    uint8_t r1;\n\n                    const char *r1_name;\n\n                    r1 = (op >> 16) & 0x1f;\n\n                    r1_name = find_reg_info(r1)->name;\n\n                    fprintf_fn(stream, \"%s\", r1_name);\n\n                    break;\n\n                }\n\n                case '2': {\n\n                    uint8_t r2;\n\n                    const char *r2_name;\n\n                    r2 = (op >> 11) & 0x1f;\n\n                    r2_name = find_reg_info(r2)->name;\n\n                    fprintf_fn(stream, \"%s\", r2_name);\n\n                    break;\n\n                }\n\n                case 'c': {\n\n                    uint8_t csr;\n\n                    const char *csr_name;\n\n                    csr = (op >> 21) & 0x1f;\n\n                    csr_name = find_csr_info(csr)->name;\n\n                    if (csr_name) {\n\n                        fprintf_fn(stream, \"%s\", csr_name);\n\n                    } else {\n\n                        fprintf_fn(stream, \"0x%x\", csr);\n\n                    }\n\n                    break;\n\n                }\n\n                case 'u': {\n\n                    uint16_t u16;\n\n                    u16 = op & 0xffff;\n\n                    fprintf_fn(stream, \"0x%x\", u16);\n\n                    break;\n\n                }\n\n                case 's': {\n\n                    int16_t s16;\n\n                    s16 = (int16_t)(op & 0xffff);\n\n                    fprintf_fn(stream, \"%d\", s16);\n\n                    break;\n\n                }\n\n                case 'r': {\n\n                    uint32_t rela;\n\n                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'R': {\n\n                    uint32_t rela;\n\n                    int32_t imm26;\n\n                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;\n\n                    rela = memaddr + imm26;\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'h': {\n\n                    uint8_t u5;\n\n                    u5 = (op & 0x1f);\n\n                    fprintf_fn(stream, \"%d\", u5);\n\n                    break;\n\n                }\n\n                default:\n\n                    break;\n\n                }\n\n            } else {\n\n                fprintf_fn(stream, \"%c\", *args_fmt);\n\n            }\n\n            args_fmt++;\n\n        }\n\n    } else {\n\n        fprintf_fn(stream, \".word 0x%x\", op);\n\n    }\n\n\n\n    return 4;\n\n}\n", "idx": 2656, "substitutes": {"memaddr": ["memoryaddr", "Memptr", " memorynr", "memoryptr", " memptr", " memoryaddr", "memadr", "Memaddr", "Memadr", "memaddress", " memaddress", "memoryaddress", " memadr", "mtadr", " memnr", " memoryaddress", "mtaddr", "memptr", "mtaddress", "mtptr", "Memaddress", "Memnr", "memnr"], "info": ["doc", "success", "core", "image", "id", "data", "transfer", "try", "list", "information", "summary", "status", "ro", "follow", "code", " Info", "size", "Info", "source", "warning", "init", "inf", "description", "ref", "import", "index", "details", "order", "options", "kind", "isu", "link", "i", "start", "check", "entry", "def", "ok", "type", "history", " error", "time", "fi", "conf", "local", "http", "error", "comment", "map", "save", "file", "name", "INFO", " inf", "io", " INFO", "always", "good", "help", "event", "f", "about", "state", "report", "fo"], "stream": ["stack", "Stream", "message", "user", "host", "view", "source", "pipe", "conv", "iterator", "seek", "row", "window", "import", "ream", "s", "progress", "iter", "path", "send", "filter", "REAM", "load", "form", "store", "sc", "ok", "speed", "ack", "history", "our", "time", "transform", "sw", "http", "flash", "block", "accept", "trans", "hook", "buffer", "context", "metadata", "response", "pool", "ous", "str", "round", "each", "v", "console", "target", "loop", "draw", "src", "line", "runtime", "os", "track", "enc", "warn", "sync", "steam", "clean", "chain"], "rc": ["ec", "rd", "ctr", "xff", "cd", "ro", "pc", "nr", "bc", " enc", " ans", " cur", "row", "rac", " ov", " co", "uc", "r", "dc", " rot", " ip", "usc", " ro", "rb", "cb", " succ", " proc", " ac", "rate", " cont", "cur", " init", "priv", "ack", "cmp", "rin", "roc", " exc", "irc", " sr", "desc", "auc", "arc", "err", " sc", "rec", "rr", "rx", "rl", "co", "gc", "rt", "RC", "ror", "loc", "con", " rec", "ry", "rs", "cc", " src", "src", " err", "ck", "ac", " cr", " hr", "rar", " alloc", "rob", "rn"], "insn": ["apsn", "insd", "vsp", "minsn", "Insn", "istssn", " insnm", "minsnote", "presnat", "insns", " insnote", "linssn", " insp", "linsnat", "pressn", "vsnw", "pointsnan", "itsns", "insna", "apsnote", "umsd", "pluginsnor", "linsp", "pluginsnan", "pointsnor", "pluginsn", "vsn", "istsnote", "insnm", "umsnat", " insna", "insnan", "itsna", "psd", "itsn", "Insns", "presnan", "itsp", "presn", "pluginsnat", "Insna", "istsn", "umsn", "pssn", "vsnm", "insnote", " inssn", "insnor", "linsnw", " insns", "psnat", "linsd", "pointssn", "istsnat", "linsnm", "linsn", "insnw", "psn", "pluginssn", " insnat", "minsnat", "ainsnat", " insnor", "insnat", "umssn", " insnw", "ainssn", "presnote", "ainsn", "insp", "pointsn", "apsnat", "minsnan", "apsnan", "inssn", " insnan", "Insp", "ainsnote"], "opc_info": ["opc_iter", "oppc___inf", "opcache_info", "oppc_info", "opc2info", "opc_history", "opc_Info", "opc___history", "opc2name", "oppc___info", "opcache_INFO", "opcode_check", "opc_details", "opcode_fo", "opc__history", "opc_name", "opc__inf", "opcode_iter", "opc_fo", "opc_INFO", "oppc_inf", "opcache_fo", "opcode_info", "opcode_INFO", "opc2fo", "opc___details", "oppc_history", "opcode_details", "opc__info", "opcode_Info", "opcache_name", "opc_check", "opc2INFO", "opc___INFO", "oppc___history", "opc___info", "opc___inf", "opc_inf", "opc___Info"], "op": ["cp", " operation", " pop", " OP", "p", "init", "iter", "out", "var", "deep", "pr", "opt", "hop", "ap", "comp", "pre", " Op", "push", "Op", "operator", " sp", " cp", " ops", "inc", " oper", "msg", " rep", "opp", "it", "ok", "at", "ack", "cmp", "tp", "im", " typ", " p", "OP", "expr", "arg", "j", "cat", "jp", "ope", "code", "operation", "mp", "oop", "update", "block", "ob", "opl", "prev", "top", "ops", "cmd", "sp", "stack", " _", "item", "pc", "up", "r", " ip", "pp", "bit", "ip", "oc", " x", "post", "o", "obj", "oper", "omp", "typ"], "args_fmt": ["args2ftype", "args_fmld", "args_fmlt", "args_Fmm", "args_vlt", "args2fld", "args2fmt", "args_fermm", "args_mmn", "args_vMT", "args_fmmt", "args_dMT", "args_jformat", "args_explt", "args_fformat", "args_factx", "args_ferstyle", "args_rfm", "args_cmn", "args_fld", "args2ftm", "args_cformat", "args2Fmt", "args_lfm", "args_Fld", "args_Fmt", "args_dmt", "args_lformat", "args_lmid", "args_dformat", "args_jfm", "args2Flt", "args_mfm", "args_Ftx", "args_dtype", "args_fstr", "args_xstyle", "args_clt", "args_xmm", "args_facmt", "args_faclt", "args2fformat", "args_fstyle", "args_vmn", "args_fmid", "args2Fld", "args_flfm", "args2mlt", "args2vtype", "args_rmid", "args_flmt", "args_ftm", "args_mlt", "args2Ftx", "args_vtype", "args_flt", "args_xstr", "args2mntax", "args_jmt", "args_mntax", "args_ftx", "args_fltm", "args_vmt", "args_vformat", "args_exptm", "args_expmt", "args_rmt", "args_ffm", "args_ctype", "args2mtm", "args2ftx", "args_Fstyle", "args_Flt", "args_vntax", "args_expntax", "args_cmt", "args2vformat", "args_Ftm", "args_cMT", "args2vmt", "args_fmn", "args_Ffm", "args_vtm", "args_mmt", "args_fermt", "args_mtm", "args_ftype", "args2vMT", "args_jmid", "args_ferstr", "args_fmm", "args_lmt", "args2mmt", "args_facld", "args_mformat", "args2fntax", "args2flt", "args_Fstr", "args_fntax", "args2fMT", "args_xmt", "args_rformat", "args_fMT", "args_fmtx", "args_fllt"], "r0": ["rb255", "rt255", "r00", "vr1", "R03", "vr03", "rb00", " r3", "rc0", "R3", "rc00", "vrne", "R1", "rne", "r03", "pair3", "rt00", "rc255", "pairne", " rne", "rt0", "r3", "pair0", "R0", "rb0", "r255", "vr3", " r03", "vr0"], "r0_name": ["r0___Name", "r0_value", "r0tnames", "r15_name", "r02___Name", "r0__word", "r0___number", "r0tvalue", "r0__name", "r02_title", "r02_number", "r0Tname", "r0_tag", "r0__tag", "r0_word", "r1tnames", "r1tvalue", "r0tname", "r0___name", "r0_Name", "r0__value", "r1_value", "r0Ttag", "r02_Name", "r02_name", "r0_names", "r15_title", "r1_names", "r0Tword", "r0__names", "r0__title", "r02___name", "r02___number", "r0Ttitle", "r02___title", "r1tname", "r0_title", "r15_word", "r15_tag", "r0___title", "r0_number"], "r1": ["m4", "r51", "rt001", " r4", "rt1", "rc01", "r01", "rc51", "rc4", "mOne", "m1", " r3", "errOne", "mr01", "err1", "err001", "rc1", " r01", " r51", " r001", "rtOne", "dr3", "dr4", "rOne", " rOne", "dr1", "drOne", "mr1", "r4", "m3", "mr51", "r3", "mr4", "r001"], "r1_name": ["r100_pair", "r01_title", "r1xclient", "r1xtype", "r1xname", "r1istclient", "r1xno", "r1_label", "r01_prefix", "r1xpair", "r1istname", "r1_client", "r1isttype", "r100_name", "r1_title", "r5xlabel", "r1istlabel", "r5_type", "r01_name", "r100_names", "r1acclient", "r5_label", "r5_client", "r1xnames", "r1_names", "r1aclabel", "r1xlabel", "r5xclient", "r5xname", "r1_type", "r1_prefix", "r1acname", "r5xtype", "r1_pair", "r5_name", "r1actype", "r1_no", "r100_no", "r01_label"], "r2": ["r62", "r2002", " r2002", "m02", "r6", "r52", "vr2", "rt52", "rc52", "vr6", "vrTwo", "rt15", " r3", "dr2002", "dr2", "drTwo", "r02", "r15", "rcTwo", " r62", "m2", "vr62", "dr3", " rTwo", "rt2", "vr2002", "m62", " r6", "vr02", "r3", "dr15", "dr52", "rc15", "m6", " r02", "rtTwo", "vr3", "rc2", "rTwo"], "r2_name": ["r2__names", "r2_pass", "r2_number", "r2msnames", "rTwo_file", "r2_group", "r3_number", "r2__file", "r2msfile", "r2idName", "r3_name", "rTwo_domain", "r3_pass", "r2oxpass", "r2_names", "r2oxName", "r2idpass", "rTwo_name", "r2oxnumber", "r2_file", "r2idnumber", "rTwo_names", "r2msname", "r2oxname", "r2__domain", "r2idname", "r2msdomain", "r2__name", "r2_title", "r3_Name", "r2_Name", "r2_domain"], "csr": ["acsc", "acsm", "csm", "psm", "psr", "csc", "cscr", "acscr", "acsr", "cssr", "psc", "csscr", "cssc", "cssm", "pscr"], "csr_name": ["cs_", "rs_", "csfunc", "rsf", "lsf", "rsfunc", "css_", "cssfunc", "lsfunc", "cssf", "ls_", "csf"]}}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n\n                   uint8_t *properties)\n\n{\n\n    int compno;\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    compno = bytestream_get_byte(&s->buf);\n\n\n\n    c      += compno;\n\n    c->csty = bytestream_get_byte(&s->buf);\n\n    get_cox(s, c);\n\n\n\n    properties[compno] |= HAD_COC;\n\n    return 0;\n\n}\n", "idx": 2665, "substitutes": {"s": ["sys", "ls", "d", "S", "q", "serv", "j", "er", "is", "source", "ss", "p", "es", "als", "n", "vs", "r", "xs", "ses", "ess", "sf", "ds", "qs", "comm", "m", "i", "b", "less", "aws", "ps", "its", "parts", "js", "ns", "bs", "conf", "ims", "ms", "sam", "cs", "ts", "ctx", "ains", "ies", "sts", "eps", "rs", "v", "in", "o", "h", "gs", "f", "sb", "ats", "ins", "sq", "os", "t", "a", "se", "this"], "c": ["ec", "d", "cp", "cr", "fc", "l", "count", "bc", "unc", "z", "p", "g", "n", "dc", "ca", "r", "ci", "cb", "m", "com", "i", "b", "u", "C", "cont", "sc", "cf", "cv", "tc", "e", "cs", "comp", "ctx", "con", "co", "gc", "v", "cu", "cc", "h", "ct", "o", "col", "f", "cm", "lc", "ac", "t", "mc", "a"], "properties": ["property", "values", "frames", " props", "prop", "images", "whatever", "settings", "objects", "resources", "codes", "names", "details", "options", "params", "policy", "fields", "services", "units", "ps", "parts", "features", "tags", "OPS", "metadata", "errors", "comments", "flags", "terms", "private", "headers", "perties", "events", "types", "blocks", "bytes", "styles", "states", "reports", "items", "pro"], "compno": ["componentpos", "compko", "compNO", "Comppos", " recompno", "omp0", "comeno", "comko", "comNo", " compNo", "ompno", " comp0", "CompNO", "compro", " recompNo", "cmpno", " compko", "CompNo", " recompeno", "Compeno", " compNO", "cmpeno", "ompNO", "ompNo", "compNo", " recompko", "componentno", "cmp0", " compro", "comp0", " comppos", "componentNo", "Compro", " compeno", "Compno", "cmpNO", "cmpNo", "comno", "compeno", "comppos", "componentNO", "cmpro"]}}
{"project": "qemu", "commit_id": "615220ddaf23db4c5686053257c568b46967e4b5", "target": 1, "func": "static void curses_setup(void)\n\n{\n\n    int i, colour_default[8] = {\n\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n\n    };\n\n\n\n    /* input as raw as possible, let everything be interpreted\n\n     * by the guest system */\n\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n\n    start_color(); raw(); scrollok(stdscr, FALSE);\n\n\n\n    for (i = 0; i < 64; i ++)\n\n        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);\n\n}\n", "idx": 2673, "substitutes": {"i": ["multi", "batch", "j", "chain", "q", "id", "ii", "ki", "jp", "ji", "status", " j", "z", "p", "sim", "conv", "g", "n", "init", "xi", "ic", "pi", "index", "me", "qi", "li", "ci", "ami", "m", "ei", "x", "u", "cli", "ui", "gi", "it", "ij", "ip", " ii", "oi", "y", "k", "bi", "im", " x", "iu", "ti", "name", "ind", "go", "ix", "dr", "v", "zi", "in", "sp", "mi", "di", "ini", "\u0438", "h", "ai", "si", "I", "ik", "t", " bi"], "colour_default": ["colour_force", "gradient_switch", " colour_force", "colour_def", "gradientntdefault", "colour_dict", "gradient_public", "gradientntswitch", " colour_Default", "colourntdiff", "colour___default", "gradientntpublic", "colour_switch", "colour_diff", "colourntpublic", "colourntdefault", "colour___dict", "colour___diff", "gradientntdiff", "colourntswitch", " colour_diff", " colour_dict", "colour_public", "colour_Default", " colour_def", "gradient_diff", "gradient_default"]}}
{"project": "FFmpeg", "commit_id": "28bf81c90d36a55cf76e2be913c5215ebebf61f2", "target": 1, "func": "static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)\n\n{\n\n#ifdef HAVE_MMX\n\n\t// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)\n\n    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))\n\n#else\n\n    if(sws_flags != SWS_FAST_BILINEAR)\n\n#endif\n\n    {\n\n    \tRENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    }\n\n    else // Fast Bilinear upscale / crap downscale\n\n    {\n\n#ifdef ARCH_X86\n\n#ifdef HAVE_MMX2\n\n\tint i;\n\n\tif(canMMX2BeUsed)\n\n\t{\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\" // 2*xalpha\n\n\t\t\t\"movd %5, %%mm6\t\t\t\\n\\t\" // xInc&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" //0,t,2t,3t\t\tt=xInc&0xFF\n\n\t\t\t\"movq %%mm2, \"MANGLE(temp0)\"\t\\n\\t\"\n\n\t\t\t\"movd %4, %%mm6\t\t\t\\n\\t\" //(xInc*4)&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\t\"movl %0, %%esi\t\t\t\\n\\t\" // src\n\n\t\t\t\"movl %1, %%edi\t\t\t\\n\\t\" // buf1\n\n\t\t\t\"movl %3, %%edx\t\t\t\\n\\t\" // (xInc*4)>>16\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\t\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\"\n\n\t\t\t\"movw %4, %%bx\t\t\t\\n\\t\" // (xInc*4)&0xFFFF\n\n\n\n#define FUNNY_Y_CODE \\\n\n\t\t\tPREFETCH\" 1024(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1056(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1088(%%esi)\t\t\\n\\t\"\\\n\n\t\t\t\"call \"MANGLE(funnyYCode)\"\t\\n\\t\"\\\n\n\t\t\t\"movq \"MANGLE(temp0)\", %%mm2\t\\n\\t\"\\\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\n\n\n\t\t\t:: \"m\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" ((xInc*4)>>16),\n\n\t\t\t\"m\" ((xInc*4)&0xFFFF), \"m\" (xInc&0xFFFF)\n\n\t\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\n\n\t\t);\n\n\t\tfor(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;\n\n\t}\n\n\telse\n\n\t{\n\n#endif\n\n\t//NO MMX just normal asm ...\n\n\tasm volatile(\n\n\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" // xx\n\n\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" // 2*xalpha\n\n\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movzbl  (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, (%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\n\n\t\t\"addl $2, %%eax\t\t\t\\n\\t\"\n\n\t\t\"cmpl %2, %%eax\t\t\t\\n\\t\"\n\n\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\n\n\t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF)\n\n\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\"\n\n\t\t);\n\n#ifdef HAVE_MMX2\n\n\t} //if MMX2 cant be used\n\n#endif\n\n#else\n\n\tint i;\n\n\tunsigned int xpos=0;\n\n\tfor(i=0;i<dstWidth;i++)\n\n\t{\n\n\t\tregister unsigned int xx=xpos>>16;\n\n\t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n\t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n\t\txpos+=xInc;\n\n\t}\n\n#endif\n\n    }\n\n}\n", "idx": 2677, "substitutes": {"dst": ["wst", "sST", "Dest", " dnt", "prc", "drc", "sst", " drc", "adst", "pst", "adnt", "dnt", "dct", "sest", "dST", "Dct", " dest", "dtd", "pct", "west", "DST", "dest", "Dst", "adtd", " dtd", "Drc", " dct", "wtd", " dST", "wnt", "adest", "pST"], "dstWidth": ["dxHeight", "destCut", "dsrcHeight", "dSTWidth", "pSTWidth", "dspWidth", "dSTLeft", "dSTPath", " dsrcCut", "drtWidth", "dtdCut", "dxPath", "dsrcWidth", "destPath", "dstW", "pstW", "dtdW", "DstWidth", "destHeight", "dstCut", "pstWidth", "dSTW", "dstSize", "dstHeight", "destWidth", "drtHeight", " dstHeight", "DestW", " dsrcHeight", "destW", "dSTHeight", "DstHeight", "pSTHeight", "dSTSize", "dxW", "drtLeft", "dspW", "dSTwidth", "DestWidth", " dstCut", "dxwidth", "destSize", "pSTW", "DstSize", "dxWidth", "destLeft", "pstHeight", "pSTwidth", "drtSize", "DstW", "dspHeight", "DestSize", "DestHeight", "dstLeft", "dtdHeight", "dspwidth", "pstwidth", "DestPath", "dstPath", "dstwidth", " dsrcWidth", "DestLeft", " dsrcW", "dsrcW", "DstLeft", "dsrcCut", " dstW", "dtdWidth", "DstPath"], "src": ["sys", "input", "inst", "usr", "ctr", "tmp", "source", "sv", "conv", "slice", "img", "sup", "sl", "txt", "s", "dist", "inc", "sc", "SOURCE", "cur", "sur", "sub", "ser", "sr", "hl", "ptr", "rl", "dest", "rt", "RC", "loc", "rs", "in", "rc", "sb", "st", "ins", "sq", "std", "sn"], "srcW": ["destS", "destP", "sourceH", "srcH", "sourceW", "srcS", "destWidth", "destR", "destW", "srcP", "sourceM", " srcWidth", "destH", " srcP", " srcS", "stW", "srcWidth", "stR", " srcR", "stS", "sourceWidth", "stP", " srcM", "srcR", "destM", " srcH", "srcM"], "xInc": [" xinc", "xInst", "exIncre", "xIncre", "exINC", "xIns", "xINC", "xEnc", "checkIncre", "rxIncre", "checkAdd", "checkInc", " xAdd", "xfInit", "xfIns", "rxINC", "XAdd", "exEnc", "xfInc", "xIss", "XINC", "exInst", " xInst", " xEnc", "txEnc", "xinc", "rxDiff", "xxIncre", "xxIns", " xDiff", "xAdd", " xIns", " xIss", "exinc", " xInit", "txInc", "Xinc", "txInst", "XEnc", "checkIss", " xINC", "exIns", "XInc", "XIss", "xxInit", "xxInc", "txIncre", "xDiff", "xxINC", "rxInc", "XIncre", "xfIncre", "xxDiff", "exInc", "xInit", "XIns", " xIncre"], "i": ["ni", "j", "q", "l", "ii", "ki", "c", " j", "z", "p", "g", "n", "xi", "pi", "index", "qi", "li", "ci", "m", "b", "x", "cli", "ui", "phi", "it", "gi", "fi", "ip", "oi", "y", "bi", "e", "ti", "ix", "v", "zi", "mi", "di", "ini", "ai", "I", "si", "t"], "FUNNY_Y_CODE": ["FUNNY_Y_Gode", "FUNNY_YEARGODE", "FUNNY_Y_FSE", "FUNNY_YONCONE", "FUNNY_Y_VCode", "FUNNY_YJECTVCIDE", "FUNNY_Y__NRIPT", "FUNNY_Y_CCODE", "FUNNY_Y_COUR", "FUNNY_Y_ECIDE", "FUNNY_Y_ECOD", "FUNNY_YOPSCODE", "FUNNY_Y_GODE", "FUNNY_Y_GNAME", "FUNNY_YOPSCTE", "FUNNY_Y_CMOD", "FUNNY_Y_NOD", "FUNNY_YEARCCOC", "FUNNY_Y_ECSE", "FUNNY_Y_CIDE", "FUNNY_Y_ACOPE", "FUNNY_YEARCCOD", "FUNNY_YOPCODE", "FUNNY_YONCCODE", "FUNNY_Y_ACTE", "FUNNY_Y__NOPE", "FUNNY_Y_LODE", "FUNNY_YONCCONE", "FUNNY_Y_NRIPT", "FUNNY_YOPCTE", "FUNNY_Y_GOUR", "FUNNY_Y_CISION", "FUNNY_YEARCNAME", "FUNNY_Y_CIME", "FUNNY_Y_CSE", "FUNNY_Y_ACOC", "FUNNY_Y_FODE", "FUNNY_Y_VCODE", "FUNNY_YJECTVCOUR", "FUNNY_Y_SCODE", "FUNNY_Y_ACENE", "FUNNY_YOPCOD", "FUNNY_YEARGNAME", "FUNNY_Y_CMETHOD", "FUNNY_Y_ICNAME", "FUNNY_Y_ICode", "FUNNY_Y_ICISION", "FUNNY_Y_CCOC", "FUNNY_Y_CETHOD", "FUNNY_Y_ACETHOD", "FUNNY_Y_NODE", "FUNNY_YEARCISION", "FUNNY_Y_ACOD", "FUNNY_Y_ACode", "FUNNY_YONCCIME", "FUNNY_Y_LONE", "FUNNY_Y_CNAME", "FUNNY_Y_NIME", "FUNNY_Y_NENE", "FUNNY_Y_LIME", "FUNNY_Y_DECENE", "FUNNY_Y_FIDE", "FUNNY_YONCOD", "FUNNY_Y_ECode", "FUNNY_YJECTVCODE", "FUNNY_Y_DECOPE", "FUNNY_YLECODE", "FUNNY_YJECTCIDE", "FUNNY_YJECTCOUR", "FUNNY_YJECTCODE", "FUNNY_Y_CCIME", "FUNNY_Y_SCTE", "FUNNY_Y_ACRIPT", "FUNNY_Y_GISION", "FUNNY_Y_CENT", "FUNNY_YEARCETHOD", "FUNNY_Y_COD", "FUNNY_YLECode", "FUNNY_Y_GOD", "FUNNY_Y_DECRIPT", "FUNNY_YOPCENT", "FUNNY_YLECOD", "FUNNY_Y_VCOD", "FUNNY_Y__CRIPT", "FUNNY_YEARCODE", "FUNNY_Y_CTE", "FUNNY_Y_CCOUR", "FUNNY_Y_CCONE", "FUNNY_Y_CMOC", "FUNNY_YOPSCENT", "FUNNY_Y_SCENT", "FUNNY_Y_ECOUR", "FUNNY_Y_ICODE", "FUNNY_YEARCCODE", "FUNNY_Y_ACISION", "FUNNY_Y_SCOD", "FUNNY_Y_VCIDE", "FUNNY_YEARCCETHOD", "FUNNY_YEARGode", "FUNNY_Y_COC", "FUNNY_Y_ACENT", "FUNNY_YOPSCOD", "FUNNY_Y_FOUR", "FUNNY_Y_COPE", "FUNNY_Y_DECODE", "FUNNY_Y_CCETHOD", "FUNNY_Y_NONE", "FUNNY_Y_ACODE", "FUNNY_YONCIME", "FUNNY_YEARCode", "FUNNY_Y_VCOUR", "FUNNY_YEARCOD", "FUNNY_Y__CODE", "FUNNY_Y_ECODE", "FUNNY_Y_ECENT", "FUNNY_Y__COPE", "FUNNY_Y_CMODE", "FUNNY_Y_CCOD", "FUNNY_Y__CENE", "FUNNY_Y_CONE", "FUNNY_Y_Code", "FUNNY_Y_VCSE", "FUNNY_Y__NODE", "FUNNY_YONCCOD", "FUNNY_YONCODE", "FUNNY_Y_ECTE", "FUNNY_Y__NENE", "FUNNY_Y_CENE", "FUNNY_YEARGISION", "FUNNY_Y_NOPE", "FUNNY_Y_VCONE", "FUNNY_Y_LOD", "FUNNY_YJECTVCSE", "FUNNY_YJECTCSE", "FUNNY_Y_ECONE", "FUNNY_YEARCOC", "FUNNY_Y_ACNAME", "FUNNY_Y_CRIPT"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 2680, "substitutes": {"f": ["fp", "d", "q", "fw", "fc", "l", "c", "ile", "p", "g", "r", "fac", "m", "i", "b", "lf", "af", "fs", "form", "tf", "fi", "conf", "file", "cf", "w", "e", "fr", "F", "fb", "h", "o", "t", "fm", "uf", "fo", "fd"], "pv": ["piv", "vpiv", "ppvc", "vpv", "paq", "vpvc", " piv", "pV", "ppv", " p2", "pave", "pq", " pve", "jpve", " pV", "pav", " pq", "pvc", "jpq", "pve", "jp2", "p2", "pa2", "ppV", "vpV", "jpv", "ppiv", " pvc"], "size": [" length", "p", " sizes", "n", " s", "ci", " sh", "m", "space", " Size", " scale", "pe", "shape", "type", "length", "SIZE", "w", "e", "ize", " len", "fee", "h", "st", "mem", "len", "Size", "sp"], "v": ["vc", "j", "d", "q", "l", "c", "V", "sv", "p", "conv", "g", "n", "ev", "vs", "r", "s", "vt", "m", "var", "i", "b", "nv", "u", "va", "tv", "lv", "cv", "w", "ver", "ov", "vol", "o", "uv", "av", "t", "a"], "v2": ["p1", "V2", "ev4", " v4", "vlet", "vsp", "vv1", "v4", "psp", "ev1", "qv5", "v5", "qv4", "V4", "p0", "plet", "ev5", "vvsp", "qv1", "p4", "Vlet", " vsp", "v0", "ev2", "V0", "vv2", "v1", " v1", "p2", " v0", " v5", "qv2", " vlet"]}}
{"project": "FFmpeg", "commit_id": "c5f15f40b9b25f033fd9e8dd1e12763913098c11", "target": 1, "func": "static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    uint8_t nal;\n\n    uint8_t type;\n\n    int result = 0;\n\n\n\n    if (!len) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Empty H264 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    nal  = buf[0];\n\n    type = nal & 0x1f;\n\n\n\n    assert(data);\n\n    assert(buf);\n\n\n\n    /* Simplify the case (these are all the nal types used internally by\n\n     * the h264 codec). */\n\n    if (type >= 1 && type <= 23)\n\n        type = 1;\n\n    switch (type) {\n\n    case 0:                    // undefined, but pass them through\n\n    case 1:\n\n        av_new_packet(pkt, len + sizeof(start_sequence));\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n        COUNT_NAL_TYPE(data, nal);\n\n        break;\n\n\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n\n        // consume the STAP-A NAL\n\n        buf++;\n\n        len--;\n\n        // first we are going to figure out the total size\n\n        {\n\n            int pass         = 0;\n\n            int total_length = 0;\n\n            uint8_t *dst     = NULL;\n\n\n\n            for (pass = 0; pass < 2; pass++) {\n\n                const uint8_t *src = buf;\n\n                int src_len        = len;\n\n\n\n                while (src_len > 2) {\n\n                    uint16_t nal_size = AV_RB16(src);\n\n\n\n                    // consume the length of the aggregate\n\n                    src     += 2;\n\n                    src_len -= 2;\n\n\n\n                    if (nal_size <= src_len) {\n\n                        if (pass == 0) {\n\n                            // counting\n\n                            total_length += sizeof(start_sequence) + nal_size;\n\n                        } else {\n\n                            // copying\n\n                            assert(dst);\n\n                            memcpy(dst, start_sequence, sizeof(start_sequence));\n\n                            dst += sizeof(start_sequence);\n\n                            memcpy(dst, src, nal_size);\n\n                            COUNT_NAL_TYPE(data, *src);\n\n                            dst += nal_size;\n\n                        }\n\n                    } else {\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n\n                    }\n\n\n\n                    // eat what we handled\n\n                    src     += nal_size;\n\n                    src_len -= nal_size;\n\n\n\n                    if (src_len < 0)\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"Consumed more bytes than we got! (%d)\\n\", src_len);\n\n                }\n\n\n\n                if (pass == 0) {\n\n                    /* now we know the total size of the packet (with the\n\n                     * start sequences added) */\n\n                    av_new_packet(pkt, total_length);\n\n                    dst = pkt->data;\n\n                } else {\n\n                    assert(dst - pkt->data == total_length);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 25:                   // STAP-B\n\n    case 26:                   // MTAP-16\n\n    case 27:                   // MTAP-24\n\n    case 29:                   // FU-B\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Unhandled type (%d) (See RFC for implementation details\\n\",\n\n               type);\n\n        result = AVERROR(ENOSYS);\n\n        break;\n\n\n\n    case 28:                   // FU-A (fragmented nal)\n\n        buf++;\n\n        len--;                 // skip the fu_indicator\n\n        if (len > 1) {\n\n            // these are the same as above, we just redo them here for clarity\n\n            uint8_t fu_indicator      = nal;\n\n            uint8_t fu_header         = *buf;\n\n            uint8_t start_bit         = fu_header >> 7;\n\n            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;\n\n            uint8_t nal_type          = fu_header & 0x1f;\n\n            uint8_t reconstructed_nal;\n\n\n\n            // Reconstruct this packet's true nal; only the data follows.\n\n            /* The original nal forbidden bit and NRI are stored in this\n\n             * packet's nal. */\n\n            reconstructed_nal  = fu_indicator & 0xe0;\n\n            reconstructed_nal |= nal_type;\n\n\n\n            // skip the fu_header\n\n            buf++;\n\n            len--;\n\n\n\n            if (start_bit)\n\n                COUNT_NAL_TYPE(data, nal_type);\n\n            if (start_bit) {\n\n                /* copy in the start sequence, and the reconstructed nal */\n\n                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);\n\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n                pkt->data[sizeof(start_sequence)] = reconstructed_nal;\n\n                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);\n\n            } else {\n\n                av_new_packet(pkt, len);\n\n                memcpy(pkt->data, buf, len);\n\n            }\n\n        } else {\n\n            av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H264 RTP packet\\n\");\n\n            result = AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n\n\n    case 30:                   // undefined\n\n    case 31:                   // undefined\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n\n        result = AVERROR_INVALIDDATA;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return result;\n\n}\n", "idx": 2704, "substitutes": {"ctx": ["cp", "wcs", "cas", "tmp", "jp", "xc", "cn", "conn", "conv", "lex", "dc", "hw", "cfg", "cb", "act", "care", "tx", "kt", "msg", "sc", "cmp", "tz", "config", "conf", "kw", "ctl", "cf", "cv", "context", "setup", "tc", "wd", "course", "grad", "pkg", "gc", " cx", "cc", "cu", "wx", "ct", "cmd", "cm", "ck", "lc", "obj", "jac", " context", "ctrl"], "data": ["d", "Data", "image", "message", "id", "list", "size", "value", "DATA", "no", "next", "source", "p", "text", "to", "n", "window", "read", "txt", "result", "r", "out", "sequence", "table", "dat", "header", "tx", "info", "new", "valid", "this", "cache", "start", "mu", "base", "length", "content", "trans", "block", "error", "version", "buffer", "rec", "stream", "name", "str", "dest", "enc", "bin", "offset", "body", "ata", "nt", "bytes", "padding", "ret", "na", "raw", "t", "obj", "a", "auth", "cmd"], "st": ["mt", "ste", "tmp", "ut", "rest", "sth", "nd", "tt", "ast", "dat", "ST", "start", "cur", "stop", "sw", "ist", "sam", "str", "pt", "sts", "nt", "ct", "est", "stage", "serv", "std", "St", "sp"], "pkt": [" ppt", "cpet", "compkt", "Packet", "opkt", "ppt", "sptx", " ptx", " pct", "nkt", " pet", "opet", " pck", "compet", "compct", "spkt", " pwk", "cpct", "compacket", "cpwk", "Pkt", "opwk", "cpck", "packet", " pkg", "pct", "pkg", "nqt", "spacket", "ntx", "Pet", "spqt", " packet", "nacket", "pqt", "pwk", "pck", "pet", "cpkg", " pqt", "opkg", "comppt", "compck", "cpacket", "cpkt", "ptx", "Ppt"], "timestamp": ["imestamp", "timtime", "timetime", "metime", "timid", "mtime", "imtime", "mid", "imetime", "timeetime", "mestamp", "imid", "timeid", "timeestamp"], "buf": ["proc", "batch", "br", "ff", "tmp", "arr", "addr", "bc", "next", "limit", "p", "ref", "result", "pb", "txt", "bp", "iter", "lim", "out", "Len", "set", "cb", "rb", "dat", "read", "b", "pack", "pos", "msg", "cur", "bar", "pad", "vec", "fl", "uf", "length", "end", "block", "cap", "buffer", "cv", "err", "ptr", "en", "str", "pkg", "Buffer", "bin", "wb", "db", "loc", "queue", "v", "bytes", "loop", "bl", "rc", "raw", "Buff", "mem", "obj", "cmd", "buff"], "len": ["ls", "lp", "l", "size", "il", "L", "nl", "limit", "p", "z", "all", "n", "sl", "ref", "kl", "lim", "iter", "Len", "lf", "ail", "fin", "pos", "lan", "ll", "cmp", "fl", "lon", "length", "end", "trans", " l", "hl", "dl", "el", "en", "pl", "ln", "str", "alt", "loc", "offset", "val", "bytes", "nt", "h", "ret", " clen", "lang", "elt", "mem", "ld", "sp"], "seq": ["sys", "ctr", "id", "acl", "list", "count", "flow", "next", "ref", "iter", "ess", "sequence", "cb", "vals", "res", "pos", "msg", "req", "gen", "vec", "cap", "desc", "stream", "ver", "alt", "loop"], "flags": ["ff", "status", "acts", "mask", "times", "s", "options", "Flags", "vals", "params", "fs", "fields", "speed", "heads", "ps", "ns", "ts", "cs", " options", "aps", "types", "ags", "bits", "args", "flag", "os", "FLAG", "ops"], "nal": [" nonals", " nonAL", "nald", "annald", " nality", "anneal", "Nal", "nale", "nality", " nAL", "nsAL", "annale", "neal", "anality", "annal", "nnale", "renal", "nAL", "renality", "nsald", "nnal", "anals", "annAL", " nonalf", "nsal", "nnalf", " nalf", "Nald", "anal", "annalf", "nals", "NAL", "anale", " nals", "nalf", "analf", "nseal", "renAL", "renale", "nnAL", " nale", "anAL", "Neal", " nonal"], "type": ["day", "id", "Type", "ype", "ty", "test", " ty", "size", "status", "op", "format", "style", "p", "stat", "all", "result", "index", "broad", "mode", "out", "kind", "set", "pack", "family", "info", "pe", "none", " Type", "pretty", "tp", "time", "state", "tag", "like", "file", "block", "error", "al", "e", "role", "name", "ver", "TYPE", " typ", "spec", "con", "month", "ror", "class", "types", "range", " TYPE", "null", "what", "sp", "field", "rel", "flag", "t", "length", "ping", "typ"], "dst": [" ddest", "idend", "wst", "dost", "dsdest", "Ddest", "jost", "ddest", "Dest", " dnt", "lnt", "sst", "dsest", "mnd", "lest", "Dsp", "idst", "lst", "dsnd", "dent", "most", "dend", "mst", "dnt", "mest", "dct", "jst", "deest", "mdest", " dsrc", "dsst", "sest", "jnd", "Dct", " dnd", " dest", "Dost", " dsp", "lsp", "wost", "lend", "wct", "snd", "west", "dsrc", "dest", "Dst", "msp", "dsost", "sdest", "idest", "Dsrc", "msrc", "idsp", "dsct", "lnd", "dsp", "dnd", "jdest", " dend", "Dnd"], "pass": ["proc", "jump", "batch", "acc", "cas", "cat", "user", "try", "prop", "skip", "gain", "step", "handle", "p", "row", "session", "commit", "ass", "mode", "pp", "lo", "act", "task", "res", "pg", "password", "pack", "pos", "miss", "weight", "def", "ask", "access", "ack", "run", "PASS", "phase", "call", "conf", "pa", "level", "save", "wd", "alias", "con", "pas", "stage", "val", " bypass", "loop", "process", "pin", "Pass", "col", "arg", "rc", "par", "scan", "push", "card"], "src": ["proc", "sys", "input", "inst", "ctr", "usr", "inner", "tmp", "addr", "bc", "source", "slice", "img", "sup", "sl", "r", "s", "url", "lit", "start", "sc", "cont", "cur", "rol", "syn", "sur", "ser", "sub", "sr", "ptr", "stream", "rec", "str", "dest", "rl", "loc", "rs", "sel", "rc", "sb", "sn", "sq", "ins", "rel", "scan", "sync", "supp", "buff"]}}
{"project": "qemu", "commit_id": "4cdd01d32ee6fe04f8d909bfd3708be6864873a2", "target": 0, "func": "void bdrv_refresh_filename(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    QDict *opts;\n\n\n\n    if (!drv) {\n\n        return;\n\n    }\n\n\n\n    /* This BDS's file name will most probably depend on its file's name, so\n\n     * refresh that first */\n\n    if (bs->file) {\n\n        bdrv_refresh_filename(bs->file->bs);\n\n    }\n\n\n\n    if (drv->bdrv_refresh_filename) {\n\n        /* Obsolete information is of no use here, so drop the old file name\n\n         * information before refreshing it */\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        drv->bdrv_refresh_filename(bs);\n\n    } else if (bs->file) {\n\n        /* Try to reconstruct valid information from the underlying file */\n\n        bool has_open_options;\n\n\n\n        bs->exact_filename[0] = '\\0';\n\n        if (bs->full_open_options) {\n\n            QDECREF(bs->full_open_options);\n\n            bs->full_open_options = NULL;\n\n        }\n\n\n\n        opts = qdict_new();\n\n        has_open_options = append_open_options(opts, bs);\n\n\n\n        /* If no specific options have been given for this BDS, the filename of\n\n         * the underlying file should suffice for this one as well */\n\n        if (bs->file->bs->exact_filename[0] && !has_open_options) {\n\n            strcpy(bs->exact_filename, bs->file->bs->exact_filename);\n\n        }\n\n        /* Reconstructing the full options QDict is simple for most format block\n\n         * drivers, as long as the full options are known for the underlying\n\n         * file BDS. The full options QDict of that file BDS should somehow\n\n         * contain a representation of the filename, therefore the following\n\n         * suffices without querying the (exact_)filename of this BDS. */\n\n        if (bs->file->bs->full_open_options) {\n\n            qdict_put_obj(opts, \"driver\",\n\n                          QOBJECT(qstring_from_str(drv->format_name)));\n\n            QINCREF(bs->file->bs->full_open_options);\n\n            qdict_put_obj(opts, \"file\",\n\n                          QOBJECT(bs->file->bs->full_open_options));\n\n\n\n            bs->full_open_options = opts;\n\n        } else {\n\n            QDECREF(opts);\n\n        }\n\n    } else if (!bs->full_open_options && qdict_size(bs->options)) {\n\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n\n         * so the full options QDict should be equal to the options given\n\n         * specifically for this block device when it was opened (plus the\n\n         * driver specification).\n\n         * Because those options don't change, there is no need to update\n\n         * full_open_options when it's already set. */\n\n\n\n        opts = qdict_new();\n\n        append_open_options(opts, bs);\n\n        qdict_put_obj(opts, \"driver\",\n\n                      QOBJECT(qstring_from_str(drv->format_name)));\n\n\n\n        if (bs->exact_filename[0]) {\n\n            /* This may not work for all block protocol drivers (some may\n\n             * require this filename to be parsed), but we have to find some\n\n             * default solution here, so just include it. If some block driver\n\n             * does not support pure options without any filename at all or\n\n             * needs some special format of the options QDict, it needs to\n\n             * implement the driver-specific bdrv_refresh_filename() function.\n\n             */\n\n            qdict_put_obj(opts, \"filename\",\n\n                          QOBJECT(qstring_from_str(bs->exact_filename)));\n\n        }\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->exact_filename[0]) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n\n    } else if (bs->full_open_options) {\n\n        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n\n        snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n\n                 qstring_get_str(json));\n\n        QDECREF(json);\n\n    }\n\n}\n", "idx": 2737, "substitutes": {"bs": ["ls", "books", "uts", "caps", "bp", "ses", "us", "its", "ables", "ports", "cs", "bps", "hz", "bys", "vers", "bytes", "tops", "bing", "gs", "sb", "os", "lets", "ils", "stats", "outs", "bc", "bh", "actions", "css", "vs", "pb", "bles", "xs", "ds", "cb", "ox", "otes", "ims", "bis", "rots", "ks", "bes", "hs", "sts", "ins", "bn", "els", "aus", "ys", "banks", "als", "ics", "utils", "bed", "bos", "ns", "bi", "ms", "irms", "ts", "changes", "stones", "bas", "sys", "eb", "cks", "boxes", "nuts", "blogs", "vals", "b", "ubs", "fs", "lbs", "BS", "obs", "ps", "bb", "js", "aos", "ads", "terms", "as", "lines", "rs", "blocks", "bl", "bits", "blog", "ats"], "drv": ["hdvt", "derv", "drivd", "drm", "srvr", " drvy", "mrvd", "drij", "vrv", "hdvd", "sru", "mrvs", "drw", "hrm", "hostve", "derx", "srg", "drvr", "hostvr", "DRve", "drV", "Drj", "hrve", "drivr", "drj", "mrv", "vrm", "dervr", "mrvt", "vrve", " drvt", "srv", "drmm", "drve", "derm", " drvs", "deru", "darv", "hrvr", "driv", "drmve", "dru", "driu", "drmx", "derw", "drig", "darm", "drvd", "drvy", "driV", "DRvr", "hostm", "hdv", " drvd", "DRm", "Drvd", "drmv", "srw", "drvs", "hrvd", "derg", "srvy", "darvy", "derve", "darvr", "hdvs", " drvr", "Drvr", "hostv", "srV", "drg", "derV", "vrx", "drvt", "drim", "Drv", "DRv", "srm", "driw", " drm", "hrj", "hrv", "drx"], "opts": [" optx", "optfs", "operss", "OPps", "OPuts", " optts", "dropty", "okts", "proTS", "opty", " opvals", "optters", "opTS", "iopTS", " opcs", "prevals", "oppt", "ports", "coptes", "coptx", "copts", "optps", "opfs", "iopters", " opfs", "opttm", "operps", " opttu", "opters", "proters", "opTs", "opss", "opx", " opsts", " optu", "OPTs", "opps", "otps", "porths", "opte", "prots", "Opts", " opte", "Opths", "opttes", "optes", "OPpt", "prests", "optTS", "opns", "opttx", " oputs", "oktes", "copals", "opths", "prete", "opttu", " opns", " opty", "prets", "optTs", "props", "iopps", "opercs", "copns", "OPmits", " opTs", "optx", " opx", "iopts", "opcs", "coputs", "Opss", "porss", "OPTS", "OPss", "prety", "operts", "okals", "precs", "optns", "opermits", "opervals", "dropts", "dropsts", " opters", " opTS", "optals", " opals", "OPts", " optals", "optss", " opmits", " opps", "oputs", "opsts", "otpt", " oppt", "dropcs", "opals", "OPters", " opss", "opmits", "optths", "optuts", "opvals", "copfs", "optu", "Optm", "operte", "optts", "otuts", "okuts", "optm", "portm", "otts"], "has_open_options": ["has_close_ops", "has_open_errors", "has_open_ptions", "has_close_options", "has_valid_option", "has_open____options", "has_opentops", "has_open_names", "has_open____ops", "has_open____errors", "has_open_option", "has_close_errors", "has_open_tags", "has_valid_ops", "has_close_names", "has_open_ops", "has_open____names", "has_opentoptions", "has_valid_options", "has_openttags", "has_valid_ptions", "has_close_tags"]}}
{"project": "qemu", "commit_id": "9b990ee5a3cc6aa38f81266fb0c6ef37a36c45b9", "target": 0, "func": "static inline bool cpu_handle_exception(CPUState *cpu, int *ret)\n\n{\n\n    if (cpu->exception_index >= 0) {\n\n        if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n            /* exit request from the cpu execution loop */\n\n            *ret = cpu->exception_index;\n\n            if (*ret == EXCP_DEBUG) {\n\n                cpu_handle_debug_exception(cpu);\n\n            }\n\n            cpu->exception_index = -1;\n\n            return true;\n\n        } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n            /* if user mode only, we simulate a fake exception\n\n               which will be handled outside the cpu execution\n\n               loop */\n\n#if defined(TARGET_I386)\n\n            CPUClass *cc = CPU_GET_CLASS(cpu);\n\n            cc->do_interrupt(cpu);\n\n#endif\n\n            *ret = cpu->exception_index;\n\n            cpu->exception_index = -1;\n\n            return true;\n\n#else\n\n            if (replay_exception()) {\n\n                CPUClass *cc = CPU_GET_CLASS(cpu);\n\n                qemu_mutex_lock_iothread();\n\n                cc->do_interrupt(cpu);\n\n                qemu_mutex_unlock_iothread();\n\n                cpu->exception_index = -1;\n\n            } else if (!replay_has_interrupt()) {\n\n                /* give a chance to iothread in replay mode */\n\n                *ret = EXCP_INTERRUPT;\n\n                return true;\n\n            }\n\n#endif\n\n        }\n\n#ifndef CONFIG_USER_ONLY\n\n    } else if (replay_has_exception()\n\n               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {\n\n        /* try to cause an exception pending in the log */\n\n        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);\n\n        *ret = -1;\n\n        return true;\n\n#endif\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 2762, "substitutes": {"cpu": ["core", "ka", "cp", "c", "component", "port", "pu", "hw", "gpu", "cow", "ctl", "vm", "cum", "xp", "cs", "comp", "nic", "pkg", "que", "hz", "uu", "launch", "program", "ck", "os", "mem", "socket", "share", "net", "percent", "rom", "upt", "np", "pause", "phy", "linux", "cmp", "tp", "ilo", "aco", "gc", "bench", "remote", "what", "thread", "sync", "kernel", "php", "software", "total", "efficiency", "ork", "phys", "jp", "CPU", "processor", "utils", "gp", "pixel", "parse", "cache", "aq", "physical", "update", "ctx", "runner", "pool", "home", "mac", "clock", "process", "pid", "cmd", "proc", "sys", "alloc", "pc", "cn", "conn", "stat", "util", "cli", "profile", "performance", "prof", "boot", "ip", "copy", "px", "rpm", "cu", "library", "coin"], "ret": ["mt", "RET", "cat", "cert", "net", "et", "try", "test", "arr", "dt", "eth", "prop", "addr", "fun", "result", "ref", "deg", "out", "crit", "cb", "url", "res", "fin", "lit", "ft", "cont", "gt", "def", "mem", "att", "Ret", " Ret", "desc", "vet", "rt", "alt", "rev", "del", "reg", "val", "rm", "rets", "pret", "nt", "rs", "nz", "hash", "arg", "rel", "det", "tr", "rc", "flag", "resp", "reset", "elt", "t", "re", "rem", "len", "cmd"], "cc": ["ec", "acc", "vc", "ace", "cp", "fc", "func", "code", "pc", "CC", "xc", "bc", "nc", "cy", "cz", "kk", "cb", "lf", "inc", "cont", "cmp", "cci", "zz", "ucc", "ctl", "cell", "oc", "cf", "tc", "cv", "cs", "ctx", "gc", "co", "cle", "mac", "ct", "cl", "icc", "rc", "ck", "lc", "mc", "ctrl", "ld", "cca"]}}
{"project": "FFmpeg", "commit_id": "1169f0d0afc0454633cfcfad73643f0458521c67", "target": 0, "func": "void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)\n\n{\n\n#if HAVE_INLINE_ASM\n\n    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {\n\n        if (ctx->cid_table->bit_depth == 8)\n\n            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;\n\n    }\n\n#endif /* HAVE_INLINE_ASM */\n\n}\n", "idx": 2793, "substitutes": {"ctx": ["cp", "ctr", "ctrl", "tmp", "mom", "jp", "c", "pc", "xc", "nc", "bc", "tk", "cn", "unc", "conn", "conv", "dc", "ca", "hw", "np", "crit", "cb", "utils", "act", "tx", "kt", "sc", "cmp", "tp", "kw", "cf", "context", "cv", "tc", "setup", "mk", "pkg", "obj", "gc", "co", "loc", "cc", "ct", "Context", "ck", "resp", "ac", "mc", "cmd"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 2806, "substitutes": {"env": ["proc", "ec", "stack", "er", "code", "gear", " environment", "conn", "org", "ev", "window", "vs", "erb", "node", "server", "hw", "menu", "vt", "viron", "open", "exc", "environment", "engine", "ah", "her", "esc", "em", "msg", "entry", "cur", "req", "walker", "dev", "forge", "config", "shell", "end", "conf", "outer", "block", "desc", "wall", "vm", "context", "e", "den", "en", "equ", "here", "ctx", "manager", "ew", "v", "ov", "eco", "esp", "queue", "erd", "te", "event", "enter", "worker", "eng", "Environment"], "arg1": [" arg01", "arg3", "axone", "param1", "ax1", "param01", "Argone", "prop1", "argone", "arg01", "param3", " argOne", "ax2", "axOne", "prop01", "prop3", " argone", "ArgOne", "Arg2", "Arg1", "argOne", " arg3"], "arg2": ["argtwo", "args1", "argumenttwo", " targ1", " argtwo", "argstwo", " argur", " targ2", " targtwo", "argumentur", "argument1", "argur", " targur", "args2", "argument2"], "farg1": ["forargOnce", "fflag61", " fagg001", "fargumentOnce", " fargs64", " farg01", " faggOne", "ufarg01", "floatiskone", "fargone", " farg64", "fargs3", "ftag1", "farg001", "forfield41", "ftagOne", "fark1", "farg3", "fparam3", "fargument91", "fargumentons", "fargument001", "fargumentone", "uftarget1", "fisk001", "fblockized", "fagg001", "freg001", " fagg01", "floatargone", "fbar1", "fagg61", "farg01", "fparamone", "fok41", " fArgone", "ffield41", " fargs1", "farg9", "fArgone", "fArg3", "ufargone", "ffargument3", "ffargument41", "ffieldOnce", "fument7", "fokOne", "fargs1", "ffargument91", "fflagOne", "fark9", "fArgOnce", "freg1", "fregOne", "faggons", "forarg41", "farg61", " farg61", "fargs2", "fok3", "fisk1", "farg64", "ufarg2", "fargs01", "fblock1", "freg9", "foblock001", " fargone", "fint1", "fbar001", "fagg9", " fargOne", " fagg1", " fArg1", "ffield1", "fargumentOne", " fagg61", "fbarized", "fumentized", "fflag001", "fark01", "ftargetone", "ftarget01", "fokOnce", "foblock7", "ffarg1", "fblock7", "fiterOne", "uftarget01", "ftag3", "fiter1", "fparam41", "fiter61", "foblock1", " fagg9", "fagg91", "fargsOne", "ufarg1", "faggOnce", "fflag1", "fint001", "fArg1", "fargOne", "fblock001", "fagg1", "ffarg91", "farg7", "faggone", "fargument3", "fargument1", "fxint001", "fok1", "foblockized", "fargsone", "fxarg1", "fparam91", "fintOne", " fargsOne", "fagg41", "foarg1", "farg41", "ffarg41", " fArgOnce", "fxargOne", "fiskons", " fArg3", "fargized", "forfieldOnce", "fargons", "fiskone", "fargument41", "fagg3", "floatargons", "ftag64", "fbar7", "fok64", " farg3", "freg01", "fxintOne", "floatisk1", " farg9", "floatarg1", "foarg001", "ftarget1", "farg91", "uftargetone", "fument001", "fagg01", "fument1", "fiter001", "floatiskons", "faggOne", " fargOnce", " farg001", "ftarget2", "fparam1", "uftarget2", "fparamOnce", "floatarg001", "fxint1", "ffarg3", "ffargument1", "forarg1", "farkOne", "floatisk001", "fargs64", " fargs3", "foarg7", "foargized", "fagg2", "fxarg001", "fargOnce", "forfield1"], "farg2": ["fregtwo", " freg02", "floatloc22", "varg02", "fvar05", "fument2", " freg2", "fagg02", "fargto", "pArg2", "fArgor", "fresult52", "fdim22", "floatarg2", "fvartwo", "cagg2", "fresultall", "fparamtwo", "carg22", "cagg02", "flocall", "floatargall", "fasc52", "carg02", "fari2", "floatlocTwo", "fdim2", "flocTwo", "carg42", "pargtwo", "fpar02", "fumenttwo", "floatarg256", "fument36", "fagg2", "fparam2", "fcalltwo", "vargto", "farg02", " freg36", "fdim02", "fument02", "freg36", "cagg42", "fari05", "fparto", "fasc2", "floc2", "fagg42", "fvar22", "parg2", "fvarTwo", "floatloc2", "fArgtwo", "fmb2", "fvaror", "faggto", "fascall", "floatarg05", "fitem22", "farg05", "varg2", "fArg2", "fdim42", "fargTwo", "floatargTwo", " farg36", "farg36", "fariTwo", "fpar2", "floatloc05", "freg02", "fagg22", "fmb02", "fcall2", "fitem42", " fregtwo", "farg42", "floatloc256", "fasc256", "fparam02", "vaggto", "freg2", "fmbto", " farg02", "fari22", "fcallor", "floc22", "floc256", "cagg22", "vagg02", " fargtwo", "farg256", "fresult256", "fvar2", "pargor", "fargall", "floc52", "floatlocall", "fresult2", "floc05", "farg22", "vagg2", "pArgor", "fitem2", "fitem02", "floatarg52", "floatloc52", "farg52", "carg2", "floatarg22", "fparam36", "fargtwo", "pArgtwo", "fargor"]}}
{"project": "qemu", "commit_id": "e4d2edc9d0c58de421eb349871e90b67edec0b9c", "target": 0, "func": "static void test_io_channel_ipv4(bool async)\n\n{\n\n    SocketAddress *listen_addr = g_new0(SocketAddress, 1);\n\n    SocketAddress *connect_addr = g_new0(SocketAddress, 1);\n\n\n\n    listen_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    listen_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");\n\n    listen_addr->u.inet->port = NULL; /* Auto-select */\n\n\n\n    connect_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    connect_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");\n\n    connect_addr->u.inet->port = NULL; /* Filled in later */\n\n\n\n    test_io_channel(async, listen_addr, connect_addr);\n\n\n\n    qapi_free_SocketAddress(listen_addr);\n\n    qapi_free_SocketAddress(connect_addr);\n\n}\n", "idx": 2817, "substitutes": {"async": ["AsAsync", "Asynchronous", "ASynchronous", " asAsync", "ASAsync", "assynchronous", "asset", "Async", " assync", "Assync", "asynchronous", "ASsync", "assync", " aset", "Aset", " asynchronous", "ASync", "asAsync", "aset"], "listen_addr": ["listenedaddr", "listenptaddr", "listened_add", "listener_tag", "liston_address", "listen67addr", "listen___map", "listen67debug", "listened_arp", "listener_url", "listen_arp", "listened_addr", "listen____ord", "listenptptr", "liston_addr", "listen____tag", "listenptpart", "listen_address", "listen_tag", "listener_conn", "listener_map", "listenedurl", "listener_sta", "listener_ptr", "listen_debug", "listen___addr", "listen_add", "listeningaddr", "listenabledata", "listen_ord", "listen_arr", "listen_map", "listen67address", "listenableurl", "listen_data", "listened_ptr", "listen_conn", "listen_ptr", "listener_ord", "listeningarr", "listener_part", "liston_debug", "listen_sta", "listen_url", "listenableaddr", "listen_part", "listen____addr", "listeneddata", "listener_addr", "listener_data", "listeningsta", "listener_arr", "listen___conn"], "connect_addr": ["connect_attr", "connect_res", " connect_add", "remove_pkg", "connect___addr", "connableaddress", "remove_grad", "connect_conn", "connableconn", "connect_align", "connect_grad", "submit_attr", "connectistpkg", "conn_conn", " connect_mod", "connect_adder", "remove_addr", "connect_address", "removeistusr", "connect_usr", "connectistusr", "submit_addr", "connectistgrad", "conn_address", "removeistpkg", "connect_der", "connectingusr", "connectingaddr", "connect_pkg", "connect___adr", "connableadr", " connect_der", " connect_align", "removeistaddr", "connectistaddr", " connect_map", " connect_ref", "conn_adr", " connect_ptr", " connect_res", "connect___conn", " connect_adder", "connectableadr", "connectableaddr", "connect_adr", "conn_addr", "connectingpkg", "connectableaddress", "connect_map", "connectableconn", "connectinggrad", "connect_ptr", "remove_usr", "connect_add", "submit_adder", "connect_ref", "connableaddr", "connect___address", "connect_mod", "removeistgrad"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson_cp2\";\n\n    uint32_t opc, shift_max;\n\n    TCGv_i64 t0, t1;\n\n\n\n    opc = MASK_LMI(ctx->opcode);\n\n    switch (opc) {\n\n    case OPC_ADD_CP2:\n\n    case OPC_SUB_CP2:\n\n    case OPC_DADD_CP2:\n\n    case OPC_DSUB_CP2:\n\n        t0 = tcg_temp_local_new_i64();\n\n        t1 = tcg_temp_local_new_i64();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_new_i64();\n\n        t1 = tcg_temp_new_i64();\n\n        break;\n\n    }\n\n\n\n    gen_load_fpr64(ctx, t0, rs);\n\n    gen_load_fpr64(ctx, t1, rt);\n\n\n\n#define LMI_HELPER(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break\n\n#define LMI_HELPER_1(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break\n\n#define LMI_DIRECT(UP, LO, OP) \\\n\n    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break\n\n\n\n    switch (opc) {\n\n    LMI_HELPER(PADDSH, paddsh);\n\n    LMI_HELPER(PADDUSH, paddush);\n\n    LMI_HELPER(PADDH, paddh);\n\n    LMI_HELPER(PADDW, paddw);\n\n    LMI_HELPER(PADDSB, paddsb);\n\n    LMI_HELPER(PADDUSB, paddusb);\n\n    LMI_HELPER(PADDB, paddb);\n\n\n\n    LMI_HELPER(PSUBSH, psubsh);\n\n    LMI_HELPER(PSUBUSH, psubush);\n\n    LMI_HELPER(PSUBH, psubh);\n\n    LMI_HELPER(PSUBW, psubw);\n\n    LMI_HELPER(PSUBSB, psubsb);\n\n    LMI_HELPER(PSUBUSB, psubusb);\n\n    LMI_HELPER(PSUBB, psubb);\n\n\n\n    LMI_HELPER(PSHUFH, pshufh);\n\n    LMI_HELPER(PACKSSWH, packsswh);\n\n    LMI_HELPER(PACKSSHB, packsshb);\n\n    LMI_HELPER(PACKUSHB, packushb);\n\n\n\n    LMI_HELPER(PUNPCKLHW, punpcklhw);\n\n    LMI_HELPER(PUNPCKHHW, punpckhhw);\n\n    LMI_HELPER(PUNPCKLBH, punpcklbh);\n\n    LMI_HELPER(PUNPCKHBH, punpckhbh);\n\n    LMI_HELPER(PUNPCKLWD, punpcklwd);\n\n    LMI_HELPER(PUNPCKHWD, punpckhwd);\n\n\n\n    LMI_HELPER(PAVGH, pavgh);\n\n    LMI_HELPER(PAVGB, pavgb);\n\n    LMI_HELPER(PMAXSH, pmaxsh);\n\n    LMI_HELPER(PMINSH, pminsh);\n\n    LMI_HELPER(PMAXUB, pmaxub);\n\n    LMI_HELPER(PMINUB, pminub);\n\n\n\n    LMI_HELPER(PCMPEQW, pcmpeqw);\n\n    LMI_HELPER(PCMPGTW, pcmpgtw);\n\n    LMI_HELPER(PCMPEQH, pcmpeqh);\n\n    LMI_HELPER(PCMPGTH, pcmpgth);\n\n    LMI_HELPER(PCMPEQB, pcmpeqb);\n\n    LMI_HELPER(PCMPGTB, pcmpgtb);\n\n\n\n    LMI_HELPER(PSLLW, psllw);\n\n    LMI_HELPER(PSLLH, psllh);\n\n    LMI_HELPER(PSRLW, psrlw);\n\n    LMI_HELPER(PSRLH, psrlh);\n\n    LMI_HELPER(PSRAW, psraw);\n\n    LMI_HELPER(PSRAH, psrah);\n\n\n\n    LMI_HELPER(PMULLH, pmullh);\n\n    LMI_HELPER(PMULHH, pmulhh);\n\n    LMI_HELPER(PMULHUH, pmulhuh);\n\n    LMI_HELPER(PMADDHW, pmaddhw);\n\n\n\n    LMI_HELPER(PASUBUB, pasubub);\n\n    LMI_HELPER_1(BIADD, biadd);\n\n    LMI_HELPER_1(PMOVMSKB, pmovmskb);\n\n\n\n    LMI_DIRECT(PADDD, paddd, add);\n\n    LMI_DIRECT(PSUBD, psubd, sub);\n\n    LMI_DIRECT(XOR_CP2, xor, xor);\n\n    LMI_DIRECT(NOR_CP2, nor, nor);\n\n    LMI_DIRECT(AND_CP2, and, and);\n\n    LMI_DIRECT(PANDN, pandn, andc);\n\n    LMI_DIRECT(OR, or, or);\n\n\n\n    case OPC_PINSRH_0:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);\n\n        opn = \"pinsrh_0\";\n\n        break;\n\n    case OPC_PINSRH_1:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);\n\n        opn = \"pinsrh_1\";\n\n        break;\n\n    case OPC_PINSRH_2:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);\n\n        opn = \"pinsrh_2\";\n\n        break;\n\n    case OPC_PINSRH_3:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);\n\n        opn = \"pinsrh_3\";\n\n        break;\n\n\n\n    case OPC_PEXTRH:\n\n        tcg_gen_andi_i64(t1, t1, 3);\n\n        tcg_gen_shli_i64(t1, t1, 4);\n\n        tcg_gen_shr_i64(t0, t0, t1);\n\n        tcg_gen_ext16u_i64(t0, t0);\n\n        opn = \"pextrh\";\n\n        break;\n\n\n\n    case OPC_ADDU_CP2:\n\n        tcg_gen_add_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n    case OPC_SUBU_CP2:\n\n        tcg_gen_sub_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n\n\n    case OPC_SLL_CP2:\n\n        opn = \"sll\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRL_CP2:\n\n        opn = \"srl\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRA_CP2:\n\n        opn = \"sra\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_DSLL_CP2:\n\n        opn = \"dsll\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRL_CP2:\n\n        opn = \"dsrl\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRA_CP2:\n\n        opn = \"dsra\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    do_shift:\n\n        /* Make sure shift count isn't TCG undefined behaviour.  */\n\n        tcg_gen_andi_i64(t1, t1, shift_max - 1);\n\n\n\n        switch (opc) {\n\n        case OPC_SLL_CP2:\n\n        case OPC_DSLL_CP2:\n\n            tcg_gen_shl_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRA_CP2:\n\n        case OPC_DSRA_CP2:\n\n            /* Since SRA is UndefinedResult without sign-extended inputs,\n\n               we can treat SRA and DSRA the same.  */\n\n            tcg_gen_sar_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRL_CP2:\n\n            /* We want to shift in zeros for SRL; zero-extend first.  */\n\n            tcg_gen_ext32u_i64(t0, t0);\n\n            /* FALLTHRU */\n\n        case OPC_DSRL_CP2:\n\n            tcg_gen_shr_i64(t0, t0, t1);\n\n            break;\n\n        }\n\n\n\n        if (shift_max == 32) {\n\n            tcg_gen_ext32s_i64(t0, t0);\n\n        }\n\n\n\n        /* Shifts larger than MAX produce zero.  */\n\n        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);\n\n        tcg_gen_neg_i64(t1, t1);\n\n        tcg_gen_and_i64(t0, t0, t1);\n\n        break;\n\n\n\n    case OPC_ADD_CP2:\n\n    case OPC_DADD_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_add_i64(t0, t1, t2);\n\n            if (opc == OPC_ADD_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_andc_i64(t1, t2, t1);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_ADD_CP2 ? \"add\" : \"dadd\");\n\n            break;\n\n        }\n\n\n\n    case OPC_SUB_CP2:\n\n    case OPC_DSUB_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_sub_i64(t0, t1, t2);\n\n            if (opc == OPC_SUB_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_and_i64(t1, t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_SUB_CP2 ? \"sub\" : \"dsub\");\n\n            break;\n\n        }\n\n\n\n    case OPC_PMULUW:\n\n        tcg_gen_ext32u_i64(t0, t0);\n\n        tcg_gen_ext32u_i64(t1, t1);\n\n        tcg_gen_mul_i64(t0, t0, t1);\n\n        opn = \"pmuluw\";\n\n        break;\n\n\n\n    case OPC_SEQU_CP2:\n\n    case OPC_SEQ_CP2:\n\n    case OPC_SLTU_CP2:\n\n    case OPC_SLT_CP2:\n\n    case OPC_SLEU_CP2:\n\n    case OPC_SLE_CP2:\n\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n\n           FD field is the CC field?  */\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n#undef LMI_HELPER\n\n#undef LMI_DIRECT\n\n\n\n    gen_store_fpr64(ctx, t0, rd);\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn,\n\n               fregnames[rd], fregnames[rs], fregnames[rt]);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 2818, "substitutes": {"ctx": ["sys", "cp", "ctr", "cas", "tmp", "jp", "c", "CC", "xc", "nc", "bc", "handle", "scl", "conn", "conv", "dc", "hw", "np", "txt", "cfg", "cb", "KC", "act", "pg", "tx", "kt", "this", "sc", "tm", "req", "cmp", "cci", "ij", "tz", "kw", "ctl", "context", "tc", "setup", "cv", "pool", "rx", "pkg", "anc", "obj", "loc", " cx", "cc", "cu", "ct", "cpp", "cmd", "cm", "Context", "rc", "lc", "resp", "mc", "jac", "ctrl", "self"], "rd": ["usr", "d", "cr", "cd", "lr", "rg", "dd", "hr", "rid", "ru", "rb", "rw", "lb", "gb", "ld", "rin", "sd", "rf", "rh", "rr", "rx", "rl", "rm", "wr", "rc", "RW", "th", "std", "rn"], "rs": ["mr", "ros", "ls", "rows", "orts", "vs", "r", "xs", "s", "ds", "res", "ubs", "fs", "RS", "ars", "ra", "ps", "ns", "bs", "sr", "ris", "Rs", "rys", "ms", "cs", "ts", "ries", "ks", "ras", "hs", "sts", "ows", "ats", "rc", "ins", "rates", "ys"], "rt": ["mr", "mt", "cr", "ty", "dt", "vr", "tt", "hr", "r", "RT", "vt", "rb", "rw", "tx", "rat", "tm", "bt", "rf", "rh", "fr", "rr", "rx", "rl", "pt", "rm", "nt", "wr", "wt", "rc", "tr", "ri", "sq", "t", "rn"], "opn": ["hopn", "optN", "opcn", " opns", "opnan", " opmn", "optc", "hoppn", "hopc", " opN", "opmn", "optnan", " oppn", "optcn", "oppn", "opnr", " opcn", "hopcn", "OPns", "OpN", "optnr", "OPcn", "Opc", "opN", "OPc", " opnan", "hopmn", "opns", "hopns", "OPnr", " opnr", "optn", "Opnan", "OPn", "OPmn", "Opn", "OPpn"], "opc": ["hopn", "OPcode", "apc", "OPf", "ppc", "OPct", "opC", "opf", "hopC", "ppn", "copC", "apC", "hopc", " opC", "opcs", "copce", "ppcode", " opcs", "opcode", "hopct", "apcode", "OPc", "OPcs", "copc", " opce", "opct", "ppcs", "opce", " opct", "OPC", "copcs", " opf", "copn", "copf", "OPce", " opcode", "copcode", "OPn", "apn"], "shift_max": ["shift_MAX", "hift_min", "shift_min", "hift_max", "hift_MAX", "hift_Max", "shift_Max"], "t0": [" t8", " tee", "dt0", "ttee", "tree4", "T1", "t00", "tt2", " t4", "pt02", " tb", "tb", "T00", "t02", "ttb", "ptee", " t000", "t4", "T4", "tree0", "treeums", "pt0", "t2", "t8", " t00", "dt8", "T000", "dtb", " tums", "t000", "ta0", "dt1", "tree1", "tee", "tt0", " t2", "ta000", "pt2", "tums", "Tums", "tt02", "T0", "ta1", " t02", "tt8", "tt1", "ta00"], "t1": ["p1", "otone", "dtOne", "t31", " t9", "dtone", "tcONE", "p3", " t3", "T1", "tree9", " tONE", "t3", "tree10", "tree0", " tOne", "tone", "t2", "p0", "T9", " tone", " t91", "tc1", "ot1", "treeONE", "otOne", "dt1", "t91", " t10", "T3", "T2", "tree1", "tONE", " t2", " t31", "T31", "tc10", "t9", "ot91", "T0", "p2", "dt91", "tree31", "t10", "tOne"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_stat(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsStat v9stat;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n\n    err = offset;\n\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n\n    v9fs_stat_free(&v9stat);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 2820, "substitutes": {"opaque": ["oppaques", "oboster", "opposter", " opque", "pque", "oposter", "Opque", "Opaque", "pacity", "paque", "opacity", " opaques", "opque", "poster", "oppque", "opaques", "obacity", "Opacity", "obque", "Opaques", "oppaque", "oppacity", " opacity", "obaque"], "fid": ["pID", "fscore", "cfoid", "cfId", "Fmid", "fId", "foid", "cfid", " fId", "cfscore", "cId", "cid", "fvalid", "Fid", " fID", "FId", "afmid", "FID", " fmid", "tfscore", "afID", "Fvalid", "tfid", "afid", "Fscore", "cvalid", "tfoid", "fmid", "pId", "fID", "Foid", "tfId", "pid", "pvalid", "cID"], "v9stat": ["V9stat", "v8stats", "v910summary", "f8Stat", "v98Stat", "v89status", "ev89dat", "v949status", "ev89attr", "vninedecl", "v9st", "v999st", "v89dat", "v970stat", "vninestat", "vninefeat", "v9sat", "vninewarn", " v89err", "V6stat", "v9warn", " v9stats", "vm900rat", "ev9feat", "v9stats", "v900rat", "v9attr", "v9hit", "ev9attr", "v09stat", " v9state", "v9summary", "v999summary", "ev89decl", "V6Stat", "v09rat", "f9sat", "v98stat", "v970status", "v9err", "inv9stat", "v90err", "v909stat", "v89stat", "v89state", "v9pri", "v89attr", "v909state", "f8pri", "v98pri", "inv9warn", " v8Stat", "v9status", "vm9hit", "v6Stat", "ev9status", "v9str", "v949attr", " v9str", "v90stat", "v98sat", "v999hit", "vm9rat", " v8stat", "v89str", "v6status", " v89stat", "v8stat", "v970dat", "v900stat", "v909err", "vm900hit", "v910attr", "v999rat", "ev9decl", "v90str", "f9Stat", " v89str", "V6status", "v6stat", "f8stat", "v09st", "vninesummary", "v9decl", "v9feat", "vm9st", "inv9summary", " v9Stat", "ev89status", "v8status", "v949decl", "f9pri", "v09sat", "v900hit", "v910warn", "v9state", "inv9attr", "v999stat", "v09pri", "v970feat", "invninesummary", "v09Stat", "f9stat", "ev9stat", "v900st", "v999attr", "invnineattr", "v9dat", "v999warn", "v6stats", " v8status", "v8pri", "v910stat", "f8sat", "v949stat", "v909str", "v89err", "v8sat", "vm900stat", "v89feat", "vm900st", "ev89feat", "vninestatus", " v8stats", "V9Stat", "v09hit", " v9err", "v89decl", "v8Stat", " v89state", "invninewarn", "ev89stat", "vm9stat", "invninestat", "vninedat", "V9status", "v9Stat", "ev9dat", " v9status", "v9rat", "vnineattr", "v90state"], "stbuf": [" stuf", "ndBuffer", "STbuf", "nddoc", "estbuffer", "stdoc", "ostbuff", "STBuffer", "ostbuffer", "estbuf", "Stbuffer", "ostbuf", " stBuffer", "nduf", "STuf", "stbuff", "estbuff", "Stvec", "ndbuf", "ostvec", "STdoc", "estvec", "stbuffer", "stBuffer", "stuf", " stdoc", "Stbuf", "Stbuff", "stvec"], "fidp": [" fidpt", "fidentp", "foidpa", "FidP", "foidl", "ufridq", "fitp", "finpa", "fridpre", "fpidpid", "foidm", "fIdp", "foidp", "fidentP", "fidq", "fridP", "fIdl", "fIdpa", " fitpid", "fidps", "fidentpid", "fIDp", "fidping", "fitpt", "fIdper", "facidping", "ufidP", "Fidp", "fidpre", "fidpa", " fidP", "fidentps", "FIdP", "ufidq", "fidl", "foidping", "FIdpa", "fpidpt", "facidentpre", "fridm", " fitps", " fitp", "ufridP", "fidentpre", "finl", " fidps", "facidentping", "fridping", "Fidl", "fIDper", "fridpa", "ufridpa", "fidentpt", "fidentpa", "facidentm", "fpidps", "finp", " fidpid", "fitpid", " fidpa", "facidm", "facidp", "foidpre", "foidP", "facidpre", " fitpt", "fidm", "ufidp", "fridp", "fidpt", "fidentping", "facidentp", "ufidpa", "fpidp", "fIdP", "fitps", "FIdper", "fridq", "ufridp", "fidper", "finP", "fidP", "fidpid", "Fidper", "FIdp", "FIdl", "Fidpa", "fIDpa", "fidentq", "fidentm", "fIDP"], "pdu": ["pcdes", "opdem", " puc", "compkt", "prud", "pge", "patchdes", "ipud", " pcom", "apdem", "compdu", " punit", "pingdu", "pu", " pcmd", "apcu", "ppda", "puer", "apdu", "ppud", "aptu", "ppkt", "comptu", "pdo", "wpud", " pkt", "pades", " pdat", " pso", "dpud", "opdu", "pkgtu", "apdr", "pkt", "opge", "pkgdat", " pda", "punit", "pingtu", "apud", "pcu", "ppdu", "pingkt", "pkgdu", "prdem", "apcmd", "puc", "formtu", " pce", " pdo", "patchuer", "impue", "patchdo", " pdes", "apuc", " pge", "upud", " pdi", "pui", "wpdr", "ipdu", " pu", "apge", "apue", "pingue", "opunit", "dpdr", "paydu", "ppdr", "ppue", "apkt", "patchtu", "ppcu", "impdr", "impdu", "pkgce", "ppce", " pcu", "compue", "pud", "wpdi", "ppui", "dpdu", "wpdu", "patchuc", "ptu", "ppdat", "dpdem", " pui", "payunit", "impu", "formdes", "pptu", "pdat", "paycom", "updu", "formdu", "upue", "opcom", "ppdes", "opue", "opru", "pcom", "uptu", "pda", " pud", "pingud", "pauer", "ppso", "pcmd", " ptu", "pcui", "padu", "ipda", "prdu", "pru", "pdes", "pdr", " pdr", "pingda", "pso", "pcdu", " pru", "prda", "pce", "pcso", "dpda", "ppu", "pdem", "patchdu", "payru", "patchcmd", "formuer", "patu", "apdo", " pue", "pdi", " pdem", "pue", "ipdem", "dpdi"], "s": ["d", "S", "stats", "status", "c", "is", "sv", "ss", "p", "z", "es", "g", "n", "r", "set", "ds", "m", "i", "b", "fs", "ps", "its", "ns", "state", "bs", "y", "w", "e", "as", "span", "ts", "spec", "sts", "v", "rs", "h", "o", "gs", "f", "sb", "ins", "os", "t", "sp"]}}
{"project": "qemu", "commit_id": "2958620f67dcfd11476e62b4ca704dae0b978ea3", "target": 1, "func": "uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n", "idx": 2832, "substitutes": {"op1": ["p1", "optN", "opt8", "op_", "cop1", "copone", "hop2", "Opone", " opone", "opt4", "op4", "hopl", "p_", "opt0", "opt01", "op8", "op0", "hop1", "OpOne", "pop2", " op01", "pop_", "popN", "hop4", " opN", "optl", "p0", "pop1", "OPOne", "optone", "hopone", " opOne", " op_", "OPone", "Op2", "hopOne", "hop0", " op4", "opN", "copl", "opOne", "Op1", "op01", "hop01", "opt1", " op8", "opt2", "OP2", "opl", "opone", "cop0", "hop8", "opt_", "pop0", "p2", " op0", "OP1"], "op2": ["opt8", "opt22", "ip02", "hop2", "tip2", "ip0", "ip1", "top02", "op8", "OP8", " op102", "op0", "hop1", "op102", "op02", "top0", "OP22", "ip2", "tiptwo", "top2", "tip1", "hoptwo", " op22", "optwo", " op02", "hop102", " op8", "opt1", "OP2", "opt2", " optwo", "op22", "tip102", " op0", "OP1", "top1"]}}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,\n\n                                   RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *l2_group;\n\n    RockerTlv **tlvs;\n\n    int err;\n\n    int i;\n\n\n\n    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n\n        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    group->l2_flood.group_count =\n\n        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n\n\n\n    tlvs = g_malloc0((group->l2_flood.group_count + 1) *\n\n                     sizeof(RockerTlv *));\n\n    if (!tlvs) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    g_free(group->l2_flood.group_ids);\n\n    group->l2_flood.group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n", "idx": 2846, "substitutes": {"of_dpa": ["of_vdpu", "of_Dpo", "of_dpo", "of_didppa", "of_idpi", "of_idpa", "of_dara", "of_vdpa", "of_vdpi", "of_idpu", "of_Dara", "of_iddp", "of_Ddp", "of_Dpi", "of_didpo", "of_dpu", "of_Dppa", "of_dppa", "of_Dpu", "of_didara", "of_vddp", "of_ddp", "of_didpa", "of_dpi", "of_Dpa"], "group": ["parent", "user", "roup", "match", "handle", "component", "p", "window", "order", "app", "sum", "pg", "form", "pattern", "manager", "channel", "batch", "message", "list", "row", "service", "link", "filter", "force", "game", "who", "band", "member", "remote", "display", "arg", "database", "sync", "graph", "chain", "host", "record", "join", "part", "guard", "network", "call", "block", "comment", "error", "one", "go", "db", "v", "client", "process", "single", "draw", "Group", "map", "mail", "GROUP", "data", "public", "status", "g", "package", "debug", "table", "profile", "config", "local", "player", "command", "role", "global", "coll", "field", "store", "rule", "module"], "group_tlvs": ["group_tlevss", "group_tcols", "group_flfs", "group_tlsss", "group_flvss", "group_tLVd", "group_tlss", "group_tcolis", "group_Tlvs", "group_tlld", "group_tlfss", "group_tlevs", "group_txtS", "group_tlfes", "group_Tlfs", "group_tllc", "group_plfs", "group_tlls", "group_tlvd", "group_nlvS", "group_tcps", "group_tyls", "group_flfS", "group_tlves", "group_tlfS", "group_dlls", "group_tcpes", "group_tlevr", "group_nlvr", "group_plfes", "group_tlvss", "group_dlvs", "group_tlvc", "group_Tlfis", "group_txts", "group_tlfis", "group_Tlvis", "group_tlfr", "group_flvS", "group_plvs", "group_txtr", "group_Tlfes", "group_tlfd", "group_tyles", "group_tlvS", "group_tlles", "group_tlsS", "group_dllc", "group_tllis", "group_nlfs", "group_dlvd", "group_tlvr", "group_tlfc", "group_tLVc", "group_flvs", "group_tlvis", "group_tlfs", "group_nlfS", "group_tlevS", "group_nlvs", "group_plves", "group_dlvc", "group_flfss", "group_tcoles", "group_Tlves", "group_nlfr", "group_tLVs", "group_dlld"], "l2_group": ["ltwo_block", "l1_user", "ltwomyblock", "l2myuser", "ltwomygroups", "ltwomyuser", "l2_match", "l3__user", "l2__match", "ltwomygroup", "ltwo_user", "ltwo_groups", "l2_part", "l1_group", "l2_user", "l2___group", "l2___user", "l3_user", "l2mygroups", "l3_match", "l1_groups", "l3_part", "l3__group", "l2_groups", "l2___match", "l2__group", "l3__match", "l3_group", "l2__part", "l2mygroup", "l2__user", "ltwo_group", "l1_field", "l2___part", "l3__part", "l2_block", "l2myblock", "l2_field"], "tlvs": ["tlfe", "tladals", "tbufses", "latvvs", "tlfS", "tvvds", "etvvers", "etlvs", "latvvfs", "latvves", "tbufs", "tvvf", "latvvc", "twlf", "tlvfs", "tladers", "tlevs", "tavs", "etlvals", "tlfc", "tlegS", " tbufses", "tlvals", "tleves", "tvvs", "tlevers", "tvde", " tbufs", "wlvf", " tlfS", "etvvals", "latlvc", "tbufes", "tavses", "etlvers", "wwlf", " tlves", "latlvs", "tolff", "tlege", "wlvs", "tvves", "tlevals", "tvvfs", "wwlfs", " tlfs", "tlvers", "tlvses", " tlve", "tladds", "tlevds", "etlvds", "tlfs", "tlvc", "tlffs", "etvvs", "tlves", "latlvfs", " tbufes", " tlvS", "tlevfs", "tvvers", "tlvf", "tlve", "twls", "tlvds", "tlfses", "tvvals", "tlads", "tlvS", "latlves", "tlfes", "etvvds", "taves", " tlvses", "wlvfs", "tolffs", " tlfe", "tvdS", "wwls", "tolfs", "tvvc", "tlegs", "tlevc", "tvds", "twlfs"], "err": ["mr", "usr", "ctr", "gr", "cr", "l", "lr", "er", "arr", "nr", "aaa", "attr", "result", "r", "order", "txt", "iter", "ner", "out", "cfg", "rb", "m", "cli", "msg", "ered", "it", "kr", "error", "ie", "Er", "e", "fr", "rr", "str", "or", "Error", "dr", "rs", "fee", "oe", "gz", "race", "elt", "late", "rn"], "i": ["parent", "init", "li", "x", "us", " ti", "iu", "ti", "span", "ind", "uri", "ix", "zi", "ini", "I", " bi", "batch", "key", " j", "xi", "ic", "qi", "m", "u", "ui", "it", "ex", "gu", "ims", "im", "remote", "\u0438", "ri", "chain", "j", " m", "ii", "l", " mi", "ji", "pi", "index", "me", "ci", "ei", "phi", "eu", " ii", "y", " pi", "bi", "hi", " I", "v", " ni", "mi", "di", "ai", "si", "point", "multi", "ki", "is", "sim", " di", "ami", "cli", "gi", " si", "ip", "oi", "ie", "print", "fire", "in"]}}
{"project": "FFmpeg", "commit_id": "8bdba1092f50d52e0af90f425811302ec91152f8", "target": 1, "func": "int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n\n    const uint64_t fuzz_tag = FUZZ_TAG;\n\n    FuzzDataBuffer buffer;\n\n    const uint8_t *last = data;\n\n    const uint8_t *end = data + size;\n\n    uint32_t it = 0;\n\n\n\n    if (!c)\n\n        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.\n\n\n\n    AVCodecContext* ctx = avcodec_alloc_context3(NULL);\n\n    if (!ctx)\n\n        error(\"Failed memory allocation\");\n\n\n\n    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs\n\n\n\n    int res = avcodec_open2(ctx, c, NULL);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    FDBCreate(&buffer);\n\n    int got_frame;\n\n    AVFrame *frame = av_frame_alloc();\n\n    if (!frame)\n\n        error(\"Failed memory allocation\");\n\n\n\n    // Read very simple container\n\n    AVPacket avpkt;\n\n    while (data < end && it < maxiteration) {\n\n        // Search for the TAG\n\n        while (data + sizeof(fuzz_tag) < end) {\n\n            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)\n\n                break;\n\n            data++;\n\n        }\n\n        if (data + sizeof(fuzz_tag) > end)\n\n            data = end;\n\n\n\n        FDBPrepare(&buffer, &avpkt, last, data - last);\n\n        data += sizeof(fuzz_tag);\n\n        last = data;\n\n\n\n        // Iterate through all data\n\n        while (avpkt.size > 0 && it++ < maxiteration) {\n\n            av_frame_unref(frame);\n\n            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);\n\n\n\n            if (it > 20)\n\n                ctx->error_concealment = 0;\n\n\n\n            if (ret <= 0 || ret > avpkt.size)\n\n               break;\n\n\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n    }\n\n\n\n    av_init_packet(&avpkt);\n\n    avpkt.data = NULL;\n\n    avpkt.size = 0;\n\n\n\n    do {\n\n        got_frame = 0;\n\n        decode_handler(ctx, frame, &got_frame, &avpkt);\n\n    } while (got_frame == 1 && it++ < maxiteration);\n\n\n\n    av_frame_free(&frame);\n\n    avcodec_free_context(&ctx);\n\n    av_freep(&ctx);\n\n    FDBDesroy(&buffer);\n\n    return 0;\n\n}", "idx": 2857, "substitutes": {"data": ["id", "format", "step", "delay", "p", "only", "window", "read", "out", "load", "zero", "time", "state", "output", "context", "response", "body", "bytes", "hash", "done", "feed", "reset", "timeout", "a", "this", "batch", "d", "Data", "message", "key", "shift", "next", "text", "result", "none", "at", "final", "name", "first", "offset", "padding", "position", "rel", "length", "byte", "device", "buf", "all", "multiple", "to", "index", "send", "dat", "res", "new", "cache", "ord", "type", "pad", "error", "str", "empty", "ata", "address", "draw", "date", "na", "da", "len", "input", "image", "add", "value", "no", "DATA", "after", "mode", "table", "tx", "pos", "start", "extra", "win", "mu", "ta", "content", "video", "raw", "t", "base"], "size": ["message", "status", "code", "count", "format", "height", "use", "shift", "style", "limit", "n", "description", "any", "index", "ci", "set", "send", "small", "sum", "space", "sent", "pos", "start", "notice", "speed", "cache", "shape", "type", "storage", "time", "scope", "tag", "error", "SIZE", "w", "ose", "iz", "name", "spec", "len", "since", "now", "loc", "offset", "ize", "body", "scale", "empty", "bytes", "fee", "scroll", "sized", "position", "args", "st", "unit", "timeout", "length", "capacity", "Size", "sn"], "buffer": ["batch", "input", "template", "document", "message", "fc", "face", "temp", "builder", "image", "buf", "code", "limit", "row", "window", "ref", "package", "sequence", "table", "memory", "engine", "header", "cache", "connection", "comment", "cv", "context", "command", "pool", "gc", "Buffer", "reference", "queue", "v", "null", "empty", "bridge", "client", "channel", "event", "f", "timeout", "tc", "base", "length", "buff"], "last": ["total", "parent", "l", "buf", "nd", "las", "count", "next", "all", "before", "ast", "after", "out", "full", "start", "cache", "state", "final", "Last", "tail", "best", "first", "since", "old", "low", "vol", "est", "max", "st", "prev", "latest", "t", "base", "length", "self"], "end": ["ec", "END", "total", "id", " End", "ff", "add", "nd", "ext", "next", "all", "p", "ent", "after", "out", "set", "send", "ending", "hend", "start", "off", "ord", "pad", "ended", "dev", "stop", "w", "e", "pend", "en", "append", "End", "len", "ment", "east", "offset", "ender", "old", "rend", "h", "est", "event", "max", "st", "begin", "enc", "obj", "eng", "length"], "ctx": ["proc", "sys", "cp", "alloc", "ctr", "ctrl", "fc", "wcs", "func", "jp", "buf", "c", "addr", "xc", "bc", "nc", "unc", "conn", "conv", "dc", "ca", "window", "np", "txt", "mc", "cb", "act", "res", "tx", "kt", "msg", "this", "sc", "qt", "req", "cmp", "tz", "kw", "ctl", "cf", "context", "cv", "err", "con", "pool", "co", "pkg", "gc", "obj", "rt", "loc", "cu", "cc", "nt", "wx", "ct", "cl", "cm", "lc", "ac", "iat", "tc", "jac", "cmd", "buff"], "got_frame": [" got_request", "gotptframe", "got_step", "got___point", "got___channel", " got_time", "got__channel", "Got__state", "got_Frame", "hung_frame", "Got__frame", "createdjstyle", "got___Frame", "Got__Frame", "gotjstep", "gotjstyle", "gotptcomponent", "Got_state", "created_step", "seen_component", " got_window", "got___request", "got___range", "got_time", "got__frame", "got___state", "seen_data", "createdjstep", "got_style", "Got__channel", "got_range", "got___window", "gotjtag", "seen_frame", "got___time", "createdjtag", "created_tag", "gotptwindow", "created_frame", "got_channel", "got_state", "seenptdata", "hung_point", "got__state", "got_request", "hung___point", "got__Frame", "gotjframe", "got_tag", "gotptdata", "hung_range", "seen_window", "got_point", "got___frame", "got_data", "Got_frame", "seenptframe", "created_style", "hung___range", "hung_channel", "hung___channel", "seenptwindow", "seenptcomponent", "got_window", "Got_Frame", "hung___frame", "got_component", "Got_channel", "createdjframe"], "frame": ["proc", "ace", "image", " framed", "fc", "face", "frames", "instance", "code", "flow", "next", "row", "init", "window", " Frame", "Frame", "package", "box", "fram", "sequence", "header", "tx", "rame", "ce", "kt", "profile", "qt", "def", "scene", "iframe", "uart", " frames", "fi", "call", "block", "cf", "error", "context", "ptr", "command", "fr", "function", "rt", "remote", "framework", "range", "fb", "process", "channel", "draw", " timeframe", "f", "line", "reset", "thread", "point", "state", "feat", "base", "cmd", "feature", "chain"], "avpkt": [" avpct", "avpsacket", "aveopet", "vrpwd", "averpingct", "ahpwk", "averpct", "avpingacket", "avtipkat", "vrparwd", "vrppt", "averpkt", "avenpcmd", "avopet", "avtipkt", "ahpett", "avwpett", "avnpjson", "ahpackkt", "avnpacket", "avparkg", "avpkgett", "avppacket", " avcpacket", "averlpkt", "vrtipkat", "avpwk", "avpaykat", "aveopkt", "vrpkg", "avpaywk", "verpct", "avckt", "avepckt", "averpqt", " avpacket", "avppct", "avlpkt", "avlpacket", "avprekg", "avpjson", "avepett", "avpkg", "evpct", "avnpwk", "avpcwk", "averlpacket", "avpacket", "avlpqt", "avtpcmd", "avpwd", "avppt", "avepcett", "avppkg", "avPett", "avcpct", "avmacket", "avcpett", "vernpkt", "avpackwk", "avepjson", "averlpett", "vrpkt", "avpadkat", "vrpkat", "avpkgjson", "avcett", "avmct", "vrpwk", "avwpct", "avnpcmd", "avopqt", "avPet", "avparpt", "avenpwk", "avcct", "avcacket", "ahpackkg", "avPacket", "avcpet", "avtipkg", "avpackkt", "avpackett", " avcpct", "averpacket", "avpcett", "avpaykg", "evpacket", "avepcacket", "avpkget", "avtpett", "averpingett", "avpackkg", "avpcct", "avpkat", "evpet", "avpet", "avpett", "avpkgkt", "ahpkg", "vrtipkg", "avepacket", "avnpct", "avpsett", "avwpacket", "evwpkt", "avpcwd", "ahpackwk", "evwpacket", "avpckt", "evpkt", "avpcpt", "avpckg", "avenpett", "averpingacket", "avcpacket", "avtipwk", "avpingct", "vrtipkt", "vernpett", "avnpet", "vernpct", "avpppt", "avlpett", "avepcmd", "avwpkt", "avnpett", "avppkt", "avopacket", "avtpwk", "avPct", "avpcqt", "avpadkt", "avenpkt", "averpett", "avpskt", "avprekt", "avopjson", "avpct", "averlpqt", "avpreett", "avpingkt", "avpsct", "avPcmd", "avopkt", "avpadwk", "aveopett", "vrparpt", "avopett", "aveopjson", "verpett", "averpingkt", "evwpct", "avpqt", " avpett", "avpcacket", "avppwd", "ahpkt", "evwpet", "avprewk", "vernpacket", "avPwk", "avtpkt", "ahpackett", "avepct", "avparwd", "avwpet", "avcpkt", "avpaykt", "vrparkg", "vrparkt", "avepcct", " avcpett", "avmett", "avnpkt", "avepwk", "avppett", "avparkt", "avpadkg", "vrtipwk", "avepkt", "avpcmd", "avepet", "verpkt", " avcpkt", "avPkt", "verpacket", "avmkt", "avpingett"], "it": ["j", "id", "ul", "try", "op", "jit", "ut", "git", "format", "which", "p", " wait", "ent", "g", "init", "n", "after", "ic", "r", "iter", "out", "set", "act", "i", "bit", "It", "lit", "at", "we", "mit", "att", " i", "its", "ex", "ta", "ait", "opt", "ip", "ist", "al", "im", "ie", "quit", "iz", "wait", "ort", "you", "IT", "and", "ind", "ect", " t", "or", " total", "what", "nt", "ct", "unit", "ot", "hit", "timeout", "t", "exec", "ate"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 2880, "substitutes": {}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "void disas_a64_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t insn;\n\n\n\n    insn = arm_ldl_code(env, s->pc, s->bswap_code);\n\n    s->insn = insn;\n\n    s->pc += 4;\n\n\n\n    switch ((insn >> 24) & 0x1f) {\n\n    default:\n\n        unallocated_encoding(s);\n\n        break;\n\n    }\n\n\n\n    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {\n\n        /* go through the main loop for single step */\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n", "idx": 2884, "substitutes": {"env": ["ec", "pres", "er", "buf", "code", "nc", "sh", "sv", "conn", "org", "ev", "window", "vs", "server", "dem", "vt", "viron", "environment", "esc", "vp", "ef", "config", "shell", "end", "conf", "cap", "context", "w", "e", "setup", "en", "cv", "ctx", "v", "h", "te", "estate", "esm", "mem", "obj", "map"], "s": ["sys", "ls", "j", "S", "q", "stats", "c", "sg", "is", "sv", "ss", "p", "es", "als", "settings", "n", "g", "sl", "stat", "vs", "session", "server", "service", "ses", "ess", "comm", "ds", "qs", "set", "utils", "i", "b", "fs", "store", "aws", "services", "ps", "js", "ns", "bs", "sw", "scope", "ims", "bis", "e", "sam", "ports", "cs", "ts", "spec", "changes", "hs", "sts", "rs", "v", "h", "pers", "gs", "source", "ats", "sb", "ins", "sq", "os", "args", "t", "serv", "self", "sp"], "insn": ["ingn", "Inssn", " inssn", "insgn", "psns", "ainsgn", "risner", "Insn", "ainssn", "insner", "ainsn", "linsns", "inn", "insns", "risen", "linssn", "linsgn", " inscn", "linsn", "Inscn", "pscn", "ainsen", "ainsner", "risn", "rissn", "Insen", " insgn", "psn", "inssn", "incn", "insen", "Insner", "itsn", "itssn", "Insns", "inscn", "linscn", "itsgn", "itsns", "psgn", "pssn"]}}
{"project": "qemu", "commit_id": "96d7073fb058e6f05257cd9041ffbbd736f6ccec", "target": 0, "func": "static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            goto std_case;\n\n        } else {\n\n            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);\n\n            tcg_gen_ext8u_tl(t0, t0);\n\n        }\n\n        break;\n\n    default:\n\n    std_case:\n\n        tcg_gen_mov_tl(t0, cpu_regs[reg]);\n\n        break;\n\n    }\n\n}\n", "idx": 2895, "substitutes": {"ot": ["oid", "net", "et", " tot", "op", "hot", "ut", "tt", "ote", "ent", "ots", "ic", "iet", "lt", "ox", "iot", "cot", "gt", "at", "oc", "y", "rot", "ant", "ota", "ort", "rt", "pt", "or", "ott", "mot", "nt", "pot", "ct", "oot", "iat", "t", "OT"], "t0": ["p1", "td000", "m0", " t8", "t6", "dt0", " T0", "pk", "tk", " tk", " t150", "time0", " T1", " T2", "m1", "tt2", " tnew", "t1", "td6", "timenew", "t5", " t512", "td512", "tree6", " t000", "td0", "p5", "t512", "tree0", "p0", "t2", " t6", "m5", "t8", "tnew", "time000", "m8", "tdnew", "t000", " t1", "dt1", "dt150", "tt0", " t2", "p8", "t150", "p150", "dtk", "tt1", "tree512", " t5"], "reg": ["br", "REG", "net", "key", "Reg", "code", "addr", "rest", "sec", "org", "g", "row", "rid", "ref", "r", "index", "rank", "leg", "act", "res", "num", "eg", "ord", "mod", "mem", "req", "tag", "ig", "cell", "block", "desc", "err", "rec", "round", "gc", "ind", "region", "loc", "rm", "nt", "brand", "ret", "rem", "rc", "state", "re", "eng", "typ"]}}
{"project": "qemu", "commit_id": "54421cb17bc744bad15f2b1adb4adefdaea83c10", "target": 0, "func": "static int hdev_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int access_flags, create_flags;\n\n    DWORD overlapped;\n\n    char device_name[64];\n\n\n\n    if (strstart(filename, \"/dev/cdrom\", NULL)) {\n\n        if (find_cdrom(device_name, sizeof(device_name)) < 0)\n\n            return -ENOENT;\n\n        filename = device_name;\n\n    } else {\n\n        /* transform drive letters into device name */\n\n        if (((filename[0] >= 'a' && filename[0] <= 'z') ||\n\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n\n            filename[1] == ':' && filename[2] == '\\0') {\n\n            snprintf(device_name, sizeof(device_name), \"\\\\\\\\.\\\\%c:\", filename[0]);\n\n            filename = device_name;\n\n        }\n\n    }\n\n    s->type = find_device_type(bs, filename);\n\n    \n\n    if ((flags & BDRV_O_ACCESS) == O_RDWR) {\n\n        access_flags = GENERIC_READ | GENERIC_WRITE;\n\n    } else {\n\n        access_flags = GENERIC_READ;\n\n    }\n\n    create_flags = OPEN_EXISTING;\n\n\n\n#ifdef QEMU_TOOL\n\n    overlapped = FILE_ATTRIBUTE_NORMAL;\n\n#else\n\n    overlapped = FILE_FLAG_OVERLAPPED;\n\n#endif\n\n    s->hfile = CreateFile(filename, access_flags, \n\n                          FILE_SHARE_READ, NULL,\n\n                          create_flags, overlapped, NULL);\n\n    if (s->hfile == INVALID_HANDLE_VALUE) \n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 2903, "substitutes": {"bs": ["ls", "cks", "bc", "bh", "bd", "bm", "es", "vs", "bp", "ds", "b", "ubs", "fs", "lbs", "BS", "obs", "ps", "its", "bb", "bos", "ns", "js", "aos", "bt", "bi", "bis", "ms", "cs", "ts", "bes", "bps", "rs", "bl", "bits", "blog", "gs", "sb", "bn", "bf", "os", "ubis"], "filename": ["ames", "NAME", "ilers", "handle", "unc", "ename", "ammy", "ren", "n", "rather", "nil", "path", "knife", "println", "username", "there", "uri", "png", "f", "fn", "rn", "fd", "fp", "FIL", "LCS", "whatever", "source", "result", "names", "mpeg", "where", "family", "tp", "location", "final", "file", "name", "ln", "FN", "without", "wit", "position", "json", "forth", "kan", "directory", "nl", "files", "description", "fle", "kj", "ame", "their", "title", "subject", "nm", "nature", "til", "sbm", "prefix", "unction", "journal", "fil", "wcs", "status", "wire", "txt", "label", "dump", "they", "assets", "archive", "metadata", "doi", "Filename", "original", "latest", "jpg", "wikipedia"], "flags": ["atts", "acts", "sets", "actions", "settings", "names", "details", "weights", "options", "Flags", "utils", "ants", "vals", "ids", "locks", "fields", "members", "heads", "ensions", "features", "tags", "planes", "lag", "comments", "fps", "ports", "levels", "pins", "ts", "events", "types", "ags", "styles", "properties", "olds", "bits", "states", "flag", "args", "reports", "FLAG", "ops"], "s": ["sys", "ls", "j", "S", "sis", "stats", "status", "is", "sv", "ss", "p", "als", "g", "n", "ses", "ds", "qs", "b", "locks", "fs", "less", "gets", "uns", "ps", "its", "js", "ns", "bis", "ms", "ts", "cs", "sports", "ies", "bes", "sts", "v", "rs", "h", "gs", "sb", "ats", "ins", "t", "acs", "ssl", "self", "sn"], "access_flags": ["usage_details", " access_notes", " access_lines", "access_rates", "accessionflags", " access2settings", " access_locks", "accessuresettings", "access_locks", "access2locks", "usage_flags", "accessiondetails", "usage_posts", "access_settings", " access_mask", "access2flag", " access_flag", "access_flag", "access_posts", "access2mask", "access2details", " access_rates", "accessionrules", "accessionposts", "usageiondetails", "usageionposts", "access_mask", "usage_rules", "access2settings", "access2notes", " access_details", " access2details", " access_settings", "access2flags", "access_lines", "usageionrules", " access2notes", " access2flags", "usageionflags", "accessureflags", "access_details", "access_properties", "accessuredetails", "access_notes", " access_properties", "accessurenotes", "access_rules"], "create_flags": ["create2flag", "create_lines", " create_links", "create_fields", "create2lines", " create_flag", "create_files", "create_details", "create_links", "create2flags", " create_files", " create_lines", "create2details", " create_details", "create_flag", " create_type", " create_fields", "create_type"], "overlapped": ["overLapped", "overlcapped", "overlapping", " overlaps", "overlcaped", "overlcAPS", "Overklapped", "overloded", "overLapping", "overflAPS", "overLaped", "Overlaped", "overLashed", " overlapping", "overliapped", "overvaps", "overflaped", " Overlapped", "overliaps", "overlaps", " Overlcaped", "overklaped", "overlaped", " overlaped", "Overklashed", "Overlashed", "overlAPS", " Overlapping", "overlitapping", "overlcoded", "overliashed", "Overlcaped", " Overlaped", "overflapping", "overliapping", "overmapped", "Overlaps", "overklapping", "overvaped", " overLaped", " overLaps", "overvapped", "overmapping", "overflapped", " OverlcAPS", "Overklaps", "overmaped", "overklapped", "overlitapped", " overLapped", "overkloded", "overklaps", "Overlcapped", "overlcapping", "overlitaped", " OverlAPS", "Overklapping", "overvapping", "overLaps", "Overlcapping", "Overloded", "Overlapped", "overmAPS", " Overlcapped", "overlashed", "overflaps", "Overlcoded", "overlitoded", "overklashed", "Overlapping", " Overlcapping", " overLapping"], "device_name": ["device_info", "volume_name", "module_default", "device_parent", "device_admin", "dev_info", "storelyadmin", "devicelyfile", " device_path", "volume_list", "storelystring", "object_data", "deviceNamefile", "store_name", "objectlydata", "device_link", "device_path", "media_name", "deviceNametree", "deviceNamename", " device_file", "device_default", "devicelyname", "devicelydata", "device_file", "volume_file", "store_admin", "storelyname", "devicelystring", "device_string", "devicelyinfo", "device_id", "device_nm", "device_tree", "media_info", "deviceNamelink", "volume_class", "deviceNameno", "device_class", "objectlyfile", "media_parent", "media_link", "dev_name", "devicelyno", "medialyparent", "devicelyorder", "medialylink", "module_name", "devicelyparent", "device_data", "store_order", "device_list", "device_no", "dev_id", "object_file", "module_link", "module_tree", "dev_nm", "devicelylink", "deviceNamedefault", "device_order", "devicelyadmin", "medialyinfo", "storelyorder", "objectlyname", "deviceNamedata", "object_no", "object_name", "store_string", "objectlyno", "medialyname"]}}
{"project": "qemu", "commit_id": "62deb62d999cf9e2be61272c6b720104f764bd6a", "target": 0, "func": "static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (!s390_has_feat(S390_FEAT_VECTOR)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);\n\n        return;\n\n    }\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    /* parameter must be aligned to 1024-byte boundary */\n\n    if (si->param & 0x3ff) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (kvm_s390_store_adtl_status(cpu, si->param)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 2911, "substitutes": {"cs": ["sys", "ls", "cp", "wcs", "cas", "c", "pc", "cks", "is", "ss", "es", "css", "ics", "cus", "s", "ci", "ds", "fs", "sc", "ps", "its", "js", "ns", "bs", "ms", "ts", "ctx", "ces", "hs", "sts", "rs", "cc", "CS", "gs", "ck", "ys", "acs"], "arg": ["data", "j", "arm", "ma", "match", "ay", "aj", "sec", "g", "from", "app", "Arg", "ax", "sa", "i", "msg", "info", "def", "ary", " args", " argument", "att", "config", "ig", "conf", "param", "w", "as", "spec", "ag", "ar", "or", "reg", "argument", "v", "in", "arp", "event", "ai", "args", "ad", "ac", "cmd"], "cpu": ["proc", "core", "sys", "cp", "net", "device", "phys", "c", "pc", "nc", "cn", "p", "pu", "cus", "hw", "gpu", "CPU", "processor", "phy", "pixel", "cli", "us", "linux", "sc", "tp", "mu", "vm", "cum", "ilo", "ctx", "aco", "gc", "pkg", "mac", "clock", "cu", "uu", "process", "du", "sky", "ck", "pro"], "si": ["sis", "ni", "Si", "ati", "ii", "ki", "ji", "xi", "ski", "pi", "asi", "qi", "ci", "sa", "sie", "ami", "ei", "eni", "i", "ali", "ui", "info", "gi", "esi", "vi", "ij", "fi", "gu", "oi", "bi", "iu", "ti", "ity", "ia", "zi", " ni", "mi", "di", "ini", "ai", "isi", "SI", "ri", "yi", "sci"]}}
{"project": "qemu", "commit_id": "ff1d1977ffe1c276f5937a6ad4b6a5b6d2b1c6ae", "target": 0, "func": "static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = ldtul_p(mem_buf);\n\n\n\n    if (n < 32) {\n\n        env->active_tc.gpr[n] = tmp;\n\n        return sizeof(target_ulong);\n\n    }\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)\n\n            && n >= 38 && n < 73) {\n\n        if (n < 70) {\n\n            if (env->CP0_Status & (1 << CP0St_FR))\n\n              env->active_fpu.fpr[n - 38].d = tmp;\n\n            else\n\n              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;\n\n        }\n\n        switch (n) {\n\n        case 70:\n\n            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;\n\n            /* set rounding mode */\n\n            RESTORE_ROUNDING_MODE;\n\n#ifndef CONFIG_SOFTFLOAT\n\n            /* no floating point exception for native float */\n\n            SET_FP_ENABLE(env->active_fpu.fcr31, 0);\n\n#endif\n\n            break;\n\n        case 71: env->active_fpu.fcr0 = tmp; break;\n\n        }\n\n        return sizeof(target_ulong);\n\n    }\n\n    switch (n) {\n\n    case 32: env->CP0_Status = tmp; break;\n\n    case 33: env->active_tc.LO[0] = tmp; break;\n\n    case 34: env->active_tc.HI[0] = tmp; break;\n\n    case 35: env->CP0_BadVAddr = tmp; break;\n\n    case 36: env->CP0_Cause = tmp; break;\n\n    case 37: env->active_tc.PC = tmp; break;\n\n    case 72: /* fp, ignored */ break;\n\n    default: \n\n\tif (n > 89)\n\n\t    return 0;\n\n\t/* Other registers are readonly.  Ignore writes.  */\n\n\tbreak;\n\n    }\n\n\n\n    return sizeof(target_ulong);\n\n}\n", "idx": 2913, "substitutes": {"env": ["eas", "ext", "ent", "ev", "window", "server", "ner", "email", "req", "ef", "conf", "vm", "vv", "context", "here", "equ", "manager", "ten", "console", "te", "enter", "estate", "eng", "era", "ec", "net", "test", "operator", "ener", "vs", "erb", "viron", "environment", "esc", "msg", "end", "ew", "door", "uv", "enc", "tern", "er", "gear", "buf", "addr", "code", "eh", "actor", "ah", "engine", "ei", "eni", "etc", "cur", "network", "dev", "el", "en", "ctx", "stage", "db", "v", "client", "oe", "erd", "ve", "rc", "worker", "cmd", "Environment", "doc", "et", "eb", "conn", "org", "erv", "query", "nv", "em", "extra", "param", "desc", "e", "event", "ee", "obj"], "mem_buf": ["memory_buff", "memvuf", "mem2buf", "mem2uf", "mem_uf", "mem_bl", "memory_uf", "memvbuffer", "mem_buff", "memory_buf", "memvbuf", "memory_bl", "mem_buffer", "memory_buffer", "mem2buffer", "memvbl", "mem2bl"], "n": ["gn", "d", "j", "number", "net", "l", "nr", "c", "count", "nc", "no", "non", "cn", "N", "p", "z", "nl", "g", "ren", "all", "conn", "after", "names", "np", "next", "index", "ng", "node", "m", "i", "x", "num", "ne", "nw", "new", "nan", "network", "ns", "t", "note", "y", "e", "en", "name", "tn", "ln", "nm", "un", "an", "v", "on", "nt", "o", "h", "nu", "dn", "nn", "na", "fn", "nor", "nb", "len", "sn"], "tmp": ["cp", "mint", "mb", "p", "out", "td", "html", " resp", "gt", " np", "ann", "pkg", "ret", "resp", "MP", "test", " sp", "result", "np", "pb", "cb", "rb", "m", "msg", "tab", "cmp", "perm", "ptr", "mk", "sam", "mm", " ob", "nt", "expr", "trap", "uf", "buf", "slice", "mp", "vt", "amp", "new", "etc", "cur", "cache", "snap", "tf", "ctx", "tn", "nm", "v", "src", "prefix", "cmd", "sp", "proc", "data", "temp", "prop", "managed", "tg", "tt", "up", "img", "attr", "txt", "emp", "table", " tcp", "rw", "orig", "tm", "tar", "cv", "copy", "rt", " out", "t", "obj", "buff"]}}
{"project": "qemu", "commit_id": "3ba235a02284c39b34a68a2a588508ffb52a7b55", "target": 0, "func": "QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_malloc0(sizeof(QEMUBH));\n\n    bh->ctx = ctx;\n\n    bh->cb = cb;\n\n    bh->opaque = opaque;\n\n    qemu_mutex_lock(&ctx->bh_lock);\n\n    bh->next = ctx->first_bh;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_mutex_unlock(&ctx->bh_lock);\n\n    return bh;\n\n}\n", "idx": 2914, "substitutes": {"ctx": ["cp", "ctr", "tmp", "p", "hw", "window", "pg", "sc", "req", "qu", "conf", "cf", "context", "xp", "ann", "pkg", "ind", "Context", "resp", "timeout", "ctrl", "acl", "bc", "soc", "np", "xs", "act", "kt", "seq", "cmp", "voc", "pat", "mk", "aco", "co", "gc", "loc", "nt", "inst", "aux", "jp", "buf", "addr", "nc", "dc", "comm", "info", "etc", "ns", "tc", "that", "pool", "anc", "go", "pt", "src", "rc", "exec", "cmd", "proc", "sys", "doc", "fc", "xc", "conn", "org", "ca", "txt", "cfg", "tx", "pos", "scope", "config", "desc", "cv", "via", "cu", "cc", "ct", "cl", "iat", "obj"], "cb": ["fp", "cp", "ctrl", "cod", "fc", "cd", "CB", "func", "buf", "c", "bc", "nc", "xb", "cn", "unc", "conn", "kb", "erb", "pb", "bp", "cfg", "rb", "b", "lb", "gb", "etc", "cmp", "job", "bb", "bt", "conf", "kw", "cf", "cv", "tc", "callback", "bg", "ob", "gc", "wb", "nob", "fb", "cu", "cc", "sb", "fn", "bf", "ck", "nb", "obj", "cmd"], "opaque": ["iopus", "oppaques", "ipque", "obaques", "ipca", "iopca", "operaque", "ipus", "peus", "opca", "operca", "obois", "peaque", "ipulence", "opois", "oppulence", "opacity", "ipois", "peca", "operois", "operacity", "obulence", "opque", "iopaque", "ipaque", "oppque", "opaques", "obca", "obacity", "iopacity", "ipaques", "opus", "obque", "peacity", "oppaque", "ipacity", "opulence", "obaque"], "bh": [" inh", "bec", "ach", "kh", "hr", "ash", "rob", " bl", "bp", "hh", " blo", "ih", "hub", " shr", "pas", "hal", "bo", "body", "hz", "hab", " ph", "h", "sb", "ht", " bi", "mr", "bel", "br", "oth", "batch", "zh", "bor", "bd", "pb", "np", "rb", "phy", "bs", "bis", "bg", "loc", "bn", "th", "rel", "nb", " Bh", "jp", "buf", " eh", " HB", "bm", "phi", "hap", "hl", "hd", "hi", "go", "sbm", "bf", "ssl", "eth", "BP", " ah", "bj", "attach", "sh", " dh", "orth", "hold", "b", "lb", "dh", "bol", " hp", "bb", "bt", "binding", "rh", "abb", " rh", "igh", "bl", " uh", "bsp"]}}
{"project": "FFmpeg", "commit_id": "37013fd018ae02679f177f42245f3e0e3c12d587", "target": 0, "func": "static void audiogen(void *data, enum AVSampleFormat sample_fmt,\n\n                     int channels, int sample_rate, int nb_samples)\n\n{\n\n    int i, ch, k;\n\n    double v, f, a, ampa;\n\n    double tabf1[SWR_CH_MAX];\n\n    double tabf2[SWR_CH_MAX];\n\n    double taba[SWR_CH_MAX];\n\n    unsigned static rnd;\n\n\n\n#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);\n\n#define uint_rand(x) (x = x * 1664525 + 1013904223)\n\n#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)\n\n    k = 0;\n\n\n\n    /* 1 second of single freq sinus at 1000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        a += M_PI * 1000.0 * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 1 second of varying frequency between 100 and 10000 Hz */\n\n    a = 0;\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        v = sin(a) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n        f  = 100.0 + (((10000.0 - 100.0) * i) / sample_rate);\n\n        a += M_PI * f * 2.0 / sample_rate;\n\n    }\n\n\n\n    /* 0.5 second of low amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 0.5 second of high amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd);\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 1 second of unrelated ramps for each channel */\n\n    for (ch = 0; ch < channels; ch++) {\n\n        taba[ch]  = 0;\n\n        tabf1[ch] = 100 + uint_rand(rnd) % 5000;\n\n        tabf2[ch] = 100 + uint_rand(rnd) % 5000;\n\n    }\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            v = sin(taba[ch]) * 0.30;\n\n            PUT_SAMPLE\n\n            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);\n\n            taba[ch] += M_PI * f * 2.0 / sample_rate;\n\n        }\n\n    }\n\n\n\n    /* 2 seconds of 500 Hz with varying volume */\n\n    a    = 0;\n\n    ampa = 0;\n\n    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            double amp = (1.0 + sin(ampa)) * 0.15;\n\n            if (ch & 1)\n\n                amp = 0.30 - amp;\n\n            v = sin(a) * amp;\n\n            PUT_SAMPLE\n\n            a    += M_PI * 500.0 * 2.0 / sample_rate;\n\n            ampa += M_PI *  2.0 / sample_rate;\n\n        }\n\n    }\n\n}\n", "idx": 2929, "substitutes": {"data": ["d", "Data", "input", "batch", "image", "device", "DATA", "sample", "window", "r", "memory", "dat", "m", "x", "xy", "block", "buffer", "array", "ata", "bytes", "channel", "results", "t", "mem", "map"], "sample_fmt": ["sample__mlt", "sample__mtm", "sample_hmt", "sample__flt", "sample_ftm", "sample_fms", "sample_mms", "sample__mms", "sample_hms", "sample__fms", "sample_mmt", "sample__mmt", "sample_mlt", "sample_hlt", "sample_flt", "sample__ftm", "sample_htm", "sample__fmt", "sample_mtm"], "channels": ["chairs", "choannels", "choats", "echines", "chapters", "chnusters", "echapters", "capters", "acholics", "chounks", " chars", "chources", "chnases", "echunks", "chines", "chars", "echolics", "quases", "chayers", "echairs", "achunks", "chnunks", "quapters", " chines", "cairs", "achapters", "compayers", "quines", "quannels", "chnines", "comproups", "echannels", "achannels", "compunks", "chusters", "achayers", "chats", "achources", "quats", "chnars", " chunks", "chases", "chnannels", "achats", "echars", "compannels", "chroups", "chunks", "achines", "chnayers", "echusters", "achairs", " chases", " chources", "cannels", "chnroups", "achroups", "choapters", "achusters", "cholics", "colics", "echources", "achars", "quunks"], "sample_rate": ["samplemmrate", "ample2rate", "ample2rates", "sampleationcounter", "ample_rates", " sample_force", "Sample_rates", "sample2rates", " sample_process", "sampleletrates", "sampleationmode", "ample2speed", "ample_rate", "sample_length", "versionationcounter", "sample0speed", "sample00rate", "versionationmode", "sample5rating", "sample_mode", "sampleablerate", "sample_rating", "sample_frequency", "version_counter", "sample_range", "sampleabletime", "sampleletcounter", "Sample_range", "samplemmmonitor", "ample2frequency", "sample00process", "sample0frequency", "sample_monitor", "sample_process", "sampleletprocess", " sample_stream", "sample2speed", "sampleletrate", " sample_rating", " sample_range", "sample2Rate", "sample0rates", " sample_Rate", "sampleableradius", "sampleationmonitor", "sample_rat", " sample_rates", "samplemmmode", " sample_length", "versionationrate", "Sample_time", "sample_rates", "samplemmcounter", "sample_force", "sample_stream", "versionationmonitor", "sample2rate", "sample0rate", "ample_speed", " sample_time", " sample_rat", "sample_counter", "sample5rat", "sample5time", "sample2frequency", "version_rate", "version_mode", "sample_Rate", "sample_speed", "sample_time", "sample00rates", "sampleableforce", "sample00counter", " sample_counter", "version_monitor", "sample5rate", "sampleationrate", " sample_radius", "ample_frequency", " sample_frequency", "sample2range", "sample_radius", "Sample_rate"], "nb_samples": ["nb_statsamples", "nb_Sforms", "nb_sannels", "nb___sikes", "nbitssamplays", "nb_damples", "nb_seamps", "nbitssamples", "nb_Sannels", "nb_testsamps", "nb_isourses", "nb_testsforms", "nb___samps", "nbitssamamps", "nb_spamps", "nb_seizes", "nb_Sactions", "nb_spamples", "nb_samps", "nb_Sales", "nb_spensions", "nb_statsourses", "nb___samamples", "nb_splays", "nb_Sikes", "nb_isannels", "nb_seamples", "nbitssamactions", "nb_sikes", "nb_samamples", "nb___samamps", "nb_dales", "nb_Samples", "nb_testsamples", "nbitssactions", "nb_Splays", "nb_contourses", "nb_seales", "nb_sforms", "nb___samikes", "nb_samensions", "nbitssamps", "nb_sales", "nb_statsforms", "nb_samplays", "nb_sourses", "nb_sizes", "nb_sactions", "nb_isamples", "nb_shplays", "nb_samactions", "nb___sensions", "nb_samamps", "nb___samples", "nb_Sourses", "nb_shactions", "nb_Sizes", "nb___samensions", "nb_contannels", "nb_statsamps", "nb_sensions", "nb_samikes", "nbitssplays", "nb_dizes", "nb_shamples", "nb_Sensions", "nb_damps", "nb_testsourses", "nb_isamps", "nb_contamples", "nbitssamamples", "nb_spikes", "nb_contamps", "nb_shamps", "nb_Samps"], "i": ["id", "c", "p", "n", "init", "ish", "li", "iii", "x", "II", "us", "iu", "ti", "ind", "ix", "zi", "h", "ini", "by", "I", "ik", "this", "xi", "ic", "qi", "m", "ui", "it", "at", "ex", "ims", "im", "io", "mm", "\u0438", "ri", "chain", "j", "ii", "er", "ji", "pi", "index", "me", "ci", "ei", "phi", "ij", "fi", " ii", "y", "bi", "hi", "mi", "di", "ai", "si", "multi", "ki", "is", "ami", "b", "cli", "gi", "ip", "ie", "ia", "in", "o"], "ch": ["vc", "cp", "try", "c", "ach", "height", "cho", "kh", "x", "form", "sk", "sc", "ih", "qu", "can", "cs", "ver", "con", "ix", "ry", "channel", "h", "sky", "ot", "chid", "ht", "batch", "br", "q", "zh", "high", "count", "bc", "CH", "ic", "cb", "m", "cht", "cell", "chrom", "mk", "chan", "och", "cm", "th", "gh", "chain", "z", "chip", "tch", "atch", "sch", "att", "history", "chn", "y", "hl", "bi", "go", "pt", "client", "col", "ble", "arch", "ph", "cha", "sh", "che", "ca", "wh", "ech", "uch", "chron", "Ch", "pl", "chart", "cl", "ich"], "k": ["ko", "ka", "j", "q", "key", "kan", "ki", "c", "tk", "km", "ke", "kh", "kg", "p", "n", "dk", "uk", "kj", "kl", "kk", "kind", "m", "x", "ijk", "kt", "sk", "unk", "ku", "ok", "sch", "ask", "ack", "kr", "kw", "mk", "ikk", "kn", "ks", "kick", "ek", "ia", "K", "max", "wk", "ik", "ck", "kid", "mc", "ak"], "v": ["vc", "j", "q", "l", "vo", "c", "V", "value", "vr", "sv", "qv", "p", "conv", "g", "vs", "r", "vt", "m", "var", "b", "x", "u", "nv", "va", "vp", "vi", "tv", "lv", "y", "vm", "version", "vv", "w", "cv", "ver", "h", "uv", "o", "ve", "t"], "f": ["fp", "d", "j", "q", "fc", "ff", "l", "c", "z", "p", "g", "fa", "r", "fac", "sf", "m", "b", "x", "u", "fs", "af", "at", "tf", "ef", "fi", "y", "cf", "w", "e", "fe", "fr", "F", "fb", "h", "bf", "t", "fm", "uf", "fo", "fd"], "a": ["j", "ma", "sta", "aw", "c", "A", "ach", "aaa", "aj", "p", "all", "to", "fa", "la", "ca", "ab", "aa", "app", "r", "ao", "sa", "xa", "out", "wa", "act", "m", "b", "x", "u", "af", "va", "ava", "au", "at", "att", "ta", "y", "pa", "al", "w", "ap", "as", "ae", "ea", "area", "ba", "ar", "an", "am", "ia", "ata", "alpha", "o", "h", "ai", "na", "ac", "t", "ak", "apa"], "ampa": ["ko", "acc", "ka", "xff", "key", "result", "uk", "aa", "pi", "kk", "ao", "sa", "mp", "xa", "au", "ij", "ta", "pa", "um", "cv", "ap", "gc", "ba", "ek", "ia", "am", "loop", "ai", "ac", "jj"], "tabf1": [" tabv5", "tabc3", " tabsf64", "tabc1", " tabf3", "tabf5", " tabv2", "tabb3", "tabb5", " tabf8", "tabf64", " tabsf3", "tabc01", " tabf64", " tabsf01", "tabsf01", " tabf5", "tabb2", "tabb64", "tabv5", "tabv1", " tabv8", "tabf8", "tabf01", "tabsf1", "tabsf64", "tabf3", "tabv8", "tabc64", "tabb8", " tabf01", " tabsf1", "tabv2", " tabv1", "tabb01", "tabsf3", "tabb1"], "tabf2": ["tabc3", " tabv0", " tabf3", " tabv2", " tabv256", "tabuf0", "tabf0", "tabv0", "tabuf3", " tabv3", "tabuf256", "tabv3", "tabf256", "tabc0", " tabf256", " tabf0", "tabc2", "tabf3", "tabv2", "tabc256", "tabuf2", "tabv256"], "taba": ["libA", "listea", "Tabao", "listb", "ctb", "tabea", "cta", "ctaa", "trackea", "tabA", "libaa", "lista", "Taba", "ctA", "liba", "tabb", "tabaa", "Tabea", "trackb", "TabA", "libb", "trackao", "tabao", "tracka", "listao", "Tabb", "Tabaa"], "rnd": ["rng", "mrng", "rmd", "rdnt", "mrrd", "rdd", "rrd", "nrng", "mrmd", "rrdd", " rdd", "rdng", "rdgd", "rgd", "nrmd", " rgd", "mrgd", " rrd", " rnt", "mrnd", "mrdd", "mrnt", "rnt", "rrng", "rrnd", "rdnd", " rmd", " rng", "nrnd", "nrrd"]}}
{"project": "FFmpeg", "commit_id": "ea97859c8c218b83ab747a7eabcb88ca446f6751", "target": 1, "func": "static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)\n\n{\n\n    CURSORINFO ci = {0};\n\n\n\n#define CURSOR_ERROR(str)                 \\\n\n    if (!gdigrab->cursor_error_printed) {       \\\n\n        WIN32_API_ERROR(str);             \\\n\n        gdigrab->cursor_error_printed = 1;      \\\n\n    }\n\n\n\n    ci.cbSize = sizeof(ci);\n\n\n\n    if (GetCursorInfo(&ci)) {\n\n        HCURSOR icon = CopyCursor(ci.hCursor);\n\n        ICONINFO info;\n\n        POINT pos;\n\n        RECT clip_rect = gdigrab->clip_rect;\n\n        HWND hwnd = gdigrab->hwnd;\n\n        info.hbmMask = NULL;\n\n        info.hbmColor = NULL;\n\n\n\n        if (ci.flags != CURSOR_SHOWING)\n\n            return;\n\n\n\n        if (!icon) {\n\n            /* Use the standard arrow cursor as a fallback.\n\n             * You'll probably only hit this in Wine, which can't fetch\n\n             * the current system cursor. */\n\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n\n        }\n\n\n\n        if (!GetIconInfo(icon, &info)) {\n\n            CURSOR_ERROR(\"Could not get icon info\");\n\n            goto icon_error;\n\n        }\n\n\n\n        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;\n\n        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;\n\n\n\n        if (hwnd) {\n\n            RECT rect;\n\n\n\n            if (GetWindowRect(hwnd, &rect)) {\n\n                pos.x -= rect.left;\n\n                pos.y -= rect.top;\n\n            } else {\n\n                CURSOR_ERROR(\"Couldn't get window rectangle\");\n\n                goto icon_error;\n\n            }\n\n        }\n\n\n\n        av_log(s1, AV_LOG_DEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\",\n\n                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);\n\n\n\n        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&\n\n                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {\n\n            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))\n\n                CURSOR_ERROR(\"Couldn't draw icon\");\n\n        }\n\n\n\nicon_error:\n\n\n\n\n\n        if (icon)\n\n            DestroyCursor(icon);\n\n    } else {\n\n        CURSOR_ERROR(\"Couldn't get cursor info\");\n\n    }\n\n}", "idx": 2946, "substitutes": {"s1": [" s3", "fs2", "fs4", "s3", " s0", "c3", "fs6", "s4", " s2", " s4", "c2", "h3", "fs1", "h1", "s0", "h2", "c0", "h0", " s6", "c1", "s2", "s6"], "gdigrab": ["mdigrad", "gradigrap", "gdircAb", "gdrogub", "gdrogAb", "ddgrab", "gdigrib", "gdgrab", "gdibrabb", "gradibrap", "gdigmap", "gdrogib", "gdigorap", "mdigab", "gdigrub", "gdigmib", "gdigrap", "gdrigabulary", "gradigrab", "GDigrab", "gdigorab", "gdigrabb", "gdrigAB", "mdigrib", "gdibrap", "gradibrib", "gdgrub", "ddigorob", "mdigad", "gdgrabb", "gdrogAB", "GDrigAB", "gdibrad", "mdigrab", "gdigorad", "gdgrib", "gdigorlab", "ddigrub", "ddgrib", "ddigrabb", "gdibrib", "ddgrabb", "gdigmab", "gdigob", "gdigad", "gdigorob", "gdrigab", "ddigrab", "mdigrub", "gdigorib", "gdigrAb", "ddigorab", "gdigrob", "ddigorib", "gdigub", "gradigrlab", "gdibrub", "gdircabulary", "gdigrlab", "GDrigAb", "mdigib", "gradibrlab", "gdigorub", "gdircab", "gdrogabb", "gdigrad", "gdigab", "gdigrabulary", "gradibrab", "GDrigab", "gdigrAB", "gdrogabulary", "gdircAB", "ddigorub", "gdigib", "ddigrib", "GDrigabulary", "GDigrabulary", "GDigrAb", "ddgrub", "mdigub", "gradigrib", "gdrogab", "gdibrlab", "gdigmlab", "gdibrob", "gdrigAb", "ddigrob", "GDigrAB", "gdibrab"], "info": ["success", "data", "image", "id", "user", "inner", "key", "ki", "ii", "status", "list", "information", "no", "is", "Info", "stat", "meta", "init", "inf", "row", "index", "ico", "pi", "details", "important", "ci", "isu", "res", "i", "icon", "ui", "none", "cache", "it", "notice", "def", "check", "history", "iso", "config", "note", "fi", "ip", "conf", "error", "hi", "ti", "ion", "INFO", "co", "io", " INFO", "good", "o", "help", "si", "f", "os", "about", "state", "json", "auth", "fo"], "pos": ["parent", "tmp", "op", "port", " position", "p", "init", "out", "set", "x", "form", "off", "mit", "conf", "cond", "spec", "comp", "bo", "yes", "os", "resp", "pres", "meta", "coord", "act", "lat", "it", "mod", "xy", "location", "tag", "trans", "rot", "co", "Pos", "loc", "offset", "apo", "position", "obj", "slot", "to", "ref", "neg", "pi", "index", "patch", "go", "pt", "val", " po", "client", "pan", "pid", "point", "top", "doc", "add", "po", "prop", "pc", "no", "POS", "def", "local", "px", "origin", "post", " POS", "mat", "o", "zone", "state", "pose", "pro"], "rect": ["dial", "br", "rad", "addr", "vr", "port", "dict", "row", "tip", "attr", "dir", "r", "tri", "box", "txt", "path", "coord", "act", "res", "lat", "ra", "cont", "mod", "type", "Rect", "ex", "tar", "RECT", "dom", "block", "rot", "desc", "ptr", "err", "color", "nav", "ctx", "round", "ect", "rt", "bo", "region", "reg", "loc", "ror", "pt", "client", "cl", "col", "pair", "tr", "rel", "feat", "obj", "area", "map"]}}
{"project": "qemu", "commit_id": "75cc7f018328e708d94cca23c3a77e85363f25dc", "target": 1, "func": "static void machine_initfn(Object *obj)\n\n{\n\n    MachineState *ms = MACHINE(obj);\n\n\n\n    ms->kernel_irqchip_allowed = true;\n\n    ms->kvm_shadow_mem = -1;\n\n    ms->dump_guest_core = true;\n\n\n\n\n    object_property_add_str(obj, \"accel\",\n\n                            machine_get_accel, machine_set_accel, NULL);\n\n    object_property_set_description(obj, \"accel\",\n\n                                    \"Accelerator list\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"kernel-irqchip\",\n\n                             NULL,\n\n                             machine_set_kernel_irqchip,\n\n                             NULL);\n\n    object_property_set_description(obj, \"kernel-irqchip\",\n\n                                    \"Use KVM in-kernel irqchip\",\n\n                                    NULL);\n\n    object_property_add(obj, \"kvm-shadow-mem\", \"int\",\n\n                        machine_get_kvm_shadow_mem,\n\n                        machine_set_kvm_shadow_mem,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"kvm-shadow-mem\",\n\n                                    \"KVM shadow MMU size\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"kernel\",\n\n                            machine_get_kernel, machine_set_kernel, NULL);\n\n    object_property_set_description(obj, \"kernel\",\n\n                                    \"Linux kernel image file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"initrd\",\n\n                            machine_get_initrd, machine_set_initrd, NULL);\n\n    object_property_set_description(obj, \"initrd\",\n\n                                    \"Linux initial ramdisk file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"append\",\n\n                            machine_get_append, machine_set_append, NULL);\n\n    object_property_set_description(obj, \"append\",\n\n                                    \"Linux kernel command line\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dtb\",\n\n                            machine_get_dtb, machine_set_dtb, NULL);\n\n    object_property_set_description(obj, \"dtb\",\n\n                                    \"Linux kernel device tree file\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dumpdtb\",\n\n                            machine_get_dumpdtb, machine_set_dumpdtb, NULL);\n\n    object_property_set_description(obj, \"dumpdtb\",\n\n                                    \"Dump current dtb to a file and quit\",\n\n                                    NULL);\n\n    object_property_add(obj, \"phandle-start\", \"int\",\n\n                        machine_get_phandle_start,\n\n                        machine_set_phandle_start,\n\n                        NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"phandle-start\",\n\n                                    \"The first phandle ID we may generate dynamically\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dt-compatible\",\n\n                            machine_get_dt_compatible,\n\n                            machine_set_dt_compatible,\n\n                            NULL);\n\n    object_property_set_description(obj, \"dt-compatible\",\n\n                                    \"Overrides the \\\"compatible\\\" property of the dt root node\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"dump-guest-core\",\n\n                             machine_get_dump_guest_core,\n\n                             machine_set_dump_guest_core,\n\n                             NULL);\n\n    object_property_set_description(obj, \"dump-guest-core\",\n\n                                    \"Include guest memory in  a core dump\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"mem-merge\",\n\n                             machine_get_mem_merge,\n\n                             machine_set_mem_merge, NULL);\n\n    object_property_set_description(obj, \"mem-merge\",\n\n                                    \"Enable/disable memory merge support\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"usb\",\n\n                             machine_get_usb,\n\n                             machine_set_usb, NULL);\n\n    object_property_set_description(obj, \"usb\",\n\n                                    \"Set on/off to enable/disable usb\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"firmware\",\n\n                            machine_get_firmware,\n\n                            machine_set_firmware, NULL);\n\n    object_property_set_description(obj, \"firmware\",\n\n                                    \"Firmware image\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"iommu\",\n\n                             machine_get_iommu,\n\n                             machine_set_iommu, NULL);\n\n    object_property_set_description(obj, \"iommu\",\n\n                                    \"Set on/off to enable/disable Intel IOMMU (VT-d)\",\n\n                                    NULL);\n\n\n\n    /* Register notifier when init is done for sysbus sanity checks */\n\n    ms->sysbus_notifier.notify = machine_init_notify;\n\n    qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);\n\n}", "idx": 2950, "substitutes": {"obj": ["mt", "oid", "gr", "try", "tmp", "obo", "object", "ext", "objects", "hw", "onet", "req", "opt", "k", "stick", "pkg", "ind", "bo", "vol", "args", "ot", "ck", "resp", "art", "net", "bh", "dict", "mg", "cb", "act", "m", "msg", "check", "opp", "it", "ll", "ex", "iso", "xy", "kr", "mk", "mo", "co", "nt", "expr", "esm", "elt", "json", "obb", "j", "inst", "addr", "ref", "comm", "info", "att", "ns", "Object", "err", "dl", "ctx", "ob", "Obj", "nm", "pt", "wr", "src", "det", "gm", "cmd", "sys", "func", "inv", "bj", "term", "org", "attr", "txt", "og", "rect", "cont", "md", "orig", "obs", "def", "js", "rt", "o", "t", "typ"], "ms": ["mt", "ls", "ils", "ma", "ems", "mb", "sim", "es", "cms", "vs", "me", "s", "mg", "mp", "lems", "mic", "mx", "fs", "ols", "mos", "md", "js", "bs", "ns", "ims", "terms", "cs", "ts", "ks", "ents", "sm", "hs", "mes", "mn", "mm", "Ms", "mi", "si", "os", "ys", "mem", "mc", "MS"]}}
{"project": "qemu", "commit_id": "d22b2f41c470067758b3636a01b452dfeda7069f", "target": 1, "func": "void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->peer);\n\n\n\n    /* remove from list, if necessary */\n\n    if (bs->device_name[0] != '\\0') {\n\n        QTAILQ_REMOVE(&bdrv_states, bs, list);\n\n    }\n\n\n\n    bdrv_close(bs);\n\n    if (bs->file != NULL) {\n\n        bdrv_delete(bs->file);\n\n    }\n\n\n\n    assert(bs != bs_snapshots);\n\n    qemu_free(bs);\n\n}\n", "idx": 2958, "substitutes": {"bs": ["sys", "ls", "outs", "cks", "bc", "bh", "ss", "ics", "als", "css", "vs", "pb", "uts", "bles", "bp", "ses", "ds", "qs", "vals", "ubs", "fs", "lbs", "BS", "fts", "iss", "obs", "ps", "its", "bb", "js", "bos", "ns", "aos", "uses", "ims", "bi", "bis", "ms", "ts", "cs", "ks", "bes", "bps", "hs", "has", "sts", "hz", "rs", "bytes", "blocks", "bl", "bits", "blog", "bing", "gs", "bas", "sb", "ats", "bsp", "acs", "ops"]}}
{"project": "qemu", "commit_id": "dde3a2184074f5c4279fd7fbfc597b5dc5859fb8", "target": 1, "func": "static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n", "idx": 2967, "substitutes": {"opaque": ["OPque", "OPzero", "copacity", "OPatile", "oplity", "copque", " opque", "OPity", "opzero", "copzero", "OPaque", " opzero", "opacity", "opity", "oplaque", "opque", "iopaque", "iopatile", "oplatile", "oplacity", "iopacity", "copaque", "OPacity", "iopity", " opacity", "opatile"], "status": ["id", "summary", "use", "handle", "server", "set", "ne", "reason", "state", "version", "response", "wait", "spec", "wrapper", "os", "scan", "message", "stats", "test", "list", "vis", "cess", "source", "settings", "service", "result", "login", "details", "pause", "msg", "check", "access", "note", "name", "gc", "sync", "report", "json", "code", "ss", "style", "record", "description", "index", "me", "send", "res", "atus", "cache", "title", "uses", "error", "comment", "compl", "str", "scale", "fail", "current", "si", "prefix", "ssl", "success", "sys", "active", "Status", "stat", "sim", "prom", "s", "mode", "sql", "score", "notice", "config", "content", "null", "site", "store", "base", "ping"], "info": ["id", "try", "op", "init", "iter", "options", "conf", "http", "ti", "Inf", "fee", "by", "ret", "te", "f", "scan", "stats", "list", "detail", "meta", "settings", "tif", "result", "details", "ready", "num", "ui", "none", "check", "it", "note", "recent", "ist", "io", "sync", "report", "json", "ii", "information", "Info", "inf", "index", "i", "type", "history", "fi", "error", "same", "diff", "one", "more", "si", "exec", "of", "doc", "success", "data", "image", "sys", "value", "no", "is", "stat", "import", "txt", "maybe", "notice", "extra", "def", "config", "ip", "metadata", "alias", "INFO", "now", " inf", "in", "good", "about", "state", "fo"], "progress": ["success", "trust", "total", "finished", "grade", "distance", "key", "quant", "summary", "percent", "step", "next", "p", "Progress", "pdf", "row", "fine", "tip", "sample", "result", "label", "iter", "debug", "dist", "page", " progressed", "load", "clip", " Progress", "speed", "bar", " progression", "history", "title", "content", " progresses", "diff", "ptr", "processing", "command", "complete", "wait", "priority", "print", "poll", "scale", "process", "good", "current", "max", "resp", "par", "rep", "state", "prefix", "report", "pro"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 2996, "substitutes": {"code": ["age", "cod", "id", "coe", "cycle", "test", "cd", "try", "c", "count", "xc", "nc", "ay", "sec", "term", "Code", "codes", "create", "ca", "cb", "close", "ce", "ne", "cont", "entry", "zero", "xe", "type", "time", "ch", "error", "xxx", "desc", "err", "xx", "ie", "cast", "here", "now", "ter", "go", "one", "ode", "frame", "cc", "address", "ct", "rc", "ck", "th", "cmd"], "addr": ["mt", "ace", "alloc", "id", "add", "eth", "arr", "mb", "host", "Address", "bind", "hw", "ref", "cb", "url", "act", "res", "x", "load", "tx", "msg", "pos", "ok", "at", "ack", "pad", "cmp", "mem", "ip", "ptr", "err", "name", "adr", "str", "gate", "alt", "rt", "ag", "loc", "offset", "pkg", "gc", "rs", "mac", "address", "arp", "hash", "src", "ad", "arg", "rc", "oad", "obj", "a", "asm", "cmd", "sp"], "vaddr": ["vaddress", "svaddr", "wptr", " vptr", "waddress", "vcadr", " vld", "vadd", "haddr", "padd", "hptr", "waddr", "paddress", "svadr", "wadd", "hadd", "haddress", "vcaddr", "vcadd", "pld", "vloc", " vloc", "vld", "svloc", "pptr", "vcloc", "vadr", "vptr", "hld", "svadd", " vadr", " vadd"], "ram_addr": ["sam_addr", "sam_ptr", "sky_map", "ram___ptr", "gem_id", "ram___offset", "ram2addr", "ram_ptr", "gem_ptr", "sam_name", "ram_address", "ram2map", "sky_id", "ram2ptr", "ram2id", "sam_address", "ram2offset", "ram_name", "ram___addr", "gem_offset", "gem_addr", "sky_addr", "ram_offset", "ram_map", "ram_id", "ram___id", "sky_ptr"], "paddr": ["vaddress", "pstat", "apaddr", "apdata", "Pstat", " padd", "pref", "vadd", " pptr", "padd", "mref", "apptr", "apstat", "paddress", " pstat", "pdata", " pdata", "maddress", "Paddress", "Pptr", "maddr", "pptr", "Paddr", "mptr", "madd", " pref", "vref", " paddress", "Padd", "Pdata"]}}
{"project": "qemu", "commit_id": "aef172ffdc2f9c41d9cc043a55f1259e7c07e587", "target": 1, "func": "coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    struct unmap_list list;\n\n    int r = 0;\n\n\n\n    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpu) {\n\n        /* UNMAP is not supported by the target */\n\n        return 0;\n\n    }\n\n\n\n    list.lba = offset / iscsilun->block_size;\n\n    list.num = bytes / iscsilun->block_size;\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\nretry:\n\n    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,\n\n                         iscsi_co_generic_cb, &iTask) == NULL) {\n\n        r = -ENOMEM;\n\n        goto out_unlock;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_mutex_unlock(&iscsilun->mutex);\n\n        qemu_coroutine_yield();\n\n        qemu_mutex_lock(&iscsilun->mutex);\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {\n\n        /* the target might fail with a check condition if it\n\n           is not happy with the alignment of the UNMAP request\n\n           we silently fail in this case */\n\n        goto out_unlock;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        r = iTask.err_code;\n\n        goto out_unlock;\n\n    }\n\n\n\n    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,\n\n                               bytes >> BDRV_SECTOR_BITS);\n\n\n\nout_unlock:\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    return r;\n\n}\n", "idx": 3001, "substitutes": {"bs": ["sys", "cks", "bc", "bh", "bd", "ss", "bm", "pb", "bp", "bles", "ds", "b", "ubs", "fs", "lbs", "BS", "obs", "ps", "its", "bb", "bos", "bt", "js", "ns", "bi", "bis", "cs", "ts", "bg", "bes", "bps", "bl", "bits", "blog", "abus", "gs", "bas", "sb", "bf", "bn", "ib"], "offset": ["mt", "bound", "batch", "alloc", "oid", "image", "et", "size", "no", "addr", "slot", "seconds", "slice", "seek", "to", "from", "ref", "index", "order", "pointer", "set", "num", "pos", "start", "off", "at", "amount", "location", "block", "error", "buffer", "command", "attribute", " offsets", "origin", "len", "Offset", "offs", "range", "address", "padding", "o", "bits", "position", "timeout", "prefix", "top", "base", "length", "byte"], "bytes": ["nets", "steps", "values", "rows", "size", "mb", "outs", "sets", "seconds", "es", "files", "words", "checks", "times", "names", "pointers", "s", "devices", "ips", "loads", "gets", "tes", "pages", "ions", "units", "reads", "pieces", "its", "parts", "uses", "izes", "Bytes", "trans", "errors", "terms", "keys", "ies", "odes", "bes", "bps", "classes", "offs", "types", "blocks", "abytes", "bits", "gs", "latest", "ys", "ops", "sofar", "byte"], "iscsilun": ["ischsprgun", " discsinul", " discsilun", "ischsilun", "ibrsilun", "miscsiloun", "miscsilun", "isecsilon", "iscviolun", "iscsslon", "miscsilUN", "iscosinun", "iscspron", "isctilmun", "iscsimUN", "issiduna", "iscsentmun", "nicsinUN", "issidun", "uscsinUN", "iscselmun", "ischsprmun", "iscsiduna", "iscsinoun", "misctilUN", " discsinune", "isecselmun", "isciphanyuna", "iscsidun", "ihsentut", "iscsslun", "iscsiloun", "ischematicun", "micsentgun", "isckillun", "ircsiluna", "miscsilund", "iscSilul", "iscsentn", "nicsilon", "ircsilun", "ihsilut", "iscsln", "iscSilgun", "isckillunt", "ischematicon", "iscosinur", "ircSilon", "iscsiluna", "isecselun", "micsentn", "iscosilune", "issilun", "misctiloun", "iscslunt", "ibrfolon", "ihsilunt", "iscticut", "ischsprun", "ibrfolmun", "misctilgun", "iscsiln", "isckillUn", "iscslgun", "iscsilgun", "iscspellun", "iscgilun", "iscsidut", "isctilUn", "ircSilUn", "iscsprun", "iscmilgun", "ihsentun", "isciphanyund", "iscSilUn", "iscfolmun", "iscsalmun", "micsilmun", "nicsinon", "iscsilut", "nicsinun", "ibrsiluno", "isecsilgun", "iscsimgun", "iscgiluna", "iscsentban", "ibrfolun", "ircsilmun", "ihsentgun", "iscosinon", "nicsiluna", "iscsalun", "iscgilul", "iscsaluna", "uscsilUN", "ibrsilmun", "iscSilon", "iscsenton", "iscsilune", "iscgilUN", "ischematicgun", "iscsilban", "micsentmun", "ircsilUn", "iscSilun", "ircsilunt", "iscsinun", "issiluna", "iscsinune", "iscsilon", "ihsentunt", "iscsinUN", "miscsilgun", "iscsilUN", "iscsentut", "iscsinon", "iscsentunt", "nicsilun", "iscosilon", "iscgiln", "iscSiluna", "iscsiluno", " discsilon", "iscinelun", "iscSilmun", "iscspellur", "isckillmun", "iscslmun", "iscgilon", "iscticuna", "iscsingun", "micsentun", "isciphanyun", "iscsentgun", "isctilunt", " discsilul", "ischematicunt", "issidban", "isecsilun", "ischsilmun", "iscslun", "iscspellune", "iscSilUN", "iscselgun", "iscsprmun", " discsilune", "iscSiln", "nicsinuna", "iscineluna", "iscmilmun", "nicsilUN", "ibrsilon", "ircsilur", "iscticban", "iscinelund", "iscsilmun", "issilut", "ihsilun", "ischematicut", "iscsentun", "iscssluna", "isctiloun", "iscsinul", "ischsilon", "iscsprgun", "issidut", "iscsilul", "misciphanyund", "iscsilUn", "ircSiluna", "iscsimun", " discsinun", "iscsidban", "misctilun", "iscosinune", "isecselon", "iscsilund", " discsinon", "iscSilune", "ircSilmun", "isctilgun", "isecselgun", "iscspellon", "ischspron", "iscviolon", "isctilun", "isctilUN", "iscsslur", "uscsinn", "uscsinun", "iscmilon", "uscsinune", "ischsilgun", "miscsilmun", "uscsiln", "iscvioluno", "micsiln", "ischematicuna", "iscviolmun", "iscosilun", "iscsilur", "iscfolun", "iscSiluno", "iscsinur", "micsilun", "uscsilun", "misciphanymun", "iscfolon", "ircSilunt", "iscsalund", "misciphanyuna", "micsilgun", "iscinelmun", "iscsimoun", "iscslut", "ircsilon", "ibrfoluno", "iscosilur", "iscgilune", "iscfoluno", "ircSilur", "misciphanyun", "iscselon", "iscticun", "isecsilmun", "iscsilunt", "iscSilur", "iscselun", "isciphanymun", "iscsentuna", "iscsinn", "iscSilunt", "ischematicur", "iscsinuna", "issilban", "iscmilun", "ircSilun", "ihsilgun", "miscsiluna", "uscsilune"], "iTask": ["iiTask", "jiFunction", " iWork", "diRunning", " iNode", "liNode", " iConfig", "multiJob", " iFunction", " iThread", "multiAttempt", "liChild", "riAsset", "oriChild", "iConfig", "diTask", "liEvent", "liFinish", "liJob", "iRunning", "phiTask", "iiParent", "uiThread", "ziEvent", " iJob", "iBlock", "itiBlock", "jiConfig", " iAttempt", "jiCommand", "iiThread", "iPlatform", "hiThread", "piFinish", "uiTransaction", "miJob", "itiTask", "iAttempt", "iChild", "riTask", "iService", " iBlock", "iTransaction", "uiTask", " iService", "piConfig", "phiCommand", "iCommand", " iRunning", "diJob", "itiAttempt", "diThread", "ciTransaction", "ciProcess", "multiTask", "liProcess", " iParent", "ciTask", "jiTask", "miWork", "iFinish", "iParent", "iiWork", "cliTask", "riPlatform", "liCommand", "iitask", "iFunction", "piEvent", "iAsset", "iiJob", "itask", "jiEvent", "jiService", "hiProcess", "miConfig", "liTask", "iThread", " iProcess", "ziFunction", "liPlatform", "miParent", "oriCommand", " iEvent", "iiBlock", "miAsset", "ciThread", "iiAttempt", "oriNode", "uiAttempt", "ziTask", "uiJob", "miTask", "iNode", "liAttempt", "phiNode", "iEvent", "jiPlatform", "hiTask", "miTransaction", "iiRunning", "cliEvent", "riTransaction", "cliConfig", "uiAsset", "miCommand", "iJob", "miPlatform", "piTask", "hiTransaction", "liConfig", "ititask", "phiChild", "cliFinish", "multiNode", "iWork", "oriTask", "iProcess", " iTransaction", " itask", "iiProcess", "uiPlatform", "litask", "iiConfig", "ziService"], "list": ["batch", "List", "parent", "total", "art", "lp", "add", "l", "tmp", "item", "status", "arr", "count", "warning", "LIST", "p", "record", "lists", "all", "n", "dict", "index", "label", "li", "out", "set", "table", "filter", "load", "form", "msg", "new", " pl", "seq", "def", "listed", "conf", "ist", "block", " l", "dl", "e", "elist", "spec", "pool", "len", "and", "array", "alist", "pkg", "member", "queue", "range", "v", "flag", "st", "t", "obj", "base", "not", "chain"]}}
{"project": "qemu", "commit_id": "def74c0cf05722b2e502d4b4f1219966c5b0cbd3", "target": 1, "func": "int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,\n\n                              int mmu_idx)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    hwaddr physical;\n\n    int prot;\n\n    int access_type;\n\n#endif\n\n    int ret = 0;\n\n\n\n#if 0\n\n    log_cpu_state(cs, 0);\n\n#endif\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n              \"%s pc \" TARGET_FMT_lx \" ad %\" VADDR_PRIx \" rw %d mmu_idx %d\\n\",\n\n              __func__, env->active_tc.PC, address, rw, mmu_idx);\n\n\n\n    /* data access */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* XXX: put correct access by using cpu_restore_state()\n\n       correctly */\n\n    access_type = ACCESS_INT;\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n             \"%s address=%\" VADDR_PRIx \" ret %d physical \" TARGET_FMT_plx\n\n             \" prot %d\\n\",\n\n             __func__, address, ret, physical, prot);\n\n    if (ret == TLBRET_MATCH) {\n\n        tlb_set_page(cs, address & TARGET_PAGE_MASK,\n\n                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0)\n\n#endif\n\n    {\n\n        raise_mmu_exception(env, address, rw, ret);\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3003, "substitutes": {"cs": ["ec", "ls", "sys", "cp", "wcs", "cas", "c", "pc", "cks", "ss", "es", "css", "ics", "cms", "cus", "vs", "caps", "s", "ses", "ds", "csv", "qs", "fs", "sc", "ps", "js", "bs", "ns", "ms", "ts", "ctx", "ks", "ces", "hs", "sts", "rs", "cc", "CS", "ins", "ck", "ys", "acs"], "address": ["domain", "ace", "message", "interface", "able", "trace", "add", "device", "document", "word", " Address", "phrase", "addr", "host", "port", "Address", "record", "absolute", "service", "route", "description", "ref", "index", "r", "order", "relative", "pointer", "path", "memory", "res", "password", "email", "resses", "request", "shape", "network", "location", "ip", "error", "ptr", "command", "private", "attribute", "context", "name", "alias", "resource", "adr", "reference", "array", "each", "uri", "region", "offset", "range", "ress", "event", "position", "point", "prefix"], "rw": ["rd", "usr", "work", "wp", "aw", "nr", "addr", "wn", "row", "ow", "hw", "r", "ru", "write", "rb", "wa", "wind", "nw", "wer", "writer", "sw", "wl", "rew", "rf", "w", "ptr", "iw", "rh", "wd", "adr", "wb", "rt", "offset", "ew", "range", "rs", "wx", "wr", "writ", "RW", "resp", "mem"], "mmu_idx": ["mmu2idy", "mmu_pidy", "mmu2Idz", "mmu_inp", "mmu_idxf", "mmu2idz", "mmu_pidz", "mmu_inw", "mmu_idy", "mmu_pidx", "mmu_midz", "mmu_inz", "mmu_idw", "mmu_idp", "mmu_Idxf", "mmu_midy", "mmu_midxf", "mmu_Idy", "mmu_pidw", "mmu2idx", "mmu_midw", "mmu_Idw", "mmu_idz", "mmu_Idx", "mmu_pidp", "mmu2Idy", "mmu_Idp", "mmu_inx", "mmu_midx", "mmu2Idx", "mmu_Idz"], "cpu": ["proc", "core", "bean", "arch", "cp", "aux", "ane", "phys", "pc", "nc", "cn", "conn", "chip", "stat", "pu", "hw", "np", "node", "CPU", "gpu", "processor", "phy", "sc", "ex", "tp", "vm", "cf", "cum", "setup", "ctx", "aco", "nic", "comp", "gc", "apache", "bench", "mac", "clock", "cu", "process", "mem", "tc", "CP"], "env": ["proc", "ec", "inst", "et", "net", "er", "buf", "nc", "sv", "next", "conn", "org", "eh", "ev", "attr", "window", "vs", "txt", "hw", "ah", "server", "cfg", "viron", "cb", "environment", "engine", "ds", "esc", "nv", "em", "eni", "ce", "pe", "sc", "priv", "dev", "scope", "config", "state", "ef", "conf", "vm", "context", "e", "ptr", "cv", "en", "err", "ts", "ctx", "enc", "ew", "ten", "eco", "enter", "worker", "estate", "esm", "obj", "eng", "cmd", "Environment"], "physical": ["sys", "total", "active", "public", "net", "pro", "information", "phys", "p", "virtual", "absolute", "pn", "ref", "hw", "relative", "localhost", "server", "pb", "np", "pointer", "vt", "path", "password", "native", "external", "phy", "policy", "vp", "network", "variable", "tp", "location", "config", "ip", "http", "local", "normal", "private", "attribute", "readable", "resource", "ruby", "protected", "effective", "restricted", "enabled", "remote", "console", "target", "primary", "Physical", "binary", "png", "present", "base", "sp"], "prot": ["proc", "ocol", "notes", " proto", "eth", "net", "pro", "phys", "prop", "format", "dt", "pc", "status", "port", "virtual", "tif", "pn", "np", "pb", "pointer", "platform", "Prot", "password", "phy", "supported", "policy", "chron", "qt", "def", "controller", "type", "tf", "tp", "pat", "att", "rot", "version", "rf", "ptr", "ports", "pattern", "protected", " PROT", "tech", "primary", "ret", "inet", "col", "tr", "prototype", "top", "cmd", "ht", "typ"], "access_type": ["access00type", "access_types", "access00TYPE", "access00options", "Access_Type", "access_TYPE", "access00Type", "access_Type", " access_Type", "Access_TYPE", "access2Type", "Access_type", " access_TYPE", "access_options", "access2types", "access2type", " access_options", " access_types"]}}
{"project": "qemu", "commit_id": "e26110cfc67d48331a76e9b1e6f7fed7569e1ab3", "target": 0, "func": "static ModuleTypeList *find_type(module_init_type type)\n\n{\n\n    ModuleTypeList *l;\n\n\n\n    init_types();\n\n\n\n    l = &init_type_list[type];\n\n\n\n    return l;\n\n}\n", "idx": 3020, "substitutes": {"type": [" value", "Type", "ype", "ty", "key", "test", " variable", "p", "description", "kind", "link", " attribute", " e", " instance", "x", "pe", " key", " error", "variable", "time", "token", " other", "file", "y", " definition", "otype", "e", "role", "name", "TYPE", " file", " p", "resource", " y", " structure", " field", "member", "function", "types", "t", "module", " types", "typ"], "l": ["ls", "ul", "j", "lp", "le", "list", "L", "il", "c", "nl", "z", "p", "all", "g", "sl", "kl", "lt", "s", "li", "m", "i", "b", "u", "lb", "ll", "it", "fl", "k", "hl", "dl", "tl", "el", "pl", "ln", "loc", "v", "lay", "h", "ml", "f", "lc", "lang", "t", "len", "ld"]}}
{"project": "qemu", "commit_id": "8bd7f71d794b93ce027b856f5b79a98f4f82e44c", "target": 0, "func": "static int qemu_suspend_requested(void)\n\n{\n\n    int r = suspend_requested;\n\n    suspend_requested = 0;\n\n    return r;\n\n}\n", "idx": 3040, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "f43a16049ef07585789d311f314f236a314f91f7", "target": 0, "func": "int opt_cpuflags(const char *opt, const char *arg)\n\n{\n\n#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)\n\n#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)\n\n#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)\n\n#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)\n\n#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)\n\n#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)\n\n#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)\n\n#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)\n\n#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)\n\n#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)\n\n    static const AVOption cpuflags_opts[] = {\n\n        { \"flags\"   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = \"flags\" },\n\n        { \"altivec\" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = \"flags\" },\n\n        { \"mmx\"     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = \"flags\" },\n\n        { \"mmx2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = \"flags\" },\n\n        { \"sse\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = \"flags\" },\n\n        { \"sse2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = \"flags\" },\n\n        { \"sse2slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = \"flags\" },\n\n        { \"sse3\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = \"flags\" },\n\n        { \"sse3slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = \"flags\" },\n\n        { \"ssse3\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = \"flags\" },\n\n        { \"atom\"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = \"flags\" },\n\n        { \"sse4.1\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = \"flags\" },\n\n        { \"sse4.2\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = \"flags\" },\n\n        { \"avx\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = \"flags\" },\n\n        { \"xop\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = \"flags\" },\n\n        { \"fma4\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = \"flags\" },\n\n        { \"3dnow\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = \"flags\" },\n\n        { \"3dnowext\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = \"flags\" },\n\n        { NULL },\n\n    };\n\n    static const AVClass class = {\n\n        .class_name = \"cpuflags\",\n\n        .item_name  = av_default_item_name,\n\n        .option     = cpuflags_opts,\n\n        .version    = LIBAVUTIL_VERSION_INT,\n\n    };\n\n    int flags = av_get_cpu_flags();\n\n    int ret;\n\n    const AVClass *pclass = &class;\n\n\n\n    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)\n\n        return ret;\n\n\n\n    av_force_cpu_flags(flags);\n\n    return 0;\n\n}\n", "idx": 3054, "substitutes": {"opt": ["feat", "ff", "prop", "op", "ext", "init", "attr", "ref", "txt", "eff", "lt", "options", "fg", "var", "oop", "off", "etc", "Opt", "oc", "kw", "oss", "ts", "option", "alt", "OP", "mem", "cmd"], "arg": ["proc", "doc", "aux", "op", "arr", "use", "ext", "all", "g", "Arg", "ax", "var", "bit", "star", "gen", "call", "w", "name", "spec", "bin", "reg", "argument", "mac", "target", "args", "flag", "mem", "cmd"], "cpuflags_opts": ["cpuflags_pts", "cpuflags_opds", "cpuflags_prods", "cpuflags_procs", "cpuflags_pcs", "cpuflags_opt", "cpuflags_pds", "cpuflags_optds", "cpuflags_optcs", "cpuflags_optt", "cpuflags_pt", "cpuflags_prots", "cpuflags_optts", "cpuflags_opcs", "cpuflags_prot"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);\n\n}\n", "idx": 3065, "substitutes": {"dst": [" ddest", "Ddest", "fdest", "ddest", "Dest", "fst", "dtr", "fsrc", "gest", "gnd", " dtr", " dsrc", "bnd", "fest", " dnd", " dest", "best", "dsrc", "dest", "Dst", "bst", "Dsrc", "gst", "gtr", "dnd", "btr"], "src": ["sys", "input", "ctr", "inner", "gin", "source", "img", "sl", "r", "txt", "np", "s", "b", "ur", "sc", "cur", "impl", "dq", "iv", "sr", "trans", "hl", "ptr", "ipl", "comp", "bg", "rl", "dest", "str", "rt", "loc", "rs", "in", "rc", "sb", "st", "ins", "sn"], "stride": [" strend", "strider", "trend", "trider", "strue", "tride", "STRide", "stid", "strid", " strade", "drride", "shrope", " strider", " strime", "STRride", "dride", "drides", " strride", "strend", "slade", "drope", "shrides", "slitud", "slride", "shrride", "stritud", "slend", " strid", "slider", "slue", "stide", " strue", "STRides", "strope", "drue", "strides", "slime", "STRope", "drime", " stritud", "shride", "trid", "strade", "strride", "stade", "strime", "dritud", "slid", "slide"]}}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n", "idx": 3070, "substitutes": {"opaque": ["OPque", "oraque", " oplay", " opque", "Opity", "ority", "bitaque", "OPlay", "oaque", "Opaque", "OPaque", "OPaques", "bitoid", "oaques", "olay", "oroid", "opity", " opaques", "Opatile", "opque", "oque", "opoid", "oplay", "Opoid", "bitity", "opaques", "bitatile", "opatile", "oratile"], "s": ["sis", "ls", "p", "es", "ses", "set", "gets", "services", "its", "t", "ports", "spec", "an", "h", "gs", "sb", "so", "os", "stats", "sv", "source", "vs", "details", "ess", "ds", "qs", "less", "bs", "ims", "bis", "bes", "hs", "sts", "eps", "pers", "ins", "states", "sq", "sync", "acs", "j", "S", "l", "ss", "als", "sl", "comm", "i", "syn", "ns", "sw", "y", "ms", "ts", "changes", "v", "se", "ssl", "sys", "is", "g", "r", "b", "fs", "aws", "ps", "parts", "js", "as", "rs", "ats", "store", "obj"], "divider": ["divander", "indide", "domide", "divide", "divrier", "divid", "provision", "domator", "digator", "provider", "devid", "DIVidable", "multiplier", " divrier", "devider", " divander", "Diviator", " divid", "multiplider", "division", " divator", "digide", "divier", "Divider", "indiator", "divIDER", " diviator", "divicator", " divIDER", "digision", "devIDER", "Divicator", "digidable", "multiplide", " divide", "diviator", " divicator", "digander", "DIVider", "DIVrier", "domider", "dividable", "providable", "provide", "devidable", "Divier", "collide", "collidable", " dividable", "multiplIDER", "Divide", "digider", "collision", "DIVIDER", "divator", "Divrier", "DIVid", " divier", "indIDER", "DIVicator", "collider", "DivIDER", "domander", "indider"]}}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n", "idx": 3076, "substitutes": {"ssd": ["tssd", "ussp", "cssdl", "bspd", "csssd", "SSw", " ssw", "rsssd", "usssd", "essdk", "issds", "ssds", "essd", "ussd", "essds", " sssd", " ssds", "rssd", "ossw", "psw", "psds", "pssd", " ssdk", "tsp", "essw", "bsds", "ssdk", "issd", "atssd", "isssd", "csspd", "psd", "bssd", "SSds", "cssds", "ussdl", "osssd", "SSsd", "cssd", "atspd", "esssd", "atsd", "atsds", "sspd", "rssds", "ossp", "essdl", "sssd", "ssp", " ssp", "bsd", "cssp", "ossd", "tsd", "tsdk", "ssdl", "pspd", "ssw", "SSd", "rsspd", "issp", "essp"], "surface": ["interface", "tmp", "summary", "port", "window", "node", "server", "texture", "sum", "volume", "vp", "FACE", "sur", "t", "output", "buffer", "manager", " Surface", "console", "wrapper", "f", "steam", "this", "message", "source", "result", "plane", "submit", "ui", "storage", "tp", "cell", "final", "ptr", "lower", "display", "uv", "tr", "database", "uf", "report", "folder", "document", "directory", "view", "pdf", "figure", "fac", "sheet", "index", "space", "panel", "grid", "new", "airo", "cache", "cur", "connection", "save", "empty", "address", "ve", "flag", "reflect", "mail", "data", "image", "public", "face", "func", "instance", "package", "sole", "unknown", "profile", "delete", "filename", "metadata", "bridge", "null", "utm", "layout", "store", "subject"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_750fx (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 3082, "substitutes": {"env": ["ka", "usr", "ev", "window", "hw", "server", "ner", "set", "tek", "qt", "vp", "vm", "vv", "context", "here", "manager", "ten", "console", "enter", "estate", "serv", "eng", "era", "ec", "net", "ut", "tk", "sv", "result", "vs", "erb", "viron", "cb", "environment", "act", "esc", "export", "nw", "msg", "shell", "end", "outer", "den", "ect", "ew", "uv", "esm", "rod", "er", "gear", "dt", "addr", "code", "eh", "ah", "engine", "ei", "entry", "cur", "esi", "dev", "forge", "el", "en", "ctx", "v", "oe", "erd", "det", "ve", "worker", "gov", "da", "cmd", "doc", "et", "inv", "conn", "org", "nv", "em", "dh", "config", "desc", "cv", "e", "vert", "origin", "chart", "project", "ja", "site", "event", "store", "obj"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))\n\n{\n\n    stream_printf(stream, \"Trace file \\\"%s\\\" %s.\\n\",\n\n                  trace_file_name, trace_file_enabled ? \"on\" : \"off\");\n\n}\n", "idx": 3098, "substitutes": {"stream": ["reader", "input", "stack", "data", "chain", "mount", "test", "status", "host", "handle", "port", "view", "source", "pipe", "iterator", "seek", "row", "sample", "window", "read", "sl", "open", "progress", "out", "path", "REAM", "form", "new", "impl", "output", "file", "trans", "buffer", "context", "pool", "str", "poll", "console", "loop", "proof", "event", "tr", "line", "socket", "sync", "Stream"], "stream_printf": ["stream_print", "stream_put", "Stream_put", "Stream_printf", "stream_println", " stream_println", " stream_print", "stream_width", "Stream_println", "Stream_print", " stream_width"]}}
{"project": "FFmpeg", "commit_id": "9924f1bc34242bb9315c355108f3ce744c1f33c5", "target": 0, "func": "static int mkv_write_header(AVFormatContext *s)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    ebml_master ebml_header;\n\n    AVDictionaryEntry *tag;\n\n    int ret, i, version = 2;\n\n    int64_t creation_time;\n\n\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n\n        mkv->mode = MODE_WEBM;\n\n    else\n\n        mkv->mode = MODE_MATROSKAv2;\n\n\n\n    if (mkv->mode != MODE_WEBM ||\n\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n\n        version = 4;\n\n\n\n    if (s->nb_streams > MAX_TRACKS) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"At most %d streams are supported for muxing in Matroska\\n\",\n\n               MAX_TRACKS);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n\n            version = 4;\n\n    }\n\n\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n\n    if (!mkv->tracks) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n\n    end_ebml_master(pb, ebml_header);\n\n\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n\n    mkv->segment_offset = avio_tell(pb);\n\n\n\n    // we write 2 seek heads - one at the end of the file to point to each\n\n    // cluster, and one at the beginning to point to all other level one\n\n    // elements (including the seek head at the end of the file), which\n\n    // isn't more than 10 elements if we only write one of each other\n\n    // currently defined level 1 element\n\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n\n    if (!mkv->main_seekhead) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n\n    if (ret < 0) goto fail;\n\n\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n    pb = mkv->info_bc;\n\n\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n\n        else\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n\n\n        if (mkv->mode != MODE_WEBM) {\n\n            uint32_t segment_uid[4];\n\n            AVLFG lfg;\n\n\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n\n\n            for (i = 0; i < 4; i++)\n\n                segment_uid[i] = av_lfg_get(&lfg);\n\n\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n\n        }\n\n    } else {\n\n        const char *ident = \"Lavf\";\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n\n    }\n\n\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n\n        uint8_t date_utc_buf[8];\n\n        AV_WB64(date_utc_buf, date_utc);\n\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n\n    }\n\n\n\n    // reserve space for the duration\n\n    mkv->duration = 0;\n\n    mkv->duration_offset = avio_tell(pb);\n\n    if (!mkv->is_live) {\n\n        int64_t metadata_duration = get_metadata_duration(s);\n\n\n\n        if (s->duration > 0) {\n\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else if (metadata_duration > 0) {\n\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else {\n\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n\n        }\n\n    }\n\n    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    else\n\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    pb = s->pb;\n\n\n\n    // initialize stream_duration fields\n\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n\n\n    ret = mkv_write_tracks(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    for (i = 0; i < s->nb_chapters; i++)\n\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n\n\n    ret = mkv_write_chapters(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (mkv->mode != MODE_WEBM) {\n\n        ret = mkv_write_attachments(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    ret = mkv_write_tags(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        mkv_write_seekhead(pb, mkv);\n\n\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n\n    if (!mkv->cues) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {\n\n        mkv->cues_pos = avio_tell(pb);\n\n        put_ebml_void(pb, mkv->reserve_cues_space);\n\n    }\n\n\n\n    av_init_packet(&mkv->cur_audio_pkt);\n\n    mkv->cur_audio_pkt.size = 0;\n\n    mkv->cluster_pos = -1;\n\n\n\n    avio_flush(pb);\n\n\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n\n    // after 4k and on a keyframe\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 5000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n\n    } else {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 1000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 32 * 1024;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    mkv_free(mkv);\n\n    return ret;\n\n}\n", "idx": 3117, "substitutes": {"s": ["ls", "these", "c", "ches", "scl", "p", "es", "aunts", "n", "app", "ses", "sc", "services", "ions", "its", "conf", "http", "ports", "ans", "cs", "spec", "pkg", "events", "ags", "h", "gs", "sb", "args", "os", "a", "south", "stats", "sv", "actions", "details", "xs", "ds", "qs", "m", "less", "ex", "bs", "ims", "bis", "sam", "ks", "hs", "sts", "eps", "ins", "sq", "j", "S", "l", "ss", "z", "als", "comm", "https", "views", "ns", "sw", "y", "ms", "ts", "changes", "v", "results", "uploads", "sp", "sys", "is", "g", "times", "sql", "b", "fs", "aws", "ps", "parts", "js", "ads", "w", "comments", "as", "sports", "rs", "o", "bits", "cl", "ats", "t"], "mkv": ["skyvp", " mkw", " mkvc", "mutch", "MKvc", " mkV", "skyt", "kmV", "mkw", "kV", "kmv", "mkvc", "makevp", "ckv", "mutvs", "skyv", "makew", "mktv", "kmvc", "MKV", "makev", "mkvs", "makevs", "mkV", "mkch", "skyw", "kvs", " mkt", "mutv", " mkvs", "kmtv", "mkvp", " mkvp", " mkch", "ckvs", "makech", "MKv", "ckV", "maket", "mkt", " mktv", "kv", "MKtv"], "pb": ["fp", "proc", "cp", "lp", "wp", "jp", "mb", "pc", "eb", "buf", "ub", "tk", "p", "conv", "bm", "dc", "pm", "np", "bp", "mp", "pp", "cb", "gp", "b", "vp", "cmp", "tp", "pa", "tc", "cv", "ctx", "pool", "ob", "pkg", "db", "pan", "pub", "sb", "cm", "PB", "uf", "typ"], "ebml_header": ["ebxml2header", "ebxml2Header", "ebml_headers", "ebml2headers", "ebml2Header", "ebml_version", "ebml2version", "ebxml_headers", "ebml2header", "ebxml_header", "ebxml2headers", "ebml_Header", "ebxml2version", "ebxml_Header", "ebxml_version"], "tag": ["cat", "key", "op", "word", "match", "record", "row", "attr", "TAG", "bug", "table", "Tag", "msg", "entry", "token", "tags", "tar", "comment", "name", "ag", "reg", "db", "event", "par", "art", "feat", "map"], "ret": ["mt", "RET", "cat", "status", "match", " RET", "result", "ref", "ner", "out", " val", "res", " resp", "new", " ok", "mem", "VAL", "Ret", "el", "alt", "re", "val", "rs", " alt", "flag", "resp"], "i": ["multi", "batch", "j", "id", "l", "ii", "ki", "iq", "ji", "status", "p", "sim", "g", "n", "init", "xi", "ski", "pi", "index", "me", "iter", "ci", "li", "ic", "ami", "m", "ei", "x", "cli", "ui", "info", "phi", "it", "gi", "ij", "ip", "oi", "y", "ims", "bi", "im", "e", "hi", "iu", "ti", "ir", "ind", "go", "uri", "io", "ix", "remote", "v", "ia", "zi", "in", "mi", "ini", "di", "\u0438", "ai", "I", "si", "f", "ri", "t", "any", "chain"], "creation_time": ["creation_t", "create_t", "create_date", "create_time", "create_times", "creation_times", "creation_date"]}}
{"project": "qemu", "commit_id": "4105de6732f771ea64113851a2ee7172c34d3a7a", "target": 1, "func": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n", "idx": 3130, "substitutes": {"s": ["sys", "sis", "j", "S", "l", "c", "is", "sv", "ss", "p", "z", "als", "g", "n", "session", "sl", "service", "r", "ses", "ess", "set", "ds", "comm", "m", "i", "b", "fs", "less", "ps", "js", "bs", "ns", "state", "sw", "conf", "y", "e", "bis", "ts", "spec", "ies", "hs", "sts", "rs", "h", "o", "gs", "sb", "sq", "so", "t", "obj", "a", "se", "ssl"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_sws_init_swScale_mmx(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_INLINE_ASM\n\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n\n        sws_init_swScale_MMX(c);\n\n#if HAVE_MMXEXT_INLINE\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT)\n\n        sws_init_swScale_MMX2(c);\n\n#endif\n\n#endif /* HAVE_INLINE_ASM */\n\n\n\n#if HAVE_YASM\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (cpu_flags & AV_CPU_FLAG_MMX) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE2) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSSE3) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE4) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 3153, "substitutes": {"c": ["ec", "vc", "cp", "fc", "l", "bc", "p", "conv", "n", "dc", "ca", "s", "mc", "m", "com", "b", "ce", "C", "cont", "sc", "cache", "oc", "conf", "ch", "k", "cf", "w", "e", "cam", "cv", "cs", "ctx", "co", "coll", "gc", "v", "cu", "cc", "ct", "cl", "rc", "cm", "lc", "ac", "t", "tc", "a"]}}
{"project": "FFmpeg", "commit_id": "0a467a9b594dd67aa96bad687d05f8845b009f18", "target": 1, "func": "static unsigned tget(const uint8_t **p, int type, int le)\n\n{\n\n    switch (type) {\n\n    case TIFF_BYTE:\n\n        return *(*p)++;\n\n    case TIFF_SHORT:\n\n        return tget_short(p, le);\n\n    case TIFF_LONG:\n\n        return tget_long(p, le);\n\n    default:\n\n        return UINT_MAX;\n\n    }\n\n}\n", "idx": 3158, "substitutes": {"p": ["fp", "php", "d", "cp", "q", "lp", "wp", "op", "jp", "pc", "c", "up", "g", "pm", "P", "pb", "r", "bp", "np", "pi", "pp", "out", "m", "b", "pod", "vp", "at", "pad", "ps", "tp", "ip", "pa", "w", "ap", "pl", "pkg", "post", "pt", "types", "v", "per", "pre", "h", "pers", "f", "par", "t", "ping", "self", "sp"], "type": ["id", "Type", "oid", "ype", "ty", " ty", "et", "dt", "code", "style", "ping", "kind", "link", "family", "info", "pe", " Type", "like", "y", "file", "error", "al", "otype", "e", "role", "name", "ver", "TYPE", " typ", "ity", "class", "types", "what", "range", "ct", "ice", "th", "t", "ime", "inter", "typ"], "le": ["ele", " ty", "l", "ole", "ile", "ke", "let", "lex", "sl", "li", "stable", "ple", "ce", "ne", "led", "pe", "ll", " ele", "ge", " ble", "Le", "el", "ale", "les", "lem", "ity", "tle", "de", "ell", "del", " pe", "sle", "ly", "te", "ve", "ler", " angle", "sol", "se", "ble", "LE"]}}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    int i, quant, level, orientation, quant_idx;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    DiracContext *s = avctx->priv_data;\n\n    DiracSlice *slice = arg;\n\n    GetBitContext *gb = &slice->gb;\n\n\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n\n    quant_idx = get_bits(gb, 8);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++) {\n\n        for (orientation = !!level; orientation < 4; orientation++) {\n\n            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n\n            quants[level][orientation] = quant;\n\n        }\n\n    }\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (i = 0; i < 3; i++) {\n\n        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);\n\n        int64_t bits_left = 8 * length;\n\n        int64_t bits_end = get_bits_count(gb) + bits_left;\n\n\n\n        if (bits_end >= INT_MAX) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,\n\n                               &s->plane[i].band[level][orientation], NULL);\n\n            }\n\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3160, "substitutes": {"avctx": ["avContext", "avctl", "ovcp", "vercp", "vertx", "avconn", "avectx", "avectl", "afjp", "wavtx", "avtx", "avjp", "aveconn", "ovctx", "Avcontext", "afcp", "afctx", " avContext", "navctx", "navcontext", " avctl", " avtx", "wavctx", " avcontext", "navtx", "verjp", "verctx", "avcp", "wavcontext", "wavContext", "Avconn", "avcontext", "avecontext", "Avctl", " avconn", "ovjp", "ovtx", "navContext", "Avctx", "aftx"], "arg": ["doc", "ang", "arr", "jp", "rg", "ay", "slot", "p", "conn", "g", "ref", "pb", "Arg", "pg", "star", "parse", "ge", "ary", "call", "param", "block", "ctx", "spec", "ray", "gate", "gc", "ag", "ar", "reg", "argument", "range", "val", "v", "vol", "arp", "ad", "args", "agg", "obj", "base", "cmd"], "i": ["multi", "j", "id", "q", "interface", "l", "ii", "list", "iq", "ji", "c", "p", "iy", "sim", "n", "xi", "ic", "index", "pi", "me", "ci", "li", "m", "ei", "x", "u", "info", "ui", "gi", "it", "phi", "ij", "ex", "ip", "local", "k", "y", "bi", "im", "e", "hi", "iu", "ti", "ion", "ind", "ix", "dr", "v", "zi", "in", "mi", "ini", "di", "o", "ai", "I", "si", "f", "t", "len", "chain"], "quant": ["total", "cp", "q", "Qual", "xff", "cat", "quad", "percent", "qq", "mix", "cost", "sim", "query", "fac", "qi", "qa", "util", "charge", "hold", "bit", "load", "qt", "volume", "qual", "cur", "qu", "series", "quick", "Q", "requ", "final", "local", "multipl", "compl", "pal", "mult", "imp", "quart", "comp", "spec", "frac", "ind", "gap", "uint", "integer", "priority", "val", "scale", "depth", "good", "alpha", "quality", "direct", "Quant", "quiet", "length", "qua"], "level": ["id", "parent", "height", "load", "lock", "volume", "zero", "version", "ind", "group", "cost", "test", "list", "high", "row", "sequence", "where", "full", "family", "variable", "tag", "location", "tail", "owner", "name", "member", "loc", "what", "depth", "driver", "thread", "rel", "length", "lvl", "le", "l", "style", "all", "half", "index", "broad", "lo", "condition", "finding", "type", "Level", "call", "hi", "el", "go", "priority", "scale", "fail", "low", "loop", "tier", "vel", "col", "VEL", "quality", "point", "ble", "len", "pri", "stack", "mount", "goal", "po", "status", "prop", "layer", "limit", "label", "mode", "pe", "scope", "fall", "local", "role", "levels", "pl", "global", "coll", "print", "frequency", "peer", "lc", "state", "stage", "module"], "orientation": [" orientity", "rotification", "rientality", "orientATION", "drawmentation", "rotoration", "rotate", "orientuation", "designration", "drawotation", "iteration", "rientature", " orientate", "orientization", "designATION", "draworation", "drawature", "innation", "orientations", "orientention", "designational", "rientation", "layoutation", "orientification", "rientations", "iterotation", "designization", "orientate", "elongATION", "rientination", " orientacy", "rientotation", "doorification", "innATION", "designoration", "designation", "iterator", "rototation", "rotator", "directionature", "orientmentation", "orientity", " orientality", "orientality", "designature", "drawation", "drawization", "designmentation", "rotuation", "designification", "innization", "designity", "orientational", " orientification", "iteruation", "layoutotation", "elongification", "orientator", " orientination", "layoutity", "rientoration", "dooration", "rientacy", "directionation", "elongoration", "directionator", "doorention", "rientication", "designotation", "iterination", "rientATION", "innration", "rientification", "rotication", "rientization", "iteracy", "orientotation", "orientacy", "rientity", " orientations", "orientination", "rientator", "doororation", "rientate", "rientuation", "orientication", " orientication", "elongator", "rotation", "iterity", "orientration", "orientature", "rotations", "elongality", "rientational", "elongication", "designention", "elongration", "rientmentation", "elongation", "rotention", "directionization", "orientoration", "elongization", "drawator", "elongature", "directionoration", "layoutational"], "quant_idx": ["quant_Idxc", "quant_indxs", "quant_indxc", "quant_ridxe", "quant_idsx", "quant_Idz", "quant_idez", "quant_idsxe", "quant_edx", "quant_idexc", "quant_Idx", "quant_idxes", "quant_idsxes", "quant_idsxs", "quant_edy", "quant_ridxs", "quant_edxe", "quant_idexs", "quant_edxs", "quant_idz", "quant_ridy", "quant_ridx", "quant_indx", "quant_indxe", "quant_idxe", "quant_indz", "quant_idy", "quant_idxs", "quant_idex", "quant_idxc", "quant_Idxs", "quant_indxes"], "quants": ["acquants", "quaints", "Quants", "quANT", " quaints", "acquANT", "aquats", "Quant", "requats", "aquant", "acquats", " quars", "Quars", "requant", "squant", " quats", "squaints", "acquant", "requants", "aquants", "aquANT", "squants", "quats", "QuANT", "quars", " quANT", "aquars", "requaints", "squats"], "MAX_DWT_LEVELS": ["MAX_DWT_LEFLAGPS", "MAX_DWT_DEPVELOPS", "MAX_DWT_LEVELINS", "MAX_DWT_LEBITINS", "MAX_DWT_DEPBITPS", "MAX_DWT_DEPBITINS", "MAX_DWT_LEFLAGOPS", "MAX_DWT_LEBITOPS", "MAX_DWT_LETHPS", "MAX_DWT_LEVELOPS", "MAX_DWT_DEPVELS", "MAX_DWT_LETHOPS", "MAX_DWT_LEFLAGINS", "MAX_DWT_LEFLAGS", "MAX_DWT_LEVELPS", "MAX_DWT_DEPBITS", "MAX_DWT_LETHINS", "MAX_DWT_DEPVELINS", "MAX_DWT_LEBITS", "MAX_DWT_LEBITPS", "MAX_DWT_LETHS", "MAX_DWT_DEPBITOPS", "MAX_DWT_DEPVELPS"], "s": ["sys", "ls", "j", "S", "stats", "c", "is", "sv", "ss", "p", "scl", "g", "n", "service", "sl", "es", "vs", "r", "ess", "comm", "ds", "qs", "sa", "utils", "sql", "csv", "space", "b", "m", "https", "less", "fs", "set", "sc", "aws", "ps", "its", "parts", "js", "ns", "bs", "conf", "local", "sd", "ims", "w", "sam", "cs", "ts", "ctx", "spec", "hs", "sts", "v", "rs", "single", "h", "gs", "sb", "ats", "ins", "sq", "os", "so", "t", "a", "se", "ssl", "self", "sp"], "slice": ["sis", "batch", "rice", "tile", "piece", "instance", "view", "source", "slot", "Sl", "limit", "sort", "sample", "sl", "service", "node", "set", "join", "link", "ringe", "star", "parse", "clip", "pe", "seq", "volume", "series", "axis", "ser", "pse", "cell", "gem", "call", "save", "copy", "spec", "via", "sci", "cut", "gate", "ray", "range", "scale", "v", "spot", "single", "sel", "ice", "pair", "seed", "slave", "scan", "se", "split", "sp"], "gb": ["sys", "tmp", "gio", "buf", "mb", "vg", "eb", "sg", "rg", "tg", "kb", "py", "g", "gif", "img", "pb", "gpu", "cfg", "cb", "csv", "rb", "gp", "gy", "pg", "b", "gd", "eg", "gt", "storage", "xy", "bs", "hub", "gnu", "buffer", "cv", "goo", "ctx", "bg", "gc", "wb", "bps", "db", "io", "bytes", "bits", "gz", "uv", "GB", "gs", "binary", "sb", "args", "gm", "gg", "nb", "uf", "buff"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_wb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRWBContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 16000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 16000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->last_bitrate    = avctx->bit_rate;\n\n\n\n    avctx->frame_size  = 320;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->state     = E_IF_init();\n\n\n\n    return 0;\n\n}", "idx": 3161, "substitutes": {"avctx": ["avctl", "avergc", "avecb", "avectx", "avectl", "afcfg", "wavcf", "avercontext", "avjac", "ravcoll", "ajhistory", "avertx", "avegc", "avheight", " avctl", "avetxt", "savheight", "wavreq", " avct", "aveheight", "aveprop", "savtxt", "wavpool", "avpkg", "avecontext", "avtxt", "avhistory", "avect", "avercfg", "AVcontext", "wavtx", " avjp", "avtx", "avcu", "ajcu", "ravcu", "wavjp", " avcfg", "ajctx", "avercb", "ajprop", " avcontext", "avgc", "avercc", "afcontext", "avecmp", "ajjac", "avecoll", "avprop", "averjp", "ravcontext", "wavcu", "avercf", " avgc", " avtxt", "avecu", " avcoll", "wavpkg", "savcmp", "avetx", "avct", "wavctx", " avprop", "AVtx", "AVctx", "avecf", "ajcc", "avcc", "avcb", "avcfg", "savctx", "wavcb", "avepool", " avcmp", "wavgc", "afcc", "ravpkg", "avjp", "ajctl", "afctx", "ravhistory", "ajcontext", "avejac", "wavcfg", "avecfg", "averpool", "ravgc", " avtx", "AVct", "avereq", "wavcontext", "ajcfg", "ajpkg", " avjac", "avcontext", "afjac", "avcf", "avreq", " avcu", "avcoll", " avheight", "averreq", "avpool", "avcmp", "averctx", "wavhistory", "ravctx"], "s": ["sys", "ls", "j", "S", "d", "stats", "c", "is", "sv", "ss", "p", "es", "g", "r", "ess", "set", "ds", "qs", "m", "i", "b", "fs", "gets", "aws", "ps", "its", "js", "bs", "ns", "e", "ms", "as", "ports", "cs", "ts", "spec", "changes", "hs", "sts", "eps", "rs", "v", "h", "pers", "gs", "ats", "ins", "sq", "os", "t", "acs"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n", "idx": 3162, "substitutes": {"q_ptr": ["sq__tr", "q__ref", " q_pos", "sq__ptr", "sq__pad", "sq_ref", "q_pad", " q_Ptr", "sq_ptr", "q_ref", "sq_pad", "q_Ptr", "q__tr", "q_pos", "q__pad", "q_tr", "sq_tr", " q_tr", "sq__ref", "q__ptr"], "num": ["total", "number", "nam", "net", "temp", "mon", "tim", "no", "alph", "non", "uni", "p", "cal", "n", "result", "np", "index", "set", "m", "sum", "Num", "msg", "zero", "t", "final", "um", "Number", "en", "mult", "nom", "con", "nm", "un", "offset", "val", "NUM", "on", "du", "nu", "current", "done", "f", "dim", "na", "bn", "missing", "nb", "eng", "len"], "den": ["zan", "ki", "mon", "fam", "cal", "window", "deg", "mont", "dem", "quist", "dat", " DEN", "fin", "rown", "pen", "DEN", "dra", "arden", "gen", "don", "dev", "zen", "ven", "perm", "der", "en", "con", "len", "ind", "Den", "un", "mn", "bill", "ten", " len", "wen", "mat", " Den", "di", "nu", "fen", "dim", "rem", "una", " denomin", "mem", "length", "dn"]}}
{"project": "FFmpeg", "commit_id": "69ee915e1c628fdf8b270de8c19ff357333e354a", "target": 1, "func": "void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)\n\n{\n\n    int i;\n\n\n\n    s->dts    =\n\n    s->pts    = AV_NOPTS_VALUE;\n\n    s->pos    = -1;\n\n    s->offset = 0;\n\n    for (i = 0; i < AV_PARSER_PTS_NB; i++) {\n\n        if (s->cur_offset + off >= s->cur_frame_offset[i] &&\n\n            (s->frame_offset < s->cur_frame_offset[i] ||\n\n             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame\n\n            // check disabled since MPEG-TS does not send complete PES packets\n\n            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){\n\n\n\n            s->dts    = s->cur_frame_dts[i];\n\n            s->pts    = s->cur_frame_pts[i];\n\n            s->pos    = s->cur_frame_pos[i];\n\n            s->offset = s->next_frame_offset - s->cur_frame_offset[i];\n\n            if (remove)\n\n                s->cur_frame_offset[i] = INT64_MAX;\n\n            if (s->cur_offset + off < s->cur_frame_end[i])\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 3176, "substitutes": {"s": ["ls", "c", "aunts", "p", "es", "ses", "set", "params", "services", "its", "t", "ports", "cs", "spec", "ains", "ags", "h", "gs", "sb", "args", "os", "stats", "sv", "vs", "details", "xs", "ess", "ds", "qs", "ants", "less", "bs", "ims", "bis", "sam", "search", "bes", "hs", "sts", "eps", "pers", "ins", "states", "sq", "aus", "sync", "acs", "S", "er", "ss", "als", "comm", "space", "ns", "sw", "y", "save", "ms", "ts", "changes", "ares", "se", "ops", "ssl", "sys", "status", "is", "g", "sql", "fs", "aws", "ps", "parts", "js", "ads", "comments", "as", "sports", "has", "rs", "bits", "ats", "state"], "off": ["ff", "head", "op", "shift", "offer", "ext", "p", "before", "from", "ow", "after", "eff", "out", "set", "oa", "aff", "pos", "start", "over", "ok", "it", "def", "extra", "pad", "ex", "OFF", "oc", "end", "ap", "a", " offset", "Offset", "offs", "offset", "un", "ov", "on", "o", "f", "reset", "raw", "Off", "t", "of", "push", "uf", "cmd"], "i": ["multi", "batch", "j", "id", "l", "ii", "ki", "status", "ji", "iri", "is", "p", "sim", "g", "n", "init", "xi", "ic", "pi", "index", "iter", "ski", "li", "ci", "me", "m", "x", "cli", "us", "ui", "info", "phi", "it", "gi", "vi", "ij", "series", "ip", "oi", "y", "ims", "bi", "im", "e", "hi", "iu", "ti", "span", "ind", "uri", "io", "ix", "v", "zi", "in", "mi", "ini", "di", "\u0438", "ai", "I", "si", "dim", "ri", "json", "chain"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 3179, "substitutes": {"i": ["id", "try", "init", "li", "x", "series", " ti", "iu", "ti", "ind", " hi", "ix", "zi", "ini", "I", "f", "this", " bi", "batch", "list", " j", "xi", "ic", "m", " n", "ui", "it", " index", "ims", " p", " v", " li", " t", "io", "\u0438", "ri", "chain", "j", " m", "ii", " mi", "ji", "z", "pi", "asi", "me", "index", "ci", " c", "info", "phi", "ij", " ii", "y", " pi", "bi", " I", "mi", "di", "ai", "si", "multi", "ki", "status", "is", "sim", " di", "cli", "gi", " si", "ip", " l", " x", "e", "in", " multi"], "encoded": ["Enccoded", "enached", "decoded", "entoding", "encrypted", "ecoder", "enoded", "eccoded", "ENCressed", "entrypted", "decached", "deccoded", "enoder", "ENCoded", "uncoded", "decressed", "decrypted", "Encoder", "uncached", "Encoded", "unccoded", "ecached", "encressed", "ENCached", "uncrypted", "encoder", "enccoded", "encached", "encoding", "Encoding", "ENCoder", "entoded", "entoder", "decoding", "ecoding", "entcoded", "ecrypted", "enressed", "enrypted", "decoder", "ecoded", "enoding"], "test_cases": ["testxcases", "test8cases", "test__cases", "test_times", "test8cs", "test67cases", "test8cards", " test_case", "test__case", "test_packs", "searchencs", "testencases", "testencs", "load_chains", "test_case", "test8config", "test67cycles", "test_needs", "load_packs", "test_cards", "load___cases", "test8windows", "test67packs", "search_config", "testxcas", "testxtests", " test_tests", "est8cards", "test__tests", "searchencases", "est8cases", "test___chains", "testenconfig", "searchenconfig", "test__times", "load_cases", "search_cases", "test8times", "test_cycles", "test_cs", " test_cas", "test___cases", "test_tests", "test___packs", "est8series", "test_series", "test_config", "search_windows", "test___cycles", "test_windows", "test_cas", "est8times", " test_times", "load___chains", " test_needs", "load___packs", "searchenwindows", "search_cs", "est_cards", "testenwindows", "est_cases", "test67chains", "load___cycles", "test8series", "testxneeds", "est_series", "test_chains", "load_cycles", "est_times"], "obj": ["j", "cod", "inst", "func", "po", "tmp", "ut", "arr", "obo", "bj", "addr", "object", "buf", "conn", "py", "dict", "init", "attr", "ref", "txt", "onet", "og", "out", "rb", "act", "ox", "res", "pos", "orig", "msg", "adj", "obs", "it", "def", "cmp", "att", "pr", "xy", "js", "wo", "opt", "xxx", "err", "ctx", "con", "Obj", "ind", "ob", "bo", "pt", "alt", "null", "nt", "bl", "o", "expr", "rel", "src", "__", "ot", "ck", "resp", "elt", "t", " Obj", "cmd", "buff"], "str": ["mt", "br", "j", "ctr", "cr", "arr", "buf", "text", "n", "sl", "txt", "Str", "s", "r", "res", "msg", "cont", "seq", "pr", "js", "ns", "sw", "ts", "fr", "name", "cs", "STR", "pt", "print", "rs", "nt", "vol", "bl", "wr", "tr", "st", "t", "sp"]}}
{"project": "qemu", "commit_id": "0857a06ef784783887e756d4b7b5f874512c506c", "target": 1, "func": "static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    } else if (!(sregnames[sr].access & access)) {\n\n        static const char * const access_text[] = {\n\n            [SR_R] = \"rsr\",\n\n            [SR_W] = \"wsr\",\n\n            [SR_X] = \"xsr\",\n\n        };\n\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n\n                access_text[access]);\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n", "idx": 3180, "substitutes": {"dc": ["ec", "vc", "d", "cp", "cr", "cd", "fc", "c", "pc", "bc", "nc", "DC", "cms", "ca", "ic", "ci", "mc", "ds", "KC", "dat", "sc", "dm", "oc", "cf", "df", "cs", "ctx", "gc", "dr", "cc", "di", "dp", "ct", "disc", "draw", "cm", "rc", "lc", "ac", "da", "tc", "cca"], "sr": ["mr", "sys", "br", "usr", "ctr", "gr", "cr", " rg", "lr", "rg", "nr", "vr", "sv", "hr", "rid", "ran", "sort", "r", "ru", "sf", "rb", " sy", " Sr", " dr", "rw", " scr", "pr", "yr", " yr", "syn", "sur", "ser", "sw", "kr", "rf", "hl", "gor", " shr", "SR", "fr", "rr", "rx", "adr", "ir", " gr", "rl", "rt", "spr", "via", "str", "ry", "rs", "rm", " rm", " radius", "src", "rem", "tr", "sb", " hr", "ire", " ir", "serv", "rar", "rn", "sn"], "access": ["Access", "use", "ccess", "ext", "route", "read", "path", "x", "sc", "request", "accessible", "xp", "cast", "pass", "est", "az", "a", "key", "ACC", "cess", "ast", "row", "upload", "act", "assert", "esc", "export", "usage", "mod", "ex", "name", "press", "display", "acc", "ace", "reach", "flow", "view", "z", "seek", "index", "fac", "ax", "sa", "cache", "priv", "ord", "att", "sw", "rage", "call", "error", "ag", "aud", "exec", "status", "aw", "stat", "attr", "ca", "util", "ache", "url", "asc", "config", "release", "ress", "ha", "connect", "allow", "ac", "state", "area"], "access_text": ["access_ind", "access_txt", "access___txt", " access_txt", "Access_TEXT", " access2ind", " access_ext", " access_Text", " access2txt", "Access2txt", "access___text", "access_ext", "access___ext", "acc_ext", " access2ext", "access2text", "access2form", "access2code", "access2ext", "acc_code", "Access2TEXT", " access_ind", "access2TEXT", "access_Text", "Access2form", "Access_form", "access___Text", "access2txt", "Access_text", " access2text", "acc_txt", "Access_txt", "access2Text", "access2ind", "acc_text", "access_code", "access_form", "Access2text", "access_TEXT"]}}
{"project": "qemu", "commit_id": "e41029b378b4a65a0b89b5a8dc087aca6b5d012d", "target": 1, "func": "static void gen_lswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    int start = rD(ctx->opcode);\n\n    int ra = rA(ctx->opcode);\n\n    int nr;\n\n\n\n    if (nb == 0)\n\n        nb = 32;\n\n    nr = (nb + 3) / 4;\n\n    if (unlikely(lsw_reg_in_range(start, nr, ra))) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(start);\n\n    gen_helper_lsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n", "idx": 3182, "substitutes": {"ctx": ["proc", "cp", "ctr", "work", "cas", "wcs", "ctrl", "today", "jp", "c", "xc", "nc", "bc", "unc", "cn", "conn", "p", "kb", "hw", "ca", "np", "txt", "bp", "cfg", "crit", "cb", "act", "gp", "pg", "x", "tx", "kt", "sc", "etc", "cur", "req", "cmp", "ctl", "kw", "conf", "desc", "cf", "context", "cv", "mk", "wd", "xp", "dl", "cpu", "gc", "pkg", "std", "obj", " cx", "cc", "nt", "cu", "wx", "ct", "gz", "cl", "cm", "ck", "resp", "lc", "prefix", "tc", "jac", "cmd"], "t0": ["tt19", "wtZero", "TZero", "dt0", " T0", "t19", "wt1", " t19", "wt000", " T1", " T2", "T1", " Toot", "t00", "tZero", "Tzero", " toot", "tt2", "pt000", " pt0", "T00", " t000", "pt0", " tzero", "dt000", " t00", "T000", "toot", "T19", "t000", "dt1", "dt00", "pt1", "ptZero", "T2", "tt0", " pt1", "wt0", " pt2", " ptoot", "T0", "ptzero", "tzero", "tt1"], "t1": ["temp001", "tm1", "nt1", " t001", "text001", "tmson", " t9", "tmONE", "text1", "temp2", "tson", "T1", "td61", "tempONE", "ttONE", "T61", " tONE", "n001", "tt2", " t61", "nt9", "none", "T9", "tone", " tOne", "temp1", " tone", " tson", "ntson", "tm9", "ntONE", "t001", "tONE", "n1", "textone", "TOne", "t9", "tt001", "n2", "td9", "t61", "text2", "tt1", "tOne", "td1", "tdOne"], "t2": ["tttwo", "tetwo", " t256", "wt2", "t12", "wt12", "ttwo", "tt256", "T1", " t3", "te2", "ot02", "tt2", "l3", "t3", "t72", "t5", "t02", "pt5", " ttwo", "dttwo", "dt2", "T5", "ot2", "Ttwo", "ottwo", "ts2", "ot256", "l1", "dt1", "tstwo", "pt1", "T3", "T2", "te12", "wttwo", "l2", "pt2", "ts12", "dt3", "wt72", "tt02", " t02", "ts72", "t256", "l5", "te72", "pt3"], "nr": ["mr", "sys", "ni", "ny", "br", " NR", "gr", "number", "no", "next", "nl", "uj", "n", "np", "r", "ng", "Ni", "cb", "res", "nv", "num", "nw", "ne", "ns", "kr", "sr", "ptr", "rr", "adr", "nm", "arity", "range", " ni", "nz", "wr", "NR", "nu", "nir", "nn", "nie", "ri", "nor", "nb", "byter", "rn", "sn"]}}
{"project": "FFmpeg", "commit_id": "c61b28e0421f0f9502dfb21495a03cda191def15", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,\n\n                        float **out_samples)\n\n{\n\n    ATRAC3Context *q = avctx->priv_data;\n\n    int ret, i;\n\n    uint8_t *ptr1;\n\n\n\n    if (q->coding_mode == JOINT_STEREO) {\n\n        /* channel coupling mode */\n\n        /* decode Sound Unit 1 */\n\n        init_get_bits(&q->gb, databuf, avctx->block_align * 8);\n\n\n\n        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,\n\n                                        JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Framedata of the su2 in the joint-stereo mode is encoded in\n\n         * reverse byte order so we need to swap it first. */\n\n        if (databuf == q->decoded_bytes_buffer) {\n\n            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;\n\n            ptr1          = q->decoded_bytes_buffer;\n\n            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)\n\n                FFSWAP(uint8_t, *ptr1, *ptr2);\n\n        } else {\n\n            const uint8_t *ptr2 = databuf + avctx->block_align - 1;\n\n            for (i = 0; i < avctx->block_align; i++)\n\n                q->decoded_bytes_buffer[i] = *ptr2--;\n\n        }\n\n\n\n        /* Skip the sync codes (0xF8). */\n\n        ptr1 = q->decoded_bytes_buffer;\n\n        for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {\n\n            if (i >= avctx->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n\n\n        /* set the bitstream reader at the start of the second Sound Unit*/\n\n        init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1);\n\n\n\n        /* Fill the Weighting coeffs delay buffer */\n\n        memmove(q->weighting_delay, &q->weighting_delay[2],\n\n                4 * sizeof(*q->weighting_delay));\n\n        q->weighting_delay[4] = get_bits1(&q->gb);\n\n        q->weighting_delay[5] = get_bits(&q->gb, 3);\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i];\n\n            q->matrix_coeff_index_now[i]  = q->matrix_coeff_index_next[i];\n\n            q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2);\n\n        }\n\n\n\n        /* Decode Sound Unit 2. */\n\n        ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],\n\n                                        out_samples[1], 1, JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Reconstruct the channel coefficients. */\n\n        reverse_matrixing(out_samples[0], out_samples[1],\n\n                          q->matrix_coeff_index_prev,\n\n                          q->matrix_coeff_index_now);\n\n\n\n        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);\n\n    } else {\n\n        /* single channels */\n\n        /* Decode the channel sound units. */\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            /* Set the bitstream reader at the start of a channel sound unit. */\n\n            init_get_bits(&q->gb,\n\n                          databuf + i * avctx->block_align / avctx->channels,\n\n                          avctx->block_align * 8 / avctx->channels);\n\n\n\n            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],\n\n                                            out_samples[i], i, q->coding_mode);\n\n            if (ret != 0)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    /* Apply the iQMF synthesis filter. */\n\n    for (i = 0; i < avctx->channels; i++) {\n\n        float *p1 = out_samples[i];\n\n        float *p2 = p1 + 256;\n\n        float *p3 = p2 + 256;\n\n        float *p4 = p3 + 256;\n\n        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);\n\n        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);\n\n        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3183, "substitutes": {"avctx": ["Avcmp", "avctl", "avectx", "avectl", "ajcmp", "Avcontext", "avjac", "abcmp", " avctl", "aveca", " avca", "afca", "avca", "evtx", "ajgc", "wavjac", "avpkg", "avecontext", "evcmp", "afpkg", " avdocument", "avercfg", "AVcontext", "averpkg", "avesys", "avconfig", "absys", "avsys", "wavtx", "avtx", "ajtx", "ajctx", "abctx", "Avtx", " avcontext", "avgc", "evcontext", "afcontext", "avecmp", "ajjac", "Avctx", "ravcontext", "abgc", "aveconfig", "abcmd", "avedocument", "aversys", "afgc", "avepkg", "AVcmp", "wavctl", "wavctx", "AVtx", "evctx", "AVctx", "avercmd", "abjac", "averjac", "abctl", "abtx", " avcmd", "avcfg", "avcmd", "abpkg", " avconfig", " avcmp", "ajctl", "afctx", "afctl", "avejac", "avercmp", "abcontext", "avecfg", " avpkg", "ravdocument", " avtx", "ajcfg", "ajpkg", "avcontext", "avdocument", "avecmd", "ravconfig", "avcmp", "averctx", "ravctx"], "databuf": ["Datobull", "datobuff", "databsuffer", "dataabof", "datABulk", "datobull", "databbuf", "datablbuf", "datABuf", "databsof", "datABull", "databof", "Datobuffer", "databuffer", " datobuch", "databanduch", "datahof", "databluf", " datobuffer", "datobuf", " datobuf", "databluff", "datablof", "databsuff", " datobuff", "dataabluf", "databsull", "databsuf", " datobulk", " databbuf", "datobuffer", "dataabbuf", " databulk", "datahbuf", "Datobuf", "databluffer", "dataabuff", "datABuffer", "databuch", "databandbuf", "databanduf", "Databuf", "datABbuf", "datahuf", "Databbuf", " databuff", "datobbuf", "databsbuf", "databandulk", "databulk", "dataablof", "dataabuf", "datABuch", "databull", "Databull", "Databuffer", "datahuff", "databuff", "datobuch", "datobulk", " databuffer", "dataabluff", "dataablbuf", " datobbuf", " databuch", "Datobbuf"], "out_samples": ["out_Sources", "out_swings", "out_nings", "out_sources", "out_nources", "out_examps", "out_samps", "out_nounds", "out_swamples", "out_sounds", "out_swamps", "out_swources", "out_examples", "out_sings", "out_Sings", "out_Samples", "out_Samps", "out_exounds", "out_exources", "out_namples", "out_namps"], "q": ["cp", "c", "qv", "p", "window", "pg", "form", "qt", "req", "qu", "dq", "Q", "conf", "k", "cf", "pkg", "que", "queue", "ry", "h", "f", "ck", "my", "ht", "kg", "qi", "qa", "ue", "qs", "m", "ox", "question", "check", "ll", "quer", "requ", "quit", "sq", "quant", "self", "j", "cat", "l", "iq", "er", "view", "z", "all", "quest", "comm", "info", "etc", "cache", "aq", "y", "hl", "ctx", "eq", "v", "client", "ve", "quality", "gm", "think", "qq", "tt", "g", "query", "r", "pp", "tx", "quick", "config", "ch", "quote", "cl", "t", "obj"], "ret": ["mt", "j", "RET", "net", "try", "tmp", "arr", "value", "f", "Return", "ext", " RET", "result", "ref", "txt", "r", "deg", "nil", "out", "res", "lit", "over", "cont", "gt", "def", "mem", "att", "tf", "Ret", "not", "xt", "err", "ruby", "tn", "rt", "re", "alt", "ter", "reg", "print", "val", "rm", "rets", "nt", "det", "rem", "reset", "flag", "tr", "resp", "elt", "t", "len"], "i": ["multi", "j", "id", "ni", "try", "l", "ii", "ki", "ji", "is", "p", "sim", "g", "n", "xi", "ic", "pi", "index", "me", "qi", "iter", "ci", "li", "ami", "m", "ei", "b", "x", "cli", "us", "ui", "gi", "it", "phi", "at", "ij", "ex", "ip", "oi", "fi", "y", "ims", "bi", "im", "e", "hi", "iu", "ti", "name", "ir", "ind", "uri", "io", "ix", "dr", "v", "print", "zi", "in", "mi", "ini", "di", "\u0438", "by", "ai", "I", "si", "f", "ri", "t", "mc", "inter"], "ptr1": ["addr1", " ptr0", "pr01", "Ptr1", "Ptr4", "pointer3", " ptr001", "ptr001", "addr4", "tr8", "Ptr2", " ptr91", " ptrN", "pointer0", "Ptr8", "pointer8", "tr5", "pt4", "pointer01", "pointer91", "tr4", "addr2", "pr4", "pt8", "ptOne", "pointer001", "ptr91", "ptr8", "pointer4", "Ptr3", "pt0", "pr2", "ptr01", "pointer2", "ptr4", "tr2", " ptr01", "Ptr91", "ptr5", "prN", "addr3", "pt1", "pr5", "addr8", "PtrOne", "pr001", "ptr0", "pointer1", "trN", "pt2", "pointerOne", "pr1", "Ptr0", "addr0", " ptr3", " ptr5", "tr1", "pr0", "ptr3", "ptrOne", "ptrN", "pt3"], "ptr2": ["tipTwo", "pert5", "pointer512", "pert512", "Ptr1", "tip2", "pointer3", "Ptr2", "pointer5", "tr5", "trTwo", "ptrTwo", "pt02", "ptr02", "prTwo", "pt3", "pr2", "pointer6", "pr6", "pointer2", "tip02", "tr2", "Ptr5", "Ptr6", "ptr6", "pt512", "ptr5", "varTwo", "pr5", "pt1", "var1", "var2", "pointer1", "pert3", "pt2", "pr1", "pr02", "tr02", "ptTwo", "ptr512", "tr1", "pert2", "var02", "ptr3", "pert1"]}}
{"project": "qemu", "commit_id": "367790cce8e14131426f5190dfd7d1bdbf656e4d", "target": 1, "func": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n", "idx": 3184, "substitutes": {"env": ["eas", "ev", "window", "server", "app", "iter", "ner", "ef", "context", "here", "equ", "manager", "console", "answer", "te", "era", "ec", "operator", "vs", "viron", "environment", "esc", "neck", "shell", "end", "den", "gate", "ter", "ew", "uv", "enc", "er", "buf", "code", "gear", "addr", "all", "eh", "ah", "engine", "ei", "eni", "entry", "esi", "dev", "err", "ende", "el", "en", "ctx", "db", "v", "eco", "client", "erd", "ve", "worker", "exec", "map", "et", "conn", "query", "txt", "tx", "config", "local", "desc", "w", "e", "vert", "global", "ell", "event", "ee", "peer", "obj", "eve"], "val": ["data", "q", "test", "l", "item", "value", "buf", "z", "Val", "p", "ref", "vals", "b", "x", "tx", "valid", "seq", "VAL", "base", "state", "local", "al", "ival", "buffer", "eval", "pt", "loc", "v", "vol", "bl", "arg", "elt", "t", "mem", "serv"], "shift": ["data", "j", "ff", "add", "hide", "skip", "size", "use", "jp", "count", "step", "sh", "mask", "p", "slice", "sign", "init", "window", "index", "out", "set", "align", "hift", "send", "reverse", "sum", "pack", "force", "start", "off", "ignore", "pad", "time", "axis", "sub", "length", "opt", "transform", "block", "update", "save", "diff", "ptr", "move", "shr", "pop", " shifted", "Shift", "loc", "offset", " shifts", "scale", "hash", "h", "field", "help", "tr", "flag", "seed", "sq", "push", "sleep", "share"], "temp": ["j", "min", "mint", "fake", "test", "tmp", "Temp", "tim", "size", "count", "z", "perature", "p", "unt", "term", "n", "attr", "window", "fac", "txt", "emp", "mp", "out", "memory", "m", "dat", "sum", "em", "stem", "orig", "cache", "tm", "time", "ta", "map", "cap", "local", "ptr", "buffer", "ts", "len", "dest", "pt", "partial", "v", "pre", "max", "tr", "make", "t", "mem", "tem"], "result": ["success", "data", "total", "number", "message", "test", "tmp", "comb", "match", "status", "value", "count", "jp", "next", "p", "nil", "r", "fac", "power", "out", "sequence", "table", "memory", "res", "sum", "x", "reverse", "pack", "relation", "new", "cache", "cur", "zero", "output", "final", "block", "comment", "error", "buffer", "command", "search", "ptr", "response", "complete", "true", "integer", "v", "results", "done", "ret", "current", "root", "Result", "tr", "make", "rc", "mate", "t", "length", "sp"]}}
{"project": "qemu", "commit_id": "95ce326e5b47b4b841849f8a2ac7b96d6e204dfb", "target": 1, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tstrcpy(term_cmd_buf, term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_printf(\"\\n\");\n\n    term_print_cmdline(term_cmd_buf);\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 3205, "substitutes": {"term_hist_entry": ["term_hist_deep", "term_hist_key", "term_hist___deep", "term_history_system", "term_histingmatch", "term_history_offset", "term_history_char", "term_hist___entry", "term_histingentry", "term_hist_offset", "term_histingkey", "term_histingno", "term_hist_char", "term_history_entry", "term_history_no", "term_hist_id", "term_hist___no", "term_hist_match", "term_history_id", "term_history_key", "term_hist_element", "term_hist_no", "term_history_match", "term_history_element", "term_history_deep", "term_hist_system"]}}
{"project": "FFmpeg", "commit_id": "3d2c3ef4b46d96023d6f0d358e4d7d65568da67c", "target": 0, "func": "static int decode_cabac_mb_cbp_luma( H264Context *h) {\n\n    int cbp_b, cbp_a, ctx, cbp = 0;\n\n\n\n    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;\n\n    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;\n\n\n\n    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);\n\n    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;\n\n    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;\n\n    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;\n\n    return cbp;\n\n}\n", "idx": 3211, "substitutes": {"h": ["q", "zh", "l", "he", "high", "ph", "c", "host", "bh", "sh", "p", "kh", "hr", "eh", "hw", "oh", "ah", "H", "hh", "her", "comm", "hp", "header", "b", "x", "info", "dh", "ih", "history", "dev", "http", "ch", "hl", "hd", "rh", "hi", "here", "each", "hal", "hm", "hs", "has", "hz", "v", "ha", "hash", "ho", "th", "gh", "ht"], "cbp_b": ["cbpTb", "cbpTa", "cbtp_b", "cbpt___rb", "cbtp_____bb", "cbtp_____x", "cbper_ab", "cbp___ba", "cbtp_____ba", "cbtp_ba", "cbpt_rb", "cbp_cb", "cbp_ab", "cbtp_x", "cbp_x", "cbp_rb", "cbp___d", "cbper_cb", "cbp_ba", "cbpt___a", "cbp_bb", "cbp_bs", "cbtp_____b", "cbp___cb", "cbtp_bb", "cbp_____bb", "cbpa_b", "cbp_sb", "cbpt___b", "cbpt___d", "cbp_d", "cbpt_a", "cbpt_b", "cbpTsb", "cbper_ba", "cbpt_d", "cbp_____ba", "cbper_b", "cbp___a", "cbpa_a", "cbpTbs", "cbp_____x", "cbp_____b", "cbp___ab", "cbp___b", "cbpa_bs", "cbp___rb", "cbpa_sb"], "cbp_a": ["cbp___both", "cbpa00app", "cbpad_l", "cbc_oa", "cbp48sa", "cbpad_a", "cbpad___a", "cbp___ga", "cbjp___as", "cbp_as", "cbp_both", "cbpad___u", "cbp___sa", "cbpad_u", "cbpa00era", "cbp_oa", "cbjp_b", "cbp00era", "cbp00la", "cbc___sa", "cbjp_ga", "cbpad___l", "cbp48oa", "cbp__a", "cbp_ga", "cbp_app", "cbp___l", "cbp_u", "cbp___as", "cbp00app", "cbp_la", "cbjp_a", "cbp48both", "cbp__l", "cbc___a", "cbpa_era", "cbp___oa", "cbp48a", "cbp___a", "cbc___oa", "cbpa_app", "cbpa_a", "cbp_l", "cbjp___ga", "cbc_sa", "cbp___u", "cbp__u", "cbp_sa", "cbp00a", "cbp_era", "cbc_both", "cbpa00a", "cbpa00la", "cbc___both", "cbjp_as", "cbjp___b", "cbc_a", "cbp___b", "cbjp___a", "cbpa_la"], "ctx": ["doc", "j", "cp", "ctr", "cas", "wcs", "temp", "tmp", "jp", "addr", "nc", "bc", "port", "unc", "conn", "kh", "dc", "ca", "window", "np", "txt", "kl", "kk", "qa", "cfg", "kj", "pause", "act", "pg", "tx", "msg", "sc", "check", "req", "cmp", "history", "tz", "gas", "kw", "ctl", "pa", "desc", "hd", "context", "cv", "wd", "ptr", "except", "pkg", "ind", "gc", "bo", "std", "loc", "obj", "cu", "cc", "urg", "nt", "nz", "wx", "ct", "gz", "rc", "na", "Context", "lc", "timeout", "prefix", "iat", "thread", "tc", "jac", "cmd", "ht"]}}
{"project": "FFmpeg", "commit_id": "f0adb99d068e659178c00271a46cd469dfc01a6e", "target": 1, "func": "void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    QSVFrame *cur;\n\n    AVPacket pkt;\n\n    int ret = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n\n\n    if (q->reinit_pending) {\n\n        close_decoder(q);\n\n    } else if (q->engine_ready) {\n\n        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode get param error %d\\n\", ret);\n\n        }\n\n\n\n        ret = MFXVideoDECODE_Reset(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode reset error %d\\n\", ret);\n\n        }\n\n\n\n        /* Free all frames*/\n\n        cur = q->work_frames;\n\n        while (cur) {\n\n            q->work_frames = cur->next;\n\n            av_frame_free(&cur->frame);\n\n            av_freep(&cur);\n\n            cur = q->work_frames;\n\n        }\n\n    }\n\n\n\n    /* Reset output surfaces */\n\n    av_fifo_reset(q->async_fifo);\n\n\n\n    /* Reset input packets fifo */\n\n    while (av_fifo_size(q->pkt_fifo)) {\n\n        av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL);\n\n        av_packet_unref(&pkt);\n\n    }\n\n\n\n    /* Reset input bitstream fifo */\n\n    av_fifo_reset(q->input_fifo);\n\n}\n", "idx": 3227, "substitutes": {"avctx": ["averpkg", "ajwcs", "avcli", "avectx", "avercf", "avercpp", "cvcmp", "avewcs", "avercfg", "cvcli", "Avcontext", "avercontext", "avcpp", "avercli", "ajctx", " avhw", "avercmp", "avecfg", "avecpp", " avpkg", "averhw", " avcontext", "Avpkg", "ajcpp", "avecf", "cvcfg", "avcontext", "avcf", "avpkg", "averwcs", "Avhw", "avecmp", "avecli", "ajcf", "avcfg", "avhw", "avwcs", "avcmp", "averctx", "Avctx", "cvctx"], "q": ["j", "l", "iq", "c", "web", "qq", "z", "p", "g", "quest", "ev", "query", "r", "qi", "qa", "pp", "comm", "ue", "qs", "i", "question", "parse", "form", "msg", "lock", "qt", "check", "cache", "aq", "req", "qu", "quick", "dq", "Q", "requ", "conf", "local", "k", "ch", "cf", "w", "e", "quit", "ctx", "quote", "pkg", "eq", "que", "queue", "v", "ry", "in", "h", "cl", "f", "ve", "ck", "sq", "gm", "t", "subject", "cmd", "self"], "cur": ["cp", "ctr", "gr", "try", "tmp", "c", "ren", "focus", " curs", "pg", "ur", "req", "sur", "cf", "ver", "comp", "con", "round", "ret", "serv", "ctrl", "count", "bc", "next", "row", "result", "open", "occ", "stable", "coord", " Cur", "cmp", "ptr", "rec", "gc", "rev", "loc", "max", "tr", "grow", "self", "cor", "cat", "cr", "buf", "nc", "fac", "new", "Cur", "kw", "compl", "ctx", "str", "old", "last", "current", "col", "rc", "gov", "cmd", "pri", "cycle", "ph", "arr", "r", "cont", "orig", "car", "ser", "ch", "desc", "cv", "igh", "now", "dr", "rs", "ct"], "pkt": ["packvc", "Packet", "paacket", "ppft", "wqt", " pct", " pet", "pft", "packqt", " pck", "twk", "pack", " pwk", "packacket", " pft", "tet", "Pkt", "tkt", "ppkt", "packwk", "pakt", "tacket", "paft", "packet", "pct", "mqt", "wct", "Pct", "packkt", " packet", "pvc", "pqt", "pwk", "pck", "pet", " pqt", "mvc", "mkt", "macket", "wkt", "ppck", "Pqt", "wacket", "ppacket", " pvc"]}}
{"project": "qemu", "commit_id": "0fcec41eec0432c77645b4a407d3a3e030c4abc4", "target": 1, "func": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 3228, "substitutes": {"a": ["d", "ma", "c", "A", "ach", "aaa", " A", "p", "n", "la", "ca", "ab", "aa", "r", "app", "sa", "oa", "m", "va", "ra", "au", "at", "y", "e", "ae", "area", "ea", "as", "ity", "ba", "ar", "an", "ia", "am", "f", "ac", "al", "apa"], "b": ["d", "j", "l", "nb", "eb", "c", "bc", "z", "p", "g", "n", "ab", "r", "s", "cb", "rb", "m", "i", "x", "be", "u", "bb", "bs", "y", "bi", "e", "ba", "db", "fb", "v", "o", "B", "f", "sb", "t"], "x0": ["wx000", "ox00", " ax50", " axZero", "txthis", "xx5", " x5", "tx10", "x10", "x5", "exZero", "ixthis", "xthis", " ax0", "wx0", "x4", "x50", " x00", "xarg", "xZero", "tx8", "ix8", "ex1", "ex50", "rx5", " ax1", "rx0", "tx00", "x8", "tx1", " x10", "rx10", "x2", "ix4", "xx1", "txarg", "exarg", "wx1", "tx5", "tx2", " x2", "ox0", "rx2", "x00", "ix1", "ix0", " x8", "tx4", "ox1", "ixarg", "tx0", "wx2", " x000", " xthis", "tx50", "ex4", "xx0", "rx1", "ox50", " x50", " xZero", "x000", "ex0", "tx000"], "x1": ["rx01", " cx0", "xx7", "xx4", "ex3", " cx7", "wx0", "x4", "ex1", " x01", "rx0", "x3", "tx1", "x2", "xx1", "X0", "tx3", "wx1", "exone", " x2", "xxone", " x3", "X2", "rx2", "wxone", "x7", "tx4", " x4", "xone", "tx0", "x01", "wx3", "xx0", " cx1", "X1", "rx1", " xone", " cxone", "ex0", "X01", " x7", "xx3"]}}
{"project": "qemu", "commit_id": "898248a32915024a4f01ce4f0c3519509fb703cb", "target": 1, "func": "static void xhci_reset(DeviceState *dev)\n\n{\n\n    XHCIState *xhci = XHCI(dev);\n\n    int i;\n\n\n\n    trace_usb_xhci_reset();\n\n    if (!(xhci->usbsts & USBSTS_HCH)) {\n\n        DPRINTF(\"xhci: reset while running!\\n\");\n\n    }\n\n\n\n    xhci->usbcmd = 0;\n\n    xhci->usbsts = USBSTS_HCH;\n\n    xhci->dnctrl = 0;\n\n    xhci->crcr_low = 0;\n\n    xhci->crcr_high = 0;\n\n    xhci->dcbaap_low = 0;\n\n    xhci->dcbaap_high = 0;\n\n    xhci->config = 0;\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i+1);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        xhci_port_update(xhci->ports + i, 0);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numintrs; i++) {\n\n        xhci->intr[i].iman = 0;\n\n        xhci->intr[i].imod = 0;\n\n        xhci->intr[i].erstsz = 0;\n\n        xhci->intr[i].erstba_low = 0;\n\n        xhci->intr[i].erstba_high = 0;\n\n        xhci->intr[i].erdp_low = 0;\n\n        xhci->intr[i].erdp_high = 0;\n\n        xhci->intr[i].msix_used = 0;\n\n\n\n        xhci->intr[i].er_ep_idx = 0;\n\n        xhci->intr[i].er_pcs = 1;\n\n        xhci->intr[i].er_full = 0;\n\n        xhci->intr[i].ev_buffer_put = 0;\n\n        xhci->intr[i].ev_buffer_get = 0;\n\n    }\n\n\n\n    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    xhci_mfwrap_update(xhci);\n\n}\n", "idx": 3236, "substitutes": {"dev": ["sys", "device", "ach", "conn", "ev", "hw", "pi", "dem", "ds", "Dev", "info", "priv", "def", "req", "pad", "att", "conf", "ch", "sd", "w", "cam", "Device", "ver", "de", "obj", "go", "DEV", "v", "nt", "hid", "ad", "ve", "os", "mem", "scan", "serv", "cmd", "pro"], "xhci": ["oxhcin", "xhecli", "xhacor", "oxhuci", "xhelic", "xxxhci", "xehclient", "xhaili", "eyhdi", "txhdi", "xhalim", "xehcheck", "xherlink", "rxhcit", "xhrcont", "xehcit", "rxhefc", " xxhci", "xhcond", " xthoci", "xehcor", "exehini", "xhsclient", "xphpclient", "xhercli", "xhashuci", "xhmlink", "wxhmcor", "rosshmci", "xhtcgi", "exhini", "eyehcin", "xhashcu", "xxxxhostlic", "eyhcit", " xthci", "xhaci", "xrhcont", "xhdpi", "xhmcgi", "xhadi", "xhashini", "xhsmm", "xchci", "xhmcin", "xhmcont", " xthili", "xphdi", "xehcin", "xhclient", "mxhapi", "xxxhclient", "xhacli", "xhecu", "xhlcor", "xhini", "oxheci", "ryhuci", "eyahcit", "xmlhci", "eyhcin", "eyahci", "xihci", "xkhci", "rxehmc", "eyehcu", "xhki", "xehcont", "xhce", " xxhmcond", "exehci", "rychci", "xthili", "xehlic", "xphpmm", "xshcin", "eyhecont", "xthoci", "xshdi", "xehcgi", "xehci", "xkhili", "lexhcli", "xhercheck", "xhpi", "wxhashcin", "rxhuci", "xshcu", "xhspi", "xrhcu", "xhrlic", "xhtcci", "xhostfc", "rxhcu", "xhdcu", " xxhmcit", "xhmce", "txheci", "xhlic", "eyehcont", "exhki", "xphclient", "xxxhcgi", "xhlcit", "xhtcli", "xshuci", "xhrlc", "xhdcit", "xahcond", "rxhlc", "xhmcli", "exhci", "xhrcli", "xhslic", "xhdri", "xheci", "rxhci", "xahclient", "xhscor", " xthcu", "xhacit", "rxhcont", "rxhcci", "xphci", "xhostdi", "rxhmit", "xphcu", "xhmit", "xphcgi", "xhdcont", "xhlc", "xahci", "xxphpi", "wxhcin", "rosshcheck", "xhashdi", "rxhlic", "ryhcgi", "xkhcli", "xphpi", " xxhcit", "rxhlci", "oxhrcgi", "xshcli", "xhtcin", "xhrcit", "xhlim", "xhlcu", "xhfc", "txhcu", "exehcit", "xphplic", "eyhcli", "xhmcu", " xxhcond", "eyehcgi", "xshcit", "eyhmm", "xhcin", "ryhlic", "xhecond", "xehfc", "rychuci", "xhostci", "xHci", "rosskhili", "txehcli", "xhdcgi", "xhemit", "xrhci", "xrhpi", "rxhlcit", "xchcgi", "xhmcor", "xmlhcin", "rxehuci", "oxhcit", "txhepi", "xhaii", "xhluci", "xhashcin", "rxhelic", "eyhci", "rosshcin", "xphcin", "xhruci", "txhecli", "xhercor", "xhdci", "xherce", "xehmc", "xhdi", "xhashki", "wxhmcin", "xshii", "xthci", "xhtmlili", "xhashmc", "eyhcheck", "rxhmc", "rosshci", "xhostclient", "exehcli", "xhrfc", "xehki", "xxhpi", "rosshili", "xehuci", "eyheci", "xhcor", "xahlim", "xhlink", "eyhlim", "xhacu", "txehcu", "rosskhci", "xhtci", "xhepi", "xhduci", "xhedi", "oxhecit", "eyhcu", "txhcli", "mxhuci", "xmlhmuci", "xhmcci", "xhddi", "xhamc", "xhdini", "xhtmit", "xxhcu", "exehdi", "xhii", "xehdi", "rxhlcu", "xhtmlci", "exhcli", "xHcor", "xrhoci", "xhaoci", "xhtcor", " xhoci", "mxhacor", "xhlcond", " xhcu", "xhlcci", "xxxhostdi", "exhdi", "wxhcor", " xxhmcu", "eyehdi", "txehcit", "xhmii", "rxhelc", "eyehclient", "xhrcu", "eyhcont", "xphpci", "xmlhmci", "oxhruci", "xhtmlmit", "wxhashri", "xmlhuci", "xmlhii", "xehlink", "rxhecu", "xhmcheck", "wxhmcci", "mxhpi", "xhdki", "exehki", "xhmcit", "exhcit", "rxehcu", "eyehcond", "xahcit", "eyhcgi", "xhlcin", "xxphcu", "xxhcin", "xxxxhostcgi", "xhecin", "eyehmm", "rosshmlink", "wxhcci", "lexhce", "xehpi", "lexhci", "eyhcond", " xxhmci", "xrhcin", "xthcu", "xhashcit", "xhapi", "xhcu", "rxehci", "rosskhmit", "xkhcin", "xhmclient", "xahcont", "xhsci", "eyehcli", "rosshmit", "xehcond", "xhmm", "xxxxhostci", "eyehlic", "mxhci", "xahini", "xehcli", "lexhmii", "xehmm", "eyhini", "xhcheck", "xhcit", "xkhuci", "xhecgi", "txhcit", "xhacin", "lexhmcli", "xxxhdi", "xkhri", "xkhclient", " xhili", "xkhmit", "xmlhmcin", "xxxhostclient", "lexhmce", "rosskhcin", "xrhcli", "mxhauci", "rosshcor", "xxxhostcgi", "rxhecont", "xhostcgi", "oxhecin", "mxhcor", "rxheci", "xihcont", "rosshmcheck", "wxhashcit", "wxhci", "xxxxhcgi", "xhefc", "xhace", "xhostlic", "eyehci", "xkhcgi", "eyehcheck", "xherii", "eyhlic", "eyhecu", "txhci", "xhashlim", "xhashci", "xhili", "txhedi", " xxhcu", "txhpi", "xchlic", "xhcli", "xhrci", "wxhmci", "xmlhmii", "xchuci", "rychlic", "xhmc", "xhtmlcin", "xrhili", "xxxxhlic", "wxhri", "xxphcin", "xshpi", "xxxhostci", "xhecit", "xhcont", "xrhcit", "xhdmit", "xrhdi", "xxhci", "xhdlc", "xxxxhfc", "oxhcu", "xhelc", "xhtili", "xkhdi", "oxhci", "xhrcgi", "xhmlic", "xhcgi", "rychcgi", "xhashri", "lexhii", "xihcu", "rosshlink", "ryhci", "wxhashci", "eyhecit", "xxxxhci", "xhauci", "xhtcu", "eyahlim", "xihcit", "xhecont", "txehci", "xhmci", "xhoci", "xhlpi", "xphcheck", "lexhmci", "xhaini", "xxphci", "eyahini", "rxhlcci", "xHcci", "rosshmcor", "xherci", "rxhfc", "eyhclient", "xehini", "xhuci", "xhri", "xehcu", "xkhcit", "xHcin", "rxhemit", "xhcci", "xhrmit", "mxhaci", "xhacheck", "oxhrcit", "xhsuci", "xhmcond", "oxhrci", "xhdcin", "xhecci", "oxhecu", "xhlci", "xshci", "wxhcit", "xhostcu", "oxhcgi", "xxxxhostfc", "xhmuci"], "i": ["id", "try", "port", "p", "init", "n", "ski", "li", "iii", "x", " vi", " ti", "iu", "ti", "ind", "uri", "ix", "zi", "by", "ini", "h", "I", "f", "this", " bi", "batch", "q", "list", " j", "xi", "ic", "qi", "m", "ui", "it", "ex", "gu", " index", "ims", "im", "name", " p", " li", "io", "remote", "\u0438", "ri", "chain", " wi", "j", " m", "ii", "l", "iq", " mi", "ji", "jp", "MI", "iri", "pi", "index", "me", "ci", " c", "ei", "info", "phi", "ij", "history", "fi", " ii", "y", " pi", "bi", " I", " ni", "loop", "mi", "di", "ai", "si", "point", "jj", "multi", "ki", "status", "is", "sim", "g", "s", " di", "ami", "cli", "gi", " pos", " si", "ip", "oi", "e", "dr", "in", "o", " multi", "t"]}}
{"project": "qemu", "commit_id": "068abdc8a57023eeafe1025b964a50f8a39929b4", "target": 1, "func": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3237, "substitutes": {"pvr": ["pfx", "pvp", "ipvr", " pserv", " ppvr", "cvr", "pver", " pbr", "tpbr", " ptr", "pserv", "pphr", "gvr", " pptr", " pplr", "ppbr", "plr", " pver", "gver", "tpserv", "ipvp", "iplr", " pfx", " plr", "ptr", "pbr", "cfx", "gvc", " ppvp", "pvc", "ppserv", "iptr", "phr", "gfx", "ppvr", "cver", " phr", " pvp", "tphr", "tpvr", "cvc", " pvc"], "def": ["day", "DEF", "aux", "fc", "prop", "buf", "fun", "fam", "cal", "ref", "DE", "crit", "out", "decl", "ds", "res", "lit", "form", "pos", "msg", "req", "dev", "ef", "vec", "defined", "ex", "conf", "define", "block", "desc", "Def", "df", "de", "del", "DEV", "val", "pass", "nt", "f", "bf", "da", "des", "feat", "push", "cmd"], "i": ["multi", "j", "batch", "try", "ii", "ki", "list", " mi", "c", " j", "ji", "is", "p", "sim", "to", "iy", "xi", "ic", "pi", "asi", "index", "qi", "me", "ci", "li", "m", "ei", "x", "cli", "ui", "info", "phi", "it", "gi", "ij", "series", " ti", " si", "ip", " ii", "oi", "y", "fi", "bi", "im", "e", "iu", "ti", " iter", "ind", "uri", " li", "io", "ix", "remote", "v", " ni", "mi", "di", "ini", "\u0438", "o", "ai", "si", "I", "ik", "ri", "point", "iat", "my", "json", " bi"], "ret": ["mt", "usr", "RET", "try", "alf", "tmp", "status", "match", "quad", " RET", "ref", "result", "out", "res", "ft", "store", "ne", "cont", "gt", "reply", "Ret", "bt", " Ret", "fi", "end", "t", "rt", "alt", "pt", "print", "dr", "val", "rm", "rets", "nt", "cmd", "det", "tr", "rem", "flag", "f", "elt", "rel", "re", "back", "len", "inter"]}}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n", "idx": 3256, "substitutes": {"T0": ["V2", "P00", "M2", " T00", "S0", "P1", " T1", "M0", "T1", "WT0", "TN1", "M1", "P9", "T00", "P0", "T9", "S00", "TN0", "WT100", "V8", "M8", "TN100", "T100", "S9", "TN9", "T8", "P2", "V1", "T2", "WT1", "S1", "V0", "WT9", " T9", " T100", "P8"], "vaddr": ["vaddress", "vvptr", "vvaddr", "fadd", " vcoord", "wadr", "wptr", " vptr", "taddress", "waddress", "tAddress", "vadd", "woca", "vvdr", "wdr", " vAddress", "faddr", "wcoord", "waddr", " Vcoord", "vdr", "fadr", "faddress", "wadd", " vaddress", "tadd", " Vaddr", "voca", "vvaddress", "vvAddress", " voca", "vvadd", "taddr", "vadr", "vptr", " vdr", "vvoca", " Vadd", " Vaddress", "vcoord", "vAddress", " vadr", " vadd"]}}
{"project": "qemu", "commit_id": "99fd437dee468609de8218f0eb3b16621fb6a9c9", "target": 0, "func": "static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n\n{\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n\n\n\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n\n     */\n\n    /* Sanity check */\n\n    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"_EJ0\", 4));\n\n\n\n    if (!eject) {\n\n        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"EJ0_\", 4);\n\n    }\n\n}\n", "idx": 3266, "substitutes": {"slot": ["chain", "id", "key", "size", "item", "hot", "addr", "handle", "height", "port", "soc", "slice", "kh", "to", "service", "ref", "window", "index", "label", "pointer", "set", "table", "pos", "usage", "lot", "zero", "entry", "snap", "esi", "locked", "location", "cell", "block", "binding", "option", "loc", "sid", "Slot", "offset", "val", "address", "spot", "pot", "hash", "scroll", "layout", "loop", "zone", "sector", "unit", "position", "seed", "timeout", "hit", "padding", "second", "share", "sp"], "ssdt_ptr": ["ssdt0tr", "ssderaphaddr", "ssdat_addr", "ssdt___ptr", "ssdt___vr", "ssdt_vr", "ssdt_addr", "ssdat_Ptr", "ssdtaphaddr", "ssdat_tr", "ssdt_pointers", "ssdt0addr", "ssDT_addr", "ssder_addr", "ssdt_obj", "ssdat_pt", "ssDT_arr", "ssdt___addr", "ssd_Ptr", "ssdt_pointer", "ssdt_pt", "ssdat_pointers", "ssdt___Ptr", "ssderaphptr", "ssd_addr", "ssdt0pointers", "ssdat_ptr", "ssdt_Ptr", "ssdt___pointer", "ssdat_eth", "ssdat_pointer", "ssdtaphptr", "ssd_vr", "ssdt_eth", "ssderaphtrace", "ssdt___eth", "ssDT_Ptr", "ssderaphpointer", "ssder_trace", "ssder_pointer", "ssder_ptr", "ssdtaphpointer", "ssdat_obj", "ssdt_trace", "ssd_ptr", "ssdtaphtrace", "ssdt0ptr", "ssdt_arr", "ssDT_ptr", "ssdt_tr"], "eject": ["ejected", "ejection", "eejected", "pejected", "Elect", "eelect", "peject", "Ejected", "eleject", "elect", "elejection", "Eject", "eeJECT", "eejection", "elelect", "elejected", "EJECT", "pejection", "Ejection", "peJECT", "eJECT", "eeject"]}}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static float ssim_plane(uint8_t *main, int main_stride,\n\n                        uint8_t *ref, int ref_stride,\n\n                        int width, int height, void *temp)\n\n{\n\n    int z = 0;\n\n    int x, y;\n\n    float ssim = 0.0;\n\n    int (*sum0)[4] = temp;\n\n    int (*sum1)[4] = sum0 + (width >> 2) + 3;\n\n\n\n    width >>= 2;\n\n    height >>= 2;\n\n\n\n    for (y = 1; y < height; y++) {\n\n        for (; z <= y; z++) {\n\n            FFSWAP(void*, sum0, sum1);\n\n            for (x = 0; x < width; x+=2)\n\n                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,\n\n                                &ref[4 * (x + z * ref_stride)], ref_stride,\n\n                                &sum0[x]);\n\n        }\n\n\n\n        ssim += ssim_endn(sum0, sum1, width - 1);\n\n    }\n\n\n\n    return ssim / ((height - 1) * (width - 1));\n\n}\n", "idx": 3274, "substitutes": {"main_stride": ["main_divice", "main_Strine", "main_Stride", "main_stripe", "main_divine", "main_strride", "main_stide", "main_variipe", "main_Stripe", "main_variide", "main_divick", "main_collice", "main_striride", "main_stie", "main_stope", "main_strice", "main_strope", "main_Strope", "main_strine", "main_striie", "main_strIDE", "main_Strie", "main_divide", "main_Strice", "main_StrIDE", "main_striide", "main_striope", "main_Strick", "main_variride", "main_variIDE", "main_colline", "main_Strride", "main_strie", "main_collick", "main_collide", "main_strick"], "ref": ["br", "q", "aux", "ro", "ext", "p", "row", "r", "lib", "m", "red", "tab", "orig", "def", "req", "mem", "ef", "conf", "local", "block", "rot", "fr", "reference", "alt", "reg", "range", "rm", "Ref", "ret", "f", "rem", "reset", "rel", "re", "base", "master", "self"], "ref_stride": ["ref_sprine", "ref_drade", "ref_grid", "ref_Stride", "ref_Strride", "ref_gride", "ref_STRid", "ref_Strid", "ref_dride", "ref_constide", "ref_STRide", "ref_Strategy", "ref_Strade", "ref_grade", "ref_drride", "ref_drategy", "ref_constategy", "ref_strride", "ref_sprider", "ref_Strine", "ref_constride", "ref_strade", "ref_STRade", "ref_spride", "ref_constade", "ref_strine", "ref_sprride", "ref_strid", "ref_Strider", "ref_strategy", "ref_STRride", "ref_grider", "ref_grine", "ref_strider", "ref_grride"], "height": ["rows", "ty", "zh", "bottom", "size", "Height", "he", "inches", "count", "high", "visible", "gravity", "style", "row", "resolution", "cy", "window", "build", "yt", "rank", "holes", "html", "above", "volume", "hei", "shape", "type", "history", "w", "buffer", " heights", " Height", "radius", "range", "depth", "angle", "padding", "h", "hash", "hang", "max", "stroke", "grow", "th", "capacity", "density", "length", "ht"], "temp": ["total", "template", "mint", "fake", "test", "tmp", "Temp", "hot", "c", "value", "p", "water", "create", "txt", "fac", "index", "vt", "out", "m", "tm", "type", "length", "tar", "buffer", "ptr", "w", "fact", "pt", "get", "offset", "v", "pre", "hum", "current", "max", "tr", "unit", "reset", "ac", "t", "tc", "tem"], "x": ["j", "fx", "q", "key", "l", "add", "c", "xc", "column", "ext", "xxxx", "p", "g", "n", "dx", "xf", "xi", "index", "r", "xs", "inx", "xa", "ax", "m", "ox", "i", "lat", "mx", "tx", "num", "ord", "at", "att", "ex", "xy", "axis", "xt", "k", "ux", "w", "xx", "xp", "el", "e", "en", "px", "rx", "one", "yx", "ix", "v", "on", "wx", "h", "f", "X"], "y": ["j", "year", "uy", "key", "ty", "try", "l", "axy", "yl", "ay", "p", "iy", "py", "n", "cy", "index", "wy", "ym", "yt", "gy", "sy", "m", "i", "b", "yn", "ey", "yr", "xy", "vy", "t", "ch", "k", "w", "xx", "kit", "yo", "ies", "Y", "ry", "v", "yy", "o", "ly", "h", "by", "sky", "col", "oy", "ot", "ys", "ny", "yi", "ye", "my"], "sum0": ["um1", "sum3", "Sum0", " sum2", " sum3", "mem1", "sum5", "mean00", " sum00", "Sum3", "Sum2", "mem0", "um2", " sum5", "Sum1", "sum2", "um5", "mem3", "mean0", "um3", "Sum5", "sum00", "mem2", "mean1", "um0", "mem00", "mean2"], "sum1": [" sum4", "um1", "sum3", "Sum0", " sum2", " sum3", "mem1", "Sum3", "Sum2", "mem0", "um2", "memy", "Sum1", "sum2", "mem3", "um4", "mem4", "sum4", "fac2", " sumy", "mem2", "facy", "um0", "sumy", "fac0", "fac1"], "z": ["j", "d", "q", "zh", "ez", "zes", "rez", "c", "ze", " cz", "g", "Z", "zx", "cy", "cz", "gy", "ox", "i", "oz", "zero", "ey", "zz", "zip", "tz", "zen", "fl", "xy", "zer", "ed", "zo", "w", "iz", "uz", "hz", "zi", "yz", "nz", "wx", "gz", "zy", "zone", "os", "t", "az", "ld"]}}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_instance_init(Object *obj)\n\n{\n\n    object_property_add(obj, \"bootindex\", \"int32\",\n\n                        nvme_get_bootindex,\n\n                        nvme_set_bootindex, NULL, NULL, NULL);\n\n    object_property_set_int(obj, -1, \"bootindex\", NULL);\n\n}\n", "idx": 3278, "substitutes": {"obj": ["inst", "j", "cod", "tmp", "po", "instance", "obo", "bj", "object", "bh", "tk", "org", "n", "init", "attr", "hw", "txt", "onet", "xs", "np", "rect", "act", "cont", "it", "obs", "req", "cmp", "att", "pr", "ij", "ex", "xy", "js", "iv", "desc", "ie", "ctx", "fr", "Obj", "ob", "gc", "ind", "bo", "rt", "pt", "str", "nt", "o", "expr", "ot", "ck", "resp", "elt", "t", "cmd", "ht", "typ"]}}
{"project": "qemu", "commit_id": "7e39d3a2dd34a84900e10b4ea1567f3b352659af", "target": 1, "func": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n", "idx": 3279, "substitutes": {"bs": ["ls", "outs", "cks", "bc", "bh", "ss", "bm", "boxes", "vs", "pb", "ab", "bp", "ses", "uts", "ds", "cb", "ops", "b", "locks", "fs", "ubs", "lbs", "BS", "aws", "obs", "ps", "its", "bb", "bos", "aos", "js", "ns", "bis", "amps", "ts", "cs", "bes", "hs", "bps", "bo", "rs", "bl", "bits", "gs", "sb", "ats", "os", "aus", "ubis"], "options": ["pps", "data", "values", "steps", "ones", "ptions", "stats", "atts", "issues", "actions", "settings", "als", "es", "checks", "times", "uts", "caps", "details", "weights", "includes", "comes", "roots", "vals", "params", "locks", "fs", "groups", "aches", "ps", "its", "parts", "opens", "features", "errors", "ims", "amps", "ts", "pins", "finals", "ption", "option", "classes", "offs", "aps", "events", " Options", "styles", "results", "properties", "Options", "tops", "IONS", "uploads", "xes", "args", "os", "rules", "ices", "obj", "lets", "ops", "tools"], "flags": ["mask", "files", "mode", "Flags", "ds", "vals", "res", "fs", "fields", "uns", " flag", "weight", "features", "tags", "lag", "ts", " Flags", "ents", "rets", "ags", "fee", "bits", "args", "flag", "states", "Flag", "cmd"], "errp": ["Erpa", "Erpat", "rarpar", "rrpb", "Erp", " errpat", "ererP", "rrp", "rarp", "ErP", "errpp", "rarpb", "iterpp", " errper", "errorp", "rrper", " errpa", "sprpa", "errorpa", "rarpn", " errP", "errpa", "sprp", "rrP", "erP", "errper", "thinkpb", "ererpa", "sprpp", "errorP", "erp", "errpn", "thinkpar", "sprP", "erpp", "errpat", "errpar", "rrpn", "erpa", "iterp", "thinkpn", "ererp", "errpb", "iterpa", "errP", "errorper", "rrpa", "iterP", "ererpat", "rrpar", "thinkp"], "s": ["sys", "ls", "ils", "S", "is", "sv", "ss", "p", "g", "vs", "ab", "ds", " ss", "b", "fs", "ps", "its", "js", "ns", "ts", "cs", "hs", "sts", "rs", "v", "h", "gs", "sb", "ats", "ins", "os", "sq", "state", "ys", "ssl", "sp"], "opts": ["popms", "vertions", " opj", "opstions", "analyts", "optte", "icts", " copj", "optents", "optfs", "popts", "droptions", " opps", "opps", " opms", "copters", "opj", "opttions", "oputs", "opsts", "copps", "iopms", "coptions", "iopt", "opte", "verts", "iopts", "coputs", "opTS", " opte", "optters", "iopTS", " coptes", "opsfs", "opt", "opttes", "optes", "popTS", "opents", "optj", "dropts", "copms", "copTS", "optuts", "opsents", " opters", " opTS", "verents", "copts", "optps", "dropents", "opfs", "analyTS", "analyt", "opms", " oputs", " opt", "icters", "dropters", "optts", "analyms", " copts", " optes", "opters", " copte", "popters", "ictions", "verfs", "icents"], "local_err": ["foreignlyerr", "local5err", "local_plain", "locallyerr", "internal_err", " local_msg", "localErer", "localingelt", "foreignlyiter", "specific_err", "localErerr", "foreign_usr", "localErelt", "foreignlyusr", "foreignlyres", " local_log", "local__rr", "locallyiter", " local_cert", "global_plain", "localjer", "global_er", "local5plain", "locallyusr", "local_sys", "localjerrors", "local_res", "locallyres", "foreign_err", "foreign_iter", "local__elt", "local_log", "local_gr", " local_iter", "local_iter", "specific_errors", "global_err", " local_rr", " local_kr", "local_errors", " local_er", "foreign_res", "local_usr", " local_gr", "localingrr", "localingerr", "locallydev", " local_dev", "internal_er", "local_rr", "local_cert", "specific_er", "locallykr", "internal_elt", "local__err", "local_elt", "local_kr", "local5er", "specific_sys", "local_dev", " local_elt", "localjerr", "localErrr", "internal_rr", "local_msg", "localjsys", "local_er"], "ret": ["mt", "jump", "usr", "RET", "cat", "try", "status", "dt", "f", "detail", "ext", " RET", "fun", "sort", "result", "ref", "txt", "lt", "out", "set", "res", "af", "ft", "lit", "over", "cont", "gt", "ll", "def", " fut", "att", "Ret", "ert", "fl", " Ret", "opt", "fi", "desc", "compl", "gc", "pas", "alt", "rev", "rt", "re", "print", "val", "rm", "rets", "arg", "nt", " alt", "nz", "rel", "__", "rem", "tr", "det", "resp", "cert", "elt", "t", "reset", "flag", "len", "cmd"]}}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,\n\n                             int s_bits, int tlb_offset)\n\n{\n\n    TCGReg base = TCG_AREG0;\n\n\n\n    /* Should generate something like the following:\n\n     * pre-v7:\n\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n\n     *   add    r2, env, #off & 0xff00\n\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n\n     *   tst    addr_reg, #s_mask\n\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n\n     *\n\n     * v7 (not implemented yet):\n\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n\n     *   movw   r0, #off\n\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n\n     *   bic    tmp, addr_reg, tmp\n\n     *   ldr    r0, [r2, r0]!                                     (3)\n\n     *   cmp    r0, tmp                                           (4)\n\n     */\n\n#  if CPU_TLB_BITS > 8\n\n#   error\n\n#  endif\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,\n\n                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n\n\n\n    /* We assume that the offset is contained within 16 bits.  */\n\n    assert((tlb_offset & ~0xffff) == 0);\n\n    if (tlb_offset > 0xff) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                        (24 << 7) | (tlb_offset >> 8));\n\n        tlb_offset &= 0xff;\n\n        base = TCG_REG_R2;\n\n    }\n\n\n\n    tcg_out_dat_imm(s, COND_AL, ARITH_AND,\n\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3288, "substitutes": {"s": ["sys", "ls", "S", "south", "stats", "c", "sg", "is", "sv", "ss", "p", "es", "scl", "g", "n", "session", "z", "vs", "r", "ses", "comm", "ds", "qs", "m", "b", "x", "fs", "less", "aws", "its", "js", "ns", "sw", "y", "w", "setup", "as", "cs", "ts", "ains", "ties", "ies", "sm", "hs", "sts", "an", "rs", "v", "h", "gs", "sb", "ins", "ats", "os", "sq", "t", "a", "tains"], "addrlo": ["addresslo", "addrLo", "addrlow", "addrilo", "ptrLo", "ptrlo", "addrLO", "offsetLO", "offsetlo", "addressLo", "addresshi", "addressilo", "offsetilo", " addrlow", "Addresslo", "ptrilo", "addressLO", "addresslow", "AddressLo", "offsetLo", "Addresslow", "Addresshi", "ptrLO", " addrLo"], "addrhi": ["clonehei", "addrupper", "clonehi", "shahi", "addrhel", "cloneupper", "shahel", "clonehel", "ptrhel", "ptrupper", "addrhei", "ptrhi", "shahei", "ptrhei", "shaupper"], "s_bits": ["s_flags", "s2bs", " s_flags", " s2bits", " s2bit", " s_bit", "s_bs", "s2flags", "s_bit", " s2flags", "s2bit", " s_bs", "s2bits", " s2bs"], "tlb_offset": ["tlb_data", "tlabptorigin", "tlabptoffset", "tpl_offset", "tlb___Offset", "terb___Offset", "tlb_off", "tlb_Offset", "tlbs_data", "tlb___offset", "tlp_Offset", "tlb_bytes", "tlbs_size", "terb___ref", "terb_Offset", "tlbs_offset", "tlbptorigin", "tlb_count", "tlb67offset", "tlbs_Offset", "tlbs_bytes", "tlb___ref", "tlab_origin", "tlb_pos", "tlb67Offset", "tlbptOffset", "tl_Offset", "tlb_size", "tlb67count", "tlbs_bit", "tlp_off", "terb_offset", "tlb_bit", "tlp_offset", "tlabptOffset", "tpl_Offset", "tlbptoffset", "tlab_offset", "tlb_ref", "terb___offset", "tpl_count", "tlb_origin", "tl_pos", "tlab_Offset", "terb_ref", "tl_offset"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "static void qdm2_decode_super_block(QDM2Context *q)\n\n{\n\n    GetBitContext gb;\n\n    QDM2SubPacket header, *packet;\n\n    int i, packet_bytes, sub_packet_size, sub_packets_D;\n\n    unsigned int next_index = 0;\n\n\n\n    memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));\n\n    memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));\n\n    memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));\n\n\n\n    q->sub_packets_B = 0;\n\n    sub_packets_D    = 0;\n\n\n\n    average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]\n\n\n\n    init_get_bits(&gb, q->compressed_data, q->compressed_size * 8);\n\n    qdm2_decode_sub_packet_header(&gb, &header);\n\n\n\n    if (header.type < 2 || header.type >= 8) {\n\n        q->has_errors = 1;\n\n        av_log(NULL, AV_LOG_ERROR, \"bad superblock type\\n\");\n\n        return;\n\n    }\n\n\n\n    q->superblocktype_2_3 = (header.type == 2 || header.type == 3);\n\n    packet_bytes          = (q->compressed_size - get_bits_count(&gb) / 8);\n\n\n\n    init_get_bits(&gb, header.data, header.size * 8);\n\n\n\n    if (header.type == 2 || header.type == 4 || header.type == 5) {\n\n        int csum = 257 * get_bits(&gb, 8);\n\n        csum += 2 * get_bits(&gb, 8);\n\n\n\n        csum = qdm2_packet_checksum(q->compressed_data, q->checksum_size, csum);\n\n\n\n        if (csum != 0) {\n\n            q->has_errors = 1;\n\n            av_log(NULL, AV_LOG_ERROR, \"bad packet checksum\\n\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    q->sub_packet_list_B[0].packet = NULL;\n\n    q->sub_packet_list_D[0].packet = NULL;\n\n\n\n    for (i = 0; i < 6; i++)\n\n        if (--q->fft_level_exp[i] < 0)\n\n            q->fft_level_exp[i] = 0;\n\n\n\n    for (i = 0; packet_bytes > 0; i++) {\n\n        int j;\n\n\n\n        if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) {\n\n            SAMPLES_NEEDED_2(\"too many packet bytes\");\n\n            return;\n\n        }\n\n\n\n        q->sub_packet_list_A[i].next = NULL;\n\n\n\n        if (i > 0) {\n\n            q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i];\n\n\n\n            /* seek to next block */\n\n            init_get_bits(&gb, header.data, header.size * 8);\n\n            skip_bits(&gb, next_index * 8);\n\n\n\n            if (next_index >= header.size)\n\n                break;\n\n        }\n\n\n\n        /* decode subpacket */\n\n        packet = &q->sub_packets[i];\n\n        qdm2_decode_sub_packet_header(&gb, packet);\n\n        next_index      = packet->size + get_bits_count(&gb) / 8;\n\n        sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2;\n\n\n\n        if (packet->type == 0)\n\n            break;\n\n\n\n        if (sub_packet_size > packet_bytes) {\n\n            if (packet->type != 10 && packet->type != 11 && packet->type != 12)\n\n                break;\n\n            packet->size += packet_bytes - sub_packet_size;\n\n        }\n\n\n\n        packet_bytes -= sub_packet_size;\n\n\n\n        /* add subpacket to 'all subpackets' list */\n\n        q->sub_packet_list_A[i].packet = packet;\n\n\n\n        /* add subpacket to related list */\n\n        if (packet->type == 8) {\n\n            SAMPLES_NEEDED_2(\"packet type 8\");\n\n            return;\n\n        } else if (packet->type >= 9 && packet->type <= 12) {\n\n            /* packets for MPEG Audio like Synthesis Filter */\n\n            QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet);\n\n        } else if (packet->type == 13) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = get_bits(&gb, 6);\n\n        } else if (packet->type == 14) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2);\n\n        } else if (packet->type == 15) {\n\n            SAMPLES_NEEDED_2(\"packet type 15\")\n\n            return;\n\n        } else if (packet->type >= 16 && packet->type < 48 &&\n\n                   !fft_subpackets[packet->type - 16]) {\n\n            /* packets for FFT */\n\n            QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet);\n\n        }\n\n    } // Packet bytes loop\n\n\n\n    if (q->sub_packet_list_D[0].packet != NULL) {\n\n        process_synthesis_subpackets(q, q->sub_packet_list_D);\n\n        q->do_synth_filter = 1;\n\n    } else if (q->do_synth_filter) {\n\n        process_subpacket_10(q, NULL);\n\n        process_subpacket_11(q, NULL);\n\n        process_subpacket_12(q, NULL);\n\n    }\n\n}\n", "idx": 3290, "substitutes": {"q": ["ql", "cp", "iq", "er", "qq", "view", "z", "p", "g", "quest", "window", "query", "r", "qi", "qa", "debug", "pp", "comm", "ue", "qs", "pg", "question", "x", "form", "msg", "info", "ce", "qt", "cache", "check", "aq", "req", "qu", "quick", "dq", "Q", "requ", "config", "conf", "y", "k", "cf", "hl", "ch", "w", "comment", "quit", "rec", "ctx", "quote", "pkg", "pt", "eq", "que", "queue", "v", "ry", "client", "h", "f", "ve", "gm", "sq", "ck", "t", "cmd", "self"], "gb": ["Gb", " rgb", " rg", "gin", "mb", "buf", "gio", "git", "rg", "tg", "bm", "kb", "hog", "g", "ga", "img", "py", "attr", "BB", "pb", "cfg", "cb", "rb", "gue", "gp", "yg", "lib", "csv", "b", "pg", "gd", "eg", "gt", "ge", "storage", "bb", "gu", "hub", " GB", "vm", "cv", "buffer", "DB", "goo", "ctx", "bg", "gc", " kb", "db", " db", "bridge", "bytes", "bits", "GB", "BG", "gs", "sb", " gcc", "bn", "bf", "gg", "gm", "nb", "binary"], "header": ["user", "summary", "match", "format", "column", "handle", "component", "drm", "server", "request", "state", "version", "vv", "buffer", "response", "spec", "ver", "body", "hash", "h", "wrapper", "handler", "heading", "line", "number", "head", "list", "detail", "operator", "sort", "filter", "relation", "msg", "note", "tag", "Header", "headers", "name", "rr", "option", "member", "offset", "magic", "padding", "position", "document", "section", "er", "dt", "size", "bm", "record", "index", "definition", "part", "info", "entry", "cache", "type", "prot", "title", "history", "block", "timer", "comment", "error", "attribute", "author", "client", "address", "flag", "master", "cmd", "len", "data", "lp", "holder", "status", "item", "layer", "term", "commit", "query", "table", "chron", "extra", "HEAD", "config", "writer", "tar", "metadata", "player", "command", "dr", "event", "peer", "t", "rule", "feature"], "packet": ["ppetter", "pets", "ppets", "bucket", "ppET", "petter", "packets", "packacket", "packET", "packetter", "ppkt", "octacket", "pET", "buckets", "octet", "packkt", "bucketter", "ppet", "pet", "pkt", "octets", "buckET", "octkt", "ppacket"], "i": ["l", "ii", "ki", "c", "p", "pi", "index", "ci", "li", "m", "b", "x", "it", "ij", " ii", "y", "bi", "ti", "ix", "v", "mi", "ai", "I", "si", "t", " bi"], "packet_bytes": ["packed_bytes", "packed_len", "packet_tes", "packet_errors", "packet_Bytes", "packets_Bytes", "packets_size", "packed_size", "packets_errors", "packets_bytes", "packed_tes", "packet_size", "packet_len"], "sub_packet_size": ["sub_packet_bytes", "sub_packet_SIZE", "sub_packets_bytes", "sub_packets_SIZE", "sub_packet_ize", "sub_packets_ize", "sub_packets_size"], "sub_packets_D": ["sub_packet_DS", "sub_packet_B", "sub_packets_P", "sub_packet_D", "sub_packet_G", "sub_packets_DS", "sub_packets_G", "sub_packets_B", "sub_packet_P"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,\n\n                          const int16_t *filter, const int16_t *filterPos,\n\n                          int filterSize)\n\n{\n\n    int i;\n\n    for (i=0; i<dstW; i++) {\n\n        int j;\n\n        int srcPos= filterPos[i];\n\n        int val=0;\n\n        for (j=0; j<filterSize; j++) {\n\n            val += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n        }\n\n        //filter += hFilterSize;\n\n        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...\n\n        //dst[i] = val>>7;\n\n    }\n\n}\n", "idx": 3293, "substitutes": {"c": ["d", "fc", "p", "g", "dc", "ca", "s", "ci", "m", "b", "C", "sc", "w", "e", "cv", "context", "cs", "ctx", "v", "cc", "h", "ct", "f", "ac", "t", "tc", "a", "chain"], "dst": [" ddest", "dsdest", "rst", "ddest", "rest", "drc", "sst", " drc", "dict", "adst", "adict", "dsict", "dct", "rrc", " dict", "dsst", "adct", "sest", " dest", "dest", "rdest", "sdest", "dsct", "addest", " dct"], "dstW": ["dstsW", "dstL", "distV", "ddestV", "dtdW", "dstSize", "dsstsV", "dstWA", "ddestW", "destV", "DestW", "dsstW", "destW", "distH", "destH", "dtdV", "DstH", "destSize", "DstSize", "dsstsL", "dstV", "dtdL", "dtdWA", "distW", "DestH", "DstW", "dsstWA", "destL", "DstV", "DestSize", "dstsWA", "ddestH", "dstsV", "ddestSize", "dsstsW", "dsstL", "dstsL", "distSize", "dstH", "dsstV", "destWA", "dsstsWA", "DestV"], "src": ["sys", "input", "inst", "usr", "fil", "ctr", "source", "conv", "slice", "img", "sl", "attr", "r", "s", "ur", "sc", "sur", "bs", "ser", "sub", "sr", "transform", "trans", "stream", "rl", "dest", "loc", "rs", "in", "sel", "rc", "sb", "st", "ins", "secure", "scan", "ssl", "std", "supp"], "filter": ["fp", "batch", "fil", "fw", "ff", "test", "skip", "match", "mask", "source", "term", "pipe", "sort", "ref", "focus", "table", "bit", "pixel", "profile", "sc", "cache", "tf", "fl", "config", "transform", "tag", "block", "buffer", "search", "attribute", "stream", "color", "offset", "scale", "range", "Filter", "channel", "hash", "control", "f", "binary", "flag", "map"], "filterPos": ["filSize", "matchSize", "FilterSize", "matchPOS", "filpos", " filterpos", "filterPOS", "filNeg", "FilterPos", "FilterNeg", "filterpos", " filterPOS", "matchPos", "filterNeg", "Filterpos", " filterNeg", "filPos", "FilterPOS", "matchpos"], "filterSize": ["blockSIZE", "filterSIZE", "blockStyle", "matchLength", "blockPos", "filterStyle", "FilterSize", "FilterSIZE", "blockSize", " filterCount", "matchSize", "filterLength", "blockHeight", "FilterStyle", " filterHeight", " filterSIZE", "FilterCount", "FilterPos", "matchHeight", "blockLength", "blockCount", "filterHeight", " filterStyle", " filterLength", "matchSIZE", "filterCount"], "i": ["multi", "id", "l", "ii", "ki", "iq", "is", "wi", "sim", "to", "xi", "ic", "pi", "index", "me", "li", "ci", "ei", "m", "x", "us", "ui", "info", "phi", "it", "gi", "ij", " ti", "ip", " ii", "y", "ims", "bi", "ie", "im", "um", "iu", "ti", " I", "ir", "ind", "uri", "or", "io", "ix", "ia", "v", "zi", "mi", "di", "ini", "\u0438", "ai", "I", "si", "f", "ri", "this"], "j": ["jump", "br", "q", "l", "jp", "ji", "dj", "bj", "er", "jit", "jack", "z", "aj", "uj", "g", "n", "r", "kj", "ng", "m", "x", "other", "bot", "it", "at", "J", "ij", "jl", "pr", "js", "bs", "y", "k", "ch", "jo", "ie", "el", "je", "jc", "fr", "ion", "oj", "ind", "bo", "pt", "ja", "v", "on", "o", "by", " J", "kid", "obj", "jj", "json"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "MigrationState *migrate_get_current(void)\n\n{\n\n    static MigrationState current_migration = {\n\n        .state = MIG_STATE_NONE,\n\n        .bandwidth_limit = MAX_THROTTLE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n    };\n\n\n\n    return &current_migration;\n\n}\n", "idx": 3320, "substitutes": {}}
{"project": "qemu", "commit_id": "25e5e4c7e9d5ec3e95c9526d1abaca40ada50ab0", "target": 1, "func": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n", "idx": 3322, "substitutes": {"sockfd": [" sockfp", "socksfp", " sinkaddr", " sockpid", " sessfp", " sockfs", "sixfd", " sockaddr", " sesspid", "sinkaddr", "sixfile", "sockfile", "socksfile", "sockfs", " sinkfs", " sessfd", "sixaddr", "sinkfs", "srcpid", "srcfp", "socksfd", " sockptr", "sinkfd", "sockaddr", "socksaddr", "sockpid", "socksptr", "sixfs", "sockptr", "socksfs", " sinkfile", "sockspid", " sockfile", "sesspid", " sinkfd", "srcfd", "sessfp", "sockfp", "sessptr", "srcptr", " sessptr", "sessfd", "sinkfile"], "iov": ["liv", "inv", "vo", "usb", "vr", "uj", "conv", "rov", "iva", "icon", "vp", "voc", "ij", "mus", "iv", "voice", "tv", "chrom", "iper", "ilo", "iu", "ovi", "ir", "iour", "isco", "eur", "iop", "io", "river", "v", "nov", "iev", "iol", "gov", "ivic", "serv", "veh"], "ret": ["mt", "RET", "try", "tmp", "ext", "read", "iter", "out", "ne", "gt", "xt", "buffer", "prime", "response", "got", "true", "ry", "rm", "vers", "done", "reset", "resp", "re", "mem", "back", "net", "next", "result", "deg", "num", "msg", "Ret", "ptr", "rev", "alt", "ter", "offset", "tr", "elt", "not", "total", "j", "cat", "jp", "buf", "code", "dt", "fun", "lt", "progress", "res", "info", "ord", "ed", "err", "val", "rets", "det", "rem", "flag", "repl", "len", "cmd", "success", "data", "status", "txt", "sent", "def", "desc", "rt", "ben", "nz", "t", "pro"]}}
{"project": "qemu", "commit_id": "e24e49e6194626e4ec9f1aecce6d6a6847320bce", "target": 1, "func": "static int qcow2_change_backing_file(BlockDriverState *bs,\n\n    const char *backing_file, const char *backing_fmt)\n\n{\n\n    return qcow2_update_ext_header(bs, backing_file, backing_fmt);\n\n}\n", "idx": 3327, "substitutes": {"bs": ["sis", "ls", "cks", "bc", "bh", "ss", "bm", "vs", "bp", "ses", "ds", "qs", "aks", "fs", "ubs", "lbs", "BS", "iss", "its", "bb", "bos", "aos", "ns", "bis", "ts", "cs", "ks", "bes", "bps", "hs", "sts", "blog", "gs", "bas", "sb", "bf", "bn"], "backing_file": ["backingphppath", "backing___channel", "backding_path", "backing_url", "backing_channel", "backing___path", "backingphpchannel", "backing___file", "backingPpath", "backding_url", "backing_FILE", "backingphpfile", "backing___FILE", "backingphpFILE", "backingPurl", "backding_FILE", "backing_path", "backding_channel", "backingPfile", "backding_file"], "backing_fmt": ["backing_Fformat", "backing_mdr", "backing_Flt", "backing_fats", "backing_figats", "backing_fpid", "backing_mformat", "backing_figpid", "backing_vmt", "backing_vdr", "backing_vformat", "backing_mlt", "backing_vats", "backing_fdr", "backing_fformat", "backing_vpid", "backing_vlt", "backing_figmt", "backing_Fdr", "backing_mmt", "backing_Fmt", "backing_flt", "backing_figformat"]}}
{"project": "FFmpeg", "commit_id": "a4f6be86d67ae30d494fbe8a470bc32b715d75a9", "target": 0, "func": "static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 3330, "substitutes": {"pix": ["cpw", "npixels", "Pix", "pik", " pIX", "cpixels", "cpix", " px", "Pik", "PIX", "paik", "cpx", "pw", "npx", "paIX", "px", "cpIX", "Pixels", "pIX", "Pw", " pik", "pixels", "pax", " pixels", "Px", "paix", " pw", "npIX", "npix"], "stride": ["strider", "divide", " strension", "stension", "strue", "tride", "swride", "strension", "divke", " strine", " strider", "stue", "sprension", " strride", "trine", "sprride", "strine", "swider", "stider", " strke", "stide", " strue", "swide", "stine", "sprke", "true", "strke", "trride", "swension", "strride", "divride", "spride", "divension"], "bS": ["brC", " bWS", "bbFS", " bP", "bP", "baFS", "subRS", "bbAS", "bgRS", "subEMS", "bWS", "bbSeries", "subArray", "bbS", "subUS", "bgUS", "baAS", "wbSeries", " bAS", "nbScreen", "bgS", "bScreen", " bScreen", "nbS", "baseEMS", "nbEMS", "brFS", " bArray", "subFS", " bRS", " bSeries", "bC", "baseScreen", "baS", "baseRS", "bbSU", " bUS", "wbP", "brAS", "bSeries", "brSU", "nbRS", "bUS", "subN", " bSU", "bSU", "wbS", "bRS", "bbEMS", "baWS", "bEMS", "bbC", "bbN", "brS", "bAS", "bgArray", "bbP", "bArray", "baseS", "bFS", " bN", " bEMS", "bN", " bFS", "brWS", " bC", "subS"], "qp": ["iqnp", " qpad", "Qpad", "qqnp", "qum", "qupc", "qP", "qqp", "qpc", " qP", "QP", "Qp", "qqP", "iqpc", "dqm", "qup", "iqm", "dqp", "qm", "qnp", "qud", "qd", "qpad", "iqp", "qunp", "qqpc", "dqd", "qqm", "qqd", "qqpad"], "h": ["php", "j", "l", "he", "ph", "c", "host", "handle", "sh", "bh", "p", "kh", "g", "eh", "hw", "oh", "ah", "H", "hh", "comm", "hp", "m", "header", "b", "dh", "ih", "cache", "history", "sw", "k", "ch", "hd", "hl", "w", "e", "rh", "hi", "ctx", "hal", "hs", "hm", "hz", "v", "hash", "o", "f", "th", "t", "ht"], "tc": ["multi", "ec", "acc", "ctr", "cas", " TC", "fc", "temp", "tmp", "tim", "c", "pc", "bc", "tt", "unc", "css", "tif", "dc", "cus", "uc", "ic", "ca", "times", "FC", "ci", "asc", "td", "tic", "cot", "sc", "cache", "tf", "cci", "ta", "tv", "toc", "cf", "cv", "cs", "ts", "ctx", "gc", "tu", "currency", "cu", "cc", "icc", "beta", "cm", "rc", "lc", "ac", "timeout", "t", "mc", "ctrl", "TC", "cca"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,\n\n                          const char *boot_device,\n\n                          DisplayState *ds, const char *kernel_filename,\n\n                          const char *kernel_cmdline,\n\n                          const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    unsigned int i;\n\n    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;\n\n    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,\n\n        *espdma_irq, *ledma_irq;\n\n    qemu_irq *esp_reset, *le_reset;\n\n    ram_addr_t ram_offset, prom_offset, tcx_offset;\n\n    unsigned long kernel_size;\n\n    int ret;\n\n    char buf[1024];\n\n    int drive_index;\n\n    void *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    if (!cpu_model)\n\n        cpu_model = hwdef->default_cpu_model;\n\n\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        cpu_sparc_set_id(env, i);\n\n        envs[i] = env;\n\n        if (i == 0) {\n\n            qemu_register_reset(main_cpu_reset, env);\n\n        } else {\n\n            qemu_register_reset(secondary_cpu_reset, env);\n\n            env->halted = 1;\n\n        }\n\n        cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);\n\n        env->prom_addr = hwdef->slavio_base;\n\n    }\n\n\n\n    for (i = smp_cpus; i < MAX_CPUS; i++)\n\n        cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > hwdef->max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(hwdef->max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    ram_offset = qemu_ram_alloc(RAM_size);\n\n    cpu_register_physical_memory(0, RAM_size, ram_offset);\n\n\n\n    /* load boot prom */\n\n    prom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\n\n    cpu_register_physical_memory(hwdef->slavio_base,\n\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\n\n                                 TARGET_PAGE_MASK,\n\n                                 prom_offset | IO_MEM_ROM);\n\n\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX)\n\n        ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);\n\n    if (ret < 0 || ret > PROM_SIZE_MAX) {\n\n        fprintf(stderr, \"qemu: could not load prom '%s'\\n\",\n\n                buf);\n\n        exit(1);\n\n    }\n\n\n\n    /* set up devices */\n\n    sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs);\n\n\n\n    for (i = 0; i < MAX_IOUNITS; i++)\n\n        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)\n\n            iounits[i] = iommu_init(hwdef->iounit_bases[i],\n\n                                    hwdef->iounit_version,\n\n                                    sbi_irq[hwdef->me_irq]);\n\n\n\n    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq],\n\n                              iounits[0], &espdma_irq, &esp_reset);\n\n\n\n    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq],\n\n                             iounits[0], &ledma_irq, &le_reset);\n\n\n\n    if (graphic_depth != 8 && graphic_depth != 24) {\n\n        fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphic_depth);\n\n        exit (1);\n\n    }\n\n    tcx_offset = qemu_ram_alloc(hwdef->vram_size);\n\n    tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,\n\n             hwdef->vram_size, graphic_width, graphic_height, graphic_depth);\n\n\n\n    if (nd_table[0].model == NULL)\n\n        nd_table[0].model = \"lance\";\n\n    if (strcmp(nd_table[0].model, \"lance\") == 0) {\n\n        lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);\n\n    } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n        fprintf(stderr, \"qemu: Supported NICs: lance\\n\");\n\n        exit (1);\n\n    } else {\n\n        fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n        exit (1);\n\n    }\n\n\n\n    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0,\n\n                        hwdef->nvram_size, 8);\n\n\n\n    slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq],\n\n                          sbi_cpu_irq, smp_cpus);\n\n\n\n    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq],\n\n                              nographic, ESCC_CLOCK, 1);\n\n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n\n    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],\n\n              serial_hds[0], ESCC_CLOCK, 1);\n\n\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    main_esp = esp_init(hwdef->esp_base, 2,\n\n                        espdma_memory_read, espdma_memory_write,\n\n                        espdma, *espdma_irq, esp_reset);\n\n\n\n    for (i = 0; i < ESP_MAX_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_SCSI, 0, i);\n\n        if (drive_index == -1)\n\n            continue;\n\n        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);\n\n    }\n\n\n\n    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,\n\n                                    RAM_size);\n\n\n\n    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,\n\n               boot_device, RAM_size, kernel_size, graphic_width,\n\n               graphic_height, graphic_depth, hwdef->nvram_machine_id,\n\n               \"Sun4d\");\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n}\n", "idx": 3333, "substitutes": {"hwdef": ["hawds", "fwdef", "hwDef", "hddev", "htmd", "fwref", "iwref", "htds", "hawDef", "hhconf", "hwref", "cmdDef", "hdname", "cmddel", "fwdefinition", "hwdev", "swdev", "hawdef", "fwmd", "hwdel", "htdef", "iwmd", "hwds", "htdefinition", "htDef", "hhDef", "iwdev", "fwconf", "hwname", "swdef", "iwname", "hddef", "htref", "hwmd", "hwconf", "hdDef", "fwDef", "iwdef", "fwdel", "iwDef", "swDef", "fwds", "cmdconf", "hhdef", "cmddef", "swname", "hawdefinition", "hhdel", "hwdefinition"], "RAM_size": ["RAMThesend", "RAM_send", "RAMThesize", "RAM_SIZE", "RAM_len", " RAM_ize", "RAMLESIZE", "RAM_ize", "Ram_send", "Ram_size", "RAM_Size", "RAMLEsize", " RAM_SIZE", "RAMTheSize", "Ram_Size", " RAM_len", "RAMLElen", "RAMLEize"], "boot_device": ["boot_block", "bootmodblock", "bootmodbuffer", "cpu_block", "boot_buffer", "cpu_device", "cpu_drive", "cpu_buffer", "boot_drive", "bootmoddrive", "bootmoddevice"], "ds": ["d", "DS", "dt", "Ds", "ss", "dd", "s", "ses", "eds", "dh", "ps", "bs", "dm", "sd", "dl", "df", "cs", "dos", "de", "db", "sts", "rs", "du", "pd", "da", "des", "ys", "vd"], "kernel_filename": ["kernel__fn", "system_file", "kernel_Filename", "kernel__Filename", "kernel_fn", "kernel_file", "system_fn", "kernel__filename", "system_Filename", "system_filename", "kernel__file"], "kernel_cmdline": ["kernel_workline", "kernel_workdir", "kernel_workl", "kernel_ctrl", "kernel_commandl", "kernel_commandline", "kernel_cmddir", "kernel_ctrline", "kernel_cmdl", "kernel_ctrdir", "kernel_commanddir"], "initrd_filename": ["initrdfilesid", "initrd_file", "initrbfilesid", "initrdfilefilename", "initrbfiledll", "initrdfilefile", "initrbfilefile", "initrb_file", "initrb_filename", "initrb_dll", "initrdfiledll", "initrb_sid", "initrbfilefilename", "initrd_sid", "initrd_dll"], "cpu_model": ["cp_model", "cpugModel", "cpu_tree", "CPU_model", "cpu_mode", "pu_Model", "CPU_models", "cpu_Model", "cpugmodel", "CPU_Model", "cpu_models", "cpuetytree", "cp_models", "pu_mode", "cpu_device", "pu_model", "cpuetymodels", "CPU_tree", "cpuetymodel", "CPU_link", "cp_policy", "pu_link", "cpuetyModel", "cpuglink", "cp_Model", "cpugdevice", "CPU_device", "cpu_link", "cpu_policy"], "env": ["usr", "eas", "ext", "ev", "window", "server", "menu", "var", "qt", "vp", "req", "ef", "conf", "vm", "vv", "context", "buffer", "here", "equ", "manager", "console", "h", "mem", "eng", "era", "ec", "tk", "vs", "pb", "box", "viron", "environment", "cb", "esc", "export", "policy", "cookie", "shell", "end", "ptr", "gate", "ew", "esp", "door", "uv", "enc", "er", "code", "gear", "vr", "ah", "vt", "engine", "ei", "va", "info", "entry", "dev", "eu", "sw", "timer", "err", "el", "en", "ctx", "ped", "db", "v", "di", "erd", "ve", "worker", "cmd", "proc", "et", "inv", "conn", "txt", "cfg", "nv", "pe", "def", "js", "desc", "cv", "e", "event", "ee", "obj"], "envs": ["Enps", " enves", "renves", "inv", "entrs", "entvs", "endVs", "invs", "entfs", " enps", "endvs", " enVs", "entps", "renv", "renps", " enrs", "Enrs", " envas", "enfs", "enrs", "endvas", "envas", "Envs", "enVs", "Envas", "EnVs", "endfs", "enves", "renvs", "enps", "inves", "Enfs", " enfs", "inps"], "MAX_CPUS": ["MAX_CPUUS", "MAX_CHus", "MAX__GPUS", "MAX_TPUS", "MAX_CAPPS", "MAX__CPUS", "MAX_CPIS", "MAX_GPIS", "MAX_CAPIS", "MAX__GPIS", "MAX_CAPus", "MAX_CAPUS", "MAX__CPus", "MAX_CPINS", "MAX_CAPINS", "MAX_CPUINS", "MAX_CPAS", "MAX_TPus", "MAX_CHOS", "MAX_CHUS", "MAX__GPINS", "MAX_MPPS", "MAX__CPINS", "MAX_TPPS", "MAX_CPUAS", "MAX_CPus", "MAX_CPUIS", "MAX_GPUS", "MAX__CPIS", "MAX__GPus", "MAX_TPIS", "MAX_GPus", "MAX_CHAS", "MAX_CPUOS", "MAX_CPUus", "MAX_Pus", "MAX_GPINS", "MAX_POS", "MAX_CPOS", "MAX_MPIS", "MAX_PUS", "MAX_MPus", "MAX_CPPS", "MAX_MPUS", "MAX_PAS"], "i": ["id", "parent", "c", "p", "n", "li", "x", "us", " ti", "iu", "ti", "ind", "ix", "zi", "ini", "I", " bi", "batch", "q", " j", "xi", "ic", "qi", "m", "ui", "it", "gu", "ims", "im", "name", "\u0438", "ri", "j", "l", "ii", "ji", "z", "pi", "index", "me", "ci", "ei", "info", "phi", "ij", "fi", " ii", "y", "bi", "hi", " I", "go", "v", "mi", "di", "ai", "si", "multi", "ki", "is", "sim", "g", "ami", "b", "cli", "gi", "ip", "oi", "ie", "e", "print", "dr", "in", "o", "t"], "iounits": ["nounit", "iounities", "iowITS", "iumnITS", "numnities", "iumnities", "iunITS", "iumnit", "iunits", "iunities", "iounit", "nounits", "iowit", "iowities", "iumnits", "numnit", "nounITS", "iounITS", "iunit", "numnits", "nounities", "numnITS", "iowits"], "MAX_IOUNITS": ["MAX_IUNITS", "MAX_IounITS", "MAX_IounITIES", "MAX_ICUNITS", "MAX_IOUNits", "MAX_ICUNITIES", "MAX_IUNits", "MAX_IOUNIT", "MAX_IUNIT", "MAX_ICUNIT", "MAX_ICounIT", "MAX_ICounITIES", "MAX_Iounits", "MAX_IOUNITIES", "MAX_ICounITS", "MAX_ICounits", "MAX_ICUNits", "MAX_IounIT", "MAX_IUNITIES"], "espdma": ["espdlma", "espnma", " espdMA", "espdca", " espdmas", " espdca", "espdhca", " espnca", "espdlMA", " espnMA", "espdlca", " espnmas", "espnmas", "espnMA", "espdmas", "espdhMA", "espdMA", "espdhmas", "espdhma", "espdlmas", "espnca", " espnma"], "ledma": ["iledda", "iledma", "aledda", "oledmas", "oledma", "iledmas", "aledama", "oledda", "ledda", "ledama", "ledmas", "iledama", "aledmas", "aledma", "oledama"], "main_esp": ["primary_ema", "primary_exe", "main_cp", "main_exe", "main_ema", "primary_cp", "primary_esp"], "nvram": ["nvrom", "nbgram", "nvgram", "NVgram", "ndram", "nbrom", "ndgram", "nvRAM", "ndRAM", "NVram", "nbram", "nbRAM", "NVRAM", "ndrom", "NVrom"], "sbi": ["psgi", "esci", "sli", "esgi", "psli", "psbi", "esbi", " sli", " sci", "psci", "esli", "sgi", " sgi", "sci"], "cpu_irqs": ["cpu_rirqs", "cpu_____irqs", "cpu_____rirq", "cpu_irtqs", "cpu_irques", "cpu_rirq", "cpu_rinq", "cpu_rinps", "cpu_pirrics", "cpu_irtq", "cpu_rirls", "cpu_iriq", "cpu_rirrics", "cpu_iriqs", "cpu_iriques", "cpu_____rirqs", "cpu_____irques", "cpu_arques", "cpu_____rirques", "cpu_____irq", "cpu_irls", "cpu_pirq", "cpu_pirques", "cpu_irips", "cpu_rinqs", "cpu_____irrics", "cpu_pirqs", "cpu_irps", "cpu_rinques", "cpu_irrics", "cpu_pirls", "cpu_rirques", "cpu_____rirrics", "cpu_irtls", "cpu_pirps", "cpu_arqs", "cpu_irq", "cpu_arq", "cpu_arrics"], "sbi_irq": ["sbi_pirq", "sbi_irev", "sbi_ireqs", "sbi_pirv", "sbi_ireq", "sbi_irQ", "sbi_mirqs", "sbi_mirQ", "sbi_irv", "sbi_pirQ", "sbi_pirqs", "sbi_mirq", "sbi_irqs", "sbi_mirv", "sbi_ireQ"], "sbi_cpu_irq": ["sbi_cpu_virqs", "sbi_cpu_virq", "sbi_cpu_pirq", "sbi_cpu_rque", "sbi_cpu_irque", "sbi_cpu_rq", "sbi_cpu_pirque", "sbi_cpu_virque", "sbi_cpu_virQ", "sbi_cpu_pirqs", "sbi_cpu_rQ", "sbi_cpu_irqs", "sbi_cpu_rqs", "sbi_cpu_pirQ", "sbi_cpu_irQ"], "espdma_irq": ["espdma_rirq", "espdma_pirqs", "espdma_rirqs", "espdma_irqu", "espdma_arqu", "espdma_pirqu", "espdma_rirresh", "espdma_pirresh", "espdma_arqs", "espdma_pirq", "espdma_irqs", "espdma_rirqu", "espdma_arresh", "espdma_arq", "espdma_irresh"], "ledma_irq": ["ledma_irsqs", "ledma_rquire", "ledma_irquire", "ledma_rql", "ledma_irqs", "ledma_irql", "ledma_irsq", "ledma_rqs", "ledma_rq", "ledma_IRqs", "ledma_irsquire", "ledma_IRq", "ledma_IRql", "ledma_irsql", "ledma_IRquire"], "esp_reset": ["esp_eval", "esp___template", " esp_template", "esp___eval", "esp___set", " esp_set", "esp_set", "esp_template", "esp___reset", " esp_eval"], "le_reset": ["lu_mem", "lu_offset", "le_mem", "lu_reset", "lu_init", "le_offset", "le_init"], "ram_offset": ["ram2index", "RAM_offset", "RAM_address", "RAM_index", "ram_address", "RAM_location", "ram2offset", "ram2location", "ram2address", "ram_location", "ram_index"], "prom_offset": ["Prom_pos", "Prom_address", "prom_addr", "prom_address", "Prom_offset", "prom_pos", "Prom_addr"], "tcx_offset": ["tcX_error", "tcx2error", "tcx_index", "tcx2index", "tcX_offset", "tcx_Offset", "tcX_index", "tcx_error", "tcx2Offset", "tcx2offset", "tcX_Offset"], "kernel_size": ["cpu_size", "cpu_SIZE", "kernel_offset", "kernel_SIZE", "kernel_count", "kernel2count", "kernel2SIZE", "kernel2size", "kernel2offset", "cpu_offset", "cpu_count"], "ret": ["j", "RET", "RI", "status", "result", "ref", "set", "res", "def", "mem", "rin", "Ret", "rt", "alt", "re", "ter", "io", "ry", "val", "rets", "si", "rem", "reset", "flag", "ri", "ib"], "buf": ["proc", "batch", "func", "code", "count", "img", " buffer", "ref", "cb", "var", "b", "family", "off", "cache", "vec", "uf", "cap", "block", "desc", "buffer", "cv", "cast", "ptr", "str", "Buffer", "array", "map", "buff"], "drive_index": ["drive_offset", "drive_id", "disk_offset", "disk_index", "disk_handle", "drive2offset", "drive_handle", "drive2handle", "drive2index", "drive2id", "disk_id"], "fw_cfg": ["fw__cfg", "fw2cfg", "fw_log", "fw2log", "FW_cfg", "FW_config", "FW_log", "fw_config", "fw__log", "FW_fg", "fw2fg", "fw_fg", "fw__config", "fw2config", "fw__fg"]}}
{"project": "qemu", "commit_id": "88571882516a7cb4291a329c537eb79fd126e1f2", "target": 0, "func": "static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested)\n\n{\n\n    int num_cq_events = 0, ret = 0;\n\n    struct ibv_cq *cq;\n\n    void *cq_ctx;\n\n    uint64_t wr_id = RDMA_WRID_NONE, wr_id_in;\n\n\n\n    if (ibv_req_notify_cq(rdma->cq, 0)) {\n\n        return -1;\n\n    }\n\n    /* poll cq first */\n\n    while (wr_id != wrid_requested) {\n\n        ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n        if (wr_id == RDMA_WRID_NONE) {\n\n            break;\n\n        }\n\n        if (wr_id != wrid_requested) {\n\n            DDDPRINTF(\"A Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                print_wrid(wrid_requested),\n\n                wrid_requested, print_wrid(wr_id), wr_id);\n\n        }\n\n    }\n\n\n\n    if (wr_id == wrid_requested) {\n\n        return 0;\n\n    }\n\n\n\n    while (1) {\n\n        /*\n\n         * Coroutine doesn't start until process_incoming_migration()\n\n         * so don't yield unless we know we're running inside of a coroutine.\n\n         */\n\n        if (rdma->migration_started_on_destination) {\n\n            yield_until_fd_readable(rdma->comp_channel->fd);\n\n        }\n\n\n\n        if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) {\n\n            perror(\"ibv_get_cq_event\");\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        num_cq_events++;\n\n\n\n        if (ibv_req_notify_cq(cq, 0)) {\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        while (wr_id != wrid_requested) {\n\n            ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n            if (ret < 0) {\n\n                goto err_block_for_wrid;\n\n            }\n\n\n\n            wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n            if (wr_id == RDMA_WRID_NONE) {\n\n                break;\n\n            }\n\n            if (wr_id != wrid_requested) {\n\n                DDDPRINTF(\"B Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                    print_wrid(wrid_requested), wrid_requested,\n\n                    print_wrid(wr_id), wr_id);\n\n            }\n\n        }\n\n\n\n        if (wr_id == wrid_requested) {\n\n            goto success_block_for_wrid;\n\n        }\n\n    }\n\n\n\nsuccess_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return 0;\n\n\n\nerr_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3348, "substitutes": {"rdma": ["rdca", "rhmo", "rwMA", "drca", "redca", "irdma", "redmo", "rdmu", "redmeta", "rdman", "redta", "rrma", "redvm", "rwma", "drta", "rodta", "rwbase", "drbase", "rodza", "ordme", "rdda", "rodmu", "drma", "drka", "drza", "rrman", "ordma", "ldma", "rdna", "drvm", "rrka", "rodvm", "redmar", "rhma", "rdmo", "rodca", "rrna", "irdna", "rdta", "rodbase", "ldmar", "rdka", "redda", "rwman", "ldme", "rdme", "rodma", "drmad", "rhda", "ordmar", "drda", "rrta", "ordmeta", "redma", "rodMA", "rdza", "rdmar", "rrmo", "rodda", "redMA", "redman", "rhMA", "redza", "rdbase", "rdMA", "irdka", "rrmad", "rdmad", "irdmad", "rdvm", "drna", "rodman", "ldmeta", "drmu", "drman", "redme", "rdmeta", "drMA", "redmu", "rodmo"], "wrid_requested": ["wrid_accessured", "wrid_maskor", "wrid4requested", "wrid_requestal", "wrid_threadized", "wrid_processed", "wrid_quested", "wrid_downired", "wrid_requester", "wrid_Requestred", "wrid_requestred", "wrid_returne", "wrid_accepting", "wrid_weighted", "wrid_accessed", "wrid_weighter", "wrid_requestared", "wrid_requesting", "wrid_beginumed", "wrid_downumed", "wrid_maskal", "wrid_reqing", "wrid_reqed", "wridpyrequestped", "wrid_reqe", "wrid_threadable", "wrid_returning", "wrid_projectedIn", "wrid_requestized", "wrid_accepted", "wrid_goed", "wrid_threaded", "wrid_Requestation", "wrid_reqeded", "wrid_accessable", "wrid_weightedIn", "wrid_returned", "wrid_processized", "wrid_returnred", "wrid_maskued", "wrid4requestued", "wrid_returnued", "wrid_acceptation", "wrid_requesteded", "wrid_counted", "wrid_downed", "wrid_conditional", "wrid_weightared", "wrid_conditionor", "wrid_goped", "wrid_projected", "wrid_counte", "wrid_goired", "wrid_processured", "wrid_accepte", "wrid_reqred", "wrid_projecter", "wrid_goumed", "wrid_requeste", "wrid_Requesting", "wrid_beginired", "wrid_requestued", "wrid_requestable", "wrid_questared", "wrid_requestired", "wrid_returnor", "wridpyrequested", "wrid_requestured", "wrid_quester", "wrid_projectared", "wrid_Requeste", "wrid_downped", "wrid4returned", "wridpydownumed", "wrid_processable", "wrid_beginped", "wrid_requestumed", "wridpydowned", "wridpyrequestired", "wrid4requestor", "wrid_returnal", "wridpydownired", "wrid_counteded", "wrid_conditionued", "wrid4requestal", "wrid_threadured", "wrid4returnal", "wrid_masked", "wrid_begined", "wrid_counting", "wrid_Requesteded", "wrid_conditioned", "wridpyrequestumed", "wrid_Requested", "wrid_accessized", "wrid4returnor", "wrid_requestor", "wrid_requestation", "wrid4returnued", "wrid_requestedIn", "wrid_reqation", "wrid_questedIn", "wridpydownped", "wrid_requestped"], "cq": ["rcq", "acq", "cck", "cqu", "xcck", "xcmp", " cue", " cqq", "pcqu", "acmp", "dcqu", "xcql", " cqu", "cql", "rcqu", "acck", "cQ", "ccck", "rcQ", "uncq", "cacheux", "cqq", "cue", "dcue", "cmp", "xcq", "rcue", "pcue", "dcq", "rcqq", "cux", "ccq", "pcqq", "pcux", "ccmp", "dcQ", "uncue", "uncQ", "acql", "pcQ", "pcq", "cacheq", " cux", "cacheQ", "uncqu", "cachequ", "ccql", " cQ"], "cq_ctx": ["cqq_cb", "cqq_context", "cue_addr", "cue_tx", "cq_cb", "cue_ctx", "cue_context", "cqq_tx", "cqq_ctx", "cq_addr", "cq_context", "cq_tx"], "wr_id_in": ["wr_id_In", "wr_name__raw", "wr_name_raw", "wr_name_in", "wr_id___input", "wr_name_inner", "wr_id___on", "wr_id___In", "wr_name__inner", "wr_sid_input", "wr_sid___In", "wr_name_IN", "wr_id_0", "wr_id_local", "wr_name__in", "wr_sid___input", "wr_id_ins", "wr_id_inner", "wr_id_input", "wr_id_out", "wr_id__raw", "wr_name__out", "wr_id__0", "wr_name_ins", "wr_id__out", "wr_sid___in", "wr_id___in", "wr_id__ins", "wr_id_IN", "wr_sid_in", "wr_id_raw", "wr_id__on", "wr_id__inner", "wr_id___ins", "wr_id__in", "wr_name_out", "wr_id_on", "wr_id___0", "wr_sid_In"], "num_cq_events": ["num_cqxevents", "num_cqs_reads", "num_cqs_obs", "num_cq_obs", "num_cq_reads", "num_cqs_events", "num_cqxerrors", "num_cqs_event", "num_cq_event", "num_cqxobs", "num_cqs_errors", "num_cq_errors", "num_cqxevent"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t *)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    __asm__ volatile(\"pxor    %%mm7,%%mm7    \\n\\t\":::\"memory\");\n\n    __asm__ volatile(\"pcmpeqd %%mm6,%%mm6    \\n\\t\":::\"memory\");\n\n    mm_end = end - 3;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            PACK_RGB32\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r)\n\n            :\"memory\");\n\n        d += 16;\n\n        s += 4;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n        *d++ = 255;\n\n    }\n\n}\n", "idx": 3375, "substitutes": {"src": ["input", "inst", "usr", "ctr", "sh", "source", "ss", "sv", "img", "r", "out", "b", "ur", "cont", "sc", "start", "cur", "obs", "sur", "bs", "sub", "sr", "ptr", "cs", "rl", "dest", "ind", "rt", "loc", "rs", "in", "rc", "sb", "st", "ins", "tr", "sn"], "dst": [" ddest", "dcr", "rst", "dsdest", "Ddest", "Dcr", "ddest", "dscr", "Dest", "dsest", "dtr", " dtr", " dsrc", "dsst", " dcr", " dnd", " dest", "rsrc", "vsrc", "dsrc", "dest", "Dst", "vst", "rnd", "vnd", "vtr", "rtr", "dnd"], "src_size": ["src_Size", "src_scale", " src_Size", " src_SIZE", "src_no", "src_SIZE", " src_scale", " src_no"], "end": ["END", "id", "ff", "size", "rest", "nd", "z", "p", "ent", "ast", "all", "r", "out", "set", "send", "m", "ending", "i", "b", "close", "full", "start", "ended", "stop", "w", "e", "en", "append", "End", "dest", "until", "offset", "v", "last", "h", "est", "max", "ad", "f", "st", "t", "se", "length"], "mm_end": ["mi_end", "mi_ends", "mm_ended", "mm_ref", "mmm_end", "mi_ref", "mm_ends", "mmm_bound", "MM_ended", "mm_End", "mm_END", "MM_offset", "mm_start", "mm_bound", "mm_offset", "MM_start", "mmm_ended", "mmm_End", "mi_END", "MM_end"], "d": ["doc", "data", "j", "id", "message", "l", " D", "status", "dt", "c", "bd", "z", "p", "dd", "g", "n", "dc", "dict", "r", "dump", "debug", "out", "ds", "send", "m", "i", "b", "x", "u", "dat", "new", "dh", "dra", "y", "sd", "diff", "w", "e", "dos", "de", "amd", "db", "fd", "dr", "v", "h", "di", "o", "draw", "done", "ct", "f", "du", "D", "pd", "st", "da", "t", "dis", "ld", "dn"], "s": ["sys", "ls", "S", "south", "j", "stats", "l", "size", "c", "is", "sv", "ss", "p", "source", "es", "g", "n", "sl", "r", "ds", "m", "i", "b", "start", "ps", "its", "js", "ns", "bs", "ims", "w", "e", "ms", "ts", "cs", "ies", "sm", "hs", "sts", "v", "rs", "ows", "h", "gs", "si", "sb", "ins", "st", "os", "ats", "des", "t", "a", "se", "sp"], "bgr": ["mbr", " bdr", "fbGr", "sbgr", "bgre", "bdr", "bbgr", "bitgr", "sbtr", "sbgre", "BGr", "rbgr", "Bgr", "bitGr", "fbtr", "bGR", "bbbr", "bbGR", " bGr", "bbge", "mGR", "rbGr", "Bdr", "mge", "mGr", "labGr", "busr", "bbr", "bitbr", " brg", "mrg", "rbbr", " bbr", "fbgr", " bge", "bGr", "Bbr", "rbdr", "labgr", "musr", "bitusr", " btr", " busr", "labrg", "fbgre", "sbGr", "bge", "mgr", "brg", " bgre", "btr", " bGR", "labbr"]}}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n", "idx": 3392, "substitutes": {"opaque": ["Opvious", "OPatile", "ipque", "operaque", " oplay", " opque", "iopen", "pque", "iopque", "oblay", "open", "Opaque", "OPaque", "opute", "pacity", "pen", "operque", "paque", "opacity", "Opute", "OPvious", "operacity", "opsaque", "Opatile", "opque", "opvious", "iopaque", "ipaque", "opsatile", "oplay", "operen", "obacity", "iopacity", "obque", "iplay", "opsvious", "opsute", "ipacity", "OPute", " opacity", "opatile", "obaque"], "chr": ["charlr", "chnru", "echusr", "chrh", "echrator", "chertx", "chnusr", " chlr", "echrb", "gerrh", "chtx", "tchusr", "tchar", "chrg", "chorh", "chro", "chnrator", "chrb", "cherg", "chorator", "chrc", "chusr", "chnar", "echr", " chrer", "charrer", " chrb", "charr", "cheR", "echrer", "echrc", "chorg", "chntx", "tchru", "chrer", "tchro", "tchr", "charR", "chlr", "cherru", "cherc", "cherr", "gerrg", "cherh", "chru", " chrc", "gerr", "cherator", "tchtx", "chnro", "cherro", "cherer", "gerrator", "chnr", "cher", "chor", "tchrator", "chR", " chR", "cherb", "chelr", "echar", "chrator"], "d": ["j", "l", "dj", "c", "dt", "nd", "bd", "z", "p", "dd", "g", "n", "dc", "dir", "r", "debug", "ds", "dat", "m", "b", "i", "gd", "md", "new", "dh", "ord", "dev", "dm", "sd", "did", "hd", "dl", "der", "e", "ind", "de", "or", "db", "fd", "dr", "v", "o", "di", "driver", "h", "dp", "ad", "f", "du", "pd", "D", "da", "t", "a", "dis", "ld", "dn"]}}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n", "idx": 3394, "substitutes": {"s": ["ls", "d", "S", "c", "is", "ss", "p", "es", "ses", "ds", "qs", "b", "fs", "aws", "ps", "its", "js", "ns", "w", "ms", "ts", "ains", "hs", "has", "sts", "rs", "h", "gs", "ats", "sb", "states", "os", "t", "a", "self"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,\n\n                                     const uint8_t *src_in[4],\n\n                                     int srcW, int xInc, const int16_t *hChrFilter,\n\n                                     const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                     uint8_t *formatConvBuffer, uint32_t *pal)\n\n{\n\n    const uint8_t *src1 = src_in[1], *src2 = src_in[2];\n\n    if (c->chrToYV12) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    } else if (c->readChrPlanar) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst1, dst2, dstWidth);\n\n}\n", "idx": 3397, "substitutes": {"c": ["ec", "vc", "d", "cp", "fc", "cd", "cr", "pc", "bc", "nc", "unc", "cn", "p", "cal", "g", "dc", "ca", "ic", "uc", "ci", "mc", "set", "cb", "com", "b", "ce", "C", "cont", "sc", "cache", "etc", "cur", "cmp", "can", "call", "conf", "ch", "cf", "cv", "w", "cam", "cs", "ctx", "comp", "con", "co", "coll", "enc", "container", "gc", "anc", "v", "abc", "cu", "cc", "h", "ct", "cl", "f", "rc", "cm", "lc", "ac", "t", "tc", "chain"], "dst1": ["dest01", " dct2", "dest2", "destIn", " dest1", "dnd2", " dest2", "dst01", "dsts2", "dv1", "dnd0", "dest4", "dsts1", "dsty1", "dv0", "dstIn", "ddestIn", "dct1", "dstA", "Dst2", "dsts4", " dct01", " dct0", "dsrc2", "dstyA", "ddest2", "Dst0", "DestA", "Dest4", "dstOne", "Dest2", "dst4", " dstIn", " destIn", "dct0", " dct1", "dstsA", "Dst4", " dst01", " destOne", "dest0", "dnd1", "dsty4", "ddest1", "Dest0", "Dst1", "ddestOne", "dsty2", "dv01", "dsrcOne", "dct2", "dsrc1", "DstA", "dct01", " dst0", "destOne", " dstOne", "dst0", "dv2", "Dest1", "dest1", "destA", "dsrcIn"], "dst2": ["dist1", "duset6", " distWidth", "duset4", "dstd2", "dst6", "dusetTwo", "DestWidth", "dstTwo", "distWidth", "Dst02", "dST102", "Dest102", "dSt02", "duset2", "dust4", "dstdWidth", "dSt1", "destB", "dust2", "DstTwo", "DstWidth", "dust6", "dst102", "dist2", "dct6", "DestB", "dstr2", "dSt2", "dost2", "dest1", "dSTWidth", "dct4", "destTwo", "dost1", " dist4", "dset2", "dest02", "dstd102", "dset4", "dst4", "Dest2", "DstB", " dst4", "dsetTwo", "dct2", " dist1", "dstdTwo", "Dst102", "dSTTwo", "dost6", " dist2", "dest2", "dctTwo", "dstr1", "dest4", "dest102", "dost4", "destWidth", "dstr02", "dist4", "Dst2", "Dest02", "dset6", "dst02", "dStB", "dST2", "dustTwo", "Dst1", "dstrB", "dostTwo", "dostWidth", "dstB", "DestTwo", "Dest1"], "dstWidth": ["dsnCut", "dspWidth", "dostwidth", "sdspHeight", "sdspW", "DsrcWidth", "DstCut", "dsnHeight", " dstHeight", "dsrcH", "sdstWidth", "dsnWidth", "sdspWidth", "DestWidth", "dostH", "dSTMin", "dstsHeight", " dstH", "destMin", "dspwidth", "drcHeight", "dstsArea", "DstExp", "dtdExp", "dsrcwidth", "drtwidth", " dstMin", "dstExp", "destExp", "dsrcHeight", "dostHeight", " destW", "drtWidth", " dest2", "DstWidth", "dstCut", "dstArea", "dSTW", "dstHeight", "drtHeight", "sdspwidth", "dspW", "sdstW", "dstsCut", "sdstHeight", "DstArea", "sdstwidth", " destMin", "DsrcCut", "dsrcW", "dstH", "DsrcHeight", " drtHeight", "dstsWidth", " dstW", "dSTWidth", " drtwidth", "dsrcWidth", "dstW", "dtdW", "destHeight", "drtH", "DsrcArea", " drtWidth", "dostExp", "destPort", "dostPort", " destWidth", "dsnArea", "dspHeight", "DestHeight", "dtdHeight", "dstwidth", "drcWidth", "dtdPort", " drtH", "dtd2", "dsrcCut", "dtdWidth", "dest2", "dstMin", "destWidth", "dtdMin", "destW", "DstHeight", "DestPort", "DestExp", "DstPort", "drcwidth", "dST2", " dstwidth", "dsrcArea", "drcW", "dostWidth", "dstPort"], "src_in": ["src_out", "rc2out", "src2ind", "rc_out", "src__inner", "inst_in", "inst__out", "inst_inner", "src_im", "scan_In", " src_IN", "inst_im", " src_ins", "src2im", "rc2ind", "src_ind", "scan_out", "scan_ini", "inst__in", "src_IN", "inst__im", "rc2in", "src1i", "src2out", "inst__inner", "src_inner", "inst_out", "rc_ind", "scan_in", "src2in", "rc2i", "src2i", "src__im", "src2ins", "rc_in", "src2inner", "src1ind", "src1out", "src__out", "rc_i", "src_i", "src_ini", "src_ins", "src__in", "src2IN", " src_out", "src1in", "src2In", "src_In", "src2ini"], "srcW": [" srcWC", "rcP", "ptrH", "instw", "srcWC", "rcW", " srcV", "rc2", "usrNW", "snWC", "sourceN", "srcH", "sourceW", "sourceWh", "srcWT", "sourcew", "sortWh", "destW", "srcP", " srcWidth", "srcWh", "destH", "ptrW", "instWh", "rcV", " srcP", "sourceV", "snW", "source1", "sortW", "rcw", "source2", "srcWidth", "sourceWT", "destNW", "rc1", "usrW", " srcR", "instW", "ptrHTML", "srcNW", "snR", "sourceWidth", "instWT", "rcWC", "snV", "srcHTML", " srcw", "rcR", "ptrNW", "rcN", "srcw", "destHTML", "srcN", "rcWidth", "srcR", "usrHTML", "sourceP", "sortWT", " srcN", "sortw", "usrH", "srcV"], "xInc": ["xIncre", "xIns", "xINC", "xEnc", "yxEnc", "XINC", " xEnc", "xIr", "xtEnc", "xtIncre", "xxIncre", "xxIns", " xIns", "yxInc", " xIr", "xtInc", " xINC", "XInc", "xtIr", "yxIr", "xxInc", "yxIncre", "xxINC", "XIncre", "XIns", " xIncre"], "hChrFilter": ["hCorrfilter", "hChrbfilter", "hChlTransform", "hChlControl", "hChrbTransform", "hStrApply", "hChrPlugin", "hChrbFilter", "hChRTransform", "hChdrFocus", "hHRTransform", "hChcFilter", "hStdControl", "hChlerTransform", "hChrControl", "hChlrFilter", "hHRQuery", "hHrPlugin", "hChdrFilter", "hChdrfilter", "hChrTransform", "hChRFilter", "hChdControl", "hCorrTransform", "hChrQuery", "hHrFilter", "hChrApply", "hStrControl", "hStdTransform", "hChdrTransform", "hChrfilter", "hChlFilter", "hChlrfilter", "hCordrFocus", "hHRPlugin", "hCordrfilter", "hChlQuery", "hChRQuery", "hChcApply", "hStdApply", "hChdFilter", "hChrbFocus", "hCordrTransform", "hChcControl", "hHrQuery", "hStrFilter", "hChlrFocus", "hStdFilter", "hChlPlugin", "hCorrFocus", "hChdApply", "hChlrTransform", "hChrFocus", "hChRPlugin", "hChcTransform", "hHRFilter", "hChlApply", "hChlerPlugin", "hStrTransform", "hChdTransform", "hChlerQuery", "hCorrFilter", "hHrTransform", "hCordrFilter", "hChlerFilter"], "hChrFilterPos": ["hCherrFormatCos", "hChrtFilterPos", "hChrtFilterLoc", "hChrFilterOpen", "hChrHeaderDir", "hChrbFilterPos", "hChrListenerCos", "hChrFormatOpen", "hChrtFilterOrigin", "hChrTransformDir", "hChrListenerOpen", "hChrFilterOffset", "hChrHeaderLoc", "hChrFormatPos", "hChrbFilterDir", "hChrRuleLoc", "hChrFieldOpen", "hChrtRuleOrigin", "hChrTestOrigin", "hChrTransformSize", "hChrFieldCos", "hChrFieldOffset", "hChrHandlerSize", "hChrHandlerLoc", "hChrtFilterVal", "hChrFieldPos", "hCherrFilterOpen", "hChrbHeaderLoc", "hChrHeaderPos", "hChrFilterDir", "hChrTestPos", "hChrRuleVal", "hChrtRuleLoc", "hChrbFilterSize", "hChrFilterOrigin", "hChrRefOrigin", "hChrListenerPos", "hChrbHeaderSize", "hChrbFilterLoc", "hChrFilterLoc", "hChrRulePos", "hChrbHeaderDir", "hChrbHeaderPos", "hChrHandlerPos", "hChrRuleOrigin", "hChrtRulePos", "hChrtRuleVal", "hChrRefVal", "hChrTransformLoc", "hChrFormatOffset", "hChrHandlerDir", "hCherrFilterOffset", "hChrRefPos", "hCherrFormatOpen", "hCherrFormatOffset", "hChrFormatCos", "hCherrFilterCos", "hCherrFilterPos", "hChrTestLoc", "hChrListenerOffset", "hCherrFormatPos", "hChrRefLoc", "hChrHeaderSize", "hChrTestVal", "hChrFilterVal", "hChrFilterCos", "hChrTransformPos"], "hChrFilterSize": ["hChvrFilterSize", "hChlTransformSize", "hChrOverrideSIZE", "hChrOverrideSize", "hChvrPixelWidth", "hChrTransformSIZE", "hChrTransformZone", "hChrerFilterZone", "hChlTransformCount", "hChlTransformScale", "hChrWindowWidth", "hChrFormatZone", "hChrerFilterSIZE", "hChrFormatSIZE", "hChrTransformSize", "hChvrFilterCode", "hChrFormatSize", "hChrerFormatLength", "hChrBlockScale", "hChlFilterCount", "hChvrPixelCode", "hChrerFormatSIZE", "hChrFilterLength", "hChrPixelSize", "hChrPixelCode", "hChrerFormatZone", "hChrPixelWidth", "hChrTransformScale", "hChrerFilterSize", "hChrTransformCount", "hChrFilterSIZE", "hChrOverrideCount", "hChvrPixelSIZE", "hChlFilterSIZE", "hChrWindowSIZE", "hChrTransformLength", "hChrFormatLength", "hChlTransformSIZE", "hChvrPixelSize", "hChrFilterCode", "hChrBlockCount", "hChrFilterWidth", "hChrFilterScale", "hChrerFormatSize", "hChlFilterSize", "hChrWindowSize", "hChlFilterScale", "hChrFilterZone", "hChvrFilterWidth", "hChrerFilterLength", "hChvrFilterSIZE", "hChrOverrideScale", "hChrWindowCode", "hChrPixelSIZE", "hChrBlockSIZE", "hChrFilterCount", "hChrBlockSize"], "formatConvBuffer": ["formatconVMatrix", "formatConcvBuffer", "formatConvertTable", "formatConnviTrack", "formatConvtBuffer", "formatEnvTable", "formatConvtTable", "formatEnfBuffer", "formatConfTrack", "formatEnfbuffer", "formatConfText", "formatconnvBuffer", "formatConcTable", "formatConfBuff", "formatConvTable", "formatConnviFormat", "formatConvertBuff", "formatConvertBuffer", "formatConviTrack", "formatConcvBuff", "formatConvcBuff", "formatConconvBuff", "formatConviFormat", "formatConvTrack", "formatConvcBuffer", "formatConfBegin", "formatEnvText", "formatConovFormat", "formatconnvBegin", "formatConVTable", "formatconVBuffer", "formatEnfBuff", "formatConvBegin", "formatConovBuff", "formatConconvBuffer", "formatConnvBuff", "formatConfCache", "formatConviBuff", "formatConvtBuff", "formatConjBuffer", "formatEncBuffer", "formatConVMatrix", "formatEnVBuffer", "formatConvText", "formatEnfCache", "formatConviBuffer", "formatConjBuff", "formatConfFormat", "formatConVBuffer", "formatConvbuffer", "formatConjbuffer", "formatConcText", "formatEnvCache", "formatConcBuff", "formatconvBuffer", "formatConovTrack", "formatconvBuff", "formatConvertCache", "formatEncText", "formatEnvBuff", "formatConconvText", "formatEncBuff", "formatEnVBuff", "formatConfBuffer", "formatConvertbuffer", "formatConnviBuff", "formatconvMatrix", "formatConcBuffer", "formatConnvTrack", "formatEnfTable", "formatConvBuff", "formatConcvMatrix", "formatConVBuff", "formatConvCache", "formatEnvBuffer", "formatConfbuffer", "formatEnVTable", "formatConovBuffer", "formatConnvBuffer", "formatConcCache", "formatconVBuff", "formatConnvBegin", "formatConnvFormat", "formatConfMatrix", "formatConnviBuffer", "formatEnvbuffer", "formatConfTable", "formatConvMatrix", "formatconvBegin", "formatConvcBegin", "formatConvFormat", "formatconnvBuff"], "pal": ["skin", "pres", "cat", "sav", "mal", "alph", "qq", "style", "phil", "cil", "cal", " Pal", "attr", "pol", "menu", "ass", "theme", "Pal", "pac", "pen", "flat", "qual", "local", "bat", "font", "el", "color", "pl", "alias", " PAL", "bal", "isal", "sal", "what", "scale", "pill", "val", "mat", " palette", "pid", "al"], "src1": ["srcName", "inst2", " srcOne", "coll01", "rc2", "src01", "coll0", "rc01", " src01", "inst1", "rcName", "src001", "rcOne", "inst11", "coll001", "source1", "rc0", "rc3", "srcOne", "sourceOne", "source2", "rc001", "rc1", " src001", " src3", "coll1", "source0", "src11", "src0", "rcN", " srcName", " src0", "sourceName", "rc11", "srcN", "src3", " srcN", "sourceN", " src11", "source3"], "src2": ["sourceB", "usr02", "rc02", "inst2", "src5", "sourceTwo", " src4", "inst1", "inst02", "src02", "rc12", "rc4", "st02", "st2", "ser2", "usrTwo", "instTwo", "source1", "rc0", "ser02", " src12", "sys2", "ser12", "serTwo", "source2", "srcTwo", "ser4", "rc1", "rcTwo", "usr2", "usr1", "source0", "stTwo", "rc5", "srcB", "source5", "ser1", " src5", "serB", "sys12", "src4", "src0", "source02", " src0", "sys1", "sys0", "src12", "rc2", "stB"], "buf2": ["buf3", "bur256", "uf1", "uf256", "famdb", " buf14", "buff2", "uf2", "fam1", "uf8", "buf8", "buf1", "vec1", "vec12", "buf256", "msg2", "bur2", "bufto", " buf4", "bagto", "buf12", "msg3", "buff256", "cb3", "buff4", "bur1", "uf02", " buf6", "fam2", "buf02", "buff12", "fam14", "fam6", "buf14", "buff8", "buff1", "fam3", "cb2", "buf6", " bufto", "bag2", "vec2", "bufdb", " buf1", "ufdb", " buf3", "cb02", "buff3", " bufdb", "famto", "uf12", "uf4", "vec8", "uf3", "buf4", "bag6", "bag14", "msg02"]}}
{"project": "qemu", "commit_id": "d470ad42acfc73c45d3e8ed5311a491160b4c100", "target": 1, "func": "static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,\n        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)\n{\n    BlockDriverState *bs = child->bs;\n    /* Perform I/O through a temporary buffer so that users who scribble over\n     * their read buffer while the operation is in progress do not end up\n     * modifying the image file.  This is critical for zero-copy guest I/O\n     * where anything might happen inside guest memory.\n     */\n    void *bounce_buffer;\n    BlockDriver *drv = bs->drv;\n    struct iovec iov;\n    QEMUIOVector local_qiov;\n    int64_t cluster_offset;\n    int64_t cluster_bytes;\n    size_t skip_bytes;\n    int ret;\n    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n                                    BDRV_REQUEST_MAX_BYTES);\n    unsigned int progress = 0;\n    /* FIXME We cannot require callers to have write permissions when all they\n     * are doing is a read request. If we did things right, write permissions\n     * would be obtained anyway, but internally by the copy-on-read code. As\n     * long as it is implemented here rather than in a separate filter driver,\n     * the copy-on-read code doesn't have its own BdrvChild, however, for which\n     * it could request permissions. Therefore we have to bypass the permission\n     * system for the moment. */\n    // assert(child->perm & (BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE));\n    /* Cover entire cluster so no additional backing file I/O is required when\n     * allocating cluster in the image file.  Note that this value may exceed\n     * BDRV_REQUEST_MAX_BYTES (even when the original read did not), which\n     * is one reason we loop rather than doing it all at once.\n     */\n    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);\n    skip_bytes = offset - cluster_offset;\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n                                   cluster_offset, cluster_bytes);\n    bounce_buffer = qemu_try_blockalign(bs,\n                                        MIN(MIN(max_transfer, cluster_bytes),\n                                            MAX_BOUNCE_BUFFER));\n    if (bounce_buffer == NULL) {\n        ret = -ENOMEM;\n        goto err;\n    while (cluster_bytes) {\n        int64_t pnum;\n        ret = bdrv_is_allocated(bs, cluster_offset,\n                                MIN(cluster_bytes, max_transfer), &pnum);\n        if (ret < 0) {\n            /* Safe to treat errors in querying allocation as if\n             * unallocated; we'll probably fail again soon on the\n             * read, but at least that will set a decent errno.\n             */\n            pnum = MIN(cluster_bytes, max_transfer);\n        assert(skip_bytes < pnum);\n        if (ret <= 0) {\n            /* Must copy-on-read; use the bounce buffer */\n            iov.iov_base = bounce_buffer;\n            iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER);\n            qemu_iovec_init_external(&local_qiov, &iov, 1);\n            ret = bdrv_driver_preadv(bs, cluster_offset, pnum,\n                                     &local_qiov, 0);\n            if (ret < 0) {\n                goto err;\n            bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n            if (drv->bdrv_co_pwrite_zeroes &&\n                buffer_is_zero(bounce_buffer, pnum)) {\n                /* FIXME: Should we (perhaps conditionally) be setting\n                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n                 * that still correctly reads as zero? */\n                ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0);\n            } else {\n                /* This does not change the data on the disk, it is not\n                 * necessary to flush even in cache=writethrough mode.\n                 */\n                ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,\n                                          &local_qiov, 0);\n            if (ret < 0) {\n                /* It might be okay to ignore write errors for guest\n                 * requests.  If this is a deliberate copy-on-read\n                 * then we don't want to ignore the error.  Simply\n                 * report it in all cases.\n                 */\n                goto err;\n            qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes,\n                                pnum - skip_bytes);\n        } else {\n            /* Read directly into the destination */\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes);\n            ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size,\n                                     &local_qiov, 0);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                goto err;\n        cluster_offset += pnum;\n        cluster_bytes -= pnum;\n        progress += pnum - skip_bytes;\n        skip_bytes = 0;\n    ret = 0;\nerr:\n    qemu_vfree(bounce_buffer);\n    return ret;", "idx": 3398, "substitutes": {"child": ["batch", "j", "parent", "q", "id", "add", "c", "count", "handle", "ach", "sim", "create", "node", "server", "link", "task", "bit", "b", "unk", "entry", "cache", "job", "shell", "cell", "ch", "block", "cs", "children", "v", "cc", "client", "Child", "h", "cl", "root", "sb", "ac", "base"], "offset": ["fp", "batch", "parent", "oid", "id", "key", "et", "shift", "encrypted", "addr", "count", "handle", "slot", "slice", "seek", "ref", "index", "node", "order", "pointer", "set", "pos", "start", "off", "extra", "location", "block", "error", "buffer", "ptr", "owner", "attribute", " offsets", "alias", "origin", "Offset", "offs", "range", "address", "client", "padding", "bits", "position", "reset", "os", "timeout", "prefix", "base", "length", "byte"], "bytes": ["steps", "values", "rows", "outs", "sets", "seconds", "es", "settings", "files", "times", "forms", "ips", "maps", "memory", "loads", "tes", "pages", "resses", "units", "reads", "ays", "pieces", "its", "parts", "uses", "Bytes", "errors", "ees", "keys", "les", " offsets", "ies", "array", "bps", "classes", "eps", "ows", "blocks", "abytes", "bits", "raw", "os", "elt", "latest", "ops", "sofar", "byte"], "qiov": ["qqvr", "quiour", "qqiev", "qvr", "quiov", " qvr", "qqiov", "quiev", "quvr", "qiour", "qqiour", " qiev", "qiev", " qiour"], "bs": ["sys", "ls", "outs", "bc", "bh", "bm", "boxes", "vs", "pb", "uts", "bp", "bles", "s", "cb", "ds", "qs", "b", "fs", "ubs", "lbs", "BS", "lb", "obs", "ps", "its", "bb", "js", "bos", "ns", "bt", "aos", "bi", "bis", "fps", "cs", "ts", "bus", "ba", "bes", "bps", "bo", "sts", "hz", "rs", "bl", "bits", "blog", "gs", "sb", "bn", "os", "bf", "bsp", "nb", "socket", "base", "ib", "ubis"], "bounce_buffer": ["bounced_buff", "bouncematcommand", "bounce_command", "bounce_volume", "bounce2buffer", "bounced_queue", "bounce2buff", "bouncematbuff", "bounce_base", "bounced_base", "bounced_buffer", "bounce_offset", "bouncematbuffer", "bounce_Buffer", "bounce_queue", "bounced_Buffer", "bounce___buff", "bounced_volume", "bounce___Buffer", "bounced_offset", "bounce2queue", "bounced_command", "bounce2Buffer", "bounce___offset", "bounce_buff", "bouncematvolume", "bounce___buffer"], "drv": ["crV", "drf", "crc", "drc", " drc", " drvr", "srvr", "srv", "rv", "srV", " drf", "rvs", " drvs", "crv", "rf", "drvs", "drvr", "srf", "src", "srvs", " drV", "rvr", "crvs", "drV"], "iov": ["liv", "iao", "aux", "inv", "iq", "vo", "nr", "vr", "jp", "kov", "conv", "drm", "ever", "nil", "rov", " commun", "iph", "lov", "rolet", "phy", " mor", "iva", " rav", "ious", "hero", "ih", "vp", "cmp", "voc", "ij", "dq", "uart", "iv", " mus", "voice", "vec", "tv", " fav", "ilo", "minecraft", "iw", " civ", "ovi", "imp", "ir", "communication", "iour", "isco", "pkg", "iop", "io", "river", "ibr", "rio", "nov", "nir", "av", "iol", "ivic", " voic", "serv", "vector", "veh"], "local_qiov": ["local_dqiop", "local_qsiev", "local_dqiov", "local_dqiev", "local_Qiop", "local_ueiever", "local_dqiever", "local_qsiov", "local_ueiop", "local_qqiov", "local_qqiv", "local_quiv", "local_dqimir", "local_quiev", "local_quantiov", "local_Qiv", "local_qiv", "local_qqiour", "local_qiever", "local_quimir", "local_qsiever", "local_ueiov", "local_qimir", "local_Qiour", "local_quantiev", "local_quantiop", "local_quiop", "local_Qiov", "local_ueiev", "local_quiov", "local_qiour", "local_quiour", "local_quantimir", "local_qqiop", "local_qiop", "local_qiev", "local_qsiop"], "cluster_offset": ["cluster___offset", "cluster___store", "clignmentipoffset", "clusteripoffset", "clbuster_id", "cluster0offset", "clusterIPoffset", "cluster___address", "clusters_addr", "cluster8offset", "clbuster_ref", "clust_offset", "clignment_offset", "clusterIPdelay", "cluster2offset", "clbuster0ref", "clbuster_area", "cluster___size", "cluster_size", "cluster__index", "cluster_ref", "clusters_Offset", "cluster2ref", "clusters_address", "clignment_address", "clignmentipbytes", "cluster_Offset", "clusters_bytes", "cluster_addr", "clusteripentry", "cluster8ref", "clusterIPbytes", "cluster0ref", "clusters_offset", "cluster8area", "clbuster_offset", "clignmentipentry", "clusters_size", "cluster_store", "clusterIPOffset", "clbuster0area", "clusters_delay", "cluster0id", "cluster2area", "clust_index", "cluster__Offset", "cluster_entry", "cluster_delay", "clust_Offset", "clust_bytes", "cluster__bytes", "cluster0area", "cluster_index", "clusteripbytes", "clusters_store", "cluster8id", "cluster_area", "cluster2id", "clusteripaddress", "clbuster0id", "cluster__offset", "cluster_id", "clbuster0offset", "cluster_address", "clignmentipaddress", "clignment_entry", "clignment_bytes"], "cluster_bytes": ["clube_steps", "cluster7bytes", "clusterlenbytes", "clber_fixes", "cluster_steps", "clust_bits", "clust_total", "clube_bytes", "cluster_es", "cluster_Bytes", "cluster_seconds", "cluster3bytes", "clancer_options", "clutter_pages", "clusters_Bytes", "cluster0es", "cluster3errors", "clubeablesteps", "cluster___fixes", "cluster_size", "clancer7bytes", "cluster_bits", "cluster_versions", "clust_size", "cluster_total", "clusters_bytes", "clutter_size", "clubeablebits", "cluster0bytes", "clber_versions", "clust_errors", "cluster___errors", "clancer_es", "clusters_errors", "cluster___bytes", "clancer7options", "clancer7es", "clusterlentotal", "cluster7options", "clusters_size", "cluster_errors", "clusterablebits", "clusterlenbits", "clber_bytes", "clubeablebytes", "clust_bytes", "cluster0seconds", "clube_bits", "clubeableoptions", "clusterlensize", "clust_names", "cluster7seconds", "clancer_bytes", "cluster3names", "cluster3size", "clutter_bytes", "clusterablesteps", "cluster7es", "clancer7seconds", "cluster_byte", "cluster_pages", "cluster_fixes", "cluster___versions", "clube_options", "clancer_seconds", "clusterablebytes", "clusterableoptions", "cluster0options", "cluster_options", "cluster_names", "clutter_byte", "clber_errors"], "skip_bytes": ["skip_bits", "skipallbytes", "jump_bits", " skip_seconds", " skip_times", "skipalllength", "skip_tes", "skip_times", " skip_reads", "jump_bytes", "jump_tes", "jump___bits", "skipallreads", " skip_errors", "skip___bytes", " skip_length", "jump___size", "skip___size", " skip_bits", "jump___bytes", "skip___bits", "skip_seconds", "skip_errors", "jump___tes", "skip_size", "skipallerrors", "skip___tes", "skip_reads", "skip_length", "skip___errors", "skip___reads", "jump_size", "skip___length"], "ret": ["success", "jump", "RET", "run", "status", "jp", "dt", "arr", "far", "Return", "ext", " RET", "fun", "result", "ref", "after", "deg", "rect", "out", "res", "vals", "fin", "ft", "num", "gt", "ll", "def", "mem", "att", "reply", "Ret", "ert", "prot", "tf", " Ret", "reg", "final", "job", "desc", "err", "vet", "ts", "rev", "alt", "rt", "re", "ter", "print", "get", "val", "rm", "rets", "del", "nt", "tech", "arg", "rem", "tr", "reset", "resp", "cert", "elt", "t", "flag", "back", "len", "cmd"], "pnum": ["wnUM", "pnim", "pnumm", "wanim", "penuma", "PNenum", "pronumm", "sonuma", "wnumer", "pronum", "gnuma", "wanum", "pngUM", "pnenum", "panumed", "pnumer", "sonumer", "gnim", "pnnum", "PNatum", "pnuma", "pronumed", "penum", "pngum", "pinumb", "pnums", "sonnum", "pinumed", "PNman", "wnum", "pennum", "nnumer", "panim", "pronumb", "wannum", "kinman", "kinenum", "pronenum", "pinumm", "nnum", "gnUM", "pnumed", "PNumer", "gnum", "PNum", "pronumer", "gnnum", "pnUM", "gnumer", "sonum", "nnumm", "gnatum", "gnums", "kinumer", "panum", "wnnum", "pnumb", "pinum", "PNums", "PNUM", "panumer", "pannum", "pngatum", "nnumb", "penUM", "panumm", "pinumer", "pronman", "pnman", "penumer", "panumb", "wanUM", "pnatum", "kinum", "panUM", "pngums"]}}
{"project": "qemu", "commit_id": "2cbe2de5454cf9af44b620b2b40d56361a12a45f", "target": 1, "func": "static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)\n{\n    virtio_scsi_common_unrealize(dev, errp);\n}", "idx": 3399, "substitutes": {"dev": ["doc", "data", "d", "env", "device", "adv", "dd", "dep", "ev", "dem", "ds", "Dev", "md", "def", "priv", "pad", "iv", "desc", "w", "cast", "wd", "ver", "spec", "home", "de", "die", "DEV", "v", "nt", "di", "sky", "ad", "av", "os", "des", "mem", "serv", "dis", "cmd"], "errp": ["errpc", "rrpb", "lerps", "rrpc", "lrpb", "rrp", "lrp", "errorp", "errorpa", "lerp", "errpa", "lerpt", "ersp", "errorpb", "rrpt", "erp", "lrpc", "rrsp", "errsp", "erpt", "errps", "erps", "rrps", "errpt", "lersp", "errpb", "rrpa", "lrpa", "errorpc"]}}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    char buf[1024];\n\n    VncShareMode mode;\n\n    int size;\n\n\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n\n    switch (vs->vd->share_policy) {\n\n    case VNC_SHARE_POLICY_IGNORE:\n\n        /*\n\n         * Ignore the shared flag.  Nothing to do here.\n\n         *\n\n         * Doesn't conform to the rfb spec but is traditional qemu\n\n         * behavior, thus left here as option for compatibility\n\n         * reasons.\n\n         */\n\n        break;\n\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n\n        /*\n\n         * Policy: Allow clients ask for exclusive access.\n\n         *\n\n         * Implementation: When a client asks for exclusive access,\n\n         * disconnect all others. Shared connects are allowed as long\n\n         * as no exclusive connection exists.\n\n         *\n\n         * This is how the rfb spec suggests to handle the shared flag.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            VncState *client;\n\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n\n                if (vs == client) {\n\n                    continue;\n\n                }\n\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n\n                    continue;\n\n                }\n\n                vnc_disconnect_start(client);\n\n            }\n\n        }\n\n        if (mode == VNC_SHARE_MODE_SHARED) {\n\n            if (vs->vd->num_exclusive > 0) {\n\n                vnc_disconnect_start(vs);\n\n                return 0;\n\n            }\n\n        }\n\n        break;\n\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n\n        /*\n\n         * Policy: Shared connects only.\n\n         * Implementation: Disallow clients asking for exclusive access.\n\n         *\n\n         * Useful for shared desktop sessions where you don't want\n\n         * someone forgetting to say -shared when running the vnc\n\n         * client disconnect everybody else.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            vnc_disconnect_start(vs);\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n    vnc_set_share_mode(vs, mode);\n\n\n\n    vs->client_width = surface_width(vs->vd->ds);\n\n    vs->client_height = surface_height(vs->vd->ds);\n\n    vnc_write_u16(vs, vs->client_width);\n\n    vnc_write_u16(vs, vs->client_height);\n\n\n\n    pixel_format_message(vs);\n\n\n\n    if (qemu_name)\n\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n\n    else\n\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_flush(vs);\n\n\n\n    vnc_client_cache_auth(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 3401, "substitutes": {"vs": ["nets", "vc", "ls", "values", "wcs", "sys", "stats", "ils", "pps", "inv", "vis", "vr", "is", "sv", "ss", "lists", "es", "caps", "xs", "s", "vt", "verts", "ds", "qs", "blogs", "vals", "ants", "params", "fs", "gets", "lbs", "vp", "obs", "views", "vi", "ps", "its", "js", "ns", "bs", "docs", "otes", "vm", "ims", "VS", "cv", "fps", "ads", "ms", "ports", "cs", "ts", "ver", "ks", "changes", "hs", "lines", "sts", "eps", "v", "rs", "vers", "tests", "uds", "versions", "styles", "gs", "ins", "os", "Vs", "vd", "ops"], "data": ["d", "Data", "batch", "values", "message", "image", "key", "value", "DATA", "next", "p", "text", "to", "n", "window", "r", "dat", "m", "b", "msg", "pos", "valid", "extra", "zero", "cache", "mu", "block", "accept", "buffer", "name", "bin", "empty", "ata", "bytes", "hash", "channel", "bits", "done", "rc", "clear", "area", "map"], "len": [" length", "ec", "l", "code", " bl", "Len", "type", "length", "cap", "en", "str", "bin", "bytes", " count", "h", "bl", "rc", "byte"], "buf": ["doc", "proc", "br", " b", "tmp", "bh", "next", "text", "p", "img", "row", "window", " buffer", "caps", "box", "iter", "txt", "out", " cmd", "cb", "rb", "var", "pg", "b", "tx", "msg", "orig", "vp", "cur", "err", "pad", "vec", "bs", "bt", " buff", "cap", "buffer", "cv", "w", "ptr", "cast", "bag", "name", "ctx", "fr", "str", "pkg", "wb", "Buffer", "nm", "db", "fd", "queue", "v", "fb", "cam", "bytes", "uffy", "sb", "raw", "Buff", "mem", "obj", "uf", "cmd", "buff"], "mode": ["mt", "id", "match", "format", "only", "menu", "raid", "zero", "mit", "time", "Mode", "version", "method", "spec", "nom", "de", "stay", "license", "te", "dim", "mem", "ME", "key", "acl", "test", "MODE", "settings", "tif", "m", "policy", "none", "ui", "mod", "cmp", "perm", "option", "member", "ode", "mm", "range", "max", "mate", "style", "DE", "me", "power", "progress", "type", "scale", "oe", "cmd", "multi", "status", "no", "ase", "kind", "mid", "pose", "md", "def", "tm", "ie", "command", "role", "now", "direction", "state", "feat", "stage", "module", "pro"], "size": ["message", "sex", "shift", "no", "format", "count", "height", " sizes", "g", "window", "index", "set", "send", "small", "sum", "space", " Size", "export", "ui", "start", "notice", "speed", "check", "shape", "type", "storage", "time", "length", "SIZE", "name", "global", "member", "offset", "ize", "scale", "loss", "empty", " count", "fee", "address", "equal", "max", "dim", "grow", "unit", "eng", "capacity", "Size", "sp"], "client": ["active", "q", "cod", "parent", "batch", "key", "public", "list", "tmp", "item", "net", "user", "c", "pc", "web", "port", "next", "component", "conn", "p", "to", "cp", "row", "service", "session", "window", "pb", "server", "node", "open", "out", "pty", "i", "cli", "start", "tab", "entry", "cur", "cache", "pat", "connection", "ip", "cell", "http", "local", "cap", "cv", "player", "name", "con", "co", "pool", "manager", "remote", "v", "null", "nt", "friend", "channel", "ct", "cl", "current", "peer", "Client", "obj", "master", "cmd"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,\n\n                                                 const uint8_t *src_y,\n\n                                                 int32_t src_stride,\n\n                                                 uint8_t *dst,\n\n                                                 int32_t dst_stride)\n\n{\n\n    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;\n\n    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;\n\n    v8i16 res0, res1;\n\n    v16u8 res;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);\n\n    src_y += (5 * src_stride);\n\n\n\n    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);\n\n    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);\n\n    src_vt2 = (v16i8) __msa_insve_w((v4i32) src_vt2, 1, (v4i32) src_vt3);\n\n    src_vt3 = (v16i8) __msa_insve_w((v4i32) src_vt3, 1, (v4i32) src_vt4);\n\n\n\n    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);\n\n    LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);\n\n    LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n    XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz0, src_hz1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out1 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src_hz2, src_hz3,\n\n                                                          mask0, mask1, mask2);\n\n    SRARI_H2_SH(hz_out0, hz_out1, 5);\n\n    SAT_SH2_SH(hz_out0, hz_out1, 7);\n\n    LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);\n\n\n\n    src_vt4 = (v16i8) __msa_insve_w((v4i32) src_vt4, 1, (v4i32) src_vt5);\n\n    src_vt5 = (v16i8) __msa_insve_w((v4i32) src_vt5, 1, (v4i32) src_vt6);\n\n    src_vt6 = (v16i8) __msa_insve_w((v4i32) src_vt6, 1, (v4i32) src_vt7);\n\n    src_vt7 = (v16i8) __msa_insve_w((v4i32) src_vt7, 1, (v4i32) src_vt8);\n\n\n\n    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);\n\n\n\n    /* filter calc */\n\n    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,\n\n                                                  src_vt3, src_vt4, src_vt5);\n\n    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,\n\n                                                  src_vt5, src_vt6, src_vt7);\n\n    SRARI_H2_SH(vert_out0, vert_out1, 5);\n\n    SAT_SH2_SH(vert_out0, vert_out1, 7);\n\n\n\n    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);\n\n    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);\n\n\n\n    SAT_SH2_SH(res0, res1, 7);\n\n    res = PCKEV_XORI128_UB(res0, res1);\n\n\n\n    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);\n\n    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);\n\n    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);\n\n    dst0 = __msa_aver_u_b(res, dst0);\n\n\n\n    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);\n\n}\n", "idx": 3416, "substitutes": {"src_x": ["src__y", "rc_w", "rc_y", "rc_x", "src__xy", "src__w", "rc_xy", "src_w", "src_xy", "src__x"], "src_y": ["src__y", "rc_y", "rc_x", "src_Y", "src_ey", "src__ies", "rc_ies", "rc_yy", "rc_ey", "src__ey", "rc_xy", "src_yy", "source_x", "src_ies", "source_yy", "src_xy", "source_Y", "src__x", "source_y"], "src_stride": ["src_glice", "src_slage", "src2strine", "src_drange", "src_slide", "src_drage", "src_depthide", "src_depthride", "src_slate", "src_grid", "src_Strride", "src_grage", "src_gline", "src2strange", "src_STRride", "src_strage", "src_dride", "src_gride", "src_glage", "src2gline", "src2glide", "src_strice", "src_strid", "src_strride", "src_strine", "src_drride", "src2strride", "src2glange", "src_drine", "src_strange", "src2stride", "src_STRide", "src_grate", "src_strate", "src_glide", "src_glride", "src_slid", "src_drid", "src_Strine", "src_STRice", "src_STRage", "src_glange", "src_drate", "src_Stride", "src_depthice", "src_Strange", "src2glride", "src_depthage"], "dst": ["sdset", "sdST", "sdsp", "dST", "edset", " dsp", " dset", "edST", "dset", "edst", "sdst", "dsp", " dST", "edsp"], "dst_stride": ["dst_tride", "dst_trid", "dst_trride", "dst_strride", "dst_grride", "dst_gride", "dst_strid", "dst_grize", "dst_trize", "dst_strize", "dst_grid", "dst_glid", "dst_glide", "dst_glize", "dst_glride"], "src_hz0": ["src_cz2", "src_cz0", "src_zz1", "src_cz3", "src_mx2", "src_cz1", "src_mx1", "src_mx0", "src_mx3", "src_zz2", "src_zz3", "src_zz0"], "src_hz1": ["src_ts12", "src_elt5", "src_ts1", "src_ts5", "src_tz0", "src_hz5", "src_elt1", "src_elt0", "src_tz1", "src_elt12", "src_tz5", "src_ts0", "src_hz12", "src_tz12"], "src_hz2": ["src_hs1", "src_kh6", "src_hs6", "src_hz7", "src_kh1", "src_kh2", "src_mx6", "src_mx2", "src_mx1", "src_mx7", "src_hs2", "src_hs7", "src_hz6", "src_kh7"], "src_hz3": ["src_css3", "src_css1", "src_css2", "src_hz03", "src_css03", "src_zz03", "src_zz1", "src_tz2", "src_tz03", "src_tz3", "src_tz1", "src_zz2", "src_zz3"], "dst0": ["dist1", "dost1", "sdest1", "sdest3", "dist0", "dest5", "sdst5", "dest3", "dost0", "dst5", "dost5", "sdest5", "dist3", "dest0", "dist5", "sdest0", "sdst1", "sdst3", "dost3", "sdst0", "dest1"], "dst1": ["dest2", "dost1", "dest4", "dost4", "dsp2", "dsp1", "Dst2", "Dest4", "dst4", "Dest2", "Dst4", "dest1", "Dst1", "dost2", "Dest1", "dsp4"], "dst2": ["dest2", "drest3", " dsc3", "dest3", "dsc7", "drest7", "drest2", "dst7", " dsc2", "dest7", " dsc7", " dst7", "dsc2", "dsc3"], "dst3": ["dST9", " dst9", "dST3", " dST7", "drest3", " dST9", "dest3", "dst9", "drest7", "dst7", "dest7", "dest9", " dst7", "dST1", "dST7", "drest9", "drest1", " dST1", " dST3", "dest1"], "src_vt0": ["srcJvt48", "src_tt0", "src_t3", "src_vtarg", "srcJmt48", "src_vet1", "src_vp0", "src_vp2", "src_ct1", "src_pt5", "srcJmtarg", "src_mt48", "src_vy5", "src_vt48", "src_vert3", "src_tt3", "src_tt5", "src_vet0", "src_ct0", "src_t0", "src_vcarg", "src_vert8", "src_vc48", "src_VT0", "src_tt8", "src_yt0", "src_ct2", "src_mtarg", "src_vy8", "src_vet2", "src_VT3", "srcJvtarg", "src_ytarg", "src_vet3", "src_yt2", "src_VT8", "srcJvt2", "src_vc0", "src_t1", "src_vert2", "src_vert5", "src_ct3", "src_t2", "src_vy3", "src_vy0", "srcJmt2", "src_vert1", "src_pt0", "srcJvt0", "src_vert0", "src_vp8", "srcJmt0", "src_mt2", "src_vp3", "src_pt1", "src_yt48", "src_VT2", "src_mt0", "src_vet5", "src_vc2"], "src_vt1": ["src_vet7", "src_vt11", "src_ht3", "src_vp9", "src_vert4", "src_vet1", "src_vt9", "src_yt9", "src_ct1", "src___v1", "src_vert7", "src_wt001", "src_bt1", "src_ht0", "src_vert3", "src_wtA", "src_qt7", "src_ht1", "src___vt11", "src_ct0", "src_ty4", "src_ct6", "src_qt9", "src_vp4", "src_vc1", "src_bt7", "src_ty9", "src_ty01", "src_vc01", "src_yt0", "src___v11", "src_vertOne", "src_vert01", "src_btOne", "src_vt001", "src_bt9", "src___vt01", "src_ty3", "src_vtOne", "src_vp7", "src___vt1", "src_ty1", "src_vc001", "src_yt3", "src_wt1", "src_qt1", "src_vert9", "src_vert11", "src_tyA", "src_vt01", "src_vp01", "src___v01", "src_yt6", "src_ct3", "src_vert1", "src_ty001", "src_vtA", "src_yt4", "src_v01", "src_ht6", "src_v1", "src_qtOne", "src_vet9", "src_yt1", "src_vcA", "src_vet4", "src_v11", "src_vp1", "src_vp11", "src_wt01"], "src_vt2": ["src_vetTwo", "src_vet7", "src___vtTwo", "src_ht3", "src___tvTwo", "src_vet1", "src_vp0", "src_vp2", "src_tv2", "src__vt2", "src_ht0", "src__vt3", "src___tv2", "src__vt7", "src_ht2", "src_ty2", "src_vet14", "src_ht7", "src_vc14", "src_tv3", "src_ht1", "src_vet0", "src_tyTwo", "src___ip", "src_ty4", "src_vp4", "src_vc1", "src___tv0", "src__vp3", "src_sys3", "sort_8", "src_vtTwo", "sort_1", "src_vet2", "src_tvTwo", "src_ty3", "src___tv3", "src_vp7", "src_ty5", "src_vet3", "src_ip", "src_ty1", "src_ty0", "src_tv0", "src___vt3", "src___1", "src__vp7", "src_ht4", "src_vc0", "src_vert2", "src_sys2", "src_vert14", "src_vert1", "src_vert0", "src_vp5", "src__vp2", "src_vp3", "sort_ip", "src_1", "src___vt2", "src___vt0", "src___8", "src_sys5", "src_vp1", "src_vc2", "src_vt14", "src_8"], "src_vt3": ["src_vt11", "src2vt5", "src_vs7", "src_cmd3", "src_vet1", "src_vt9", "src_vp2", "src_pt5", "src2vt2", "src_vs11", "src_vert7", "src_virt7", "src_tvard", "src_vert3", "src_kt0", "src_vpry", "src_tv3", "src_ts2", "src_vet0", "src_vet03", "src_ts3", "src_qt9", "src_ktard", "src_ts5", "src_vert8", "src_kt3", "src_vetard", "src_pt7", "src_ty7", "src_tv1", "src_cmd03", "src_ts7", "src_ty3", "src_vt03", "src_vp7", "src2vp2", "src_vet3", "src_kt1", "src_pt2", "src_vtry", "src_vtard", "src_qt1", "src2vt7", "src_vert11", "src_tv0", "src2vp3", "src_tyry", "src_cmd1", "src_vs8", "src_virtry", "src_vp5", "src_qt3", "src_vs3", "src_cmd9", "src_virt3", "src_vp3", "src_kt7", "src_vet9", "src_kt11", "src_kt8", "src2vt3", "src_qt03", "src_pt3", "src2vp7", "src2vp5"], "src_vt4": ["src_vtn", "src_ty5", "src_tt4", "src_vt32", "src_vet3", "src_ty4", "src_vet04", "src_vy32", "src_vc4", "src_ty1", "src_vc1", "src_vert4", "src_vet1", "src_VTn", "src_vt44", "src_ty04", "src_vert44", "src_vertn", "src_tt32", "src_vy5", "src_tvn", "src_vy4", "src_tv1", "src_vt04", "src_VT4", "src_VT1", "src_tt3", "src_tv4", "src_vet4", "src_vet32", "src_vc5", "src_tv44", "src_VT44", "src_tt5", "src_vy3", "src_vet5", "src_vc04", "src_vert1"], "src_vt5": ["src_vet8", "src_vp5", "src_vet1", "src_qt1", "src_vp2", "src_qt5", "src_qt8", "src_qt2", "src_vet2", "src_vp1", "src_vet5", "src_vp8"], "src_vt6": ["src_virt4", "src_vet3", "src_qt3", "src_vtect", "src_virt3", "src_qtect", "src_qt6", "src_qt4", "src_vet6", "src_virtect", "src_vet4", "src_virt6", "src_vetect"], "src_vt7": ["src_vet7", "src___tt7", "src_tt7", "src___vt9", "src___tt5", "src_ts5", "src_vt9", "src_tt9", "src_vet9", "src___vt5", "src_ts9", "src___tt9", "src_ts7", "src_tt5", "src_vet5", "src___vt7"], "src_vt8": ["src_vertint", "src_tv9", "src_tv8", "src_vc1", "src_tvint", "src_vert8", "src_vtint", "src_vt9", "src_vert9", "src_vc9", "src_vcint", "src_tv1", "src_vc8", "src_vert1"], "mask0": ["ask3", "ask0", "ask1", "Mask2", "mask3", "Mask1", "ask2", "Mask0", " mask3", "Mask3"], "mask1": ["miss1", "filter1", "filter4", "mask4", "map0", "ask3", "map4", "ask0", "ask1", "map1", "mask3", "ask4", " mask4", "ask2", "miss4", "filter3", " mask3", "map2", "filter2", "miss0", "miss2"], "mask2": ["miss1", "filter1", "filter4", "mask4", "ask3", "ask0", "filter0", "ask1", "mask3", "ask4", " mask4", "ask2", "miss4", "miss3", " mask3", "filter2", "miss2"], "hz_out0": ["hz_fix0", "hz_in3", "hz_fix3", "hz_out00", "hz_out3", "hz_mask1", "hz_mask00", "hz_fix1", "hz_fix00", "hz_in0", "hz_in00", "hz_mask3", "hz_in1", "hz_mask0"], "hz_out1": ["hz_Out5", "hz_Out0", "hz_Out1", "hz_sum5", "hz_sum0", "hz_in0", "hz_in5", "hz_in1", "hz_out5", "hz_sum1"], "vert_out0": ["vert_in5", "vert_mask2", "vert_in2", "vert_OUT2", "vert_out5", "vert_OUT0", "vert_OUT5", "vert_mask0", "vert_OUT1", "vert_mask1", "vert_out2", "vert_mask5", "vert_in1", "vert_in0"], "vert_out1": ["vert_in2", "vert_bit9", "vert_OUT2", "vert_bit2", "vert_out9", "vert_bit1", "vert_OUT1", "vert_in9", "vert_OUT9", "vert_out2", "vert_in1"], "res0": ["Res5", "res00", "Res00", "Res0", "req00", "resolution00", "req0", "req5", "resolution0", "resolution5", "res5"], "res1": ["Resone", "Res1", "Res0", "Res2", "maskone", " res2", " resone", "resone", "res2"], "res": ["pres", "sys", "wcs", "Res", "gr", "RES", "mask", "resolution", "resh", "out", "ps", "vec", "bs", "js", "ch", "ms", "reg", "rs", "ress", "val", "vol", "bits", "ret", "os", "resp", "des", "re"]}}
{"project": "qemu", "commit_id": "a27365265cc2fed1178bf25a205e8ee02a9c0caf", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n                         BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n\n                       cb, opaque, QEMU_AIO_READ);\n\n}\n", "idx": 3440, "substitutes": {"bs": ["ls", "cks", "bc", "bh", "ss", "bm", "es", "vs", "pb", "bp", "ds", "b", "ubs", "fs", "lbs", "BS", "obs", "boot", "ps", "its", "bb", "js", "ns", "aos", "bos", "bt", "bis", "ms", "ts", "cs", "ks", "bes", "hs", "hz", "sts", "rs", "bl", "bits", "blog", "bing", "gs", "sb", "bf", "bn", "os", "aus"], "sector_num": ["sectorseqnr", "ector_num", "sectorseqnum", " sector_number", "sector_number", "sector__number", "sectorseqindex", "sector_Num", "ector_Num", "sector__nr", "sector_nr", "ector_number", "sector__index", "sector__num", "sector_index", " sector_index", "sectorseqnumber", "sector_mon", "ector_mon", " sector_nr"], "qiov": ["queryiour", "queryovi", "queryiov", " qiour", " qrolet", "requiol", "qualiov", "qovi", "Qiop", "Qrolet", "qiour", "Qiov", "qrolet", "requovi", "qiol", "qiop", " qiol", "requiov", "queryiol", "Qiour", "qualiop", "requiour", "qualiour", " qovi", " qiop", "qualrolet"], "nb_sectors": ["nb_seors", "nb_veors", "nb_veriers", "nb_vevers", "nb_seriers", "nb_reors", "nb_spectors", "nb_vevisors", "nb_revisors", "nb_severs", "nb_rellers", "nb_spellers", "nb_spevisors", "nb_pseriers", "nb_sevisors", "nb_speors", "nb_psectors", "nb_pseors", "nb_vellers", "nb_rectors", "nb_psevers", "nb_sellers", "nb_vectors"], "cb": ["cp", "fc", "cd", "CB", "func", "eb", "c", "ub", "bc", "nc", "unc", "fun", "dc", "pb", "bp", "cfg", "rb", "b", "lb", "gb", "job", "bb", "fi", "cf", "cv", "callback", "abb", "rl", "ob", "wb", "db", "fb", "cc", "rc", "fn", "bf", "ck", "nb", "tc", "ctrl"], "opaque": ["oppity", "OPque", " opity", "opac", "popaque", "iopac", "operaque", "ompity", "operula", "posacity", " opula", " opque", "OPity", "popque", "iopque", "obity", "ompque", "OPaque", "oppula", "operque", "posity", "opacity", "ompaque", "popity", "opity", "OPac", "posaque", "opque", "opula", "iopaque", "operity", "ompac", "popacity", "oppque", "obacity", "posque", "obque", "oppaque", "iopity", "obaque"], "s": ["ls", "j", "S", "stats", "c", "sg", "sh", "is", "sv", "ss", "p", "g", "n", "sl", "ses", "sa", "ds", " ss", "fs", "ps", "js", "ns", "sd", "ts", "cs", "hs", "sts", "rs", "h", "gs", "sb", "ats", "st", "sq", "os", "se", "sp"]}}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_blit_writel(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n", "idx": 3449, "substitutes": {"opaque": ["OPatile", "popaque", "ipque", "pque", "popque", "oposter", "OPaque", "OPaques", "pacity", " opatile", "paque", "opacity", "iopaques", " opaques", "opque", "iopaque", "ipaque", "poster", "popacity", "iopatile", "poposter", "opaques", "iopacity", "iposter", "OPacity", "ipacity", " opacity", "opatile"], "addr": ["mt", "id", "handle", "Address", "hw", "iter", "var", "aff", "x", "off", "wd", "pkg", "ind", "ix", "hash", " ref", "rn", "mem", "row", "coord", "act", "msg", "at", "ack", "pat", "ptr", "gate", "alt", "loc", "offset", "arp", " address", "wid", "sha", "elt", "ace", "host", "nl", "rid", "seek", "index", "res", "ord", "pad", "hl", "ctx", "ag", "mac", "v", "urg", "address", "src", "rc", "prefix", "map", "inter", "cmd", "sp", "alloc", "work", "add", "eth", "arr", "attr", "r", " ip", "align", "tx", "pos", "ip", "alias", "adr", "now", "rt", "dr", "rs", "ha", "gz", "ad", "ac", " af", "obj", " mac"], "val": ["cho", "p", "cal", "var", "x", "pr", " eval", "buffer", "comp", "vol", "ret", "Value", "sol", "mem", "serv", "test", "key", "num", "valid", "rol", "it", "cmp", "ival", "pal", " v", "eval", "alt", "loc", "sel", "arg", "elt", "rel", "al", "values", "l", "buf", "slot", "ref", "index", "pol", "vt", "res", "el", "ctx", "bin", "pt", "v", "point", "data", " value", "func", "prop", "arr", "value", "il", "item", "Val", "attr", "util", "vals", "bit", "lit", "tx", "pos", "VAL", "vec", "pl", "aval", "reg", "bl", "base"], "size": ["d", "id", "l", "count", "z", "n", "align", "num", "type", "cmp", "cap", "SIZE", "e", "iz", "en", "name", "offset", "ize", "address", "h", "mem", "length", "Size", "sp"], "s": ["sis", "ls", "p", "es", "n", "ses", "params", "services", "series", "t", "conf", "cs", "spec", "h", "gs", "sb", "so", "serv", "stats", "sv", "service", "details", "ess", "ds", "qs", "m", "less", "ex", "bs", "ims", "bis", "sam", "hs", "sts", "ins", "states", "sq", "acs", "j", "S", "ss", "als", "sl", "comm", "ns", "sw", "ms", "ts", "changes", "rates", "se", "ssl", "sys", "status", "is", "stat", "sim", "r", "b", "fs", "aws", "ps", "parts", "js", "comments", "as", "sports", "sm", "rs", "bits", "ats", "store"], "adsr": ["advr", "ipsr", "modssr", "adsrg", "rsr", "lsm", "adesrt", "adrg", "adsrc", "lsr", "adsvr", "ainsrb", "adsl", "adler", "adsler", "agsR", "ainsr", "achesrc", "ipsrs", "rsm", "ader", "aysr", "modser", "ainsrc", "adsm", "lsvr", "aysl", "adssr", "adsrs", "adsrb", "ainsrt", "aysrc", "modsr", "adsrt", "achesr", "adrs", "rsR", "adesrar", "modsrg", "aysrar", "aysrt", "adr", "agsrs", "ipsR", "apsrg", "aysrb", "adesl", "achesrt", "adesr", "ipsler", "agsler", "apssr", "apsr", "adm", "adR", "adrt", "lsR", "agsr", "adsR", "adrar", "apser", "rsvr", "adl", "adsrar", "adser", "achesrb"], "len": ["ls", "ul", "lp", "le", "l", "list", "L", "nl", "limit", "n", "sl", "kl", "lim", "li", "Len", "lib", "lf", "fin", "lit", "num", "pos", "seq", "lan", "ll", "cmp", "Length", "vec", "lon", "length", "hl", "SIZE", "den", "el", "en", "ln", "ell", "loc", "offset", "nt", "vol", "lin", "bytes", "h", "ml", "ret", "f", "lis", "elt", "rel", "mem", "ld"], "i": ["multi", "j", "chain", "l", "ii", " m", "ori", "ji", " j", "p", "sim", "g", "n", "init", "xi", "ic", "pi", "qi", "iter", "ci", "li", " di", "m", "ei", "x", "u", "cli", "us", "ui", "gi", "phi", "it", " si", " ti", "ip", " ii", "oi", "y", "bi", "e", "iu", "ti", "uri", " li", "io", "ix", "v", "zi", "in", " ni", "client", "mi", "di", "ini", "\u0438", "o", "ai", "I", "si", "prefix", "t", " bi"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,\n\n                                                       uint8_t alpha_in,\n\n                                                       uint8_t beta_in,\n\n                                                       uint32_t img_width)\n\n{\n\n    uint16_t out0, out1, out2, out3;\n\n    v8i16 tmp1;\n\n    v16u8 alpha, beta, is_less_than;\n\n    v8i16 p0_or_q0, q0_or_p0;\n\n    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;\n\n    v16i8 zero = { 0 };\n\n    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;\n\n    v16u8 is_less_than_alpha, is_less_than_beta;\n\n    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;\n\n\n\n    {\n\n        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;\n\n\n\n        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,\n\n                      row0, row1, row2, row3, row4, row5, row6, row7);\n\n\n\n        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,\n\n                          p1_or_q1_org, p0_or_q0_org,\n\n                          q0_or_p0_org, q1_or_p1_org);\n\n    }\n\n\n\n    alpha = (v16u8) __msa_fill_b(alpha_in);\n\n    beta = (v16u8) __msa_fill_b(beta_in);\n\n\n\n    p0_asub_q0 = __msa_asub_u_b(p0_or_q0_org, q0_or_p0_org);\n\n    p1_asub_p0 = __msa_asub_u_b(p1_or_q1_org, p0_or_q0_org);\n\n    q1_asub_q0 = __msa_asub_u_b(q1_or_p1_org, q0_or_p0_org);\n\n\n\n    is_less_than_alpha = (p0_asub_q0 < alpha);\n\n    is_less_than_beta = (p1_asub_p0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than_alpha;\n\n    is_less_than_beta = (q1_asub_q0 < beta);\n\n    is_less_than = is_less_than_beta & is_less_than;\n\n\n\n    is_less_than = (v16u8) __msa_ilvr_d((v2i64) zero, (v2i64) is_less_than);\n\n\n\n    if (!__msa_test_bz_v(is_less_than)) {\n\n        p1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p1_or_q1_org);\n\n        p0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) p0_or_q0_org);\n\n        q0_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q0_or_p0_org);\n\n        q1_org_r = (v8i16) __msa_ilvr_b(zero, (v16i8) q1_or_p1_org);\n\n\n\n        AVC_LOOP_FILTER_P0_OR_Q0(p0_org_r, q1_org_r, p1_org_r, p0_or_q0);\n\n        AVC_LOOP_FILTER_P0_OR_Q0(q0_org_r, p1_org_r, q1_org_r, q0_or_p0);\n\n\n\n        /* convert 16 bit output into 8 bit output */\n\n        p0_or_q0 = (v8i16) __msa_pckev_b(zero, (v16i8) p0_or_q0);\n\n        q0_or_p0 = (v8i16) __msa_pckev_b(zero, (v16i8) q0_or_p0);\n\n\n\n        p0_or_q0_org =\n\n            __msa_bmnz_v(p0_or_q0_org, (v16u8) p0_or_q0, is_less_than);\n\n        q0_or_p0_org =\n\n            __msa_bmnz_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);\n\n\n\n        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);\n\n\n\n        data_cb_or_cr -= 1;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 0);\n\n        out1 = __msa_copy_u_h(tmp1, 1);\n\n        out2 = __msa_copy_u_h(tmp1, 2);\n\n        out3 = __msa_copy_u_h(tmp1, 3);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n        data_cb_or_cr += img_width;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 4);\n\n        out1 = __msa_copy_u_h(tmp1, 5);\n\n        out2 = __msa_copy_u_h(tmp1, 6);\n\n        out3 = __msa_copy_u_h(tmp1, 7);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n    }\n\n}\n", "idx": 3452, "substitutes": {"data_cb_or_cr": ["data_cb_nor_cm", "data_cb_nor_cr", "data_cb_or__r", "data_cb_or_tr", "data_cb_or_Cr", "data_cb_nor_r", "data_cb_or_cm", "data_cb_or__Cr", "data_cb_nor_Cr", "data_cb_or_ctr", "data_cb_or__ctr", "data_cb_or_r", "data_cb_nor_tr", "data_cb_nor_ctr", "data_cb_or__cr"], "alpha_in": ["alpha_IN", " alpha_din", "alpha_cin", "acl_in", "acl_IN", "acl_ins", "alpha_din", "alphaioin", "alphaiocin", "alphaioIN", "acl_out", " alpha_IN", "alphaiodin", " alpha_cin", "alpha_ins", "alpha_out"], "beta_in": ["betammins", "beta__in", "betammout", "betaixin", " beta_ind", "beta_ins", "beta_gen", " beta__ind", "beta__ind", "beta__bin", " beta__in", "betaixbin", "alpha_gen", "betammin", "alpha_ins", "alpha_out", "betammgen", "betaixind", "beta_bin", " beta_bin", "beta_out", " beta__bin", "beta_ind"], "img_width": ["img_w", " img_length", "img_len", " img_len", "image_width", "image_height", "img_length", "image_w", "img_height", " img_height"], "out0": ["Out0", "in1", "in2", "Out2", "Out1", "Out3", "in0", "in3"], "out1": ["OUT8", "Out0", "OUT1", "in1", "out01", "Out1", "in01", "OUT01", "in8", "out8", "OUT0", "Out01", "in0", "Out8"], "out2": ["result2", "result4", "OUT4", "OUT2", "OUT02", "result02", " out02", " out4", "out5", "out02", "out4", " out5", "result5", "OUT5"], "out3": ["OUT4", "result03", "OUT7", " out4", "out03", "OUT03", "result7", "out4", "result3", " out03", "OUT3", "result4", " out7", "out7"], "tmp1": ["mp9", "pi1", "tmp9", "pi5", "po5", "tmp5", "mp1", "mp5", "pi9", "po1", "po9"], "alpha": ["success", "acc", "ma", "acl", "alph", "fa", "upper", "la", "attr", "pi", "power", "xa", "balance", "asc", "anti", "asa", "Alpha", "weight", "phi", "extra", "amount", "title", "ta", "ppa", "error", "al", "pha", "lambda", "area", "name", "alias", "ity", "angle", "admin", "ac", "sha", "da", "prefix", "a"], "beta": ["gradient", "lr", "uni", "term", "meta", "fa", "mega", "fine", "confidence", "b", "Beta", "eta", "bet", "ava", "phi", "extra", "\u03b2", "ta", "mu", "bs", "xy", "minus", "normal", "bi", "bis", "lambda", "ba", "secret", "dirty", "fee", "nu", "binary", "gam", "base", "late"], "is_less_than": ["is_more_than", "is_lessablethan", "is_less_after", "is_lessableafter", "is_less_about", "is_lessableabout", "is_more_after", "is_more_about"], "p0_or_q0": ["p0_or_p0", "p0_or_q1", "p0_or_p1", "p0_or_dq1", "p0_or_dq0", "p0_or_dq2", "p0_or_q2", "p0_or_p2"], "q0_or_p0": ["q0_or_P0", "q0_or_q0", "q0_or_q1", "q0_or_P1", "q0_or_qk", "q0_or_p1", "q0_or_Pk", "q0_or_pk"], "p1_or_q1_org": ["p1_or_q1__reg", "p1_or_q1__or", "p1_or_q0_reg", "p1_or_q1_gen", "p1_or_q0_or", "p1_or_q0_og", "p1_or_q1__gen", "p1_or_q1_og", "p1_or_q1__org", "p1_or_q1_reg", "p1_or_q0_org", "p1_or_q0_gen", "p1_or_q1_or"], "p0_or_q0_org": ["p0_or_q0_gov", "p0_or_q1_Org", "p0_or_q0xgov", "p0_or_q0xgen", "p0_or_q0_or", "p0_or_q1_gov", "p0_or_q0_orig", "p0_or_q0_gen", "p0_or_q1_org", "p0_or_q0_Org", "p0_or_q0xorg", "p0_or_q1_orig", "p0_or_q1_gen", "p0_or_q1_or"], "q0_or_p0_org": ["q0_or_p0_gov", "q0_or_p0xcom", "q0_or_p0_or", "q0_or_p1xorg", "q0_or_p0xorg", "q0_or_p0xgen", "q0_or_p1_og", "q0_or_p1_or", "q0_or_p0xor", "q0_or_p1xog", "q0_or_p1_com", "q0_or_p0xog", "q0_or_p1_gov", "q0_or_p1_gen", "q0_or_p0_og", "q0_or_p0_com", "q0_or_p1xor", "q0_or_p0_gen", "q0_or_p1_org"], "q1_or_p1_org": ["q1_or_p1xgov", "q1_or_p2_gov", "q1_or_p1xOrg", "q1_or_p0_gov", "q1_or_p1_gen", "q1_or_p1_gov", "q1_or_p2_org", "q1_or_p1xgen", "q1_or_p1_Org", "q1_or_p0_gen", "q1_or_p0_org", "q1_or_p1xorg", "q1_or_p2_Org"], "p0_asub_q0": ["p0_asub_dq0", "p0_asub_Q1", "p0_asub_dqk", "p0_asub_dq2", "p0_asub_dq1", "p0_asub_q1", "p0_asub_p1", "p0_asub_Qk", "p0_asub_Q0", "p0_asub_pk", "p0_asub_p2", "p0_asub_qk", "p0_asub_p0", "p0_asub_q2"], "p1_asub_p0": ["p1_asub_P1", "p1_asub_p1", "p1_asub_u1", "p1_asub_u0", "p1_asub_Parg", "p1_asub_q1", "p1_asub_m0", "p1_asub_u50", "p1_asub_uarg", "p1_asub_m1", "p1_asub_q3", "p1_asub_p3", "p1_asub_p50", "p1_asub_P0", "p1_asub_q50", "p1_asub_q0", "p1_asub_qarg", "p1_asub_parg", "p1_asub_P50", "p1_asub_m3"], "q1_asub_q0": ["q1_asub_j1", "q1_asub_dq50", "q1_asub_q1", "q1_asub_dqarg", "q1_asub_p1", "q1_asub_dq0", "q1_asub_p50", "q1_asub_qarg", "q1_asub_jarg", "q1_asub_dq1", "q1_asub_q50", "q1_asub_j50", "q1_asub_p0", "q1_asub_parg", "q1_asub_j0"], "is_less_than_alpha": ["is_less_than_asc", "is_less_than_Alpha"], "is_less_than_beta": ["is_less_than_Beta", "is_less_than_phi"], "p1_org_r": ["p1_org2org", "p1_gov_R", "p1_org_R", "p1_org2or", "p1_gov_or", "p1_org_org", "p1_gov_org", "p1_org_or", "p1_gov_r", "p1_org2R", "p1_org2r"], "p0_org_r": ["p0_reg_or", "p0_org2org", "p0_org2or", "p0_org_rd", "p0_org2r", "p0_reg_r", "p0_reg_rd", "p0_org_or", "p0_org_org", "p0_org2rd", "p0_reg_org"], "q0_org_r": ["q0_org2rd", "q0_org_rb", "q0_org_ro", "q0_reg_r", "q0_org_rd", "q0_reg_rb", "q0_org2r", "q0_org2ro", "q0_reg_rd", "q0_reg_ro", "q0_org2rb"], "q1_org_r": ["q1_org_vr", "q1_orglyvr", "q1_reg2R", "q1_org2r", "q1_reg2vr", "q1_reg2org", "q1_reg_r", "q1_orglyR", "q1_reg_R", "q1_reg2r", "q1_org2org", "q1_org2R", "q1_org_R", "q1_orglyorg", "q1_orglyr", "q1_org_org", "q1_org2vr", "q1_reg_org", "q1_reg_vr"], "row0": ["col1", "col5", "ro00", " row10", "ow10", "roll5", "col3", " row02", "rollfrom", "ow0", "ow1", "colfrom", " rowfrom", " row00", "roll3", "col0", "ow5", "ow02", "row00", "rowfrom", "ow00", "row02", "row10", "roll1", "ro0", "roll0", "ro02", "ro10"], "row1": [" rowG", "col1", "ryG", "col5", "rowsOne", " rowOne", "roll5", "ry1", "ry2", "rows0", "rollOne", "col2", "col0", "rowOne", "roll1", "rows1", "rowG", "roll2", "rollG", "roll0", "ry0"], "row2": ["post5", "block3", "ow256", "block2", "roll5", "ry2", "server3", "post3", "ry02", "ow6", "post2", "ry5", "block5", "post4", "ow5", "roll02", "ow02", "server6", "row256", "roll256", "ry256", "row02", "server2", "roll2", "ow3", "block4", "server5", "ow2"], "row3": ["ry4", "block3", "roll7", "roll4", "roll5", " row43", "cell4", "block1", "ow1", "cell3", "ry3", "roll3", "block5", "ow4", "ow5", "ow7", "block7", "cell43", "ry43", "roll1", "row43", "ow3"], "row4": ["ry4", " row44", "ry49", "ow49", "ow44", "roll4", "roll5", "ry2", "rowFour", "roll44", "ow04", "ry04", "row49", "owFour", "server3", "roll49", "server4", "ow4", "serverFour", "roll04", "ow5", "row04", " rowFour", "roll2", "ow3", "row44", "server5", "ow2"], "row5": ["row05", " row45", "block05", "batch5", "roll5", "block8", "roll68", "ow05", "roll45", "row8", " row25", "row25", "roll6", "serverFive", "ow8", "block5", "batch8", "ry5", "row68", "ow5", "rollFive", "ow7", "block7", "ry6", "ry68", "server45", "roll25", "ry25", " row68", "batch05", " rowFive", "row45", "batch7", "server5", "rowFive"], "row6": ["roll9", "server5", "roll7", "server8", "rowDef", "batch5", "serverSix", "block8", "row8", "ow9", "row9", "blockSix", " row8", "ow6", "roll6", "ow8", "batch6", "block5", " row9", "batch8", "ow7", "server6", "until4", "block6", "roll8", " rowDef", "until6", "rowSix", "batchSix", "untilDef", "rollDef", "roll4"], "row7": ["roll9", " row77", "row67", "roll7", " row67", "viewseven", " rowseven", "ow77", "rowseven", "ow625", "box7", "box4", "box77", "ow9", "row9", "roll67", "row625", "ow6", "roll6", "batch07", "batch6", "box625", " row9", "ow4", " row07", "ow7", "row07", "batchseven", "view7", "view6", "row77", " row625", "ow67", "batch7", "view07"]}}
{"project": "FFmpeg", "commit_id": "e15824e75b5549e53eb5c1ffb79766321ac8d122", "target": 1, "func": "int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                          AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                          const uint8_t *buf, int len, uint16_t seq, int flags)\n\n{\n\n    int sbit, ebit, gobn, mbap, quant;\n\n    int res;\n\n\n\n    //av_log(ctx, AV_LOG_DEBUG, \"got h261 RTP packet with time: %u\\n\", timestamp);\n\n\n\n    /* drop data of previous packets in case of non-continuous (loss) packet stream */\n\n    if (data->buf && data->timestamp != *timestamp) {\n\n        h261_free_dyn_buffer(&data->buf);\n\n    }\n\n\n\n    /* sanity check for size of input packet */\n\n    if (len < 5 /* 4 bytes header and 1 byte payload at least */) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short H.261 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n      decode the H.261 payload header according to section 4.1 of RFC 4587:\n\n      (uses 4 bytes between RTP header and H.261 stream per packet)\n\n\n\n         0                   1                   2                   3\n\n         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n        |SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |\n\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n\n\n           Start bit position (SBIT): 3 bits\n\n           End bit position (EBIT): 3 bits\n\n           INTRA-frame encoded data (I): 1 bit\n\n           Motion Vector flag (V): 1 bit\n\n           GOB number (GOBN): 4 bits\n\n           Macroblock address predictor (MBAP): 5 bits\n\n           Quantizer (QUANT): 5 bits\n\n           Horizontal motion vector data (HMVD): 5 bits\n\n           Vertical motion vector data (VMVD): 5 bits\n\n\n\n    */\n\n    sbit  =  (buf[0] >> 5) & 0x07;\n\n    ebit  =  (buf[0] >> 2) & 0x07;\n\n    gobn  =  (buf[1] >> 4) & 0x0f;\n\n    mbap  = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01);\n\n    quant =  (buf[1] >> 4) & 0x0f;\n\n\n\n    /* pass the H.261 payload header and continue with the actual payload */\n\n    buf += RTP_H261_PAYLOAD_HEADER_SIZE;\n\n    len -= RTP_H261_PAYLOAD_HEADER_SIZE;\n\n\n\n    /* start frame buffering with new dynamic buffer */\n\n    if (!data->buf) {\n\n        /* sanity check: a new frame starts with gobn=0, sbit=0, mbap=0, uqnat=0 */\n\n        if (!gobn  && !sbit && !mbap && !quant){\n\n            res = avio_open_dyn_buf(&data->buf);\n\n            if (res < 0)\n\n                return res;\n\n            /* update the timestamp in the frame packet with the one from the RTP packet */\n\n            data->timestamp = *timestamp;\n\n        } else {\n\n            /* frame not started yet, need more packets */\n\n            return AVERROR(EAGAIN);\n\n        }\n\n    }\n\n\n\n    /* do the \"byte merging\" at the boundaries of two consecutive frame fragments */\n\n    if (data->endbyte_bits || sbit) {\n\n        if (data->endbyte_bits == sbit) {\n\n            data->endbyte |= buf[0] & (0xff >> sbit);\n\n            data->endbyte_bits = 0;\n\n            buf++;\n\n            len--;\n\n            avio_w8(data->buf, data->endbyte);\n\n        } else {\n\n            /* ebit/sbit values inconsistent, assuming packet loss */\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, buf, len*8 - ebit);\n\n            skip_bits(&gb, sbit);\n\n            if (data->endbyte_bits) {\n\n                data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits);\n\n                avio_w8(data->buf, data->endbyte);\n\n            }\n\n            while (get_bits_left(&gb) >= 8)\n\n                avio_w8(data->buf, get_bits(&gb, 8));\n\n            data->endbyte_bits = get_bits_left(&gb);\n\n            if (data->endbyte_bits)\n\n                data->endbyte = get_bits(&gb, data->endbyte_bits) <<\n\n                                (8 - data->endbyte_bits);\n\n            ebit = 0;\n\n            len = 0;\n\n        }\n\n    }\n\n    if (ebit) {\n\n        if (len > 0)\n\n            avio_write(data->buf, buf, len - 1);\n\n        data->endbyte_bits = 8 - ebit;\n\n        data->endbyte = buf[len - 1] & (0xff << ebit);\n\n    } else {\n\n        avio_write(data->buf, buf, len);\n\n    }\n\n\n\n    /* RTP marker bit means: last fragment of current frame was received;\n\n       otherwise, an additional fragment is needed for the current frame */\n\n    if (!(flags & RTP_FLAG_MARKER))\n\n        return AVERROR(EAGAIN);\n\n\n\n    /* write the completed last byte from the \"byte merging\" */\n\n    if (data->endbyte_bits)\n\n        avio_w8(data->buf, data->endbyte);\n\n    data->endbyte_bits = 0;\n\n\n\n    /* close frame buffering and create resulting A/V packet */\n\n    res = ff_rtp_finalize_packet(pkt, &data->buf, st->index);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    return 0;\n\n}\n", "idx": 3456, "substitutes": {"ctx": ["cp", "tmp", "xc", "cn", "conn", "conv", "dc", "txt", "cfg", "ci", "mc", "cb", "act", "tx", "kt", "sc", "cmp", "tz", "config", "kw", "conf", "cf", "cv", "context", "tc", "pkg", "gc", "co", "cc", "ct", "cm", "rc", "ck", "Context", "iat", "obj", "jac", "cmd"], "data": ["reader", "parent", "user", "format", "handle", "p", "window", "read", "out", "load", "form", "request", "zero", "time", "state", "context", "buffer", "response", "de", "partial", "done", "missing", "resp", "this", "batch", "d", "Data", "message", "test", "list", "next", "session", "result", "details", "relation", "policy", "valid", "final", "accept", "rec", "name", "nt", "rel", "al", "report", "length", "self", "device", "size", "record", "dd", "to", "definition", "action", "dat", "info", "cache", "dev", "connection", "update", "error", " DATA", "db", "exclusive", "empty", "ata", "client", "di", "results", " Data", "present", "date", "da", "exec", "cmd", "image", "public", "no", "DATA", "query", "debug", "important", "table", "tx", "extra", "def", "delete", "defined", "content", "writer", "local", "metadata", "command", "complete", "video", "o", "event", "ad", "store", "obj", "module"], "st": ["mt", "inst", "sta", "ste", "et", "ut", "rest", "sth", "tt", "ast", "ST", "sent", "start", "sw", "ist", "sam", "fr", "str", "sts", "nt", "est", "ct", "ost", "stage", "se", "std", "St", "sp"], "pkt": ["pqt", "pck", "ppqt", " pck", " pqt", "ppct", "pct", "ppck", "Pck", "Pqt", "Pct", "Pkt", " pct", "ppkt"], "timestamp": ["Timeline", "timetime", "temest", "tmeline", "temetime", "mominal", "temeline", "statency", "timeity", "timtime", "tmest", "momestamp", "tmestamp", "typest", "stimeline", "statestamp", "tmtime", "Timtime", "tmetime", "typity", "stimestamp", "Timetime", "typestamp", "timest", "temency", "temtime", "stiminal", "momency", "teminal", "timity", "timeeline", "Timestamp", "timeestamp", "timinal", "timency", "stimency", "momeline", "Timest", "timeline", "statest", "timeency", "momest", "timeetime", "statity", "typency", "temestamp", "Timency", "timeest"], "buf": ["ctr", "ff", "tmp", "mb", "port", "window", "read", "bp", "iter", "var", "bar", "cap", "cf", "buffer", "cam", "nom", "pkg", "emb", "queue", "bytes", "f", "mem", "batch", "br", "test", "bc", "text", "conv", "pb", "deg", "box", "np", "Len", "cb", "rb", "act", "msg", "bs", "ptr", "aka", "loc", "uv", "tr", "bn", "elt", "enc", "uf", "length", "code", "addr", "half", "ref", "fac", "broad", "bed", "cache", "cur", "gen", "block", "err", "pool", "ob", "str", "nm", "bin", "wb", "pt", "db", "fb", "empty", "rc", "bu", "map", "cmd", "doc", "proc", "alloc", "xff", "func", "prop", "temp", "arr", "limit", "img", "txt", "b", "pos", "orig", "vec", "desc", "cv", "bag", "Buffer", "good", "bits", "raw", "Buff", "obj", "buff"], "len": ["ls", "lp", "le", "l", "list", "size", "L", "nl", "z", "limit", "all", "lic", "n", "ref", "ren", "kl", "lim", "ish", "li", "Len", "lf", "fin", "lit", "num", "pos", "msg", "lan", "ll", "cmp", "syn", "fl", "vec", "length", "uf", "lon", " l", "SIZE", "dl", "e", "err", "el", "en", "ln", "str", "del", "loc", "offset", "val", "nt", "bytes", "h", "rel", "ret", "f", " clen", "fn", "resp", "elt", "t", "mem", "ld", "sp"], "seq": [" sequence", " req", " rid", " enc", " nos", " spec", " trans", " resp", " pos", " status", " next", " sig", " cond", " ver", " sup", " typ", " pref", " cas", " frag", " alt", " count", " rev", " ref", " clen", " vers", " continuation", " qual", " id"], "flags": ["status", "acts", "mask", "faces", "times", "options", "Flags", "ds", "vals", "fs", "fields", " flag", "heads", "ps", "fl", "ns", "tags", "ts", "cs", "ents", " options", "aps", "types", "rs", "ags", "bits", "args", "flag"], "sbit": ["ssbyte", "lsbit", "sbyte", "esbyte", "Schar", "fsbyte", "fsbits", " sbits", "gsbutt", "schar", "jsbyte", "stsbt", " sBit", "lsBIT", "Sbits", "tsbit", " sbutt", "sbits", "lsbutt", "ssbits", "fsbit", "sBIT", "gsbool", "jsket", "esbit", "lsbits", "lsbool", "esbits", "srot", "sBit", "jsbit", "Sbit", "sbt", "stsBit", " sbin", "sbool", "tsbutt", "atsbyte", "fsrot", "stsbyte", "sbug", " sket", " sBIT", "sket", "Sbyte", "stsbit", "eschar", " sbyte", "atsbug", "SBIT", "sbin", "ssbit", "atsbit", "sschar", "atsket", " srot", "sbutt", "tsbin", "tsbits", "gsbyte", "lsbyte", " sbug", "Srot", "gsbit", " sbt", "jsbug"], "ebit": ["obbit", " ebbit", "deblit", "rebio", "embiter", "rebIT", "ibIT", " ebap", "embit", "ebitt", "escIT", "embitt", "eblit", "obit", "rebit", "debap", "ebIT", "ebith", "zebait", "embait", "ibio", "obap", "zebitt", "zebiter", "escith", "debit", "escio", "debbit", "ebiter", "zbitt", "zbiter", "ibith", "ebait", "ibit", "oblit", "ebbit", "rebith", "escit", "ebap", "zebit", "ebio", "zbit", "zbait", " eblit"], "gobn": ["sban", "gobns", "gobd", "hubl", "obmn", "ombmn", "hubmn", "gobl", "dban", "huban", "ubermn", "robn", "orbns", "orbd", "oban", "sbmn", "sbn", "orbn", "ombn", "ubern", "ombl", "uberd", "dbl", "gobmn", "mbn", "dbn", "robmn", "robd", "mbmn", "orbmn", "dbmn", "omban", "uberns", "mban", "obn", "hubn", "goban", "obl", "mbl", "robns", "sbl"], "mbap": ["mpac", "embmap", "ymap", "gbaps", "ebac", "bbmap", "embap", "gbmap", "gbap", "ebapper", "embapper", "mpache", "obapper", "bmap", "mbat", "embaps", "mpmap", "bbap", "mpat", "ebat", "obap", "ymat", "bbac", "mpap", "bmmap", "mbapper", "bmac", "mbac", "gbapper", "bbache", "bmache", "mbmap", "ebap", "obaps", "mpapper", "mbaps", "ymapper", "mbache", "ymac", "obmap"], "quant": ["q", "aux", "gr", "iq", "percent", "mask", "qq", "mix", "sim", "prim", "supp", "fac", "txt", "qi", "util", "debug", "stable", "var", "bit", "serial", "qt", "volume", "qual", "req", "prof", "cmp", "qu", "shock", "series", "dq", "requ", "product", "compl", "mult", "imp", "comp", "frac", "pkg", "uint", "tech", "eq", "material", "scale", "nt", "vol", "alpha", "fet", "pub", "Quant", "quiet", "cmd", "buff"], "res": ["proc", "pres", "rows", "Res", "func", "RES", "arr", "rest", "acts", "mask", "als", " Res", "resolution", "resources", "result", "r", "details", "resh", "s", "out", "act", "i", "respons", "vals", "fs", "ne", "RS", "zero", "req", "cons", "ps", " rs", "js", "ms", "cond", "ts", "ver", "cs", " ret", " RES", "pas", "rev", "reg", "has", "rs", "ress", "val", "results", "expr", "ret", "yes", "pers", "bits", "rem", "reset", "resp", "sol", "os", "rel", "re", " results"], "gb": ["Gb", " rgb", " rg", "mb", "rg", "gio", "git", "tg", "bd", "big", "kb", "py", "g", " gif", "gif", "hog", "cfg", "ng", "cb", "rb", "yg", "lib", "pg", "b", "gd", "gt", "gi", "ge", "xy", "ig", "bs", "gu", " GB", " g", "ghost", "cv", " pg", "bg", "rl", "gc", " db", "db", "bytes", "bits", "GB", "gs", "sb", "bf", " eg", "gg", "gm", "nb", "gh", "buff"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int vdpau_mpeg_start_frame(AVCodecContext *avctx,\n\n                                  const uint8_t *buffer, uint32_t size)\n\n{\n\n    MpegEncContext * const s = avctx->priv_data;\n\n    Picture *pic             = s->current_picture_ptr;\n\n    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;\n\n    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;\n\n    VdpVideoSurface ref;\n\n    int i;\n\n\n\n    /* fill VdpPictureInfoMPEG1Or2 struct */\n\n    info->forward_reference  = VDP_INVALID_HANDLE;\n\n    info->backward_reference = VDP_INVALID_HANDLE;\n\n\n\n    switch (s->pict_type) {\n\n    case AV_PICTURE_TYPE_B:\n\n        ref = ff_vdpau_get_surface_id(&s->next_picture.f);\n\n        assert(ref != VDP_INVALID_HANDLE);\n\n        info->backward_reference = ref;\n\n        /* fall through to forward prediction */\n\n    case AV_PICTURE_TYPE_P:\n\n        ref = ff_vdpau_get_surface_id(&s->last_picture.f);\n\n        info->forward_reference  = ref;\n\n    }\n\n\n\n    info->slice_count                = 0;\n\n    info->picture_structure          = s->picture_structure;\n\n    info->picture_coding_type        = s->pict_type;\n\n    info->intra_dc_precision         = s->intra_dc_precision;\n\n    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;\n\n    info->concealment_motion_vectors = s->concealment_motion_vectors;\n\n    info->intra_vlc_format           = s->intra_vlc_format;\n\n    info->alternate_scan             = s->alternate_scan;\n\n    info->q_scale_type               = s->q_scale_type;\n\n    info->top_field_first            = s->top_field_first;\n\n    // Both for MPEG-1 only, zero for MPEG-2:\n\n    info->full_pel_forward_vector    = s->full_pel[0];\n\n    info->full_pel_backward_vector   = s->full_pel[1];\n\n    // For MPEG-1 fill both horizontal & vertical:\n\n    info->f_code[0][0]               = s->mpeg_f_code[0][0];\n\n    info->f_code[0][1]               = s->mpeg_f_code[0][1];\n\n    info->f_code[1][0]               = s->mpeg_f_code[1][0];\n\n    info->f_code[1][1]               = s->mpeg_f_code[1][1];\n\n    for (i = 0; i < 64; ++i) {\n\n        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];\n\n        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];\n\n    }\n\n\n\n    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);\n\n}\n", "idx": 3460, "substitutes": {"avctx": ["cvpkg", "avctl", "vcontext", "vtx", "avtx", "Avcontext", "vctl", " avctl", "Avtx", " avtx", " avpkg", " avcontext", "camctx", "camcontext", "vctx", "cvcontext", "avcontext", "camtx", "avpkg", "Avctl", "cvtx", "campkg", "Avctx", "cvctx"], "buffer": ["batch", "image", "document", "message", "face", "buf", "code", "window", "result", "cache", "bb", "uf", "file", "block", "context", "command", "stream", "Buffer", "queue", "frame", "channel", "screen", "binary", "bf", "base", "length", "buff"], "size": [" length", "code", "count", "z", " sizes", " Size", " n", " scale", "shape", "type", " resize", " shape", "length", "SIZE", "w", "e", "offset", "ize", "scale", " len", "bytes", " count", "dim", "len", "Size"], "s": ["ls", "c", "p", "es", "n", "app", "ses", "set", "series", "its", "cs", "spec", "h", "gs", "sb", "args", "os", "serv", "a", "d", "stats", "sv", "conv", "settings", "vs", "details", "xs", "ess", "ds", "qs", "m", "less", "ex", "bs", "ims", "sam", "hs", "sts", "ins", "sq", "j", "S", "ss", "z", "sa", "comm", "res", "sym", "ns", "sw", "y", "ms", "ts", "changes", "v", "ops", "sp", "sys", "status", "is", "g", "times", "fs", "ps", "parts", "js", "sd", "comments", "w", "as", "sports", "rs", "bits", "ats", "t", "obj"], "pic": ["proc", "doc", "pres", "fp", "cp", "jp", "phys", "pc", "c", "p", "img", "ic", "pi", "photo", "pp", "mp", "pict", "picture", "pr", "ps", "Picture", "ig", "pa", "cap", "cam", "peg", "Pic", "ctx", "pl", "gc", "pas", "phot", "ct", "capt", "f", "ac", "t", "mc", "sp"], "pic_ctx": ["pic_context", "pic2tx", " pic_tx", "picture_ctx", "pic2pkg", " pic_context", "pic_tmp", "picture_tmp", "pic2ctx", "pic_pkg", " pic_pkg", "picture_tx", "pic2context", "pic_tx", "picture_context"], "info": ["id", "user", "trace", "try", "summary", "p", "init", "app", "iter", "options", "out", "set", "sum", "store", "lock", "off", "reason", "time", "conf", "http", "version", "ti", "by", "help", "f", "mem", "list", "follow", "meta", "result", "create", "details", "open", "link", "num", "ui", "check", "picture", "it", "note", "name", "ion", "io", "frame", "report", "j", "information", "er", "code", "Info", "all", "inf", "description", "pi", "index", "progress", "ci", "cache", "type", "history", "fi", "update", "error", "comment", "exec", "auth", "success", "data", "image", "status", "item", "stat", "query", "debug", "notice", "def", "edit", "config", "ip", "local", "metadata", "command", "alias", "show", "INFO", "now", "o", "event", "about", "state", "fo"], "ref": ["id", "mb", "use", "port", "p", " href", "aff", "req", "ef", "conf", "rf", "round", " pointer", " pref", "ret", "f", "resp", "href", "mem", "re", "br", " rel", " ptr", "tip", "cb", "af", "tab", "cmp", " refer", "tag", "note", "ptr", "rec", "eval", "rev", "alt", "remote", "range", "frame", "rel", "Reference", "uf", "alf", "l", "addr", " reference", "seek", "index", "pointer", " Ref", "virt", "fi", " referenced", "diff", "err", "val", "Ref", "REF", "reflect", "prefix", "point", "inter", "prop", "eb", "r", "label", "url", "pos", "def", " hint", "alias", " offset", "reference", "obj"], "i": ["j", "ii", "c", " j", "p", "pi", "r", "ci", "li", "m", "b", "it", "ij", "fi", "ip", " ii", " pi", "e", "ia", "v", "o", "di", "f", "si", "t", "a", " bi"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_decode_init_vlc(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, \n\n                 intra_MCBPC_bits, 1, 1,\n\n                 intra_MCBPC_code, 1, 1);\n\n        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, \n\n                 inter_MCBPC_bits, 1, 1,\n\n                 inter_MCBPC_code, 1, 1);\n\n        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,\n\n                 &cbpy_tab[0][1], 2, 1,\n\n                 &cbpy_tab[0][0], 2, 1);\n\n        init_vlc(&mv_vlc, MV_VLC_BITS, 33,\n\n                 &mvtab[0][1], 2, 1,\n\n                 &mvtab[0][0], 2, 1);\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rvlc_rl_inter);\n\n        init_rl(&rvlc_rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        init_vlc_rl(&rl_inter);\n\n        init_vlc_rl(&rl_intra);\n\n        init_vlc_rl(&rvlc_rl_inter);\n\n        init_vlc_rl(&rvlc_rl_intra);\n\n        init_vlc_rl(&rl_intra_aic);\n\n        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_lum[0][1], 2, 1,\n\n                 &DCtab_lum[0][0], 2, 1);\n\n        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_chrom[0][1], 2, 1,\n\n                 &DCtab_chrom[0][0], 2, 1);\n\n        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n\n                 &sprite_trajectory_tab[0][1], 4, 2,\n\n                 &sprite_trajectory_tab[0][0], 4, 2);\n\n        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n\n                 &mb_type_b_tab[0][1], 2, 1,\n\n                 &mb_type_b_tab[0][0], 2, 1);\n\n        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,\n\n                 &h263_mbtype_b_tab[0][1], 2, 1,\n\n                 &h263_mbtype_b_tab[0][0], 2, 1);\n\n        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,\n\n                 &cbpc_b_tab[0][1], 2, 1,\n\n                 &cbpc_b_tab[0][0], 2, 1);\n\n    }\n\n}\n", "idx": 3476, "substitutes": {"s": ["d", "S", "c", "sg", "sv", "ss", "p", "es", "g", "ds", "b", "fs", "sc", "ps", "js", "ims", "w", "e", "ms", "cs", "ts", "rs", "v", "gs", "sb", "sq", "os"]}}
{"project": "qemu", "commit_id": "ee71c984342408a357a74f65915bf66484ba445a", "target": 1, "func": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_read: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n", "idx": 3484, "substitutes": {"opaque": ["oatile", " opula", " opque", "compaque", "oposter", "oaque", "Opque", "Opaque", " opatile", "compaques", "oplque", "oplaque", " opaques", "opque", "opula", "ooster", "oque", "oplatile", "compque", "opaques", "compula", " oposter", "Opula", "Opaques", "oploster", "opatile"], "offset": ["data", "oid", "et", "op", "shift", "addr", "count", "slot", "limit", "seek", "from", "ref", "index", "pointer", "set", "align", "pos", "start", "off", "zero", "at", "type", "pad", "amount", "base", "location", "length", "block", "error", "SIZE", "buffer", "attribute", " offsets", "origin", "Offset", "into", "address", "padding", "o", "position", "seed", "timeout", "point", "t", "area", "len", "sp"], "size": [" length", "message", "shift", "count", "z", "p", "set", "align", "m", "start", "off", "type", "amount", "length", "SIZE", "e", "command", "name", "ize", "address", "h", "len", "Size", "sp"], "s": ["sys", "ls", "S", "c", "is", "sv", "ss", "p", "es", "service", "sl", "sa", "qs", "m", "b", "fs", "aws", "ps", "js", "ns", "w", "ts", "spec", "hs", "sts", "rs", "v", "h", "gs", "sb", "sq", "os", "sol", "t", "a", "sp"], "n": ["gn", "ni", "j", "d", "number", "ul", " ng", "l", "c", "no", "count", "nc", "nr", "non", "cn", "N", "z", "p", "nl", "g", "wn", "np", "ng", "out", " c", "m", "i", "x", "num", "ne", "none", "nan", " i", "ns", "note", " l", "e", "en", "tn", "ln", "nm", "ind", " t", "un", "mn", "an", "v", " len", "nt", "o", "dn", "nu", " N", "nn", "na", "fn", "nor", "t", "len", "rn", "sn"]}}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    \n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    skip_bits(&s->gb, 4);\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        s->has_b_frames = 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        mpeg1_init_vlc(s);\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_intra_matrix[i];\n\n            s->intra_matrix[i] = v;\n\n            s->chroma_intra_matrix[i] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->non_intra_matrix[j] = v;\n\n            s->chroma_non_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->non_intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_non_intra_matrix[i];\n\n            s->non_intra_matrix[i] = v;\n\n            s->chroma_non_intra_matrix[i] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    return 0;\n\n}\n", "idx": 3499, "substitutes": {"avctx": ["avconn", "avectx", "vrobj", "avclient", "AVdc", "Avcontext", "avercontext", "avjac", "avobj", "avertx", "avetc", "AVconn", "aveca", " avca", "avca", "evtx", "Avconn", "wavjac", "avpkg", "avecontext", "avercu", "averca", "vrreq", "AVcontext", "averpkg", "abdc", "avconfig", "wavtx", "avedc", "avtx", "avcu", "vrconn", "ajctx", "avdc", "ajca", "abctx", "Avtx", " avcontext", " avobj", "evcontext", "averobj", "aveclient", "ajjac", "abconfig", "Avctx", "wavcu", "aveconfig", "abconn", "avertc", "evjac", "wavpkg", "avtc", "avetx", "averclient", "wavctx", "AVtx", "evctx", "AVctx", "avercmd", "ajobj", " avconn", "abclient", " avcmd", "avcmd", "vrctx", "aveconn", " avtc", "avejac", "abcontext", "averconn", " avpkg", " avtx", "AVconfig", "avereq", "wavcontext", " avjac", "avcontext", "avreq", " avcu", "avecmd", "averreq", "aveobj", "averctx"], "buf": ["data", "xff", "tmp", "bc", "p", "text", "img", "window", "ref", "pb", "read", "out", "cb", "rb", "b", "msg", "seq", "block", "buffer", "cv", "w", "ctx", "bg", "wb", "Buffer", "bin", "db", "fb", "queue", "bytes", "bf", "raw", "Buff", "nb", "mem", "uf", "cmd", "buff"], "buf_size": [" buf1ize", " buf1SIZE", "buf1SIZE", "buf_SIZE", "buf_Size", "buf1ize", "buf2Size", " buf1size", "buf2ize", "buf_ize", " buf_SIZE", "buf1size", "buf2size", "buf2SIZE", " buf_Size", " buf_ize", " buf1Size", "buf1Size"], "s1": [" sOne", "ssOne", "sOne", "s01", "nsone", " s0", "ses1", "gs2", "ns01", " s9", "gs1", "rs1", "rs0", "rs2", "rsone", "jsOne", "ls0", "sesOne", "ns2", "sone", "cs1", " s2", "ls2", "ls01", "ses2", "ss2", "js1", "csOne", "ls1", "ns1", "gsone", " s01", "gs01", "ses9", "s0", "s9", "rs01", "ss1", "ss9", "s2"], "s": ["ls", "summary", "c", "sg", "p", "es", "n", "set", "params", "us", "services", "its", "conf", "ords", "ports", "cs", "spec", "ains", "ies", "an", "h", "gs", "sb", "os", "a", "stats", "sv", "settings", "vs", "details", "ers", "ds", "qs", "m", "ants", "less", "bs", "ims", "bis", "hs", "ar", "sts", "eps", "ins", "self", "S", "l", "ges", "er", "ss", "z", "als", "comm", "res", "tes", "ns", "sw", "y", "ms", "ts", "changes", "se", "ops", "sys", "status", "is", "simple", "r", "b", "fs", "aws", "ps", "parts", "js", "w", "e", "as", "sports", "sm", "rs", "bits", "ats", "t", "obj"], "height": ["ty", "bottom", "axy", "visible", "window", "hung", "html", "above", "volume", "ih", "hei", "buffer", "here", "available", "embed", " Height", "scroll", "h", "alpha", "sky", "hash", "dim", "huge", "ht", "era", "high", "tight", "count", "gravity", "row", "lat", "shape", "location", "bid", "range", "depth", "angle", "padding", "grow", "th", "length", "capacity", "gh", "size", "host", "style", "chip", "power", "rank", "confidence", "memory", "cache", "history", "title", "y", "radius", "quality", "input", "rows", "he", "Height", "through", "docker", "resolution", "added", "crop", "table", " heights", "ows", "bits", "hang", "density"], "i": ["multi", "id", "l", "ii", "ki", "c", "p", "sim", "g", "n", "xi", "ic", "index", "pi", "qi", "me", "ci", "li", "ami", "m", "b", "x", "u", "ui", "phi", "it", "gi", "vi", "ip", "gu", "y", "bi", "im", "e", "ie", "iu", "ti", "ind", "ix", "print", "zi", "in", "mi", "di", "h", "\u0438", "o", "ai", "I", "si", "f"], "v": ["vc", "q", "vo", "value", "V", "vr", "sv", "qv", "conv", "p", "g", "n", "ev", "vs", "vt", "m", "nv", "b", "x", "u", "va", "vp", "vi", "tv", "y", "vm", "version", "vv", "cv", "w", "e", "ver", "video", "ov", "h", "uv", "av", "ve"], "j": ["jump", "q", "jp", "ji", "jit", "dj", "uj", "aj", "z", "g", "n", "kj", "jas", "b", "it", "J", "ij", "jl", "job", "js", "bi", "jc", "oj", "ja", "h", "jac", "jj", "json"]}}
{"project": "FFmpeg", "commit_id": "d600b18f224e02f8bfc6660bfa442e7ff3fb057c", "target": 1, "func": "void ff_rfps_calculate(AVFormatContext *ic)\n{\n    int i, j;\n    for (i = 0; i<ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)\n        // the check for tb_unreliable() is not completely correct, since this is not about handling\n        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.\n        // ipmovie.c produces.\n        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);\n        if (st->info->duration_count>1 && !st->r_frame_rate.num\n            && tb_unreliable(st->codec)) {\n            int num = 0;\n            double best_error= 0.01;\n            for (j=0; j<MAX_STD_TIMEBASES; j++) {\n                int k;\n                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))\n                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))\n                for(k=0; k<2; k++){\n                    int n= st->info->duration_count;\n                    double a= st->info->duration_error[k][0][j] / n;\n                    double error= st->info->duration_error[k][1][j]/n - a*a;\n                    if(error < best_error && best_error> 0.000000001){\n                        best_error= error;\n                        num = get_std_framerate(j);\n                    }\n                    if(error < 0.02)\n                        av_log(NULL, AV_LOG_DEBUG, \"rfps: %f %f\\n\", get_std_framerate(j) / 12.0/1001, error);\n                }\n            }\n            // do not increase frame rate by more than 1 % in order to match a standard rate.\n            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))\n                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);\n        }\n        av_freep(&st->info->duration_error);\n        st->info->last_dts = AV_NOPTS_VALUE;\n        st->info->duration_count = 0;\n        st->info->rfps_duration_sum = 0;\n    }\n}", "idx": 3502, "substitutes": {"ic": ["vc", "fc", "et", "iq", "c", "pc", "bc", "tt", "ics", "iac", "eric", "ico", "ici", "ci", "comm", "tic", "mic", "inc", "ict", "ric", "IC", "etc", "WC", "voc", "aci", "ip", "oc", "icing", "irc", "ICS", "ctx", "nic", "wic", "anc", "gc", "ia", "cc", "onic", "ct", "icc", "aic", "pic", "ik", "lc", "ac", "aus", "tc"], "i": ["multi", "batch", "id", "ii", "ki", "is", "p", "sim", "n", "init", "xi", "pi", "index", "me", "qi", "li", "ci", "ami", "m", "ei", "x", "us", "ui", "info", "phi", "it", "gi", "ij", "ip", " ii", "oi", "y", "fi", "ims", "bi", "im", "e", "hi", "iu", "ti", "ie", "ind", "ix", "v", "zi", "in", "mi", "o", "ini", "di", "ai", "si", "I", "f", "ri", "a", "inter"], "j": ["jit", "aj", "p", "n", "server", "out", "jas", "x", "off", "J", "pr", "job", "ind", "vol", "h", "jac", "br", "q", "next", "uj", "it", "jl", "xy", "note", "im", "ion", "tr", "json", "jump", "l", "ii", "jp", "ji", "z", "kj", "index", "adj", "ij", "y", "jo", "bi", "el", "je", "go", "v", "jj", "_", "dj", "bj", "jack", "sim", "g", "b", "js", "jc", "oj", "ja", "obj", "jpg"], "st": ["mt", "stan", "usr", "sta", "ty", "step", "sth", "tra", "mont", "kl", "set", "td", "ST", "sc", "t", "h", "est", "ck", "so", "art", "ld", "St", "net", "list", "ut", "ast", "act", "lat", "kt", "storage", "ist", "sam", "sty", "sts", "mm", "nt", "ost", "th", "std", "sn", "ace", "inst", "rd", "ste", "rest", "ss", "dd", "lt", "lo", "ust", "etc", "sw", "ts", "str", "pt", "stage", "irst", "must", "se", "sp", "spect", "stack", "add", "et", "nd", "sh", "tt", "stat", "sim", "ft", "cont", "start", "stop", "rt", "sm", "play", "ct", "cl", "lc", "store", "obj"], "k": ["ko", "ka", "acc", "q", "work", "key", "kan", "ki", "c", "tk", "km", "z", "ke", "kh", "p", "isk", "n", "uk", "kj", "kl", "kk", "kind", "m", "x", "ijk", "kt", "ku", "unk", "sk", "ok", "ark", "ask", "it", "ack", "kr", "kw", "y", "mk", "kit", "ikk", "spec", "ks", "kn", "kick", "ind", "ek", "v", "jj", "UK", "o", "K", "wk", "ik", "ck", "ac", "t", "kid", "ger", "ak"]}}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_o(DisasContext *s, TCGv reg)\n\n{\n\n    gen_compute_eflags(s);\n\n    tcg_gen_shri_tl(reg, cpu_cc_src, 11);\n\n    tcg_gen_andi_tl(reg, reg, 1);\n\n}\n", "idx": 3513, "substitutes": {"s": ["d", "S", "c", "sg", "is", "sv", "ss", "p", "scl", "n", "ses", "comm", "ds", "qs", "m", "b", "fs", "ps", "js", "ns", "w", "e", "as", "cs", "ts", "sts", "rs", "v", "in", "h", "gs", "sb", "os", "sq", "t", "a"], "reg": ["sys", "REG", " r", "gr", " rg", "list", "Reg", "rg", "ro", "addr", "sg", "pc", " registry", "g", "row", "ref", "hw", "r", "ru", "out", " ro", "act", "res", "num", "eg", "grid", "ric", "red", "msg", "req", "ex", "tag", " g", "sd", "err", " gp", "rec", "rr", "str", "gc", "istry", "re", "region", "or", " mem", "disc", "ret", "rem", "rc", "ac", "mem", "obj", "serv", "eng", " region"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->sps.direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 3517, "substitutes": {"h": ["zh", "l", "he", "c", "host", "handle", "sh", "bh", "p", "kh", "hw", "oh", "ah", "H", "hh", "s", "her", "util", "hp", "dh", "phi", "ih", "history", "http", "ch", "hl", "w", "rh", "context", "hi", "ctx", "hm", "hs", "v", "ha", "hash", "help", "t", "ht"], "sl": ["ls", "zh", "l", "vl", "il", "owl", "sh", "bh", "isl", "nl", "Sl", "sv", "scl", "gl", "slice", "service", "la", "kl", "sql", "spl", "lit", "sil", "SL", "ll", "sc", "phi", "jl", "syn", "fl", "sw", "hl", "dl", "tl", "pl", "sche", "ln", "rl", "pkg", "coll", "eval", "sm", "str", "console", "sp", "bl", "ml", "sel", "cl", "sb", "sol", "serv", "asm", "ssl", "sn"], "mb_type": ["mm_name", "MB_TYPE", "mblyTYPE", "mb_name", "mb7type", "mb_number", "mb_TYPE", "MB_number", "mb7ype", "mblyname", "mb7Type", "mm_class", "mb7name", "MB_no", "mblynumber", "mb_Type", "mblytype", "mb_class", "mm_TYPE", "MB_type", "mblyno", "mb_no", "MB_Type", "mb_ype", "mm_type", "MB_name", "MB_ype", "mblyclass"], "mb_type_col": ["mb_type2col", "mb_type_column", "mb_type_row", "mb_type2column", "mb_type2Col", "mb_type2row", "mb_types_col", "mb_types_column", "mb_type_Col", "mb_types_row", "mb_types_Col"], "l1mv0": ["l1mav4", "l1imv0", "l1imvc4", "l1mvc8", "l1mva8", "l1imvc1", "l1imv8", "l1mvc1", "l1mv4", "l1mav0", "l1mva4", "l1imv4", "l1mvc0", "l1mva1", "l1imvc8", "l1mav1", "l1mv8", "l1mvc4", "l1mav8", "l1imvc0", "l1imv1", "l1mva0"], "l1mv1": ["l1mv2", "l1imv0", "l1mV2", "l1mV0", "l1imvc1", "l1mvc1", "l1mav0", "l1mV1", "l1mvc0", "l1mav1", "l1mvc2", "l1imv2", "l1imvc0", "l1imv1", "l1imvc2", "l1mav2"], "l1ref0": ["l2ref0", "l2ref2", "l1rel2", "l1re1", "l1rel1", "l1reference1", "l1rel0", "l1reference2", "l2rel0", "l2ref1", "l2rel2", "l2rel1", "l1reference0", "l1ref2", "l1re0", "l1re2"], "l1ref1": ["l0rel2", "l0ref0", "l0rel1", "l1refy", "l0rely", "l0ref1", "l1rel2", "l1rem2", "l0ref2", "l1rel1", "l1reference1", "l1rem0", "l1rel0", "l1reference2", "l1rely", "l0refy", "l1referencey", "l1reference0", "l1remy", "l1ref2", "l1rem1", "l0rel0"], "i8": ["pi8", "b08", "b8", "b6", " i08", "pi6", "pi08", "i08", "i6", "b4", "pi4", " i6"], "i4": [" i24", "i24", "ip24", "int24", " i44", "ip4", "int44", "ip44", "i44", "int4"], "ref": ["br", "id", "mb", "ro", "p", "all", "row", "result", "index", "out", "pointer", "table", "pos", "tab", "def", "req", "type", "ef", "conf", "buffer", "ap", "ob", "reference", "loc", "val", "null", "range", "Ref", "REF", "ret", "arg", "col", "f", "resp", "rep", "rel", "mem", "obj", "point", "map"], "mv": [" mvc", "rmV", "Mv", "MV", "rmv", "mV", "mvc", "Mav", "rmvc", " mV", "Mvc", "rmav", " mav", "mav"], "list": ["List", "parent", "id", "try", "out", "li", "set", "page", "reason", "can", "spec", "ind", "alist", "queue", "line", "back", "batch", "number", "test", "net", "count", "detail", "lists", "dict", "row", "result", "msg", "listed", "ist", "name", "alt", "range", "chain", "lvl", "l", "code", "LIST", "all", "record", "index", "lt", "header", "i", "info", "flat", "entry", "type", "call", "block", "error", "level", "comment", "err", "dl", "old", "low", "loop", "card", "map", "stack", "ul", "add", "status", "L", "item", "no", "stat", "commit", "table", "cont", "def", "local", "e", "pl", "array", "print", "null", "st", "feat", "base"], "C": ["CR", "S", "L", "c", "V", "JC", "CC", "DC", "N", "O", "P", "H", "W", "Cache", "CA", "CCC", "Counter", "LC", "CL", "CG", "M", "Q", "Chain", "T", "CU", "G", "CT", "F", "E", "CV", "K", "CS", "I", "D", "R", "CP"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,\n\n        unsigned size)\n\n{\n\n    GemState *s = (GemState *)opaque;\n\n    uint32_t readonly;\n\n\n\n    DB_PRINT(\"offset: 0x%04x write: 0x%08x \", offset, (unsigned)val);\n\n    offset >>= 2;\n\n\n\n    /* Squash bits which are read only in write value */\n\n    val &= ~(s->regs_ro[offset]);\n\n    /* Preserve (only) bits which are read only in register */\n\n    readonly = s->regs[offset];\n\n    readonly &= s->regs_ro[offset];\n\n\n\n    /* Squash bits which are write 1 to clear */\n\n    val &= ~(s->regs_w1c[offset] & val);\n\n\n\n    /* Copy register write to backing store */\n\n    s->regs[offset] = val | readonly;\n\n\n\n    /* Handle register write side effects */\n\n    switch (offset) {\n\n    case GEM_NWCTRL:\n\n        if (val & GEM_NWCTRL_TXSTART) {\n\n            gem_transmit(s);\n\n        }\n\n        if (!(val & GEM_NWCTRL_TXENA)) {\n\n            /* Reset to start of Q when transmit disabled. */\n\n            s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n        }\n\n        if (!(val & GEM_NWCTRL_RXENA)) {\n\n            /* Reset to start of Q when receive disabled. */\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        }\n\n        break;\n\n\n\n    case GEM_TXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_RXQBASE:\n\n        s->rx_desc_addr = val;\n\n        break;\n\n    case GEM_TXQBASE:\n\n        s->tx_desc_addr = val;\n\n        break;\n\n    case GEM_RXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IER:\n\n        s->regs[GEM_IMR] &= ~val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IDR:\n\n        s->regs[GEM_IMR] |= val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (val & GEM_PHYMNTNC_OP_W) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                gem_phy_write(s, reg_num, val);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    DB_PRINT(\"newval: 0x%08x\\n\", s->regs[offset]);\n\n}\n", "idx": 3521, "substitutes": {"opaque": ["obaques", " opque", "compaque", "bitaque", " opent", "iopent", "opacity", "compaques", "iopaques", "opent", " opaques", "opque", "iopaque", "compcache", "compque", "opaques", "obacity", "iopacity", "opcache", " opcache", "bitcache", "bitaques", "obent", "bitque", " opacity", "obaque"], "offset": ["mt", "template", "trace", "op", "height", "kh", "atomic", "window", "set", "needed", "adjusted", "off", "mounted", "locked", "buffer", "scroll", "reset", "os", "timeout", "prototype", "key", "shift", "count", "next", "row", "tab", "optional", "xy", "location", "ptr", "owner", "alt", "option", "range", "padding", "position", "length", "addr", "slot", "style", "slice", "seek", "ref", "index", "pointer", "memory", "secondary", "locking", "lag", "error", "attribute", "ctx", "priority", "empty", "address", "flag", "point", "linked", "len", "sp", "alloc", "value", "attr", "table", "bit", "pos", "start", "ta", "scope", "OFF", "origin", "reference", "Offset", "layout", "frequency", "o", "field", "primary", "peer", "t"], "val": ["cho", "p", "cal", "var", "x", "zero", "req", "pr", "conf", "buffer", "ver", "ind", "pre", "vol", "echo", "alpha", "hash", "ret", "fee", "Value", "mem", "serv", "test", "key", "count", "crit", "num", "valid", "rol", "it", "xy", "rot", "ival", "bal", "eval", "alt", "loc", "sel", "arg", "elt", "al", "rel", "values", "buf", "mix", "slot", "ref", "bool", "index", "pol", "vt", "res", "oval", "new", "type", "dev", "update", "block", "err", "ctx", "bin", "pt", "eq", "v", "empty", "fail", "ve", "len", "inter", "late", "pri", "data", "func", "prop", "status", "il", "value", "Val", "txt", "label", "util", "lib", "vals", "bit", "lit", "tx", "pos", "def", "VAL", "vec", "local", "role", "aval", "reg", "bl", "typ"], "size": [" length", "data", "value", "count", "slot", " flag", "type", "VAL", " pos", " whence", "length", " sig", "SIZE", "v", " slot", " len", "bytes", "fee", " count", "mem", "len", "Size"], "s": ["sys", "ls", "sis", "S", "stats", "ges", "is", "sv", "ss", "aunts", "es", "als", "session", "sl", "vs", "details", "xs", "ses", "comm", "set", "ds", "qs", "m", "params", "fs", "less", "gets", "store", "services", "ps", "its", "js", "ns", "bs", "sw", "conf", "ims", "bis", "ms", "ports", "sam", "ts", "cs", "spec", "as", "ies", "changes", "sm", "hs", "sts", "eps", "rs", "h", "bits", "gs", "sb", "ins", "ats", "os", "sq", "sol", "t", "rates", "states", "serv", "se", "ssl", "obj"], "readonly": ["readablemore", " readalways", "rideOnly", "edOnly", "readableOnly", " readstatus", "rideonly", "readablealways", "edonly", "readstatus", "readableenabled", "readeronly", "readflag", "readymore", "readOnly", "readyonly", "readyOnly", "readmore", " readwith", " readall", "edwith", "readerflag", "readystatus", " readmore", "readall", "readablestatus", "readerOnly", "Readflag", "Readall", " readflag", " readOnly", "readalways", " readenabled", "ridealways", "edall", "readenabled", "readwith", "rideenabled", "Readwith", "Readonly", "readableonly", "ReadOnly"], "phy_addr": ["phy____address", "phy_mac", "pha67adr", "pha_adr", "pha67url", "ph_address", "phy____addr", "phy_adr", "phy\u043daddress", "phy67addr", "phy___addr", "phone\u043daddress", "ph_int", "pha_edge", "phy67adr", "phone_loc", "phy\u043daddr", "phone_addr", "phy___int", "phy\u043dadr", "phy_url", "phone_mac", "phy67edge", "phy___address", "ph_adr", "pha67edge", "phy\u043dloc", "phone\u043daddr", "phy____int", "phy\u043dedge", "ph_addr", "phy_address", "pha_addr", "pha_url", "phy___adr", "phone\u043dloc", "phy\u043dmac", "phy_int", "phy____adr", "phy_loc", "pha67addr", "phone\u043dmac", "phy\u043durl", "phone_address", "phy_edge", "phy67url"], "reg_num": [" reg_number", "regjnum", "reg_number", "regjref", "regjno", "regjnumber", "reg_ref", "reg_no", " reg_no", " reg_ref"]}}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "void cpu_loop(CPUMIPSState *env)\n\n{\n\n    target_siginfo_t info;\n\n    int trapnr, ret;\n\n    unsigned int syscall_num;\n\n\n\n    for(;;) {\n\n        trapnr = cpu_mips_exec(env);\n\n        switch(trapnr) {\n\n        case EXCP_SYSCALL:\n\n            syscall_num = env->active_tc.gpr[2] - 4000;\n\n            env->active_tc.PC += 4;\n\n            if (syscall_num >= sizeof(mips_syscall_args)) {\n\n                ret = -ENOSYS;\n\n            } else {\n\n                int nb_args;\n\n                abi_ulong sp_reg;\n\n                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;\n\n\n\n                nb_args = mips_syscall_args[syscall_num];\n\n                sp_reg = env->active_tc.gpr[29];\n\n                switch (nb_args) {\n\n                /* these arguments are taken from the stack */\n\n                /* FIXME - what to do if get_user() fails? */\n\n                case 8: get_user_ual(arg8, sp_reg + 28);\n\n                case 7: get_user_ual(arg7, sp_reg + 24);\n\n                case 6: get_user_ual(arg6, sp_reg + 20);\n\n                case 5: get_user_ual(arg5, sp_reg + 16);\n\n                default:\n\n\n\n                ret = do_syscall(env, env->active_tc.gpr[2],\n\n                                 env->active_tc.gpr[4],\n\n                                 env->active_tc.gpr[5],\n\n                                 env->active_tc.gpr[6],\n\n                                 env->active_tc.gpr[7],\n\n                                 arg5, arg6/*, arg7, arg8*/);\n\n\n\n\n\n\n\n            if ((unsigned int)ret >= (unsigned int)(-1133)) {\n\n                env->active_tc.gpr[7] = 1; /* error flag */\n\n                ret = -ret;\n\n            } else {\n\n                env->active_tc.gpr[7] = 0; /* error flag */\n\n\n            env->active_tc.gpr[2] = ret;\n\n\n        case EXCP_TLBL:\n\n        case EXCP_TLBS:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            /* XXX: check env->error_code */\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->CP0_BadVAddr;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_CpU:\n\n        case EXCP_RI:\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = 0;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n\n\n\n        default:\n\n            //        error:\n\n            fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\",\n\n                    trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            abort();\n\n\n        process_pending_signals(env);\n\n", "idx": 3540, "substitutes": {"env": ["cp", "ext", "ent", "init", "ev", "window", "hw", "server", "app", "ner", "set", "email", "sc", "vp", "req", "ef", "man", "conf", "context", "buffer", "here", "manager", "queue", "ten", "console", "te", "enter", "estate", "serv", "era", "ec", "test", "operator", "vs", "erb", "viron", "cb", "environment", "rb", "esc", "shell", "end", "den", "setup", "ew", "uv", "enc", "er", "code", "gear", " environment", "buf", "addr", "editor", "ah", "vt", "engine", "ei", "eni", "entry", "cur", "network", "don", "dev", "sw", "en", "ctx", "db", "v", "ov", "client", "oe", "erd", "ve", "worker", "gov", "Environment", "doc", "et", "inv", "eb", "conn", "org", "erv", "txt", "ami", "em", "nv", "config", "desc", "w", "e", "ie", "cv", "event", "ee", "st", "t", "obj", "dn"], "info": ["data", "id", "try", "ii", "status", "list", "no", "information", " Info", "is", "Info", "ote", "stat", "py", "init", "inf", "result", "index", "details", "txt", "ci", "table", "i", "unknown", "tx", "lock", "notice", "entry", "def", "bar", "cache", "type", "zero", "history", "check", "tab", "xy", "t", "fi", "conf", "local", "http", "error", "metadata", "diff", "ti", "rec", "INFO", "rt", " inf", "now", "by", "help", "admin", "f", "about", "state", "obj", "base", "auth", "fo"], "trapnr": ["tapnos", "tripnr", "trapnos", "tipctr", " trapctr", "triNR", "trapctr", " trapnum", " trapbyter", "trinr", "tipnr", "tapctr", "tapNR", "tripNR", "tripnos", "tipbyter", "trapno", " trapnos", " trapno", "trino", " trapNR", "trapNR", "tapbyter", "trapbyter", "tapnr", "tipNR", "trapnum", "tapnum", "trinum", "tapno", "tripno"], "ret": ["mt", "usr", "RET", "try", "tmp", "mb", "ext", "out", "ne", "gt", "reply", "xt", "rm", "reset", "resp", "re", "mem", "back", "net", "result", "num", "ll", "it", "Ret", "ptr", "rev", "alt", "ter", "get", "nt", "arg", "tr", "elt", "jump", "alf", "jp", "rest", "addr", "nl", "all", "fun", "ref", "lt", "RT", "res", "fi", "err", "tn", "val", "rets", "det", "flag", "len", "cmd", "success", "status", "arr", "Return", "conn", "txt", "lib", "url", "fin", "lit", "ft", "over", "cont", "def", "desc", "rt", "pret", "nz", "t"], "syscall_num": ["syscall_no", "syscallablen", "syscall_n", "sysall_NUM", "syscall2num", "syscall_number", "sysall_num", "syscall2n", "syscall2no", "syscall1num", "sysall_number", "syscall2number", "syscallablenum", "syscall_NUM", "sysall_no", "syscall1nr", "syscall_Num", "syscall1no", "syscallablenumber", "syscall_nr", "syscall1Num", "syscallableNUM", "sysall_n", "sysall_Num", "sysall_nr"], "nb_args": ["bj_changes", "nbwants", "nbwvals", "np__arg", "nb\u0648args", "nb_changes", "bj_arr", "nb_arg", "np__args", "nie_pres", "bj_args", "nbwargs", "nb_vals", "nbwpres", "nb__arg", "np_ants", "nb_pres", "nb\u0648tags", "nb__ants", "nb_gs", "np_arg", "np__ants", "nb\u0648changes", "bj_tags", "np_args", "nb_arr", "nb__gs", "nb_ants", "nie_vals", "nie_args", "np__gs", "nie_ants", "nb\u0648arr", "nb__args", "np_gs", "nb_tags"], "sp_reg": ["sp64ref", "sp_rand", " sp_rm", "sp1num", "sp_addr", "sp5rand", "sp32admin", " sp_num", "sp_ref", "sp_register", "sp_pre", "sp_prom", "sp_mem", "sp2Reg", "splreg", "spladmin", "snap_Reg", "sp64reg", "snapladmin", "snaplregister", "sp2reg", " sp_ref", "sp55reg", "sp1reg", "sp_Reg", "snaplReg", "sp55ref", "sp_admin", "sp5conn", "sp__reg", " sp_REG", "sp_conn", "sp_num", "sp32Reg", " sp_pre", " sp_rand", "sp2num", " sp_mem", "snap_register", "sp64rand", "sp64register", " sp_conn", " sp_addr", "sp1Reg", "snap_admin", "sp__rm", " sp_prom", "sp5ref", "sp32reg", "sp32register", "sp_rm", "sp5register", "splregister", "sp_REG", "sp5REG", "sp__addr", "sp5reg", "sp55prom", "sp1mem", "splReg", "snap_reg", " sp_register", "sp55pre", "sp2mem", "sp__REG", "snaplreg", " sp_Reg"]}}
{"project": "FFmpeg", "commit_id": "066ad0926a53ea6ee9d5cb3e348160a881145e73", "target": 1, "func": "static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n", "idx": 3551, "substitutes": {"s": ["sys", "ls", "d", "S", "q", "stats", "c", "is", "sv", "ss", "p", "es", "n", "comm", "ds", "qs", "b", "fs", "sc", "aws", "its", "ex", "js", "ns", "bs", "conf", "ms", "as", "ts", "cs", "hs", "sts", "v", "rs", "h", "gs", "f", "ats", "sb", "ins", "sq", "os", "t", "a", "acs"], "stream_index": ["stream_no", " stream_data", " stream_ind", "stream2Index", "channel_Index", "streamityindex", " stream_point", "streamitypoint", "streamityno", "stream2index", " stream_Index", "channel_index", "channel_ind", "channel_id", "streamityind", "stream_id", "stream_data", " stream_no", "streamityIndex", "stream_point", "streamitydata", "stream2id", "stream_ind", "stream2ind", "stream_Index"], "timestamp": ["exteline", "transformesta", "Timeline", "extestamp", "timetime", "timension", "extest", "transformest", "imetime", "imesta", "timesta", "Timetime", "timest", "timeension", "imest", "transformetime", "timeeline", "transformestamp", "Timestamp", "timeestamp", "imestamp", "Timesta", "Timest", "timeline", "Timension", "extension", "timeest"], "flags": ["fp", "frames", "status", "mask", "style", "options", "Flags", "fs", "fields", " fmt", " flag", "ps", " whence", "tags", "lag", "cf", "fps", "ms", "ts", " options", "ags", "bits", " compression", "args", "flag", "FLAG", "Flag", "fd"], "tmv": ["ttvt", "temvs", "htmvs", "tmapter", "mtl", "tmm", "mxvt", "temav", "mtm", "tkf", "gmvs", "tmj", "tcj", "mtj", "temx", "htmm", "mxvs", "mtv", "mtvs", "mtapter", "html", "tkv", "ttav", "ttv", "tmf", "tmvs", "mxv", "htmapter", "tml", "ttvs", "tmav", "temv", "tcv", "tcl", "tomq", "tmq", "tmx", "htmx", "htmav", "tomapter", "mxav", "gmav", "tkj", "htmv", "gmvt", "htmj", "temm", "htmf", "tmvt", "tomv", "temj", "tcvs", "mtav", "mtq", "htmq", "tomm", "tkm", "mtx", "temf", "gmv"], "pos": ["doc", "pres", "nos", "add", "l", "po", "size", "tmp", "pro", "pc", "port", " position", "p", "limit", "neg", "index", "pi", "POS", "pointer", "Position", "res", "us", "off", "start", "at", "ps", "tz", "bs", "length", "trans", "rot", "oss", "ts", "spec", " Pos", "pt", "Pos", "offset", "loc", "val", "sp", "o", "estamp", "position", "os", "pid", "t", "pose", "len", "top"]}}
{"project": "qemu", "commit_id": "58d479786b11a7e982419c1e0905b8490ef9a787", "target": 1, "func": "static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;", "idx": 3555, "substitutes": {"opaque": ["Opus", "Opaco", "opaco", "popaco", "popaques", "popaque", "boque", " opque", "oaque", "Opque", "Opaque", "bous", "boacity", "oacity", "oaques", "opacity", " opus", "opque", "popacity", "boaque", "opaques", "Opacity", "opus", "Opaques", "oaco", " opacity"], "addr": ["alloc", "id", "add", "host", " ax", "Address", " cur", " ptr", "to", "attr", "r", " ip", "align", "res", "tx", "pos", " loc", "at", "ack", "pad", "att", " add", " a", "ptr", "name", "ctx", "alias", "adr", "ag", "loc", "offset", "ar", " aid", "rs", "dr", "on", "address", " address", "ad", "arg", " err", " pad", "prefix", "obj", "a", " mac"], "val": ["data", " value", " aval", "test", " ty", " serv", "value", "buf", " arg", " upd", "Val", "util", " lac", " vel", "vt", "out", " al", "vals", "bit", " resp", "x", "lit", " msg", "tx", "valid", " update", "au", " tx", " fut", "VAL", " eval", "dev", "local", " x", "buffer", "ctx", " ret", " v", "eval", " valid", " el", " inval", "v", " seq", "vol", " amount", "sel", " needle", "Value", "mem", "serv"], "size": ["l", "c", "count", "z", "n", "set", "align", "m", "sum", "num", "type", "cap", "SIZE", "w", "name", "len", "loc", "offset", "ize", "v", "address", "h", "args", "mem", "length", "Size", "sp"], "s": ["sis", "ls", "S", "j", "c", "is", "ss", "p", "soc", "n", "sl", "ses", "ess", "sa", "ds", "i", "less", "ps", "ns", "state", "ts", "sm", "hs", "sts", "rs", "o", "gs", "sb", "sq", "sol", "os", "t", "a", "ssl", "sp"]}}
{"project": "FFmpeg", "commit_id": "3d5822d9cf07d08bce82903e4715658f46b01b5c", "target": 1, "func": "static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,\n\n                                  Jpeg2000CodingStyle *codsty,\n\n                                  Jpeg2000ResLevel *rlevel, int precno,\n\n                                  int layno, uint8_t *expn, int numgbits)\n\n{\n\n    int bandno, cblkno, ret, nb_code_blocks;\n\n    int cwsno;\n\n\n\n    if (layno < rlevel->band[0].prec[precno].decoded_layers)\n\n        return 0;\n\n    rlevel->band[0].prec[precno].decoded_layers = layno + 1;\n\n\n\n    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {\n\n        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {\n\n            s->g = tile->tile_part[++(*tp_index)].tpg;\n\n        }\n\n    }\n\n\n\n    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)\n\n        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);\n\n\n\n    if (!(ret = get_bits(s, 1))) {\n\n        jpeg2000_flush(s);\n\n        return 0;\n\n    } else if (ret < 0)\n\n        return ret;\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        if (band->coord[0][0] == band->coord[0][1] ||\n\n            band->coord[1][0] == band->coord[1][1])\n\n            continue;\n\n        nb_code_blocks =  prec->nb_codeblocks_height *\n\n                          prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            int incl, newpasses, llen;\n\n\n\n            if (cblk->npasses)\n\n                incl = get_bits(s, 1);\n\n            else\n\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n\n            if (!incl)\n\n                continue;\n\n            else if (incl < 0)\n\n                return incl;\n\n\n\n            if (!cblk->npasses) {\n\n                int v = expn[bandno] + numgbits - 1 -\n\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n\n                if (v < 0 || v > 30) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"nonzerobits %d invalid or unsupported\\n\", v);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                cblk->nonzerobits = v;\n\n            }\n\n            if ((newpasses = getnpasses(s)) < 0)\n\n                return newpasses;\n\n            av_assert2(newpasses > 0);\n\n            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {\n\n                avpriv_request_sample(s->avctx, \"Too many passes\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((llen = getlblockinc(s)) < 0)\n\n                return llen;\n\n            if (cblk->lblock + llen + av_log2(newpasses) > 16) {\n\n                avpriv_request_sample(s->avctx,\n\n                                      \"Block with length beyond 16 bits\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            cblk->lblock += llen;\n\n\n\n            cblk->nb_lengthinc = 0;\n\n            cblk->nb_terminationsinc = 0;\n\n            do {\n\n                int newpasses1 = 0;\n\n\n\n                while (newpasses1 < newpasses) {\n\n                    newpasses1 ++;\n\n                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {\n\n                        cblk->nb_terminationsinc ++;\n\n                        break;\n\n                    }\n\n                }\n\n\n\n                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)\n\n                    return ret;\n\n                if (ret > sizeof(cblk->data)) {\n\n                    avpriv_request_sample(s->avctx,\n\n                                        \"Block with lengthinc greater than %\"SIZE_SPECIFIER\"\",\n\n                                        sizeof(cblk->data));\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                cblk->lengthinc[cblk->nb_lengthinc++] = ret;\n\n                cblk->npasses  += newpasses1;\n\n                newpasses -= newpasses1;\n\n            } while(newpasses);\n\n        }\n\n    }\n\n    jpeg2000_flush(s);\n\n\n\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n\n            bytestream2_skip(&s->g, 2);\n\n        else\n\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found. instead %X\\n\", bytestream2_peek_be32(&s->g));\n\n    }\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {\n\n                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]\n\n                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4\n\n                ) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                        \"Block length %\"PRIu16\" or lengthinc %d is too large, left %d\\n\",\n\n                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);\n\n                cblk->length   += cblk->lengthinc[cwsno];\n\n                cblk->lengthinc[cwsno] = 0;\n\n                if (cblk->nb_terminationsinc) {\n\n                    cblk->nb_terminationsinc--;\n\n                    cblk->nb_terminations++;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data_start[cblk->nb_terminations] = cblk->length;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 3561, "substitutes": {"s": ["sys", "ls", "d", "S", "j", "stats", "c", "sg", "is", "sv", "ss", "p", "es", "source", "g", "n", "session", "sl", "sort", "sim", "settings", "service", "comm", "set", "ds", "m", "i", "b", "space", "fs", "less", "store", "sc", "services", "request", "ps", "its", "js", "ns", "sw", "conf", "ims", "w", "e", "sam", "bis", "span", "cs", "ts", "spec", "changes", "sts", "v", "rs", "in", "h", "src", "gs", "f", "sb", "sq", "os", "t", "socket", "serv", "se", "ssl", "self"], "tile": ["league", "template", "piece", "TI", "detail", "ile", "layer", "chip", "slice", "tif", "tip", "google", "nil", "plane", "fit", "texture", "vt", "table", "header", "phy", "pixel", "grid", "Tile", "tf", "title", "tp", "cell", "file", "metadata", "tc", "ti", "complete", "tle", "lay", "frame", "target", "skill", "sel", "te", "unit", "mate", "t", "ite", "map", "feature"], "tp_index": ["txt_index", "np_index", "tp2number", "txt67amount", "npaxymax", "tp_number", "npaxynumber", "tpaxyIndex", "tpaxymax", "tpptamount", "tpptnode", "tpaxyindex", "tp_ind", "tp_node", "tpptinfo", "tp67index", "tpznum", "tp67node", "np_Index", "tp_num", "txt_node", "tp67amount", "np_number", "txt_info", "tpzindex", "npaxyIndex", "tpznumber", "tp2index", "TP_index", "tp_info", "tpptindex", "tp67info", "tpzind", "tp_Index", "TP_num", "tpaxynumber", "txt67index", "np_max", "tp2ind", "txt_amount", "tp_amount", "tp2num", "tp_max", "TP_ind", "npaxyindex", "txt67info", "txt67node", "TP_number"], "codsty": ["Codsty", "codestyles", " codestyle", "codestyle", "Codestyles", "Codstyle", "odstyle", " codestyles", " codstyle", "Codestyle", "odsty", "odestyles", "odestyle", "codstyle"], "rlevel": ["nrscope", "rscope", "srlevels", "vrvel", "nrlevel", "hlevel", "nrserver", "rwindow", "rbuffer", "rtlevel", "hlvl", "lvel", "llevels", "hvel", "vrlevels", "hlayer", " rscope", "llvl", "vrwall", " rwindow", "srlevel", "rtserver", "rdwindow", "rlayer", "vrlimit", "rrwindow", "rdlvl", "rserver", "clvl", " rserver", "nrbuffer", " rlvl", "rtscope", "srlimit", "clevel", "rrlvl", " rbuffer", "hlimit", "srwall", "rwall", "rlimit", " rlevels", "rtbuffer", "climit", "vrlevel", " rwall", " rlimit", "rdlevel", " rlayer", "llevel", "vrlvl", "rvel", "hlevels", "rlvl", "rlevels", "clayer", "rrlevel"], "precno": ["prefno", "prefceno", "prercmajor", "PrefNo", "prekeno", "prercna", "prercorno", "notepmajor", "prepunit", "prcstable", "precNO", "prefna", "precstable", "notecorno", "PrecNo", "notecno", "Prefeno", "prekyes", "precNo", "PrecNO", "noteporno", "predno", "prercunit", "prescno", "prikNo", "prfna", "prevno", "prepno", "prikno", "precmajor", "prepmajor", "priceno", "prefcNO", "notecunit", "PrefNO", "pricno", "pricyes", "precorno", "pricNo", "precunit", "prelcstable", "Prefno", "prefNo", "prercno", "prescunit", "prescmajor", "prefeno", "prikyes", "prelcna", "predeno", "Preceno", "notepno", "prelcno", "prekno", "prefcyes", "prercstable", "predNo", "notecmajor", "preporno", "precyes", "prfno", "prcna", "predyes", "prfstable", "prefstable", "notepunit", "prcno", "prekNo", "preceno", "preveno", "Precno", "prevNO", "prescorno", "prefcNo", "precna", "prikeno", "prevNo", "prefcno", "prefNO"], "layno": ["laynum", "laynumber", "bandNO", "layernum", "ayno", "layoutNO", "Laybo", "layoutnumber", "laynone", "bandko", " laynum", "layko", "aybo", "playnumber", "layNO", "bandnone", "bandbo", " layNO", "layerno", "layerko", "bandnum", "laybo", "rownumber", "aynone", "playko", "Laynone", "layoutno", "Layno", "rowko", "playNO", "rowNO", "layerNO", " layko", "playno", "layoutko", "rowno"], "expn": ["xpnum", "xpn", "defnum", "expN", "expnum", "respno", "respnum", "defn", "defN", "xpno", "xpN", "respN", "expno", "respn", "defno"], "numgbits": ["umbergcbits", "numgmits", "numGbytes", "umbergits", "numgmbits", "numgmbytes", "numgcbytes", "numgits", "numgbytes", "umbergitems", "numGitems", "umbergbytes", "numGits", "numgitems", "umbergcitems", "numgmitems", "numgcbits", "numgcitems", "umbergcbytes", "numGbits", "numgcits", "umbergcits", "umbergbits"], "bandno": ["BandNo", "brandwa", "bandNO", " bandna", "bandNo", " bandeno", " banddo", "batchko", "bandid", "diskne", " bandNO", "bandko", "layid", "layko", "bandgo", "boarddo", "brandeno", "batchno", "layeno", " bandne", "BandNO", "broadname", "bandeno", "diskgo", "diskko", "broadne", "brandno", " bandwa", "roadna", "laygo", "boardno", "bandnumber", "roadno", "broadno", "boardwa", "Bandeno", "bandne", "bandname", "Bandno", "banddo", "batchid", "diskname", "bandna", "layNo", "diskno", "diskid", "branddo", "bandwa", "brandnumber", "roadnumber", " bandnumber", " bandNo", "roadeno", "layNO", " bandname", "batchgo", "brandna"], "cblkno": ["cbrknumber", "cblakno", "cblknos", "cbrknos", "cbrkidstro", "cblekno", "cblkeeno", "cblklno", "cbrkidno", "cbrkidnumber", "cblckano", "cblunkano", "cbleknum", "cblknumber", "cblklstro", "cBlkNo", "cclkeno", "cblkname", "cblkidnumber", "cblikstro", "cblckno", "cblcknum", "cblunkNo", "cclakno", "cBlkNO", "cblknum", "cbliknos", "cbrkstro", "cbrkno", "cblkideno", "cBlkno", "cblckNO", "cblikno", "cbrkidnos", "cblkeNo", "cBlknum", "cblkidno", "cblekNo", "cblklnumber", "cblkano", "cbljNo", "cblkeno", "cblkidnum", "cbljano", "cblakname", "cblkNo", "cblkidname", "cblckNo", "cblkidstro", "cbljno", "cblunkno", "cclakname", "cclkname", "cblkenum", "cblunkeno", "cblakeno", "cclakeno", "cbliknumber", "cclkno", "cblklnos", "cblkidNo", "cblkstro", "cblckeno", "cblkidnos", "cblekNO", "cbljeno", "cblkNO"], "ret": ["success", "mt", "RET", "try", "et", "net", "status", "arr", "dt", "format", "ext", "nl", "fun", "result", "bool", "txt", "ref", "lt", "out", "res", "fin", "ft", "red", "gt", "ll", "def", "it", "Ret", "final", "mel", "got", "gc", "rt", "alt", "reg", "val", "rm", "rets", "pret", "nt", "fail", "nz", "det", "rem", "reset", "arg", "resp", "flag", "elt", "t", "re", "obj", "back", "len", "pert"], "nb_code_blocks": ["nb_Code_ops", "nb_code67ops", "nb_codewcells", "nb_co_block", "nb_code_block", "nb_codewunits", "nb_codewblocks", "nb_co_units", "nb_code_codes", "nb_code_ops", "nb_co_blocks", "nb_code2codes", "nb_codewblock", "nb_Code_Blocks", "nb_code_units", "nb_line2blocks", "nb_co_cells", "nb_code2lines", "nb_code2blocks", "nb_codeblockblocks", "nb_codeblocklines", "nb_line2lines", "nb_code_lines", "nb_Code_blocks", "nb_code_Blocks", "nb_line2codes", "nb_code2block", "nb_code67Blocks", "nb_code2cells", "nb_line_blocks", "nb_line_codes", "nb_code_cells", "nb_line_lines", "nb_code2units", "nb_codeblockcodes", "nb_code67blocks"], "cwsno": ["cbsna", " crsno", "crsno", " crsna", "cwtno", "crsna", " cwsna", " crsNo", "cbsNo", "cwtna", "crsNo", "cbsno", " cwsNo", "cwsNo", "cwtNo", "cwsna"], "band": ["bound", "rad", "beam", "window", "node", "raid", "iband", "ber", "amber", "version", "disk", "cast", "bo", " bands", "group", "channel", "binary", "line", "batch", "br", "comb", "bor", "bank", "bd", "pipe", "fine", "box", "filter", "bolt", "tag", "bright", "co", "bart", "range", "well", "frame", "album", "brand", "chain", "byte", "word", "broad", "power", "bed", "pixel", "part", "block", "lag", "level", "plug", " limb", " Band", "brid", "bin", "db", "low", "pair", "flag", "ble", "cand", "work", " brick", "BW", "Band", "mode", "bands", "bit", "be", "b", "ring", "plugin", "road", "bb", "dom", "flash", "command", "station", "array", "bridge", "field", "stage", "module", "feature"], "prec": ["preac", "Preco", "Pref", "prep", "pec", "Prepc", " prev", "prp", "PREb", "metpc", " prepc", "prov", " pref", "preco", "preci", "peco", "calco", "pech", "calpc", "prc", "metco", "Prev", "porci", "pef", "prech", "preuc", "porc", "blef", "procs", "calf", "rec", "Preac", "PREac", "prek", "PREc", "Preb", "prf", "Prek", "prip", "metf", "pref", "rech", "blek", "ref", " preuc", "Preuc", "priv", " prech", "porp", "precs", "calc", " preb", "metc", "prev", "PREk", "prif", " preco", "proc", "prepc", "prici", "PREuc", "PREf", "preb", "blec", "blepc", "prics", "porf", "prof", " prek", "reco", "PREv", " preac", "prci", "pric", "Precs", "Prec"], "cblk": ["lblk", "lbrkt", "cblockks", "cbreek", "cbrk", "cclv", "cclkt", "cblkt", "lbrv", "cblks", "cblockkt", "cclks", " cblek", "cblockv", "cblv", "cbrks", "lblv", "cblck", "cbrck", "lbrks", "lbrk", "cblek", "cbrekt", "cbrv", "cclk", "cbrkt", " cblkt", "cbrek", "lblkt", "cbreck", " cblck", "lblks", "cblockk"], "incl": ["inbytes", "Inbytes", "In_", " inbytes", "in_", " in8", "outbytes", "in8", "out8", " in_", "In8", "out_"]}}
{"project": "qemu", "commit_id": "bba4e1b591531c087fce4ae501dc1ca299d8fb42", "target": 1, "func": "static void curses_refresh(DisplayChangeListener *dcl)\n\n{\n\n    int chr, nextchr, keysym, keycode, keycode_alt;\n\n\n\n    curses_winch_check();\n\n\n\n    if (invalidate) {\n\n        clear();\n\n        refresh();\n\n        curses_calc_pad();\n\n        graphic_hw_invalidate(NULL);\n\n        invalidate = 0;\n\n    }\n\n\n\n    graphic_hw_text_update(NULL, screen);\n\n\n\n    nextchr = ERR;\n\n    while (1) {\n\n        /* while there are any pending key strokes to process */\n\n        if (nextchr == ERR)\n\n            chr = getch();\n\n        else {\n\n            chr = nextchr;\n\n            nextchr = ERR;\n\n        }\n\n\n\n        if (chr == ERR)\n\n            break;\n\n\n\n#ifdef KEY_RESIZE\n\n        /* this shouldn't occur when we use a custom SIGWINCH handler */\n\n        if (chr == KEY_RESIZE) {\n\n            clear();\n\n            refresh();\n\n            curses_calc_pad();\n\n            curses_update(dcl, 0, 0, width, height);\n\n            continue;\n\n        }\n\n#endif\n\n\n\n        keycode = curses2keycode[chr];\n\n        keycode_alt = 0;\n\n\n\n        /* alt key */\n\n        if (keycode == 1) {\n\n            nextchr = getch();\n\n\n\n            if (nextchr != ERR) {\n\n                chr = nextchr;\n\n                keycode_alt = ALT;\n\n                keycode = curses2keycode[nextchr];\n\n                nextchr = ERR;\n\n\n\n                if (keycode != -1) {\n\n                    keycode |= ALT;\n\n\n\n                    /* process keys reserved for qemu */\n\n                    if (keycode >= QEMU_KEY_CONSOLE0 &&\n\n                            keycode < QEMU_KEY_CONSOLE0 + 9) {\n\n                        erase();\n\n                        wnoutrefresh(stdscr);\n\n                        console_select(keycode - QEMU_KEY_CONSOLE0);\n\n\n\n                        invalidate = 1;\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (kbd_layout) {\n\n            keysym = -1;\n\n            if (chr < CURSES_KEYS)\n\n                keysym = curses2keysym[chr];\n\n\n\n            if (keysym == -1) {\n\n                if (chr < ' ') {\n\n                    keysym = chr + '@';\n\n                    if (keysym >= 'A' && keysym <= 'Z')\n\n                        keysym += 'a' - 'A';\n\n                    keysym |= KEYSYM_CNTRL;\n\n                } else\n\n                    keysym = chr;\n\n            }\n\n\n\n            keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);\n\n            if (keycode == 0)\n\n                continue;\n\n\n\n            keycode |= (keysym & ~KEYSYM_MASK) >> 16;\n\n            keycode |= keycode_alt;\n\n        }\n\n\n\n        if (keycode == -1)\n\n            continue;\n\n\n\n        if (qemu_console_is_graphic(NULL)) {\n\n            /* since terminals don't know about key press and release\n\n             * events, we need to emit both for each key received */\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n\n            qemu_input_event_send_key_delay(0);\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n\n            qemu_input_event_send_key_delay(0);\n\n\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n        } else {\n\n            keysym = curses2qemu[chr];\n\n            if (keysym == -1)\n\n                keysym = chr;\n\n\n\n            kbd_put_keysym(keysym);\n\n        }\n\n    }\n\n}\n", "idx": 3582, "substitutes": {"dcl": ["dbCL", " dwl", "sdwl", "dCL", "rscl", "dbcl", "sdCl", "dwl", "dbwl", "rCL", "sdcl", " dscl", "dsscl", "rCl", "dCl", "dbCl", "dscl", "sdCL", "dsCL", " dCl", "rcl", " dCL", "dsCl"], "chr": ["chrt", "chedr", "chnR", "echrar", "chnrar", "chear", " chrt", "chrg", "chers", "chrc", "echrs", "chern", "chedrl", "Chrc", "chsr", "anchrt", "achrc", "shr", "cherc", "cherr", " chrc", "cherrc", "ichR", " chry", "chnr", "achc", "echg", "echrl", "thrb", "chg", "Chsr", "schar", "achr", "schR", "schbr", "echtr", "shR", "actsr", "scherr", " chrn", "echry", "chrb", "acherr", "actr", "cheg", "chedR", "Chr", "ichg", "chec", "schrc", "shry", " chrg", "ichrn", "cher", "chR", "icherr", " chR", "chnrl", "ichrg", "chery", "anchrc", "achtr", "anchr", "echrb", "chedrar", "achbr", "chrs", "echmr", "echr", "chn", " cher", "achar", "echrc", "shrs", "chert", "chbr", "cheer", "chmr", "chertr", "chermr", "echc", "cherrb", "achrt", "ichrc", "chrn", "chry", "achmr", "schr", "thR", " chc", "chrar", "achn", "icher", "thr", "schrt", "thrc", "Chrb", "ichr", "actrb", "achsr", "actn", "anchar", "chc", "echR", "schrg", "cheR", "achrb", "ichbr", "ChR", "ichar", "achry", "Chn", "chtr", "cherar", "chrl", "echar"], "nextchr": ["nextcherar", "prechrc", "newchn", "nextChp", "firstechr", "maxcharin", "nextcorrar", "nextechrs", "nextthrt", "trychdr", "nextyrg", "nextchdr", "nextcheer", " nextchp", "nextcurar", " nextcher", "nextcurrb", "nextchedrs", "nextachdr", "prechr", " nextechrb", "nextyrin", "nextachry", "nextcharg", "maxchrin", "nextChry", "trychro", "prechedrt", "nextcurry", "trychedr", "nextchrt", "nextyr", " nextcurar", "nextchedrc", "newthp", "nextchedry", "nextChrs", "nextchildrt", "trychr", "nextechrb", "defaultchR", "nextchedrt", "newthn", "nextachr", "nextthrb", "nextechar", "nextyar", "nextcurp", "nextachR", "firstchry", "newthr", " nextcorrb", "nextcharr", "firstchp", "nextechr", " nextchry", " nextechp", " nextcorr", " nextcurry", "prechrb", "nextchro", "newchr", "nextchrs", "nextchildrc", "maxcharg", "nextcherb", "nextcharry", "nextchrin", "trychedrs", "nextcurl", "nextchedR", "defaultchedR", "firstechrb", "nextchedrb", "nextChl", "nextcorR", " nextcorR", "trycheddr", "nextcorr", "firstchrb", "nextcharR", "nextcorrb", "nextcharrar", "nextchn", "nextthp", "nextcheR", "nextcheddr", "nextechrin", "defaultchry", "prechedr", "maxchr", "nextChdr", "nextcurr", "nextthR", "nextachn", "prechedrc", "nextChn", "nextechry", "firstechp", "prechedrb", "maxchar", "nextchery", "nextechro", "nextchildrb", "defaultchrar", "nextechrg", " nextchar", " nextcorer", "trychedro", "nextChr", "nextthr", "nextchar", "nextchear", "nextCher", "defaultchedry", "nextthrc", "nextchR", "nextchp", "nextchrg", "newchp", " nextchl", "newchdr", "nextcher", "nextthrar", " nextchR", "nextchl", "nextechl", "nextcorer", "nextchrar", "defaultchedrar", "nextChro", " nextchdr", "nextchildr", " nextechr", "nextcharin", " nextcordr", "nextachrar", "defaultchr", "trychrs", " nextcorrar", " nextchrar", "nextchedro", "nextcurdr", "nextchep", "firstechry", "defaultchedr", "nextchedr", "nextchedrar", " nextcurdr", "maxchrg", "nextthn", "nextachp", " nextechl", "nextchrc", "maxchaar", "nextChar", "nextchrb", "nextChrb", "nextchry", "nextcordr", "nextechp", " nextcurr", "firstchr", "nextechdr", "nextthdr", "nextchaar", "newthdr", "prechrt", " nextchrb"], "keysym": [" keysmem", "ksym", "handsys", "valsym", "valsyn", " keysem", "codesym", "lightsyn", " keysymm", "kesyn", "codesymm", "lightsym", "letsyn", "handsrm", "keysesm", "handsyr", "valsem", " keysy", "typesm", "letsyr", "keysem", "namessym", "keysyr", "valuesesm", "keyssym", "keysyp", "typesyn", "namesym", "lightsymm", "letssym", "handsym", "keysrm", "ksymm", "ksyn", "namesyn", "kesyp", "valsymm", "stylessym", "uesyp", "ksm", "stylesym", "valuessym", "handsymm", "lightsys", "typesyp", "handsyn", "rotssym", "kssym", "ksrm", "uessym", "codesyr", " keyssym", "uesymm", "codesyn", "keysys", "lightsyr", "kessym", "kesymm", "keysyn", "keysy", "uesym", "kesrm", "keysm", " keysyn", "handssym", "openssym", "typesym", "ksmem", "keysmem", "opensesm", "rotsyn", " keysyp", "ksyp", "rotsyr", "kesym", "letsym", "handsyp", "rotsym", "kesesm", "opensym", "valuesyn", "codesys", "stylesyn", "opensyn", "kesy", "keysymm", "namesyr", "codesem", "kesmem", "ksy", "stylesyp", "valuesym", "handsm", "kesyr", "typessym"], "keycode": ["keycoe", "echocoe", " keystroke", "switchcod", "modeCode", "condcoded", " keycoe", "condfunction", "echoCode", " keycache", "lockcod", "lockcase", "keycase", "keycycle", "keycoded", "Keychange", "firecache", "eycase", "keyno", "keyCode", "lockcoe", "KeyCode", "eycode", "condcode", "charcode", "featurecycle", " keycod", "charchange", "charCode", "switchcase", "versioncod", "firecycle", "versioncode", " keycoded", "Keystroke", "charcase", "featurecache", "modestroke", "fireno", "powercoe", "eyCode", "keystroke", "eycod", "keychange", "leaderfunction", "powercode", "featureno", "leadercoded", " keycycle", "Keycod", "echocode", " keyfunction", " keychange", "powercase", "versionchange", "keycod", "switchCode", "leadercode", "modecode", "modecase", "Keycoe", "featurecode", "Keycase", "eychange", "Keycode", "lockcode", "keyfunction", " keyCode", "versioncase", " keycase", "switchcode", "modecod", "charcod", "keycache", "firecode", " keyno", "powercod", "echocase"], "keycode_alt": ["keycode2offset", "keycodes2rel", "keycode2ALT", "keycode__ALT", "keycoded_ret", "keycode__alt", "keycode__rel", "keycodes2extra", "keycode2alt", "keycycle_alt", "keycode_alter", "keycoded_alt", "keycycle_Alt", "keycodes2ALT", "keycodes_rel", "keycode_extra", "keycode2alter", "keycodes_extra", "keycycle_offset", "keycode2extra", "keycode__offset", "keycodes_ALT", "keycode_Alt", "keycode_offset", "keycode_rel", "keycodes2alt", "keycodes_alt", "keycode2rel", "keycode_ALT", "keycode2Alt", "keycode2ret", "keycoded_alter", "keycycle_ALT", "keycoded_ALT", "keycode_ret", "keycode__Alt", "keycode__extra"]}}
{"project": "FFmpeg", "commit_id": "b84a7330af41cec93384bf59ed68c67b09d105cd", "target": 1, "func": "static int64_t read_ts(char **line, int *duration)\n\n{\n\n    int64_t start, end;\n\n\n\n    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {\n\n        *line += strcspn(*line, \"\\\"\") + 1;\n\n        *duration = end - start;\n\n        return start;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n", "idx": 3596, "substitutes": {"line": ["user", "le", "l", "list", "try", "word", "code", "phrase", "column", "handle", "eline", "Line", "limit", "text", "port", "pipe", "source", "row", "sample", "pointer", "lo", "sequence", "path", "url", "out", "link", "page", "lf", "liner", "lock", "valid", "time", "cell", "file", "block", "comment", "lane", "buffer", "ln", "lines", "offset", "on", "frame", "sp", "lin", "position", "ine", "LINE", "online", "point", "base", "se", "length", "chain"], "duration": ["total", "d", "number", "period", "document", "uration", "distance", "delay", "seconds", "Duration", "resolution", "window", "relative", "sequence", "minimum", "portion", "volume", "amount", "during", "trip", "time", "dimension", "future", "video", "since", "repeat", "until", "frequency", "event", "days", "position", "unit", "date", "timeout", "direction", "length", "recorded"], "start": ["data", "id", "number", "key", "try", "size", "match", "value", "rest", "step", "starting", "next", "source", "p", "before", "seek", "init", "from", "window", "import", "index", "result", "open", "ish", "set", "i", "space", "wind", "part", "load", "pos", "new", "check", "entry", "info", "it", "store", "time", "stop", "state", "t", "trans", "error", "name", "origin", "first", "len", "Start", "str", "get", "offset", "v", "range", "val", "position", "date", "st", "begin", "started", "point", "art", "length", "sp"], "end": ["END", "id", " End", "ff", "add", "size", "rest", "nd", "port", "ent", "after", "eff", "ish", "ue", "send", "ending", "hend", "fin", "it", "pad", "ended", "time", "stop", "e", "en", "ort", "End", "len", "dest", "until", "ment", "offset", "last", "v", "est", "max", "st", "begin", "length", "ENDED"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598, "substitutes": {"klass": [" kazz", "ikkls", "ekazz", "tkls", "Klass", "kazz", "ikclass", "Klasses", "eklass", "tklass", "kls", "ktls", "ktlc", "klc", "iklass", "ikkclass", "ikls", "klasses", "ekls", "klf", "ikkazz", " klc", " klasses", "ikklass", "kclass", " klf", "tklasses", "tklf", " kclass", " kls", "ekclass", "ktlass", "ktclass", "Kls", "iklc", "Klf"], "data": ["d", "Data", "DATA", "result", "r", "dat", "res", "m", "def", " sd", "dev", "mu", "rew", "w", "name", " d", "rec", " DATA", "bin", "v", "ata", "o", "di", " Data", "raw", "json"], "k": ["ko", "ka", "q", "work", "key", "ki", "tk", "km", "ke", "kh", "p", "g", "n", "dk", "uk", "kj", "kk", "kind", "m", "i", "ijk", "kt", "u", "sk", "unk", "ku", "ok", "ark", "it", "ack", "kr", "kw", "mk", "ikk", "spec", "aka", "kn", "ks", "kick", "ek", "K", "wk", "ik", "ck", "kid", "ak", "rek"], "dc": ["doc", "ec", "d", "cp", "cat", "fc", "cd", "cr", "dt", "pc", "c", "bc", "DC", "nc", "dd", "ga", "dk", "ca", "ds", "md", "dm", "desc", "tc", "cam", "df", "cs", "rec", "gc", "db", "dr", "cc", "nz", "di", "dp", "disc", "rc", "lc", "ac", "da", "mc", "cca"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n\n                               Error **errp)\n\n{\n\n    int size;\n\n    char *path;\n\n    void *ptr;\n\n    char name[32];\n\n    const VMStateDescription *vmsd;\n\n\n\n    if (!pdev->romfile)\n\n        return;\n\n    if (strlen(pdev->romfile) == 0)\n\n        return;\n\n\n\n    if (!pdev->rom_bar) {\n\n        /*\n\n         * Load rom via fw_cfg instead of creating a rom bar,\n\n         * for 0.11 compatibility.\n\n         */\n\n        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);\n\n\n\n        /*\n\n         * Hot-plugged devices can't use the option ROM\n\n         * if the rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n", "idx": 3602, "substitutes": {"pdev": ["dDev", "pciver", "ppdef", "Pdef", "pver", "ppdev", "pcde", "patfam", "pcomment", "ipdev", "psw", "pkgcast", "pastick", "pvar", "pDEV", " pserial", "pDev", "ydev", "pdebug", " pgu", "PDev", "pkgde", "jppriv", "paysw", "pppad", "payve", "pcdev", "pingdebug", "ndevice", "patDev", "pkgrav", "pacam", "pstore", " ppriv", "dfam", "pcsw", "pgo", "pvision", "pkgvision", "psgo", " pcast", "pingDEV", "pingdev", "ddevice", "paydebug", " pfam", "apdebug", "Pdev", " pouch", "patdevice", "pdevice", "pkgstick", "qdev", "pedev", "yvar", " pdef", "tfam", " pdebug", "pkgcam", "pidev", "pkggu", "pev", " pdevice", "pserial", " pev", "nver", "pkgdev", "peng", "pgu", "tenv", "payfam", "peDEV", "tdev", "pego", "qev", "patchDev", "pcver", "ipouch", "pinggu", "tev", "pouch", "psvision", "pade", "ppserv", " pvar", "lpserv", "pfam", "patchdebug", "parav", "pceng", "cpDev", "pkgiver", "paddev", "Pver", "tpenv", "pave", "paddevice", "apdevice", "ndev", " penv", "paycam", "pagu", "cpdev", "pde", "pdef", "paygu", "ipcomment", "pkgfam", "pinggo", "patchdev", "psouch", "pegu", "tpdev", "patserial", "pingDev", "pingfam", "jpDev", "pevar", " pver", "pcve", "peev", "jpdef", "Ppad", "ipgo", "pedevice", "aprav", "nDev", "pingver", "Pdevice", "ppad", "cpdevice", "pcvision", "pastore", "pcast", " pDEV", "payDev", "pkgDev", " pgo", "yDEV", "pkgdebug", "Pgu", "pscomment", "paaddr", "tpdevice", "pcam", "pcfam", "pve", "pirav", "pingrav", "penv", "lpdef", "payserial", "ppriv", "ddev", "piver", "pkgstore", "pcaddr", "paygo", "payeng", "psdev", "padev", "pstick", "pserv", "Ppriv", "psiver", "pcouch", "tpev", "jpdev", "patdebug", "patdev", "lpdev", "tDEV", "pingdevice", "patchcast", "Pserv", "tver", "pasw", "prav", "pergo", "paydev", " peng", "perdev", "apdev", "lppad", "percomment", "qgo", "padfam", "qgu", "payaddr", "tdevice", "pcrav", "perouch", " pDev", "pcstore", "ydevice", "paddr", "pidevice", "payver", "pidebug", "payouch", "psfam", "paystick", "cpgu"], "is_default_rom": ["is_no_ram", "is_default2ram", "is_default2mem", "is_no2mem", "is_no2chrom", "is_no2rom", "is_default_mem", "is_no2ram", "is_no_mem", "is_default_chrom", "is_default2chrom", "is_default_ram", "is_no_chrom", "is_no_rom", "is_default2rom"], "errp": ["errorr", " errpp", "errorpg", "diep", "rerp", "rerpg", "errpg", "crpp", "rrr", "derp", "ierpp", "errpre", "dieP", "ererP", "rrp", "errpp", "derpp", "crpoint", "errorp", "ererping", " errpa", "ererpre", "rrpad", "ierpoint", "rerpad", " errP", "errorpp", "errorping", "diepa", "errpa", "derP", "errorpre", "erP", "errorP", "ierp", "erp", "ierpad", "rerr", "derpa", "errping", "crpad", "crp", "errr", "erpre", "errorpad", "rrpg", "errpad", "errpoint", "ererp", "errorpoint", "errP", "diepp", "erping"], "size": ["ze", "format", "height", "p", "n", "machine", "set", "see", "sum", "zero", "time", "disk", "body", "bytes", "fee", "equal", "mem", "south", "number", "message", "sex", "count", "any", "small", "password", "export", "num", "shape", "storage", "zip", "file", "dimension", "im", "offset", "range", "too", "sized", "max", "IZE", "length", "capacity", "Size", "chain", "l", "z", "sample", "mini", "send", "space", "type", "network", "error", "SIZE", "ize", "scale", "empty", "address", "si", "len", "sp", "city", "sh", "g", " sizes", "s", "score", " Size", "pos", "speed", "izes", "iz", "zone", "area", "news"], "path": ["core", "template", "id", "cp", "parent", "trace", "format", "port", "p", "form", "xml", "disk", "context", "cam", "pattern", "pkg", "mem", "key", "test", "dir", "open", "where", "link", "full", "policy", "ex", "zip", "location", "file", "loc", "PATH", "root", "th", "length", "chain", "folder", "code", "Path", "ref", "index", "tree", "pointer", "progress", "entry", "priv", "type", "history", "call", "error", "home", "empty", "address", "prefix", "cmd", "sp", "data", "image", "mount", "temp", "stat", "ath", "package", "rect", "url", "cont", "config", "transform", "desc", "copy", "alias", "resource", "null", "walk", "raw", "base"], "ptr": ["fp", "br", "alloc", "ctr", "eth", "pc", "addr", "handle", "port", "p", "ref", "pi", "r", "pointers", "rect", "pointer", "Ptr", "pos", "pad", "pr", "ps", "tp", "err", "buffer", "pt", "loc", "offset", " pointer", "dr", "address", "rc", "tr", "rep", "mem", "inter", "sp"], "name": ["id", "parent", "NAME", "user", "format", "n", "init", "order", "options", "out", "x", "time", "version", " Name", "group", "admin", "f", "mem", "a", " NAME", "key", "test", "names", "none", "tag", "location", "file", "normal", "named", "length", "l", "word", "code", "tree", "space", "ame", "part", "new", "type", " names", "title", "error", "comment", "str", "v", "flag", "prefix", "data", "image", "status", "value", "no", "g", "label", "start", "def", "filename", "local", "w", "alias", "class", "o", "Name", "t", "base", "module"], "vmsd": ["vinssd", "vpssd", "vMsde", " vmsde", " vpsd", " vmssd", "vinspd", "vlinesd", "vMsD", "vpsde", "vlinesdm", "vmssd", "evomsd", "vinsds", "vmspd", " vomsd", "hMSD", "evmssd", " vpsde", "evmsd", "vmesc", "evomspd", "evmsds", "vlinesD", "hmsc", "hMSc", "vemssd", " vomsg", "vpsd", "vmsdm", " vpssd", "vmesd", "vMsd", "vmsde", "vmmd", "vomspd", " vmsD", "evomsds", "vMSc", "vysds", "vkssd", "hmsD", "hmsdm", " vmsg", "vomsds", "vMSd", "vpsD", "hMSdm", "vemsd", " vomsds", "vemsds", "vmesdm", "vysg", "vkspd", "vlinesc", "vmsc", " vmsds", "vmsg", "vyssd", "vmmD", "vomsd", "evmspd", "vksd", "vMSD", "vysd", "evomssd", "vMSdm", "vmsD", "vmesD", "vmsds", "vemsg", "vinsd", "hmsd", "vksds", "vomsg", "vmmsd", "hMSd", "vMssd", "vomssd", " vpsD", " vomssd", "vmmde"]}}
{"project": "FFmpeg", "commit_id": "21bffa93a6fc73e1f1859f8bc224409eaaf27658", "target": 1, "func": "static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)\n\n{\n\n    AVStream       *video_st    = s->streams[0];\n\n    AVCodecParameters *video_par = s->streams[0]->codecpar;\n\n    AVCodecParameters *audio_par = s->streams[1]->codecpar;\n\n    int audio_rate = audio_par->sample_rate;\n\n    // TODO: should be avg_frame_rate\n\n    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);\n\n    int audio_kbitrate = audio_par->bit_rate / 1000;\n\n    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);\n\n\n\n    avio_wb32(pb, 0x94); /* size */\n\n    ffio_wfourcc(pb, \"uuid\");\n\n    ffio_wfourcc(pb, \"PROF\");\n\n\n\n    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n\n    avio_wb32(pb, 0xbb88695c);\n\n    avio_wb32(pb, 0xfac9c740);\n\n\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x3);  /* 3 sections ? */\n\n\n\n    avio_wb32(pb, 0x14); /* size */\n\n    ffio_wfourcc(pb, \"FPRF\");\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n\n\n    avio_wb32(pb, 0x2c);  /* size */\n\n    ffio_wfourcc(pb, \"APRF\"); /* audio */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x2);   /* TrackID */\n\n    ffio_wfourcc(pb, \"mp4a\");\n\n    avio_wb32(pb, 0x20f);\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_rate);\n\n    avio_wb32(pb, audio_par->channels);\n\n\n\n    avio_wb32(pb, 0x34);  /* size */\n\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x1);    /* TrackID */\n\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n\n        ffio_wfourcc(pb, \"avc1\");\n\n        avio_wb16(pb, 0x014D);\n\n        avio_wb16(pb, 0x0015);\n\n    } else {\n\n        ffio_wfourcc(pb, \"mp4v\");\n\n        avio_wb16(pb, 0x0000);\n\n        avio_wb16(pb, 0x0103);\n\n    }\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb16(pb, video_par->width);\n\n    avio_wb16(pb, video_par->height);\n\n    avio_wb32(pb, 0x010001); /* ? */\n\n}\n", "idx": 3610, "substitutes": {"pb": ["cp", "tmp", "p", "py", "kl", "bp", "td", "pg", "vp", "req", "pr", "job", "xp", "ap", "pkg", "emb", "bps", "rm", "orp", "sb", "resp", "fp", "tk", "pm", "erb", "np", "pel", "rb", "phy", "tab", "tp", "bs", "pa", "um", "apache", "dp", "nb", "uf", "obj", "obb", "wp", "jp", "buf", "ub", "phys", "xb", "mp", "amp", "patch", "gp", "gb", "err", "ctx", "pool", "ob", "pt", "fb", "ker", "prefix", "PB", "proc", "sys", "lp", "func", "prop", "pc", "bj", "pp", "b", "lb", "ps", "bb", "pl", "rpm", "stab", "peer", "tc", "jpg", "typ"], "s": ["sys", "ls", "S", "stats", "c", "sv", "ss", "p", "es", "g", "sl", "times", "vs", "ses", "comm", "ds", "qs", "m", "b", "fs", "https", "less", "aws", "ps", "its", "ex", "js", "bs", "ns", "parts", "http", "ims", "w", "cs", "ts", "spec", "sts", "v", "rs", "gs", "sb", "ats", "os", "sq", "t"], "video_st": [" video_ste", "video_stable", "video_ste", "video__str", " video_est", "video_sty", " video_sta", " video_trans", "video_str", "video_sta", "video_trans", " video_sty", " video_stable", "video__est", "video__st", "video__ste", " video_str", "video_est"], "video_par": ["videolibjp", "videoitypr", "ideo_pr", "videolibcomp", "video0par", "videoartypar", "videoartypa", "video_se", "ideo_par", "video0pa", "video0se", "videoitycomp", "videoartycar", "videoitypar", "video_pa", "video0car", "voice_se", "voice_pa", "ideoitypr", "voice_par", "voice_car", "ideo_jp", "videolibpar", "video_car", "videoartyse", "ideoitycomp", "ideoityjp", "ideoitypar", "videoityjp", "videolibpr", "video_pr", "video_comp", "ideo_comp", "video_jp"], "audio_par": [" audio_pas", "audiolcomp", "audioitycomp", "audioitypar", "audio_comp", " audio_pkg", "video_comp", "audio___rep", "audio___par", " audio_comp", " audio_mat", "audiolp", "audio___comp", "audio___part", "audiolpair", "audio_part", " audio_prep", "audio_pair", "audio_p", "audio_pas", "video_rep", "audiolpar", "audio_prep", "video_pair", "audio_rep", "audioitypkg", "video_p", "audio_mat", "video_part", "audio_pkg", "audioitymat"]}}
{"project": "qemu", "commit_id": "8f68760561abf90156456fec6ad55c3b2a066d46", "target": 1, "func": "static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n", "idx": 3611, "substitutes": {"sphb": ["sPhb", "sPhB", " sphB", "sPhdb", " spha", " sphdb", "spga", "sPha", "sphdb", "spgb", "spgdb", "sphB", "spgB", "spha"], "pdev": ["pdevice", "dDev", "pdef", "ppdef", " pdef", "ppdev", "postdev", "dgu", "postdevices", "ppdevices", " pdevice", "pcdevice", "pDev", "pgu", "PDev", "postdef", "Pdevice", "postdevice", "pcdev", "ppdevice", " pdevices", "pdevices", "Pgu", "pcgu", "ddev", "ddevice", "pcDev", "Pdev"], "path": ["template", "id", "parent", "c", "port", "p", "localhost", "out", "set", "context", "cam", "buffer", "pattern", "here", "method", "ports", "pkg", "h", "program", "br", "key", "text", "near", "dir", "where", "link", "full", "ready", "valid", "check", "pat", "ex", "location", "end", "file", "ptr", "name", "dest", "loc", "PATH", "root", "cert", "th", "length", "self", "chain", "Path", "half", "ref", "index", "pointer", "part", "phi", "priv", "dev", "call", "ctx", "str", "home", "pt", "target", "client", "address", "empty", "current", "pid", "prefix", "cmd", "data", "mount", "prop", "conn", "ath", "ith", "kind", "url", "pos", "quick", "transform", "ip", "local", "binding", "w", "ha", "mat"], "buf": ["proc", "doc", "data", "br", "cp", "batch", "cat", "env", "prop", "arr", "bc", "port", "conv", "conn", "text", "img", "ref", "result", "txt", "iter", "cfg", "out", "cb", "rb", "bed", "b", "msg", "cont", "seq", "cur", "gen", "filename", "dev", "vec", "config", "content", "output", "file", "cap", "desc", "buffer", "err", "context", "cv", "cam", "ptr", "bag", "ctx", "pool", "ob", "str", "Buffer", "bin", "pkg", "pt", "db", "loc", "queue", "bytes", "norm", "raw", "Buff", "mem", "obj", "serv", "uf", "cmd", "buff"], "host": ["domain", "OST", "user", "Host", "addr", "handle", "object", "port", "source", "conn", "p", "bind", "ref", "ith", "index", "localhost", "server", "node", "url", "hat", "physical", "cmp", "nick", "dev", "hand", "ip", "http", "local", "hop", "ghost", "hd", "context", "binding", "hook", "rh", "here", "name", "comp", "sche", "pool", "str", "home", "container", "hs", "loc", "ha", "target", "client", "address", "h", "ost", "driver", "ich", "cert", "th", "ac", "serv", "map", "cmd", "chain"]}}
{"project": "FFmpeg", "commit_id": "8b2fce0d3f5a56c40c28899c9237210ca8f9cf75", "target": 1, "func": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)\n\n{\n\n    //FIXME Optimize (just quickly writen not opti..)\n\n    int i;\n\n    for (i=0; i<dstW; i++)\n\n    {\n\n        int val=1<<18;\n\n        int j;\n\n        for (j=0; j<lumFilterSize; j++)\n\n            val += lumSrc[j][i] * lumFilter[j];\n\n\n\n        dest[i]= av_clip_uint8(val>>19);\n\n    }\n\n\n\n    if (!uDest)\n\n        return;\n\n\n\n    if (dstFormat == PIX_FMT_NV12)\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(u>>19);\n\n            uDest[2*i+1]= av_clip_uint8(v>>19);\n\n        }\n\n    else\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(v>>19);\n\n            uDest[2*i+1]= av_clip_uint8(u>>19);\n\n        }\n\n}\n", "idx": 3621, "substitutes": {"lumFilter": ["loomFilter", "llumFilter", "lumaF", "lumaRule", "lummFilter", "llumaF", "lumfilter", "loomFil", "lumaFilter", "loomF", "lumBlock", "luvBlock", "llumF", "lumRule", "lamfilter", "luvFilter", "lummRule", "lummBlock", "llumaRule", "lumaBlock", "llumaFil", "llumaBlock", "llumRule", "llumBlock", "lamFil", "lumafilter", "llumfilter", "lamFilter", "llumafilter", "lamF", "lumFil", "luvRule", "loomfilter", "lumaFil", "llumaFilter", "llumFil", "lumF"], "lumSrc": ["lumInRC", "lumAsRC", "lumaSrc", "lumaSsrc", "lumAsrc", "lumsInrc", "lumNrc", "lumInsrs", "lumAsrs", "lumInsrc", "lumInrs", "lumsSRC", "lumsSrs", "lumNsrc", "lumsInrs", "lumInsRC", "lumaSrs", "lumNrs", "lumaSRC", "lumSRC", "lumNRC", "lumsInRC", "lumsSrc", "lumSrs", "lumInrc", "lumSsrc"], "lumFilterSize": ["lumFilSize", "lumsFilterSIZE", "lumsFilterMode", "lumbFilterSIZE", "lumbChannelSize", "lumBufferInfo", "lumRangeSIZE", "lumRangeStyle", "lumChannelSIZE", "lumBufferStyle", "lumFilterStyle", "lumbChannelSIZE", "lumsBlockMode", "lumbFilterInfo", "lumBufferSize", "lumsBlockStyle", "lumbChannelInfo", "lumChannelInfo", "lumChannelSize", "lumFilterInfo", "lumBlockStyle", "lumsFilterStyle", "lumFilterMode", "lumBufferSIZE", "lumsFilterSize", "lumBufferMode", "lumRangeMode", "lumBlockSize", "lumBlockMode", "lumFilInfo", "lumbFilterSize", "lumsBlockSize", "lumBlockSIZE", "lumsBlockSIZE", "lumRangeSize", "lumFilterSIZE", "lumFilSIZE"], "chrFilter": ["chreFilter", "chrarControl", "chrofilter", "chrQuery", "chuFrame", "childrgBuffer", "chrgTransform", "chrarFrame", "chrHandler", "childrRule", "achrFil", "chrtFilter", "chlQuery", "chroFilter", "chroFil", "achrFilter", "chrcFilter", "chrtQuery", "chuFilter", "chrarFilter", "childrgTransform", "chlFil", "childrFilter", "chrFrame", " chrQuery", "achrcFil", "chreFormat", " chrFil", "chreFrame", "chnrQuery", "chrtFrame", " chrcFrame", "achrcFilter", "chuControl", "chrgFilter", "chnrtFilter", "chrFil", "chrfilter", "chlFrame", "chnrFrame", "chlFilter", "chrBuffer", "chrtTransform", "chrFormat", "achrTransform", "chrControl", "chnrControl", "chuFormat", "chrdFilter", "chrtRule", "chrdQuery", " chrfilter", " chrcFilter", "childrTransform", "chlTransform", "chrcRule", "chlControl", " chrofilter", " chroQuery", "chnrtControl", "childrgRule", " chrcFormat", "chrcFormat", "achrcTransform", "chrgBuffer", "childrBuffer", "chruFilter", "chrcHandler", "chruTransform", " chrFormat", " chroFilter", " chrcControl", "chrcControl", " chrControl", "childrgFilter", "chnrFilter", "chruHandler", "chrdFil", "chrufilter", "chrcFrame", "chrtControl", "chrdfilter", "chnrtFrame", "chrarQuery", " chrFrame", "chrcTransform", "achrHandler", " chroFil", "chroQuery", "chrcFil", "chlHandler", "chrgRule", "chrRule", "chrtBuffer", "chruFil", "chnrtQuery", "chrTransform", "achrcHandler", "chruQuery", "chrcBuffer", "chreControl"], "chrSrc": ["chrtSq", "chrResRC", "chrOutnc", "chrSsc", "chrcInsRC", "chrtPRC", "chrtSvc", "chrOutrc", "chrOutvc", "chrNRC", "chrSourcesrc", "chrtPsrc", "chrSource", "chrSourceRC", "chrDrs", "chrtSource", "chrSourceource", "chrPsnc", "chrDsrc", "chrcSrs", "chrtSrc", "chrInsRC", "chrInrc", "chrcInsrc", "chrSrs", "chrRessrc", "chrtSsc", "chrInource", "chrtSsrc", "chrtPrc", "chrtSRC", "chrResrc", "chrPsvc", "chrSRC", "chrSsrc", "chrPrc", "chrInssrc", "chrPq", "chrInssc", "chrSq", "chrOutRC", "chrInRC", "chrcSrc", "chrSourcerc", "chrPRC", "chrcSRC", "chrPsrc", "chrSnc", "chrtPq", "chrNsrc", "chrInsrc", "chrtSnc", "chrDrc", "chrDRC", "chrcSsrc", "chrRessc", "chrcInssrc", "chrNq", "chrInsrs", "chrSvc", "chrNrc", "chrPsRC", "chrcInsrs"], "chrFilterSize": ["chrtFilLength", "chruRuleWindow", "chrsFilterSIZE", "chruRuleSize", "chrsBufferSize", "chrBufferize", "chrRangeType", "chrFilterN", "chruRuleN", "chrFilterLength", "chrFilterize", "chrListenerSIZE", "chrMaskScale", "chrBufferSIZE", "chrtFilSIZE", "chrListenerize", "chrBufferType", "chrRuleN", "chrsBufferScale", "chrBufferLength", "chrMaskType", "chrFilSIZE", "chrtFilize", "chruFilterWindow", "chrFilterWindow", "chrFilterSIZE", "chrsFilterSize", "chruFilterSize", "chrStreamN", "chrTransformN", "chrRuleW", "chrtFilSize", "chruFilterW", "chrFilSize", "chrsFilterScale", "chrFilterW", "chrRuleWindow", "chrtFilterLength", "chrStreamWindow", "chrFilterType", "chrBufferSize", "chrMaskSize", "chrFilize", "chrListenerLength", "chrMaskSIZE", "chrtFilterize", "chrTransformW", "chrTransformWindow", "chrsFilterType", "chrStreamW", "chrsBufferType", "chrsBufferSIZE", "chrBufferScale", "chrFilterScale", "chruFilterN", "chrFilLength", "chrRuleSize", "chrRangeSize", "chrTransformSize", "chruRuleW", "chrStreamSize", "chrListenerSize", "chrtFilterSize", "chrtFilterSIZE", "chrRangeSIZE", "chrRangeScale"], "dest": ["data", "cat", "Dest", "temp", "comb", "EST", "buf", "rest", "port", "source", "sort", "result", "pi", "iter", "out", "dist", "decl", "table", "cont", "it", "transform", "opt", "output", "trans", "ist", "desc", "end", "buffer", "ptr", "origin", "loc", "target", "est", "src", "tr", "st", "mem", "master", "sp"], "uDest": ["uSource", "uuSource", "puOrig", "cuDec", "uQueue", "uiQueue", "pDesc", "oDest", "oDec", "uTarget", " uDesc", "uuDest", "oQueue", "uNeg", " uDep", "uDec", "puDesc", "iuDest", "pDec", " uNow", "uStore", " uTarget", "uiNeg", "uiDest", "puDec", "uuStore", "uuRest", "puDest", "cuDesc", "iuDec", "uiRest", "uiDec", " uNeg", "uiTarget", "uvDest", "uiSource", "iuDesc", "pOrig", "uiDep", "uiDesc", "tuNeg", "uvNow", "uvDep", "iuStore", "iuSource", "iuRest", "iuOrig", " uQueue", "cuDest", "pDest", "uNow", "uDesc", "cuTarget", "oDesc", "tuNow", "tuDest", "tuDep", "uDep", "uRest", "tuDesc", "uOrig", "uiStore", "oTarget"], "dstW": ["distVW", "dtdVW", "dstSW", "dtdSize", "dostVW", "distSW", "dostSW", "dtdW", "dostW", "dstN", "DistVW", "DistSW", "dstSize", "DstSW", "DstVW", "dostG", "dSTW", "distG", "dtdSW", "DistG", "dSTSize", "distN", "DstSize", "dSTG", "dostSize", "distW", "DistSize", "DstW", "DstN", "dstVW", "dostN", "DistW", "distSize", "DstG", "DistN", "dSTN", "dstG"], "chrDstW": ["chrSrcZ", "chrDstrZ", "chrDSTN", "chrDistSize", "chrDistWP", "chrDstR", "chrDstrD", "chrDrcWP", "chrSistV", "chrDndV", "chrDndW", "chrDestD", "chrDndN", "chrDestWP", "chrDSTV", "chrSstSize", "chrSstR", "chrSistW", "chrSrcW", "chrSstW", "chrDstSize", "chrSistR", "chrSstD", "chrDSTR", "chrDstZ", "chrDstrSize", "chrDstN", "chrDestZ", "chrDrcSize", "chrDndR", "chrSstN", "chrSstZ", "chrDrcN", "chrDistN", "chrDSTW", "chrDrcZ", "chrDistW", "chrSrcSize", "chrSistN", "chrDistV", "chrDistR", "chrDstD", "chrDstrW", "chrSstV", "chrDrcD", "chrDrcW", "chrDestW", "chrSrcWP", "chrSrcN", "chrDestSize", "chrDstV", "chrSstWP", "chrDstWP", "chrSrcD", "chrDestN"], "dstFormat": ["dstMT", "drcformat", "distFormat", "destType", "dstformat", "dstrType", "Dstformat", "DistFormat", "DSTType", "dSTType", "DSTForm", "DstMT", "distStyle", "distMT", "DistStyle", "DstFormat", "DSTFormat", "drcStyle", "dSTForm", "DistMT", "dSTFormat", "dSTStyle", "destFormat", "DSTStyle", "dstType", "DstType", "dstrForm", "dstForm", "destStyle", "dstStyle", "DstStyle", "dstrFormat", "distformat", "Distformat", "drcFormat", "destForm", "dstrStyle", "DstForm", "drcMT"], "i": ["id", "parent", "user", "c", "p", "n", "init", "iter", "li", "iii", "x", "ih", "t", "iu", "ti", "ind", "ix", "zi", "ini", "I", "ik", "this", "batch", "key", "iy", "xi", "ic", "qi", "m", "u", "ui", "it", "ims", "im", "name", "io", "medi", "\u0438", "ri", "ii", "iq", "ji", "z", "to", "pi", "index", "me", "ci", "ei", "info", "phi", "ij", "y", "bi", "hi", "val", "v", "mi", "di", "ai", "si", "point", "multi", "ni", "ki", "status", "il", "tim", "is", "sim", "ami", "cli", "gi", "ip", "ie", "print", "ia", "dr", "in", "iat"], "j": ["try", "jit", "aj", "kh", "py", "n", "jar", "jas", "x", "ijk", "other", "him", "ge", "J", "pr", "job", "ind", "bo", "ix", "by", "jac", "my", "br", "q", "key", "uj", "it", "at", "jl", "note", "im", "ion", "gh", "json", "jump", "jp", "ji", "er", "z", "kj", "res", "adj", "att", "ij", "y", "jo", "bi", "err", "el", "je", "fr", "str", "pt", "mn", "v", "Ja", "di", "jj", "dj", "bj", "jack", "g", "og", "ng", "them", "js", "ie", "jc", "oj", "jet", "ja", "dr", "bl", "obj"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)\n\n{\n\n    uint32_t qid;\n\n\n\n    if (addr & ((1 << 2) - 1)) {\n\n        return;\n\n    }\n\n\n\n    if (((addr - 0x1000) >> 2) & 1) {\n\n        uint16_t new_head = val & 0xffff;\n\n        int start_sqs;\n\n        NvmeCQueue *cq;\n\n\n\n        qid = (addr - (0x1000 + (1 << 2))) >> 3;\n\n        if (nvme_check_cqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        cq = n->cq[qid];\n\n        if (new_head >= cq->size) {\n\n            return;\n\n        }\n\n\n\n        start_sqs = nvme_cq_full(cq) ? 1 : 0;\n\n        cq->head = new_head;\n\n        if (start_sqs) {\n\n            NvmeSQueue *sq;\n\n            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {\n\n                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n            }\n\n            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n        }\n\n\n\n        if (cq->tail != cq->head) {\n\n            nvme_isr_notify(n, cq);\n\n        }\n\n    } else {\n\n        uint16_t new_tail = val & 0xffff;\n\n        NvmeSQueue *sq;\n\n\n\n        qid = (addr - 0x1000) >> 3;\n\n        if (nvme_check_sqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        sq = n->sq[qid];\n\n        if (new_tail >= sq->size) {\n\n            return;\n\n        }\n\n\n\n        sq->tail = new_tail;\n\n        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n}\n", "idx": 3634, "substitutes": {"n": ["gn", "j", "net", "self", "c", "nr", "nd", "nc", "cn", "nl", "N", "p", "conn", "g", "ren", "np", "names", "node", "ng", "comm", "m", "nv", "num", "ne", "nw", "yn", "network", "ns", "note", "y", "w", "en", "name", "ln", "nm", "un", "mn", "an", "v", "on", "nt", "o", "nu", "dn", "nn", "na", "nor", "nb", "rn", "sn"], "addr": ["mt", "id", "usr", "work", "add", "l", "eth", "arr", "host", "adv", " cur", "Address", "to", " ptr", "ash", "attr", "hw", "r", "index", " ip", "iter", "align", "url", "act", "res", "b", "x", "tx", "pos", "adj", "ord", "ack", "pad", "sw", "ip", "hop", "hl", "ptr", "wd", "name", "alias", " amp", "adr", "pkg", "gate", "rt", "alt", "now", "loc", "offset", "ix", "hz", "v", "on", "dr", "address", "hash", "arp", " address", "ret", "inter", "ad", "src", "rc", " err", "iat", " af", "len", "cmd", " mac", "sp"], "val": [" value", "values", "func", " res", "value", "arr", " arg", "buf", "Val", "cal", "attr", "ref", "pol", "vt", "act", "vals", "oval", " resp", "b", "var", " msg", "num", "pos", "tx", "valid", " step", " tx", "VAL", " eval", "xy", "dev", "iv", " index", " x", "err", "aval", " ret", " offset", " v", "eval", " state", "hz", "v", "fail", " len", "vol", " count", " amount", "alpha", "rel", "ret", "sel", " interval", " act", " num", " height", "elt", "resp", " iv"], "qid": [" qtry", "querymid", "quinfo", "qID", "questref", "dqid", "itemide", "quref", "iqmid", "iqpid", "dqpid", "qtry", "qqid", "eqid", "iqID", "itemid", "iqoid", "dqinfo", "qoid", "quoid", "iqname", "queryId", "quId", "qqID", "qname", "eqtry", "itemident", " qpid", "quident", "queid", "qualident", "qualid", "itemmid", "iqm", "questmid", "questide", "questid", "quid", "qqname", "quem", "qum", "qumid", "querypid", "qqId", "qualmid", "dqId", "queoid", "qualref", "iqid", " qname", " qinfo", "qref", "qmid", "eqmid", "qpid", " qId", " qmid", "qinfo", "qupid", "quide", "qualide", "qm", "iqId", "qident", " qID", "iqtry", "queryid", "qide", "qId"], "start_sqs": ["start_squs", "start_shls", "startfulsqis", "start2sqs", "start_seqches", "startfulsqos", "start_scS", "start2sqls", "startfulsqus", "start_sqds", "start_seqds", "start_scs", "start2seqls", "start_seqls", "start_iqls", "start_sqarts", "start_squos", "start_txarts", "start_txis", "start_iqches", "start2seqches", "start_sqS", "start_scds", "start_squarts", "start_seqs", "start_iqs", "start_aqarts", "start2seqds", "start_squis", "start_aqis", "start_eqs", "start_txos", "start_aqs", "startfulsqarts", "startfulsqs", "start_eqds", "start_sqos", "start_eqls", "start_sqls", "start_sqis", "startfulsquos", "start_shs", "start2sqds", "start_txs", "start2seqs", "start_scls", "startfulsquarts", "startfulsquis", "start2sqches", "start_iqS", "start_shS", "start_aqos", "start_shds", "start_eqches", "start_sqches", "start_iqds"], "cq": ["lcue", "cpe", "contue", " cwe", "cqu", "conwe", "dcqu", "cinqq", "cQ", "contqu", "conog", "ceque", "cqq", "dq", "nciq", "aciq", "acog", "ncqu", "lcqq", " cque", "acqs", "cachequ", " cQ", "crqq", "contq", "dqu", "cue", "ciq", "pqs", "cog", "condq", "scqu", "cquery", "cque", "dcQ", "cdq", "catue", "acquery", "acq", "cedq", "mcue", " cue", "scq", "acQ", "dqq", "cequ", "catqu", "cacheque", "scqq", "acue", "xcwe", "cqs", "xcqq", "pq", "xcq", "dcq", "crque", "pqu", "acqq", "pQ", "mcquery", "mcq", "ecQ", "mcqq", "conq", "diq", "ecq", "cacheq", "cinq", "ecqu", "cinque", " cqs", "acpe", " cdq", " cqq", "catq", "crq", "ceq", " cqu", "conqs", "lcpe", "catque", "xcdq", " cquery", "dcqq", "acqu", " cpe", "cwe", "ncq", "lcq", "contque", "ncqq", "conqq", "cachedq", "crpe", "ecqq", "sciq", " cog", "cinpe", "dciq"], "sq": ["sys", "ctr", "q", "aux", "squ", "iq", "square", "shift", "sg", "ssh", "sh", "qq", "sv", "scl", "ss", "cn", "inqu", "she", "tk", "ash", "sl", "query", "nil", "qi", "qa", "sf", "ksh", "s", "sa", "ds", "sql", "qs", "parse", "biz", "lbs", "seq", "qt", "sc", "aws", "aq", "qu", "ps", "zz", "dq", "ship", "ns", "subject", "cap", "cf", "sing", "mph", "quit", "ctx", "cs", "esque", "pkg", "rt", "hs", "sid", "eq", "ry", "cu", "ct", "gs", "sb", "sol", "socket", "sync", "se", "ssl", "cmd", "news", "supp"]}}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold void build_modpred(Indeo3DecodeContext *s)\n\n{\n\n  int i, j;\n\n\n\n  s->ModPred = av_malloc(8 * 128);\n\n\n\n  for (i=0; i < 128; ++i) {\n\n    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));\n\n    s->ModPred[i+1*128] = i ==   7 ?  20 :\n\n                          i == 119 ||\n\n                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));\n\n    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));\n\n    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));\n\n    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));\n\n    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));\n\n    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));\n\n    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));\n\n  }\n\n\n\n  s->corrector_type = av_malloc(24 * 256);\n\n\n\n  for (i=0; i < 24; ++i) {\n\n    for (j=0; j < 256; ++j) {\n\n      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :\n\n                                   j < 248 || (i == 16 && j == 248) ? 0 :\n\n                                   corrector_type_2[j - 248];\n\n    }\n\n  }\n\n}\n", "idx": 3658, "substitutes": {"s": ["ls", "S", "stats", "status", "c", "sg", "is", "sets", "sv", "ss", "p", "settings", "als", "conv", "service", "vs", "acs", "details", "ses", "comm", "set", "ds", "qs", "utils", "ers", "ants", "fs", "less", "aws", "services", "ps", "parts", "js", "ns", "bs", "ims", "bis", "ms", "ports", "ans", "cs", "ts", "spec", "a", "hs", "lines", "sts", "eps", "rs", "h", "gs", "ats", "sb", "ins", "sq", "os", "states", "sync", "se", "ops"], "i": ["id", "ori", "p", "init", "li", "iii", "x", "iu", "ti", "ind", "uri", "ix", "zi", "ini", "I", "f", "ik", "this", "q", "xi", "ic", "qi", "m", "u", "ui", "it", "at", "aci", "ims", "im", "um", "name", "ar", "io", "\u0438", "ri", "yi", "chain", "ati", "l", "ii", "er", "iri", "pi", "index", "adi", "me", "ci", "ei", "info", "phi", "esi", "ij", "eu", "ed", "y", "bi", "err", "hi", "mac", "v", "mi", "di", "ai", "si", "multi", "ki", "status", "is", "sim", "g", "ami", "cli", "gi", "ip", "oi", "ie", "e", "ia", "in", "o"], "j": ["jump", "br", "q", "try", "l", "iaz", "jp", "ji", "dj", "bj", "er", "jit", "uj", "p", "aj", "z", "g", "n", "ju", "kj", "r", "li", "m", "b", "x", "u", "us", "it", "at", "J", "ij", "jl", "job", "js", "bs", "y", "k", "jo", "bi", "ie", "e", "je", "jc", "ian", "fr", "oj", "ion", "ind", "or", "ja", "ix", "v", "Ja", "on", "o", "h", "si", "t", "obj", "jj", "json"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 3681, "substitutes": {"s": ["sys", "S", "q", "stats", "c", "sg", "is", "sv", "ss", "p", "g", "n", "r", "ses", "set", "ds", "b", "space", "fs", "sc", "js", "ns", "bs", "sw", "w", "e", "as", "ts", "cs", "ctx", "sm", "hs", "sts", "rs", "v", "h", "gs", "sb", "st", "os", "t", "self", "sp"], "rlow": ["relhigh", "rtlow", "vlow", "mrlittle", " rlower", "mrlo", "radlow", "vlo", "rello", "rtlower", "rLow", "radlittle", "rlittle", "vLow", "mrhigh", "rlo", "rellow", "radhigh", "rtlo", "rlower", " rlo", "rtLow", "vlower", "mrlow", " rLow", "radlo", "rellittle"], "rhigh": [" rhighest", "rthighest", "Rmax", "rmax", "rdupper", "Rhighest", "rtmax", "Rhigher", "nrupper", "nrhighest", "rhigher", "rhighest", "Rmost", "nrhigher", "rdhigh", "rmost", "nrhigh", "Rhigh", "rdhigher", "rthigh", "rdhighest", " rmost", "rtmost", "rupper", " rmax", "Rupper"], "val": ["data", " aval", " value", "key", "l", "func", "test", "value", "buf", " arg", "V", "sv", "Val", "p", "cal", "ref", "index", "pol", "vt", "vals", "var", "b", "x", "tx", "num", "valid", "it", "VAL", "pr", " eval", "xy", "vec", "t", " x", "ival", "pl", "ctx", " v", "eval", "alt", "pt", "loc", "reg", "v", "vol", "alpha", "ret", "sol", "al", "mem", "base"], "tmp": ["proc", "cp", "mint", "temp", "mb", "buf", "jp", "tt", "xb", "tg", " sp", "p", "py", "img", "attr", "np", "txt", "vt", "mp", "emp", "lib", "cb", "td", "m", "buff", "var", "b", "out", "msg", "orig", "gb", "new", "etc", "tm", " np", " mp", "cmp", "snap", "xy", "bt", "tv", "tar", "perm", "cv", "ptr", "mk", "sam", "ctx", "tn", "pkg", "rt", "pt", "mm", "null", "nt", "wx", "gz", "ret", "grow", "gm", "resp", "timeout", "t", "split", "obj", "jj", "uf", "cmd", "sp"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n\n{\n\n    int ret = 0;\n\n\n\n    assert(len > 0);\n\n    ccid_bulk_in_get(s);\n\n    if (s->current_bulk_in != NULL) {\n\n        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n\n        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n\n        s->current_bulk_in->pos += ret;\n\n        if (s->current_bulk_in->pos == s->current_bulk_in->len) {\n\n            ccid_bulk_in_release(s);\n\n        }\n\n    } else {\n\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n\n        ret = USB_RET_NAK;\n\n    }\n\n    if (ret > 0) {\n\n        DPRINTF(s, D_MORE_INFO,\n\n                \"%s: %d/%d req/act to guest (BULK_IN)\\n\", __func__, len, ret);\n\n    }\n\n    if (ret != USB_RET_NAK && ret < len) {\n\n        DPRINTF(s, 1,\n\n            \"%s: returning short (EREMOTEIO) %d < %d\\n\", __func__, ret, len);\n\n    }\n\n    return ret;\n\n}\n", "idx": 3691, "substitutes": {"s": ["sis", "ls", "sta", "p", "es", "n", "ses", "set", "us", "services", "its", "t", "cs", "ies", "h", "gs", "sb", "so", "os", "serv", "stats", "sv", "vs", "details", "xs", "ds", "qs", "less", "bs", "ims", "bis", "hs", "sts", "ins", "states", "sq", "sync", "sn", "S", "ss", "als", "sl", "comm", "utils", "i", "ns", "sw", "y", "ms", "ts", "changes", "v", "ops", "sp", "sys", "is", "stat", "b", "fs", "cli", "aws", "ps", "parts", "js", "comments", "sports", "sm", "rs", "bits", "ats", "st", "store"], "data": ["batch", "Data", "d", "id", "size", "buf", "value", "DATA", "next", "p", "text", "to", "r", "out", "ds", "mid", "dat", "m", "b", "pos", "start", "cache", "extra", "def", "type", "pad", "xy", "mu", "length", "trans", "block", "rew", "buffer", "ptr", "as", "name", " DATA", "str", "bin", "reg", "offset", "partial", "val", "empty", "ata", "bytes", "in", "bits", "done", "ret", "ad", "f", "fn", "t", "mem"], "len": ["ls", "n", "lic", "kl", "li", "lf", "led", "gt", "lon", "cap", "lif", "bytes", "h", "ret", "lu", "resp", "mem", "ld", "list", "lim", "Len", "num", "seq", "ll", "lan", "cmp", "end", "den", "ln", "alt", "del", "loc", "offset", "rev", "nt", " le", "elt", "enc", "length", " length", "le", "l", "size", "buf", "nl", "fun", "ref", "lt", "gen", "hl", "err", "el", "en", "str", "val", "lin", "lang", "lp", "L", "limit", "fin", "lit", "pos", "vec", " l", "lc", "t"]}}
{"project": "FFmpeg", "commit_id": "29c2fcb6776f80a0a5551bb82b43bc14c8202331", "target": 1, "func": "static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)\n\n{\n\n    int16_t icoef;\n\n    int recent = s->cdlms[ich][ilms].recent;\n\n    int16_t range = 1 << (s->bits_per_sample - 1);\n\n    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample\n\n\n\n    if (input > pred) {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] +=\n\n                s->cdlms[ich][ilms].lms_updates[icoef + recent];\n\n    } else {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] -=\n\n                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?\n\n    }\n\n    s->cdlms[ich][ilms].recent--;\n\n    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);\n\n\n\n    if (input > pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];\n\n    else if (input < pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];\n\n\n\n    /* XXX: spec says:\n\n    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;\n\n    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;\n\n\n\n        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two\n\n        seperate buffers? Here I've assumed that the two are same which makes\n\n        more sense to me.\n\n    */\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;\n\n    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */\n\n\n\n    if (s->cdlms[ich][ilms].recent == 0) {\n\n        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.\n\n                follow kshishkov's suggestion of using a union. */\n\n        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_prevvalues,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_updates,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;\n\n    }\n\n}\n", "idx": 3714, "substitutes": {"s": ["ls", "c", "es", "n", "ses", "gets", "services", "series", "its", "conf", "cs", "ains", "ies", "h", "gs", "f", "sb", "os", "serv", "tools", "stats", "sv", "settings", "vs", "details", "ers", "ds", "qs", "m", "ants", "less", "we", "ex", "bs", "ims", "sam", "ties", "bes", "hs", "sts", "states", "ins", "sq", "acs", "self", "S", "l", "ges", "ss", "als", "sl", "comm", "space", "ns", "sw", "same", "ms", "ts", "changes", "tests", "se", "ops", "sys", "is", "sim", "g", "fs", "aws", "ps", "parts", "js", "comments", "e", "w", "as", "rs", "ows", "ats", "store"], "ich": ["itech", " ch", "ach", "iche", "hw", "resh", "ish", "html", "ih", "ship", "nick", "chest", "ix", "yout", "hum", "h", "channel", "uph", "ik", "isch", "chid", "ht", "domain", "ull", "CH", "nih", "eric", "ic", "clus", "act", "phy", "thus", "iv", "cht", "chrom", "irc", "icht", "chan", "hs", "roth", "esp", "psych", "iah", "och", "craft", "alth", "wife", "th", "ether", "gh", "unch", "chain", "uth", "liv", "iq", "host", "urn", "chip", "ah", "ict", "icon", "hip", "history", "ait", "chn", "y", "anch", "chant", "arch", "sys", "isc", "hirt", "eth", "cha", "ight", "erv", "iam", "ith", "igr", "hill", "ech", "ill", "uch", "rich", "icy", "irm", "Ch", "ip", "dom", "ch", "chart", "igh", "irt", "ick"], "ilms": ["ilml", "filmb", "bilmn", "ilks", "ilimers", "illmic", "utilvs", "ilmos", "ilws", "utilmes", "ilsml", "utilms", "ailmb", "iliws", "ilemic", "ilkes", "ailmm", "utilmers", "ilm", "illmins", "ilemes", "tilmes", "ilmm", "ailms", "ilbs", "ailmos", "ialml", "kilms", "ailks", "utilmins", "filmes", "filmers", "ilmers", "illmers", "ilijs", "tilws", "ailmers", "tilmic", "ilimic", "filems", "ialms", "utilks", "ailjs", "utilfs", "illmos", "ailmic", "ilmic", "filvs", "tilmb", "kilmb", "filmos", "filks", "ilems", "utilkes", "illm", "film", "ilmn", "tilmins", "ilemos", "ilims", "ailmins", "ilejs", "illfs", "filmm", "ilemins", "filfs", "ilmb", "ilfs", "utilmn", "bilkes", "filjs", "ilimb", "ilins", "utilems", "tilfs", "ailm", "ilens", "ailmes", "utilmm", "ilmes", "tilms", "ailns", "kilws", "filns", "ilns", "utilmb", "filmins", "bilms", "kilns", "ilim", "ailbs", "ilmins", "illms", "iljs", "utilns", "ilsms", "ilsbs", "utilmos", "ailvs", "illns", "filkes", "ilefs", "films", "tilmos", "ailems", "ailfs", "ailml", "ileems", "tilns", "filmn", "illmes", "ilimes", "ialbs", "bilmes", "ilem", "ilivs", "ilvs"], "input": ["ec", "data", "image", "initial", "q", "inner", "head", "op", "iq", "shift", "c", "view", "up", "text", "before", "img", "init", "inf", "select", "p", "read", "index", "out", "act", "bit", "i", "x", "unknown", "expression", "form", "cont", "this", "it", "history", "config", "ip", "output", "local", "ch", "update", "error", "w", "command", "Input", "ind", " inputs", "get", "ix", "val", "empty", "in", "current", "rc", "missing", "raw", "hidden", "state", "yet", "not", "cmd", "supp"], "pred": ["proc", "ved", "br", "cod", "false", "ff", "ched", "prop", "tmp", "buf", "next", "p", "fitted", "reported", "dict", "prep", "inf", "tip", "ref", "neg", "rib", "rect", "bed", "act", "fed", "red", "orig", "hist", "valid", "ok", "def", "RED", "req", "history", "pr", "vec", "iv", "ed", "sub", "err", "ptr", "xx", "Pred", "cond", "ob", "ind", "ped", "post", "med", "ied", "reg", "bo", "val", "pre", "fail", "rend", "selected", "binary", "repl", "rep", "redict", "cmd", "buff"], "icoef": ["ciffe", "ericefficient", "BOefficient", "icoalf", "icoffee", "ericEF", "icalf", "icefe", "icoffe", "iceff", "loeffee", "kiefe", "loeefer", "eroefficients", "BOelf", "ICOeph", "imiffee", "icef", "eroef", "soefficient", "stroek", "imiek", "Coelf", "icaEF", "icefficient", "cief", "ICOef", "ICOEF", "ICOefe", "icieff", "icioefficients", "icoefer", "icaeff", "coeefficient", "soeff", "ICOefficient", "imiefer", "icioef", "icioeless", "cif", "imiefined", "imief", "coeEF", "icoelf", "icaffe", "stroefined", "cieff", "Coefficient", "ICOeff", "icaf", "nicffee", "ericef", "ckiffee", "kieff", "icoeph", "loeeval", "icoefficients", "ciec", "soef", "coalf", "ericefficients", "coffe", "coeefficients", "ciefer", "ciefined", "ICOelf", "imieless", "ciek", "icoec", "stroefer", "icoefe", "soefe", "ciEF", "niceph", "niceff", "cielf", "icoEF", "coffee", "icaelf", "coEF", "coeef", "ckieless", "stroef", "Coeff", "loeeless", "icoeff", "icioeval", "cof", "icaec", "icoefficient", "ckiefer", "ICOffee", "nicef", "icof", "kief", "loeef", "eroeless", "icoeval", "Coef", "iciffee", "coef", "icief", "icoeless", "ICOefficients", "BOef", "coefficient", "icieph", "icoefined", "ckief", "kiEF", "icffee", "icaef", "coefe", "BOeff", "ICOec", "icoek", "cialf", "eroeval", "ciffee", "loeefficients", "coeff"], "cdlms": ["cdlems", "condlmp", "cdlmos", "chardlmt", "cdllmos", "cdlmt", "condlms", "cddlns", "cdlnems", "cdleftens", "cdlns", "cplml", "cdllmop", "ecdlims", "casleftmn", "cdlljs", "cdlocmop", "cdlmp", "cdnlmn", "codlfs", "cdlbmos", "cdlimes", "ecdlmop", "cmdlts", "xdnlts", "cdllmes", "chardlks", "cdlinjs", "chardlcs", "ctnlts", "cdlinmes", "cdlnmes", "cdllces", "cdlks", "eddlnmn", "eddlnms", "cdlbms", "cdlcjs", "ecdlcs", "ecdlics", " cdlmodules", "ctlfs", "cdllarms", "cplbmos", "cdnlml", "cdlnmm", "cdnlms", "cdliens", "cdlbml", "cmdlces", "codlbvs", "cdlymop", "ctnlms", "cdlinms", "codnlems", "cddelems", "cdlics", "cdlitms", "cdllfs", "codlpmes", "cdlivs", "rodladms", "cdlmes", "cdlpms", " cdlcs", "cdlnmn", "ecdlts", "cdlens", "cddlmes", "cdlits", "cdlimn", "casleftens", "cdliems", "condladms", "chardlms", "condladmp", "cdllms", "cdlbfs", "codlvs", "ctlmos", "cdlnms", "cdlinmt", "cplbts", "cdlifs", "cdlincs", "cddelms", " cdllems", "cdlts", "cmdelmes", "cdladms", "xdnlems", "caslmodules", "cdoljs", "codlpjs", "chardlocmn", "codlbfs", "eddlns", "chardlitmn", "cplbms", "cdlimop", " cdllms", "cdlbwe", "cdnlmt", "codlems", "cddelts", "codlqs", "rodlts", "cdlitens", "cdelms", "cdelmes", "cdlcts", "cdlvs", "cplmos", "cdllmodules", "ecdlms", "ctnlfs", "cdnlfs", "cdlims", " cdllcs", "cdlymn", "cdladmes", "cdlcs", "eddlms", "cdlnmp", "cddlts", "cdlinkes", "cdnlmos", "cplms", "cddlqs", "cdolmos", "cdnlmes", "ctnlmos", "cdlml", "cdladmp", "rodlarms", "cdolmes", "caslmn", "cdelts", "cdnlvs", "cdnlmm", "cdolms", "casleftms", "cdlpkes", "eddlnns", "cmdlmes", " cdllts", "cddlems", "cdlitcs", "cdlfs", " cdlts", "cdladml", "chardlmop", "condladmes", "cdolems", "ctlts", "cdnlqs", "cdlitmodules", "cdlcems", "cdladarms", "cmdelms", "codlwe", "cddelmodules", "cdlbvs", "chardlitcs", "caslens", "codlbwe", "cdleftms", "cdnlns", "condlmm", "cdlocmn", " cdllmos", "cdleftmodules", "cdnlmp", "cdnlems", "caslms", "cdolts", " cdlmos", "cddlmn", "rodlms", "ctlms", "cdolkes", "cdlwe", "cdlmm", "cdnlarms", "chardlmn", "xdlems", "rodlml", "cdladmm", "cdlocks", "cdlmop", "cmdlms", "cdlices", "cdnljs", "cdljs", "cddlms", " cdllmodules", "xdlms", " cdlems", "rodladarms", "cdnlts", "cdlyks", "cdlnns", " cdljs", "chardlitmt", "codlkes", "cmdelces", "chardlitms", "codnlmes", "cdnlmodules", "rodladml", "cmdelts", "cdlcmn", "cdlocms", "cdlmn", "cdladts", "cdliwe", "cdllems", "cdllcs", "cdlinmn", "cdlpjs", "eddlems", "cdlitmt", "cdlbts", "cdlkes", "cdlarms", " cdlljs", "cdlqs", "rodladts", "xdlts", "cdlcks", "chardlocmop", "cdliqs", "cdlitmn", "cdnlwe", "codlbms", "cdlpmes", "codlpms", "chardlocms", "cplbml", "condlmes", "cdnlcs", "ecdlimop", "condladmm", "ecdlits", "cdlcms", "codlmes", "codlms", "eddlnems", "xdnlmodules", "cdleftmn", "cdllts", "cdlcmop", "codljs", "codnlqs", "cddlcs", "cdlyms", "cplts", "codlpkes", "cdlces", "chardlocks", "eddlmn", "cdlmodules", "casleftmodules", "codnlms", "cdelces", "xdnlms", "cdllml", "cddlmop", "cdlimodules", "xdlmodules"], "recent": ["parent", "historic", "component", "released", "only", "genre", "window", "order", "server", "off", "req", "foreign", "version", "prime", "available", "chance", "trial", "modern", "rend", "done", "recorded", "sofar", "this", "domain", "head", "high", "dist", "reverse", "ready", "serial", "valid", "unique", "known", "final", "rec", "sid", "random", "remote", "range", "depth", "when", "ident", "max", "quant", "rar", "cas", "device", "rest", "record", "custom", "major", "progress", "rank", "res", "Recent", "new", "ord", "history", "many", "save", "one", "priority", "client", "ient", "current", "rem", "cmd", "common", "success", "created", "today", "org", "times", "after", "important", "quick", "confirmed", "tar", "dom", "desc", "critical", "command", "release", "region", "reg", "good", "latest", "raw", "store", "feat"]}}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n\n                         const char *filt_name, const char *args, AVClass *log_ctx)\n\n{\n\n    AVFilter *filt;\n\n    char inst_name[30];\n\n    char tmp_args[256];\n\n    int ret;\n\n\n\n    snprintf(inst_name, sizeof(inst_name), \"Parsed filter %d %s\", index, filt_name);\n\n\n\n    filt = avfilter_get_by_name(filt_name);\n\n\n\n    if (!filt) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"No such filter: '%s'\\n\", filt_name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ret = avfilter_open(filt_ctx, filt, inst_name);\n\n    if (!*filt_ctx) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error creating filter '%s'\\n\", filt_name);\n\n        return ret;\n\n    }\n\n\n\n    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n\n        avfilter_free(*filt_ctx);\n\n        return ret;\n\n    }\n\n\n\n    if (!strcmp(filt_name, \"scale\") && !strstr(args, \"flags\")) {\n\n        snprintf(tmp_args, sizeof(tmp_args), \"%s:%s\",\n\n                 args, ctx->scale_sws_opts);\n\n        args = tmp_args;\n\n    }\n\n\n\n    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error initializing filter '%s' with args '%s'\\n\", filt_name, args);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3721, "substitutes": {"filt_ctx": ["filt__ct", "fil_obj", "fil_tx", "filt2tx", "ffilter_cp", "ffilter_context", "facet_tx", "fil_cp", "filt_obj", "filt2ctx", "flt_tx", "filt__tx", "filt_cfg", "facet_ctx", "filt_cas", "flt_ctx", "fld_conn", "filt_parent", "facet_parent", "filt_ct", "fld_tx", "filt_conn", "fld_ctx", "flt_context", "filt_pkg", "filt_tx", "filt__ctx", "filt_context", "filt__conn", "ffilter_cas", "filt_cp", "facet_cfg", "flt_obj", "fil_pkg", "fil_context", "ffilter_ctx", "filt2context", "filt2obj", "fil_ctx", "fld_ct"], "ctx": ["sys", "cp", "ctr", "jp", "handle", "bc", "unc", "conn", "g", "hw", "window", "np", "txt", "xs", "cfg", "comm", "cb", "act", "pg", "x", "tx", "kt", "sc", "gt", "tm", "req", "history", "config", "ctl", "kw", "cf", "context", "cv", "xp", "grad", "gc", "pkg", "pt", "cc", "nt", "ct", "cmd", "gs", "Context", "mem", "tc", "jac", "obj", "graph"], "index": ["batch", "image", "id", "number", "size", "status", "count", "row", "n", "ref", "result", "order", "open", "iter", "set", "i", "x", "num", "find", "start", "info", "valid", "new", "run", "param", "update", "error", "context", "name", "ion", "con", "ind", "offset", "val", "connect", "address", "si", "thread", "point", "Index", "len", "sp"], "filt_name": ["filtPname", "facetOnode", "filt_label", "ffilter_Name", "fld_name", "fitt_Name", "filtetricold", "filt_old", "fil_name", "filt2Name", "filt_prefix", "filtOnode", "filtOkey", "filt_data", "fitt_old", "ffilter2prefix", "filt_key", "ffilter_type", "fartz_key", "filtetricname", "filt__Name", "facetOname", "filt09title", "filt_title", "filt09label", "ffilter2Name", "ffilter_prefix", "fartzOtree", "fartz_tree", "fil_type", "filtPtype", "filt09type", "filtOlabel", "facet_node", "filtPref", "facet_path", "filt09tree", "filt_path", "fartzOlabel", "filt_type", "filtPcache", "filtetricuser", "fitt_name", "ffilter2name", "filt_tree", "filt2name", "fartzOkey", "fitt_cache", "fitt_ref", "filt_user", "filt09name", "facetOpath", "fitt_user", "filtetricName", "ffilter2type", "filt__name", "facet_Name", "fartzOname", "ffilter_name", "filtOpath", "fld_data", "fartz_label", "filt09key", "filtOName", "facetOName", "fitt_type", "filt__path", "facet_name", "filt_Name", "fld_Name", "filt_node", "filt__node", "fartz_name", "filtOtree", "filt2prefix", "fil_title", "filt_cache", "filtOname", "filt2type", "filt_ref"], "args": ["values", "rows", "aux", "stats", "func", "atts", "arr", "outs", "limits", "actions", "settings", "cards", "vs", "names", "xs", "weights", "cfg", "options", "ds", "qs", "utils", "vals", "params", "locks", "fs", "fields", "members", "ps", " arguments", "parts", "js", "bs", "tags", "ns", "docs", "ims", "flags", "amps", "terms", "ts", "cs", "points", "keys", "changes", "types", "tests", "GS", "ags", "bytes", "GV", "bits", "posts", "results", "gs", "arg", "ins", "items", "cmd", "Args"], "log_ctx": ["logingcrit", "logitycss", "blog_conn", "blog_ctx", "log2obj", "basetcrit", "blog_js", "logtctx", "logingcss", " log2tx", "base_cp", " log_obj", " log_context", "loglyjs", "blog_tx", "prop_ctx", "log_conn", "logingctx", "logityctx", "log2tx", " log2context", "logingcf", "loglyctx", "basetcf", "logtcp", "base_crit", " log2ctx", "logingnz", "base_ctx", " log_tx", "log_crit", "logingcp", "logitynz", "log_obj", "basetctx", "logingconn", "base_cf", "logtcf", "prop_nz", "loglyconn", " log2obj", "loglytx", "log_css", "log_cf", "log2context", "log_tx", "log_context", "prop_css", "logtcrit", "log_js", "log2ctx", "log_cp", "log_nz", "logityconn", "basetcp", "prop_conn"], "filt": ["tlt", "bfil", "fil", "faciltration", "faclt", "bilt", "flil", " fitt", "facitt", "hiber", "bil", "Fiber", "ffil", "fril", "fliltration", "firm", "Filt", "facirm", "vil", "frfil", "Ffil", "friltration", " filtration", "biber", " firm", "facil", "tilt", "filtration", " flt", " ffil", "vilt", "frilt", "facilt", "titt", "flilt", "hil", "flirm", "hfil", "viltration", "vfil", "hilt", "til", "flt", "Fil", "fiber", "fitt", " fil"], "inst_name": ["instance_NAME", "inst___names", "inst__name", "inst__Name", "instance_nam", " inst_key", "inst_NAME", "instance_Name", " inst_Name", "inst_names", " inst_names", "inst__key", "instance_name", "inst_nam", "inst___Name", "inst___nam", "inst_key", " inst_NAME", "inst___name", "inst_id", "inst_Name", "inst__names", " inst_id", "instance_names"], "tmp_args": ["tmp67arg", "tmp_igs", "tmp2arg", "tmp_params", "temp_weights", "temp_params", "tmp_err", "tmp67len", "tmp_weights", "tmp_results", "ppo___lines", "tmp_xs", "tmp__results", "tmp2args", "tmp__lines", "emp_igs", "tmp___args", "ppo___results", "ppo___args", "tmp__weights", "tmp_lines", "emp_args", "tmp67weights", "ppo_weights", "temp_xs", "tmp__args", "tmp___weights", "tmp67params", "ppo_lines", "tmp2params", "emp_flags", "ppo___weights", "tmp2len", "tmp___results", "tmp_len", "ppo_results", " tmp_len", "tmp67xs", "tmp___lines", "tmp_arg", " tmp_arg", "emp_err", " tmp_params", "tmp_flags", "temp_args", "tmp67args", "ppo_args"], "ret": ["mt", "j", "usr", "RET", "jump", "cert", "net", "et", "func", "status", "il", "value", "arr", "addr", "count", "Return", "ext", "nl", "ref", "result", "txt", "deg", "progress", "out", "res", "fin", "lit", "ft", "cont", "gt", "ll", "it", "def", "att", "Ret", " Ret", "mel", "vet", "gc", "pas", "rt", "alt", "re", "rev", "del", "print", "reg", "val", "last", "rets", "rm", "nt", "ry", "hash", "pret", "rel", "f", "det", "reset", "flag", "reflect", "rem", "elt", "t", "resp", "back", "len", "cmd"]}}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_mclms(WmallDecodeCtx *s)\n\n{\n\n    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;\n\n    s->mclms_scaling = get_bits(&s->gb, 4);\n\n    if(get_bits1(&s->gb)) {\n\n\t// mclms_send_coef\n\n\tint i;\n\n\tint send_coef_bits;\n\n\tint cbits = av_log2(s->mclms_scaling + 1);\n\n\tassert(cbits == my_log2(s->mclms_scaling + 1));\n\n\tif(1 << cbits < s->mclms_scaling + 1)\n\n\t    cbits++;\n\n\n\n\tsend_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;\n\n\n\n\tfor(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {\n\n\t    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);\n\n\t}\n\n\n\n\tfor(i = 0; i < s->num_channels; i++) {\n\n\t    int c;\n\n\t    for(c = 0; c < i; c++) {\n\n\t\ts->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);\n\n\t    }\n\n\t}\n\n    }\n\n}\n", "idx": 3722, "substitutes": {"s": ["sys", "ls", "j", "S", "stats", "status", "sg", "is", "sv", "ss", "p", "ast", "als", "n", "service", "vs", "details", "plays", "ses", "comm", "set", "ds", "qs", "ants", "fs", "less", "gets", "tes", "aws", "services", "reads", "ps", "its", "parts", "js", "ns", "ears", "bs", "sw", "conf", "y", "sac", "ims", "ms", "as", "ports", "cs", "ts", "spec", "changes", "bes", "hs", "sts", "eps", "rs", "v", "ows", "results", "gs", "ats", "sb", "ins", "sq", "so", "os", "serv", "se", "ops"], "i": ["id", "p", "n", "init", "ish", "li", "x", "us", "k", "iu", "ti", "ind", "uri", "ix", "zi", "h", "ini", "I", "f", "this", "batch", "q", "xi", "ic", "qi", "m", "ui", "it", "ims", "im", "integer", "io", "\u0438", "ri", "length", "chain", "j", "l", "ii", "iri", "ji", "to", "pi", "index", "me", "asi", "ci", "ei", "phi", "ij", "y", "bi", "hi", " I", "v", "mi", "di", "ai", "si", "point", "multi", "ki", "pc", "is", "sim", "g", "ami", "b", "cli", "gi", "ip", "oi", "ie", "print", "in", "o", "t"], "send_coef_bits": ["send_coefficients_pins", "send_coff_bs", "send_coef__bs", "send_coeff_pins", "send_coff_its", "send_coefficients_bytes", "send_coff_bit", "send_coiff_ats", "send_coef_bytes", "send_coef_ats", "send_coeff_bytes", "send_coef__bits", "send_coefficients_its", "send_coef_its", "send_coeff_bs", "send_coiff_bs", "send_coefficients_bits", "send_coef__bytes", "send_coeff_bits", "send_coef_bs", "send_coef_bit", "send_coiff_bits", "send_coiff_bit", "send_coef__its", "send_coef_pins", "send_coef__pins", "send_coff_bits"], "cbits": ["xcbits", "lclevels", "pcots", "clocks", "cononds", "gcbits", "cuplugins", "cuboxes", " clocks", "pcdates", "cnets", "cfouts", "lcpieces", "conbits", "conbis", "pcbits", "clevels", "cplugins", "lcnets", "pcpieces", "cflags", "cboxes", "conbps", "cinets", "pcnets", "cbps", "lcplugins", "pcflags", "lconds", "conds", "lcdates", "gcits", "cflevels", "xcots", "ucplugins", "cfbits", "ciouts", "ucbits", "lcbits", "xcflags", "cibits", "ucboxes", "xcbis", "cots", "xconds", "cilevels", "lcits", "lcflags", " cflags", "cubits", " cpieces", "gcplugins", "cfnets", "lcbps", "lcots", "cpieces", "xcnets", " cits", "lcouts", "lclocks", " cdates", " cboxes", "xcbps", "cdates", "lcbis", "couts", "cbis", "gclocks", " cplugins", "cits"], "c": ["ec", "d", "cp", "q", "j", "cat", "cr", "cd", "l", "fc", "add", "pc", "count", "bc", "nc", "xc", "unc", "z", "g", "n", "dc", "uc", "ic", "r", "ca", "ci", "m", "b", "inc", "u", "ce", "C", "cont", "cache", "call", "k", "cf", "tc", "cv", "cs", "con", "co", "gc", "v", "\u00e7", "cu", "cc", "h", "ct", "col", "f", "cm", "lc", "ac", "t", "mc", "chain"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void ppc_spapr_init(ram_addr_t ram_size,\n                           const char *boot_device,\n                           const char *kernel_filename,\n                           const char *kernel_cmdline,\n                           const char *initrd_filename,\n                           const char *cpu_model)\n{\n    PowerPCCPU *cpu;\n    CPUPPCState *env;\n    int i;\n    MemoryRegion *sysmem = get_system_memory();\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    target_phys_addr_t rma_alloc_size, rma_size;\n    uint32_t initrd_base = 0;\n    long kernel_size = 0, initrd_size = 0;\n    long load_limit, rtas_limit, fw_size;\n    long pteg_shift = 17;\n    char *filename;\n    spapr = g_malloc0(sizeof(*spapr));\n    QLIST_INIT(&spapr->phbs);\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n    /* Allocate RMA if necessary */\n    rma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);\n    if (rma_alloc_size == -1) {\n        hw_error(\"qemu: Unable to create RMA\\n\");\n        exit(1);\n    }\n    if (rma_alloc_size && (rma_alloc_size < ram_size)) {\n        rma_size = rma_alloc_size;\n    } else {\n        rma_size = ram_size;\n    }\n    /* We place the device tree and RTAS just below either the top of the RMA,\n     * or just below 2GB, whichever is lowere, so that it can be\n     * processed with 32-bit real mode code if necessary */\n    rtas_limit = MIN(rma_size, 0x80000000);\n    spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n    spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\n    load_limit = spapr->fdt_addr - FW_OVERHEAD;\n    /* init CPUs */\n    if (cpu_model == NULL) {\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n    }\n    for (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_ppc_init(cpu_model);\n        if (cpu == NULL) {\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n            exit(1);\n        }\n        env = &cpu->env;\n        /* Set time-base frequency to 512 MHz */\n        cpu_ppc_tb_init(env, TIMEBASE_FREQ);\n        qemu_register_reset(spapr_cpu_reset, cpu);\n        env->hreset_vector = 0x60;\n        env->hreset_excp_prefix = 0;\n        env->gpr[3] = env->cpu_index;\n    }\n    /* allocate RAM */\n    spapr->ram_limit = ram_size;\n    if (spapr->ram_limit > rma_alloc_size) {\n        ram_addr_t nonrma_base = rma_alloc_size;\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n        memory_region_init_ram(ram, \"ppc_spapr.ram\", nonrma_size);\n        vmstate_register_ram_global(ram);\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n    }\n    /* allocate hash page table.  For now we always make this 16mb,\n     * later we should probably make it scale to the size of guest\n     * RAM */\n    spapr->htab_size = 1ULL << (pteg_shift + 7);\n    spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size);\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->external_htab = spapr->htab;\n        env->htab_base = -1;\n        env->htab_mask = spapr->htab_size - 1;\n        /* Tell KVM that we're in PAPR mode */\n        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |\n                             ((pteg_shift + 7) - 18);\n        env->spr[SPR_HIOR] = 0;\n        if (kvm_enabled()) {\n            kvmppc_set_papr(env);\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n                                           rtas_limit - spapr->rtas_addr);\n    if (spapr->rtas_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n    }\n    g_free(filename);\n    /* Set up Interrupt Controller */\n    spapr->icp = xics_system_init(XICS_IRQS);\n    spapr->next_irq = 16;\n    /* Set up VIO bus */\n    spapr->vio_bus = spapr_vio_bus_init();\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n    }\n    /* Set up PCI */\n    spapr_create_phb(spapr, \"pci\", SPAPR_PCI_BUID,\n                     SPAPR_PCI_MEM_WIN_ADDR,\n                     SPAPR_PCI_MEM_WIN_SIZE,\n                     SPAPR_PCI_IO_WIN_ADDR);\n    for (i = 0; i < nb_nics; i++) {\n        NICInfo *nd = &nd_table[i];\n        if (!nd->model) {\n            nd->model = g_strdup(\"ibmveth\");\n        }\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n            spapr_vlan_create(spapr->vio_bus, nd);\n        } else {\n            pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n        }\n    }\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n    }\n    if (rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n        exit(1);\n    }\n    fprintf(stderr, \"sPAPR memory map:\\n\");\n    fprintf(stderr, \"RTAS                 : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->rtas_addr,\n            (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n    fprintf(stderr, \"FDT                  : 0x%08lx..%08lx\\n\",\n            (unsigned long)spapr->fdt_addr,\n            (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n    if (kernel_filename) {\n        uint64_t lowaddr = 0;\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename,\n                                              KERNEL_LOAD_ADDR,\n                                              load_limit - KERNEL_LOAD_ADDR);\n        }\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n            exit(1);\n        }\n        fprintf(stderr, \"Kernel               : 0x%08x..%08lx\\n\",\n                KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n        /* load initrd */\n        if (initrd_filename) {\n            /* Try to locate the initrd in the gap between the kernel\n             * and the firmware. Add a bit of space just in case\n             */\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                                              load_limit - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n                        initrd_filename);\n                exit(1);\n            }\n            fprintf(stderr, \"Ramdisk              : 0x%08lx..%08lx\\n\",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n    if (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    g_free(filename);\n    fprintf(stderr, \"Firmware load        : 0x%08x..%08lx\\n\",\n            0, fw_size);\n    fprintf(stderr, \"Firmware runtime     : 0x%08lx..%08lx\\n\",\n            load_limit, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    /* SLOF will startup the secondary CPUs using RTAS */\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->halted = 1;\n    }\n    /* Prepare the device tree */\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            boot_device, kernel_cmdline,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}", "idx": 3731, "substitutes": {"ram_size": ["RAM_space", "ram_space", "ram_length", "gram_SIZE", "RAM_SIZE", "gram_name", "ramaxyname", "RAM_length", "RAM_size", "ram_addr", "ramaxysize", "RAM_name", "ram_name", "gram_addr", "gram_size", "ramaxySIZE", "ramaxyaddr", "RAM_addr", "ram_SIZE"], "boot_device": ["bootabledirectory", "boot_address", "boot_directory", "bootabledev", "kernelabledev", "kernel_dev", "kernel_directory", "kernelabledevice", "bootableaddress", "kernelableaddress", "kernelabledirectory", "kernel_address", "bootabledevice", "kernel_device", "boot_dev"], "kernel_filename": [" kernel_file", " kernel___device", " kernel___file", "kernel___file", "kernel___directory", " kernel_device", "kernel_file", " kernel_directory", "kernel_directory", "kernel___device", " kernel___directory", " kernel___filename", "kernel___filename", "kernel_device"], "kernel_cmdline": ["kernel_extline", "kernel_commandlines", "kernel_extlines", "kernel_cpline", "kernel_cplines", "kernel_commandline", "kernel_cpfile", "kernel_cmdlines", "kernel_commandfile", "kernel_extfile", "kernel_cmdfile"], "initrd_filename": ["initrd_file", "initrd__filename", "initrd__file", "initrd_fn", "initrd_location", "initrd__location", "initrb_file", "initrb_filename", "initrb_location", "initrd__fn", "initrb_fn"], "cpu_model": ["cpuitycondition", "cpu_config", " cpu_models", "cpuaxybase", "cpuaxycondition", "cpu__library", "cpu_Model", "cpu_models", "desktopaxycondition", "cpuityModel", "cpu_policy", "desktopaxymodel", "cpuaxyModel", "cpu__models", "cpumypolicy", "cpumylabel", "cpuitybase", " cpu_link", "cpuetymodel", "cpumyModel", "cpumymodel", "desktop_base", "cpu_base", " cpu_config", "desktop_Model", "cpuetymodels", " cpu_Model", "cpu_condition", "cpu_library", " cpu_library", "desktop_model", "cpu_label", "desktopaxyModel", " cpu_base", "cpuetybase", "cpu__model", " cpu_label", "cpuetylibrary", "cpu__base", "desktop_condition", " cpu_policy", "desktopaxybase", "cpuitymodel", "cpuaxymodel", "cpu_link"], "cpu": ["proc", "core", "php", "ka", "cp", "bean", "alloc", "efficiency", "aux", "pc", "c", "cn", "uda", "chip", "conn", "stat", "pu", "docker", "hw", "gpu", "CPU", "util", "node", "processor", "mx", "cli", "linux", "cache", "cow", "mu", "python", "uart", "vm", "cum", "cam", "ctx", "aco", "nic", "ruby", "computer", "anc", "gc", "apache", "runner", "mac", "ola", "clock", "cu", "uu", "process", "nu", "worker", "java", "mem", "kernel"], "env": ["proc", "ec", "ework", "inst", "net", "er", "buf", "gear", "ext", "sv", "next", "conn", "ent", "term", "init", "ev", "attr", "window", "hw", "vs", "server", "cfg", "vt", "viron", "dem", "exc", "environment", "ei", "esc", "em", "nv", "eni", "eg", "entry", "priv", "dev", "ef", "config", "eu", "shell", "scope", "conf", "context", "e", "ptr", "en", "ea", "ctx", "emb", "esp", "v", "console", "ew", "uv", "screen", "state", "mem", "obj", "eng", "Environment"], "i": ["multi", "batch", "j", " m", "ii", "status", "tim", " mi", "c", " j", "p", "sim", "xi", "pi", "index", "me", "li", "ci", " di", "ami", " c", "sql", "m", " e", "ei", "x", "eu", "cli", "us", "ui", " vi", "info", "gi", "phi", "it", "ex", " ti", " si", "ip", " ii", " index", "y", " pi", "gu", "ims", "bi", "im", "e", "iu", "ti", " I", "ix", "in", " ni", "mi", "di", "ini", "ai", "I", "si", " multi", " bi"], "sysmem": ["skymb", "sysmb", "systemmem", "skyram", "skymemory", " sysmemory", "ysmb", "ysmem", "sysram", " sysram", "sysmemory", "ysmemory", "systemmemory", " sysmb", "skymem", "systemram", "ysram"], "ram": ["ma", "mb", "ro", "rom", "iam", "row", "memory", "res", "sum", "ra", "dev", "gram", "vm", "disk", "cam", "sam", "RAM", "rum", "region", "reg", "mm", "am", "range", "dim", "rem", "mem", "tem", "gra"], "rma_alloc_size": ["rma_alloc2name", "rma_cmp_size", "rma_alloc2addr", "rma_alloc_sum", "rma_pos_set", "rma_mem_size", "rma_max_sum", "rma_oc_name", "rma_allocavsum", "rma_alloc_count", "rma_mem_num", "rma_alloc_num", "rma_allocavlen", "rma_allocxnumber", "rma_cmp_number", "rma_allocxsum", "rma_pos_SIZE", "rma_allocxlen", "rma_allocavsize", "rma_max_name", "rma_mem_name", "rma_alloc2sum", "rma_alloc_storage", "rma_alloc_SIZE", "rma_alloc_number", "rma_alloc_name", "rma_alloc2num", "rma_cmp_sum", "rma_oc_count", "rma_oc_SIZE", "rma_alloc_len", "rma_alloc2size", "rma_oc_size", "rma_max_size", "rma_alloc_addr", "rma_mem_addr", "rma_alloc_set", "rma_cmp_len", "rma_allocavnumber", "rma_pos_size", "rma_allocxsize"], "rma_size": ["rma00export", "rMA_limit", "rva00export", "rma00size", "rva00size", "rma___size", "rma_export", "rva_gz", "rma_align", "rma_scale", "rma___gz", "rva_size", "rma_limit", "rota_handle", "rota_size", "rMA_max", "rva00gz", "rma_handle", "rota_scale", "rma_diff", "rms_Size", "rMA_size", "rMA_scale", "rmaaxysize", "rma00align", "rms_length", "rma_max", "rma___align", "rma_Size", "rva_align", "rma00gz", "rva_export", "rma_gz", "rva00align", "rms_diff", "rms_size", "rmaaxyhandle", "rma___export", "rmaaxyscale", "rma_length"], "load_limit": ["Load_length", "download_lim", "download_delay", "Load_limit", "download_margin", "load_policy", "load_margin", "Load_policy", "load_delay", "download_limit", "Load_size", "load_size", "load_length", "load_lim"], "rtas_limit": ["rtas__limit", "rtas_range", "rtas48wrapper", "rtas____size", "rtaos____offset", "rtAs_offset", "rtras_range", "rtras_limit", "rtAs_limit", "rtas____wrapper", "rtas_filter", "rtaos_limit", "rtaos____filter", "rtas48offset", "rtaos____wrapper", "rtas_offset", "rtas__offset", "rtaos____limit", "rtaszsize", "rtas____range", "rtas_block", "rtas12limit", "rtAs_block", "rtas12offset", "rtas_ignore", "rtaos_wrapper", "rtas____ignore", "rtras_ignore", "rtas__size", "rtas____limit", "rtas48filter", "rtAs_size", "rtas_size", "rtas48limit", "rtas____offset", "rtras_size", "rtas____filter", "rtaos_filter", "rtas_wrapper", "rtaszlimit", "rtaos_offset", "rtaszignore", "rtas12filter", "rtas__block", "rtas12wrapper", "rtaszrange"], "fw_size": ["hw_SIZE", "fw_info", "fw_SIZE", "hw_info", "hw_size", "hw_Size", "fw_Size"], "filename": ["fp", "fw", "ename", "files", "wire", "fle", "kj", "kl", "txt", "params", "ame", "fs", "family", "location", "kw", "file", "username", "metadata", "buffer", "nm", "framework", "Filename", "src", "fn", "prefix", "socket", "json"]}}
{"project": "FFmpeg", "commit_id": "69d0a2922f76e4e121c9f434bdf29f55b26c0c66", "target": 0, "func": "static av_cold int sonic_encode_init(AVCodecContext *avctx)\n\n{\n\n    SonicContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    int i, version = 0;\n\n\n\n    if (avctx->channels > MAX_CHANNELS)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo streams are supported by now\\n\");\n\n        return AVERROR(EINVAL); /* only stereo or mono for now */\n\n    }\n\n\n\n    if (avctx->channels == 2)\n\n        s->decorrelation = MID_SIDE;\n\n    else\n\n        s->decorrelation = 3;\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)\n\n    {\n\n        s->lossless = 1;\n\n        s->num_taps = 32;\n\n        s->downsampling = 1;\n\n        s->quantization = 0.0;\n\n    }\n\n    else\n\n    {\n\n        s->num_taps = 128;\n\n        s->downsampling = 2;\n\n        s->quantization = 1.0;\n\n    }\n\n\n\n    // max tap 2048\n\n    if ((s->num_taps < 32) || (s->num_taps > 1024) ||\n\n        ((s->num_taps>>5)<<5 != s->num_taps))\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of taps\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    // generate taps\n\n    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));\n\n    for (i = 0; i < s->num_taps; i++)\n\n        s->tap_quant[i] = ff_sqrt(i+1);\n\n\n\n    s->channels = avctx->channels;\n\n    s->samplerate = avctx->sample_rate;\n\n\n\n    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);\n\n    s->frame_size = s->channels*s->block_align*s->downsampling;\n\n\n\n    s->tail_size = s->num_taps*s->channels;\n\n    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));\n\n    if (!s->tail)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );\n\n    if (!s->predictor_k)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < s->channels; i++)\n\n    {\n\n        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));\n\n        if (!s->coded_samples[i])\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));\n\n\n\n    s->window_size = ((2*s->tail_size)+s->frame_size);\n\n    s->window = av_calloc(s->window_size, sizeof(*s->window));\n\n    if (!s->window)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->extradata = av_mallocz(16);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&pb, avctx->extradata, 16*8);\n\n\n\n    put_bits(&pb, 2, version); // version\n\n    if (version == 1)\n\n    {\n\n        put_bits(&pb, 2, s->channels);\n\n        put_bits(&pb, 4, code_samplerate(s->samplerate));\n\n    }\n\n    put_bits(&pb, 1, s->lossless);\n\n    if (!s->lossless)\n\n        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision\n\n    put_bits(&pb, 2, s->decorrelation);\n\n    put_bits(&pb, 2, s->downsampling);\n\n    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024\n\n    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table\n\n\n\n    flush_put_bits(&pb);\n\n    avctx->extradata_size = put_bits_count(&pb)/8;\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\",\n\n        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);\n\n\n\n    avctx->frame_size = s->block_align*s->downsampling;\n\n\n\n    return 0;\n\n}\n", "idx": 3743, "substitutes": {"avctx": ["avconn", "avectx", "ajcmp", "afjp", "aveconf", "avercontext", "avejp", "avjac", "afconf", "avertx", "ajnp", "ajbc", "vrpkg", "avpkg", "abtc", "avecontext", "avecm", "avercu", "avebc", " avnp", "wavcmp", "avercfg", "avercp", "wavtx", "avnp", "avercpu", "avtx", "avcu", "ajcu", "ajtx", "ajctx", "abctx", "avbc", "avercm", " avcontext", "ajconn", "avecmp", "ajjac", "avecpu", "avecv", "averjp", "aftx", "ajconf", "avconf", "avertc", "averresp", "abcv", "vrcmp", "avecu", "averesp", "avepkg", "wavpkg", "avtc", "avercv", "avetx", "wavctx", "avcp", "vrtx", "abtx", "afcmp", " avconn", "avcfg", "afcm", "savctx", "avresp", " avcp", " avcmp", "vrctx", "avjp", "aveconn", "savconn", "afcp", " avtc", "afctx", "avecp", "avejac", "savcontext", "abcontext", "avercmp", "avecfg", "avenp", "averconn", " avtx", "averctx", "avcpu", "abcpu", "ajcfg", "avcv", "avcontext", "afjac", "avcm", "savcp", " avbc", "avcmp", "afresp"], "s": ["ls", "c", "scl", "p", "es", "ses", "set", "services", "its", "ports", "cs", "spec", "ies", "h", "gs", "his", "sb", "args", "so", "os", "mods", "stats", "sv", "actions", "settings", "vs", "details", "xs", "ers", "ds", "qs", "m", "ants", "less", "reads", "bs", "tags", "ims", "bis", "hs", "ar", "sts", "eps", "pers", "ins", "states", "sq", "self", "j", "S", "l", "sets", "ss", "als", "sl", "sa", "comm", "utils", "locks", "tes", "views", "ns", "sw", "ms", "ts", "changes", "v", "tests", "results", "uploads", "rates", "se", "ops", "sys", "scripts", "status", "is", "g", "ids", "fs", "aws", "ps", "parts", "js", "ads", "comments", "w", "terms", "as", "sports", "rs", "ows", "bits", "ats", "t", "obj"], "pb": [" proto", " pc", " pat", " ns", " sp", "p", " cp", " pa", "bp", " sk", " subp", " pl", " np", " mp", " tmp", " pos", " tf", " cl", " prob", " sc", " salsa", " p", " ap", " clip", " db", " po", "uv", " buf", " pad"], "i": ["c", "p", "n", "li", "x", "us", " ti", "k", "iu", "ti", "ix", "zi", "h", "I", "f", " bi", "key", " j", "xi", "ic", "qi", " e", "m", " n", "u", "ui", "it", " index", "ims", "im", " p", " v", " li", " t", " id", "j", " m", "ii", " mi", " counter", "pi", "index", "me", "ci", "ij", " ii", "y", " pi", "bi", "hi", "ms", " I", "go", "mi", "di", "ai", "si", "multi", "ki", "is", "sim", " di", "cli", "gi", " pos", "mu", " si", "ip", "oi", " x", " iter", "print", "dr", "in", " multi"]}}
{"project": "FFmpeg", "commit_id": "2005fddcbb4e18e8f7c34326e40609e4a2d83c31", "target": 0, "func": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n\n{\n\n    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n\n    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n\n\n    if (mode > 6U) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"out of range intra chroma pred mode at %d %d\\n\",\n\n               h->mb_x, h->mb_y);\n\n        return -1;\n\n    }\n\n\n\n    if (!(h->top_samples_available & 0x8000)) {\n\n        mode = top[mode];\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n\n        mode = left[mode];\n\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n\n                   (!(h->left_samples_available & 0x8000)) +\n\n                   2 * (mode == DC_128_PRED8x8);\n\n        }\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return mode;\n\n}\n", "idx": 3748, "substitutes": {"h": ["q", "wcs", "l", "he", "ph", "c", "host", "handle", "bh", "sh", "p", "kh", "uh", "eh", "hw", "oh", "ah", "H", "wh", "hh", "comm", "pp", "hp", "act", "m", "header", "b", "x", "dh", "ih", "it", "cache", "history", "http", "y", "ch", "hd", "hl", "w", "e", "rh", "hi", "here", "rec", "hal", "hm", "hs", "hz", "v", "hash", "o", "f", "th", "t", "ht"], "mode": ["mt", "id", "try", "mom", "match", "format", "menu", "set", "raid", "form", "lock", "off", "zero", "tone", "mit", "time", "activity", "dm", "Mode", "conf", "version", "method", "de", "te", "f", "dim", "timeout", "message", "key", "test", "MODE", "mega", "language", "result", "act", "m", "force", "none", "mod", "cmp", "perm", "option", "member", "ode", "gone", "mm", "range", "depth", "when", "driver", "position", "mate", "enable", "chain", "ace", "device", "size", "code", "mask", "style", "dd", "me", "power", "theme", "send", "type", "network", "phase", "mac", "scale", "loop", "mobile", "fm", "cmd", "distance", "status", "phrase", "purpose", "ase", "kind", "mid", "pose", "md", "pe", "def", "tm", "metadata", "command", "e", "role", "mission", "layout", "direction", "state", "slave", "stage", "area", "module", "feature"], "is_chroma": ["is_romo", "is_chromo", "is_romA", "is_chromia", "is_chromA", "is_chromata", "is_chata", "is_romia", "is_cho", "is_chA", "is_romata", "is_cha", "is_roma"], "top": ["user", "tmp", "bottom", "op", "tool", "high", "Top", "soc", "all", "meta", "to", "upt", "tip", "onet", "lt", "mp", "ops", "table", "part", "above", "bot", "tab", "at", "trop", "title", "tp", "t", "toc", "hop", "best", "ap", "first", "alt", "pt", "client", "scroll", "tops", "current", "TOP", "root", "master", "tools", "typ"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n", "idx": 3755, "substitutes": {"info": ["core", "id", "try", "trace", "op", "summary", "api", "warning", "init", "order", "app", "iter", "sum", "lock", "off", "t", "state", "conf", "http", "help", "f", "test", "list", "details", "link", "full", "num", "check", "it", "at", "note", "setup", "search", "ion", "loc", "warn", "report", "information", "Info", "style", "inf", "index", "pi", "ci", "i", "parse", "cache", "entry", "history", "update", "error", "comment", "one", "address", "exec", "auth", "map", "success", "data", "work", "add", "status", "no", "stat", "import", "query", "debug", "kind", "start", "notice", "def", "edit", "config", "ip", "content", "local", "metadata", "command", "alias", "INFO", "now", " inf", "good", "about", "store", "obj", "fo"], "as": ["aser", "sis", "mas", "las", "is", "sv", "ast", "ais", "from", "acs", "asi", "ab", "app", "ass", "ase", "sa", "nas", "asa", "jas", "asha", "asar", "ars", "asio", "au", "asis", "ps", "js", "bs", "aos", "pa", " a", " AS", "ap", "ms", "asy", "ams", "ras", "ag", "ar", "an", "am", "asp", "rs", "AS", "As", "gs", "ats", "ias", "av", " As", "aster", "ac", "asia", "aus", "a", "asm", "ak"]}}
{"project": "qemu", "commit_id": "4fb588e95bacb770746cc794ef165fd71a4d27ea", "target": 0, "func": "static void block_job_completed_txn_abort(BlockJob *job)\n\n{\n\n    AioContext *ctx;\n\n    BlockJobTxn *txn = job->txn;\n\n    BlockJob *other_job, *next;\n\n\n\n    if (txn->aborting) {\n\n        /*\n\n         * We are cancelled by another job, which will handle everything.\n\n         */\n\n        return;\n\n    }\n\n    txn->aborting = true;\n\n    /* We are the first failed job. Cancel other jobs. */\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        aio_context_acquire(ctx);\n\n    }\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        if (other_job == job || other_job->completed) {\n\n            /* Other jobs are \"effectively\" cancelled by us, set the status for\n\n             * them; this job, however, may or may not be cancelled, depending\n\n             * on the caller, so leave it. */\n\n            if (other_job != job) {\n\n                block_job_cancel_async(other_job);\n\n            }\n\n            continue;\n\n        }\n\n        block_job_cancel_sync(other_job);\n\n        assert(other_job->completed);\n\n    }\n\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        block_job_completed_single(other_job);\n\n        aio_context_release(ctx);\n\n    }\n\n}\n", "idx": 3763, "substitutes": {"job": ["jump", "batch", "image", "j", "journal", "work", "try", "op", "mb", "jp", "item", "big", "org", "row", "build", "node", "package", "bug", "task", "com", "unknown", "msg", "tab", "new", "none", "obs", "jobs", "cell", "Job", "block", "jo", "normal", "command", "name", "ob", "now", "manager", "member", "db", "project", "band", "queue", "go", "good", "event", "worker", "gov", "jj", "module", "cmd", "common"], "ctx": ["sys", "ctr", "cp", "fw", "acl", "jp", "addr", "xc", "nc", "bc", "tk", "unc", "nd", "conn", "kb", "hw", "ca", "np", "kl", "xs", "box", "cfg", "crit", "mc", "cb", "act", "tx", "kt", "tab", "req", "cmp", "qu", "xy", "tz", "kw", "cf", "context", "xp", "mk", "wd", "dl", "comp", "pool", "pkg", "anc", "co", "bo", "ind", "loc", " cx", "cc", "nt", "urg", "wx", "ct", "cl", "cmd", "ck", "lc", "resp", "iat", "mem", "tc", "jac", "ctrl"], "txn": ["xns", "actne", "txm", "transns", "seqnb", "actns", "latout", "xne", "Txm", "TxN", " txns", "Txon", "xnt", "seqns", "taxns", "Txj", " txv", "xout", "txnr", "xnor", "txj", "txnb", "actnb", " txon", "exnt", "txnor", "xnb", "transm", "txnw", "xv", "txv", "latnr", "timesnw", "actn", "xj", "Txns", "exn", "txN", "xm", "exnor", "latn", "timesnr", "latne", "txout", "fxnw", "laton", "exns", "Txout", "txne", "xon", "xn", "txon", "fxnr", "taxnor", "txnt", "seqne", "transN", "timesn", "Txv", "transn", "txns", "transj", " txN", "taxnt", "taxn", "timesne", "Txn", "fxn", "latnw", "seqn", " txj", "latns", "transon", "fxne"], "other_job": ["wrong_job", "common___org", "other_bug", "othererorg", "other___try", "outer_word", "another___job", "otherJbug", "otherjJob", "another___car", "other___package", "common_builder", "another_cor", "other_byte", "another__bug", "unknown_link", "common_org", "unknown_worker", "othererpackage", "other___builder", "othererbuilder", "another_bug", "otherJcell", "common___job", "wrong_request", "another_worker", "outer_job", "block_job", "odd_manager", "oddcurrentfire", "anotherJjob", "another_byte", "other_manager", " other_name", "another___com", "another__job", "other_package", "common___builder", "other__word", "blocktbatch", "oddcurrentJob", "otherlyband", "other___job", "same_process", " other___name", "otherlyjob", "other__process", "other_band", "other___car", "otherThejob", "another_car", "otherjjob", "otherxword", "other_item", "other_try", "otherjmanager", " other___job", "other_db", "wrong_Job", "otherJJob", "other___cmd", "other_car", "otherJdb", "othertlink", "otherJorg", "other_cor", "otherjfire", "otherJrequest", "other_process", "anotherJcor", "otherjdb", "other_link", "othertbatch", "othererworker", "oddcurrentmanager", "common___cmd", "another__org", "other___name", "otherJmanager", "otherJprocess", "another_manager", "another__word", "block_link", "othercurrentJob", "other_batch", "otherJbuilder", "common_cmd", "outer_item", "otherJcmd", "unknown_job", "otherThedb", " other_Job", "other__org", "common_job", "wrongxJob", "othertjob", "otherlybatch", "other_worker", "otherJjob", "otherJcor", "wrongxrequest", "oddcurrentjob", "other_fire", "wrongxjob", "wrongxword", "blocktlink", "other___org", "another_word", "odd_fire", "other_builder", "another___worker", "othercurrentjob", "another_db", "anotherJdb", "othertband", "another_job", "otherThecor", "other_cmd", "other___com", "wrong_word", "othererlink", "othercurrentmanager", "blocktband", "otherxJob", " other___try", " other_try", "other_org", "block_batch", "odd_job", "other_com", "blocktjob", "other__job", "other___manager", "another_org", "othercurrentfire", "otherxrequest", "other_request", "other__cell", "block_band", "otherThebyte", "unknown_package", "odd_Job", "another_com", "other__bug", "othererjob", "same_bug", "anotherJbyte", "otherJword", "another___manager", " other_db", "other_word", "other___worker", "otherJcom", "same_job", "otherJbyte", "other___link", "otherjcor", "other_Job", "same_cell", "otherlylink", "other_cell", "other_name", "otherjbyte", "otherxjob", "otherercmd", "otherJworker"], "next": ["data", "j", "key", "list", "tmp", "jp", "buf", "nd", "nl", "news", "sec", "result", "txt", "iter", " NEXT", "ng", "link", "Next", "ne", "new", "gt", "seq", "req", "zip", "ptr", "queue", "fee", "done", "current", "fn", "prev", "gov", "state", "obj", "self", "chain"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)\n\n{\n\n    memory_region_init_io(mr, &isa_mmio_ops, NULL, \"isa-mmio\", size);\n\n}\n", "idx": 3766, "substitutes": {"mr": ["mt", "br", "MR", "gr", "mir", "lr", "rg", "vr", "bm", "hr", "drm", "RM", "r", "m", "tm", "irm", "sr", "kr", "shr", "rr", "adr", "rt", "mn", "dr", "rs", "rm", "rpm", "MT", "ml", "ocr", "tr", "Mr", "cm", "mc", "rar", "rn"], "size": [" length", "data", "id", "code", "count", "z", " sizes", "g", " data", "out", "set", "sum", " Size", "space", "zero", "shape", "storage", "type", "SIZE", "iz", "name", "len", "ize", "scale", "empty", "address", "fee", "grow", "mem", "area", "length", "Size"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddressLegacy *localAddr,\n\n                                  SocketAddressLegacy *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3770, "substitutes": {"ioc": ["giOC", "sioc", "iocon", " iosc", "pioc", "ooco", "itocon", " iOC", "piosc", "sioci", "sioco", "iocy", " iocy", " ioco", "piocon", "gioco", "abiocy", "biocon", " iroc", "iOC", "itoc", "oroc", "piroc", "siOC", "biroc", "bioc", "abioc", "diosc", " ioci", "pioco", "ioci", " iocon", "ioco", "biosc", "itroc", "iroc", "dioc", "abiocon", "bioco", "itoci", "diroc", "gioci", "gioc", "dioco", "oosc", "abiosc", "ooc", "pioci", "biocy", "iosc"], "localAddr": ["localAttrt", "localAddl", "localAddry", " localAddrt", "localaddl", "localAddrs", "localPartrt", "localaddp", "localAttrc", "localaddrc", " localAddrc", "localAttrs", "localAddressrc", " localAddressr", "localPartr", "localAttry", "localAddressl", "localAttr", "localAttl", " localAttr", "localPartry", " localAddl", "localAddressrs", "localAttp", " localAddressl", " localAddrs", "localAddp", " localAddry", "localaddr", "localAddrt", "localAddressp", " localAttry", " localAddressrc", " localAttrt", "localAddrc", "localPartp", " localAddressp", " localAttp", " localAddp", "localAddressr"], "remoteAddr": ["remoteAttri", " remoteAttri", "remotePortn", "remoteAttachri", "remoteAttp", " remoteAddn", "RemotePortr", " remoteAddri", "remoteAttachp", "RemotePortp", "remoteAttachr", "RemotePorter", "remoteAttr", "remotePortR", "remoteAttl", "remoteAttR", "remotePortp", " remotePortl", " remoteAttl", "remotePortr", " remotePortr", "remoteAddn", " remotePortn", "remoteAttn", " remotePortp", "RemoteAddp", "remoteAddl", "RemotePortR", "remoteAddri", " remoteAttp", "RemoteAdder", "remoteAdder", "remoteAtter", " remoteAddp", "remoteAttachl", "RemoteAddr", "remotePorter", "remoteAddp", "RemoteAddR", " remoteAttr", " remoteAddl", "remoteAddR", "remotePortl"], "errp": ["errorr", "errpc", "diep", " errpc", "rrr", " errm", "rrp", "errorp", " errpa", "errorpa", " errP", "errpa", "diepa", " errr", " errps", "rrP", "erP", "rrm", "errorP", "dier", "err", "erp", "errorps", "errps", "errm", "erps", "errorm", "errr", "diepc", "errP", "errorpc"], "fd": ["fp", "d", "fx", "fc", "ff", "func", "FH", "dt", "nd", " f", "handle", "bd", "dd", "fun", " fid", " dur", " fin", "ds", "dig", "td", "dat", "lf", "fin", "fed", "fs", "gd", "form", " fut", "dra", "fl", "fi", "dy", "cf", "ffff", "sd", "dl", " fs", "ptr", "fps", "hd", "df", "fe", "fr", "ln", "db", " df", "fb", "ud", "fee", " td", "gz", "f", "pd", "FD", "bf", " ff", "fn", "da", "elt", "pid", "fm", "ld"]}}
{"project": "qemu", "commit_id": "bb3cb951ef530da7d248051347c974e4d20e6ea0", "target": 0, "func": "static void dec_bit(DisasContext *dc)\n\n{\n\n    TCGv t0, t1;\n\n    unsigned int op;\n\n    int mem_index = cpu_mmu_index(dc->env);\n\n\n\n    op = dc->ir & ((1 << 9) - 1);\n\n    switch (op) {\n\n        case 0x21:\n\n            /* src.  */\n\n            t0 = tcg_temp_new();\n\n\n\n            LOG_DIS(\"src r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            if (dc->rd) {\n\n                t1 = tcg_temp_new();\n\n                read_carry(dc, t1);\n\n                tcg_gen_shli_tl(t1, t1, 31);\n\n\n\n                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);\n\n                tcg_temp_free(t1);\n\n            }\n\n\n\n            /* Update carry.  */\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x41:\n\n            /* srl.  */\n\n            t0 = tcg_temp_new();\n\n            LOG_DIS(\"srl r%d r%d\\n\", dc->rd, dc->ra);\n\n\n\n            /* Update carry.  */\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            if (dc->rd) {\n\n                if (op == 0x41)\n\n                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                else\n\n                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n            }\n\n            break;\n\n        case 0x60:\n\n            LOG_DIS(\"ext8s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x61:\n\n            LOG_DIS(\"ext16s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x64:\n\n        case 0x66:\n\n        case 0x74:\n\n        case 0x76:\n\n            /* wdc.  */\n\n            LOG_DIS(\"wdc r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0x68:\n\n            /* wic.  */\n\n            LOG_DIS(\"wic r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0xe0:\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n            }\n\n            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n\n                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            }\n\n            break;\n\n        case 0x1e0:\n\n            /* swapb */\n\n            LOG_DIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x1e2:\n\n            /*swaph */\n\n            LOG_DIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);\n\n            break;\n\n        default:\n\n            cpu_abort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\",\n\n                     dc->pc, op, dc->rd, dc->ra, dc->rb);\n\n            break;\n\n    }\n\n}\n", "idx": 3778, "substitutes": {"dc": ["vc", "c", "ga", "cus", " mc", "td", "sc", "dm", "ctl", "disk", "df", "cs", "spec", "de", "fee", "dim", "ec", "d", "design", "bc", "dep", "iac", "dir", " DC", "eric", "ds", "coord", "rec", "gc", "central", "du", "dp", "cm", "mc", "cca", "document", "cat", "cr", "cd", "wp", "device", "dt", "nc", "dd", "dat", "cache", "dev", "kw", "dl", "ctx", "db", "mac", "di", "draw", "rc", "da", "exec", "cmd", "doc", "sys", "fc", "pc", "dan", "DC", "ca", "def", "oc", "desc", "adr", "dr", "cu", "cc", "disc", "lc", "ac", "tc"], "t0": [" t8", "lat0", "at2", "at00", "trace0", "wt000", "tcMac", "lat140", "t512", "trace050", "pt0", " tzero", "t2", "Targ", "targ", "T512", "ptZero", "TMac", "pt1", "kt0", " t2", "pt2", "vt512", "pt00", " t08", " tZero", "kt000", "t08", "T140", "dt0", "tcarg", "tZero", "vt1", "dt\t", " t000", "tt10", " t00", "ty000", "tyums", "ty0", "ta0", "dt1", " t10", "at0", "kt1", "tums", "T050", "t\t", "ptMac", "tzero", "tc050", "tazero", "at000", "TZero", "t050", "pt000", "tc0", "t140", "tcZero", "t8", "tt000", "tyarg", "tc1", "T000", "t000", "wtarg", "tt0", "T10", "T\t", "tt1", "lat000", "dt512", "tt08", "ta8", "vt\t", "T1", "wtums", "t00", "T08", "tracearg", "Tzero", "vt0", "T8", "lat1", "dtZero", "ttarg", "trace1", "wt0", "ttums", "T0", "ta1", "t10", "tMac", "kt140"], "t1": ["temp001", "temp0", "f2", "m0", "wtup", "dt384", "wt2", " t001", "dt0", "f1", "wt1", "t01", " t01", "temp2", " t3", "T1", "m1", "dt5", " tor", "T01", "t3", " tup", "t5", " t127", "ter1", "td0", "tt01", "T5", "t2", "temp1", "t384", "T001", "tor", "td384", "t127", "ter2", "tup", "t001", "ter127", "m2", "dt1", "Tor", "T3", "T2", "T384", "tt0", " t2", "m3", "ter0", "fup", "tt001", "T127", "T0", "dtor", "tt1", "td1", " t5"], "op": ["id", "ype", "yp", "omp", "jp", "ep", "Op", "operator", "operation", " OP", "p", "up", "ic", "app", " ip", "cop", "mp", "pp", "bit", "lit", "num", "oop", "opp", "it", "ok", "mod", "cmp", "type", "ps", "opt", "ip", "oc", "perm", " cop", "hop", "ie", "ap", "ver", "comp", "pop", " hop", "eq", "OP", "sp", "oe", "o", "arg", "ot", "top", " Op", "oper", "ops", "cmd", "typ"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "int memory_region_get_fd(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_fd(mr->alias);\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 3795, "substitutes": {"mr": ["mt", "br", "ctr", "MR", "wcs", "usr", "cr", "cp", "lr", "nr", "pc", "vr", "km", "mor", "drm", "hr", "rer", "r", "bp", "m", "mx", "tm", "asm", "pr", "tp", "irm", "kr", "sr", "mk", "ms", "shr", "fr", "rr", "adr", "rl", "nm", "hm", "mn", "dr", "rs", "rm", "rpm", "wr", "ml", "ocr", "tr", "Mr", "lc", "rar", "rn"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,\n\n                              TCGReg r1, TCGReg r2, TCGReg rn,\n\n                              tcg_target_long ofs, bool pre, bool w)\n\n{\n\n    insn |= 1u << 31; /* ext */\n\n    insn |= pre << 24;\n\n    insn |= w << 23;\n\n\n\n    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);\n\n    insn |= (ofs & (0x7f << 3)) << (15 - 3);\n\n\n\n    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);\n\n}\n", "idx": 3811, "substitutes": {"s": ["S", "q", "c", "sg", "is", "ss", "p", "g", "n", "r", "ds", "m", "b", "x", "tx", "fs", "sc", "ps", "js", "ns", "e", "as", "cs", "ts", "ctx", "ains", "ies", "sts", "rs", "v", "in", "h", "gs", "sb", "os", "t", "a"], "insn": ["ingn", " insun", "ainsyn", "ainsne", "insyn", " insyn", " inssn", "insg", "rsns", "inspn", "psun", "tscn", "rsn", "linsne", "insgn", "ainsun", "psns", "Insn", "INSn", "insun", " insns", "ainssn", "inyn", "ainsn", "inn", "insns", "inns", " insne", "INSns", "linssn", " insg", "linsgn", "risg", "linsn", "rsne", "risns", "Inspn", "INSsn", "psne", "rssn", "psn", "risn", "inne", "rsgn", "INScn", "inssn", "Insns", "incn", "insne", "tsns", "tssn", "inscn", " inspn", "rispn", "psgn", "Insg", "tsn", "pssn"], "r1": ["p1", "or3", "t11", "or1", "r01", "p3", "t1", "t3", " r3", "t2", "cr3", " r11", "cr1", " r01", "cr01", "or2", "or01", "p11", "cr2", "r11", "r3", "p2"], "r2": ["r62", "rr2", " r4", "R2", "rr62", " r3", "rr4", "ar62", "ar2", "lr3", "ar4", "R3", "arTwo", "lr1", "R1", "R4", " r62", " rTwo", "r4", "lr2", "r3", "lr4", "rrTwo", "rTwo"], "rn": ["mr", "fp", "rd", "cr", "lp", "lr", "cn", "nl", "drm", "n", "ren", "rob", "r", "np", "rb", " re", "rw", "ra", "rin", "kr", "rf", "err", "cv", "rh", "rr", "rx", "rl", "RN", "rt", "arn", "rs", "rm", "ern", "orn", "wr", "rc", "nn", "fn", "rar", "RP", "dn"], "ofs": ["ofms", "\u00f3sd", "Ofts", "OFjs", "ofsd", "Ofjs", "Ofsd", "OFs", "OFc", " ofxs", "ofxs", " ofc", "\u00f3js", "offjs", "\u00f3s", "Ofgs", " ofjs", "offts", "ofgs", "OFts", "oftxs", "ofc", " ofgs", "offms", "OFxs", "offs", " ofsd", "Ofc", "ofjs", "Ofs", " ofms", "oftjs", "Ofxs", " ofts", "oftms", "\u00f3c", "OFgs", "ofts", "offxs"], "pre": ["fp", "pres", "j", "wp", "lp", "et", "po", "Pre", "jp", "web", "p", "up", "py", "ref", "pb", "mp", "res", "tx", "ra", "pr", "ps", "tp", "pa", "prime", "ap", "rec", "fr", "post", "get", "pt", "per", "current", "ve", "tr", "fn", "prev", "prefix", "rel", "re", "PRE", "ble", "inter", "pri"], "w": ["q", "fw", "wp", "word", "p", "wi", "n", "ow", "window", "r", "wh", "write", "W", "wa", "m", "rw", "b", "x", "u", "nw", "wo", "wl", "y", "kw", "iw", "wb", "re", "v", "wx", "wr", "h", "f", "wt", "wk", "t", "mem", "tw"]}}
{"project": "qemu", "commit_id": "2e84849aa2cc7f220d3b3668f5f7e3c57bb1b590", "target": 0, "func": "static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,\n\n                                   const char *name, Error **errp)\n\n{\n\n    X86CPU *cpu = X86_CPU(obj);\n\n    const int64_t min = 0;\n\n    const int64_t max = INT_MAX;\n\n    int64_t value;\n\n\n\n    visit_type_int(v, &value, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    if (value < min || value > max) {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, \"\",\n\n                  name ? name : \"null\", value, min, max);\n\n        return;\n\n    }\n\n\n\n    cpu->env.tsc_khz = value / 1000;\n\n}\n", "idx": 3815, "substitutes": {"obj": ["proc", "sys", "inst", "id", "oid", "tmp", "op", "po", "instance", "object", "conn", "org", "attr", "hw", "ref", "np", "onet", "act", "att", "pr", "impl", "ex", "js", "ns", "owner", "imp", "ctx", "Obj", "ob", "pkg", "nt", "o", "h", "expr", "ot", "os", "t", "cmd", "self"], "v": ["vc", "j", "q", "l", "op", "vis", "c", "V", "vr", "sv", "p", "g", "n", "ev", "vs", "r", "vt", "m", "nv", "b", "i", "u", "vp", "vi", "vy", "tv", "vm", "cv", "e", "o", "uv", "f", "ve", "t"], "opaque": ["opient", "ospane", "ospient", "opsane", "ospacity", "opsient", "opsacity", "ocient", "ocacity", "opsaque", "ocaque", "opane", "ocane", "ospaque", "opacity"], "name": ["data", "id", "NAME", "nam", "key", "size", "word", "no", "term", "ename", "n", "attr", "names", "label", "broad", "path", "m", "other", "ame", "part", "unknown", "family", "none", "valid", "new", "type", " names", "title", "defined", "dev", "local", "error", "comment", " Name", "specified", "alias", "str", "am", "on", "Name", "named", "prefix", "t", "mem", "a", "not"], "errp": [" erper", " errping", "rerp", "errpg", "derp", "rerP", " erp", "rrp", " errper", "errorp", "rrper", " errpg", " errpa", "errorpa", " errP", "errorping", "errpa", " errr", "rrP", "errper", "errorP", "err", "erp", "rerpa", "derpa", "errping", "erpa", "errr", "rrpg", "derr", "errorper", "errP", " erpg", "rerping"], "cpu": ["proc", "core", "sys", "cp", "ork", "lp", "net", "phys", "pc", "conn", "p", "pu", "hw", "np", "gpu", "CPU", "node", "onet", "processor", "phy", "pixel", "mx", "linux", "aq", "prof", "tp", "mu", "cum", "cv", "ctx", "gc", "clock", "cu", "process", "nu", "ck", "mem", "kernel"], "value": ["data", "values", "number", "total", "image", "input", "key", "message", "min", "size", "status", "word", "instance", "count", "flow", "no", "text", "widget", "result", "index", "label", "power", "ue", "set", "see", "sum", "expression", "num", "start", "weight", "entry", "type", "we", "VALUE", "update", "version", "buffer", "context", "try", "attribute", "test", "now", "get", "val", "range", "scale", "always", "fee", "field", "current", "max", "position", "unit", "Value", "byte", "raw", "length", "json", "property"]}}
{"project": "qemu", "commit_id": "6764579f894950afe87d8ec3b323adde8925d4fd", "target": 1, "func": "static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    struct cow_header_v2 cow_header;\n\n    struct stat st;\n\n    int64_t image_sectors = 0;\n\n    char *image_filename = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    BlockDriverState *cow_bs;\n\n\n\n    /* Read out options */\n\n    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;\n\n    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    cow_bs = NULL;\n\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    memset(&cow_header, 0, sizeof(cow_header));\n\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n\n    cow_header.version = cpu_to_be32(COW_VERSION);\n\n    if (image_filename) {\n\n        /* Note: if no file, we put a dummy mtime */\n\n        cow_header.mtime = cpu_to_be32(0);\n\n\n\n        if (stat(image_filename, &st) != 0) {\n\n            goto mtime_fail;\n\n        }\n\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n\n    mtime_fail:\n\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n\n                image_filename);\n\n    }\n\n    cow_header.sectorsize = cpu_to_be32(512);\n\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* resize to include at least all the bitmap */\n\n    ret = bdrv_truncate(cow_bs,\n\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(image_filename);\n\n    bdrv_unref(cow_bs);\n\n    return ret;\n\n}\n", "idx": 3824, "substitutes": {"filename": ["fp", "ames", "fil", "NAME", "kan", "FIL", "FH", "LOC", "amen", "directory", "source", "ename", "ren", "fle", "txt", "kl", "kj", "nil", "localhost", "path", "IL", "knife", "oval", "ame", "SOURCE", "bite", "println", "SourceFile", "location", "file", "username", "name", "aka", "nm", "FN", "til", "AME", "Filename", "flake", "PATH", "sbm", "png", "f", "fn", "prefix", "jpg", "fd"], "opts": ["opss", "optte", "optpt", " oports", "popts", "props", " opps", "opps", "opercs", "opttions", "pross", "options", "opte", "prots", "optcs", "iopts", "alts", "opcs", " opte", "opTS", "OPTS", "iopTS", "opds", " opcs", "prot", "operts", " opss", "opt", "OPds", "iops", "oppt", "OPpt", "alps", "iopds", "optTS", "alt", "operorts", "OPs", "OPts", "operte", "oports", " opt", "OPtions", "poptions", "optts", "pops", "optorts", "optds", "ops", "alss", "poppt"], "errp": [" errping", "rrpe", "diep", "errorpe", "nerpy", "erera", "derp", "orderp", "derping", "dieP", "rrp", "errorp", "errorpa", "errpy", " errP", " errpb", "errorping", "errpa", "ererpe", "nerping", "erra", "nerp", "nerps", "ererpa", "orderping", "errorP", "errorpb", "diepb", "orderps", "dieping", "errora", "errps", "errping", "rra", "derps", "errpe", "orderpy", "derpy", "errpb", "ererp", "rrpa", "errP"], "cow_header": ["motion_head", "usammplayer", "craft_header", "cow_device", "ow_version", "cowmmheader", "cowmyheader", "cotPevent", "cowmmsession", "cowDpeer", "cow_module", "cowmycomment", "womanDaverage", "ow_average", "cow11header", "cowPevent", "cow___head", "craft_headers", "yeah_comment", "motionmyversion", "cow11comment", "usa_player", "cowmmplayer", "cow_cache", "cow___commit", "cow_event", "cowJdevice", "ow_spec", "motion_comment", "cot_module", " cow_head", " cow___header", "cow_Header", "yeah11head", "cowPpeer", "womanDcommit", "Cow_header", "Cow_metadata", "woman_commit", " cow_average", "craft_wrapper", "ow_filter", "cow67average", "cow_peer", "cowMversion", "cow_head", "cot_event", "dylib_init", "cowmyrule", " cow___head", " cow_buffer", "cowmyinit", "usa_header", "cotPmodule", "ow_Header", "woman_comment", "cowDaverage", "cow11device", "cot_peer", "cow_filter", "cow_version", "cowDevent", "cow_session", "cotPheader", "dylib_iter", "yeah_device", "cow_info", "cow67commit", "cowJcomment", "cowmyiter", "cow_comment", "cowMaverage", "cow_dr", "motion_version", "woman_header", "craft_buffer", "ow_info", "ow_dr", "usammcache", "Cow_dr", "cow2wrapper", "motionmyhead", "yeah11comment", "cow_buffer", "woman_average", "usammheader", "cow_rule", "cow_headers", "cow2headers", "cow___buffer", "cowmmcache", "dylib_rule", "cowMheader", "cow67header", "cow_layer", "yeah11header", "cow_commit", "dylib_header", "cow_spec", "womanDheader", "cowJhead", "ow_layer", "cow_wrapper", "cow2header", "cowDcommit", "cow___comment", "womanDcomment", "ow_head", "cowJheader", "cow_init", "Cow_head", "motion_header", "motionmyheader", "cowDcomment", "cotPpeer", " cow___buffer", "cow___average", "yeah11device", "cot_header", "cow_player", "yeah_header", "cow_average", "cowDheader", "cowPheader", "cowmyhead", "cowDmodule", "cow2buffer", "ow_header", "usammsession", "yeah_head", "motionmycomment", "cow67comment", "cowMlayer", "cow11head", "cow_metadata", "usa_session", "cowmyversion", "usa_cache", "cowPmodule", "cow_iter", " cow___average", "cow___header"], "st": ["stack", "inst", "sta", "ste", "ut", "rest", "nd", "sth", " enc", "step", "tt", "ss", " sp", " std", "stat", "ast", "sh", "r", "ust", " ss", "ST", " ts", " rest", "start", "cont", "sc", " net", "it", " storage", "stop", " ST", "sw", "ist", " sc", "fr", "str", " est", "stage", "sts", "sp", "irst", "est", "ost", "ct", " St", " dst", " ut", " et", "se", "std", "St"], "image_filename": ["memory_header", " image_file", "Image_Filename", " image_stem", "Image_fil", " image_Filename", "Image_filename", "image_fn", "image_header", "image___Filename", "Image_fn", "memory_enabled", "image___source", "image___name", "imageNameenabled", "Image_source", "image___fn", "image___enabled", "image_stem", "image_fil", "image___filename", "image___header", "image_name", "image_file", "memory___header", "memory___filename", "image_enabled", "image___fil", "imageNameheader", "imageNamefilename", "image_username", "memory___enabled", "image_source", "image_Filename", "memory_filename", " image_username", "Image_name", " image_fil"], "local_err": ["langlysys", "local_r", "locallyattr", "locallyerr", "langlycss", " local_errors", "local_css", " local_obj", " local_r", "local___r", "langlyerr", "local___err", "local___attr", " local_error", "lang_sys", "local_attr", "local___obj", "locallyiter", "local___iter", "global_er", "local___css", "local_sys", " local_attr", "lang_css", "lang_r", "langlyr", "localpyerrors", " local_iter", "locallyobj", "local_iter", "global_err", "local_obj", "local_errors", " local_rr", "local___sys", "localpyerror", "local_error", "localpyerr", "locallycss", "localpyrr", "local_rr", "local__err", "locallyr", "local__r", "lang_err", "locallysys", "global_error", "local__error", "local_er"], "ret": ["mt", "del", "usr", "RET", "net", "try", "arr", "git", "Return", "ext", " RET", "fun", "after", "ref", "result", "deg", "lt", "out", "sat", "res", "fin", "ft", "cont", "gt", "ll", "def", "at", "mem", "att", "run", "Ret", "pt", " Ret", "nat", "err", "mel", "tn", "gc", "rt", "re", "alt", "ter", "ben", "print", "ry", "val", "get", "rets", "reg", "nt", "rm", "mat", "cmd", "det", "tr", "rem", "reset", "flag", "cert", "elt", "t", "resp", "len", "inter"], "cow_bs": ["ow_gs", "cow__bs", "alky_sb", "drm_bs", "alky___bs", "cow_ba", "cow_bes", "drm_ps", "cow_sb", "cow_cs", "cow2bs", "cow_bt", "ow_sb", "ow_bg", "cow__ba", "alky___sb", "cow__cs", "cow_sys", "ow_cs", "alky___bt", "alky_bs", "cow___bs", "cow___sb", "cow_gs", "cow_BS", "cow2sys", "cow2sb", "cow_bg", "cow__sb", "alky___sys", "ow_ba", "cow_ps", "alky_sys", "cow___sys", "ow_bs", "drm_bm", "ow_BS", "alky_bt", "drm_bes", "cow___bt", "cow_bm", "cow2bt"]}}
{"project": "FFmpeg", "commit_id": "4a023d5b53132ced3643d0e8397baa80cf75f656", "target": 0, "func": "static av_cold int check_format(AVCodecContext *avctx)\n\n{\n\n    AVCodecParserContext *parser;\n\n    uint8_t *pout;\n\n    int psize;\n\n    int index;\n\n    H264Context *h;\n\n    int ret = -1;\n\n\n\n    /* init parser & parse file */\n\n    parser = av_parser_init(avctx->codec->id);\n\n    if (!parser) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 parser.\\n\");\n\n        goto final;\n\n    }\n\n    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;\n\n    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);\n\n    if (index < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to parse this file.\\n\");\n\n        goto release_parser;\n\n    }\n\n\n\n    /* check if support */\n\n    h = parser->priv_data;\n\n    switch (h->sps.bit_depth_luma) {\n\n    case 8:\n\n        if (!CHROMA444(h) && !CHROMA422(h)) {\n\n            // only this will H.264 decoder switch to hwaccel\n\n            ret = 0;\n\n            break;\n\n        }\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported file.\\n\");\n\n    }\n\n\n\nrelease_parser:\n\n    av_parser_close(parser);\n\n\n\nfinal:\n\n    return ret;\n\n}\n", "idx": 3832, "substitutes": {"avctx": ["afcpu", "avconn", "absetup", "avectx", "afcmd", "avercpu", " avcats", " avcrit", "avtx", " avsetup", "avcu", "ajcu", "ivercb", "savconn", "avercontext", "wavconn", " avcfg", "avcrit", "afctx", "ajtx", "savcats", "ajctx", "ajcpu", "ajcontext", "avertx", "savcontext", "avecfg", "avercv", "abcontext", "avsetup", "aversetup", "avercb", "wavcats", "avercrit", "abctx", " avtx", "wavctx", "averctx", " avcontext", "avercas", "avcats", "wavcontext", "ivercontext", "avcpu", "afcv", "avercmd", "avcas", "avcv", "iverctx", "avcontext", "avecrit", "avecontext", "abtx", " avcb", "afcontext", " avconn", "avcb", "avercu", "avcfg", "afcu", " avcas", "ajcmd", "avcmd", "ajcv", "savctx", "ivercas", "aftx", "avercfg"], "parser": ["reader", "parent", "cp", "ard", "p", "server", "ner", "native", "loader", "xml", "context", "buffer", "manager", "wrapper", "program", "handler", "pd", "reset", "fp", "Parser", "iterator", "language", "mpeg", "pause", "password", "ready", "policy", "tp", "token", "final", "application", "php", "basic", "document", "builder", "wp", "arson", "er", "arser", "power", "processor", "parse", "type", "timer", "ctx", "pool", "v", "process", "worker", "aster", "master", "proc", "public", "lp", "func", "instance", "pc", "jack", "rer", "package", "util", "expression", "writer", "tar", "local", "metadata", "player", "command", "function", "primary", "peer", "t", "pro"], "pout": ["opin", "spOUT", "goutput", "ppouts", "gin", "ppOUT", "spout", "gout", " pouts", "spouts", "opoutput", "spin", "opOUT", "opout", "ppout", "gouts", " pin", " poutput", "pin", "pouts", "ppin", "pOUT", "opouts", "poutput"], "psize": ["pshare", "PSize", "sssize", "pershare", "persizes", " psizes", "PShare", "apsization", "apssize", "apsized", "ssization", "tsized", "psized", "persize", "ssize", "PSizes", " psiz", "psiz", "tsize", " pshare", "persiz", "tsization", "ssized", "psizes", "tssize", "pssize", "apsize", "psization", "PSiz"], "index": ["success", "j", "id", "number", "active", "interface", "false", "key", "status", "size", "value", "count", "port", "slice", "seek", "n", "row", "ref", "order", "open", "iter", "pointer", "out", "set", "i", "x", "num", "find", "pos", "info", "zero", "connection", "error", "ion", "ind", "get", "offset", "val", "connect", "address", "IND", "ret", "si", "position", "resp", "Index", "scan", "len", "inter"], "h": ["data", "head", "zh", "l", "he", "ph", "high", "c", "host", "handle", "bh", "sh", "p", "kh", "hr", "eh", "hw", "oh", "ah", "hh", "H", "pp", "hp", "html", "header", "b", "dh", "ih", "history", "ch", "hd", "hl", "context", "rh", "hi", "ctx", "hal", "hm", "hs", "hz", "v", "ha", "hum", "hash", "t", "ht"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_move_mr(DisasContext *dc)\n\n{\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tif (memsize == 4) {\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_update_cc_op(dc, CC_OP_MOVE, 4);\n\n\t\tcris_update_cc_x(dc);\n\n\t\tcris_update_result(dc, cpu_R[dc->op2]);\n\n\t}\n\n\telse {\n\n\t\tTCGv t0;\n\n\n\n\t\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, memsize, t0);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);\n\n\t\ttcg_temp_free(t0);\n\n\t}\n\n\tdo_postinc(dc, memsize);\n\n\treturn insn_len;\n\n}\n", "idx": 3834, "substitutes": {"dc": ["doc", "ec", "vc", "d", "design", "sys", "cat", "fc", "cd", "wp", "cr", "dt", "c", "pc", "bc", "DC", "nc", "dd", "ga", "iac", "ca", " DC", "cus", "eric", "session", "rank", "ds", "td", "dat", "cont", "sc", "def", "tm", "dm", "oc", "ctl", "kw", "desc", "tc", "dl", "cs", "df", "rec", "ctx", "nic", "spec", "gc", "de", "std", "db", "dr", "mac", "currency", "cu", "cc", "mm", "di", "dp", "disc", "du", "draw", "icc", "rc", "cm", "lc", "ac", "da", "exec", "mc", "cmd", "cca"], "insn_len": ["inspan_lan", "inspan_str", "insn_Len", "inspn_ll", "insn___Len", "inspan_int", "inspan_el", "insn67len", "insn_lan", "insn2ls", "inspn_Len", "insn_nl", "insne_Len", "insn_ls", "insn2len", "insn67int", "insn2ll", "insn_ll", "insn2ln", "insn_ln", "inspn_len", "insn2Len", "insn_int", "inspan_Len", "insn___len", "insn___str", "insne_ls", "inspn_ln", "inspan_len", "insn67nl", "insn67lan", "insn_el", "insne_len", "inspan_nl", "insn___el", "insn_str"], "t0": ["tbase", "at000", "TZero", "dt0", " tk", "tmp0", "tk", "tcoval", "tZero", " t3", "T1", " tau", "st0", "ot0", " t4", "pt4", "tc0", "atarg", "t3", "t1", "ot4", " t000", "t4", "pt0", "t2", " tbase", "dtau", "tc1", "tmpoval", "targ", "tmp1", "t000", "ptZero", " t1", "starg", "pt1", "T2", "at0", " t2", "atbase", "pt2", "st000", " targ", "stbase", "tau", "toval", "otZero", "T0", " tZero", "dtk", "otk", "ot3", " toval", "otau", "pt3"]}}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn(ISADevice *dev)\n\n{\n\n    RTCState *s = DO_UPCAST(RTCState, dev, dev);\n\n    int base = 0x70;\n\n    int isairq = 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n", "idx": 3838, "substitutes": {"dev": ["data", "d", " device", "device", "buf", "usb", "adv", "handle", "conn", "dd", "p", "ev", "hw", "server", "app", "dem", "debug", "out", "devices", "Dev", "phy", "serial", "info", "def", "pad", "dm", "sd", "disk", "w", "cam", "ptr", "ver", "ctx", "Device", "home", "de", "DEV", "db", "v", "nt", "h", "o", "sky", "ad", "av", "ve", "scan", "raw", "des", "mem", "obj", "serv", "cmd", "pro"], "s": ["ls", "c", "p", "es", "n", "server", "ses", "out", "set", "params", "gets", "services", "its", "t", "conf", "ports", "cs", "spec", "ies", "an", "h", "gs", "sb", "args", "os", "a", "mods", "stats", "sv", "source", "settings", "vs", "details", "ds", "qs", "less", "ex", "bs", "ims", "sam", "hs", "sts", "states", "ins", "sq", "ys", "self", "j", "S", "l", "sets", "ss", "als", "sl", "comm", "sa", "utils", "i", "syn", "ns", "sw", "y", "ms", "ts", "changes", "v", "tests", "results", "si", "se", "ops", "cmd", "sys", "steps", "scripts", "status", "is", "g", "r", "b", "fs", "aws", "ps", "js", "sd", "w", "e", "as", "copy", "sm", "rs", "ats", "des", "state", "obj"]}}
{"project": "qemu", "commit_id": "1f8828ef573c83365b4a87a776daf8bcef1caa21", "target": 0, "func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    return virtio_load(vdev, f, version_id);\n\n}\n", "idx": 3845, "substitutes": {"f": ["fp", "d", "fx", "q", "fc", "l", "c", "ile", "p", "fa", "xf", "r", "sf", "lf", "b", "af", "fs", "tf", "fi", "file", "cf", "rf", "w", "e", "fe", "fr", "F", "fb", "v", "h", "feed", "fn", "bf", "t", "fm", "uf", "fo", "fd"], "opaque": ["opsac", "opac", " oparam", " Opulence", "opsaram", "pulent", "obaques", "opsulence", " opac", "oparam", " opulent", "opulent", " Opaque", " opulence", "pacity", "paque", "opacity", "paques", " opaques", "opsaque", " Opac", "opaques", "obacity", "obulent", " Oparam", "opulence", " opacity", "obaque"], "version_id": [" version2start", " version_sid", "v_ip", " version2bit", "VERSION_Id", "version2bit", "version_Id", " version2info", " version_ids", "VERSION_with", "VERSION_ids", "version_start", "version_no", " version_info", " version_start", "version2id", "v_mid", "version_mid", "version_ip", "version2info", " version2id", "VERSION_id", "v_id", "version_with", "version2start", "v_no", "version_ids", "version_bit", "version_sid", "version_info", " version_bit"], "n": ["gn", "d", "j", "l", " gn", "c", "nc", "cn", "N", "p", "g", "np", "node", "ng", "m", "nv", "b", "ne", "nw", "ns", "w", "en", "nm", "an", "v", "nt", "o", "h", "nn", "na", "sn", " N", "nor", "t", "rn", "dn"], "vdev": ["vdevice", " vdevice", "wdevice", " vswitch", "vev", " vev", "dDevice", "gev", "gDevice", "vmdev", "vmdevice", "dev", "wdef", "wdev", "gdev", " vDevice", "wswitch", "vDevice", "vmswitch", "vmdef", "vswitch", "gdevice", "ddev", "ddevice", " vdef", "vdef"]}}
{"project": "FFmpeg", "commit_id": "3f8148911c6e6e1f2a042bd4ca3ad8516a92130c", "target": 0, "func": "static int read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]={0}, ret[3]={0};\n\n    AVIOContext *f[3] = {NULL};\n\n    AVCodecContext *codec= s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path, s->img_number)<0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for(i=0; i<3; i++){\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if(i>=1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i]= avio_size(f[i]);\n\n\n\n            if(!s->split_planes)\n\n                break;\n\n            filename[ strlen(filename) - 1 ]= 'U' + i;\n\n        }\n\n\n\n        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        size[0]= 4096;\n\n    }\n\n\n\n    av_new_packet(pkt, size[0] + size[1] + size[2]);\n\n    pkt->stream_index = 0;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    pkt->size= 0;\n\n    for(i=0; i<3; i++){\n\n        if(f[i]){\n\n            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if(ret[i]>0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n", "idx": 3901, "substitutes": {"s1": ["ds0", " s3", "ds2", "fs2", "S0", " sone", "ts1", "js2", "js3", "s3", " s0", "s01", "fs3", "dsone", "ds1", "rs3", "fs01", "rs1", "rs0", "S2", "rsone", "ds3", "js01", "S3", "ts2", "sone", " s2", "js1", " s01", "fs1", "s0", "ts3", "S1", "S01", "ts01", "rs2", "s2"], "pkt": ["Packet", "spdu", " pet", "pdu", "packck", " pck", "spkt", "packacket", "Pkt", "cpck", " pdu", "packkg", "packet", " pkg", "Pdu", "pkg", "spacket", "Pet", "packkt", " packet", "pck", "pet", "cpkg", "spet", "cpacket", "cpkt"], "s": ["ls", "c", "p", "es", "n", "ses", "set", "sc", "series", "t", "state", "spec", "h", "gs", "sb", "args", "os", "a", "south", "stats", "sv", "source", "session", "service", "vs", "details", "ess", "ds", "qs", "m", "less", "ims", "bis", "sam", "search", "sts", "styles", "ins", "sq", "sync", "j", "S", "ss", "z", "sl", "comm", "space", "https", "ns", "sw", "y", "save", "ms", "ts", "changes", "v", "single", "se", "ops", "ssl", "sp", "sys", "status", "is", "sim", "g", "b", "fs", "ps", "js", "local", "sd", "comments", "w", "as", "sports", "has", "rs", "bits", "ats", "st", "store"], "filename_bytes": ["filename_uses", "Filename_bytes", "filename_byte", "Filename_tes", "filename_binary", " filename_Bytes", "username_data", "filename_Bytes", "filename_data", "username_bytes", "filename_tes", " filename_byte", "filename_strings", "Filename_strings", "username_binary", "Filename_pieces", "filename_pieces", "username_pieces", "username_uses"], "filename": ["fp", "ames", "wav", "image", "fil", "NAME", "kan", "l", "tmp", "status", "FIL", "directory", "source", "unc", "p", "ename", "files", "n", "ren", "description", "fle", "txt", "kj", "nil", "mpeg", "names", "result", "lua", "path", "url", "ame", "title", "subject", "location", "browser", "output", "final", "file", "username", "metadata", "buffer", "name", "via", "nm", "FN", "uri", "river", "AME", "Filename", "original", "src", "sbm", "png", "position", "fn", "binary", "prefix", "jpg", "length", "json"], "i": ["id", "c", "p", "n", "init", "iter", "li", "x", "cgi", "k", "iu", "ti", "ind", "uri", "ix", "zi", "h", "ini", "I", "a", "batch", "q", "list", " j", "iy", "xi", "ic", "qi", "m", "u", "ui", "it", "ex", "ims", "im", "io", "\u0438", "ri", "chain", "j", "l", "ii", "iq", "ji", "uni", "z", "to", "index", "pi", "me", "progress", "ci", "ei", "ij", " ii", "y", "bi", "go", "v", "mi", "di", "ai", "si", "point", "multi", "ki", "status", "is", "sim", "g", "r", "b", "cli", "gi", "ip", "oi", "e", "in", "o", "t"], "size": ["data", "message", "status", "code", "c", "ze", "count", "format", "use", "height", "source", "z", "news", "settings", "g", "n", " sizes", "sample", "mode", "fit", "options", "set", "send", "score", "small", "sum", " Size", "x", "export", "needed", "space", "form", "info", "speed", "cache", "shape", "type", "storage", "time", "dimension", "SIZE", "e", "en", "name", "len", "function", "member", "loc", "offset", "ize", "get", "v", "scale", "empty", "fee", "hash", "sized", "args", "sn", "t", "mem", "length", "fo", "Size", "sp"], "ret": ["success", "sys", "message", "status", "match", "code", "count", "p", "seek", "result", "nil", "read", "send", "res", "num", "pos", "info", "reason", "response", "en", "empty", "rc", "args", "flag", "t", "mem"], "f": ["fp", "d", "j", "q", "fw", "fx", "fc", "l", "c", "z", "p", "g", "n", "xf", "fa", "r", "fac", "sf", "m", "b", "x", "u", "fs", "tf", "fl", "fi", "y", "file", "cf", "rf", "w", "e", "buffer", "fe", "fr", "F", "fb", "v", "h", "o", "fn", "bf", "t", "uf", "fo", "fd"], "codec": [" codesc", "protenc", "codenc", "condc", "Codeco", "challect", "cryptEC", "codesc", "codedEC", "challiac", "protc", "cvect", "Codesc", " codEC", "challec", "odEC", " codeco", "codc", "codiac", "Codect", " codet", "challEC", "codedeco", "odec", "codet", "cdect", "condet", "Codec", "codeco", " codc", "protec", "Codiac", "condec", "protect", "condEC", "cryptect", "cdec", "cryptec", "codedec", "odet", "odc", "odenc", "odect", "codect", "cvesc", "cdenc", "cvEC", "codEC", "CodEC", " codect", "cryptiac", "cvec", "cdc"], "img_number": ["img_first", "image_count", "image_first", "img__nr", "img_nr", "img___size", "img___number", "imggno", "imggnum", "img__version", "image_version", "image_counter", "imggnumber", "img_na", "img64number", "img_display", "img_size", "imggfirst", "image_num", "img_num", "img___num", "img___no", "img64no", "img64first", "img_version", "image_number", "img__number", "image_na", "image_name", "img_no", "img_name", "image_size", "img__no", "img_counter", "image_no", "image_nr", "img64na", "image_display"]}}
{"project": "FFmpeg", "commit_id": "7ed47e97297fd5ef473d0cc93f0455adbadaac83", "target": 1, "func": "static int smacker_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    SmackerContext *smk = s->priv_data;\n    AVStream *st, *ast[7];\n    int i, ret;\n    int tbase;\n    /* read and check header */\n    smk->magic = avio_rl32(pb);\n    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))\n    smk->width = avio_rl32(pb);\n    smk->height = avio_rl32(pb);\n    smk->frames = avio_rl32(pb);\n    smk->pts_inc = (int32_t)avio_rl32(pb);\n    smk->flags = avio_rl32(pb);\n    if(smk->flags & SMACKER_FLAG_RING_FRAME)\n        smk->frames++;\n    for(i = 0; i < 7; i++)\n        smk->audio[i] = avio_rl32(pb);\n    smk->treesize = avio_rl32(pb);\n    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)\n        av_log(s, AV_LOG_ERROR, \"treesize too large\\n\");\n//FIXME remove extradata \"rebuilding\"\n    smk->mmap_size = avio_rl32(pb);\n    smk->mclr_size = avio_rl32(pb);\n    smk->full_size = avio_rl32(pb);\n    smk->type_size = avio_rl32(pb);\n    for(i = 0; i < 7; i++) {\n        smk->rates[i]  = avio_rl24(pb);\n        smk->aflags[i] = avio_r8(pb);\n    smk->pad = avio_rl32(pb);\n    /* setup data */\n    if(smk->frames > 0xFFFFFF) {\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames);\n    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));\n    smk->frm_flags = av_malloc(smk->frames);\n    if (!smk->frm_size || !smk->frm_flags) {\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_size[i] = avio_rl32(pb);\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_flags[i] = avio_r8(pb);\n    /* init video codec */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    smk->videoindex = st->index;\n    st->codec->width = smk->width;\n    st->codec->height = smk->height;\n    st->codec->pix_fmt = AV_PIX_FMT_PAL8;\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;\n    st->codec->codec_tag = smk->magic;\n    /* Smacker uses 100000 as internal timebase */\n    if(smk->pts_inc < 0)\n        smk->pts_inc = -smk->pts_inc;\n    else\n        smk->pts_inc *= 100;\n    tbase = 100000;\n    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);\n    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);\n    st->duration = smk->frames;\n    /* handle possible audio streams */\n    for(i = 0; i < 7; i++) {\n        smk->indexes[i] = -1;\n        if (smk->rates[i]) {\n            ast[i] = avformat_new_stream(s, NULL);\n            if (!ast[i])\n                return AVERROR(ENOMEM);\n            smk->indexes[i] = ast[i]->index;\n            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n            if (smk->aflags[i] & SMK_AUD_BINKAUD) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;\n            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;\n            } else if (smk->aflags[i] & SMK_AUD_PACKED){\n                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;\n                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');\n            } else {\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            if (smk->aflags[i] & SMK_AUD_STEREO) {\n                ast[i]->codec->channels       = 2;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            } else {\n                ast[i]->codec->channels       = 1;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            ast[i]->codec->sample_rate = smk->rates[i];\n            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;\n            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate\n                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){\n        av_log(s, AV_LOG_ERROR,\n               \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\",\n               smk->treesize + 16);\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = avio_tell(pb);\n    return 0;", "idx": 3913, "substitutes": {"s": ["sys", "ls", "S", "south", "stats", "status", "c", "sg", "sv", "ss", "p", "g", "n", "simple", "ses", "sa", "ds", "m", "b", "space", "fs", "sc", "aws", "ps", "its", "js", "ns", "bs", "sw", "conf", "k", "ims", "w", "e", "sam", "as", "cs", "ts", "hs", "sts", "an", "v", "rs", "h", "gs", "ats", "sb", "ins", "sq", "t", "a", "acs"], "pb": ["cp", "mb", "p", "kb", "py", "bp", "pg", "bot", "vp", "req", "conf", "vm", "buffer", "xp", "pkg", "emb", "queue", "sb", "resp", "push", "fp", "bank", "tk", "meta", "conv", "pm", "erb", "np", "pel", "cb", "rb", "pause", "tab", "tp", "lv", "pa", "um", "dp", "uf", "obj", "wp", "jp", "buf", "mp", "amp", "oa", "patch", "header", "snap", "ctx", "pool", "wb", "pt", "db", "fb", "pan", "pid", "PB", "proc", "lp", "BP", "eb", "pc", "bj", "txt", "pp", "b", "pack", "tx", "lb", "bb", "metadata", "cv", "pl", "pop", "stab", "peer", "apy", "tap", "tc", "buff"], "smk": [" smj", "svkt", "hemkg", "sykl", "mtkk", "smkw", " smkin", "syac", "bmkk", "smkt", "symkw", " smkt", "demac", "smv", "smn", "mmik", " smka", "mnkit", "smsk", "ismki", "smkin", "sykt", "svkg", "mbtk", "mgkt", "smork", "skyik", " smkick", "symkick", "simq", "esmkick", "mnj", "mkick", "stemak", "simkick", "mbork", "ymk", "storetk", "symkk", "stemkw", "memkit", "symok", "mbkl", "mnunk", "memj", "bmk", "mnkl", "hemkk", "ismkk", "smik", "speik", "ismka", "storeark", "esmunk", " smkl", "symq", "symak", "symsk", "smkick", "syv", " smunk", "memak", "mbk", "symek", "esmkt", "simj", "mg", "esmck", "mgk", " smak", "mkw", " smark", "simtk", "syik", "symtk", "mmkk", "smq", "symik", "syack", "storen", "mtkt", " smkg", "smkl", "bmkit", "syek", "svk", "mk", "smkk", " smn", "smack", "mak", "mnck", "spekick", "spek", "symkit", "smkit", "sytk", "stemik", "storekl", "smac", "symv", "ismkg", " smork", "memkk", "smunk", "demak", "simak", "smtk", "esmkit", "mnkick", "memk", "smak", "smj", "esmn", "memkm", "esmj", "mnork", "storek", "sykw", " smkk", "skyok", "syk", "smck", " smac", " smki", "mnsk", "smkm", "syg", "mmk", "smok", "mnkg", "stemkick", " smkw", "simkg", "mac", "memki", "demk", "sykg", "stemkl", "mnkt", "smek", "ymkick", "simk", "symk", "mbkg", "stemk", "memik", "mtk", "spekin", "mtkit", "hemk", "simkw", "symg", " smik", "esmtk", "syq", "mmkw", "simv", "smkg", "smki", " smek", "mtck", "mgkg", " smtk", "sykk", "ismkm", "simkk", "bmak", "simkl", "ymak", "ismj", "syok", "esmark", "hemka", "demkt", "mtak", "mnk", "smark", "demkg", "memg", "svork", "mgork", "esmkg", "simik", "skyk", "demkl", "sykick", "esmk", "ismk", "stemkin", "simkt", "ymkw", "esmsk", "syak", "symack", "storekg", "esmkl", "skyack", "smka", "symac", " smg", " smkm", "smg", "mtark", " smck", "memtk"], "st": ["mt", "inst", "ste", "rest", "sth", "sh", "sv", "ss", "sl", "ess", "ust", "ST", "ft", "sc", "sw", "sam", "ts", "str", "sm", "sts", "bl", "ct", "est", "sb", "se", "std", "St", "sp"], "ast": ["mt", "inst", "ma", "sta", "asts", "op", "aw", "rest", "ep", "utt", "node", "ream", "ess", "ust", "ist", "saw", "cast", "gc", "esp", "ata", "ost", "est", "must", "os", "ac", "AST", "stage", "asm"], "i": ["id", "try", "p", "init", "iter", "li", "set", "iii", "x", "us", "iu", "ti", "span", "ind", "ix", "zi", "ini", "I", "this", "q", "xi", "ic", "qi", "m", "u", "ui", "it", "gu", "ims", "im", "um", "name", "io", "depth", "\u0438", "ri", "mc", "chain", "j", "l", "ii", "iq", "ji", "pi", "index", "me", "ci", "ei", "info", "phi", "ij", "eu", " ii", "y", "bi", "hi", "v", "mi", "di", "ai", "si", "sp", "multi", "is", "sim", "g", "ami", "b", "cli", "gi", "ip", "oi", "complete", "dr", "in", "t"], "ret": ["mt", "et", "status", "match", "conv", "result", "ref", "res", "ft", "new", "gt", "ll", "at", "mem", "Ret", "fi", "rt", "alt", "val", "nt", "reset", "ri", "elt", "rel", "re", "uf"], "tbase": ["tbuffer", "cbody", "cbuffer", "pBase", "Tbuffer", "TBase", "cbase", "pbuffer", "Tbody", "tBase", "tbody", "pbody", "cBase", "Tbase", "pbase"], "frames": ["steps", "values", "amples", "rows", "ones", "images", "seconds", "flows", "files", "faces", "boxes", "words", "times", "caps", "weights", "fram", "plays", "runs", "fs", "pages", "fields", "cells", "heads", "views", "obs", "Frames", "hops", "parts", "features", "planes", "videos", "errors", "fps", "flags", "points", "events", "lines", "fb", "ints", "frame", "bytes", "blocks", "bits", "windows", "states", "rates", "items", "tracks", "cycles"]}}
{"project": "qemu", "commit_id": "9f1963b3f72521f75a549f8afd61b19e7da63c6f", "target": 0, "func": "static int coroutine_fn raw_co_discard(BlockDriverState *bs,\n\n                                       int64_t sector_num, int nb_sectors)\n\n{\n\n    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);\n\n}\n", "idx": 3920, "substitutes": {"bs": ["ls", "stats", "cks", "bc", "bh", "ss", "bm", "als", "vs", "pb", "bp", "s", "ses", "ds", "bed", "b", "ubs", "fs", "lbs", "BS", "iss", "obs", "ps", "its", "bb", "bos", "ns", "js", "bi", "bis", "ts", "cs", "ks", "ba", "hs", "bps", "bes", "rs", "bid", "bl", "bits", "blog", "sbm", "bas", "gs", "sb", "bn", "bf"], "sector_num": ["sector_dim", "sector_number", "sector2num", "section_num", "sector2number", "sector00num", "sector2mon", "sector_Num", "section2Num", " sector_dim", " sector_pub", "sector2Num", "section2number", "section_Num", "section2mon", "sector_pub", "section_mon", "sector00mon", "sector00dim", " sector_mon", "section_number", "sector00pub", "section2num", "sector_mon"], "nb_sectors": ["nb_seors", "nb_selements", "nb_veors", "nb_SEivers", "nb_vevers", "nb_veivers", "nb_velements", "nb_severs", "nb_SEors", "nb_SEters", "nb_serctors", "nb_serivers", "nb_seivers", "nb_veters", "nb_SEctors", "nb_SElements", "nb_serors", "nb_SEvers", "nb_seters", "nb_servers", "nb_vectors"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n", "idx": 3924, "substitutes": {"bs": ["ls", "cks", "bc", "bh", "ss", "bm", "cus", "uts", "pb", "bp", "s", "ds", "b", "locks", "ubs", "fs", "lbs", "BS", "iss", "obs", "ps", "its", "js", "ns", "aos", "bos", "bi", "bis", "ms", "cs", "ts", "ks", "bps", "aps", "hz", "sts", "rs", "bits", "blog", "bas", "gs", "sb", "bf", "aus", "bsp", "ys", "ubis"], "sector_num": ["sector_orig", "ector_num", "sector_sym", "sector_nm", " sector_nm", " sector_um", " sector_un", "sector_Num", "sector_um", "ector_Num", "sector_un", " sector_mon", " sector_orig", "sector_mon", "ector_mon", "ector_sym"], "nb_sectors": ["nb_sexctors", "nb_seors", "nb_partices", "nb_partors", "nb_veors", "nb_partivers", "nb_bectors", "nb_sels", "nb_vevers", "nb_veivers", "nb_veices", "nb_suctors", "nb_spectors", "nb_segments", "nb_suors", "nb_svers", "nb_beors", "nb_serices", "nb_spegments", "nb_suves", "nb_severs", "nb_partctors", "nb_sexors", "nb_sexvers", "nb_seels", "nb_sctors", "nb_sugments", "nb_seices", "nb_serctors", "nb_speors", "nb_serivers", "nb_speves", "nb_seivers", "nb_sexels", "nb_begments", "nb_sors", "nb_seves", "nb_serors", "nb_beves", "nb_veels", "nb_vectors"], "flags": ["wcs", "mods", "stats", "frames", "atts", "acts", "mask", "nl", "settings", "files", "faces", "details", "weights", "s", "options", "Flags", "ds", " mods", "ants", "lf", "fs", "ols", "heads", "ps", "tags", " interests", "lag", "cf", "ads", "comments", "fps", "amps", " offsets", " bits", "levels", "pins", "cs", "ts", "bps", "offs", "aps", "rs", "ags", "bits", "olds", "posts", "gs", "args", "flag", "ats", "FLAG", "ops", "cmd"], "cb": ["fp", "ec", "cp", "fc", "cd", "CB", "func", "eb", "c", "ub", "bc", "nc", "unc", "cn", "fun", "erb", "pb", "bp", "rb", "b", "lb", "gb", "bb", "cf", "cv", "callback", "ob", "db", "fb", "cc", "sb", "fn", "bf", "ck", "tc", "ctrl"], "opaque": ["oatile", "Openo", "operaque", "opsque", " opacity", "patile", "mopaques", "mopacity", "oaque", "Opaque", "pacity", "oaques", "operque", "paque", "opacity", "paques", "mopaque", " openo", "Opatile", "opsaque", "opque", "oque", "openo", "ipaque", "opsatile", "opsaques", "ipeno", "opaques", "operatile", "Opacity", "mopatile", "Opaques", "ipacity", "operaques", "opatile"]}}
{"project": "qemu", "commit_id": "25db9ebe15125deb32958c6df74996f745edf1f9", "target": 0, "func": "static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n", "idx": 3926, "substitutes": {"d": ["j", "l", "c", "z", "p", "dd", "g", "n", "dc", "r", "s", "ds", "dat", "m", "b", "dev", "dm", "y", "sd", "did", "w", "e", "dos", "de", "dr", "v", "h", "o", "di", "ad", "f", "D", "pd", "da", "t", "des", "dn"], "proxy": ["proc", "cp", "cas", "device", "po", "web", "sh", "port", "roxy", "source", "pipe", "p", "py", "view", "docker", "index", "server", "boss", "pointer", "gp", "reverse", "phy", "native", "x", "force", "su", "phi", "cache", "controller", "weak", "cow", "reply", "ps", "xy", "Proxy", "connection", "pse", "browser", "report", "prime", "command", "cast", "shadow", "alias", "pool", "manager", "project", "remote", "target", "client", "friend", "pin", "echo", "wrapper", "primary", "driver", "super", "flag", "slave", "master", "ping", "pro"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,\n\n                            TCGReg dst, TCGReg lhs, TCGArg rhs,\n\n                            bool rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rIK\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        if (rot < 0) {\n\n            rhs = ~rhs;\n\n            rot = encode_imm(rhs);\n\n            assert(rot >= 0);\n\n            opc = opinv;\n\n        }\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3933, "substitutes": {"s": ["sys", "S", "c", "sg", "bc", "is", "sv", "ss", "p", "cn", "es", "g", "n", "r", "ses", "comm", "ds", "qs", "m", "i", "b", "x", "fs", "sc", "ps", "js", "ns", "bs", "conf", "w", "context", "cs", "ts", "ctx", "ties", "hs", "sts", "an", "rs", "v", "in", "h", "gs", "f", "os", "sq", "t", "aus", "a"], "cond": ["cod", "fc", "mut", "c", "count", "bc", "CON", "sec", "dict", "ref", "bool", " Cond", "act", "condition", "pos", "cont", "lock", "red", "def", "win", "cmp", "config", "conf", "rot", "circ", "ctx", "comp", "con", "co", "ind", "cut", "bo", "loc", "pre", "ct", "col", "Cond", "rc", "state", "cmd"], "opc": [" opz", "optca", "ppc", "iopci", "operatorcache", "iopca", "opC", "opca", " opci", "copC", "iopc", "ropca", "operca", "ropz", "optc", "ropcache", "opercin", "operatorcin", "OPca", "opcs", " opC", "operatorca", "copca", "ropcin", "ppcode", "operatorc", " opcs", "opcode", "ppz", "opci", "OPci", "opz", "OPcs", "OPc", "copc", "copci", "operc", "ropci", "optC", "iopcs", "ppci", "ropc", "opcin", "opcache", "optci", " opcode", "opercache", " opca", "ropcode"], "opinv": ["opin", " opvec", "ipin", "opvec", "ipinv", "opsInv", "hopinv", "ompinv", " opin", " opInv", "hopvec", "ompInv", "ipInv", "hopInv", "opsvec", "opInv", "oprev", "ipc", "ompc", "ompin", " oprev", "opsrev", "opsinv", "hoprev"], "dst": ["sdnd", "lsts", "dost", "sdsts", "Dest", "lest", "lost", "dsnd", "lst", "dssts", "dsst", "dsts", "Dsts", " dnd", "Dost", " dest", "dest", "Dst", "dsost", " dost", "sdst", "dnd", " dsts", "Dnd"], "lhs": [" lgs", "rst", "Lps", " lts", "Lxs", "rlxs", " lps", "lst", "rlhs", "lgs", " lxs", "lps", "dhs", "lxs", "rps", "rxs", "rgs", "lts", "Lhs", "Lst", "dts", "rlst", "rts", "rlgs", "dxs", " lst"], "rhs": [" rht", "mrph", " rrh", " rts", "lrh", " rhea", " rHS", "arxs", "rgts", " rph", "erhs", "rrs", "arht", "hh", "rHS", "lHS", "rht", "errh", "Rhs", "hhs", " rxs", "dHS", "mrht", "arhs", "lfs", "hts", "mrhs", "dhea", "dfs", " rsh", "erht", "rfs", "dhs", "rh", "rgsh", "lxs", "lph", "rxs", "rsh", "hsh", "rrh", "lhea", "RHS", " rh", " rfs", "rgh", "rghs", "arHS", "mrHS", "arrh", "Rrs", "dts", "drs", "erHS", "Rts", "rph", "rts", "lht", "rhea", " rrs", "dxs"], "rhs_is_const": ["rhs_is_co", "rhs_is_con", "rhs_Is_Const", "rhs_is__con", "rhs_Is_const", "rhs_Is_cont", "rhs_is_cont", "rhs_is__const", "rhs_is_Const", "rhs_is__Const", "rhs_Is_con", "rhs_is__cont"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static int twl92230_init(i2c_slave *i2c)\n\n{\n\n    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);\n\n\n\n    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);\n\n    /* Three output pins plus one interrupt pin.  */\n\n    qdev_init_gpio_out(&i2c->qdev, s->out, 4);\n\n    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);\n\n    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];\n\n\n\n    menelaus_reset(&s->i2c);\n\n\n\n    return 0;\n\n}\n", "idx": 3946, "substitutes": {"i2c": ["iu5cs", " i2cc", "api102dc", "i1cs", "i4d", "i5e", "iu2e", "iorte", "iu2c", "i5c", "iu2cs", "iortd", " i2e", "i4e", " i1con", "i5cs", "iletc", " i1c", "i4cu", "i1e", "i1c", "api2e", "i3C", "i1ca", "i2e", "i1C", "iletcc", "api102c", "i2cc", "i5dc", "i3e", "api2cu", "i2C", "i3c", "i1cc", "iu5c", "i3dc", "i1ce", "i102c", "iortc", "i102cu", "i102e", "i4dc", "api2c", "iu5dc", "i2cu", "i2d", "i1con", " i1d", "i3cs", "iletca", "iu2dc", " i1ce", "iletC", "iu5e", "i4ce", "i2dc", "api102cu", "i3cc", "i1d", " i1e", " i2C", "i102dc", "iortcon", " i1C", "iletce", "i2ce", "i4con", "i2con", " i2ce", "i2ca", " i2ca", "i2cs", " i1cc", "i4c", "i1cu", " i1ca", "api102e", "api2dc", " i2d", "ilete", " i2con", "i4ca", "i1dc"], "s": ["sys", "sis", "ls", "S", "j", "d", "stats", "l", "c", "is", "sv", "ss", "source", "p", "settings", "g", "n", "es", "r", "ses", "sa", "set", "ds", "qs", "i", "b", "fs", "less", "su", "aws", "iss", "services", "ps", "js", "ns", "bs", "sw", "conf", "y", "w", "e", "sam", "ts", "spec", "cs", "sm", "hs", "ar", "has", "sts", "an", "rs", "v", "in", "h", "o", "gs", "f", "sb", "ats", "st", "sol", "sq", "os", "t", "so", "a", "se", "self"]}}
{"project": "FFmpeg", "commit_id": "e8c4df40e399fc87c6167c5557c11e0d904ca720", "target": 1, "func": "static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n\n    AVCodecContext *enc = trk->enc;\n\n    unsigned int samplesInChunk = 0;\n\n    int size= pkt->size;\n\n\n\n    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */\n\n    if (!size) return 0; /* Discard 0 sized packets */\n\n\n\n    if (enc->codec_id == CODEC_ID_AMR_NB) {\n\n        /* We must find out how many AMR blocks there are in one packet */\n\n        static uint16_t packed_size[16] =\n\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};\n\n        int len = 0;\n\n\n\n        while (len < size && samplesInChunk < 100) {\n\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n\n            samplesInChunk++;\n\n        }\n\n        if(samplesInChunk > 1){\n\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n\n            return -1;\n\n        }\n\n    } else if (trk->sampleSize)\n\n        samplesInChunk = size/trk->sampleSize;\n\n    else\n\n        samplesInChunk = 1;\n\n\n\n    /* copy extradata if it exists */\n\n    if (trk->vosLen == 0 && enc->extradata_size > 0) {\n\n        trk->vosLen = enc->extradata_size;\n\n        trk->vosData = av_malloc(trk->vosLen);\n\n        memcpy(trk->vosData, enc->extradata, trk->vosLen);\n\n    }\n\n\n\n    if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {\n\n        /* from x264 or from bytestream h264 */\n\n        /* nal reformating needed */\n\n        int ret = ff_avc_parse_nal_units(pkt->data, &pkt->data, &pkt->size);\n\n        if (ret < 0)\n\n            return ret;\n\n        assert(pkt->size);\n\n        size = pkt->size;\n\n    } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {\n\n        /* copy frame to create needed atoms */\n\n        trk->vosLen = size;\n\n        trk->vosData = av_malloc(size);\n\n\n\n        memcpy(trk->vosData, pkt->data, size);\n\n    }\n\n\n\n    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {\n\n        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));\n\n        if (!trk->cluster)\n\n            return -1;\n\n    }\n\n\n\n    trk->cluster[trk->entry].pos = url_ftell(pb);\n\n    trk->cluster[trk->entry].samplesInChunk = samplesInChunk;\n\n    trk->cluster[trk->entry].size = size;\n\n    trk->cluster[trk->entry].entries = samplesInChunk;\n\n    trk->cluster[trk->entry].dts = pkt->dts;\n\n    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;\n\n\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n\n        pkt->pts = pkt->dts;\n\n    }\n\n    if (pkt->dts != pkt->pts)\n\n        trk->hasBframes = 1;\n\n    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;\n\n    trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY);\n\n    if(trk->cluster[trk->entry].key_frame)\n\n        trk->hasKeyframes++;\n\n    trk->entry++;\n\n    trk->sampleCount += samplesInChunk;\n\n    mov->mdat_size += size;\n\n\n\n    put_buffer(pb, pkt->data, size);\n\n\n\n    put_flush_packet(pb);\n\n    return 0;\n\n}", "idx": 3956, "substitutes": {"s": ["sys", "ls", "j", "S", "stats", "c", "sg", "ss", "p", "scl", "es", "g", "n", "vs", "r", "xs", "ses", "comm", "set", "ds", "qs", "m", "i", "b", "fs", "sc", "aws", "ps", "its", "js", "ns", "bs", "conf", "w", "e", "cs", "ts", "spec", "hs", "sts", "rs", "v", "h", "src", "gs", "ats", "ins", "os", "sq", "t", "a"], "pkt": ["rkt", "cptx", " ppt", "racket", "Packet", "Pkg", "nkg", "opkt", "Pwk", "mpt", "ppt", "hkt", "ppkg", "pwd", " ptx", " pct", "opacket", "nkt", "wwd", "tpwk", " pwd", "dacket", "dkt", " pwk", "tpkt", "cpnt", "mnt", "Pkt", "cpwk", "ppkt", "rkg", "tpkg", "packet", " pkg", "rpt", "hkg", "oppt", "pct", "npt", "hpt", "Pct", "hacket", "ppwk", "wkg", "pkg", "cpacket", " packet", "pnt", "nacket", "pwk", "Pnt", "wacket", "cpkg", "mct", " pnt", "macket", "mkt", "wkt", "dkg", "opkg", "Ptx", "mtx", "cpkt", "mkg", "ptx", "ppacket", "dwd", "tpacket"], "mov": ["smvo", "amOV", "cmOV", "amrav", " move", "mrav", "smOV", "smov", "smove", " mOV", "gmove", "mOV", " mvo", "gmOV", "move", "gmvo", "amove", "cmov", "cmove", "amov", "gmov", "cmrav", "mvo", " mrav"], "pb": ["fp", "obb", "cp", "lp", "wp", "tmp", "jp", "buf", "pc", "ub", "eb", "tk", "p", "conv", "np", "bp", "mp", "pp", "vt", "cb", "rb", "gp", "td", "b", "pac", "lb", "PB", "vp", "tp", "bb", "bs", "pa", "cv", "ctx", "pl", "pool", "ob", "pkg", "wb", "bps", "db", "fb", "dp", "pan", "sb", "pid", "tc", "uf", "typ"], "trk": ["grck", "Trk", "TRkr", "trm", "grkm", "tarik", "trch", "grk", "thkar", "trK", "Trks", "rtik", "tenkn", "tarkk", "tarka", "ptrk", "ptrch", "terak", "brkn", "tlak", "transkin", "trakm", "brK", "trkw", "brek", "trakl", "prk", "TRk", " trkm", "grch", "thck", "terik", "Trck", "srK", "srkin", "trek", "rtks", "trak", "grik", "tenkar", "vrks", "thik", " trkid", "trck", "ctrks", "trakw", "grak", "transck", "terch", "tlK", "tlkid", "brkl", "tarkar", "trkid", "prK", "trka", "tarks", "Trkr", "brak", "TRkid", "trkar", "tln", "track", " trik", "ctrkid", "transK", "brn", "prm", "tark", "rtk", "tlk", "turk", "brck", "srk", "tran", " trK", "trkin", "vrka", " trkr", "tenak", "thka", "trkr", "trkl", " trck", "vrk", "tlkn", "terk", "ctrk", "tenck", "traK", "ptrak", "trn", "prck", "brkin", "trik", "tlck", " trkw", "tlkl", "grkw", "tenk", "turik", "grK", "ptrik", "turck", "srck", " trks", "tlik", "tlek", "trkn", "ctrik", "tenkk", "brk", "trkm", "trkk", "grm", "thK", "vrik", "trks", "tenka", "TRck", "thkk", "thm", "transk", "brik", "turek", "thk", "TRks", "rtkid", "thks", "TRK"], "enc": ["ec", "acc", "ang", "cod", "isc", "fc", "env", "et", "iq", "buf", "code", "encrypted", "nc", "ext", "sec", "ent", "conn", "conv", "ev", "eric", "ic", "hw", "util", "ENC", "exc", "lib", "act", "esc", "inc", "kt", "Enc", "ack", "cmp", "gen", "crypt", "iv", "vec", "oc", "kw", " Enc", "desc", "oder", "cv", "en", "rec", "ctx", "con", "len", "coll", "anc", "loc", "ew", "nt", "rc", "nec", "lang", "ac", "obj", "eng", "auth", "ens"], "packed_size": ["packed_name", "packed_len", "packed2name", "packed2size", "packed_type", " packed_name", " packed_type", " packed2size", "packed_Size", " packed2SIZE", " packed_Size", " packed2type", " packed_SIZE", " packed_len", "packed2SIZE", " packed2name", "packed_SIZE", "packed2type", "packed2Size", "packed2len"], "samplesInChunk": ["samplesInChair", "samplesOutchunk", "samplesOutChunc", "samplesInPartard", "samplesInchunk", "samplesinChick", "samplesinClunks", "samplesOutChunks", "samplesINInstunk", "samplesInInstard", "samplesInCodack", "samplesInchack", "samplesINChard", "samplesInChoo", "samplesInCHunks", "samplesinClunk", "samplesINInstair", "samplesOutchucket", "samplesInCHoo", "samplesinChunks", "samplesInChunks", "samplesInPartunc", "samplesINChunk", "samplesInCHucket", "samplesInChard", "samplesInChucket", "samplesInCompunc", "samplesOutChucket", "samplesinChoo", "samplesInClick", "samplesInClunks", "samplesInClunk", "samplesInPartick", "samplesinCompunk", "samplesOutChunk", "samplesInChunc", "samplesinchunc", "samplesInCHunk", "samplesInchunks", "samplesInClunc", "samplesinClucket", "samplesinchunk", "samplesINChair", "samplesInChack", "samplesInCodunk", "samplesInCompunk", "samplesInPartair", "samplesInInstunk", "samplesInClack", "samplesInchucket", "samplesInInstunks", "samplesINChucket", "samplesOutchunks", "samplesINInstard", "samplesInInstair", "samplesinchick", "samplesinChunc", "samplesInchick", "samplesOutchunc", "samplesInPartucket", "samplesInchunc", "samplesINInstucket", "samplesinChunk", "samplesInCHair", "samplesInCodunc", "samplesInCHard", "samplesInClucket", "samplesInCompunks", "samplesInInstoo", "samplesInChick", "samplesInCloo", "samplesinCompunc", "samplesinChucket", "samplesinCloo", "samplesInInstucket", "samplesinCompunks", "samplesInPartunk"]}}
{"project": "qemu", "commit_id": "b835e919f022d768abdf00e8dc94f1a23fdcab15", "target": 1, "func": "static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 3960, "substitutes": {"ctx": ["sys", "batch", "cp", "ctrl", "ctr", "wcs", "aux", "func", "tmp", "jp", "pc", "c", "xc", "bc", "nc", "bh", "height", "conn", "conv", "p", "hw", "ca", "np", "txt", "kl", "cfg", "cb", "act", "tx", "kt", "msg", "this", "sc", "qt", "cur", "req", "cmp", "history", "scope", "kw", "ctl", "cf", "hl", "context", "setup", "cv", "wd", "via", "pool", "gc", "obj", "pkg", "loc", " cx", "cc", "nt", "cu", "wx", "ct", "cl", "cm", "resp", "iat", "tc", "jac", "cmd", "sp"], "opc": [" popc", "hopn", "opcn", " popct", "iopct", "popn", "iopc", "opnc", "iopcz", " popcs", "popcn", "hopc", " popcz", "opcs", " opcz", "popc", "hopnc", "hopcn", " opcs", "OPcn", "OPc", "opct", "iopcs", " opct", "popnc", "OPnc", "OPn", "opcz"], "rt": ["mt", "sys", "rd", "art", "et", "dt", "addr", "vr", "format", "tt", "port", "rid", " addr", "attr", "r", "index", "RT", "iter", "yt", "rw", "rate", "ft", "kt", "start", "off", "gt", "qt", "it", "at", "tp", "pat", "bt", "rot", "rf", "ptr", "rec", "fr", "round", "rl", "ind", "quote", "alt", "loc", "rx", "rs", "nt", "root", "rel", "ret", "wt", "unit", "ot", "reset", "iat", "t", "feat", "NT", "typ"], "base": ["bound", "br", "id", "et", "size", "mb", "back", "p", "kb", "style", "ref", "r", "bp", "ase", "set", "bit", "b", "start", "pe", "Base", "type", "bt", "based", "ip", "scope", "file", "pa", "local", "buffer", "area", "name", "alias", "cpu", "origin", "db", "address", "root", "bas", "f", "unit", "line", "bf", "reset", "prefix", "nb", "se"], "offset": ["mt", "bound", "id", "key", "et", "op", "size", "shift", "addr", "port", "slot", "row", "attr", "ref", "index", "r", "util", "pointer", "set", "bit", "pos", "start", "off", "type", "pad", "ta", "location", "end", "block", "error", "rot", "ptr", "attribute", "area", "Offset", "range", "address", "padding", "position", "unit", "reset", "timeout", "point", "t", "prefix", "length"], "opn": [" opns", "oefn", "opcn", "opner", " opnn", "oecn", " ipn", "pc", " opfn", "oen", " opnc", "pn", " ipd", "appn", "optc", "opnc", "opnn", "opsn", "appc", "ipcn", "ippcn", "ipns", "ipnc", "ipsn", "oppner", "oener", "oppn", " opcn", "appcn", "oppfn", " ipc", "appsn", "ippn", "optns", "ippc", "ipnn", "oppcn", "opfn", "opd", "opns", "ipc", "optnn", " opsn", "ipn", "pnc", "ippnc", "pd", " opner", "optn", " opd", " ipnc"], "t0": ["entZero", "t08", "tos", "ttzero", " tos", " tk", "tk", "ctos", "ctk", "T1", " t3", "tZero", " tor", "t00", "vt1", "ot0", "te08", "otarg", "ta00", "t3", "vt0", "T00", " t000", "teZero", "tt3", "ot2", "t2", "ent08", "tor", "Targ", " t00", "ent0", "tezero", "T000", "targ", "ttk", "t000", "ta0", "Tor", "te0", "T3", "T2", "tt0", "vtor", "entzero", "ttZero", "ta000", " t2", " targ", "ct1", "T0", "ta1", "ct0", "tzero", "tt1", "tt08", "ttos"], "t1": ["otone", "to2", "otric", "m0", "nt1", "t6", "nt0", "t01", "Tone", "T6", "toor", "treeOne", "e0", " t01", "taric", "e01", "T1", "tric", "mOne", "m1", " tor", "ot0", "T01", "tree01", "to6", "t100", " tOne", "tone", "taOne", "t2", " tone", "tree100", " t6", "tor", "to1", "ot1", "ta0", "otOne", "m2", "tree1", "Tor", "T2", " t2", "TOne", "Tric", "ot100", "T0", "ta1", " t100", "nt2", "ntOne", "e2", "ot01", "e1", "tOne"]}}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n", "idx": 3970, "substitutes": {"dma": [" dMA", "mwa", "dpa", "mma", "mdma", " dme", "Dmo", "mmm", "djma", " dna", "djMA", "Dma", " dwa", "mme", " dmo", "mdpa", "Dwa", "mdmo", "mna", "mdmm", "mmo", "mdme", "dMA", " dpa", "djmo", "djpa", "mdwa", "dwa", "dme", "mdMA", "dmo", "dna", "dmm", " dmm", "Dna"], "is_write": ["is_rw", "is_read", "is2writer", " is_read", "is2read", " is_writer", "is2rw", "is2write", "is_writer", " is_rw"], "bm": ["mt", "cp", "mb", "fam", "drm", "lamm", "bp", "lam", "dm", "vm", "bo", "am", "rm", "gs", "dim", "sb", "fn", "mem", "asm", "ht", "mr", "br", "monitor", "ool", "bank", "bc", "bh", "web", "pm", "pb", "mg", "cb", "m", "phy", "bs", "um", "bis", "sam", "im", "bg", "bal", "hs", "mm", "cm", "abl", "bn", "arb", "nb", "mc", "BM", "ym", "comm", "cache", "bi", "nm", "bin", "hm", "db", "mn", "mi", "sbm", "rem", "ram", "bf", "gm", "imm", "il", "eb", "ay", "txt", "lib", "ail", "b", "em", "mx", "bol", "wm", "tm", "bb", "bt", "irm", "sm", "bridge", "bl", "umi", "om"], "s": ["sys", "ls", "S", "q", "stats", "c", "sg", "is", "sv", "ss", "p", "es", "settings", "n", "g", "sl", "als", "vs", "ses", "sa", "set", "ds", "comm", "qs", "m", "i", "fs", "store", "services", "ps", "its", "js", "ns", "bs", "sw", "y", "sd", "ims", "w", "bis", "ms", "ports", "ts", "cs", "spec", "ains", "sm", "hs", "sts", "rs", "h", "gs", "sb", "ats", "sn", "sol", "sq", "so", "states", "ins", "ys", "serv", "os", "ssl", "sp"], "pci_dev": ["pci2div", "pci_data", "ppi_device", "pci_obj", "pci____device", "pci67home", "pci_ev", "pciaxyev", "pci2device", "pci_device", "pci67device", "pcu_home", "pcu_device", "pci_pad", "pcu_div", "pci_div", "pdi_ev", "pci____div", "pdi_data", "pciaxydev", "pci2dev", "pcu_dev", "pdi_dev", "pciaxydevice", "pcu_server", "pci2server", "pci_server", "pci67dev", "pci67pad", "pciaxyobj", "ppi_ev", "pci____dev", "pci____server", "ppi_obj", "pci_home", "pcu_pad", "ppi_dev", "pdi_device"], "prd": ["polr", "Prp", "Prad", "pordl", " prond", "prad", "PRm", "prder", " prder", "port", "prD", "prode", "grd", "prde", " prde", "prp", "PRr", "sprd", "ptrd", "servd", "exprd", "prt", "pd", "Prl", "prdd", "exprdd", "prdx", "servs", "exprdx", "exprp", "pirdx", "ptrn", "sprr", "PRds", "polde", "prdl", "PrD", " prdd", "ptrds", " prl", "pirdd", " prt", " prad", "replad", "prm", "servr", " prD", "sprn", "prl", "repld", "poldx", "Prdd", "exprder", " prr", "pird", " prdl", " prn", "prs", " prds", "grp", "prds", "grl", "sprds", "Prond", " prp", " prs", "grD", "sprs", "pold", "exprl", "sprm", "pror", "pdd", "servder", "replond", "sprder", "ptrr", "pirl", "pder", "prod", "pp", "pirt", "pord", "prn", "pordx", " prdx", "pirdl", "prond", "prr", "prodx", " prm", "PRd", "Prd", "repldd"], "l": ["ls", "d", "ul", "lp", "le", "list", "size", "L", "il", "ol", "nl", "z", "g", "n", "lic", "la", "sl", "kl", "lt", "li", "lo", " L", "m", "lf", "i", "b", "x", "lit", "lock", "ll", "fl", "length", "lv", "local", "hl", "dl", "tl", "el", "pl", "ln", "ell", " el", "loc", "v", "h", "ml", "o", "lu", " le", "f", "line", "lis", "lc", "al", "ld"], "len": ["ls", "lp", "le", "size", "L", "il", "addr", "nl", "gl", "n", "lic", "la", "sl", "kl", "lim", "lt", "iter", "li", "Len", "lib", "lf", "fin", "pos", "seq", "lan", "ll", "cmp", "fl", "lon", "length", "hl", "tl", "el", "en", "ln", "alt", "ell", "v", "val", "lin", "bl", "ml", "gz", "cl", "lc", "elt", "mem", "ld"]}}
{"project": "FFmpeg", "commit_id": "5a2ad7ede33b5d63c1f1b1313a218da62e1c0d48", "target": 0, "func": "static int apply_window_and_mdct(vorbis_enc_context *venc,\n\n                                 float *audio, int samples)\n\n{\n\n    int channel;\n\n    const float * win = venc->win[0];\n\n    int window_len = 1 << (venc->log2_blocksize[0] - 1);\n\n    float n = (float)(1 << venc->log2_blocksize[0]) / 4.0;\n\n    AVFloatDSPContext *fdsp = venc->fdsp;\n\n\n\n    if (!venc->have_saved && !samples)\n\n        return 0;\n\n\n\n    if (venc->have_saved) {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memcpy(venc->samples + channel * window_len * 2,\n\n                   venc->saved + channel * window_len, sizeof(float) * window_len);\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2, 0,\n\n                   sizeof(float) * window_len);\n\n    }\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->samples + channel * window_len * 2 + window_len;\n\n\n\n            fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2 + window_len,\n\n                   0, sizeof(float) * window_len);\n\n    }\n\n\n\n    for (channel = 0; channel < venc->channels; channel++)\n\n        venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len,\n\n                     venc->samples + channel * window_len * 2);\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->saved + channel * window_len;\n\n\n\n            fdsp->vector_fmul(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n        venc->have_saved = 1;\n\n    } else {\n\n        venc->have_saved = 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 3971, "substitutes": {"venc": ["venz", "vehcs", "vanac", "dencam", "vetgc", "verl", "vehcurrent", "venf", " venlc", "vancam", "venfc", "munce", "veng", "zenc", "verz", "vetv", "enedca", "venx", " venca", "enedc", "vehc", "vetz", "verec", "venlc", "isenci", "virtc", "venac", "vercu", "vencur", "vendc", "verci", "vinv", "VENec", "tenC", "vergc", "verce", "eneddc", "denc", "vancs", "avenlc", "denac", "vehac", "VENc", "vene", "zencu", "vinC", "isenw", "isenc", "vence", "avenl", "muncache", "vinac", "virtconf", "vince", "tencs", "vehce", "erencur", "enedcer", "vencu", "vehca", "vencurrent", "avenn", " venac", "vanec", "vancu", "vinf", "venw", "avenv", "enedv", "erence", "vincs", "tence", "vinz", "ovenf", "enedcurrent", "vehg", "terncur", "tenv", "verca", "vercc", "verlc", " vencam", "vandc", "venmc", "enedconf", "VENv", "vinec", "vencache", "zenlc", "verC", "erenx", " venec", "ovenca", "virtce", "erenz", "zenn", "avencs", "virtv", "vincache", "vancer", "venn", " vencc", "vencs", "fendc", "vanc", "tenc", " vencur", "avenac", "isenl", "vinc", "avendc", "vance", "ternc", " vencache", "avene", "vertc", "ovenc", "venca", "enedcu", "tencer", "vinlc", "avence", "ternec", "verx", "vetce", "vehcall", "vencam", " vencs", "ving", "vetconf", "erencurrent", "ternfc", "vancur", "venl", "ovenz", "vetcur", "tenec", "vindc", "erencu", "vehcer", "vertcam", "munc", "vingc", "vencc", "erenca", "mung", "vencall", " vencu", "vehcu", "avenci", "vincer", " vence", "vinca", "vancache", "verw", "vertac", "vinfc", "erenf", "vinmc", "avencam", "venec", " vendc", "vanmc", "venv", "avencu", "dene", "vetx", " veng", "vermc", "fencache", "venci", "verc", "enedcc", "vengc", "enedce", "vetlc", "fenec", " vene", "fenc", "venC", "vetC", "avenec", "vetdc", "VENC", "avenw", "vencer", " venv", "venconf", " venC", "vetec", "erenc", " venn", "vetc", "vincu", "vertec", "avenc", "enedcall", "vincur", "erencall", "vang", "vetfc"], "audio": ["wav", "image", "ogram", "amples", "input", "batch", "data", "total", "hello", " soundtrack", "vo", "sample", "speech", "window", "relative", "mpeg", "sound", "memory", "audi", "native", "music", "ogg", "above", "volume", "au", "voice", "output", "video", "array", "integer", "wave", "in", "play", "media", "alpha", "current", "Audio", "binary", "av", "a", "length", "recorded"], "samples": ["tamples", "damps", " saved", "rsamples", "csamps", "Sourses", "alsamps", "atsaved", "scamps", " samps", "csources", "atsamples", " sourses", "isamps", "tizes", "rsamps", "ssaved", "tsources", "asaves", "asources", "nsamples", "sockets", "sizes", "scamples", "isaves", "scockets", "insamps", "exaves", "asents", "ssamps", "sents", "saved", "insamples", "csamples", "nsamps", "exannels", "Sample", " sents", "insaved", "Sounds", "alsaves", "Sources", "examples", "damples", "Sizes", "asamples", "nsockets", "ssamples", "alsamples", "tsannels", "Samples", "tamps", "dannels", "exources", "ssaves", "sample", "Saves", "insources", "ssources", "saves", "atsources", "tsamps", "rsents", "tsaves", "Samps", "sourses", "exaved", "ssounds", "atsaves", "sannels", "nsaved", "asamps", "scaved", " sources", "tsamples", "isaved", "tsaved", "samps", "sources", "csourses", "tounds", "examps", "alsample", "daved", " sounds", "isockets", "asample", "Saved", "Sents", "isamples", "ssizes", "rsaved", "sounds"], "channel": ["user", "column", "component", "window", "server", "menu", "cloud", "form", "axis", "can", "version", "cam", "ann", "pattern", "manager", "queue", "group", "console", "handler", "campaign", "batch", "monitor", "key", "Channel", "row", "annels", "service", "coord", "character", "relation", "variable", "token", "cell", "entity", "name", "chan", "member", "remote", "category", "frame", "unit", "button", "byte", "chain", "section", "slot", "slice", "actor", "index", "broad", "processor", "counter", "pixel", "panel", "part", "entry", "ord", "controller", "connection", "chn", "call", "block", "attribute", "container", "client", "camera", "col", "worker", "face", "no", "label", "table", "chron", "plugin", "quick", "scope", "config", "browser", "fall", "ch", "player", "command", "course", "color", "resource", "chart", "global", "enabled", " Channel", "field", "peer", "module"], "win": ["doc", "sys", "wav", "work", "wp", "gain", "inv", "size", "aw", "port", "wn", "Win", "n", "init", "window", "hw", "workers", "wa", "rw", "wind", "nw", "pos", "start", "wm", "snap", "gen", "won", "wl", "local", "w", "wd", "oss", "rec", "margin", "bin", "WIN", "wb", "v", "wal", "loss", "val", "play", "alpha", "windows", "root", "gui", "max", "png", "wt", "fn", "ram", "pid", "mem", "scan", "len"], "fdsp": ["dfsc", "fdsc", "fdosp", "pdgp", "sdsp", "dlp", "dltp", "ddsw", "vdsc", "dfosp", "vdtp", "dlisp", "dlosp", "conv", "dlasp", "fdisp", "dlsp", "mdasp", "sdtp", "fdtp", "fdserv", "vdsp", "fdasp", "dfserv", "ddsc", "mdsp", "sdsc", "pdsp", "mdgp", "dlsc", "dlsw", "pdasp", "dfsp", "dlgp", "sdp", "v", "pdisp", "_", "pdsw", "func", "vdsw", "fdp", "ddserv", "ddsp", "pdosp", "vdserv", "cont", "def", "dfgp", "fdsw", "fdgp", "mdisp", "dfsw", "vdp"], "offset": ["bound", "data", "batch", "tile", "et", "key", "size", "offer", "shift", "addr", "delay", "mask", "slot", "absolute", "slice", "seek", "row", "sample", "window", "index", "pointer", "out", "set", "url", "pos", "start", "off", "entry", "zero", "it", "pad", "location", "output", "end", "error", "rot", "attribute", "Offset", "offs", "range", "address", "scroll", "o", "alpha", "padding", "f", "position", "reset", "ot", "seed", "point", "prefix", "online"]}}
{"project": "qemu", "commit_id": "591b320ad046b2780c1b2841b836b50ba8192f02", "target": 1, "func": "static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n", "idx": 3977, "substitutes": {"l": ["ls", "d", "lp", "le", "L", "c", "nl", "p", "g", "n", "sl", "r", "kl", "lt", "li", "lo", "m", "b", "lit", "lb", "lock", "ll", "jl", "like", "length", "lv", "local", "al", "hl", "dl", "tl", "el", "pl", "ln", "v", "h", "ml", "line", "lc", "t", "len", "ld"]}}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int32_t parse_gain(const char *gain)\n\n{\n\n    char *fraction;\n\n    int  scale = 10000;\n\n    int32_t mb = 0;\n\n    int sign   = 1;\n\n    int db;\n\n\n\n    if (!gain)\n\n        return INT32_MIN;\n\n\n\n    gain += strspn(gain, \" \\t\");\n\n\n\n    if (*gain == '-')\n\n        sign = -1;\n\n\n\n    db = strtol(gain, &fraction, 0);\n\n    if (*fraction++ == '.') {\n\n        while (av_isdigit(*fraction) && scale) {\n\n            mb += scale * (*fraction - '0');\n\n            scale /= 10;\n\n            fraction++;\n\n        }\n\n    }\n\n\n\n    if (abs(db) > (INT32_MAX - mb) / 100000)\n\n        return INT32_MIN;\n\n\n\n    return db * 100000 + sign * mb;\n\n}\n", "idx": 3984, "substitutes": {"gain": ["gn", "ang", "age", "acc", "forward", "cale", "status", "aw", "jack", "cn", "ain", "record", "ga", "conn", "g", "seek", "sort", "n", "conv", "sign", "wire", "limit", "say", "query", "charge", "rain", "rank", "gp", "reverse", "phy", "inc", "parse", "ogg", "icon", "inn", "guard", "speed", "gi", "glass", "wm", "snap", "win", "gen", "game", "won", "can", "config", "grad", "wait", "rec", "press", "con", "gc", "gate", "bin", "go", "grain", "scale", "bridge", "group", "pass", "wave", "play", "sb", "raw", "gg", "scan", "eng", "cmd", "clean", "chain"], "fraction": ["fractions", "facraction", " frequency", "vportion", " fportion", "tractions", " Fension", " Fract", "folean", "facault", "fportion", "tension", "cractions", "Fraction", "faccomponent", "cension", "fension", " fractions", "Fractions", " fract", "facract", "volean", "vract", "vraction", "fortportion", "Fault", "fract", " fault", "traction", "vault", "fortault", "tcomponent", "tract", " fcomponent", "Frequency", "fault", "facrequency", "facolean", "cract", "craction", " Fractions", "frequency", " Fraction", " folean", "facractions", "fcomponent", "vractions", "fortractions", "Fract", "fortraction"], "db": ["bound", "d", "mb", "eb", "deb", "nd", "bor", "addr", "bd", "limit", "bm", "record", "bind", "Db", "fine", "ref", "dir", "index", "og", "mg", "cb", "rb", "ds", "sql", "m", "dat", "b", "pg", "be", "gd", "gb", "md", "lib", "ord", "bb", "ig", "orb", "dm", "sd", "buffer", "DB", "dl", "im", "bg", "ob", "bin", "dB", "fb", "orm", "binary", "sb", "bf", "byte", "database", "nb", "base", "ib", "ld", "fd"]}}
{"project": "qemu", "commit_id": "c641483fbe0aa08cd7c0580d019dc2d5a7e71138", "target": 1, "func": "static inline void ide_dma_submit_check(IDEState *s,\n\n          BlockDriverCompletionFunc *dma_cb)\n\n{\n\n    if (s->bus->dma->aiocb)\n\n\treturn;\n\n    dma_cb(s, -1);\n\n}\n", "idx": 3988, "substitutes": {"s": ["sys", "ls", "d", "S", "q", "c", "is", "sh", "sv", "ss", "p", "es", "z", "n", "r", "ses", "ds", "qs", "m", "i", "b", "fs", "ps", "js", "bs", "ns", "e", "ts", "cs", "sts", "rs", "v", "h", "gs", "sb", "ins", "st", "os", "sq", "t", "se", "sp"], "dma_cb": ["dma____callback", "dma_callback", "dwa_fn", "dwa_callback", "dme_callback", "dwa_cb", "dma____cue", "dme_fb", "dme_cb", "dma_cue", "dma_cf", "dma_fn", "dma_fb", "dwa_cf", "dma____cb", "dme_cue", "dma____fb"]}}
{"project": "qemu", "commit_id": "d3c8c67469ee70fcae116d5abc277a7ebc8a19fd", "target": 1, "func": "static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n\n                                 bool query_backing)\n\n{\n\n    BlockStats *s = NULL;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n    s->stats = g_malloc0(sizeof(*s->stats));\n\n\n\n    if (!bs) {\n\n        return s;\n\n    }\n\n\n\n    if (bdrv_get_node_name(bs)[0]) {\n\n        s->has_node_name = true;\n\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n\n    }\n\n\n\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n\n\n\n    if (bs->file) {\n\n        s->has_parent = true;\n\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n\n    }\n\n\n\n    if (query_backing && bs->backing) {\n\n        s->has_backing = true;\n\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n\n    }\n\n\n\n    return s;\n\n}\n", "idx": 4006, "substitutes": {"bs": ["ls", "abilities", "stats", "bitcoin", "banks", "eb", "outs", "cks", "bc", "bh", "las", "soc", "bm", "es", "als", "css", "boxes", "vs", "pb", "uts", "bp", "bles", "ab", "ds", "bed", "cb", "qs", "vals", "b", "ubs", "fs", "lbs", "BS", "obs", "ps", "its", "bb", "js", "ns", "bos", "aos", "was", "bi", "bis", "ms", "cs", "ts", "ks", "bes", "bps", "hs", "hz", "sts", "rs", "blocks", "bytes", "bl", "stones", "bits", "blog", "bing", "bas", "gs", "sb", "ats", "bn", "os", "bf", "aus", "base", "ubis"], "query_backing": ["query_backning", "query_lookging", "query_landging", "query_backening", "query_groupinging", "query_forwardinging", "query_pointing", "query_grouping", "query_backinging", "query_pointging", "query_holding", "query_forwardging", "query_returnging", "query_groupding", "query_backding", "query_backging", "query_landing", "query_groupging", "query_loadging", "query_forwardning", "query_groupning", "query_holdging", "query_bookging", "query_loadinging", "query_returnling", "query_booking", "query_loadding", "query_returning", "query_returnening", "query_lookinging", "query_forwarding", "query_holdling", "query_pointning", "query_groupling", "query_holdening", "query_bookinging", "query_groupening", "query_lookancing", "query_looking", "query_backancing", "query_backling", "query_pointling", "query_landancing", "query_landinging", "query_forwardding", "query_forwardling", "query_loading", "query_bookancing"], "s": ["ls", "c", "ches", "p", "es", "n", "uts", "ses", "set", "params", "services", "its", "conf", "ports", "cs", "ies", "h", "gs", "f", "sb", "args", "os", "a", "stats", "outs", "sv", "settings", "vs", "details", "xs", " reports", "ds", "qs", "m", "eds", "less", "ims", "errors", "bis", "sam", "bes", "hs", "sts", "eps", "pers", "ins", "states", "sq", "ys", "sync", "acs", "self", "j", "S", "l", "ges", "ss", "als", "comm", "utils", "views", "ns", "sw", "y", "ms", "ts", "changes", "v", "uploads", "se", "sys", "rows", "status", "is", "stat", "b", "fs", "ubs", "aws", "ps", "parts", "js", "w", "as", "has", "rs", "ats", "des", "t"]}}
{"project": "FFmpeg", "commit_id": "6f1b2967712e25e4c39c506862982b3011e06532", "target": 1, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n\n                                    const uint8_t *src, const uint8_t *src_end,\n\n                                    int width, int esc_count)\n\n{\n\n    int i = 0;\n\n    int count;\n\n    uint8_t zero_run = 0;\n\n    const uint8_t *src_start = src;\n\n    uint8_t mask1 = -(esc_count < 2);\n\n    uint8_t mask2 = -(esc_count < 3);\n\n    uint8_t *end = dst + (width - 2);\n\n\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n\n    return AVERROR_PATCHWELCOME;\n\n\n\noutput_zeros:\n\n    if (l->zeros_rem) {\n\n        count = FFMIN(l->zeros_rem, width - i);\n\n        if (end - dst < count) {\n\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        memset(dst, 0, count);\n\n        l->zeros_rem -= count;\n\n        dst += count;\n\n    }\n\n\n\n    while (dst < end) {\n\n        i = 0;\n\n        while (!zero_run && dst + i < end) {\n\n            i++;\n\n            if (i+2 >= src_end - src)\n\n                return AVERROR_INVALIDDATA;\n\n            zero_run =\n\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n\n        }\n\n        if (zero_run) {\n\n            zero_run = 0;\n\n            i += esc_count;\n\n            memcpy(dst, src, i);\n\n            dst += i;\n\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n\n\n            src += i + 1;\n\n            goto output_zeros;\n\n        } else {\n\n            memcpy(dst, src, i);\n\n            src += i;\n\n            dst += i;\n\n        }\n\n    }\n\n    return  src - src_start;\n\n}\n", "idx": 4009, "substitutes": {"l": ["ls", "d", "j", "lp", "le", "list", "acl", "L", "il", "c", "nl", "p", "g", "sl", "la", "r", "kl", "lt", "li", "lo", "lib", "url", "m", "b", "lit", "lb", "lock", "ll", "jl", "fl", "lv", "local", "lag", "al", "dl", "tl", "el", "ctx", "pl", "ln", "ell", "v", "lay", "lin", "h", "ml", "cl", "lu", "f", "lc", "t", "ld"], "dst": [" dlist", "drest", "disost", "dhint", "dtST", "dtsc", "dtest", "Dlist", "dhest", "adst", " dirst", " dset", "dsstart", "pest", "adbr", "dsts", " dest", "Dst", "rdest", "dtst", "deost", "rend", " dtd", "desp", "rST", " ddest", "dirst", "ldst", "idst", "dlist", " dsc", "Dsts", "Dost", "Drest", " dbr", "sdrest", "pset", "dbdest", "dest", "adint", "sdest", "Dsc", "dstart", "Dsrc", "dbst", "ldest", " dsts", "Dint", "dbST", " dint", "idST", "ddest", "Dest", "ddlist", "ntd", "rest", "Dirst", "rsts", "Dsp", "nest", "dhdest", "pst", "dend", "dset", "nsts", "deest", "sdirst", "dbr", " dsrc", "dsst", "dST", "lddest", "rsrc", "dtd", "disest", "dsrc", "dsc", "sdst", " dST", "dsbr", "dsint", " drest", "pST", "dint", " dstart", "idend", "rst", "dost", "Ddest", "nst", "iddest", "ddST", "ldST", "ddst", "Dset", "dissp", "DST", "Dtd", "adstart", "dsp", "disst", "dhst", "dbend"], "src": ["usr", "ctr", "tmp", "c", "height", "init", "sup", "window", "iter", "out", "load", "sc", "sur", "sr", "comp", "ind", "sb", "scan", "inner", "bc", "source", "conv", "text", "sort", "dist", "seq", "it", "bs", "sub", "iv", "trans", "ptr", "stream", "ln", "dest", "loc", "offset", "ident", "ins", "begin", "sq", "secure", "sync", "supp", "length", "std", "sn", "inst", "addr", "sl", "stock", "send", "cur", "syn", "sw", "hl", "str", "rl", "bin", "target", "rc", "ssl", "proc", "sys", "input", "stack", "xff", "sec", "stat", "img", "attr", "txt", "r", "s", "lit", "start", "cont", "ser", "desc", "rt", "region", "rs", "in", "cc", "screen", "st", "obj", "buff"], "src_end": ["rc_last", "src_last", "rc_stop", "rc_ends", "rc_start", "rc_end", "src_stop", "src_ends"], "esc_count": ["esc2Count", "ec_default", " esc_Count", "esc_found", "esc00Count", "desc_Count", "esc00count", "desc_length", "expr_offset", "escptdefault", "expr_count", "esc2counter", "desc_count", "esc_counter", "esc___counter", "escptcount", "esc___found", "esc_Count", "expr_counter", "esc___count", "esc2count", "ec_sum", "esc00counter", "esc_amount", " esc_found", "expr_amount", "ec_count", "esc2length", "desc_counter", "esc_length", "esc_sum", " esc_counter", "esc00found", "esc_offset", "esc_default", "escptsum", "esc___Count"], "count": ["core", "Count", "id", "ctr", "match", "c", "height", "p", "n", "set", "sum", "found", "buffer", "ind", "scroll", "reset", "a", "batch", "number", "q", "list", "result", "inc", "force", "num", "check", "name", "gc", "offset", "nt", "max", "th", "length", "total", "size", "code", "z", "index", "counter", " c", "find", "cache", "type", "call", "comment", "err", "ctx", "pt", "v", "current", "col", "len", "cmd", "cycle", "mount", "add", "temp", "limit", "C", "start", "cont", "amount", "e", "now", "cc", "ct", "ount", " cc", "t"], "src_start": ["rc_stop", "src_offset", "rc_start", "rc_offset", "rc_end", "src_stop"], "end": ["bound", "END", "id", "ff", "size", "rest", "nd", "ext", "z", "ent", "all", "window", "out", "set", "send", "ending", "hend", "start", "it", "ended", "stop", "final", "w", "e", "pend", "en", "append", "End", "len", "dest", "ind", "offset", "ender", "last", "est", "max", "st", "begin", "eng", "length"], "i": ["id", "c", "api", "height", "port", "p", "n", "init", "li", "x", "cgi", "iu", "ti", "ind", "uri", "ix", "zi", "h", "ini", "I", "f", "batch", " j", "xi", "ic", "qi", "m", "u", "ui", "it", "ims", "im", "name", "\u0438", "ri", "length", "j", "ii", "size", "ji", "z", "slice", "pi", "index", "ci", "ei", "info", "phi", "ij", "fi", " ii", "y", "bi", "err", "hi", "go", "v", "mi", "di", "ai", "si", "point", "multi", "ki", "status", "instance", "is", "sim", "g", "r", "s", "ami", "b", "cli", "start", "gi", "ip", "oi", "w", "e", "in", "o", "t"]}}
{"project": "qemu", "commit_id": "84593a0807004d852132eaa56edf24d55793d480", "target": 1, "func": "static int ram_init_all(RAMState **rsp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (ram_state_init(rsp)) {\n\n        return -1;\n\n    }\n\n\n\n    if (migrate_use_xbzrle()) {\n\n        XBZRLE_cache_lock();\n\n        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);\n\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),\n\n                                  TARGET_PAGE_SIZE, &local_err);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report_err(local_err);\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n\n\n    /* Skip setting bitmap if there is no RAM */\n\n    if (ram_bytes_total()) {\n\n        RAMBlock *block;\n\n\n\n        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;\n\n\n\n            block->bmap = bitmap_new(pages);\n\n            bitmap_set(block->bmap, 0, pages);\n\n            if (migrate_postcopy_ram()) {\n\n                block->unsentmap = bitmap_new(pages);\n\n                bitmap_set(block->unsentmap, 0, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync(*rsp);\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 4017, "substitutes": {"rsp": ["relserv", "RSP", "rjp", "rtp", " rsm", "rsvol", "rrvol", "rerserv", "rsm", "erspr", "gresp", "rssp", " rhtml", "rpp", "erserv", "erSP", "rssm", "msc", "nrst", "msp", "rsi", "rrsm", " rjp", "ertp", "gsp", " rsw", "rersp", "rerjp", "gjp", "Rst", " rserv", "Rserv", "mjp", " rSp", "rersl", "msw", "Rbsp", "rcsw", "nrsp", "rerspr", "rrhtml", "erst", "rspr", "rbsp", "gsw", "Rsc", "rcpp", "Rsp", "rvol", "rerst", "rsc", "rcst", " rsl", "nrsi", "mserv", "urbsp", "relspr", "urserv", " rSP", "nrsw", "rserv", "rchtml", "rrsp", "Rtp", "ursc", "rsSp", "rcSp", "rsl", "rhtml", "rsw", "mresp", "rrpp", "rst", "rcsp", "rrSp", "ersl", " rtp", "rSp", "rSP", " rvol", " rresp", "mbsp", " rst", "relsp", "rresp", "ersp", "ursp", "reljp", "erjp", " rpp", " rsi", "rcsi"], "local_err": [" local_log", "local_buf", "local____log", "inner_err", "locallyerr", "local_iter", "loc_priv", "localityerr", "local_priv", " local_Er", "local____err", "localityattr", "local_attr", "inner_iter", "loc_cr", "locedcr", "locederr", "localitypriv", "local___priv", "locedattr", "inner_buf", "localederr", "localedcr", "loc_attr", "locedpriv", "localedattr", "loc_err", "local___err", "local_Er", "local___attr", "local___cr", "local_cr", "localitycr", "local____Er", "localedpriv", "local_log", "locallyEr", "locallylog"], "block": ["Block", "batch", "image", "data", "number", "piece", "list", "instance", "word", "object", "bc", "view", "record", "p", "row", "commit", "ref", "window", "BL", "box", "out", "set", "table", "link", "header", "page", "pack", "part", "lock", "start", "check", "cache", "def", "snap", "type", "network", "tag", "ip", "wall", "local", "disk", "buffer", "pool", "bin", "container", "mm", "group", "blocks", "address", "bl", "hash", "loop", "cl", "unit", "line", "byte", "raw", "prefix", "art", "mem", "obj", "sync", "join", "map", "self", "chain"]}}
{"project": "FFmpeg", "commit_id": "86b0d9cd58137fc499f263267c3219ac6186b98e", "target": 0, "func": "static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 4025, "substitutes": {"pix": ["piv", "npixels", "Pix", " pIX", " pct", "cpixels", " piv", "cpix", " px", "PIX", "cpct", "npx", "Piv", "pct", "px", "Pixels", "cpIX", "pIX", "Pct", "pixels", "cpiv", " pixels", "Px", "npIX", "npix"], "stride": ["gride", "strider", "Strider", "divide", "stie", " strade", "Strade", "Stride", " strime", " strie", " strride", "Strride", "suspime", "grride", "strine", "stider", "stide", "Strine", "stine", "Strie", "divime", "suspride", "suspide", "strade", "strride", "stade", "grider", "grine", "strime", "divride", "strie"], "bS": [" biS", "bbFS", "bbSet", " bIS", "chVS", "bbIS", "bcS", " dbSB", "sbINS", "bcINS", " biGS", "ibTS", " bJS", "bbS", "chJS", " bR", " dbGS", "bcDS", "sbR", "bTS", "bV", " bV", "bSB", "nbSet", "nbS", " biSB", "bbINS", "bC", "chC", "bbJS", "sbIS", "bSet", "ibSet", " bGS", "ibC", "bIS", "bbTS", "ibJS", "sbC", "bbVS", " bVS", "bGS", "ibV", "bbV", "sbDS", "chS", "bbC", "bbDS", " dbS", "bVS", "bINS", " bTS", "bbR", "nbJS", "bcFS", "bDS", "sbFS", "ibS", "bFS", "bR", "bJS", "sbS", " bSB", " bC"], "qp": ["iqnp", " qpad", "querypa", "qqnp", "qlpad", "qlP", "questionpa", "questionpc", "qqpp", "qupc", "querynp", "qP", "qqp", "qpc", " qP", "questionp", "qupa", "iqc", "qqP", "iqpc", "qlp", "qup", "queryp", "qpa", "querypc", "quc", "qqc", "qnp", "qpad", "iqp", "qc", "qunp", "qqpc", "qlpp", " qpp", "qpp", "qqpad", "questionnp"], "h": ["q", "l", "he", "ph", "c", "host", "handle", "sh", "bh", "p", "kh", "g", "eh", "hw", "oh", "ah", "H", "hh", "comm", "hp", "m", "header", "b", "dh", "ih", "it", "cache", "history", "k", "ch", "hd", "hl", "w", "context", "rh", "e", "here", "ctx", "hal", "hs", "hm", "hz", "v", "hash", "help", "th", "t", "a", "ht"], "tc": ["ec", "acc", "ctr", "cas", " TC", "fc", "temp", "tim", "c", "pc", "bc", "tt", "unc", "css", "dc", "cus", "uc", "ic", "times", "ci", "asc", "td", "tic", "com", "tx", "uca", "ce", "ui", "cot", "etc", "cache", "tf", "cci", "tv", "toc", "ctl", "cf", "cv", "cs", "ts", "ctx", "aco", "gc", "tu", "currency", "cu", "cc", "fee", "icc", "cm", "rc", "lc", "t", "mc", "ctrl", "TC"]}}
{"project": "FFmpeg", "commit_id": "8c5cd1c9d33b4b287f85d42efb1aecfaee31de6c", "target": 1, "func": "static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,\n\n                                      int w, int h)\n\n{\n\n    ImageContext *img;\n\n    HuffReader *hg;\n\n    int i, j, ret, x, y, width;\n\n\n\n    img       = &s->image[role];\n\n    img->role = role;\n\n\n\n    if (!img->frame) {\n\n        img->frame = av_frame_alloc();\n\n        if (!img->frame)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    img->frame->format = AV_PIX_FMT_ARGB;\n\n    img->frame->width  = w;\n\n    img->frame->height = h;\n\n\n\n    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {\n\n        ThreadFrame pt = { .f = img->frame };\n\n        ret = ff_thread_get_buffer(s->avctx, &pt, 0);\n\n    } else\n\n        ret = av_frame_get_buffer(img->frame, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (get_bits1(&s->gb)) {\n\n        img->color_cache_bits = get_bits(&s->gb, 4);\n\n        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid color cache bits: %d\\n\",\n\n                   img->color_cache_bits);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,\n\n                                            sizeof(*img->color_cache));\n\n        if (!img->color_cache)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        img->color_cache_bits = 0;\n\n    }\n\n\n\n    img->nb_huffman_groups = 1;\n\n    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {\n\n        ret = decode_entropy_image(s);\n\n        if (ret < 0)\n\n            return ret;\n\n        img->nb_huffman_groups = s->nb_huffman_groups;\n\n    }\n\n    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *\n\n                                           HUFFMAN_CODES_PER_META_CODE,\n\n                                           sizeof(*img->huffman_groups));\n\n    if (!img->huffman_groups)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < img->nb_huffman_groups; i++) {\n\n        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];\n\n        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {\n\n            int alphabet_size = alphabet_sizes[j];\n\n            if (!j && img->color_cache_bits > 0)\n\n                alphabet_size += 1 << img->color_cache_bits;\n\n\n\n            if (get_bits1(&s->gb)) {\n\n                read_huffman_code_simple(s, &hg[j]);\n\n            } else {\n\n                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n        }\n\n    }\n\n\n\n    width = img->frame->width;\n\n    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)\n\n        width = s->reduced_width;\n\n\n\n    x = 0; y = 0;\n\n    while (y < img->frame->height) {\n\n        int v;\n\n\n\n        hg = get_huffman_group(s, img, x, y);\n\n        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);\n\n        if (v < NUM_LITERAL_CODES) {\n\n            /* literal pixel values */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            p[2] = v;\n\n            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);\n\n            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);\n\n            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);\n\n            if (img->color_cache_bits)\n\n                color_cache_put(img, AV_RB32(p));\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {\n\n            /* LZ77 backwards mapping */\n\n            int prefix_code, length, distance, ref_x, ref_y;\n\n\n\n            /* parse length and distance */\n\n            prefix_code = v - NUM_LITERAL_CODES;\n\n            if (prefix_code < 4) {\n\n                length = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = (prefix_code - 2) >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                length = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);\n\n            if (prefix_code > 39) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"distance prefix code too large: %d\\n\", prefix_code);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (prefix_code < 4) {\n\n                distance = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = prefix_code - 2 >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                distance = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n\n\n            /* find reference location */\n\n            if (distance <= NUM_SHORT_DISTANCES) {\n\n                int xi = lz77_distance_offsets[distance - 1][0];\n\n                int yi = lz77_distance_offsets[distance - 1][1];\n\n                distance = FFMAX(1, xi + yi * width);\n\n            } else {\n\n                distance -= NUM_SHORT_DISTANCES;\n\n            }\n\n            ref_x = x;\n\n            ref_y = y;\n\n            if (distance <= x) {\n\n                ref_x -= distance;\n\n                distance = 0;\n\n            } else {\n\n                ref_x = 0;\n\n                distance -= x;\n\n            }\n\n            while (distance >= width) {\n\n                ref_y--;\n\n                distance -= width;\n\n            }\n\n            if (distance > 0) {\n\n                ref_x = width - distance;\n\n                ref_y--;\n\n            }\n\n            ref_x = FFMAX(0, ref_x);\n\n            ref_y = FFMAX(0, ref_y);\n\n\n\n            /* copy pixels\n\n             * source and dest regions can overlap and wrap lines, so just\n\n             * copy per-pixel */\n\n            for (i = 0; i < length; i++) {\n\n                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);\n\n                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);\n\n\n\n                AV_COPY32(p, p_ref);\n\n                if (img->color_cache_bits)\n\n                    color_cache_put(img, AV_RB32(p));\n\n                x++;\n\n                ref_x++;\n\n                if (x == width) {\n\n                    x = 0;\n\n                    y++;\n\n                }\n\n                if (ref_x == width) {\n\n                    ref_x = 0;\n\n                    ref_y++;\n\n                }\n\n                if (y == img->frame->height || ref_y == img->frame->height)\n\n                    break;\n\n            }\n\n        } else {\n\n            /* read from color cache */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);\n\n\n\n            if (!img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"color cache not found\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (cache_idx >= 1 << img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"color cache index out-of-bounds\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            AV_WB32(p, img->color_cache[cache_idx]);\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4029, "substitutes": {"s": ["sys", "d", "S", "serv", "stats", "status", "op", "c", "sg", "is", "sv", "ss", "es", "scl", "n", "service", "times", "vs", "r", "session", "g", "ses", "set", "ds", "qs", "m", "b", "fs", "info", "aws", "services", "ps", "its", "js", "ns", "sw", "conf", "ims", "e", "sam", "as", "ts", "cs", "spec", "ctx", "sts", "an", "rs", "gs", "sb", "ins", "ats", "os", "sq", "st", "t", "args", "a", "self"], "role": ["br", "image", "user", "key", "le", "ro", "format", "ole", "source", "slot", "style", "ke", "slice", "only", "fun", "pillar", "r", "label", "node", "order", "mode", "definition", "balance", "rb", "table", "task", "star", "family", "policy", "profile", "relation", "rol", "def", "type", "scope", "tag", "note", "can", "file", "RO", "rot", "level", "binding", "error", "lambda", "attribute", "ti", "name", "resource", "origin", "function", "member", "priority", "Role", "range", "group", "angle", "frame", "by", "rel", "root", " galaxy", "position", "seed", "state", "slave", "base", "rule", "module", "LE", "chain"], "w": ["d", "q", "fw", "wp", "l", "ww", "aw", "c", "wn", "wi", "ow", "hw", "wh", "W", "wa", "m", "rw", "b", " dw", "nw", "win", "wl", "kw", "wd", "iw", "wb", "ew", "wal", "wx", "wr", "wt", "wid"], "h": ["q", "l", "high", "ph", "he", "c", "height", "bh", "z", "kh", "uh", "g", "oh", "ah", "hh", "H", "wh", "ish", "m", "b", "dh", "ih", "hei", "ch", "k", "hd", "hi", "en", "ha", "o", "ho", "f", "t", "ht"], "img": ["gr", "anim", "tmp", "op", "ext", "init", "hw", "app", "aug", "html", "aff", "pg", "form", "xml", "conf", "ann", "shr", "embed", "pkg", "emb", "ind", "am", "f", "dim", "png", "agg", "mem", "ht", "images", "np", "m", "num", "msg", "opp", "it", "tag", "im", "um", "bg", "eval", "uv", "av", "uf", "inst", "jp", "buf", "mask", "inf", "ref", "mp", "amp", "gd", "info", "cache", "att", "comment", "imp", "ob", "str", "nm", "ag", "db", "gm", "imm", "fm", "auth", "cmd", "proc", "doc", "image", "mount", "ahi", "prop", "imgur", "conn", "gif", "iam", "g", "org", "attr", "og", "util", "important", "lib", "url", "orig", "md", "def", " imag", "ip", "desc", "ie", "dr", "imag", "utm", "good", "bl", "pub", "obj", "jpg", "alg"], "hg": ["wbg", "wg", " hbg", " hgs", "hgm", "Hbg", "wgs", "Hg", " hgm", "wgm", "hbg", "hgs", "Hgm", "Hgs"], "i": ["id", "l", "ii", "n", "r", "index", "ci", "li", "m", "b", "it", "ij", " ii", "im", "ir", "ix", "in", "o", "mi", "f", "I"], "j": ["jump", "br", "q", "l", "ii", "jp", "ji", "dj", "aj", "z", "uj", "g", "n", "kj", "r", "m", "b", "pos", "J", "jl", "ij", "job", "js", "k", "jc", "jj"], "ret": ["mt", "usr", "RET", "try", "mb", "ext", "out", "gt", " Ret", "ure", "pas", "ry", "rm", "reset", "resp", "re", "mem", "back", "net", "result", "deg", "at", "Ret", "final", "gc", "alt", "ter", "nt", "arg", "cert", "tr", "elt", "rel", "not", "cat", "alf", "jp", "dt", "addr", "nl", "fun", "ref", "res", "new", "att", "pt", "val", "fail", "rets", "det", "rem", "flag", "len", "cmd", "success", "status", "arr", "Return", "after", "txt", "rect", "bit", "ft", "red", "cont", "def", "complete", "rt", "print", "dr", "mat", "nz", "jpg"], "x": ["image", "fx", "l", "height", "dx", "xi", "xs", "path", "m", "ox", "lat", "tx", "ex", "xy", "xt", "px", "rx", "yx", "ix", "in", "f", "X"], "y": ["ny", "axy", "yl", "height", "iy", "py", "n", "ym", "yt", "sy", "m", "b", "ey", "xy", "ch", "Y", "offset", "yy", "col", "t", "ys", "my", "top"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void ff_mspel_motion(MpegEncContext *s,\n\n                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n\n                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n\n                               int motion_x, int motion_y, int h)\n\n{\n\n    Wmv2Context * const w= (Wmv2Context*)s;\n\n    uint8_t *ptr;\n\n    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;\n\n    int emu=0;\n\n\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n\n    dxy = 2*dxy + w->hshift;\n\n    src_x = s->mb_x * 16 + (motion_x >> 1);\n\n    src_y = s->mb_y * 16 + (motion_y >> 1);\n\n\n\n    /* WARNING: do no forget half pels */\n\n    v_edge_pos = s->v_edge_pos;\n\n    src_x = av_clip(src_x, -16, s->width);\n\n    src_y = av_clip(src_y, -16, s->height);\n\n\n\n    if(src_x<=-16 || src_x >= s->width)\n\n        dxy &= ~3;\n\n    if(src_y<=-16 || src_y >= s->height)\n\n        dxy &= ~4;\n\n\n\n    linesize   = s->linesize;\n\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + (src_y * linesize) + src_x;\n\n\n\n        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos\n\n                              || src_y + h+1 >= v_edge_pos){\n\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,\n\n                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);\n\n            ptr= s->edge_emu_buffer + 1 + s->linesize;\n\n            emu=1;\n\n        }\n\n\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);\n\n\n\n    if(s->flags&CODEC_FLAG_GRAY) return;\n\n\n\n    if (s->out_format == FMT_H263) {\n\n        dxy = 0;\n\n        if ((motion_x & 3) != 0)\n\n            dxy |= 1;\n\n        if ((motion_y & 3) != 0)\n\n            dxy |= 2;\n\n        mx = motion_x >> 2;\n\n        my = motion_y >> 2;\n\n    } else {\n\n        mx = motion_x / 2;\n\n        my = motion_y / 2;\n\n        dxy = ((my & 1) << 1) | (mx & 1);\n\n        mx >>= 1;\n\n        my >>= 1;\n\n    }\n\n\n\n    src_x = s->mb_x * 8 + mx;\n\n    src_y = s->mb_y * 8 + my;\n\n    src_x = av_clip(src_x, -8, s->width >> 1);\n\n    if (src_x == (s->width >> 1))\n\n        dxy &= ~1;\n\n    src_y = av_clip(src_y, -8, s->height >> 1);\n\n    if (src_y == (s->height >> 1))\n\n        dxy &= ~2;\n\n    offset = (src_y * uvlinesize) + src_x;\n\n    ptr = ref_picture[1] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);\n\n\n\n    ptr = ref_picture[2] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);\n\n}\n", "idx": 4041, "substitutes": {"s": ["ls", "c", "sg", "aunts", "p", "es", "n", "app", "ses", "services", "its", "t", "conf", "ports", "cs", "spec", "ies", "an", "gs", "f", "sb", "args", "os", "a", "south", "stats", "sv", "settings", "ds", "qs", "m", "less", "ex", "bs", "ims", "bis", "hs", "sts", "eps", "ins", "sq", "self", "S", "l", "ges", "er", "ss", "als", "comm", "space", "ns", "sw", "y", "ms", "ts", "changes", "v", "se", "ops", "sp", "sys", "is", "g", "r", "b", "fs", "aws", "ps", "js", "e", "comments", "as", "sports", "rs", "o", "ats", "state", "obj"], "dest_y": ["dest__xy", "src_gy", "dest_xy", "dest__x", "dest__gy", "dest_gy", "dest__y", "dest_x", "src_xy"], "dest_cb": ["dest_cpp", "dest_rb", "src_cpp", "src_cb", "dest_cm", "src_cm", "dest8cb", "dest8cm", "dest8rb", "dest8cpp", "src_rb"], "dest_cr": ["destLcr", "dest2cm", "destLcrop", "dest2crop", "src_cb", "src_crop", "dest_crop", "dest_cm", "dest2cr", "destLcm", "src_cm", "dest2cb", "destLcb", "src_cr"], "ref_picture": ["ref_profile", "refobjpict", "ref2reference", "reference_profile", "ref2frame", "ref2image", "ref____reference", "ref_pict", "ref_frame", "refobjprofile", "refobjpicture", "ref_reference", "reference_image", "ref2pict", "reference_frame", "ref____image", "refobjframe", "reference_reference", "ref2profile", "ref_image", "reference_pict", "ref2picture", "reference_picture", "ref____picture"], "pix_op": ["pil_op", "pix2op", "pix_oper", "pil_oper", "pix2oper", "pil_hop", "pix2ops", "pil_ops", "pix_ops", "pix2hop", "pix_hop"], "motion_x": ["motion___xt", "feature___xt", "motion08tx", "feature___xx", "ision_ox", "feature___x", "sequence08ox", "sequence_ox", "motion_ox", "motion00ex", "ision00x", "motion00x", "ision00tx", "sequence_x", "motion___x", "motion_xx", "sequence08left", "motion_ex", "feature_xx", "motion08left", "motion00ox", "feature_y", "motion_xt", "sequence_left", "motion00tx", "ision_ex", "feature_xt", "motion_tx", "motion_left", "ision00ex", "motion___xx", "ision_tx", "motion08x", "sequence08x", "feature_x", "motion___y", "feature___y", "motion08ox", "ision_x", "ision00ox", "motion08ex"], "motion_y": ["music11z", "motion7content", "music11entity", "motion_b", "motion_entity", "motion2b", "motion_yt", "motion___ey", "otion_x", "otion_yy", "feature___x", "feature_yt", "motion67y", "motion7entity", "motion7y", "music11y", "music11content", "motion2x", "motion_ey", "motion7z", "motion67ey", "motion___x", "motion2y", "motion67x", "music_content", "motion11content", "motion__yy", "motion11entity", "motion11z", "feature_y", "motion___yt", "motion__b", "feature___yt", "motion__x", "motion_z", "otion_y", "music_z", "motion_content", "feature___ey", "motion2yy", "motion__y", "motion67yt", "feature_x", "music_y", "motion___y", "music_entity", "feature___y", "otion_b", "feature_ey", "motion11y", "motion_yy"], "h": ["j", "d", "l", "he", "size", "c", "height", "bh", "z", "p", "kh", "uh", "hw", "r", "oh", "hh", "H", "ish", "m", "i", "b", "u", "ih", "y", "ch", "k", "hi", "hs", "hz", "v", "ha", "loop", "hash", "f", "t", "a", "length", "ht"], "w": ["d", "wcs", "fw", "wp", "word", "c", "z", "p", "g", "words", "hw", "window", "r", "weights", "wh", "W", "wa", "m", "rw", "nw", "new", "writer", "sw", "kw", "y", "cam", "e", "wb", "enc", "v", "wt", "RW", "t", "mem", "tw"], "ptr": ["fp", "br", "j", "ctr", "eth", "trace", "tmp", "jp", "shift", "pc", "addr", "p", "seek", "row", "ref", "pointers", "np", "crop", "iter", "index", "pointer", "dist", "r", "td", "i", "Ptr", "pos", "off", "req", "pad", "pr", "ij", "tp", "dq", "y", "buffer", "prime", "ts", "adr", "pt", "loc", "dr", "address", "src", "tr", "rep", "rel", "push", "inter", "sp"], "dxy": [" dwy", "ddaxis", "idaxis", "pdoxy", "sdxy", "fdoxy", "ddx", "sdoxy", "doxy", "dx", "bdpx", " doxy", "dXY", "Dcoord", "Dwy", "idx", "dpx", "Dxf", "ddxy", " dlate", "dwy", "daxis", "bdXY", "sdXY", "bdxy", " dzip", "fdxy", "DXY", " dXY", "dxf", "bdx", "ddxf", "ddwy", "bdoxy", " dxf", "pdzip", "bdxf", "Dzip", " dx", "fdpx", "Dxy", "dlate", "Dlate", "ddoxy", "idXY", "bdwy", "sdcoord", "pdlate", "fdwy", "dzip", "Doxy", "idxy", "ddXY", " daxis", " dpx", " dcoord", "pdxy", "dcoord"], "offset": ["mt", "image", "tile", "key", "op", "size", "shift", "addr", "center", "ay", "index", "crop", "set", "coord", "pos", "start", "off", "xy", "location", "ip", "error", "origin", "Offset", "loc", "mm", "address", "scroll"], "mx": ["mr", "mt", "fx", "ma", "xc", "xs", "mp", "ax", "ox", "mic", "tx", "tm", "tp", "ex", "mph", "xp", "xx", "ms", "px", "rx", "mes", "mn", "mm", "yx", "hz", "mi", "wx", "ml"], "my": ["mr", "mt", "ma", "ty", "py", "cy", "pm", "me", "ym", "mp", "gy", "mid", "sym", "tz", "tom", "ky", "mk", "ms", "ury", "yx", "mm", "mi", "yy", "by", "mis", "ias", "ny"], "src_x": ["source_xc", "rc_X", "src_ry", "src_ox", "src_z", "attr00lat", "source_rx", "source_z", "attr_y", "src00x", "src00name", "src__rx", "src___px", "attr00name", "attr_x", "src___d", "rc_ry", "srcpypx", "src__y", "rc_w", "rc_ex", "src_ex", "src_X", "srcpyyx", "source_ox", "src___z", "source_d", "src_ix", "rc_yx", "source_x", "src_lat", "rc_rx", "srcpyX", "source_y", "src_xc", "rc_x", "srcpyxc", "src__ix", "src_px", "srcpyx", "attr00x", "rc_ix", "src_yx", "srcpyy", "attr00y", "src__ex", "src_w", "src_rx", "source_px", "rc_y", "rc_wx", "src___y", "attr_name", "attr_lat", "srcpyex", "src_wx", "src_d", "src_name", "source_ex", "src___xc", "src00y", "src__x", "src00lat", "src___x"], "src_y": ["src___ies", "inst_yy", "supp_ya", "src_ry", "src_cy", " src_yt", "source_b", "inst_x", "srcaxyx", "srcaxysy", "src_ies", "source_sy", "rc_ey", "supp_yy", "src64y", "inst_cy", "srcaxypy", " src_ies", "supp_y", "inst___cy", "src64i", "src_py", "src_sy", " src_yer", "src___yy", "src_yt", "source_x", " src_b", "source_y", " src_ye", "src___i", "rc_x", "src_Y", " src_yy", "src_ey", "src_ny", "inst_y", "syn_y", "inst___yy", "syn_cy", "syn_xy", "src64yer", "src___yer", "src_yy", "src_ya", "src_xy", "srcaxyy", "src64ies", "src_i", "rc_y", "src___y", "inst___y", "syn_ry", " src_i", "src_b", "source_py", "supp_ny", "src_yer", "src_ye", "inst___x", "source_Y", "src___cy", "src___x"], "v_edge_pos": ["v_ge_pos", "v_edgeptop", "v_edge__pro", "v_ge_Pos", "v_node_pos", "v_Edge_loc", "v_edge__pos", "v_edgeptPos", "v_entity___loc", "v_ge_tag", "v_edge_Pos", "v_edge2position", "v_entity_loc", "v_edge___buf", "v_edge___pos", "v_Edge_pro", "v_entity_pos", "v_edge___pro", "v_edge_buf", "v_edge__loc", "v_Edge_pos", "v_Edge_buf", "v_entity___pos", "v_edge__buf", "v_edge2pose", "v_edge___pose", "v_edge_tag", "v_edge_pose", "v_entity___pose", "v_edge___loc", "v_edgeptpos", "v_entity_pose", "v_edge_pro", "v_edge_op", "v_ge_pose", "v_ge_position", "v_edge_position", "v_edge2pos", "v_node_Pos", "v_ge_op", "v_edgepttag", "v_node_loc", "v_edge_loc", "v_node_position", "v_edge2loc", "v_ge_loc"], "linesize": ["ringsIZE", "linesiz", "stylesizer", "styleszie", "linesate", "codesIZE", "levelsization", "codesizer", "linesization", "pointsized", "inesate", "inesiz", "framesization", "pointsize", "stylesIZE", "codesization", "elinesizer", "linesized", "inesized", "platesiz", "platesizer", "elinesate", "pointsizer", "framesize", "lsiz", "linesIZE", "inesize", "lsization", "stylesization", "levelsize", "elinesized", "ringsization", "inesizer", "lsIZE", "platesize", "codesiz", "platesate", "elinesize", "elinesization", " linesization", "pointsization", "levelsIZE", "codesize", "elinesiz", "elinesIZE", "framesiz", "inesization", "stylesize", "pointsiz", "lsize", " linesizer", "ringsize", "lineszie", "framesized", "levelsized", " lineszie", "codeszie", "inesIZE", "framesizer", "ringsizer", "linesizer"], "uvlinesize": ["uvlinesization", "uvpointsization", "lvlevelsize", "uvineszie", "uvworksize", "uvlevelsiz", "svinesense", "uvlsize", "lvlinesize", "svlinesize", "svlineszie", "uvpointsify", "avlsify", "uvblocksize", "uvlsify", "lvlinesiz", "uvworksization", "uvlsization", "uvlinesify", "uvinesense", "uvpointsize", "svlinesiz", "uvinesization", "avlsization", "uvpointsiz", "svinesize", "uvlinesense", "uvlsiz", "svineszie", "uvlevelsization", "uvlinesiz", "uvlinsize", "uvinesiz", "uvblocksense", "uvworksify", "svlinesense", "avlinesization", "uvlevelsized", "uvlosiz", "svinesiz", "avlsiz", "uvinesize", "uvblocksiz", "uvworksiz", "uvlosize", "uvlinesized", "uvlosized", "uvlinsiz", "avlinesize", "lvlevelsization", "uvinesized", "uvblockszie", "avlsize", "avlinesiz", "uvlineszie", "uvlevelsize", "lvlinesized", "uvlinszie", "lvlevelsiz", "avlinesify", "lvlinesization", "uvlinsense", "lvlevelsized", "uvlosization"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int svq1_encode_plane(SVQ1Context *s, int plane,\n\n                             unsigned char *src_plane,\n\n                             unsigned char *ref_plane,\n\n                             unsigned char *decoded_plane,\n\n                             int width, int height, int src_stride, int stride)\n\n{\n\n    const AVFrame *f = s->avctx->coded_frame;\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    uint8_t *src     = s->scratchbuf + stride * 16;\n\n    const int lambda = (f->quality * f->quality) >>\n\n                       (2 * FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width  = (width  + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n        s->m.avctx                         = s->avctx;\n\n        s->m.current_picture_ptr           = &s->m.current_picture;\n\n        s->m.last_picture_ptr              = &s->m.last_picture;\n\n        s->m.last_picture.f.data[0]        = ref_plane;\n\n        s->m.linesize                      =\n\n        s->m.last_picture.f.linesize[0]    =\n\n        s->m.new_picture.f.linesize[0]     =\n\n        s->m.current_picture.f.linesize[0] = stride;\n\n        s->m.width                         = width;\n\n        s->m.height                        = height;\n\n        s->m.mb_width                      = block_width;\n\n        s->m.mb_height                     = block_height;\n\n        s->m.mb_stride                     = s->m.mb_width + 1;\n\n        s->m.b8_stride                     = 2 * s->m.mb_width + 1;\n\n        s->m.f_code                        = 1;\n\n        s->m.pict_type                     = f->pict_type;\n\n        s->m.me_method                     = s->avctx->me_method;\n\n        s->m.me.scene_change_score         = 0;\n\n        s->m.flags                         = s->avctx->flags;\n\n        // s->m.out_format                    = FMT_H263;\n\n        // s->m.unrestricted_mv               = 1;\n\n        s->m.lambda                        = f->quality;\n\n        s->m.qscale                        = s->m.lambda * 139 +\n\n                                             FF_LAMBDA_SCALE * 64 >>\n\n                                             FF_LAMBDA_SHIFT + 7;\n\n        s->m.lambda2                       = s->m.lambda * s->m.lambda +\n\n                                             FF_LAMBDA_SCALE / 2 >>\n\n                                             FF_LAMBDA_SHIFT;\n\n\n\n        if (!s->motion_val8[plane]) {\n\n            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *\n\n                                                 block_height * 2 + 2) *\n\n                                                2 * sizeof(int16_t));\n\n            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *\n\n                                                 (block_height + 2) + 1) *\n\n                                                2 * sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type = s->mb_type;\n\n\n\n        // dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mb_type = s->dummy;\n\n\n\n        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table                      = s->motion_val16[plane] +\n\n                                               s->m.mb_stride + 1;\n\n        s->m.dsp                             = s->dsp; // move\n\n        ff_init_me(&s->m);\n\n\n\n        s->m.me.dia_size      = s->avctx->dia_size;\n\n        s->m.first_slice_line = 1;\n\n        for (y = 0; y < block_height; y++) {\n\n            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly\n\n            s->m.mb_y                  = y;\n\n\n\n            for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                       width);\n\n                for (x = width; x < 16 * block_width; x++)\n\n                    src[i * stride + x] = src[i * stride + x - 1];\n\n            }\n\n            for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n                memcpy(&src[i * stride], &src[(i - 1) * stride],\n\n                       16 * block_width);\n\n\n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x = x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n\n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line = 0;\n\n        }\n\n\n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,\n\n                        CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n\n\n    s->m.first_slice_line = 1;\n\n    for (y = 0; y < block_height; y++) {\n\n        for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                   width);\n\n            for (x = width; x < 16 * block_width; x++)\n\n                src[i * stride + x] = src[i * stride + x - 1];\n\n        }\n\n        for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);\n\n\n\n        s->m.mb_y = y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7 * 32];\n\n            int count[3][6];\n\n            int offset       = y * 16 * stride + x * 16;\n\n            uint8_t *decoded = decoded_plane + offset;\n\n            uint8_t *ref     = ref_plane + offset;\n\n            int score[4]     = { 0, 0, 0, 0 }, best;\n\n            uint8_t *temp    = s->scratchbuf;\n\n\n\n            if (s->pb.buf_end - s->pb.buf -\n\n                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            s->m.mb_x = x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_I ||\n\n                (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                 CANDIDATE_MB_TYPE_INTRA)) {\n\n                for (i = 0; i < 6; i++)\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],\n\n                                  7 * 32);\n\n                if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0] = vlc[1] * lambda;\n\n                }\n\n                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,\n\n                                         5, 64, lambda, 1);\n\n                for (i = 0; i < 6; i++) {\n\n                    count[0][i] = put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            } else\n\n                score[0] = INT_MAX;\n\n\n\n            best = 0;\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                    CANDIDATE_MB_TYPE_INTER) {\n\n                    for (i = 0; i < 6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],\n\n                                      7 * 32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n\n\n                    s->m.pb = s->reorder_pb[5];\n\n                    mx      = motion_ptr[0];\n\n                    my      = motion_ptr[1];\n\n                    assert(mx     >= -32 && mx     <= 31);\n\n                    assert(my     >= -32 && my     <= 31);\n\n                    assert(pred_x >= -32 && pred_x <= 31);\n\n                    assert(pred_y >= -32 && pred_y <= 31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5] = s->m.pb;\n\n                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);\n\n\n\n                    dxy = (mx & 1) + 2 * (my & 1);\n\n\n\n                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,\n\n                                                   ref + (mx >> 1) +\n\n                                                   stride * (my >> 1),\n\n                                                   stride, 16);\n\n\n\n                    score[1] += encode_block(s, src + 16 * x, temp + 16,\n\n                                             decoded, stride, 5, 64, lambda, 0);\n\n                    best      = score[1] <= score[0];\n\n\n\n                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,\n\n                                              stride, 16);\n\n                    score[2] += vlc[1] * lambda;\n\n                    if (score[2] < score[best] && mx == 0 && my == 0) {\n\n                        best = 2;\n\n                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for (i = 0; i < 6; i++)\n\n                            count[2][i] = 0;\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if (best == 1) {\n\n                    for (i = 0; i < 6; i++) {\n\n                        count[1][i] = put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                } else {\n\n                    motion_ptr[0]                      =\n\n                    motion_ptr[1]                      =\n\n                    motion_ptr[2]                      =\n\n                    motion_ptr[3]                      =\n\n                    motion_ptr[0 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[1 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[2 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for (i = 5; i >= 0; i--)\n\n                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],\n\n                                 count[best][i]);\n\n            if (best == 0)\n\n                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n        }\n\n        s->m.first_slice_line = 0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4062, "substitutes": {"s": ["ls", "c", "p", "es", "n", "ses", "set", "gets", "its", "ports", "cs", "spec", "h", "gs", "sb", "os", "so", "a", "south", "stats", "sv", "vs", "ers", "ds", "qs", "m", "ants", "less", "ex", "bs", "ims", "bis", "ties", "bes", "hs", "ar", "sts", "ins", "states", "sq", "self", "S", "l", "ss", "sl", "comm", "https", "views", "ns", "sw", "ms", "ts", "changes", "v", "ops", "sys", "is", "g", "times", "r", "fs", "aws", "ps", "parts", "js", "w", "e", "as", "sports", "rs", "ats", "t"], "plane": ["ide", "age", "face", "ane", "code", "flow", "mask", "port", "p", "slice", "window", "plot", "mode", "panel", "profile", "pe", "clip", "plate", "fl", "board", "planes", "buffer", "angle", "frame", "line", "pose"], "src_plane": ["srclysource", "rc_plane", "rc_source", "src_source", "rc_cube", "srclycube", "src_planes", "srclyplane", "src_cube", "rc_planes", "srclyplanes"], "ref_plane": ["ref__panel", "REF_mate", "REF___line", "REF___mate", "ref_line", "ref___frame", "imglyframe", "reflyframe", "ref___gate", "ref_gate", "ref__gate", "imglygate", "ref___panel", "refptline", "refptplane", "ref_planes", "refptplanes", "REF___plane", "ref_frame", "REF_planes", "imglypanel", "REF___planes", "REF_plane", "ref___mate", "REF_line", "reflypanel", "imglyplane", "img_panel", "reflyplane", "ref___plane", "img_plane", "ref_mate", "img_frame", "ref__frame", "reflygate", "img_gate", "ref__plane", "ref___planes", "ref___line", "ref_panel", "refptmate"], "decoded_plane": ["decoded_flat", "decoded_mode", "decode_flat", "decode_plane", "decoded___planes", "decoded_planes", "decode_mode", "decodedatedflat", "decode_planes", "decodedatedplane", "decoded___flat", "decodedatedmode", "decoded___plane", "decodedatedplanes", "decoded___mode"], "height": ["how", "image", "id", "ty", "zh", "size", "high", "bottom", "axy", "Height", "host", "view", "gravity", "style", "resolution", "window", "power", "rank", "holes", "table", "html", "above", "weight", "volume", "shape", "hei", "history", "SIZE", "buffer", " heights", "show", "radius", "background", "range", "depth", "angle", "ows", "padding", "h", "hash", "hang", "stroke", "dim", "grow", "quality", "th", "capacity", "density", "length", "gh", "ht"], "src_stride": ["src_slide", "src_bride", "src_sline", "src_trider", "src_slride", "src_strride", "src_strine", "src_strider", "src_slider", "src_trride", "src_trine", "src_brider", "src_brride", "src_tride", "src_brine"], "stride": ["StrIDE", "strider", "Strider", "Strime", "divide", "slided", "strided", "sprIDE", "brime", "arrIDE", "divided", "Stride", "decider", "slIDE", "Strride", "arrride", "sprride", "strIDE", "decime", "bride", "decide", "sprider", "brride", "slider", "arrided", "arride", "brider", "arrider", "decride", "divider", "divIDE", "strime", "strride", "spride", "slide"], "f": ["fp", "data", "d", "fw", "fc", "ff", "l", "c", "p", "of", "fa", "xf", "inf", "fac", "fu", "sf", "fab", "m", "fg", "b", "aff", "lf", "fs", "form", "full", "elf", "ft", "def", "tf", "foreign", "fl", "ef", "fi", "cf", "rf", "w", "e", "df", "fe", "fr", "F", "fb", "v", "frame", "h", "field", "fen", "bf", "t", "feat", "fff", "fm", "uf", "fo", "fd"], "x": ["fx", "l", "p", "dx", "r", "xs", "coord", "m", "ox", "lat", "tx", "pos", "ex", "xy", "w", "px", "rx", "ix", "v", "o", "col", "a", "X"], "y": ["ty", "axy", "yl", "p", "iy", "py", "cy", "ym", "yt", "sy", "m", "b", "ey", "yr", "xy", "t", "ch", "e", "Y", "yy", "o", "ny", "yi", "a"], "i": ["j", "id", "l", "ii", "c", "p", "iy", "n", "pi", "r", "index", "li", "ci", "m", "b", "phi", "it", "ij", "k", "e", "v", "mi", "h", "di", "I", "si", "t"], "block_width": ["block_work", "block_write", " block_Width", "mb_work", " block_work", "block12Width", "blockLwidth", " block_flow", "mb_write", "blockLWidth", "block12flow", "block12work", "block12width", "blockLwork", "row_width", "block_Width", "row_height", "mb_width", "blocklexwrite", "block_flow", "block_length", "row_length", "blockLflow", "blocklexwidth", "blocklexwork"], "block_height": ["line_density", "block_window", "block10height", "block10width", "line_window", " block_resolution", " block_capacity", "block10capacity", " block_length", "block_capacity", "block_ty", " block_ty", "line_height", "line_ty", "block10resolution", "block_length", "block_density", "block_resolution"], "level": ["stack", "user", "lvl", "le", "l", "goal", "high", "code", "status", "key", "po", "L", "layer", "limit", "cost", "all", "n", "index", "order", "broad", "open", "mode", "kl", "lo", "counter", "where", "load", "family", "pe", "volume", "zero", "type", "module", "Level", "variable", "scope", "tag", "call", "local", "block", "k", "e", "role", "levels", "pl", "show", "len", "ind", "go", "priority", "print", "what", "scale", "v", "depth", "frame", "low", "loop", "angle", "val", "pass", "vel", "VEL", "quality", "prop", "point", "state", "stage", "length", "episode"], "threshold": ["hasholerance", "shail", "shreshold", "hashresh", "Threshold", "cholerance", "tholerance", "thilt", " thresh", "thsresh", "THhold", "thhold", "THolerance", "shensor", "shresh", "thafety", "thsilt", "thsreshold", "shhold", "hashreshold", "chreshold", "shilt", "ethhold", "THresh", "Thhold", "thresh", "Thresh", "thensor", "ethafety", "ethreshold", " thafety", " thhold", "Thail", "THafety", "thail", "THilt", "chresh", "chhold", "ethresh", "hashhold", "thsensor", "THreshold", "THensor", "THail"], "src": ["sys", "input", "inst", "ctr", "tmp", "buf", "source", "img", "sup", "r", "dist", "sc", "cur", "iv", "trans", "ptr", "buffer", "stream", "comp", "str", "dest", "rl", "loc", "rc", "sb", "st", "th", "tr"]}}
{"project": "FFmpeg", "commit_id": "39f01e346cab464ef6c0d4ec58cc13b7123e60d8", "target": 1, "func": "static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             int is_extradata)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    AVBufferRef *buf = NULL;\n\n    int size = 0;\n\n    uint8_t *data = (uint8_t *)\"\";\n\n    uint8_t *start;\n\n    int ret = 0;\n\n\n\n    if (avpkt->size) {\n\n        if (avpkt->buf) {\n\n            buf = av_buffer_ref(avpkt->buf);\n\n            size = avpkt->size;\n\n            data = avpkt->data;\n\n        } else {\n\n            buf = av_buffer_alloc(avpkt->size);\n\n            if (buf) {\n\n                memcpy(buf->data, avpkt->data, avpkt->size);\n\n                size = buf->size;\n\n                data = buf->data;\n\n            }\n\n        }\n\n        if (!buf) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n        if (!is_extradata)\n\n            ctx->packets_sent++;\n\n    } else {\n\n        if (!ctx->packets_sent) {\n\n            // Short-cut the flush logic to avoid upsetting MMAL.\n\n            ctx->eos_sent = 1;\n\n            ctx->eos_received = 1;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    start = data;\n\n\n\n    do {\n\n        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));\n\n        if (!buffer) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n\n\n        buffer->data = data;\n\n        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);\n\n\n\n        if (is_extradata)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;\n\n\n\n        if (data == start)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;\n\n\n\n        data += buffer->length;\n\n        size -= buffer->length;\n\n\n\n        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;\n\n        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;\n\n\n\n        if (!size)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;\n\n\n\n        if (!buffer->length) {\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;\n\n            ctx->eos_sent = 1;\n\n        }\n\n\n\n        if (buf) {\n\n            buffer->ref = av_buffer_ref(buf);\n\n            if (!buffer->ref) {\n\n                av_free(buffer);\n\n                ret = AVERROR(ENOMEM);\n\n                goto done;\n\n            }\n\n        }\n\n\n\n        // Insert at end of the list\n\n        if (!ctx->waiting_buffers)\n\n            ctx->waiting_buffers = buffer;\n\n        if (ctx->waiting_buffers_tail)\n\n            ctx->waiting_buffers_tail->next = buffer;\n\n        ctx->waiting_buffers_tail = buffer;\n\n    } while (size);\n\n\n\ndone:\n\n    av_buffer_unref(&buf);\n\n    return ret;\n\n}\n", "idx": 4064, "substitutes": {"avctx": ["AVcontext", "AVcc", "avconn", "avectx", " avkit", "cvkit", "afcc", "aveconn", "afctx", "AVconn", "avkit", " avcontext", "AVctx", "cvcontext", "avcontext", "afconn", "avcc", "avecontext", "afcontext", " avconn", "cvconn", " avcc", "avekit", "cvctx"], "avpkt": [" avpct", "avpck", "avPnt", "compkt", "iverpkt", "avpyman", "avpatchkt", "wavpadwk", "abwpkg", "averpkt", "iverpaywp", "avpayac", "avppkl", "avnpnt", "avpidkt", "avpadConn", "avercpkg", "avpConn", "avpodacket", "avpatt", "avparkg", "avcpkg", "wavwpwk", "avpidwk", "avpvc", "iverpaykt", "avwpck", "avparmsg", "avppacket", "avpkgwk", "avpatck", "wavwpkg", "avpwk", "avparmk", "avpakl", "ravpodacket", "avercpacket", "avwpdu", "avpkgdu", "avpadtt", "avparConn", "avpdu", "avpwp", "avpodkt", "avnpft", "ravpodnton", "evpkg", "abwpacket", "avppct", "avpervc", "avperkt", "avpkgkg", "avcpac", "avtpacket", "avpykt", "avpkg", "avcpck", "wavcpck", "avppnt", "avppmk", "wavpck", "avpatvc", "avpacket", "wavwpkt", " avPct", "avptt", "wavpwk", "iverpaykl", "avpwd", "avpatchnton", "comwpacket", "avparwk", "avppkg", "avvcht", "avvkg", "averpkg", "avtpck", "avpkl", "avpadmk", "iverpwp", "avwpkl", "avperck", "ravpnton", "avwpcmd", "avercpkt", "avwpvc", "wavcpkg", "avpercht", "avpodnton", "avpac", "avwpkg", "avpidmk", "wavpadkg", "comwpkt", "avpyk", "avpnton", "abpacket", "avpaddu", " avpft", "ajpadwd", "ajpwd", "averpacket", "ravpodmk", "avpaykg", "ajpadmsg", "avercpac", "ravpodkt", "avpman", "avpaykl", " avPft", "avpconn", "compck", "avpkgkt", "aveptt", "avercpcht", "wavpkt", "avpnt", "avnpct", " avpnt", "avwpacket", "avpakt", "avjpConn", " avPkt", "abwpkt", "avppcmd", "evpkt", "avpadacket", "evpkl", "avcpcht", "avwpman", "avcpacket", "avpatacket", "avercpconn", "avepman", "ajpmsg", "avpatchacket", "evppkl", "ajpadConn", "ravpacket", "wavpkg", "avpkgkl", "avewpkt", "compacket", "abptt", "avpk", "avewptt", "avpawp", "avjpmsg", "wavcpacket", "avppac", "averpac", "evpcmd", "avcpconn", "avwpkt", "avperacket", "iverpkl", "evppkt", "avpaman", "avppkt", "avPct", "avtpkg", "avpkgcmd", "avpadkt", "avpaywp", "ajpConn", "avperconn", "wavpdu", "avppnton", "ravpkt", "avpmk", "avpct", "ajpkt", "avpertt", "avpatkt", "ajpadkt", "avpadmsg", "wavpmk", "avparacket", "abpkt", "avwpwk", "wavpadmk", "avpodmk", "abpkg", "avpadwk", "avpakg", "avwpk", "compvc", "iverpkg", "avwptt", "avPft", "avpak", "avewpk", "avpft", "avpayacket", "evppkg", "avpatchmk", "averpconn", "abwptt", "avjpwd", "avpmsg", "wavwpdu", "wavpacket", "avpidkg", "avpadwd", "avewpman", "ravpmk", "evppcmd", "avjpkt", "avparck", "avtpkt", "avparwd", "avperkg", "avpytt", " avPnt", "iverpaykg", "avcpkt", "avpaykt", "comwpvc", "wavpadkt", "avppft", "avnpkt", "avparkt", "avvkt", "avpadkg", "comwpck", "averpcht", "avepkt", "avpcmd", "avpcht", "avPkt", "wavcpkt", "avwpwp", "avepk", "avvconn"], "is_extradata": ["is_extracada", "is_extribaton", "is_xtradATA", "is_xtracatum", "is_extributedaton", "is_xtracATA", "is_extributedATA", "is_extranATA", "is_extractATA", "is_extractada", "is_extradaton", "is_xtradatum", "is_extrenday", "is_extranaton", "is_extributedict", "is_xtraday", "is_extractata", "is_extrendada", "is_extranata", "is_extribatum", "is_extracatum", "is_extribata", "is_xtracata", "is_extribATA", "is_extributedata", "is_xtradada", "is_extraday", "is_extradada", "is_xtradaton", "is_extracATA", "is_extradict", "is_extrendata", "is_extracata", "is_extracict", "is_xtracict", "is_xtradict", "is_extranict", "is_extradatum", "is_extracay", "is_extradATA", "is_extranatum", "is_xtracay", "is_xtracaton", "is_xtracada", "is_extracaton", "is_extrendATA", "is_extractay", "is_xtradata"], "ctx": ["doc", "sys", "j", "cp", "ctrl", "cas", "fc", "func", "tmp", "addr", "xc", "bc", "nc", "unc", "conn", "ref", "hw", "np", "txt", "iac", "cfg", "crit", "comm", "cb", "act", "tx", "info", "etc", "tm", "req", "cmp", "tz", "config", "kw", "conf", "ctl", "cf", "desc", "cv", "context", "cam", "setup", "comp", "exec", "pkg", "gc", "rt", "loc", "abc", "cc", "nt", "fee", "wx", "ct", "cmd", "resp", "timeout", "ac", "lc", "mem", "tc", "jac", "obj", "buff"], "buf": ["cp", "usr", "ff", "env", "tmp", "fam", "init", "window", "bp", "iter", "var", "fg", "pg", "opt", "conf", "cap", "cam", "nom", "pkg", "bo", "queue", "agg", "mem", "br", "batch", "bc", "bh", "next", "conv", "np", "box", "cb", "rb", "ready", "bs", "ptr", "mk", "quit", "foo", "rev", "loc", "max", "tr", "uf", "obj", "aux", "fun", "ref", "fac", "ah", "cache", "cur", "gen", "block", "err", "pool", "bin", "fb", "urg", "src", "rc", "map", "cmd", "proc", "alloc", "roller", "temp", "prop", "func", "arr", "img", "txt", "cfg", "b", "orig", "vec", "desc", "cv", "callback", "abb", "Buffer", "good", "bl", "pub", "Buff", "t", "tc", "buff"], "data": ["id", "format", "step", "height", "p", "n", "init", "window", "read", "out", "options", "load", "form", "off", "zero", "time", "output", "version", "partial", "bytes", "done", "ret", "timeout", "mem", "a", "batch", "d", "Data", "message", "key", "count", "next", "text", "meta", "result", "sequence", "msg", "end", "name", "offset", "padding", "rel", "items", "not", "length", "json", "device", "size", "addr", "before", "to", "ref", "index", "send", "action", "memory", "dat", "info", "cache", "type", "pad", "dev", "ns", "error", "flags", "bin", "empty", "ata", "address", "results", "date", "len", "map", "image", "add", "value", "no", "DATA", "package", "debug", "mode", "table", "pos", "def", "mu", "content", "video", "bits", "raw", "t", "area"], "start": ["d", "id", "head", "add", "tmp", "size", "key", "shift", "addr", "count", "step", "starting", "next", "p", "before", "to", "seek", "init", "from", "read", "index", "open", "set", "send", "wind", "part", "pos", "new", "info", "entry", "it", "time", "stop", "t", "end", "name", "origin", " offset", "first", "len", "Start", "offset", "address", "started", "st", "begin", "art", "length", "sp"], "packets_sent": ["packets_send", "packet_sent", "packets___received", "packet_received", "packets_used", "packets___send", "packes_sent", "packes_received", "packets__received", "packets___sent", "packets_received", "packets__sent", "packet_send", "packet_used", "packets__send", "packes_send", "packets__used"], "buffer": ["interface", "uffer", "match", "window", "server", "iter", "menu", "set", "page", "bar", "context", "queue", "console", "wrapper", "channel", "program", "binary", "timeout", "mem", "socket", "batch", "message", "head", "row", "result", "pb", "sequence", "filter", "bolt", "ptr", "frame", "position", "button", "database", "length", "uf", "byte", "document", "builder", "device", "directory", "record", "seek", "index", "tree", "engine", "memory", "header", "FFER", "cache", "entry", "type", "block", "timer", "comment", "append", "loop", "map", "stack", "face", "temp", "func", "txt", "table", "pack", "profile", "config", "writer", "tar", "command", "callback", "reference", "Buffer", "bridge", "store", "tc", "buff"]}}
{"project": "FFmpeg", "commit_id": "969267482de97b08503d27d2fe090ec820273e40", "target": 1, "func": "static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)\n\n{\n\n    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;\n\n    AVCodecContext          *avctx = ost->st->codec;\n\n    int ret;\n\n\n\n    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||\n\n        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))\n\n        pkt->pts = pkt->dts = AV_NOPTS_VALUE;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {\n\n        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);\n\n        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {\n\n            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt->dts, max);\n\n            pkt->pts = pkt->dts = max;\n\n\n\n\n\n    /*\n\n     * Audio encoders may split the packets --  #frames in != #packets out.\n\n     * But there is no reordering, so we can limit the number of output packets\n\n     * by simply dropping them here.\n\n     * Counting encoded video frames needs to be done separately because of\n\n     * reordering, see do_video_out()\n\n     */\n\n    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {\n\n        if (ost->frame_number >= ost->max_frames) {\n\n            av_free_packet(pkt);\n\n            return;\n\n\n        ost->frame_number++;\n\n\n\n\n    while (bsfc) {\n\n        AVPacket new_pkt = *pkt;\n\n        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,\n\n                                           &new_pkt.data, &new_pkt.size,\n\n                                           pkt->data, pkt->size,\n\n                                           pkt->flags & AV_PKT_FLAG_KEY);\n\n\n\n\n\n\n\n\n\n\n\n        if (a > 0) {\n\n            av_free_packet(pkt);\n\n            new_pkt.destruct = av_destruct_packet;\n\n        } else if (a < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Failed to open bitstream filter %s for stream %d with codec %s\",\n\n                   bsfc->filter->name, pkt->stream_index,\n\n                   avctx->codec ? avctx->codec->name : \"copy\");\n\n            print_error(\"\", a);\n\n            if (exit_on_error)\n\n                exit_program(1);\n\n\n        *pkt = new_pkt;\n\n\n\n        bsfc = bsfc->next;\n\n\n\n\n    pkt->stream_index = ost->index;\n\n    ret = av_interleaved_write_frame(s, pkt);\n\n    if (ret < 0) {\n\n        print_error(\"av_interleaved_write_frame()\", ret);\n\n        exit_program(1);\n\n", "idx": 4070, "substitutes": {"s": ["sys", "ls", "ec", "S", "stats", "status", "c", "is", "ss", "p", "es", "n", "r", "server", "ses", "set", "ds", "fs", "aws", "ps", "its", "js", "ns", "bs", "ser", "w", "ts", "cs", "spec", "sports", "name", "ctx", "hs", "sts", "v", "rs", "o", "h", "cmd", "gs", "ats", "st", "os", "sq", "t", "socket", "a", "obj", "self", "sn"], "pkt": ["cnt", "Pett", "cpett", "ptxt", "nkg", " pett", " ptx", "prekt", "paykt", "nkt", "pett", " pcmd", " ptxt", "upkt", "spkt", "cpnt", "ppkt", "ncmd", "uptxt", "pingkg", "Pct", "pent", "wkg", "pkg", "spacket", "wptx", "respqt", " pqt", " pnt", "ppmit", "wkt", "spet", "Pqt", "wacket", "cpacket", "upacket", "paymit", "Packet", "patchnt", "pingkt", "Pkw", "wpkg", "wtxt", "payacket", "cett", "prkt", "ckt", "pkw", "Pkt", "payett", "packet", "pct", "ppwk", "patchkw", "pnt", "pingacket", "pqt", "nnt", "ppet", "cacket", "respacket", "ppacket", "ppett", "wpnt", "prtx", "cpet", "cpent", "pingnt", "patchacket", " pet", "pptx", "Pcmd", "Pcht", "ppnt", "upkg", "wpkt", " pkg", "patchkt", "Pet", "pingcht", "pwk", "Pnt", "cpcmd", "pinget", "pracket", "cpkt", "respnt", "pcht", "spent", "ppct", "Pkg", " pct", "pcmd", " pkw", "prekg", " pent", " pwk", "upct", "upwk", "respkt", " packet", "prect", "prent", "pret", "pet", "cpkg", " pcht", "cpmit", "Ptx", "pmit", "ptx"], "ost": ["mt", "usr", "OST", "oid", "ty", "ori", "drm", "rob", "onet", "server", "yt", "oster", "http", "hop", "ous", "ora", "console", "est", "ot", "os", "vest", "tto", "list", "htt", "ast", "vs", "ox", "ist", "ott", "sts", "nt", "ocr", "osta", "wp", "ond", "rest", "host", " nost", "ust", "ord", "that", "ctx", "ob", "or", "od", "irst", "src", "oo", "hess", "the", "ops", "proc", "sys", "ocol", "et", "stone", "tt", "utt", "org", "boost", "bott", "ird", "be", "obs", "rost", "tz", "oc", "oss", "ort", "via", "rt", "post", "o", "st", "store", "oad", "rog", "omp", "news"], "bsfc": ["jscc", "gspc", "csfc", "jscf", "ubscf", "lbsfn", "BStc", "gscf", "jslc", "BSfn", "lbscf", "bsFC", "bstc", "ascc", "gsfc", "lbsfc", "bslc", "bispc", "bitstc", "bspc", "cscc", "bscc", "bitsfn", "ascf", "biscf", "ubsFC", "bsfn", "bitscf", "BSfc", "cscf", "jsfc", "lbstc", "bitsfc", "ubsfc", "cslc", "aslc", "ubspc", "gsFC", "bisfc", "bscf", "asfc", "bisFC", "BScf"], "avctx": ["averpkg", "avctl", "avergc", "avcomp", "vertx", "ravjac", "avectx", "avercf", "varhw", "camsys", " avcmp", "avsys", "avectl", " avctl", "aversys", "avtx", " avcf", "avercomp", " avgc", "wavcf", "verctl", "avercontext", "avjac", "camgc", "avertx", "avejac", "camcmp", "avepkg", "avercmp", "varcmp", "avegc", "wavctl", "avetx", "averctl", "avkw", " avcomp", " avtx", "averhw", "aveca", " avca", " avpkg", "avca", " avcontext", "avehw", "wavctx", "verctx", "wavcontext", "camctx", "avgc", "averjac", " avjac", "ravcomp", "ravcmp", "verkw", "avekw", "averkw", "avcontext", "avpkg", "avcf", "avecontext", "varkw", "avecmp", "varctx", "varca", "varjac", " avsys", "avhw", "avcmp", "averctx", "vargc", "ravctx"], "ret": ["RET", " res", " red", "no", " arg", " ans", " RET", " continued", " tv", " resp", "gt", " ok", "Ret", " Ret", "ed", " buff", " ma", " sa", " real", " total", "val", " mem", " reply", " alt", " af", "len"], "frame_number": ["frames_number", "frames_index", " frame_no", "frame__number", "frame_counter", "frameenindex", "frame__counter", "frame_index", " frame_counter", "frame_no", "frameenno", "frames_counter", "frames_no", "frameencounter", "frame__no", "frameennumber"]}}
{"project": "qemu", "commit_id": "14fe292d86da90b79e2fb56a4986d27346339a00", "target": 1, "func": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n", "idx": 4080, "substitutes": {"l2_cache": ["l2ycache", "l52_hash", "l1_depth", "l2_module", "l2ycover", "l2xtable", "l2_comment", "l4_table", "l2grdepth", "l52_cover", "ltwoptmap", "l3_Cache", "l1_module", "l2_Cache", "l2xcache", "l4_chain", "l2_session", "l1_cover", "l4_report", "l2_hash", "ltwopttable", "l2cacheCache", "l2cachecache", "l2pttable", "l2pycache", "l1_cache", "ltwo_parse", "l1_table", "l2_report", "l3_table", "l2ytable", "l2tcache", "l2tparse", "l2grtable", "l2grcache", "l2_map", "l2ymodule", "l2pychain", "l2dbcache", "l2tchain", "l2grCache", "l2pycover", "l4_cache", "ltwoptcache", "l2dbcover", "ltwoptparse", "l4_parse", "l2ptcache", "l3_comment", "l2dbtable", "l52_chain", "l2dbmodule", "l2ptmap", "l2cachecomment", "l2cachetable", "l2xreport", "l2_parse", "l1_Cache", "l3_cache", "ltwo_cache", "l2ptparse", "l2_cover", "l2_chain", "l4_session", "ltwo_table", "l2_depth", "l52_cache", "ltwo_map", "l2pyhash"], "l2_table": ["l2_page", "l3_tree", "l2__tab", "l2Tplain", "l2_stable", "l02_cache", "l2__table", "l3_cache", "l2_entity", "l2_tree", "l3_entity", "l3_plain", "l2_plain", "l02_table", "l2TTABLE", "l2_tab", "l02_stable", "l2Tentity", "l2__cache", "l3_TABLE", "l2Ttable", "l02_tree", "l2__tree", "l2_TABLE", "l3_tab", "l3_page", "l3_table"], "entry": ["id", "try", "tmp", "match", "rent", "ent", "node", "server", "set", "see", "ENT", "needed", "form", "ence", "xml", "ry", "channel", "equal", "enter", "line", "q", "inner", "key", "list", "row", "element", "result", "link", "ready", "ce", "valid", "check", "zip", "cell", "entity", "search", "member", "offset", "nt", "byte", "ace", "slot", "record", "child", "index", "info", "shot", "comment", "attribute", "existent", "office", "insert", "or", "address", "se", "card", "inter", "image", "add", "instance", "way", "import", "query", "table", "delete", "ary", "Entry", "ie", "e", "ment", "escape", "field", "RY", "event"], "n_entries": ["nappingendries", "nappingentries", "n_ntlements", "nappingentents", "nappingendents", "n_sentires", "nappingendants", "n_ntents", "n_Entries", "n_curriers", "n_contents", "n_contry", "n_curires", "n_contries", "n_Entry", "n_endants", "n_ntants", "n_entents", "n_entires", "n_contlements", "n_conties", "n_contities", "n_entriers", "n_endents", "n_enties", "n_sentriers", "n_ntries", "n_Entities", "n_sentities", "n_Enties", "nappingentants", "n_curries", "n_senties", "n_ENTries", "n_endlements", "n_entities", "nappingentlements", "n_entants", "n_ENTriers", "n_ENTies", "n_sentries", "n_sentry", "n_ENTires", "n_endries", "n_entlements", "n_curies", "nappingendlements", "n_contants", "n_entry"]}}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,\n\n                                     AVCodecContext *avctx,\n\n                                     unsigned high_bit_depth)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_mmx;\n\n\n        c->diff_pixels = ff_diff_pixels_mmx;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_sse2;\n\n\n        c->diff_pixels = ff_diff_pixels_sse2;\n\n    }\n\n}", "idx": 4091, "substitutes": {"c": ["ec", "d", "cp", "fc", "cr", "l", "pc", "bc", "p", "conv", "cal", "dc", "ca", "ci", "m", "x", "ce", "C", "cont", "sc", "etc", "cache", "cmp", "can", "config", "conf", "ch", "cf", "cv", "e", "cam", "tc", "cs", "ctx", "comp", "con", "co", "gc", "enc", "coll", "anc", "container", "v", "abc", "cu", "cc", "ct", "f", "rc", "cm", "lc", "ac", "t", "mc"], "avctx": ["AVcontext", "avecontext", "AVcc", " avcontext", " avcfg", "avectx", "avcfg", "AVctx", " avcc", "avecfg", "avecc", "AVcfg", "avcontext", "avcc"], "high_bit_depth": ["high_byte_driven", "high_bitnessdist", "high_byte_depth", "high_byte_level", "high_byte_height", "high_bitingheight", "high_bits_deep", "high_bit_height", "high_bit_level", "high_bitnessdepth", "high_bit_deep", "high_byte_deep", "high_bits_dist", "high_byte_weight", "high_bitnessdistance", "high_bit_distance", "high_bitingdriven", "high_bits_distance", "high_bitingdepth", "high_bit_driven", "high_bits_depth", "high_bit_dist", "high_bitingdeep", "high_bit_weight", "high_bitnessdeep"]}}
